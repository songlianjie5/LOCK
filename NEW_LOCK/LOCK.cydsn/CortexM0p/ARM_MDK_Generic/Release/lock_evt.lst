L 1 "Modules\Lock\lock_evt.c"
N/**
N  ******************************************************************************
N  * @file         lock_evt.c
N  * @brief        锁体延时事件管理，实现精确无阻塞延时执行某个事件
N  * @author       Fli
N  * @date         2018-06-22
N  * @version      v001
N  * @copyright    kaadas
N  * 
N  * @note         凯迪仕・智能锁
N  *
N  ******************************************************************************
N  */
N#include "lock_evt.h"
L 1 "Modules\Lock\lock_evt.h" 1
N/**
N  ******************************************************************************
N  * @file         lock_evt.h
N  * @brief        与lock_evt.c对应的头文件
N  * @author       Fli
N  * @date         2018-06-22
N  * @version      v001
N  * @copyright    kaadas
N  * 
N  * @note         凯迪仕・智能锁
N  *
N  ******************************************************************************
N  */
N#ifndef __LOCK_EVT_H__
N#define __LOCK_EVT_H__
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#include "main.h"
L 1 ".\main.h" 1
N/* ========================================
N *
N * Copyright YOUR COMPANY, THE YEAR
N * All Rights Reserved
N * UNPUBLISHED, LICENSED SOFTWARE.
N *
N * CONFIDENTIAL AND PROPRIETARY INFORMATION
N * WHICH IS THE PROPERTY OF your company.
N *
N * ========================================
N*/
N#ifndef _MAIN_H_
N#define _MAIN_H_
N
N#include "stdio.h"
L 1 "D:\Keil_v5\ARM\ARMCC\bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060019
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 16 ".\main.h" 2
N#include "stdlib.h"
L 1 "D:\Keil_v5\ARM\ARMCC\bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 17 ".\main.h" 2
N#include "stdint.h"
L 1 "D:\Keil_v5\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 180721 $
N * Checkin $Date: 2013-06-24 09:41:57 +0100 (Mon, 24 Jun 2013) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5040049
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 18 ".\main.h" 2
N#include "stdbool.h"
L 1 "D:\Keil_v5\ARM\ARMCC\bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060019
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 19 ".\main.h" 2
N     
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
Ntypedef enum {LOW = 0, HIGH = !LOW}PinLevel ;
N    
N#include "Function.h"  
L 1 ".\Modules\Function\Function.h" 1
N/* ========================================
N *
N * Copyright YOUR COMPANY, THE YEAR
N * All Rights Reserved
N * UNPUBLISHED, LICENSED SOFTWARE.
N *
N * CONFIDENTIAL AND PROPRIETARY INFORMATION
N * WHICH IS THE PROPERTY OF your company.
N *
N * ========================================
N*/
N#ifndef _FUNCTION_H_
N#define _FUNCTION_H_
N    
N#include "main.h" 
L 1 ".\main.h" 1
N/* ========================================
N *
N * Copyright YOUR COMPANY, THE YEAR
N * All Rights Reserved
N * UNPUBLISHED, LICENSED SOFTWARE.
N *
N * CONFIDENTIAL AND PROPRIETARY INFORMATION
N * WHICH IS THE PROPERTY OF your company.
N *
N * ========================================
N*/
N#ifndef _MAIN_H_
S#define _MAIN_H_
S
S#include "stdio.h"
S#include "stdlib.h"
S#include "stdint.h"
S#include "stdbool.h"
S     
Stypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
Stypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
Stypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
Stypedef enum {LOW = 0, HIGH = !LOW}PinLevel ;
S    
S#include "Function.h"  
S#include "List.h"
S#include "Tuch.h"
S#include "Display.h"
S#include "Rtc.h"
S#include "Voice.h"
S#include "Card.h"
S#include "Fingerprint.h"
S#include "Bat.h"
S#include "Power.h"
S#include "Led.h"
S#include "SwitchKey.h"
S#include "Lock.h"
S#include "Wdt.h"
S#include "Record.h"
S#include "Extend.h"
S#include "MLock.h"
S    
S#define PLATFORM        
S#define TIME_BASIC_MS 10
S
S#ifdef PLATFORM
S#include "project.h"
S#include "gpio.h"
S#endif
S
S
S
S
N#endif
N/* [] END OF FILE */
L 16 ".\Modules\Function\Function.h" 2
N#include "MenuTips.h"  
L 1 ".\Modules\Function\MenuTips.h" 1
N/* ========================================
N *
N * Copyright YOUR COMPANY, THE YEAR
N * All Rights Reserved
N * UNPUBLISHED, LICENSED SOFTWARE.
N *
N * CONFIDENTIAL AND PROPRIETARY INFORMATION
N * WHICH IS THE PROPERTY OF your company.
N *
N * ========================================
N*/
N#ifndef _MENUTIPS_H_
N#define _MENUTIPS_H_
N
N#include "main.h"
N    
Ntypedef struct   
N{
N  char *Num;
N  char *MenuChinese;
N  char *MenuEnglish;
N  uint16_t SpeakAddr;
N}item_t;
N
Ntypedef struct   
N{
N  char *TipsChinese;
N  char *TipsEnglish;
N  uint16_t SpeakAddr;
N}tips_t;
N
N
Nextern const item_t main_menu[];
Nextern const item_t user_menu[];
Nextern const item_t sys_menu[];
Nextern const item_t record_menu[];
Nextern const item_t ext_menu[];
N
Nextern const item_t Del_menu[];
Nextern const item_t Mode_menu[];
Nextern const item_t Voice_menu[];
Nextern const item_t Language_menu[];
N
Nextern const tips_t TIPS_YZSB;
Nextern const tips_t TIPS_YTCGLMS;
Nextern const tips_t TIPS_QSRYHMMYJHJJS;
Nextern const tips_t TIPS_QSRLWBHYJHJJS;
Nextern const tips_t TIPS_SRCW;
Nextern const tips_t TIPS_MMGYJD;
Nextern const tips_t TIPS_SZSB;
Nextern const tips_t TIPS_SZCG;
Nextern const tips_t TIPS_QCXSR;
Nextern const tips_t TIPS_QNKSZZFYC;
Nextern const tips_t TIPS_QXZWWYDSZ;
Nextern const tips_t TIPS_QXYWWYDSZ;
Nextern const tips_t TIPS_QXSWWYDSZ;
Nextern const tips_t TIPS_QXXWWYDSZ;
Nextern const tips_t TIPS_TJSB;
Nextern const tips_t TIPS_TJCG;
Nextern const tips_t TIPS_SCSB;
Nextern const tips_t TIPS_SCCG;
Nextern const tips_t TIPS_ZWKWK;
Nextern const tips_t TIPS_BHBCZ;
Nextern const tips_t TIPS_KPBCZ;
Nextern const tips_t TIPS_YJRGLMS;
Nextern const tips_t TIPS_YZCG;
Nextern const tips_t TIPS_DLDQGHDC;
Nextern const tips_t TIPS_BHYCZ;
Nextern const tips_t TIPS_ZWYCZ;
Nextern const tips_t TIPS_QSRSZ;
Nextern const tips_t TIPS_GYMS;
Nextern const tips_t TIPS_DYMS;
Nextern const tips_t TIPS_JYMS;
Nextern const tips_t TIPS_XTYSD;
Nextern const tips_t TIPS_SRCWBJ;
Nextern const tips_t TIPS_QSHZS;
Nextern const tips_t TIPS_MMYCZ;
Nextern const tips_t TIPS_MKYCZ;
Nextern const tips_t TIPS_MMCW;
Nextern const tips_t TIPS_MMWX;
Nextern const tips_t TIPS_QZSRYC;
Nextern const tips_t TIPS_QAZW;
Nextern const tips_t TIPS_QSRZWHKP;
Nextern const tips_t TIPS_WTJZW;
Nextern const tips_t TIPS_WSZMM;
Nextern const tips_t TIPS_WTJYHK;
Nextern const tips_t TIPS_QTJGLMM;
Nextern const tips_t TIPS_QSFWM;
Nextern const tips_t TIPS_QCXSK;
Nextern const tips_t TIPS_YHFDCCSZ;
Nextern const tips_t TIPS_ZZHFQSH;
Nextern const tips_t TIPS_QXGGLMM;
Nextern const tips_t TIPS_QAYKQ;
Nextern const tips_t TIPS_QSK;
Nextern const tips_t TIPS_QSRZWHSRLWBHQJHJJS;
Nextern const tips_t TIPS_QSKHSRLWBHYJHJJS;
Nextern const tips_t TIPS_KPKWK;
Nextern const tips_t TIPS_KPKYM;
Nextern const tips_t TIPS_KPYCZ;
Nextern const tips_t TIPS_YQKSYKP;
Nextern const tips_t TIPS_ZWKYM;
Nextern const tips_t TIPS_MMKYM;
Nextern const tips_t TIPS_MMKWK;
Nextern const tips_t TIPS_FZCKS;
Nextern const tips_t TIPS_FQBJ;
Nextern const tips_t TIPS_MSYC;
Nextern const tips_t TIPS_BFBJ;
Nextern const tips_t TIPS_JXYSKM;
Nextern const tips_t TIPS_QSKHAZW;
Nextern const tips_t TIPS_QSRMMHKP;
Nextern const tips_t TIPS_QSRMMHZW;
Nextern const tips_t TIPS_KMJLWK;
Nextern const tips_t TIPS_MM;
Nextern const tips_t TIPS_ZW;
Nextern const tips_t TIPS_KP;
Nextern const tips_t TIPS_JXYC;
Nextern const tips_t TIPS_YKKM;
Nextern const tips_t TIPS_YJKQ;
Nextern const tips_t TIPS_APP;
Nextern const tips_t TIPS_WZLX;
Nextern const tips_t TIPS_QSH;
Nextern const tips_t TIPS_WAQMS;
Nextern const tips_t TIPS_YKYCZ;
Nextern const tips_t TIPS_YKBCZ;
Nextern const tips_t TIPS_YKYPM;
Nextern const tips_t TIPS_ZZSCMM;
Nextern const tips_t TIPS_ZZSCZW;
Nextern const tips_t TIPS_ZZSCKP;
Nextern const tips_t TIPS_ZZSCKMJL;
Nextern const tips_t TIPS_QKM;
Nextern const tips_t TIPS_YGM;
Nextern const tips_t TIPS_LYKQ;
Nextern const tips_t TIPS_LYGB;
Nextern const tips_t TIPS_YQDBF;
Nextern const tips_t TIPS_YFS;
Nextern const tips_t TIPS_YYMS;
Nextern const tips_t TIPS_ZDMS;
Nextern const tips_t TIPS_SDMS;
Nextern const tips_t TIPS_MWSS;
N
Nextern void DisplayTips(const tips_t *tip);
Nextern void DisplayTipsEx(const tips_t *tip,uint8_t y,bool clr);
Xextern void DisplayTipsEx(const tips_t *tip,uint8_t y,_Bool clr);
N#endif
N/* [] END OF FILE */
L 17 ".\Modules\Function\Function.h" 2
N#include "Utilities.h"
L 1 ".\Modules\Function\Utilities.h" 1
N#ifndef _UTILITIES_H
N#define _UTILITIES_H
N#include "main.h"
N    
Nuint8_t KeysMan_MatchKeysLibrary(uint8_t *pData, uint8_t len);
N
N#define PWD_LENGHT_MAX      12		        //瀵澶ч垮害
Nextern bool Pwd_Analyse(uint8_t *pbuf);     //ゆ瀵绠瀵 true涓鸿浜绠
Xextern _Bool Pwd_Analyse(uint8_t *pbuf);     
N    
N#endif
N
L 18 ".\Modules\Function\Function.h" 2
N
Ntypedef enum{
N    MUTE_OFF=0,
N    MUTE_ON=1
N}VOICE_E;
Ntypedef enum{
N    CHN=0,
N    EN=1
N}LANGUAGE_E;
Ntypedef enum{
N    DOOR_NORMAL=0,
N    DOOR_SAVFT=1
N}DOORMODE_E;
N
Ntypedef struct{
N    uint8_t SysSN[16];                                              //
N    uint8_t UserPSW[12];
N    uint8_t ManagePSW[12];
N    VOICE_E Voice;                                                  //璇
N    LANGUAGE_E Language;                                            //璇瑷
N    DOORMODE_E OpenDoorMode;                                        //寮ㄦā寮
N    uint8_t NetStaues;
N}ManageMode_t;
N
N#define DEEPSLEEP_TIME   10000                                      //浣剁＄瓒
N#define USER_PSW_LEN     16                                         //姝ｅ父妯″瀵垮害
N#define MAX_ERRO_TIME    5                                          //澶璇娆℃
Ntypedef struct{ 
N    uint8_t ManagePSW[USER_PSW_LEN];
X    uint8_t ManagePSW[16];
N    bool ALM;                                                       //甯茬舵
X    _Bool ALM;                                                       
N    bool FANG_SUO;                                                  //
X    _Bool FANG_SUO;                                                  
N    bool SYSTEM_LOCK;                                               //绯荤瀹舵
X    _Bool SYSTEM_LOCK;                                               
N    bool BAT_ALM;                                                   //浣甸ヨ
X    _Bool BAT_ALM;                                                   
N}NormalMode_t;
N
Ntypedef struct{
N    uint8_t Option;
N    uint8_t Status;
N}LockMode_t;
N
Ntypedef struct{
N    enum{INIT=0,SLEEP=1,DEEP_SLEEP=2,INT_MODE=3}McuState;           //MCU宸ヤ舵
N    enum{NORMAL_MODE=0,MANAGE_MODE=1,LOCK_MODE=2}workmode;          //戒妯″
N	ManageMode_t ManageMode;                                        //绠＄妯″涓
N    NormalMode_t NormalMode;                                        //姝ｅ父妯″涓
N    LockMode_t LockMode;                                            //瀹妯″涓
N    uint16_t TimeOutCount;                                          //杩ョ＄璁℃
N    bool Wakeup;                                                    //浠＄ら璁
X    _Bool Wakeup;                                                    
N    bool Tick;                                                      //Tick璁
X    _Bool Tick;                                                      
N}Function_t;
N
Nextern void Function_init(void);
Nextern Function_t *Function_status(void);
Nextern void FunctionProcess(void);
Nextern uint8_t ManageMode(void);
Nextern uint8_t NormalMode(void);
Nextern uint8_t LockMode(void);
N    
Nextern void Function_Sleep(void);
Nextern void Function_Wakup(void);
N
N#endif
N/* [] END OF FILE */
L 26 ".\main.h" 2
N#include "List.h"
L 1 ".\Modules\Function\List\List.h" 1
N/* ========================================
N *
N * Copyright YOUR COMPANY, THE YEAR
N * All Rights Reserved
N * UNPUBLISHED, LICENSED SOFTWARE.
N *
N * CONFIDENTIAL AND PROPRIETARY INFORMATION
N * WHICH IS THE PROPERTY OF your company.
N *
N * ========================================
N*/
N#ifndef _LIST_H
N#define _LIST_H
N
N#include "main.h"
N    
Ntypedef struct FunNode {
N	void(*Fun)(void);
N	char *Describe;
N	uint16_t Tick;
N	uint16_t Period;
N	uint16_t RunCount;
N	struct FunNode *Prev;
N	struct FunNode *Next;
N}FunNode_t;
N
N#define BASE_TICK_MS TIME_BASIC_MS                                                                                                          //烘杩琛堕村浣ms
N
Nextern bool RegisterCallback(FunNode_t *pList, void(*callback)(), char *descr, uint16_t TickCount, uint16_t TickTaget, uint16_t RunCount);  //娉ㄥ芥
Xextern _Bool RegisterCallback(FunNode_t *pList, void(*callback)(), char *descr, uint16_t TickCount, uint16_t TickTaget, uint16_t RunCount);  
Nextern bool UnRegisterCallback(FunNode_t *pList, void(*callback)());                                                                        //娉ㄦ芥
Xextern _Bool UnRegisterCallback(FunNode_t *pList, void(*callback)());                                                                        
Nextern bool ListRun(FunNode_t *pList);                                                                                                      //杩琛捐〃
Xextern _Bool ListRun(FunNode_t *pList);                                                                                                      
Nextern bool ListInit(void);                                                                                                                 //濮澶
Xextern _Bool ListInit(void);                                                                                                                 
Nextern FunNode_t List;
N
N/*渚
Nvoid LedTest(void)
N{
N    printf("Led\r\n");
N}
Nvoid TimeTest(void)
N{
N    if(RegisterCallback(&List,LedTest,"Led",0,100,0xFFFF)==false)
N        printf("TimeTest Fail: %d\r\n",__LINE__);
N    else 
N        UnRegisterCallback(&List,TimeTest);             
N}
N
Nvoid main(void)
N{
N    ListInit();
N    RegisterCallback(&List,TimeTest,"Time",0,200,0xFFFF); 
N    while(1)
N    {
N        //call in BASE_TICK_MS
N        ListRun(&List);
N    }
N}
N*/
N#endif
N/* [] END OF FILE */
L 27 ".\main.h" 2
N#include "Tuch.h"
L 1 ".\Modules\Tuch\Tuch.h" 1
N/* ========================================
N *
N * Copyright YOUR COMPANY, THE YEAR
N * All Rights Reserved
N * UNPUBLISHED, LICENSED SOFTWARE.
N *
N * CONFIDENTIAL AND PROPRIETARY INFORMATION
N * WHICH IS THE PROPERTY OF your company.
N *
N * ========================================
N*/
N#ifndef _TUCH_H_
N#define _TUCH_H_
N    
N#include "project.h"
L 1 "Generated_Source\PSoC4\project.h" 1
N/*******************************************************************************
N* File Name: project.h
N* 
N* PSoC Creator  4.2
N*
N* Description:
N* It contains references to all generated header files and should not be modified.
N* This file is automatically generated by PSoC Creator.
N*
N********************************************************************************
N* Copyright (c) 2007-2018 Cypress Semiconductor.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N********************************************************************************/
N
N#include "cyfitter_cfg.h"
L 1 "Generated_Source\PSoC4\cyfitter_cfg.h" 1
N/*******************************************************************************
N* File Name: cyfitter_cfg.h
N* 
N* PSoC Creator  4.2
N*
N* Description:
N* This file provides basic startup and mux configuration settings
N* This file is automatically generated by PSoC Creator.
N*
N********************************************************************************
N* Copyright (c) 2007-2018 Cypress Semiconductor.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N********************************************************************************/
N
N#ifndef CYFITTER_CFG_H
N#define CYFITTER_CFG_H
N
N#include "cytypes.h"
L 1 "Generated_Source\PSoC4\cytypes.h" 1
N/***************************************************************************//**
N* \file cytypes.h
N* \version 5.70
N*
N* \brief CyTypes provides register access macros and approved types for use in
N* firmware.
N*
N* \note Due to endiannesses of the hardware and some compilers, the register
N* access macros for big endian compilers use some library calls to arrange
N* data the correct way.
N*
N* Register Access macros and functions perform their operations on an
N* input of the type pointer to void.  The arguments passed to it should be
N* pointers to the type associated with the register size.
N* (i.e. a "uint8 *" shouldn't be passed to obtain a 16-bit register value)
N*
N********************************************************************************
N* \copyright
N* Copyright 2008-2018, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_BOOT_CYTYPES_H)
X#if !0L
N#define CY_BOOT_CYTYPES_H
N
N#if defined(__C51__)
X#if 0L
S    #include <intrins.h>
N#endif  /* (__C51__) */
N
N/* ARM and C99 or later */
N#if defined(__GNUC__) || defined(__ARMCC_VERSION) || (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L)
X#if 0L || 1L || (1L && 199901L >= 199901L)
N    #include <stdint.h>
N#endif  /* (__GNUC__) || defined(__ARMCC_VERSION) || (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) */
N
N#include "cyfitter.h"
L 1 "Generated_Source\PSoC4\cyfitter.h" 1
N/*******************************************************************************
N* File Name: cyfitter.h
N* 
N* PSoC Creator  4.2
N*
N* Description:
N* 
N* This file is automatically generated by PSoC Creator.
N*
N********************************************************************************
N* Copyright (c) 2007-2018 Cypress Semiconductor.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N********************************************************************************/
N
N#ifndef INCLUDED_CYFITTER_H
N#define INCLUDED_CYFITTER_H
N#include "cydevice_trm.h"
L 1 "Generated_Source\PSoC4\cydevice_trm.h" 1
N/*******************************************************************************
N* File Name: cydevice_trm.h
N* 
N* PSoC Creator  4.2
N*
N* Description:
N* This file provides all of the address values for the entire PSoC device.
N* This file is automatically generated by PSoC Creator.
N*
N********************************************************************************
N* Copyright (c) 2007-2018 Cypress Semiconductor.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N********************************************************************************/
N
N#if !defined(CYDEVICE_TRM_H)
X#if !0L
N#define CYDEVICE_TRM_H
N#define CYDEV_FLASH_BASE 0x00000000u
N#define CYDEV_FLASH_SIZE 0x00020000u
N#define CYREG_FLASH_DATA_MBASE 0x00000000u
N#define CYREG_FLASH_DATA_MSIZE 0x00020000u
N#define CYDEV_SFLASH_BASE 0x0ffff000u
N#define CYDEV_SFLASH_SIZE 0x00000800u
N#define CYREG_SFLASH_PROT_ROW0 0x0ffff000u
N#define CYFLD_SFLASH_DATA8__OFFSET 0x00000000u
N#define CYFLD_SFLASH_DATA8__SIZE 0x00000008u
N#define CYREG_SFLASH_PROT_ROW1 0x0ffff001u
N#define CYREG_SFLASH_PROT_ROW2 0x0ffff002u
N#define CYREG_SFLASH_PROT_ROW3 0x0ffff003u
N#define CYREG_SFLASH_PROT_ROW4 0x0ffff004u
N#define CYREG_SFLASH_PROT_ROW5 0x0ffff005u
N#define CYREG_SFLASH_PROT_ROW6 0x0ffff006u
N#define CYREG_SFLASH_PROT_ROW7 0x0ffff007u
N#define CYREG_SFLASH_PROT_ROW8 0x0ffff008u
N#define CYREG_SFLASH_PROT_ROW9 0x0ffff009u
N#define CYREG_SFLASH_PROT_ROW10 0x0ffff00au
N#define CYREG_SFLASH_PROT_ROW11 0x0ffff00bu
N#define CYREG_SFLASH_PROT_ROW12 0x0ffff00cu
N#define CYREG_SFLASH_PROT_ROW13 0x0ffff00du
N#define CYREG_SFLASH_PROT_ROW14 0x0ffff00eu
N#define CYREG_SFLASH_PROT_ROW15 0x0ffff00fu
N#define CYREG_SFLASH_PROT_ROW16 0x0ffff010u
N#define CYREG_SFLASH_PROT_ROW17 0x0ffff011u
N#define CYREG_SFLASH_PROT_ROW18 0x0ffff012u
N#define CYREG_SFLASH_PROT_ROW19 0x0ffff013u
N#define CYREG_SFLASH_PROT_ROW20 0x0ffff014u
N#define CYREG_SFLASH_PROT_ROW21 0x0ffff015u
N#define CYREG_SFLASH_PROT_ROW22 0x0ffff016u
N#define CYREG_SFLASH_PROT_ROW23 0x0ffff017u
N#define CYREG_SFLASH_PROT_ROW24 0x0ffff018u
N#define CYREG_SFLASH_PROT_ROW25 0x0ffff019u
N#define CYREG_SFLASH_PROT_ROW26 0x0ffff01au
N#define CYREG_SFLASH_PROT_ROW27 0x0ffff01bu
N#define CYREG_SFLASH_PROT_ROW28 0x0ffff01cu
N#define CYREG_SFLASH_PROT_ROW29 0x0ffff01du
N#define CYREG_SFLASH_PROT_ROW30 0x0ffff01eu
N#define CYREG_SFLASH_PROT_ROW31 0x0ffff01fu
N#define CYREG_SFLASH_PROT_ROW32 0x0ffff020u
N#define CYREG_SFLASH_PROT_ROW33 0x0ffff021u
N#define CYREG_SFLASH_PROT_ROW34 0x0ffff022u
N#define CYREG_SFLASH_PROT_ROW35 0x0ffff023u
N#define CYREG_SFLASH_PROT_ROW36 0x0ffff024u
N#define CYREG_SFLASH_PROT_ROW37 0x0ffff025u
N#define CYREG_SFLASH_PROT_ROW38 0x0ffff026u
N#define CYREG_SFLASH_PROT_ROW39 0x0ffff027u
N#define CYREG_SFLASH_PROT_ROW40 0x0ffff028u
N#define CYREG_SFLASH_PROT_ROW41 0x0ffff029u
N#define CYREG_SFLASH_PROT_ROW42 0x0ffff02au
N#define CYREG_SFLASH_PROT_ROW43 0x0ffff02bu
N#define CYREG_SFLASH_PROT_ROW44 0x0ffff02cu
N#define CYREG_SFLASH_PROT_ROW45 0x0ffff02du
N#define CYREG_SFLASH_PROT_ROW46 0x0ffff02eu
N#define CYREG_SFLASH_PROT_ROW47 0x0ffff02fu
N#define CYREG_SFLASH_PROT_ROW48 0x0ffff030u
N#define CYREG_SFLASH_PROT_ROW49 0x0ffff031u
N#define CYREG_SFLASH_PROT_ROW50 0x0ffff032u
N#define CYREG_SFLASH_PROT_ROW51 0x0ffff033u
N#define CYREG_SFLASH_PROT_ROW52 0x0ffff034u
N#define CYREG_SFLASH_PROT_ROW53 0x0ffff035u
N#define CYREG_SFLASH_PROT_ROW54 0x0ffff036u
N#define CYREG_SFLASH_PROT_ROW55 0x0ffff037u
N#define CYREG_SFLASH_PROT_ROW56 0x0ffff038u
N#define CYREG_SFLASH_PROT_ROW57 0x0ffff039u
N#define CYREG_SFLASH_PROT_ROW58 0x0ffff03au
N#define CYREG_SFLASH_PROT_ROW59 0x0ffff03bu
N#define CYREG_SFLASH_PROT_ROW60 0x0ffff03cu
N#define CYREG_SFLASH_PROT_ROW61 0x0ffff03du
N#define CYREG_SFLASH_PROT_ROW62 0x0ffff03eu
N#define CYREG_SFLASH_PROT_ROW63 0x0ffff03fu
N#define CYREG_SFLASH_PROT_PROTECTION 0x0ffff0ffu
N#define CYFLD_SFLASH_PROT_LEVEL__OFFSET 0x00000000u
N#define CYFLD_SFLASH_PROT_LEVEL__SIZE 0x00000002u
N#define CYVAL_SFLASH_PROT_LEVEL_VIRGIN 0x00000001u
N#define CYVAL_SFLASH_PROT_LEVEL_OPEN 0x00000000u
N#define CYVAL_SFLASH_PROT_LEVEL_PROTECTED 0x00000002u
N#define CYVAL_SFLASH_PROT_LEVEL_KILL 0x00000003u
N#define CYREG_SFLASH_AV_PAIRS_8B0 0x0ffff100u
N#define CYREG_SFLASH_AV_PAIRS_8B1 0x0ffff101u
N#define CYREG_SFLASH_AV_PAIRS_8B2 0x0ffff102u
N#define CYREG_SFLASH_AV_PAIRS_8B3 0x0ffff103u
N#define CYREG_SFLASH_AV_PAIRS_8B4 0x0ffff104u
N#define CYREG_SFLASH_AV_PAIRS_8B5 0x0ffff105u
N#define CYREG_SFLASH_AV_PAIRS_8B6 0x0ffff106u
N#define CYREG_SFLASH_AV_PAIRS_8B7 0x0ffff107u
N#define CYREG_SFLASH_AV_PAIRS_8B8 0x0ffff108u
N#define CYREG_SFLASH_AV_PAIRS_8B9 0x0ffff109u
N#define CYREG_SFLASH_AV_PAIRS_8B10 0x0ffff10au
N#define CYREG_SFLASH_AV_PAIRS_8B11 0x0ffff10bu
N#define CYREG_SFLASH_AV_PAIRS_8B12 0x0ffff10cu
N#define CYREG_SFLASH_AV_PAIRS_8B13 0x0ffff10du
N#define CYREG_SFLASH_AV_PAIRS_8B14 0x0ffff10eu
N#define CYREG_SFLASH_AV_PAIRS_8B15 0x0ffff10fu
N#define CYREG_SFLASH_AV_PAIRS_8B16 0x0ffff110u
N#define CYREG_SFLASH_AV_PAIRS_8B17 0x0ffff111u
N#define CYREG_SFLASH_AV_PAIRS_8B18 0x0ffff112u
N#define CYREG_SFLASH_AV_PAIRS_8B19 0x0ffff113u
N#define CYREG_SFLASH_AV_PAIRS_8B20 0x0ffff114u
N#define CYREG_SFLASH_AV_PAIRS_8B21 0x0ffff115u
N#define CYREG_SFLASH_AV_PAIRS_8B22 0x0ffff116u
N#define CYREG_SFLASH_AV_PAIRS_8B23 0x0ffff117u
N#define CYREG_SFLASH_AV_PAIRS_8B24 0x0ffff118u
N#define CYREG_SFLASH_AV_PAIRS_8B25 0x0ffff119u
N#define CYREG_SFLASH_AV_PAIRS_8B26 0x0ffff11au
N#define CYREG_SFLASH_AV_PAIRS_8B27 0x0ffff11bu
N#define CYREG_SFLASH_AV_PAIRS_8B28 0x0ffff11cu
N#define CYREG_SFLASH_AV_PAIRS_8B29 0x0ffff11du
N#define CYREG_SFLASH_AV_PAIRS_8B30 0x0ffff11eu
N#define CYREG_SFLASH_AV_PAIRS_8B31 0x0ffff11fu
N#define CYREG_SFLASH_AV_PAIRS_8B32 0x0ffff120u
N#define CYREG_SFLASH_AV_PAIRS_8B33 0x0ffff121u
N#define CYREG_SFLASH_AV_PAIRS_8B34 0x0ffff122u
N#define CYREG_SFLASH_AV_PAIRS_8B35 0x0ffff123u
N#define CYREG_SFLASH_AV_PAIRS_8B36 0x0ffff124u
N#define CYREG_SFLASH_AV_PAIRS_8B37 0x0ffff125u
N#define CYREG_SFLASH_AV_PAIRS_8B38 0x0ffff126u
N#define CYREG_SFLASH_AV_PAIRS_8B39 0x0ffff127u
N#define CYREG_SFLASH_AV_PAIRS_8B40 0x0ffff128u
N#define CYREG_SFLASH_AV_PAIRS_8B41 0x0ffff129u
N#define CYREG_SFLASH_AV_PAIRS_8B42 0x0ffff12au
N#define CYREG_SFLASH_AV_PAIRS_8B43 0x0ffff12bu
N#define CYREG_SFLASH_AV_PAIRS_8B44 0x0ffff12cu
N#define CYREG_SFLASH_AV_PAIRS_8B45 0x0ffff12du
N#define CYREG_SFLASH_AV_PAIRS_8B46 0x0ffff12eu
N#define CYREG_SFLASH_AV_PAIRS_8B47 0x0ffff12fu
N#define CYREG_SFLASH_AV_PAIRS_8B48 0x0ffff130u
N#define CYREG_SFLASH_AV_PAIRS_8B49 0x0ffff131u
N#define CYREG_SFLASH_AV_PAIRS_8B50 0x0ffff132u
N#define CYREG_SFLASH_AV_PAIRS_8B51 0x0ffff133u
N#define CYREG_SFLASH_AV_PAIRS_8B52 0x0ffff134u
N#define CYREG_SFLASH_AV_PAIRS_8B53 0x0ffff135u
N#define CYREG_SFLASH_AV_PAIRS_8B54 0x0ffff136u
N#define CYREG_SFLASH_AV_PAIRS_8B55 0x0ffff137u
N#define CYREG_SFLASH_AV_PAIRS_8B56 0x0ffff138u
N#define CYREG_SFLASH_AV_PAIRS_8B57 0x0ffff139u
N#define CYREG_SFLASH_AV_PAIRS_8B58 0x0ffff13au
N#define CYREG_SFLASH_AV_PAIRS_8B59 0x0ffff13bu
N#define CYREG_SFLASH_AV_PAIRS_8B60 0x0ffff13cu
N#define CYREG_SFLASH_AV_PAIRS_8B61 0x0ffff13du
N#define CYREG_SFLASH_AV_PAIRS_8B62 0x0ffff13eu
N#define CYREG_SFLASH_AV_PAIRS_8B63 0x0ffff13fu
N#define CYREG_SFLASH_AV_PAIRS_8B64 0x0ffff140u
N#define CYREG_SFLASH_AV_PAIRS_8B65 0x0ffff141u
N#define CYREG_SFLASH_AV_PAIRS_8B66 0x0ffff142u
N#define CYREG_SFLASH_AV_PAIRS_8B67 0x0ffff143u
N#define CYREG_SFLASH_AV_PAIRS_8B68 0x0ffff144u
N#define CYREG_SFLASH_AV_PAIRS_8B69 0x0ffff145u
N#define CYREG_SFLASH_AV_PAIRS_8B70 0x0ffff146u
N#define CYREG_SFLASH_AV_PAIRS_8B71 0x0ffff147u
N#define CYREG_SFLASH_AV_PAIRS_8B72 0x0ffff148u
N#define CYREG_SFLASH_AV_PAIRS_8B73 0x0ffff149u
N#define CYREG_SFLASH_AV_PAIRS_8B74 0x0ffff14au
N#define CYREG_SFLASH_AV_PAIRS_8B75 0x0ffff14bu
N#define CYREG_SFLASH_AV_PAIRS_8B76 0x0ffff14cu
N#define CYREG_SFLASH_AV_PAIRS_8B77 0x0ffff14du
N#define CYREG_SFLASH_AV_PAIRS_8B78 0x0ffff14eu
N#define CYREG_SFLASH_AV_PAIRS_8B79 0x0ffff14fu
N#define CYREG_SFLASH_AV_PAIRS_8B80 0x0ffff150u
N#define CYREG_SFLASH_AV_PAIRS_8B81 0x0ffff151u
N#define CYREG_SFLASH_AV_PAIRS_8B82 0x0ffff152u
N#define CYREG_SFLASH_AV_PAIRS_8B83 0x0ffff153u
N#define CYREG_SFLASH_AV_PAIRS_8B84 0x0ffff154u
N#define CYREG_SFLASH_AV_PAIRS_8B85 0x0ffff155u
N#define CYREG_SFLASH_AV_PAIRS_8B86 0x0ffff156u
N#define CYREG_SFLASH_AV_PAIRS_8B87 0x0ffff157u
N#define CYREG_SFLASH_AV_PAIRS_8B88 0x0ffff158u
N#define CYREG_SFLASH_AV_PAIRS_8B89 0x0ffff159u
N#define CYREG_SFLASH_AV_PAIRS_8B90 0x0ffff15au
N#define CYREG_SFLASH_AV_PAIRS_8B91 0x0ffff15bu
N#define CYREG_SFLASH_AV_PAIRS_8B92 0x0ffff15cu
N#define CYREG_SFLASH_AV_PAIRS_8B93 0x0ffff15du
N#define CYREG_SFLASH_AV_PAIRS_8B94 0x0ffff15eu
N#define CYREG_SFLASH_AV_PAIRS_8B95 0x0ffff15fu
N#define CYREG_SFLASH_AV_PAIRS_8B96 0x0ffff160u
N#define CYREG_SFLASH_AV_PAIRS_8B97 0x0ffff161u
N#define CYREG_SFLASH_AV_PAIRS_8B98 0x0ffff162u
N#define CYREG_SFLASH_AV_PAIRS_8B99 0x0ffff163u
N#define CYREG_SFLASH_AV_PAIRS_8B100 0x0ffff164u
N#define CYREG_SFLASH_AV_PAIRS_8B101 0x0ffff165u
N#define CYREG_SFLASH_AV_PAIRS_8B102 0x0ffff166u
N#define CYREG_SFLASH_AV_PAIRS_8B103 0x0ffff167u
N#define CYREG_SFLASH_AV_PAIRS_8B104 0x0ffff168u
N#define CYREG_SFLASH_AV_PAIRS_8B105 0x0ffff169u
N#define CYREG_SFLASH_AV_PAIRS_8B106 0x0ffff16au
N#define CYREG_SFLASH_AV_PAIRS_8B107 0x0ffff16bu
N#define CYREG_SFLASH_AV_PAIRS_8B108 0x0ffff16cu
N#define CYREG_SFLASH_AV_PAIRS_8B109 0x0ffff16du
N#define CYREG_SFLASH_AV_PAIRS_8B110 0x0ffff16eu
N#define CYREG_SFLASH_AV_PAIRS_8B111 0x0ffff16fu
N#define CYREG_SFLASH_AV_PAIRS_8B112 0x0ffff170u
N#define CYREG_SFLASH_AV_PAIRS_8B113 0x0ffff171u
N#define CYREG_SFLASH_AV_PAIRS_8B114 0x0ffff172u
N#define CYREG_SFLASH_AV_PAIRS_8B115 0x0ffff173u
N#define CYREG_SFLASH_AV_PAIRS_8B116 0x0ffff174u
N#define CYREG_SFLASH_AV_PAIRS_8B117 0x0ffff175u
N#define CYREG_SFLASH_AV_PAIRS_8B118 0x0ffff176u
N#define CYREG_SFLASH_AV_PAIRS_8B119 0x0ffff177u
N#define CYREG_SFLASH_AV_PAIRS_8B120 0x0ffff178u
N#define CYREG_SFLASH_AV_PAIRS_8B121 0x0ffff179u
N#define CYREG_SFLASH_AV_PAIRS_8B122 0x0ffff17au
N#define CYREG_SFLASH_AV_PAIRS_8B123 0x0ffff17bu
N#define CYREG_SFLASH_AV_PAIRS_8B124 0x0ffff17cu
N#define CYREG_SFLASH_AV_PAIRS_8B125 0x0ffff17du
N#define CYREG_SFLASH_AV_PAIRS_8B126 0x0ffff17eu
N#define CYREG_SFLASH_AV_PAIRS_8B127 0x0ffff17fu
N#define CYREG_SFLASH_AV_PAIRS_32B0 0x0ffff200u
N#define CYFLD_SFLASH_DATA32__OFFSET 0x00000000u
N#define CYFLD_SFLASH_DATA32__SIZE 0x00000020u
N#define CYREG_SFLASH_AV_PAIRS_32B1 0x0ffff204u
N#define CYREG_SFLASH_AV_PAIRS_32B2 0x0ffff208u
N#define CYREG_SFLASH_AV_PAIRS_32B3 0x0ffff20cu
N#define CYREG_SFLASH_AV_PAIRS_32B4 0x0ffff210u
N#define CYREG_SFLASH_AV_PAIRS_32B5 0x0ffff214u
N#define CYREG_SFLASH_AV_PAIRS_32B6 0x0ffff218u
N#define CYREG_SFLASH_AV_PAIRS_32B7 0x0ffff21cu
N#define CYREG_SFLASH_AV_PAIRS_32B8 0x0ffff220u
N#define CYREG_SFLASH_AV_PAIRS_32B9 0x0ffff224u
N#define CYREG_SFLASH_AV_PAIRS_32B10 0x0ffff228u
N#define CYREG_SFLASH_AV_PAIRS_32B11 0x0ffff22cu
N#define CYREG_SFLASH_AV_PAIRS_32B12 0x0ffff230u
N#define CYREG_SFLASH_AV_PAIRS_32B13 0x0ffff234u
N#define CYREG_SFLASH_AV_PAIRS_32B14 0x0ffff238u
N#define CYREG_SFLASH_AV_PAIRS_32B15 0x0ffff23cu
N#define CYREG_SFLASH_SILICON_ID 0x0ffff244u
N#define CYFLD_SFLASH_ID__OFFSET 0x00000000u
N#define CYFLD_SFLASH_ID__SIZE 0x00000010u
N#define CYREG_SFLASH_HIB_KEY_DELAY 0x0ffff250u
N#define CYFLD_SFLASH_WAKEUP_HOLDOFF__OFFSET 0x00000000u
N#define CYFLD_SFLASH_WAKEUP_HOLDOFF__SIZE 0x0000000au
N#define CYREG_SFLASH_DPSLP_KEY_DELAY 0x0ffff252u
N#define CYREG_SFLASH_SWD_CONFIG 0x0ffff254u
N#define CYFLD_SFLASH_SWD_SELECT__OFFSET 0x00000000u
N#define CYFLD_SFLASH_SWD_SELECT__SIZE 0x00000001u
N#define CYREG_SFLASH_SWD_LISTEN 0x0ffff258u
N#define CYFLD_SFLASH_CYCLES__OFFSET 0x00000000u
N#define CYFLD_SFLASH_CYCLES__SIZE 0x00000020u
N#define CYREG_SFLASH_FLASH_START 0x0ffff25cu
N#define CYFLD_SFLASH_ADDRESS__OFFSET 0x00000000u
N#define CYFLD_SFLASH_ADDRESS__SIZE 0x00000020u
N#define CYREG_SFLASH_CSDV2_CSD0_ADC_TRIM1 0x0ffff260u
N#define CYFLD_SFLASH_CSD_ADC_CAL_LSB__OFFSET 0x00000000u
N#define CYFLD_SFLASH_CSD_ADC_CAL_LSB__SIZE 0x00000008u
N#define CYREG_SFLASH_CSDV2_CSD0_ADC_TRIM2 0x0ffff261u
N#define CYFLD_SFLASH_CSD_ADC_CAL_MSB__OFFSET 0x00000000u
N#define CYFLD_SFLASH_CSD_ADC_CAL_MSB__SIZE 0x00000008u
N#define CYREG_SFLASH_SAR_TEMP_MULTIPLIER 0x0ffff264u
N#define CYFLD_SFLASH_TEMP_MULTIPLIER__OFFSET 0x00000000u
N#define CYFLD_SFLASH_TEMP_MULTIPLIER__SIZE 0x00000010u
N#define CYREG_SFLASH_SAR_TEMP_OFFSET 0x0ffff266u
N#define CYFLD_SFLASH_TEMP_OFFSET__OFFSET 0x00000000u
N#define CYFLD_SFLASH_TEMP_OFFSET__SIZE 0x00000010u
N#define CYREG_SFLASH_PROT_VIRGINKEY0 0x0ffff270u
N#define CYFLD_SFLASH_KEY8__OFFSET 0x00000000u
N#define CYFLD_SFLASH_KEY8__SIZE 0x00000008u
N#define CYREG_SFLASH_PROT_VIRGINKEY1 0x0ffff271u
N#define CYREG_SFLASH_PROT_VIRGINKEY2 0x0ffff272u
N#define CYREG_SFLASH_PROT_VIRGINKEY3 0x0ffff273u
N#define CYREG_SFLASH_PROT_VIRGINKEY4 0x0ffff274u
N#define CYREG_SFLASH_PROT_VIRGINKEY5 0x0ffff275u
N#define CYREG_SFLASH_PROT_VIRGINKEY6 0x0ffff276u
N#define CYREG_SFLASH_PROT_VIRGINKEY7 0x0ffff277u
N#define CYREG_SFLASH_DIE_LOT0 0x0ffff278u
N#define CYFLD_SFLASH_LOT__OFFSET 0x00000000u
N#define CYFLD_SFLASH_LOT__SIZE 0x00000008u
N#define CYREG_SFLASH_DIE_LOT1 0x0ffff279u
N#define CYREG_SFLASH_DIE_LOT2 0x0ffff27au
N#define CYREG_SFLASH_DIE_WAFER 0x0ffff27bu
N#define CYFLD_SFLASH_WAFER__OFFSET 0x00000000u
N#define CYFLD_SFLASH_WAFER__SIZE 0x00000008u
N#define CYREG_SFLASH_DIE_X 0x0ffff27cu
N#define CYFLD_SFLASH_X__OFFSET 0x00000000u
N#define CYFLD_SFLASH_X__SIZE 0x00000008u
N#define CYREG_SFLASH_DIE_Y 0x0ffff27du
N#define CYFLD_SFLASH_Y__OFFSET 0x00000000u
N#define CYFLD_SFLASH_Y__SIZE 0x00000008u
N#define CYREG_SFLASH_DIE_SORT 0x0ffff27eu
N#define CYFLD_SFLASH_S1_PASS__OFFSET 0x00000000u
N#define CYFLD_SFLASH_S1_PASS__SIZE 0x00000001u
N#define CYFLD_SFLASH_S2_PASS__OFFSET 0x00000001u
N#define CYFLD_SFLASH_S2_PASS__SIZE 0x00000001u
N#define CYFLD_SFLASH_S3_PASS__OFFSET 0x00000002u
N#define CYFLD_SFLASH_S3_PASS__SIZE 0x00000001u
N#define CYFLD_SFLASH_CRI_PASS__OFFSET 0x00000003u
N#define CYFLD_SFLASH_CRI_PASS__SIZE 0x00000001u
N#define CYFLD_SFLASH_CHI_PASS__OFFSET 0x00000004u
N#define CYFLD_SFLASH_CHI_PASS__SIZE 0x00000001u
N#define CYFLD_SFLASH_ENG_PASS__OFFSET 0x00000005u
N#define CYFLD_SFLASH_ENG_PASS__SIZE 0x00000001u
N#define CYREG_SFLASH_DIE_MINOR 0x0ffff27fu
N#define CYFLD_SFLASH_MINOR__OFFSET 0x00000000u
N#define CYFLD_SFLASH_MINOR__SIZE 0x00000008u
N#define CYREG_SFLASH_IMO_TRIM_USBMODE_24 0x0ffff33eu
N#define CYFLD_SFLASH_TRIM_24__OFFSET 0x00000000u
N#define CYFLD_SFLASH_TRIM_24__SIZE 0x00000008u
N#define CYREG_SFLASH_IMO_TRIM_USBMODE_48 0x0ffff33fu
N#define CYREG_SFLASH_IMO_TCTRIM_LT0 0x0ffff34cu
N#define CYFLD_SFLASH_STEPSIZE__OFFSET 0x00000000u
N#define CYFLD_SFLASH_STEPSIZE__SIZE 0x00000005u
N#define CYFLD_SFLASH_TCTRIM__OFFSET 0x00000005u
N#define CYFLD_SFLASH_TCTRIM__SIZE 0x00000002u
N#define CYREG_SFLASH_IMO_TCTRIM_LT1 0x0ffff34du
N#define CYREG_SFLASH_IMO_TCTRIM_LT2 0x0ffff34eu
N#define CYREG_SFLASH_IMO_TCTRIM_LT3 0x0ffff34fu
N#define CYREG_SFLASH_IMO_TCTRIM_LT4 0x0ffff350u
N#define CYREG_SFLASH_IMO_TCTRIM_LT5 0x0ffff351u
N#define CYREG_SFLASH_IMO_TCTRIM_LT6 0x0ffff352u
N#define CYREG_SFLASH_IMO_TCTRIM_LT7 0x0ffff353u
N#define CYREG_SFLASH_IMO_TCTRIM_LT8 0x0ffff354u
N#define CYREG_SFLASH_IMO_TCTRIM_LT9 0x0ffff355u
N#define CYREG_SFLASH_IMO_TCTRIM_LT10 0x0ffff356u
N#define CYREG_SFLASH_IMO_TCTRIM_LT11 0x0ffff357u
N#define CYREG_SFLASH_IMO_TCTRIM_LT12 0x0ffff358u
N#define CYREG_SFLASH_IMO_TCTRIM_LT13 0x0ffff359u
N#define CYREG_SFLASH_IMO_TCTRIM_LT14 0x0ffff35au
N#define CYREG_SFLASH_IMO_TCTRIM_LT15 0x0ffff35bu
N#define CYREG_SFLASH_IMO_TCTRIM_LT16 0x0ffff35cu
N#define CYREG_SFLASH_IMO_TCTRIM_LT17 0x0ffff35du
N#define CYREG_SFLASH_IMO_TCTRIM_LT18 0x0ffff35eu
N#define CYREG_SFLASH_IMO_TCTRIM_LT19 0x0ffff35fu
N#define CYREG_SFLASH_IMO_TCTRIM_LT20 0x0ffff360u
N#define CYREG_SFLASH_IMO_TCTRIM_LT21 0x0ffff361u
N#define CYREG_SFLASH_IMO_TCTRIM_LT22 0x0ffff362u
N#define CYREG_SFLASH_IMO_TCTRIM_LT23 0x0ffff363u
N#define CYREG_SFLASH_IMO_TCTRIM_LT24 0x0ffff364u
N#define CYREG_SFLASH_IMO_TRIM_LT0 0x0ffff365u
N#define CYFLD_SFLASH_OFFSET__OFFSET 0x00000000u
N#define CYFLD_SFLASH_OFFSET__SIZE 0x00000008u
N#define CYREG_SFLASH_IMO_TRIM_LT1 0x0ffff366u
N#define CYREG_SFLASH_IMO_TRIM_LT2 0x0ffff367u
N#define CYREG_SFLASH_IMO_TRIM_LT3 0x0ffff368u
N#define CYREG_SFLASH_IMO_TRIM_LT4 0x0ffff369u
N#define CYREG_SFLASH_IMO_TRIM_LT5 0x0ffff36au
N#define CYREG_SFLASH_IMO_TRIM_LT6 0x0ffff36bu
N#define CYREG_SFLASH_IMO_TRIM_LT7 0x0ffff36cu
N#define CYREG_SFLASH_IMO_TRIM_LT8 0x0ffff36du
N#define CYREG_SFLASH_IMO_TRIM_LT9 0x0ffff36eu
N#define CYREG_SFLASH_IMO_TRIM_LT10 0x0ffff36fu
N#define CYREG_SFLASH_IMO_TRIM_LT11 0x0ffff370u
N#define CYREG_SFLASH_IMO_TRIM_LT12 0x0ffff371u
N#define CYREG_SFLASH_IMO_TRIM_LT13 0x0ffff372u
N#define CYREG_SFLASH_IMO_TRIM_LT14 0x0ffff373u
N#define CYREG_SFLASH_IMO_TRIM_LT15 0x0ffff374u
N#define CYREG_SFLASH_IMO_TRIM_LT16 0x0ffff375u
N#define CYREG_SFLASH_IMO_TRIM_LT17 0x0ffff376u
N#define CYREG_SFLASH_IMO_TRIM_LT18 0x0ffff377u
N#define CYREG_SFLASH_IMO_TRIM_LT19 0x0ffff378u
N#define CYREG_SFLASH_IMO_TRIM_LT20 0x0ffff379u
N#define CYREG_SFLASH_IMO_TRIM_LT21 0x0ffff37au
N#define CYREG_SFLASH_IMO_TRIM_LT22 0x0ffff37bu
N#define CYREG_SFLASH_IMO_TRIM_LT23 0x0ffff37cu
N#define CYREG_SFLASH_IMO_TRIM_LT24 0x0ffff37du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH0 0x0ffff400u
N#define CYFLD_SFLASH_BYTE_MEM__OFFSET 0x00000000u
N#define CYFLD_SFLASH_BYTE_MEM__SIZE 0x00000008u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1 0x0ffff401u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH2 0x0ffff402u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH3 0x0ffff403u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH4 0x0ffff404u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH5 0x0ffff405u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH6 0x0ffff406u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH7 0x0ffff407u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH8 0x0ffff408u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH9 0x0ffff409u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH10 0x0ffff40au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH11 0x0ffff40bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH12 0x0ffff40cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH13 0x0ffff40du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH14 0x0ffff40eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH15 0x0ffff40fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH16 0x0ffff410u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH17 0x0ffff411u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH18 0x0ffff412u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH19 0x0ffff413u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH20 0x0ffff414u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH21 0x0ffff415u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH22 0x0ffff416u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH23 0x0ffff417u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH24 0x0ffff418u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH25 0x0ffff419u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH26 0x0ffff41au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH27 0x0ffff41bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH28 0x0ffff41cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH29 0x0ffff41du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH30 0x0ffff41eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH31 0x0ffff41fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH32 0x0ffff420u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH33 0x0ffff421u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH34 0x0ffff422u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH35 0x0ffff423u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH36 0x0ffff424u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH37 0x0ffff425u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH38 0x0ffff426u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH39 0x0ffff427u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH40 0x0ffff428u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH41 0x0ffff429u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH42 0x0ffff42au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH43 0x0ffff42bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH44 0x0ffff42cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH45 0x0ffff42du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH46 0x0ffff42eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH47 0x0ffff42fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH48 0x0ffff430u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH49 0x0ffff431u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH50 0x0ffff432u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH51 0x0ffff433u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH52 0x0ffff434u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH53 0x0ffff435u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH54 0x0ffff436u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH55 0x0ffff437u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH56 0x0ffff438u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH57 0x0ffff439u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH58 0x0ffff43au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH59 0x0ffff43bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH60 0x0ffff43cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH61 0x0ffff43du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH62 0x0ffff43eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH63 0x0ffff43fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH64 0x0ffff440u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH65 0x0ffff441u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH66 0x0ffff442u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH67 0x0ffff443u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH68 0x0ffff444u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH69 0x0ffff445u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH70 0x0ffff446u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH71 0x0ffff447u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH72 0x0ffff448u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH73 0x0ffff449u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH74 0x0ffff44au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH75 0x0ffff44bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH76 0x0ffff44cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH77 0x0ffff44du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH78 0x0ffff44eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH79 0x0ffff44fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH80 0x0ffff450u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH81 0x0ffff451u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH82 0x0ffff452u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH83 0x0ffff453u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH84 0x0ffff454u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH85 0x0ffff455u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH86 0x0ffff456u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH87 0x0ffff457u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH88 0x0ffff458u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH89 0x0ffff459u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH90 0x0ffff45au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH91 0x0ffff45bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH92 0x0ffff45cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH93 0x0ffff45du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH94 0x0ffff45eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH95 0x0ffff45fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH96 0x0ffff460u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH97 0x0ffff461u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH98 0x0ffff462u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH99 0x0ffff463u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH100 0x0ffff464u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH101 0x0ffff465u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH102 0x0ffff466u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH103 0x0ffff467u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH104 0x0ffff468u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH105 0x0ffff469u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH106 0x0ffff46au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH107 0x0ffff46bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH108 0x0ffff46cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH109 0x0ffff46du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH110 0x0ffff46eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH111 0x0ffff46fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH112 0x0ffff470u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH113 0x0ffff471u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH114 0x0ffff472u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH115 0x0ffff473u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH116 0x0ffff474u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH117 0x0ffff475u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH118 0x0ffff476u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH119 0x0ffff477u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH120 0x0ffff478u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH121 0x0ffff479u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH122 0x0ffff47au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH123 0x0ffff47bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH124 0x0ffff47cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH125 0x0ffff47du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH126 0x0ffff47eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH127 0x0ffff47fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH128 0x0ffff480u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH129 0x0ffff481u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH130 0x0ffff482u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH131 0x0ffff483u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH132 0x0ffff484u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH133 0x0ffff485u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH134 0x0ffff486u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH135 0x0ffff487u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH136 0x0ffff488u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH137 0x0ffff489u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH138 0x0ffff48au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH139 0x0ffff48bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH140 0x0ffff48cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH141 0x0ffff48du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH142 0x0ffff48eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH143 0x0ffff48fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH144 0x0ffff490u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH145 0x0ffff491u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH146 0x0ffff492u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH147 0x0ffff493u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH148 0x0ffff494u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH149 0x0ffff495u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH150 0x0ffff496u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH151 0x0ffff497u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH152 0x0ffff498u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH153 0x0ffff499u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH154 0x0ffff49au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH155 0x0ffff49bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH156 0x0ffff49cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH157 0x0ffff49du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH158 0x0ffff49eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH159 0x0ffff49fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH160 0x0ffff4a0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH161 0x0ffff4a1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH162 0x0ffff4a2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH163 0x0ffff4a3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH164 0x0ffff4a4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH165 0x0ffff4a5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH166 0x0ffff4a6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH167 0x0ffff4a7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH168 0x0ffff4a8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH169 0x0ffff4a9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH170 0x0ffff4aau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH171 0x0ffff4abu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH172 0x0ffff4acu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH173 0x0ffff4adu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH174 0x0ffff4aeu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH175 0x0ffff4afu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH176 0x0ffff4b0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH177 0x0ffff4b1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH178 0x0ffff4b2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH179 0x0ffff4b3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH180 0x0ffff4b4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH181 0x0ffff4b5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH182 0x0ffff4b6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH183 0x0ffff4b7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH184 0x0ffff4b8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH185 0x0ffff4b9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH186 0x0ffff4bau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH187 0x0ffff4bbu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH188 0x0ffff4bcu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH189 0x0ffff4bdu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH190 0x0ffff4beu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH191 0x0ffff4bfu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH192 0x0ffff4c0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH193 0x0ffff4c1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH194 0x0ffff4c2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH195 0x0ffff4c3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH196 0x0ffff4c4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH197 0x0ffff4c5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH198 0x0ffff4c6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH199 0x0ffff4c7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH200 0x0ffff4c8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH201 0x0ffff4c9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH202 0x0ffff4cau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH203 0x0ffff4cbu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH204 0x0ffff4ccu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH205 0x0ffff4cdu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH206 0x0ffff4ceu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH207 0x0ffff4cfu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH208 0x0ffff4d0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH209 0x0ffff4d1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH210 0x0ffff4d2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH211 0x0ffff4d3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH212 0x0ffff4d4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH213 0x0ffff4d5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH214 0x0ffff4d6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH215 0x0ffff4d7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH216 0x0ffff4d8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH217 0x0ffff4d9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH218 0x0ffff4dau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH219 0x0ffff4dbu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH220 0x0ffff4dcu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH221 0x0ffff4ddu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH222 0x0ffff4deu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH223 0x0ffff4dfu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH224 0x0ffff4e0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH225 0x0ffff4e1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH226 0x0ffff4e2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH227 0x0ffff4e3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH228 0x0ffff4e4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH229 0x0ffff4e5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH230 0x0ffff4e6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH231 0x0ffff4e7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH232 0x0ffff4e8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH233 0x0ffff4e9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH234 0x0ffff4eau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH235 0x0ffff4ebu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH236 0x0ffff4ecu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH237 0x0ffff4edu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH238 0x0ffff4eeu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH239 0x0ffff4efu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH240 0x0ffff4f0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH241 0x0ffff4f1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH242 0x0ffff4f2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH243 0x0ffff4f3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH244 0x0ffff4f4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH245 0x0ffff4f5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH246 0x0ffff4f6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH247 0x0ffff4f7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH248 0x0ffff4f8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH249 0x0ffff4f9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH250 0x0ffff4fau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH251 0x0ffff4fbu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH252 0x0ffff4fcu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH253 0x0ffff4fdu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH254 0x0ffff4feu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH255 0x0ffff4ffu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH256 0x0ffff500u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH257 0x0ffff501u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH258 0x0ffff502u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH259 0x0ffff503u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH260 0x0ffff504u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH261 0x0ffff505u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH262 0x0ffff506u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH263 0x0ffff507u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH264 0x0ffff508u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH265 0x0ffff509u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH266 0x0ffff50au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH267 0x0ffff50bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH268 0x0ffff50cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH269 0x0ffff50du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH270 0x0ffff50eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH271 0x0ffff50fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH272 0x0ffff510u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH273 0x0ffff511u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH274 0x0ffff512u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH275 0x0ffff513u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH276 0x0ffff514u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH277 0x0ffff515u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH278 0x0ffff516u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH279 0x0ffff517u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH280 0x0ffff518u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH281 0x0ffff519u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH282 0x0ffff51au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH283 0x0ffff51bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH284 0x0ffff51cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH285 0x0ffff51du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH286 0x0ffff51eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH287 0x0ffff51fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH288 0x0ffff520u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH289 0x0ffff521u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH290 0x0ffff522u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH291 0x0ffff523u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH292 0x0ffff524u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH293 0x0ffff525u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH294 0x0ffff526u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH295 0x0ffff527u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH296 0x0ffff528u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH297 0x0ffff529u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH298 0x0ffff52au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH299 0x0ffff52bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH300 0x0ffff52cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH301 0x0ffff52du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH302 0x0ffff52eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH303 0x0ffff52fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH304 0x0ffff530u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH305 0x0ffff531u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH306 0x0ffff532u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH307 0x0ffff533u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH308 0x0ffff534u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH309 0x0ffff535u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH310 0x0ffff536u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH311 0x0ffff537u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH312 0x0ffff538u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH313 0x0ffff539u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH314 0x0ffff53au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH315 0x0ffff53bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH316 0x0ffff53cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH317 0x0ffff53du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH318 0x0ffff53eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH319 0x0ffff53fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH320 0x0ffff540u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH321 0x0ffff541u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH322 0x0ffff542u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH323 0x0ffff543u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH324 0x0ffff544u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH325 0x0ffff545u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH326 0x0ffff546u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH327 0x0ffff547u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH328 0x0ffff548u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH329 0x0ffff549u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH330 0x0ffff54au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH331 0x0ffff54bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH332 0x0ffff54cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH333 0x0ffff54du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH334 0x0ffff54eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH335 0x0ffff54fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH336 0x0ffff550u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH337 0x0ffff551u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH338 0x0ffff552u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH339 0x0ffff553u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH340 0x0ffff554u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH341 0x0ffff555u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH342 0x0ffff556u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH343 0x0ffff557u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH344 0x0ffff558u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH345 0x0ffff559u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH346 0x0ffff55au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH347 0x0ffff55bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH348 0x0ffff55cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH349 0x0ffff55du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH350 0x0ffff55eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH351 0x0ffff55fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH352 0x0ffff560u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH353 0x0ffff561u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH354 0x0ffff562u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH355 0x0ffff563u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH356 0x0ffff564u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH357 0x0ffff565u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH358 0x0ffff566u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH359 0x0ffff567u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH360 0x0ffff568u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH361 0x0ffff569u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH362 0x0ffff56au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH363 0x0ffff56bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH364 0x0ffff56cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH365 0x0ffff56du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH366 0x0ffff56eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH367 0x0ffff56fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH368 0x0ffff570u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH369 0x0ffff571u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH370 0x0ffff572u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH371 0x0ffff573u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH372 0x0ffff574u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH373 0x0ffff575u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH374 0x0ffff576u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH375 0x0ffff577u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH376 0x0ffff578u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH377 0x0ffff579u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH378 0x0ffff57au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH379 0x0ffff57bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH380 0x0ffff57cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH381 0x0ffff57du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH382 0x0ffff57eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH383 0x0ffff57fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH384 0x0ffff580u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH385 0x0ffff581u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH386 0x0ffff582u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH387 0x0ffff583u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH388 0x0ffff584u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH389 0x0ffff585u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH390 0x0ffff586u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH391 0x0ffff587u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH392 0x0ffff588u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH393 0x0ffff589u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH394 0x0ffff58au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH395 0x0ffff58bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH396 0x0ffff58cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH397 0x0ffff58du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH398 0x0ffff58eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH399 0x0ffff58fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH400 0x0ffff590u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH401 0x0ffff591u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH402 0x0ffff592u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH403 0x0ffff593u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH404 0x0ffff594u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH405 0x0ffff595u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH406 0x0ffff596u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH407 0x0ffff597u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH408 0x0ffff598u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH409 0x0ffff599u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH410 0x0ffff59au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH411 0x0ffff59bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH412 0x0ffff59cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH413 0x0ffff59du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH414 0x0ffff59eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH415 0x0ffff59fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH416 0x0ffff5a0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH417 0x0ffff5a1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH418 0x0ffff5a2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH419 0x0ffff5a3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH420 0x0ffff5a4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH421 0x0ffff5a5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH422 0x0ffff5a6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH423 0x0ffff5a7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH424 0x0ffff5a8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH425 0x0ffff5a9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH426 0x0ffff5aau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH427 0x0ffff5abu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH428 0x0ffff5acu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH429 0x0ffff5adu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH430 0x0ffff5aeu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH431 0x0ffff5afu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH432 0x0ffff5b0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH433 0x0ffff5b1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH434 0x0ffff5b2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH435 0x0ffff5b3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH436 0x0ffff5b4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH437 0x0ffff5b5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH438 0x0ffff5b6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH439 0x0ffff5b7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH440 0x0ffff5b8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH441 0x0ffff5b9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH442 0x0ffff5bau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH443 0x0ffff5bbu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH444 0x0ffff5bcu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH445 0x0ffff5bdu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH446 0x0ffff5beu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH447 0x0ffff5bfu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH448 0x0ffff5c0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH449 0x0ffff5c1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH450 0x0ffff5c2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH451 0x0ffff5c3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH452 0x0ffff5c4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH453 0x0ffff5c5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH454 0x0ffff5c6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH455 0x0ffff5c7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH456 0x0ffff5c8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH457 0x0ffff5c9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH458 0x0ffff5cau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH459 0x0ffff5cbu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH460 0x0ffff5ccu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH461 0x0ffff5cdu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH462 0x0ffff5ceu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH463 0x0ffff5cfu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH464 0x0ffff5d0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH465 0x0ffff5d1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH466 0x0ffff5d2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH467 0x0ffff5d3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH468 0x0ffff5d4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH469 0x0ffff5d5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH470 0x0ffff5d6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH471 0x0ffff5d7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH472 0x0ffff5d8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH473 0x0ffff5d9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH474 0x0ffff5dau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH475 0x0ffff5dbu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH476 0x0ffff5dcu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH477 0x0ffff5ddu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH478 0x0ffff5deu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH479 0x0ffff5dfu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH480 0x0ffff5e0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH481 0x0ffff5e1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH482 0x0ffff5e2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH483 0x0ffff5e3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH484 0x0ffff5e4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH485 0x0ffff5e5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH486 0x0ffff5e6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH487 0x0ffff5e7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH488 0x0ffff5e8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH489 0x0ffff5e9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH490 0x0ffff5eau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH491 0x0ffff5ebu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH492 0x0ffff5ecu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH493 0x0ffff5edu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH494 0x0ffff5eeu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH495 0x0ffff5efu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH496 0x0ffff5f0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH497 0x0ffff5f1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH498 0x0ffff5f2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH499 0x0ffff5f3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH500 0x0ffff5f4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH501 0x0ffff5f5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH502 0x0ffff5f6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH503 0x0ffff5f7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH504 0x0ffff5f8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH505 0x0ffff5f9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH506 0x0ffff5fau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH507 0x0ffff5fbu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH508 0x0ffff5fcu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH509 0x0ffff5fdu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH510 0x0ffff5feu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH511 0x0ffff5ffu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH512 0x0ffff600u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH513 0x0ffff601u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH514 0x0ffff602u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH515 0x0ffff603u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH516 0x0ffff604u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH517 0x0ffff605u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH518 0x0ffff606u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH519 0x0ffff607u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH520 0x0ffff608u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH521 0x0ffff609u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH522 0x0ffff60au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH523 0x0ffff60bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH524 0x0ffff60cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH525 0x0ffff60du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH526 0x0ffff60eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH527 0x0ffff60fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH528 0x0ffff610u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH529 0x0ffff611u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH530 0x0ffff612u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH531 0x0ffff613u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH532 0x0ffff614u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH533 0x0ffff615u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH534 0x0ffff616u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH535 0x0ffff617u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH536 0x0ffff618u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH537 0x0ffff619u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH538 0x0ffff61au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH539 0x0ffff61bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH540 0x0ffff61cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH541 0x0ffff61du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH542 0x0ffff61eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH543 0x0ffff61fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH544 0x0ffff620u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH545 0x0ffff621u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH546 0x0ffff622u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH547 0x0ffff623u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH548 0x0ffff624u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH549 0x0ffff625u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH550 0x0ffff626u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH551 0x0ffff627u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH552 0x0ffff628u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH553 0x0ffff629u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH554 0x0ffff62au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH555 0x0ffff62bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH556 0x0ffff62cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH557 0x0ffff62du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH558 0x0ffff62eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH559 0x0ffff62fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH560 0x0ffff630u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH561 0x0ffff631u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH562 0x0ffff632u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH563 0x0ffff633u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH564 0x0ffff634u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH565 0x0ffff635u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH566 0x0ffff636u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH567 0x0ffff637u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH568 0x0ffff638u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH569 0x0ffff639u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH570 0x0ffff63au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH571 0x0ffff63bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH572 0x0ffff63cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH573 0x0ffff63du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH574 0x0ffff63eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH575 0x0ffff63fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH576 0x0ffff640u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH577 0x0ffff641u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH578 0x0ffff642u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH579 0x0ffff643u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH580 0x0ffff644u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH581 0x0ffff645u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH582 0x0ffff646u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH583 0x0ffff647u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH584 0x0ffff648u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH585 0x0ffff649u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH586 0x0ffff64au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH587 0x0ffff64bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH588 0x0ffff64cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH589 0x0ffff64du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH590 0x0ffff64eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH591 0x0ffff64fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH592 0x0ffff650u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH593 0x0ffff651u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH594 0x0ffff652u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH595 0x0ffff653u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH596 0x0ffff654u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH597 0x0ffff655u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH598 0x0ffff656u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH599 0x0ffff657u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH600 0x0ffff658u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH601 0x0ffff659u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH602 0x0ffff65au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH603 0x0ffff65bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH604 0x0ffff65cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH605 0x0ffff65du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH606 0x0ffff65eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH607 0x0ffff65fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH608 0x0ffff660u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH609 0x0ffff661u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH610 0x0ffff662u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH611 0x0ffff663u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH612 0x0ffff664u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH613 0x0ffff665u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH614 0x0ffff666u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH615 0x0ffff667u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH616 0x0ffff668u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH617 0x0ffff669u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH618 0x0ffff66au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH619 0x0ffff66bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH620 0x0ffff66cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH621 0x0ffff66du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH622 0x0ffff66eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH623 0x0ffff66fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH624 0x0ffff670u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH625 0x0ffff671u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH626 0x0ffff672u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH627 0x0ffff673u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH628 0x0ffff674u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH629 0x0ffff675u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH630 0x0ffff676u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH631 0x0ffff677u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH632 0x0ffff678u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH633 0x0ffff679u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH634 0x0ffff67au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH635 0x0ffff67bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH636 0x0ffff67cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH637 0x0ffff67du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH638 0x0ffff67eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH639 0x0ffff67fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH640 0x0ffff680u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH641 0x0ffff681u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH642 0x0ffff682u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH643 0x0ffff683u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH644 0x0ffff684u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH645 0x0ffff685u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH646 0x0ffff686u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH647 0x0ffff687u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH648 0x0ffff688u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH649 0x0ffff689u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH650 0x0ffff68au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH651 0x0ffff68bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH652 0x0ffff68cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH653 0x0ffff68du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH654 0x0ffff68eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH655 0x0ffff68fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH656 0x0ffff690u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH657 0x0ffff691u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH658 0x0ffff692u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH659 0x0ffff693u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH660 0x0ffff694u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH661 0x0ffff695u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH662 0x0ffff696u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH663 0x0ffff697u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH664 0x0ffff698u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH665 0x0ffff699u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH666 0x0ffff69au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH667 0x0ffff69bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH668 0x0ffff69cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH669 0x0ffff69du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH670 0x0ffff69eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH671 0x0ffff69fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH672 0x0ffff6a0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH673 0x0ffff6a1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH674 0x0ffff6a2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH675 0x0ffff6a3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH676 0x0ffff6a4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH677 0x0ffff6a5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH678 0x0ffff6a6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH679 0x0ffff6a7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH680 0x0ffff6a8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH681 0x0ffff6a9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH682 0x0ffff6aau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH683 0x0ffff6abu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH684 0x0ffff6acu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH685 0x0ffff6adu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH686 0x0ffff6aeu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH687 0x0ffff6afu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH688 0x0ffff6b0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH689 0x0ffff6b1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH690 0x0ffff6b2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH691 0x0ffff6b3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH692 0x0ffff6b4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH693 0x0ffff6b5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH694 0x0ffff6b6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH695 0x0ffff6b7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH696 0x0ffff6b8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH697 0x0ffff6b9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH698 0x0ffff6bau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH699 0x0ffff6bbu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH700 0x0ffff6bcu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH701 0x0ffff6bdu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH702 0x0ffff6beu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH703 0x0ffff6bfu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH704 0x0ffff6c0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH705 0x0ffff6c1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH706 0x0ffff6c2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH707 0x0ffff6c3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH708 0x0ffff6c4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH709 0x0ffff6c5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH710 0x0ffff6c6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH711 0x0ffff6c7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH712 0x0ffff6c8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH713 0x0ffff6c9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH714 0x0ffff6cau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH715 0x0ffff6cbu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH716 0x0ffff6ccu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH717 0x0ffff6cdu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH718 0x0ffff6ceu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH719 0x0ffff6cfu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH720 0x0ffff6d0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH721 0x0ffff6d1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH722 0x0ffff6d2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH723 0x0ffff6d3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH724 0x0ffff6d4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH725 0x0ffff6d5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH726 0x0ffff6d6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH727 0x0ffff6d7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH728 0x0ffff6d8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH729 0x0ffff6d9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH730 0x0ffff6dau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH731 0x0ffff6dbu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH732 0x0ffff6dcu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH733 0x0ffff6ddu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH734 0x0ffff6deu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH735 0x0ffff6dfu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH736 0x0ffff6e0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH737 0x0ffff6e1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH738 0x0ffff6e2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH739 0x0ffff6e3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH740 0x0ffff6e4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH741 0x0ffff6e5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH742 0x0ffff6e6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH743 0x0ffff6e7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH744 0x0ffff6e8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH745 0x0ffff6e9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH746 0x0ffff6eau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH747 0x0ffff6ebu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH748 0x0ffff6ecu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH749 0x0ffff6edu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH750 0x0ffff6eeu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH751 0x0ffff6efu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH752 0x0ffff6f0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH753 0x0ffff6f1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH754 0x0ffff6f2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH755 0x0ffff6f3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH756 0x0ffff6f4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH757 0x0ffff6f5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH758 0x0ffff6f6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH759 0x0ffff6f7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH760 0x0ffff6f8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH761 0x0ffff6f9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH762 0x0ffff6fau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH763 0x0ffff6fbu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH764 0x0ffff6fcu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH765 0x0ffff6fdu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH766 0x0ffff6feu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH767 0x0ffff6ffu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH768 0x0ffff700u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH769 0x0ffff701u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH770 0x0ffff702u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH771 0x0ffff703u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH772 0x0ffff704u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH773 0x0ffff705u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH774 0x0ffff706u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH775 0x0ffff707u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH776 0x0ffff708u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH777 0x0ffff709u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH778 0x0ffff70au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH779 0x0ffff70bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH780 0x0ffff70cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH781 0x0ffff70du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH782 0x0ffff70eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH783 0x0ffff70fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH784 0x0ffff710u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH785 0x0ffff711u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH786 0x0ffff712u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH787 0x0ffff713u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH788 0x0ffff714u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH789 0x0ffff715u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH790 0x0ffff716u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH791 0x0ffff717u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH792 0x0ffff718u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH793 0x0ffff719u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH794 0x0ffff71au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH795 0x0ffff71bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH796 0x0ffff71cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH797 0x0ffff71du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH798 0x0ffff71eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH799 0x0ffff71fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH800 0x0ffff720u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH801 0x0ffff721u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH802 0x0ffff722u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH803 0x0ffff723u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH804 0x0ffff724u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH805 0x0ffff725u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH806 0x0ffff726u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH807 0x0ffff727u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH808 0x0ffff728u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH809 0x0ffff729u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH810 0x0ffff72au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH811 0x0ffff72bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH812 0x0ffff72cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH813 0x0ffff72du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH814 0x0ffff72eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH815 0x0ffff72fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH816 0x0ffff730u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH817 0x0ffff731u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH818 0x0ffff732u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH819 0x0ffff733u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH820 0x0ffff734u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH821 0x0ffff735u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH822 0x0ffff736u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH823 0x0ffff737u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH824 0x0ffff738u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH825 0x0ffff739u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH826 0x0ffff73au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH827 0x0ffff73bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH828 0x0ffff73cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH829 0x0ffff73du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH830 0x0ffff73eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH831 0x0ffff73fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH832 0x0ffff740u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH833 0x0ffff741u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH834 0x0ffff742u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH835 0x0ffff743u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH836 0x0ffff744u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH837 0x0ffff745u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH838 0x0ffff746u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH839 0x0ffff747u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH840 0x0ffff748u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH841 0x0ffff749u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH842 0x0ffff74au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH843 0x0ffff74bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH844 0x0ffff74cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH845 0x0ffff74du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH846 0x0ffff74eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH847 0x0ffff74fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH848 0x0ffff750u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH849 0x0ffff751u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH850 0x0ffff752u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH851 0x0ffff753u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH852 0x0ffff754u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH853 0x0ffff755u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH854 0x0ffff756u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH855 0x0ffff757u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH856 0x0ffff758u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH857 0x0ffff759u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH858 0x0ffff75au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH859 0x0ffff75bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH860 0x0ffff75cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH861 0x0ffff75du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH862 0x0ffff75eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH863 0x0ffff75fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH864 0x0ffff760u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH865 0x0ffff761u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH866 0x0ffff762u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH867 0x0ffff763u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH868 0x0ffff764u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH869 0x0ffff765u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH870 0x0ffff766u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH871 0x0ffff767u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH872 0x0ffff768u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH873 0x0ffff769u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH874 0x0ffff76au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH875 0x0ffff76bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH876 0x0ffff76cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH877 0x0ffff76du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH878 0x0ffff76eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH879 0x0ffff76fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH880 0x0ffff770u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH881 0x0ffff771u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH882 0x0ffff772u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH883 0x0ffff773u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH884 0x0ffff774u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH885 0x0ffff775u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH886 0x0ffff776u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH887 0x0ffff777u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH888 0x0ffff778u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH889 0x0ffff779u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH890 0x0ffff77au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH891 0x0ffff77bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH892 0x0ffff77cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH893 0x0ffff77du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH894 0x0ffff77eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH895 0x0ffff77fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH896 0x0ffff780u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH897 0x0ffff781u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH898 0x0ffff782u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH899 0x0ffff783u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH900 0x0ffff784u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH901 0x0ffff785u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH902 0x0ffff786u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH903 0x0ffff787u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH904 0x0ffff788u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH905 0x0ffff789u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH906 0x0ffff78au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH907 0x0ffff78bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH908 0x0ffff78cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH909 0x0ffff78du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH910 0x0ffff78eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH911 0x0ffff78fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH912 0x0ffff790u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH913 0x0ffff791u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH914 0x0ffff792u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH915 0x0ffff793u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH916 0x0ffff794u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH917 0x0ffff795u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH918 0x0ffff796u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH919 0x0ffff797u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH920 0x0ffff798u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH921 0x0ffff799u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH922 0x0ffff79au
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH923 0x0ffff79bu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH924 0x0ffff79cu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH925 0x0ffff79du
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH926 0x0ffff79eu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH927 0x0ffff79fu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH928 0x0ffff7a0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH929 0x0ffff7a1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH930 0x0ffff7a2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH931 0x0ffff7a3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH932 0x0ffff7a4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH933 0x0ffff7a5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH934 0x0ffff7a6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH935 0x0ffff7a7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH936 0x0ffff7a8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH937 0x0ffff7a9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH938 0x0ffff7aau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH939 0x0ffff7abu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH940 0x0ffff7acu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH941 0x0ffff7adu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH942 0x0ffff7aeu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH943 0x0ffff7afu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH944 0x0ffff7b0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH945 0x0ffff7b1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH946 0x0ffff7b2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH947 0x0ffff7b3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH948 0x0ffff7b4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH949 0x0ffff7b5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH950 0x0ffff7b6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH951 0x0ffff7b7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH952 0x0ffff7b8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH953 0x0ffff7b9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH954 0x0ffff7bau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH955 0x0ffff7bbu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH956 0x0ffff7bcu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH957 0x0ffff7bdu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH958 0x0ffff7beu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH959 0x0ffff7bfu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH960 0x0ffff7c0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH961 0x0ffff7c1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH962 0x0ffff7c2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH963 0x0ffff7c3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH964 0x0ffff7c4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH965 0x0ffff7c5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH966 0x0ffff7c6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH967 0x0ffff7c7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH968 0x0ffff7c8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH969 0x0ffff7c9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH970 0x0ffff7cau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH971 0x0ffff7cbu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH972 0x0ffff7ccu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH973 0x0ffff7cdu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH974 0x0ffff7ceu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH975 0x0ffff7cfu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH976 0x0ffff7d0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH977 0x0ffff7d1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH978 0x0ffff7d2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH979 0x0ffff7d3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH980 0x0ffff7d4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH981 0x0ffff7d5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH982 0x0ffff7d6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH983 0x0ffff7d7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH984 0x0ffff7d8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH985 0x0ffff7d9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH986 0x0ffff7dau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH987 0x0ffff7dbu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH988 0x0ffff7dcu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH989 0x0ffff7ddu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH990 0x0ffff7deu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH991 0x0ffff7dfu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH992 0x0ffff7e0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH993 0x0ffff7e1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH994 0x0ffff7e2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH995 0x0ffff7e3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH996 0x0ffff7e4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH997 0x0ffff7e5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH998 0x0ffff7e6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH999 0x0ffff7e7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1000 0x0ffff7e8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1001 0x0ffff7e9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1002 0x0ffff7eau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1003 0x0ffff7ebu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1004 0x0ffff7ecu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1005 0x0ffff7edu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1006 0x0ffff7eeu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1007 0x0ffff7efu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1008 0x0ffff7f0u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1009 0x0ffff7f1u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1010 0x0ffff7f2u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1011 0x0ffff7f3u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1012 0x0ffff7f4u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1013 0x0ffff7f5u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1014 0x0ffff7f6u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1015 0x0ffff7f7u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1016 0x0ffff7f8u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1017 0x0ffff7f9u
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1018 0x0ffff7fau
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1019 0x0ffff7fbu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1020 0x0ffff7fcu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1021 0x0ffff7fdu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1022 0x0ffff7feu
N#define CYREG_SFLASH_MACRO_0_FREE_SFLASH1023 0x0ffff7ffu
N#define CYDEV_ROM_BASE 0x10000000u
N#define CYDEV_ROM_SIZE 0x00002000u
N#define CYREG_ROM_DATA_MBASE 0x10000000u
N#define CYREG_ROM_DATA_MSIZE 0x00002000u
N#define CYDEV_SRAM_BASE 0x20000000u
N#define CYDEV_SRAM_SIZE 0x00004000u
N#define CYREG_SRAM_DATA_MBASE 0x20000000u
N#define CYREG_SRAM_DATA_MSIZE 0x00004000u
N#define CYDEV_PERI_BASE 0x40010000u
N#define CYDEV_PERI_SIZE 0x00010000u
N#define CYREG_PERI_DIV_CMD 0x40010000u
N#define CYFLD_PERI_SEL_DIV__OFFSET 0x00000000u
N#define CYFLD_PERI_SEL_DIV__SIZE 0x00000006u
N#define CYFLD_PERI_SEL_TYPE__OFFSET 0x00000006u
N#define CYFLD_PERI_SEL_TYPE__SIZE 0x00000002u
N#define CYFLD_PERI_PA_SEL_DIV__OFFSET 0x00000008u
N#define CYFLD_PERI_PA_SEL_DIV__SIZE 0x00000006u
N#define CYFLD_PERI_PA_SEL_TYPE__OFFSET 0x0000000eu
N#define CYFLD_PERI_PA_SEL_TYPE__SIZE 0x00000002u
N#define CYFLD_PERI_DISABLE__OFFSET 0x0000001eu
N#define CYFLD_PERI_DISABLE__SIZE 0x00000001u
N#define CYFLD_PERI_ENABLE__OFFSET 0x0000001fu
N#define CYFLD_PERI_ENABLE__SIZE 0x00000001u
N#define CYREG_PERI_PCLK_CTL0 0x40010100u
N/* Duplicate field name in PERI: SEL_DIV [3:0] (previous: [5:0]) */
N#define CYREG_PERI_PCLK_CTL1 0x40010104u
N#define CYREG_PERI_PCLK_CTL2 0x40010108u
N#define CYREG_PERI_PCLK_CTL3 0x4001010cu
N#define CYREG_PERI_PCLK_CTL4 0x40010110u
N#define CYREG_PERI_PCLK_CTL5 0x40010114u
N#define CYREG_PERI_PCLK_CTL6 0x40010118u
N#define CYREG_PERI_PCLK_CTL7 0x4001011cu
N#define CYREG_PERI_PCLK_CTL8 0x40010120u
N#define CYREG_PERI_PCLK_CTL9 0x40010124u
N#define CYREG_PERI_PCLK_CTL10 0x40010128u
N#define CYREG_PERI_PCLK_CTL11 0x4001012cu
N#define CYREG_PERI_PCLK_CTL12 0x40010130u
N#define CYREG_PERI_PCLK_CTL13 0x40010134u
N#define CYREG_PERI_PCLK_CTL14 0x40010138u
N#define CYREG_PERI_PCLK_CTL15 0x4001013cu
N#define CYREG_PERI_PCLK_CTL16 0x40010140u
N#define CYREG_PERI_PCLK_CTL17 0x40010144u
N#define CYREG_PERI_PCLK_CTL18 0x40010148u
N#define CYREG_PERI_DIV_16_CTL0 0x40010300u
N#define CYFLD_PERI_EN__OFFSET 0x00000000u
N#define CYFLD_PERI_EN__SIZE 0x00000001u
N#define CYFLD_PERI_INT16_DIV__OFFSET 0x00000008u
N#define CYFLD_PERI_INT16_DIV__SIZE 0x00000010u
N#define CYREG_PERI_DIV_16_CTL1 0x40010304u
N#define CYREG_PERI_DIV_16_CTL2 0x40010308u
N#define CYREG_PERI_DIV_16_CTL3 0x4001030cu
N#define CYREG_PERI_DIV_16_CTL4 0x40010310u
N#define CYREG_PERI_DIV_16_CTL5 0x40010314u
N#define CYREG_PERI_DIV_16_CTL6 0x40010318u
N#define CYREG_PERI_DIV_16_CTL7 0x4001031cu
N#define CYREG_PERI_DIV_16_CTL8 0x40010320u
N#define CYREG_PERI_DIV_16_CTL9 0x40010324u
N#define CYREG_PERI_DIV_16_CTL10 0x40010328u
N#define CYREG_PERI_DIV_16_CTL11 0x4001032cu
N#define CYREG_PERI_DIV_16_5_CTL0 0x40010400u
N#define CYFLD_PERI_FRAC5_DIV__OFFSET 0x00000003u
N#define CYFLD_PERI_FRAC5_DIV__SIZE 0x00000005u
N#define CYREG_PERI_DIV_16_5_CTL1 0x40010404u
N#define CYREG_PERI_DIV_16_5_CTL2 0x40010408u
N#define CYREG_PERI_DIV_16_5_CTL3 0x4001040cu
N#define CYREG_PERI_DIV_16_5_CTL4 0x40010410u
N#define CYREG_PERI_DIV_24_5_CTL 0x40010500u
N#define CYFLD_PERI_INT24_DIV__OFFSET 0x00000008u
N#define CYFLD_PERI_INT24_DIV__SIZE 0x00000018u
N#define CYREG_PERI_TR_CTL 0x40010600u
N#define CYFLD_PERI_TR_SEL__OFFSET 0x00000000u
N#define CYFLD_PERI_TR_SEL__SIZE 0x00000007u
N#define CYFLD_PERI_TR_GROUP__OFFSET 0x00000008u
N#define CYFLD_PERI_TR_GROUP__SIZE 0x00000004u
N#define CYFLD_PERI_TR_COUNT__OFFSET 0x00000010u
N#define CYFLD_PERI_TR_COUNT__SIZE 0x00000008u
N#define CYFLD_PERI_TR_OUT__OFFSET 0x0000001eu
N#define CYFLD_PERI_TR_OUT__SIZE 0x00000001u
N#define CYFLD_PERI_TR_ACT__OFFSET 0x0000001fu
N#define CYFLD_PERI_TR_ACT__SIZE 0x00000001u
N#define CYDEV_PERI_TR_GROUP0_BASE 0x40012000u
N#define CYDEV_PERI_TR_GROUP0_SIZE 0x00000200u
N#define CYREG_PERI_TR_GROUP0_TR_OUT_CTL0 0x40012000u
N#define CYFLD_PERI_TR_GROUP_SEL__OFFSET 0x00000000u
N#define CYFLD_PERI_TR_GROUP_SEL__SIZE 0x00000006u
N#define CYREG_PERI_TR_GROUP0_TR_OUT_CTL1 0x40012004u
N#define CYREG_PERI_TR_GROUP0_TR_OUT_CTL2 0x40012008u
N#define CYREG_PERI_TR_GROUP0_TR_OUT_CTL3 0x4001200cu
N#define CYREG_PERI_TR_GROUP0_TR_OUT_CTL4 0x40012010u
N#define CYREG_PERI_TR_GROUP0_TR_OUT_CTL5 0x40012014u
N#define CYREG_PERI_TR_GROUP0_TR_OUT_CTL6 0x40012018u
N#define CYREG_PERI_TR_GROUP0_TR_OUT_CTL7 0x4001201cu
N#define CYDEV_PERI_TR_GROUP1_BASE 0x40012200u
N#define CYDEV_PERI_TR_GROUP1_SIZE 0x00000200u
N#define CYREG_PERI_TR_GROUP1_TR_OUT_CTL0 0x40012200u
N/* Duplicate field name in PERI_TR_GROUP: SEL [4:0] (previous: [5:0]) */
N#define CYREG_PERI_TR_GROUP1_TR_OUT_CTL1 0x40012204u
N#define CYREG_PERI_TR_GROUP1_TR_OUT_CTL2 0x40012208u
N#define CYREG_PERI_TR_GROUP1_TR_OUT_CTL3 0x4001220cu
N#define CYREG_PERI_TR_GROUP1_TR_OUT_CTL4 0x40012210u
N#define CYREG_PERI_TR_GROUP1_TR_OUT_CTL5 0x40012214u
N#define CYREG_PERI_TR_GROUP1_TR_OUT_CTL6 0x40012218u
N#define CYDEV_PERI_TR_GROUP2_BASE 0x40012400u
N#define CYDEV_PERI_TR_GROUP2_SIZE 0x00000200u
N#define CYREG_PERI_TR_GROUP2_TR_OUT_CTL 0x40012400u
N/* Duplicate field name in PERI_TR_GROUP: SEL [5:0] (previous: [4:0]) */
N#define CYDEV_PERI_TR_GROUP3_BASE 0x40012600u
N#define CYDEV_PERI_TR_GROUP3_SIZE 0x00000200u
N#define CYREG_PERI_TR_GROUP3_TR_OUT_CTL 0x40012600u
N/* Duplicate field name in PERI_TR_GROUP: SEL [3:0] (previous: [5:0]) */
N#define CYDEV_HSIOM_BASE 0x40020000u
N#define CYDEV_HSIOM_SIZE 0x00004000u
N#define CYREG_HSIOM_PORT_SEL0 0x40020000u
N#define CYFLD_HSIOM_IO0_SEL__OFFSET 0x00000000u
N#define CYFLD_HSIOM_IO0_SEL__SIZE 0x00000004u
N#define CYVAL_HSIOM_IO0_SEL_GPIO 0x00000000u
N#define CYVAL_HSIOM_IO0_SEL_GPIO_DSI 0x00000001u
N#define CYVAL_HSIOM_IO0_SEL_DSI_DSI 0x00000002u
N#define CYVAL_HSIOM_IO0_SEL_DSI_GPIO 0x00000003u
N#define CYVAL_HSIOM_IO0_SEL_CSD_SENSE 0x00000004u
N#define CYVAL_HSIOM_IO0_SEL_CSD_SHIELD 0x00000005u
N#define CYVAL_HSIOM_IO0_SEL_AMUXA 0x00000006u
N#define CYVAL_HSIOM_IO0_SEL_AMUXB 0x00000007u
N#define CYVAL_HSIOM_IO0_SEL_ACT_0 0x00000008u
N#define CYVAL_HSIOM_IO0_SEL_ACT_1 0x00000009u
N#define CYVAL_HSIOM_IO0_SEL_ACT_2 0x0000000au
N#define CYVAL_HSIOM_IO0_SEL_ACT_3 0x0000000bu
N#define CYVAL_HSIOM_IO0_SEL_LCD_COM 0x0000000cu
N#define CYVAL_HSIOM_IO0_SEL_LCD_SEG 0x0000000du
N#define CYVAL_HSIOM_IO0_SEL_DS_0 0x0000000cu
N#define CYVAL_HSIOM_IO0_SEL_DS_1 0x0000000du
N#define CYVAL_HSIOM_IO0_SEL_DS_2 0x0000000eu
N#define CYVAL_HSIOM_IO0_SEL_DS_3 0x0000000fu
N#define CYFLD_HSIOM_IO1_SEL__OFFSET 0x00000004u
N#define CYFLD_HSIOM_IO1_SEL__SIZE 0x00000004u
N#define CYFLD_HSIOM_IO2_SEL__OFFSET 0x00000008u
N#define CYFLD_HSIOM_IO2_SEL__SIZE 0x00000004u
N#define CYFLD_HSIOM_IO3_SEL__OFFSET 0x0000000cu
N#define CYFLD_HSIOM_IO3_SEL__SIZE 0x00000004u
N#define CYFLD_HSIOM_IO4_SEL__OFFSET 0x00000010u
N#define CYFLD_HSIOM_IO4_SEL__SIZE 0x00000004u
N#define CYFLD_HSIOM_IO5_SEL__OFFSET 0x00000014u
N#define CYFLD_HSIOM_IO5_SEL__SIZE 0x00000004u
N#define CYFLD_HSIOM_IO6_SEL__OFFSET 0x00000018u
N#define CYFLD_HSIOM_IO6_SEL__SIZE 0x00000004u
N#define CYFLD_HSIOM_IO7_SEL__OFFSET 0x0000001cu
N#define CYFLD_HSIOM_IO7_SEL__SIZE 0x00000004u
N#define CYREG_HSIOM_PORT_SEL1 0x40020100u
N#define CYREG_HSIOM_PORT_SEL2 0x40020200u
N#define CYREG_HSIOM_PORT_SEL3 0x40020300u
N#define CYREG_HSIOM_PORT_SEL4 0x40020400u
N#define CYREG_HSIOM_PORT_SEL5 0x40020500u
N#define CYREG_HSIOM_PORT_SEL6 0x40020600u
N#define CYREG_HSIOM_PORT_SEL7 0x40020700u
N#define CYREG_HSIOM_AMUX_SPLIT_CTL0 0x40022100u
N#define CYFLD_HSIOM_SWITCH_AA_SL__OFFSET 0x00000000u
N#define CYFLD_HSIOM_SWITCH_AA_SL__SIZE 0x00000001u
N#define CYFLD_HSIOM_SWITCH_AA_SR__OFFSET 0x00000001u
N#define CYFLD_HSIOM_SWITCH_AA_SR__SIZE 0x00000001u
N#define CYFLD_HSIOM_SWITCH_AA_S0__OFFSET 0x00000002u
N#define CYFLD_HSIOM_SWITCH_AA_S0__SIZE 0x00000001u
N#define CYFLD_HSIOM_SWITCH_BB_SL__OFFSET 0x00000004u
N#define CYFLD_HSIOM_SWITCH_BB_SL__SIZE 0x00000001u
N#define CYFLD_HSIOM_SWITCH_BB_SR__OFFSET 0x00000005u
N#define CYFLD_HSIOM_SWITCH_BB_SR__SIZE 0x00000001u
N#define CYFLD_HSIOM_SWITCH_BB_S0__OFFSET 0x00000006u
N#define CYFLD_HSIOM_SWITCH_BB_S0__SIZE 0x00000001u
N#define CYREG_HSIOM_AMUX_SPLIT_CTL1 0x40022104u
N#define CYREG_PWR_CONTROL 0x40030000u
N#define CYFLD__POWER_MODE__OFFSET 0x00000000u
N#define CYFLD__POWER_MODE__SIZE 0x00000004u
N#define CYVAL__POWER_MODE_RESET 0x00000000u
N#define CYVAL__POWER_MODE_ACTIVE 0x00000001u
N#define CYVAL__POWER_MODE_SLEEP 0x00000002u
N#define CYVAL__POWER_MODE_DEEP_SLEEP 0x00000003u
N#define CYFLD__DEBUG_SESSION__OFFSET 0x00000004u
N#define CYFLD__DEBUG_SESSION__SIZE 0x00000001u
N#define CYVAL__DEBUG_SESSION_NO_SESSION 0x00000000u
N#define CYVAL__DEBUG_SESSION_SESSION_ACTIVE 0x00000001u
N#define CYFLD__LPM_READY__OFFSET 0x00000005u
N#define CYFLD__LPM_READY__SIZE 0x00000001u
N#define CYFLD__OVER_TEMP_EN__OFFSET 0x00000010u
N#define CYFLD__OVER_TEMP_EN__SIZE 0x00000001u
N#define CYFLD__OVER_TEMP_THRESH__OFFSET 0x00000011u
N#define CYFLD__OVER_TEMP_THRESH__SIZE 0x00000001u
N#define CYFLD__SPARE__OFFSET 0x00000012u
N#define CYFLD__SPARE__SIZE 0x00000002u
N#define CYFLD__EXT_VCCD__OFFSET 0x00000017u
N#define CYFLD__EXT_VCCD__SIZE 0x00000001u
N#define CYREG_PWR_KEY_DELAY 0x40030004u
N#define CYFLD__WAKEUP_HOLDOFF__OFFSET 0x00000000u
N#define CYFLD__WAKEUP_HOLDOFF__SIZE 0x0000000au
N#define CYREG_PWR_DDFT_SELECT 0x4003000cu
N#define CYFLD__DDFT0_SEL__OFFSET 0x00000000u
N#define CYFLD__DDFT0_SEL__SIZE 0x00000004u
N#define CYVAL__DDFT0_SEL_WAKEUP 0x00000000u
N#define CYVAL__DDFT0_SEL_AWAKE 0x00000001u
N#define CYVAL__DDFT0_SEL_ACT_POWER_EN 0x00000002u
N#define CYVAL__DDFT0_SEL_ACT_POWER_UP 0x00000003u
N#define CYVAL__DDFT0_SEL_ACT_POWER_GOOD 0x00000004u
N#define CYVAL__DDFT0_SEL_ACT_REF_EN 0x00000005u
N#define CYVAL__DDFT0_SEL_ACT_COMP_EN 0x00000006u
N#define CYVAL__DDFT0_SEL_DPSLP_REF_EN 0x00000007u
N#define CYVAL__DDFT0_SEL_DPSLP_REG_EN 0x00000008u
N#define CYVAL__DDFT0_SEL_DPSLP_COMP_EN 0x00000009u
N#define CYVAL__DDFT0_SEL_OVER_TEMP_EN 0x0000000au
N#define CYVAL__DDFT0_SEL_SLEEPHOLDREQ_N 0x0000000bu
N#define CYVAL__DDFT0_SEL_ADFT_BUF_EN 0x0000000cu
N#define CYVAL__DDFT0_SEL_ATPG_OBSERVE 0x0000000du
N#define CYVAL__DDFT0_SEL_GND 0x0000000eu
N#define CYVAL__DDFT0_SEL_PWR 0x0000000fu
N#define CYFLD__DDFT1_SEL__OFFSET 0x00000004u
N#define CYFLD__DDFT1_SEL__SIZE 0x00000004u
N#define CYVAL__DDFT1_SEL_WAKEUP 0x00000000u
N#define CYVAL__DDFT1_SEL_AWAKE 0x00000001u
N#define CYVAL__DDFT1_SEL_ACT_POWER_EN 0x00000002u
N#define CYVAL__DDFT1_SEL_ACT_POWER_UP 0x00000003u
N#define CYVAL__DDFT1_SEL_ACT_POWER_GOOD 0x00000004u
N#define CYVAL__DDFT1_SEL_ACT_REF_VALID 0x00000005u
N#define CYVAL__DDFT1_SEL_ACT_REG_VALID 0x00000006u
N#define CYVAL__DDFT1_SEL_ACT_COMP_OUT 0x00000007u
N#define CYVAL__DDFT1_SEL_ACT_TEMP_HIGH 0x00000008u
N#define CYVAL__DDFT1_SEL_DPSLP_COMP_OUT 0x00000009u
N#define CYVAL__DDFT1_SEL_DPSLP_POWER_UP 0x0000000au
N#define CYVAL__DDFT1_SEL_AWAKE_DELAYED 0x0000000bu
N#define CYVAL__DDFT1_SEL_LPM_READY 0x0000000cu
N#define CYVAL__DDFT1_SEL_SLEEPHOLDACK_N 0x0000000du
N#define CYVAL__DDFT1_SEL_GND 0x0000000eu
N#define CYVAL__DDFT1_SEL_PWR 0x0000000fu
N#define CYREG_TST_MODE 0x40030014u
N#define CYFLD__SWD_CONNECTED__OFFSET 0x00000002u
N#define CYFLD__SWD_CONNECTED__SIZE 0x00000001u
N#define CYFLD__BLOCK_ALT_XRES__OFFSET 0x0000001cu
N#define CYFLD__BLOCK_ALT_XRES__SIZE 0x00000001u
N#define CYFLD__TEST_KEY_DFT_EN__OFFSET 0x0000001eu
N#define CYFLD__TEST_KEY_DFT_EN__SIZE 0x00000001u
N#define CYFLD__TEST_MODE__OFFSET 0x0000001fu
N#define CYFLD__TEST_MODE__SIZE 0x00000001u
N#define CYREG_TST_DDFT_CTRL 0x40030018u
N#define CYFLD__DFT_SEL0__OFFSET 0x00000000u
N#define CYFLD__DFT_SEL0__SIZE 0x00000004u
N#define CYVAL__DFT_SEL0_SRC0 0x00000000u
N#define CYVAL__DFT_SEL0_SRC1 0x00000001u
N#define CYVAL__DFT_SEL0_SRC2 0x00000002u
N#define CYVAL__DFT_SEL0_SRC3 0x00000003u
N#define CYVAL__DFT_SEL0_SRC4 0x00000004u
N#define CYVAL__DFT_SEL0_SRC5 0x00000005u
N#define CYVAL__DFT_SEL0_SRC6 0x00000006u
N#define CYVAL__DFT_SEL0_SRC7 0x00000007u
N#define CYVAL__DFT_SEL0_CLK0 0x00000008u
N#define CYVAL__DFT_SEL0_CLK1 0x00000009u
N#define CYVAL__DFT_SEL0_PWR0 0x0000000au
N#define CYVAL__DFT_SEL0_PWR1 0x0000000bu
N#define CYVAL__DFT_SEL0_RES0 0x0000000cu
N#define CYVAL__DFT_SEL0_RES1 0x0000000du
N#define CYVAL__DFT_SEL0_ADFT_COMP 0x0000000eu
N#define CYVAL__DFT_SEL0_VSS 0x0000000fu
N#define CYFLD__DFT_SEL1__OFFSET 0x00000008u
N#define CYFLD__DFT_SEL1__SIZE 0x00000004u
N#define CYVAL__DFT_SEL1_SRC0 0x00000000u
N#define CYVAL__DFT_SEL1_SRC1 0x00000001u
N#define CYVAL__DFT_SEL1_SRC2 0x00000002u
N#define CYVAL__DFT_SEL1_SRC3 0x00000003u
N#define CYVAL__DFT_SEL1_SRC4 0x00000004u
N#define CYVAL__DFT_SEL1_SRC5 0x00000005u
N#define CYVAL__DFT_SEL1_SRC6 0x00000006u
N#define CYVAL__DFT_SEL1_SRC7 0x00000007u
N#define CYVAL__DFT_SEL1_CLK0 0x00000008u
N#define CYVAL__DFT_SEL1_CLK1 0x00000009u
N#define CYVAL__DFT_SEL1_PWR0 0x0000000au
N#define CYVAL__DFT_SEL1_PWR1 0x0000000bu
N#define CYVAL__DFT_SEL1_RES0 0x0000000cu
N#define CYVAL__DFT_SEL1_RES1 0x0000000du
N#define CYVAL__DFT_SEL1_ADFT_COMP 0x0000000eu
N#define CYVAL__DFT_SEL1_VSS 0x0000000fu
N#define CYFLD__ENABLE__OFFSET 0x0000001fu
N#define CYFLD__ENABLE__SIZE 0x00000001u
N#define CYREG_TST_TRIM_CNTR1 0x4003001cu
N#define CYFLD__COUNTER__OFFSET 0x00000000u
N#define CYFLD__COUNTER__SIZE 0x00000010u
N#define CYFLD__COUNTER_DONE__OFFSET 0x0000001fu
N#define CYFLD__COUNTER_DONE__SIZE 0x00000001u
N#define CYREG_TST_TRIM_CNTR2 0x40030020u
N#define CYREG_TST_ADFT_CTRL 0x40030024u
N#define CYFLD__BUF_AUTO_ZERO__OFFSET 0x00000000u
N#define CYFLD__BUF_AUTO_ZERO__SIZE 0x00000001u
N#define CYFLD__BUF_MODE__OFFSET 0x00000008u
N#define CYFLD__BUF_MODE__SIZE 0x00000002u
N#define CYFLD__BUF_COMP_OUT__OFFSET 0x00000010u
N#define CYFLD__BUF_COMP_OUT__SIZE 0x00000001u
N#define CYFLD__BUF_EN__OFFSET 0x0000001fu
N#define CYFLD__BUF_EN__SIZE 0x00000001u
N#define CYREG_CLK_SELECT 0x40030028u
N#define CYFLD__HFCLK_SEL__OFFSET 0x00000000u
N#define CYFLD__HFCLK_SEL__SIZE 0x00000002u
N#define CYVAL__HFCLK_SEL_IMO 0x00000000u
N#define CYVAL__HFCLK_SEL_EXTCLK 0x00000001u
N#define CYVAL__HFCLK_SEL_ECO 0x00000002u
N#define CYFLD__HFCLK_DIV__OFFSET 0x00000002u
N#define CYFLD__HFCLK_DIV__SIZE 0x00000002u
N#define CYVAL__HFCLK_DIV_NO_DIV 0x00000000u
N#define CYVAL__HFCLK_DIV_DIV_BY_2 0x00000001u
N#define CYVAL__HFCLK_DIV_DIV_BY_4 0x00000002u
N#define CYVAL__HFCLK_DIV_DIV_BY_8 0x00000003u
N#define CYFLD__PUMP_SEL__OFFSET 0x00000004u
N#define CYFLD__PUMP_SEL__SIZE 0x00000002u
N#define CYVAL__PUMP_SEL_GND 0x00000000u
N#define CYVAL__PUMP_SEL_IMO 0x00000001u
N#define CYVAL__PUMP_SEL_HFCLK 0x00000002u
N#define CYFLD__SYSCLK_DIV__OFFSET 0x00000006u
N#define CYFLD__SYSCLK_DIV__SIZE 0x00000002u
N#define CYVAL__SYSCLK_DIV_NO_DIV 0x00000000u
N#define CYVAL__SYSCLK_DIV_DIV_BY_2 0x00000001u
N#define CYVAL__SYSCLK_DIV_DIV_BY_4 0x00000002u
N#define CYVAL__SYSCLK_DIV_DIV_BY_8 0x00000003u
N#define CYREG_CLK_ILO_CONFIG 0x4003002cu
N#define CYREG_CLK_IMO_CONFIG 0x40030030u
N#define CYREG_CLK_DFT_SELECT 0x40030034u
N#define CYFLD__DFT_DIV0__OFFSET 0x00000004u
N#define CYFLD__DFT_DIV0__SIZE 0x00000002u
N#define CYVAL__DFT_DIV0_NO_DIV 0x00000000u
N#define CYVAL__DFT_DIV0_DIV_BY_2 0x00000001u
N#define CYVAL__DFT_DIV0_DIV_BY_4 0x00000002u
N#define CYVAL__DFT_DIV0_DIV_BY_8 0x00000003u
N#define CYFLD__DFT_EDGE0__OFFSET 0x00000006u
N#define CYFLD__DFT_EDGE0__SIZE 0x00000001u
N#define CYVAL__DFT_EDGE0_POSEDGE 0x00000000u
N#define CYVAL__DFT_EDGE0_NEGEDGE 0x00000001u
N#define CYFLD__DFT_DIV1__OFFSET 0x0000000cu
N#define CYFLD__DFT_DIV1__SIZE 0x00000002u
N#define CYVAL__DFT_DIV1_NO_DIV 0x00000000u
N#define CYVAL__DFT_DIV1_DIV_BY_2 0x00000001u
N#define CYVAL__DFT_DIV1_DIV_BY_4 0x00000002u
N#define CYVAL__DFT_DIV1_DIV_BY_8 0x00000003u
N#define CYFLD__DFT_EDGE1__OFFSET 0x0000000eu
N#define CYFLD__DFT_EDGE1__SIZE 0x00000001u
N#define CYVAL__DFT_EDGE1_POSEDGE 0x00000000u
N#define CYVAL__DFT_EDGE1_NEGEDGE 0x00000001u
N#define CYREG_WDT_DISABLE_KEY 0x40030038u
N#define CYFLD__KEY__OFFSET 0x00000000u
N#define CYFLD__KEY__SIZE 0x00000020u
N#define CYREG_WDT_COUNTER 0x4003003cu
N#define CYREG_WDT_MATCH 0x40030040u
N#define CYFLD__MATCH__OFFSET 0x00000000u
N#define CYFLD__MATCH__SIZE 0x00000010u
N#define CYFLD__IGNORE_BITS__OFFSET 0x00000010u
N#define CYFLD__IGNORE_BITS__SIZE 0x00000004u
N#define CYREG_SRSS_INTR 0x40030044u
N#define CYFLD__WDT_MATCH__OFFSET 0x00000000u
N#define CYFLD__WDT_MATCH__SIZE 0x00000001u
N#define CYFLD__TEMP_HIGH__OFFSET 0x00000001u
N#define CYFLD__TEMP_HIGH__SIZE 0x00000001u
N#define CYREG_SRSS_INTR_SET 0x40030048u
N#define CYREG_SRSS_INTR_MASK 0x4003004cu
N#define CYREG_RES_CAUSE 0x40030054u
N#define CYFLD__RESET_WDT__OFFSET 0x00000000u
N#define CYFLD__RESET_WDT__SIZE 0x00000001u
N#define CYFLD__RESET_PROT_FAULT__OFFSET 0x00000003u
N#define CYFLD__RESET_PROT_FAULT__SIZE 0x00000001u
N#define CYFLD__RESET_SOFT__OFFSET 0x00000004u
N#define CYFLD__RESET_SOFT__SIZE 0x00000001u
N#define CYREG_PWR_BG_TRIM1 0x40030f00u
N#define CYFLD__REF_VTRIM__OFFSET 0x00000000u
N#define CYFLD__REF_VTRIM__SIZE 0x00000006u
N#define CYREG_PWR_BG_TRIM2 0x40030f04u
N#define CYFLD__REF_ITRIM__OFFSET 0x00000000u
N#define CYFLD__REF_ITRIM__SIZE 0x00000006u
N#define CYREG_CLK_IMO_SELECT 0x40030f08u
N#define CYFLD__FREQ__OFFSET 0x00000000u
N#define CYFLD__FREQ__SIZE 0x00000003u
N#define CYVAL__FREQ_24_MHZ 0x00000000u
N#define CYVAL__FREQ_28_MHZ 0x00000001u
N#define CYVAL__FREQ_32_MHZ 0x00000002u
N#define CYVAL__FREQ_36_MHZ 0x00000003u
N#define CYVAL__FREQ_40_MHZ 0x00000004u
N#define CYVAL__FREQ_44_MHZ 0x00000005u
N#define CYVAL__FREQ_48_MHZ 0x00000006u
N#define CYREG_CLK_IMO_TRIM1 0x40030f0cu
N#define CYFLD__OFFSET__OFFSET 0x00000000u
N#define CYFLD__OFFSET__SIZE 0x00000008u
N#define CYREG_CLK_IMO_TRIM2 0x40030f10u
N#define CYFLD__FSOFFSET__OFFSET 0x00000000u
N#define CYFLD__FSOFFSET__SIZE 0x00000003u
N#define CYREG_PWR_PWRSYS_TRIM1 0x40030f14u
N#define CYFLD__DPSLP_REF_TRIM__OFFSET 0x00000000u
N#define CYFLD__DPSLP_REF_TRIM__SIZE 0x00000004u
N#define CYFLD__SPARE_TRIM__OFFSET 0x00000004u
N#define CYFLD__SPARE_TRIM__SIZE 0x00000004u
N#define CYREG_CLK_IMO_TRIM3 0x40030f18u
N#define CYFLD__STEPSIZE__OFFSET 0x00000000u
N#define CYFLD__STEPSIZE__SIZE 0x00000005u
N#define CYFLD__TCTRIM__OFFSET 0x00000005u
N#define CYFLD__TCTRIM__SIZE 0x00000002u
N#define CYDEV_GPIO_BASE 0x40040000u
N#define CYDEV_GPIO_SIZE 0x00004000u
N#define CYDEV_GPIO_PRT0_BASE 0x40040000u
N#define CYDEV_GPIO_PRT0_SIZE 0x00000100u
N#define CYREG_GPIO_PRT0_DR 0x40040000u
N#define CYFLD_GPIO_PRT_DATA0__OFFSET 0x00000000u
N#define CYFLD_GPIO_PRT_DATA0__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_DATA1__OFFSET 0x00000001u
N#define CYFLD_GPIO_PRT_DATA1__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_DATA2__OFFSET 0x00000002u
N#define CYFLD_GPIO_PRT_DATA2__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_DATA3__OFFSET 0x00000003u
N#define CYFLD_GPIO_PRT_DATA3__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_DATA4__OFFSET 0x00000004u
N#define CYFLD_GPIO_PRT_DATA4__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_DATA5__OFFSET 0x00000005u
N#define CYFLD_GPIO_PRT_DATA5__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_DATA6__OFFSET 0x00000006u
N#define CYFLD_GPIO_PRT_DATA6__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_DATA7__OFFSET 0x00000007u
N#define CYFLD_GPIO_PRT_DATA7__SIZE 0x00000001u
N#define CYREG_GPIO_PRT0_PS 0x40040004u
N#define CYFLD_GPIO_PRT_FLT_DATA__OFFSET 0x00000008u
N#define CYFLD_GPIO_PRT_FLT_DATA__SIZE 0x00000001u
N#define CYREG_GPIO_PRT0_PC 0x40040008u
N#define CYFLD_GPIO_PRT_DM0__OFFSET 0x00000000u
N#define CYFLD_GPIO_PRT_DM0__SIZE 0x00000003u
N#define CYVAL_GPIO_PRT_DM0_OFF 0x00000000u
N#define CYVAL_GPIO_PRT_DM0_INPUT 0x00000001u
N#define CYVAL_GPIO_PRT_DM0_0_PU 0x00000002u
N#define CYVAL_GPIO_PRT_DM0_PD_1 0x00000003u
N#define CYVAL_GPIO_PRT_DM0_0_Z 0x00000004u
N#define CYVAL_GPIO_PRT_DM0_Z_1 0x00000005u
N#define CYVAL_GPIO_PRT_DM0_0_1 0x00000006u
N#define CYVAL_GPIO_PRT_DM0_PD_PU 0x00000007u
N#define CYFLD_GPIO_PRT_DM1__OFFSET 0x00000003u
N#define CYFLD_GPIO_PRT_DM1__SIZE 0x00000003u
N#define CYFLD_GPIO_PRT_DM2__OFFSET 0x00000006u
N#define CYFLD_GPIO_PRT_DM2__SIZE 0x00000003u
N#define CYFLD_GPIO_PRT_DM3__OFFSET 0x00000009u
N#define CYFLD_GPIO_PRT_DM3__SIZE 0x00000003u
N#define CYFLD_GPIO_PRT_DM4__OFFSET 0x0000000cu
N#define CYFLD_GPIO_PRT_DM4__SIZE 0x00000003u
N#define CYFLD_GPIO_PRT_DM5__OFFSET 0x0000000fu
N#define CYFLD_GPIO_PRT_DM5__SIZE 0x00000003u
N#define CYFLD_GPIO_PRT_DM6__OFFSET 0x00000012u
N#define CYFLD_GPIO_PRT_DM6__SIZE 0x00000003u
N#define CYFLD_GPIO_PRT_DM7__OFFSET 0x00000015u
N#define CYFLD_GPIO_PRT_DM7__SIZE 0x00000003u
N#define CYFLD_GPIO_PRT_PORT_VTRIP_SEL__OFFSET 0x00000018u
N#define CYFLD_GPIO_PRT_PORT_VTRIP_SEL__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_PORT_SLOW__OFFSET 0x00000019u
N#define CYFLD_GPIO_PRT_PORT_SLOW__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_PORT_IB_MODE_SEL__OFFSET 0x0000001eu
N#define CYFLD_GPIO_PRT_PORT_IB_MODE_SEL__SIZE 0x00000002u
N#define CYREG_GPIO_PRT0_INTR_CFG 0x4004000cu
N#define CYFLD_GPIO_PRT_EDGE0_SEL__OFFSET 0x00000000u
N#define CYFLD_GPIO_PRT_EDGE0_SEL__SIZE 0x00000002u
N#define CYVAL_GPIO_PRT_EDGE0_SEL_DISABLE 0x00000000u
N#define CYVAL_GPIO_PRT_EDGE0_SEL_RISING 0x00000001u
N#define CYVAL_GPIO_PRT_EDGE0_SEL_FALLING 0x00000002u
N#define CYVAL_GPIO_PRT_EDGE0_SEL_BOTH 0x00000003u
N#define CYFLD_GPIO_PRT_EDGE1_SEL__OFFSET 0x00000002u
N#define CYFLD_GPIO_PRT_EDGE1_SEL__SIZE 0x00000002u
N#define CYFLD_GPIO_PRT_EDGE2_SEL__OFFSET 0x00000004u
N#define CYFLD_GPIO_PRT_EDGE2_SEL__SIZE 0x00000002u
N#define CYFLD_GPIO_PRT_EDGE3_SEL__OFFSET 0x00000006u
N#define CYFLD_GPIO_PRT_EDGE3_SEL__SIZE 0x00000002u
N#define CYFLD_GPIO_PRT_EDGE4_SEL__OFFSET 0x00000008u
N#define CYFLD_GPIO_PRT_EDGE4_SEL__SIZE 0x00000002u
N#define CYFLD_GPIO_PRT_EDGE5_SEL__OFFSET 0x0000000au
N#define CYFLD_GPIO_PRT_EDGE5_SEL__SIZE 0x00000002u
N#define CYFLD_GPIO_PRT_EDGE6_SEL__OFFSET 0x0000000cu
N#define CYFLD_GPIO_PRT_EDGE6_SEL__SIZE 0x00000002u
N#define CYFLD_GPIO_PRT_EDGE7_SEL__OFFSET 0x0000000eu
N#define CYFLD_GPIO_PRT_EDGE7_SEL__SIZE 0x00000002u
N#define CYFLD_GPIO_PRT_FLT_EDGE_SEL__OFFSET 0x00000010u
N#define CYFLD_GPIO_PRT_FLT_EDGE_SEL__SIZE 0x00000002u
N#define CYVAL_GPIO_PRT_FLT_EDGE_SEL_DISABLE 0x00000000u
N#define CYVAL_GPIO_PRT_FLT_EDGE_SEL_RISING 0x00000001u
N#define CYVAL_GPIO_PRT_FLT_EDGE_SEL_FALLING 0x00000002u
N#define CYVAL_GPIO_PRT_FLT_EDGE_SEL_BOTH 0x00000003u
N#define CYFLD_GPIO_PRT_FLT_SEL__OFFSET 0x00000012u
N#define CYFLD_GPIO_PRT_FLT_SEL__SIZE 0x00000003u
N#define CYREG_GPIO_PRT0_INTR 0x40040010u
N#define CYFLD_GPIO_PRT_PS_DATA0__OFFSET 0x00000010u
N#define CYFLD_GPIO_PRT_PS_DATA0__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_PS_DATA1__OFFSET 0x00000011u
N#define CYFLD_GPIO_PRT_PS_DATA1__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_PS_DATA2__OFFSET 0x00000012u
N#define CYFLD_GPIO_PRT_PS_DATA2__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_PS_DATA3__OFFSET 0x00000013u
N#define CYFLD_GPIO_PRT_PS_DATA3__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_PS_DATA4__OFFSET 0x00000014u
N#define CYFLD_GPIO_PRT_PS_DATA4__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_PS_DATA5__OFFSET 0x00000015u
N#define CYFLD_GPIO_PRT_PS_DATA5__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_PS_DATA6__OFFSET 0x00000016u
N#define CYFLD_GPIO_PRT_PS_DATA6__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_PS_DATA7__OFFSET 0x00000017u
N#define CYFLD_GPIO_PRT_PS_DATA7__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_PS_FLT_DATA__OFFSET 0x00000018u
N#define CYFLD_GPIO_PRT_PS_FLT_DATA__SIZE 0x00000001u
N#define CYREG_GPIO_PRT0_PC2 0x40040018u
N#define CYFLD_GPIO_PRT_INP_DIS0__OFFSET 0x00000000u
N#define CYFLD_GPIO_PRT_INP_DIS0__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_INP_DIS1__OFFSET 0x00000001u
N#define CYFLD_GPIO_PRT_INP_DIS1__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_INP_DIS2__OFFSET 0x00000002u
N#define CYFLD_GPIO_PRT_INP_DIS2__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_INP_DIS3__OFFSET 0x00000003u
N#define CYFLD_GPIO_PRT_INP_DIS3__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_INP_DIS4__OFFSET 0x00000004u
N#define CYFLD_GPIO_PRT_INP_DIS4__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_INP_DIS5__OFFSET 0x00000005u
N#define CYFLD_GPIO_PRT_INP_DIS5__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_INP_DIS6__OFFSET 0x00000006u
N#define CYFLD_GPIO_PRT_INP_DIS6__SIZE 0x00000001u
N#define CYFLD_GPIO_PRT_INP_DIS7__OFFSET 0x00000007u
N#define CYFLD_GPIO_PRT_INP_DIS7__SIZE 0x00000001u
N#define CYREG_GPIO_PRT0_DR_SET 0x40040040u
N#define CYFLD_GPIO_PRT_DATA__OFFSET 0x00000000u
N#define CYFLD_GPIO_PRT_DATA__SIZE 0x00000008u
N#define CYREG_GPIO_PRT0_DR_CLR 0x40040044u
N#define CYREG_GPIO_PRT0_DR_INV 0x40040048u
N#define CYDEV_GPIO_PRT1_BASE 0x40040100u
N#define CYDEV_GPIO_PRT1_SIZE 0x00000100u
N#define CYREG_GPIO_PRT1_DR 0x40040100u
N#define CYREG_GPIO_PRT1_PS 0x40040104u
N#define CYREG_GPIO_PRT1_PC 0x40040108u
N#define CYREG_GPIO_PRT1_INTR_CFG 0x4004010cu
N#define CYREG_GPIO_PRT1_INTR 0x40040110u
N#define CYREG_GPIO_PRT1_PC2 0x40040118u
N#define CYREG_GPIO_PRT1_DR_SET 0x40040140u
N#define CYREG_GPIO_PRT1_DR_CLR 0x40040144u
N#define CYREG_GPIO_PRT1_DR_INV 0x40040148u
N#define CYDEV_GPIO_PRT2_BASE 0x40040200u
N#define CYDEV_GPIO_PRT2_SIZE 0x00000100u
N#define CYREG_GPIO_PRT2_DR 0x40040200u
N#define CYREG_GPIO_PRT2_PS 0x40040204u
N#define CYREG_GPIO_PRT2_PC 0x40040208u
N#define CYREG_GPIO_PRT2_INTR_CFG 0x4004020cu
N#define CYREG_GPIO_PRT2_INTR 0x40040210u
N#define CYREG_GPIO_PRT2_PC2 0x40040218u
N#define CYREG_GPIO_PRT2_DR_SET 0x40040240u
N#define CYREG_GPIO_PRT2_DR_CLR 0x40040244u
N#define CYREG_GPIO_PRT2_DR_INV 0x40040248u
N#define CYDEV_GPIO_PRT3_BASE 0x40040300u
N#define CYDEV_GPIO_PRT3_SIZE 0x00000100u
N#define CYREG_GPIO_PRT3_DR 0x40040300u
N#define CYREG_GPIO_PRT3_PS 0x40040304u
N#define CYREG_GPIO_PRT3_PC 0x40040308u
N#define CYREG_GPIO_PRT3_INTR_CFG 0x4004030cu
N#define CYREG_GPIO_PRT3_INTR 0x40040310u
N#define CYREG_GPIO_PRT3_PC2 0x40040318u
N#define CYREG_GPIO_PRT3_DR_SET 0x40040340u
N#define CYREG_GPIO_PRT3_DR_CLR 0x40040344u
N#define CYREG_GPIO_PRT3_DR_INV 0x40040348u
N#define CYDEV_GPIO_PRT4_BASE 0x40040400u
N#define CYDEV_GPIO_PRT4_SIZE 0x00000100u
N#define CYREG_GPIO_PRT4_DR 0x40040400u
N#define CYREG_GPIO_PRT4_PS 0x40040404u
N#define CYREG_GPIO_PRT4_PC 0x40040408u
N#define CYREG_GPIO_PRT4_INTR_CFG 0x4004040cu
N#define CYREG_GPIO_PRT4_INTR 0x40040410u
N#define CYREG_GPIO_PRT4_PC2 0x40040418u
N#define CYREG_GPIO_PRT4_DR_SET 0x40040440u
N#define CYREG_GPIO_PRT4_DR_CLR 0x40040444u
N#define CYREG_GPIO_PRT4_DR_INV 0x40040448u
N#define CYDEV_GPIO_PRT5_BASE 0x40040500u
N#define CYDEV_GPIO_PRT5_SIZE 0x00000100u
N#define CYREG_GPIO_PRT5_DR 0x40040500u
N#define CYREG_GPIO_PRT5_PS 0x40040504u
N#define CYREG_GPIO_PRT5_PC 0x40040508u
N#define CYREG_GPIO_PRT5_INTR_CFG 0x4004050cu
N#define CYREG_GPIO_PRT5_INTR 0x40040510u
N#define CYREG_GPIO_PRT5_PC2 0x40040518u
N#define CYREG_GPIO_PRT5_DR_SET 0x40040540u
N#define CYREG_GPIO_PRT5_DR_CLR 0x40040544u
N#define CYREG_GPIO_PRT5_DR_INV 0x40040548u
N#define CYDEV_GPIO_PRT6_BASE 0x40040600u
N#define CYDEV_GPIO_PRT6_SIZE 0x00000100u
N#define CYREG_GPIO_PRT6_DR 0x40040600u
N#define CYREG_GPIO_PRT6_PS 0x40040604u
N#define CYREG_GPIO_PRT6_PC 0x40040608u
N#define CYREG_GPIO_PRT6_INTR_CFG 0x4004060cu
N#define CYREG_GPIO_PRT6_INTR 0x40040610u
N#define CYREG_GPIO_PRT6_PC2 0x40040618u
N#define CYREG_GPIO_PRT6_DR_SET 0x40040640u
N#define CYREG_GPIO_PRT6_DR_CLR 0x40040644u
N#define CYREG_GPIO_PRT6_DR_INV 0x40040648u
N#define CYDEV_GPIO_PRT7_BASE 0x40040700u
N#define CYDEV_GPIO_PRT7_SIZE 0x00000100u
N#define CYREG_GPIO_PRT7_DR 0x40040700u
N#define CYREG_GPIO_PRT7_PS 0x40040704u
N#define CYREG_GPIO_PRT7_PC 0x40040708u
N#define CYREG_GPIO_PRT7_INTR_CFG 0x4004070cu
N#define CYREG_GPIO_PRT7_INTR 0x40040710u
N#define CYREG_GPIO_PRT7_PC2 0x40040718u
N#define CYREG_GPIO_PRT7_DR_SET 0x40040740u
N#define CYREG_GPIO_PRT7_DR_CLR 0x40040744u
N#define CYREG_GPIO_PRT7_DR_INV 0x40040748u
N#define CYREG_GPIO_INTR_CAUSE 0x40041000u
N#define CYFLD_GPIO_PORT_INT__OFFSET 0x00000000u
N#define CYFLD_GPIO_PORT_INT__SIZE 0x00000008u
N#define CYDEV_PRGIO_BASE 0x40050000u
N#define CYDEV_PRGIO_SIZE 0x00001000u
N#define CYDEV_PRGIO_PRT0_BASE 0x40050000u
N#define CYDEV_PRGIO_PRT0_SIZE 0x00000100u
N#define CYREG_PRGIO_PRT0_CTL 0x40050000u
N#define CYFLD_PRGIO_PRT_BYPASS__OFFSET 0x00000000u
N#define CYFLD_PRGIO_PRT_BYPASS__SIZE 0x00000008u
N#define CYFLD_PRGIO_PRT_CLOCK_SRC__OFFSET 0x00000008u
N#define CYFLD_PRGIO_PRT_CLOCK_SRC__SIZE 0x00000005u
N#define CYFLD_PRGIO_PRT_HLD_OVR__OFFSET 0x00000018u
N#define CYFLD_PRGIO_PRT_HLD_OVR__SIZE 0x00000001u
N#define CYFLD_PRGIO_PRT_PIPELINE_EN__OFFSET 0x00000019u
N#define CYFLD_PRGIO_PRT_PIPELINE_EN__SIZE 0x00000001u
N#define CYFLD_PRGIO_PRT_ENABLED__OFFSET 0x0000001fu
N#define CYFLD_PRGIO_PRT_ENABLED__SIZE 0x00000001u
N#define CYREG_PRGIO_PRT0_SYNC_CTL 0x40050010u
N#define CYFLD_PRGIO_PRT_IO_SYNC_EN__OFFSET 0x00000000u
N#define CYFLD_PRGIO_PRT_IO_SYNC_EN__SIZE 0x00000008u
N#define CYFLD_PRGIO_PRT_CHIP_SYNC_EN__OFFSET 0x00000008u
N#define CYFLD_PRGIO_PRT_CHIP_SYNC_EN__SIZE 0x00000008u
N#define CYREG_PRGIO_PRT0_LUT_SEL0 0x40050020u
N#define CYFLD_PRGIO_PRT_LUT_TR0_SEL__OFFSET 0x00000000u
N#define CYFLD_PRGIO_PRT_LUT_TR0_SEL__SIZE 0x00000004u
N#define CYFLD_PRGIO_PRT_LUT_TR1_SEL__OFFSET 0x00000008u
N#define CYFLD_PRGIO_PRT_LUT_TR1_SEL__SIZE 0x00000004u
N#define CYFLD_PRGIO_PRT_LUT_TR2_SEL__OFFSET 0x00000010u
N#define CYFLD_PRGIO_PRT_LUT_TR2_SEL__SIZE 0x00000004u
N#define CYREG_PRGIO_PRT0_LUT_SEL1 0x40050024u
N#define CYREG_PRGIO_PRT0_LUT_SEL2 0x40050028u
N#define CYREG_PRGIO_PRT0_LUT_SEL3 0x4005002cu
N#define CYREG_PRGIO_PRT0_LUT_SEL4 0x40050030u
N#define CYREG_PRGIO_PRT0_LUT_SEL5 0x40050034u
N#define CYREG_PRGIO_PRT0_LUT_SEL6 0x40050038u
N#define CYREG_PRGIO_PRT0_LUT_SEL7 0x4005003cu
N#define CYREG_PRGIO_PRT0_LUT_CTL0 0x40050040u
N#define CYFLD_PRGIO_PRT_LUT__OFFSET 0x00000000u
N#define CYFLD_PRGIO_PRT_LUT__SIZE 0x00000008u
N#define CYFLD_PRGIO_PRT_LUT_OPC__OFFSET 0x00000008u
N#define CYFLD_PRGIO_PRT_LUT_OPC__SIZE 0x00000002u
N#define CYREG_PRGIO_PRT0_LUT_CTL1 0x40050044u
N#define CYREG_PRGIO_PRT0_LUT_CTL2 0x40050048u
N#define CYREG_PRGIO_PRT0_LUT_CTL3 0x4005004cu
N#define CYREG_PRGIO_PRT0_LUT_CTL4 0x40050050u
N#define CYREG_PRGIO_PRT0_LUT_CTL5 0x40050054u
N#define CYREG_PRGIO_PRT0_LUT_CTL6 0x40050058u
N#define CYREG_PRGIO_PRT0_LUT_CTL7 0x4005005cu
N#define CYREG_PRGIO_PRT0_DU_SEL 0x400500c0u
N#define CYFLD_PRGIO_PRT_DU_TR0_SEL__OFFSET 0x00000000u
N#define CYFLD_PRGIO_PRT_DU_TR0_SEL__SIZE 0x00000004u
N#define CYFLD_PRGIO_PRT_DU_TR1_SEL__OFFSET 0x00000008u
N#define CYFLD_PRGIO_PRT_DU_TR1_SEL__SIZE 0x00000004u
N#define CYFLD_PRGIO_PRT_DU_TR2_SEL__OFFSET 0x00000010u
N#define CYFLD_PRGIO_PRT_DU_TR2_SEL__SIZE 0x00000004u
N#define CYFLD_PRGIO_PRT_DU_DATA0_SEL__OFFSET 0x00000018u
N#define CYFLD_PRGIO_PRT_DU_DATA0_SEL__SIZE 0x00000002u
N#define CYFLD_PRGIO_PRT_DU_DATA1_SEL__OFFSET 0x0000001cu
N#define CYFLD_PRGIO_PRT_DU_DATA1_SEL__SIZE 0x00000002u
N#define CYREG_PRGIO_PRT0_DU_CTL 0x400500c4u
N#define CYFLD_PRGIO_PRT_DU_SIZE__OFFSET 0x00000000u
N#define CYFLD_PRGIO_PRT_DU_SIZE__SIZE 0x00000003u
N#define CYFLD_PRGIO_PRT_DU_OPC__OFFSET 0x00000008u
N#define CYFLD_PRGIO_PRT_DU_OPC__SIZE 0x00000004u
N#define CYREG_PRGIO_PRT0_DATA 0x400500f0u
N#define CYFLD_PRGIO_PRT_DATA__OFFSET 0x00000000u
N#define CYFLD_PRGIO_PRT_DATA__SIZE 0x00000008u
N#define CYDEV_PRGIO_PRT1_BASE 0x40050100u
N#define CYDEV_PRGIO_PRT1_SIZE 0x00000100u
N#define CYREG_PRGIO_PRT1_CTL 0x40050100u
N#define CYREG_PRGIO_PRT1_SYNC_CTL 0x40050110u
N#define CYREG_PRGIO_PRT1_LUT_SEL0 0x40050120u
N#define CYREG_PRGIO_PRT1_LUT_SEL1 0x40050124u
N#define CYREG_PRGIO_PRT1_LUT_SEL2 0x40050128u
N#define CYREG_PRGIO_PRT1_LUT_SEL3 0x4005012cu
N#define CYREG_PRGIO_PRT1_LUT_SEL4 0x40050130u
N#define CYREG_PRGIO_PRT1_LUT_SEL5 0x40050134u
N#define CYREG_PRGIO_PRT1_LUT_SEL6 0x40050138u
N#define CYREG_PRGIO_PRT1_LUT_SEL7 0x4005013cu
N#define CYREG_PRGIO_PRT1_LUT_CTL0 0x40050140u
N#define CYREG_PRGIO_PRT1_LUT_CTL1 0x40050144u
N#define CYREG_PRGIO_PRT1_LUT_CTL2 0x40050148u
N#define CYREG_PRGIO_PRT1_LUT_CTL3 0x4005014cu
N#define CYREG_PRGIO_PRT1_LUT_CTL4 0x40050150u
N#define CYREG_PRGIO_PRT1_LUT_CTL5 0x40050154u
N#define CYREG_PRGIO_PRT1_LUT_CTL6 0x40050158u
N#define CYREG_PRGIO_PRT1_LUT_CTL7 0x4005015cu
N#define CYREG_PRGIO_PRT1_DU_SEL 0x400501c0u
N#define CYREG_PRGIO_PRT1_DU_CTL 0x400501c4u
N#define CYREG_PRGIO_PRT1_DATA 0x400501f0u
N#define CYDEV_PRGIO_PRT2_BASE 0x40050200u
N#define CYDEV_PRGIO_PRT2_SIZE 0x00000100u
N#define CYREG_PRGIO_PRT2_CTL 0x40050200u
N#define CYREG_PRGIO_PRT2_SYNC_CTL 0x40050210u
N#define CYREG_PRGIO_PRT2_LUT_SEL0 0x40050220u
N#define CYREG_PRGIO_PRT2_LUT_SEL1 0x40050224u
N#define CYREG_PRGIO_PRT2_LUT_SEL2 0x40050228u
N#define CYREG_PRGIO_PRT2_LUT_SEL3 0x4005022cu
N#define CYREG_PRGIO_PRT2_LUT_SEL4 0x40050230u
N#define CYREG_PRGIO_PRT2_LUT_SEL5 0x40050234u
N#define CYREG_PRGIO_PRT2_LUT_SEL6 0x40050238u
N#define CYREG_PRGIO_PRT2_LUT_SEL7 0x4005023cu
N#define CYREG_PRGIO_PRT2_LUT_CTL0 0x40050240u
N#define CYREG_PRGIO_PRT2_LUT_CTL1 0x40050244u
N#define CYREG_PRGIO_PRT2_LUT_CTL2 0x40050248u
N#define CYREG_PRGIO_PRT2_LUT_CTL3 0x4005024cu
N#define CYREG_PRGIO_PRT2_LUT_CTL4 0x40050250u
N#define CYREG_PRGIO_PRT2_LUT_CTL5 0x40050254u
N#define CYREG_PRGIO_PRT2_LUT_CTL6 0x40050258u
N#define CYREG_PRGIO_PRT2_LUT_CTL7 0x4005025cu
N#define CYREG_PRGIO_PRT2_DU_SEL 0x400502c0u
N#define CYREG_PRGIO_PRT2_DU_CTL 0x400502c4u
N#define CYREG_PRGIO_PRT2_DATA 0x400502f0u
N#define CYDEV_CPUSS_BASE 0x40100000u
N#define CYDEV_CPUSS_SIZE 0x00001000u
N#define CYREG_CPUSS_SYSREQ 0x40100004u
N#define CYFLD_CPUSS_SYSCALL_COMMAND__OFFSET 0x00000000u
N#define CYFLD_CPUSS_SYSCALL_COMMAND__SIZE 0x00000010u
N#define CYFLD_CPUSS_DIS_RESET_VECT_REL__OFFSET 0x0000001bu
N#define CYFLD_CPUSS_DIS_RESET_VECT_REL__SIZE 0x00000001u
N#define CYFLD_CPUSS_PRIVILEGED__OFFSET 0x0000001cu
N#define CYFLD_CPUSS_PRIVILEGED__SIZE 0x00000001u
N#define CYFLD_CPUSS_ROM_ACCESS_EN__OFFSET 0x0000001du
N#define CYFLD_CPUSS_ROM_ACCESS_EN__SIZE 0x00000001u
N#define CYFLD_CPUSS_HMASTER_0__OFFSET 0x0000001eu
N#define CYFLD_CPUSS_HMASTER_0__SIZE 0x00000001u
N#define CYFLD_CPUSS_SYSCALL_REQ__OFFSET 0x0000001fu
N#define CYFLD_CPUSS_SYSCALL_REQ__SIZE 0x00000001u
N#define CYREG_CPUSS_SYSARG 0x40100008u
N#define CYFLD_CPUSS_SYSCALL_ARG__OFFSET 0x00000000u
N#define CYFLD_CPUSS_SYSCALL_ARG__SIZE 0x00000020u
N#define CYREG_CPUSS_PROTECTION 0x4010000cu
N#define CYFLD_CPUSS_PROTECTION_MODE__OFFSET 0x00000000u
N#define CYFLD_CPUSS_PROTECTION_MODE__SIZE 0x00000004u
N#define CYFLD_CPUSS_FLASH_LOCK__OFFSET 0x0000001eu
N#define CYFLD_CPUSS_FLASH_LOCK__SIZE 0x00000001u
N#define CYFLD_CPUSS_PROTECTION_LOCK__OFFSET 0x0000001fu
N#define CYFLD_CPUSS_PROTECTION_LOCK__SIZE 0x00000001u
N#define CYREG_CPUSS_PRIV_ROM 0x40100010u
N#define CYFLD_CPUSS_BROM_PROT_LIMIT__OFFSET 0x00000000u
N#define CYFLD_CPUSS_BROM_PROT_LIMIT__SIZE 0x00000008u
N#define CYREG_CPUSS_PRIV_RAM 0x40100014u
N#define CYFLD_CPUSS_RAM_PROT_LIMIT__OFFSET 0x00000000u
N#define CYFLD_CPUSS_RAM_PROT_LIMIT__SIZE 0x00000009u
N#define CYREG_CPUSS_PRIV_FLASH 0x40100018u
N#define CYFLD_CPUSS_FLASH_PROT_LIMIT__OFFSET 0x00000000u
N#define CYFLD_CPUSS_FLASH_PROT_LIMIT__SIZE 0x0000000cu
N#define CYREG_CPUSS_WOUNDING 0x4010001cu
N#define CYFLD_CPUSS_RAM_WOUND__OFFSET 0x00000010u
N#define CYFLD_CPUSS_RAM_WOUND__SIZE 0x00000003u
N#define CYFLD_CPUSS_FLASH_WOUND__OFFSET 0x00000014u
N#define CYFLD_CPUSS_FLASH_WOUND__SIZE 0x00000003u
N#define CYREG_CPUSS_FLASH_CTL 0x40100030u
N#define CYFLD_CPUSS_FLASH_WS__OFFSET 0x00000000u
N#define CYFLD_CPUSS_FLASH_WS__SIZE 0x00000002u
N#define CYFLD_CPUSS_PREF_EN__OFFSET 0x00000004u
N#define CYFLD_CPUSS_PREF_EN__SIZE 0x00000001u
N#define CYFLD_CPUSS_FLASH_INVALIDATE__OFFSET 0x00000008u
N#define CYFLD_CPUSS_FLASH_INVALIDATE__SIZE 0x00000001u
N#define CYFLD_CPUSS_ARB__OFFSET 0x00000010u
N#define CYFLD_CPUSS_ARB__SIZE 0x00000002u
N#define CYREG_CPUSS_ROM_CTL 0x40100034u
N#define CYFLD_CPUSS_ROM_WS__OFFSET 0x00000000u
N#define CYFLD_CPUSS_ROM_WS__SIZE 0x00000001u
N#define CYREG_CPUSS_RAM_CTL 0x40100038u
N#define CYREG_CPUSS_DMAC_CTL 0x4010003cu
N#define CYREG_CPUSS_SL_CTL0 0x40100100u
N#define CYREG_CPUSS_SL_CTL1 0x40100104u
N#define CYREG_CPUSS_SL_CTL2 0x40100108u
N#define CYDEV_DMAC_BASE 0x40101000u
N#define CYDEV_DMAC_SIZE 0x00001000u
N#define CYREG_DMAC_CTL 0x40101000u
N#define CYFLD_DMAC_ENABLED__OFFSET 0x0000001fu
N#define CYFLD_DMAC_ENABLED__SIZE 0x00000001u
N#define CYREG_DMAC_STATUS 0x40101010u
N#define CYFLD_DMAC_DATA_NR__OFFSET 0x00000000u
N#define CYFLD_DMAC_DATA_NR__SIZE 0x00000010u
N#define CYFLD_DMAC_CH_ADDR__OFFSET 0x00000010u
N#define CYFLD_DMAC_CH_ADDR__SIZE 0x00000003u
N#define CYFLD_DMAC_STATE__OFFSET 0x00000018u
N#define CYFLD_DMAC_STATE__SIZE 0x00000003u
N#define CYFLD_DMAC_PRIO__OFFSET 0x0000001cu
N#define CYFLD_DMAC_PRIO__SIZE 0x00000002u
N#define CYFLD_DMAC_PING_PONG__OFFSET 0x0000001eu
N#define CYFLD_DMAC_PING_PONG__SIZE 0x00000001u
N#define CYFLD_DMAC_ACTIVE__OFFSET 0x0000001fu
N#define CYFLD_DMAC_ACTIVE__SIZE 0x00000001u
N#define CYREG_DMAC_STATUS_SRC_ADDR 0x40101014u
N#define CYFLD_DMAC_ADDR__OFFSET 0x00000000u
N#define CYFLD_DMAC_ADDR__SIZE 0x00000020u
N#define CYREG_DMAC_STATUS_DST_ADDR 0x40101018u
N#define CYREG_DMAC_STATUS_CH_ACT 0x4010101cu
N#define CYFLD_DMAC_CH__OFFSET 0x00000000u
N#define CYFLD_DMAC_CH__SIZE 0x00000008u
N#define CYREG_DMAC_CH_CTL0 0x40101080u
N#define CYREG_DMAC_CH_CTL1 0x40101084u
N#define CYREG_DMAC_CH_CTL2 0x40101088u
N#define CYREG_DMAC_CH_CTL3 0x4010108cu
N#define CYREG_DMAC_CH_CTL4 0x40101090u
N#define CYREG_DMAC_CH_CTL5 0x40101094u
N#define CYREG_DMAC_CH_CTL6 0x40101098u
N#define CYREG_DMAC_CH_CTL7 0x4010109cu
N#define CYREG_DMAC_INTR 0x401017f0u
N#define CYREG_DMAC_INTR_SET 0x401017f4u
N#define CYREG_DMAC_INTR_MASK 0x401017f8u
N#define CYREG_DMAC_INTR_MASKED 0x401017fcu
N#define CYDEV_DMAC_DESCR0_BASE 0x40101800u
N#define CYDEV_DMAC_DESCR0_SIZE 0x00000020u
N#define CYREG_DMAC_DESCR0_PING_SRC 0x40101800u
N#define CYFLD_DMAC_DESCR_ADDR__OFFSET 0x00000000u
N#define CYFLD_DMAC_DESCR_ADDR__SIZE 0x00000020u
N#define CYREG_DMAC_DESCR0_PING_DST 0x40101804u
N#define CYREG_DMAC_DESCR0_PING_CTL 0x40101808u
N#define CYFLD_DMAC_DESCR_DATA_NR__OFFSET 0x00000000u
N#define CYFLD_DMAC_DESCR_DATA_NR__SIZE 0x00000010u
N#define CYFLD_DMAC_DESCR_DATA_SIZE__OFFSET 0x00000010u
N#define CYFLD_DMAC_DESCR_DATA_SIZE__SIZE 0x00000002u
N#define CYFLD_DMAC_DESCR_DST_TRANSFER_SIZE__OFFSET 0x00000014u
N#define CYFLD_DMAC_DESCR_DST_TRANSFER_SIZE__SIZE 0x00000001u
N#define CYFLD_DMAC_DESCR_DST_ADDR_INCR__OFFSET 0x00000015u
N#define CYFLD_DMAC_DESCR_DST_ADDR_INCR__SIZE 0x00000001u
N#define CYFLD_DMAC_DESCR_SRC_TRANSFER_SIZE__OFFSET 0x00000016u
N#define CYFLD_DMAC_DESCR_SRC_TRANSFER_SIZE__SIZE 0x00000001u
N#define CYFLD_DMAC_DESCR_SRC_ADDR_INCR__OFFSET 0x00000017u
N#define CYFLD_DMAC_DESCR_SRC_ADDR_INCR__SIZE 0x00000001u
N#define CYFLD_DMAC_DESCR_WAIT_FOR_DEACT__OFFSET 0x00000018u
N#define CYFLD_DMAC_DESCR_WAIT_FOR_DEACT__SIZE 0x00000002u
N#define CYFLD_DMAC_DESCR_INV_DESCR__OFFSET 0x0000001au
N#define CYFLD_DMAC_DESCR_INV_DESCR__SIZE 0x00000001u
N#define CYFLD_DMAC_DESCR_SET_CAUSE__OFFSET 0x0000001bu
N#define CYFLD_DMAC_DESCR_SET_CAUSE__SIZE 0x00000001u
N#define CYFLD_DMAC_DESCR_PREEMPTABLE__OFFSET 0x0000001cu
N#define CYFLD_DMAC_DESCR_PREEMPTABLE__SIZE 0x00000001u
N#define CYFLD_DMAC_DESCR_FLIPPING__OFFSET 0x0000001du
N#define CYFLD_DMAC_DESCR_FLIPPING__SIZE 0x00000001u
N#define CYFLD_DMAC_DESCR_OPCODE__OFFSET 0x0000001eu
N#define CYFLD_DMAC_DESCR_OPCODE__SIZE 0x00000002u
N#define CYREG_DMAC_DESCR0_PING_STATUS 0x4010180cu
N#define CYFLD_DMAC_DESCR_CURR_DATA_NR__OFFSET 0x00000000u
N#define CYFLD_DMAC_DESCR_CURR_DATA_NR__SIZE 0x00000010u
N#define CYFLD_DMAC_DESCR_RESPONSE__OFFSET 0x00000010u
N#define CYFLD_DMAC_DESCR_RESPONSE__SIZE 0x00000003u
N#define CYFLD_DMAC_DESCR_VALID__OFFSET 0x0000001fu
N#define CYFLD_DMAC_DESCR_VALID__SIZE 0x00000001u
N#define CYREG_DMAC_DESCR0_PONG_SRC 0x40101810u
N#define CYREG_DMAC_DESCR0_PONG_DST 0x40101814u
N#define CYREG_DMAC_DESCR0_PONG_CTL 0x40101818u
N#define CYREG_DMAC_DESCR0_PONG_STATUS 0x4010181cu
N#define CYDEV_DMAC_DESCR1_BASE 0x40101820u
N#define CYDEV_DMAC_DESCR1_SIZE 0x00000020u
N#define CYREG_DMAC_DESCR1_PING_SRC 0x40101820u
N#define CYREG_DMAC_DESCR1_PING_DST 0x40101824u
N#define CYREG_DMAC_DESCR1_PING_CTL 0x40101828u
N#define CYREG_DMAC_DESCR1_PING_STATUS 0x4010182cu
N#define CYREG_DMAC_DESCR1_PONG_SRC 0x40101830u
N#define CYREG_DMAC_DESCR1_PONG_DST 0x40101834u
N#define CYREG_DMAC_DESCR1_PONG_CTL 0x40101838u
N#define CYREG_DMAC_DESCR1_PONG_STATUS 0x4010183cu
N#define CYDEV_DMAC_DESCR2_BASE 0x40101840u
N#define CYDEV_DMAC_DESCR2_SIZE 0x00000020u
N#define CYREG_DMAC_DESCR2_PING_SRC 0x40101840u
N#define CYREG_DMAC_DESCR2_PING_DST 0x40101844u
N#define CYREG_DMAC_DESCR2_PING_CTL 0x40101848u
N#define CYREG_DMAC_DESCR2_PING_STATUS 0x4010184cu
N#define CYREG_DMAC_DESCR2_PONG_SRC 0x40101850u
N#define CYREG_DMAC_DESCR2_PONG_DST 0x40101854u
N#define CYREG_DMAC_DESCR2_PONG_CTL 0x40101858u
N#define CYREG_DMAC_DESCR2_PONG_STATUS 0x4010185cu
N#define CYDEV_DMAC_DESCR3_BASE 0x40101860u
N#define CYDEV_DMAC_DESCR3_SIZE 0x00000020u
N#define CYREG_DMAC_DESCR3_PING_SRC 0x40101860u
N#define CYREG_DMAC_DESCR3_PING_DST 0x40101864u
N#define CYREG_DMAC_DESCR3_PING_CTL 0x40101868u
N#define CYREG_DMAC_DESCR3_PING_STATUS 0x4010186cu
N#define CYREG_DMAC_DESCR3_PONG_SRC 0x40101870u
N#define CYREG_DMAC_DESCR3_PONG_DST 0x40101874u
N#define CYREG_DMAC_DESCR3_PONG_CTL 0x40101878u
N#define CYREG_DMAC_DESCR3_PONG_STATUS 0x4010187cu
N#define CYDEV_DMAC_DESCR4_BASE 0x40101880u
N#define CYDEV_DMAC_DESCR4_SIZE 0x00000020u
N#define CYREG_DMAC_DESCR4_PING_SRC 0x40101880u
N#define CYREG_DMAC_DESCR4_PING_DST 0x40101884u
N#define CYREG_DMAC_DESCR4_PING_CTL 0x40101888u
N#define CYREG_DMAC_DESCR4_PING_STATUS 0x4010188cu
N#define CYREG_DMAC_DESCR4_PONG_SRC 0x40101890u
N#define CYREG_DMAC_DESCR4_PONG_DST 0x40101894u
N#define CYREG_DMAC_DESCR4_PONG_CTL 0x40101898u
N#define CYREG_DMAC_DESCR4_PONG_STATUS 0x4010189cu
N#define CYDEV_DMAC_DESCR5_BASE 0x401018a0u
N#define CYDEV_DMAC_DESCR5_SIZE 0x00000020u
N#define CYREG_DMAC_DESCR5_PING_SRC 0x401018a0u
N#define CYREG_DMAC_DESCR5_PING_DST 0x401018a4u
N#define CYREG_DMAC_DESCR5_PING_CTL 0x401018a8u
N#define CYREG_DMAC_DESCR5_PING_STATUS 0x401018acu
N#define CYREG_DMAC_DESCR5_PONG_SRC 0x401018b0u
N#define CYREG_DMAC_DESCR5_PONG_DST 0x401018b4u
N#define CYREG_DMAC_DESCR5_PONG_CTL 0x401018b8u
N#define CYREG_DMAC_DESCR5_PONG_STATUS 0x401018bcu
N#define CYDEV_DMAC_DESCR6_BASE 0x401018c0u
N#define CYDEV_DMAC_DESCR6_SIZE 0x00000020u
N#define CYREG_DMAC_DESCR6_PING_SRC 0x401018c0u
N#define CYREG_DMAC_DESCR6_PING_DST 0x401018c4u
N#define CYREG_DMAC_DESCR6_PING_CTL 0x401018c8u
N#define CYREG_DMAC_DESCR6_PING_STATUS 0x401018ccu
N#define CYREG_DMAC_DESCR6_PONG_SRC 0x401018d0u
N#define CYREG_DMAC_DESCR6_PONG_DST 0x401018d4u
N#define CYREG_DMAC_DESCR6_PONG_CTL 0x401018d8u
N#define CYREG_DMAC_DESCR6_PONG_STATUS 0x401018dcu
N#define CYDEV_DMAC_DESCR7_BASE 0x401018e0u
N#define CYDEV_DMAC_DESCR7_SIZE 0x00000020u
N#define CYREG_DMAC_DESCR7_PING_SRC 0x401018e0u
N#define CYREG_DMAC_DESCR7_PING_DST 0x401018e4u
N#define CYREG_DMAC_DESCR7_PING_CTL 0x401018e8u
N#define CYREG_DMAC_DESCR7_PING_STATUS 0x401018ecu
N#define CYREG_DMAC_DESCR7_PONG_SRC 0x401018f0u
N#define CYREG_DMAC_DESCR7_PONG_DST 0x401018f4u
N#define CYREG_DMAC_DESCR7_PONG_CTL 0x401018f8u
N#define CYREG_DMAC_DESCR7_PONG_STATUS 0x401018fcu
N#define CYDEV_SPCIF_BASE 0x40110000u
N#define CYDEV_SPCIF_SIZE 0x00010000u
N#define CYREG_SPCIF_GEOMETRY 0x40110000u
N#define CYFLD_SPCIF_FLASH__OFFSET 0x00000000u
N#define CYFLD_SPCIF_FLASH__SIZE 0x0000000eu
N#define CYFLD_SPCIF_SFLASH__OFFSET 0x0000000eu
N#define CYFLD_SPCIF_SFLASH__SIZE 0x00000006u
N#define CYFLD_SPCIF_NUM_FLASH__OFFSET 0x00000014u
N#define CYFLD_SPCIF_NUM_FLASH__SIZE 0x00000002u
N#define CYFLD_SPCIF_FLASH_ROW__OFFSET 0x00000016u
N#define CYFLD_SPCIF_FLASH_ROW__SIZE 0x00000002u
N#define CYFLD_SPCIF_DE_CPD_LP__OFFSET 0x0000001fu
N#define CYFLD_SPCIF_DE_CPD_LP__SIZE 0x00000001u
N#define CYREG_SPCIF_INTR 0x401107f0u
N#define CYFLD_SPCIF_TIMER__OFFSET 0x00000000u
N#define CYFLD_SPCIF_TIMER__SIZE 0x00000001u
N#define CYREG_SPCIF_INTR_SET 0x401107f4u
N#define CYREG_SPCIF_INTR_MASK 0x401107f8u
N#define CYREG_SPCIF_INTR_MASKED 0x401107fcu
N#define CYDEV_TCPWM_BASE 0x40200000u
N#define CYDEV_TCPWM_SIZE 0x00010000u
N#define CYREG_TCPWM_CTRL 0x40200000u
N#define CYFLD_TCPWM_COUNTER_ENABLED__OFFSET 0x00000000u
N#define CYFLD_TCPWM_COUNTER_ENABLED__SIZE 0x00000008u
N#define CYREG_TCPWM_CMD 0x40200008u
N#define CYFLD_TCPWM_COUNTER_CAPTURE__OFFSET 0x00000000u
N#define CYFLD_TCPWM_COUNTER_CAPTURE__SIZE 0x00000008u
N#define CYFLD_TCPWM_COUNTER_RELOAD__OFFSET 0x00000008u
N#define CYFLD_TCPWM_COUNTER_RELOAD__SIZE 0x00000008u
N#define CYFLD_TCPWM_COUNTER_STOP__OFFSET 0x00000010u
N#define CYFLD_TCPWM_COUNTER_STOP__SIZE 0x00000008u
N#define CYFLD_TCPWM_COUNTER_START__OFFSET 0x00000018u
N#define CYFLD_TCPWM_COUNTER_START__SIZE 0x00000008u
N#define CYREG_TCPWM_INTR_CAUSE 0x4020000cu
N#define CYFLD_TCPWM_COUNTER_INT__OFFSET 0x00000000u
N#define CYFLD_TCPWM_COUNTER_INT__SIZE 0x00000008u
N#define CYDEV_TCPWM_CNT0_BASE 0x40200100u
N#define CYDEV_TCPWM_CNT0_SIZE 0x00000040u
N#define CYREG_TCPWM_CNT0_CTRL 0x40200100u
N#define CYFLD_TCPWM_CNT_AUTO_RELOAD_CC__OFFSET 0x00000000u
N#define CYFLD_TCPWM_CNT_AUTO_RELOAD_CC__SIZE 0x00000001u
N#define CYFLD_TCPWM_CNT_AUTO_RELOAD_PERIOD__OFFSET 0x00000001u
N#define CYFLD_TCPWM_CNT_AUTO_RELOAD_PERIOD__SIZE 0x00000001u
N#define CYFLD_TCPWM_CNT_PWM_SYNC_KILL__OFFSET 0x00000002u
N#define CYFLD_TCPWM_CNT_PWM_SYNC_KILL__SIZE 0x00000001u
N#define CYFLD_TCPWM_CNT_PWM_STOP_ON_KILL__OFFSET 0x00000003u
N#define CYFLD_TCPWM_CNT_PWM_STOP_ON_KILL__SIZE 0x00000001u
N#define CYFLD_TCPWM_CNT_GENERIC__OFFSET 0x00000008u
N#define CYFLD_TCPWM_CNT_GENERIC__SIZE 0x00000008u
N#define CYVAL_TCPWM_CNT_GENERIC_DIVBY1 0x00000000u
N#define CYVAL_TCPWM_CNT_GENERIC_DIVBY2 0x00000001u
N#define CYVAL_TCPWM_CNT_GENERIC_DIVBY4 0x00000002u
N#define CYVAL_TCPWM_CNT_GENERIC_DIVBY8 0x00000003u
N#define CYVAL_TCPWM_CNT_GENERIC_DIVBY16 0x00000004u
N#define CYVAL_TCPWM_CNT_GENERIC_DIVBY32 0x00000005u
N#define CYVAL_TCPWM_CNT_GENERIC_DIVBY64 0x00000006u
N#define CYVAL_TCPWM_CNT_GENERIC_DIVBY128 0x00000007u
N#define CYFLD_TCPWM_CNT_UP_DOWN_MODE__OFFSET 0x00000010u
N#define CYFLD_TCPWM_CNT_UP_DOWN_MODE__SIZE 0x00000002u
N#define CYVAL_TCPWM_CNT_UP_DOWN_MODE_COUNT_UP 0x00000000u
N#define CYVAL_TCPWM_CNT_UP_DOWN_MODE_COUNT_DOWN 0x00000001u
N#define CYVAL_TCPWM_CNT_UP_DOWN_MODE_COUNT_UPDN1 0x00000002u
N#define CYVAL_TCPWM_CNT_UP_DOWN_MODE_COUNT_UPDN2 0x00000003u
N#define CYFLD_TCPWM_CNT_ONE_SHOT__OFFSET 0x00000012u
N#define CYFLD_TCPWM_CNT_ONE_SHOT__SIZE 0x00000001u
N#define CYFLD_TCPWM_CNT_QUADRATURE_MODE__OFFSET 0x00000014u
N#define CYFLD_TCPWM_CNT_QUADRATURE_MODE__SIZE 0x00000002u
N#define CYVAL_TCPWM_CNT_QUADRATURE_MODE_X1 0x00000000u
N#define CYVAL_TCPWM_CNT_QUADRATURE_MODE_X2 0x00000001u
N#define CYVAL_TCPWM_CNT_QUADRATURE_MODE_X4 0x00000002u
N#define CYVAL_TCPWM_CNT_QUADRATURE_MODE_INV_OUT 0x00000001u
N#define CYVAL_TCPWM_CNT_QUADRATURE_MODE_INV_COMPL_OUT 0x00000002u
N#define CYFLD_TCPWM_CNT_MODE__OFFSET 0x00000018u
N#define CYFLD_TCPWM_CNT_MODE__SIZE 0x00000003u
N#define CYVAL_TCPWM_CNT_MODE_TIMER 0x00000000u
N#define CYVAL_TCPWM_CNT_MODE_CAPTURE 0x00000002u
N#define CYVAL_TCPWM_CNT_MODE_QUAD 0x00000003u
N#define CYVAL_TCPWM_CNT_MODE_PWM 0x00000004u
N#define CYVAL_TCPWM_CNT_MODE_PWM_DT 0x00000005u
N#define CYVAL_TCPWM_CNT_MODE_PWM_PR 0x00000006u
N#define CYREG_TCPWM_CNT0_STATUS 0x40200104u
N#define CYFLD_TCPWM_CNT_DOWN__OFFSET 0x00000000u
N#define CYFLD_TCPWM_CNT_DOWN__SIZE 0x00000001u
N#define CYFLD_TCPWM_CNT_RUNNING__OFFSET 0x0000001fu
N#define CYFLD_TCPWM_CNT_RUNNING__SIZE 0x00000001u
N#define CYREG_TCPWM_CNT0_COUNTER 0x40200108u
N#define CYFLD_TCPWM_CNT_COUNTER__OFFSET 0x00000000u
N#define CYFLD_TCPWM_CNT_COUNTER__SIZE 0x00000010u
N#define CYREG_TCPWM_CNT0_CC 0x4020010cu
N#define CYFLD_TCPWM_CNT_CC__OFFSET 0x00000000u
N#define CYFLD_TCPWM_CNT_CC__SIZE 0x00000010u
N#define CYREG_TCPWM_CNT0_CC_BUFF 0x40200110u
N#define CYREG_TCPWM_CNT0_PERIOD 0x40200114u
N#define CYFLD_TCPWM_CNT_PERIOD__OFFSET 0x00000000u
N#define CYFLD_TCPWM_CNT_PERIOD__SIZE 0x00000010u
N#define CYREG_TCPWM_CNT0_PERIOD_BUFF 0x40200118u
N#define CYREG_TCPWM_CNT0_TR_CTRL0 0x40200120u
N#define CYFLD_TCPWM_CNT_CAPTURE_SEL__OFFSET 0x00000000u
N#define CYFLD_TCPWM_CNT_CAPTURE_SEL__SIZE 0x00000004u
N#define CYFLD_TCPWM_CNT_COUNT_SEL__OFFSET 0x00000004u
N#define CYFLD_TCPWM_CNT_COUNT_SEL__SIZE 0x00000004u
N#define CYFLD_TCPWM_CNT_RELOAD_SEL__OFFSET 0x00000008u
N#define CYFLD_TCPWM_CNT_RELOAD_SEL__SIZE 0x00000004u
N#define CYFLD_TCPWM_CNT_STOP_SEL__OFFSET 0x0000000cu
N#define CYFLD_TCPWM_CNT_STOP_SEL__SIZE 0x00000004u
N#define CYFLD_TCPWM_CNT_START_SEL__OFFSET 0x00000010u
N#define CYFLD_TCPWM_CNT_START_SEL__SIZE 0x00000004u
N#define CYREG_TCPWM_CNT0_TR_CTRL1 0x40200124u
N#define CYFLD_TCPWM_CNT_CAPTURE_EDGE__OFFSET 0x00000000u
N#define CYFLD_TCPWM_CNT_CAPTURE_EDGE__SIZE 0x00000002u
N#define CYVAL_TCPWM_CNT_CAPTURE_EDGE_RISING_EDGE 0x00000000u
N#define CYVAL_TCPWM_CNT_CAPTURE_EDGE_FALLING_EDGE 0x00000001u
N#define CYVAL_TCPWM_CNT_CAPTURE_EDGE_BOTH_EDGES 0x00000002u
N#define CYVAL_TCPWM_CNT_CAPTURE_EDGE_NO_EDGE_DET 0x00000003u
N#define CYFLD_TCPWM_CNT_COUNT_EDGE__OFFSET 0x00000002u
N#define CYFLD_TCPWM_CNT_COUNT_EDGE__SIZE 0x00000002u
N#define CYVAL_TCPWM_CNT_COUNT_EDGE_RISING_EDGE 0x00000000u
N#define CYVAL_TCPWM_CNT_COUNT_EDGE_FALLING_EDGE 0x00000001u
N#define CYVAL_TCPWM_CNT_COUNT_EDGE_BOTH_EDGES 0x00000002u
N#define CYVAL_TCPWM_CNT_COUNT_EDGE_NO_EDGE_DET 0x00000003u
N#define CYFLD_TCPWM_CNT_RELOAD_EDGE__OFFSET 0x00000004u
N#define CYFLD_TCPWM_CNT_RELOAD_EDGE__SIZE 0x00000002u
N#define CYVAL_TCPWM_CNT_RELOAD_EDGE_RISING_EDGE 0x00000000u
N#define CYVAL_TCPWM_CNT_RELOAD_EDGE_FALLING_EDGE 0x00000001u
N#define CYVAL_TCPWM_CNT_RELOAD_EDGE_BOTH_EDGES 0x00000002u
N#define CYVAL_TCPWM_CNT_RELOAD_EDGE_NO_EDGE_DET 0x00000003u
N#define CYFLD_TCPWM_CNT_STOP_EDGE__OFFSET 0x00000006u
N#define CYFLD_TCPWM_CNT_STOP_EDGE__SIZE 0x00000002u
N#define CYVAL_TCPWM_CNT_STOP_EDGE_RISING_EDGE 0x00000000u
N#define CYVAL_TCPWM_CNT_STOP_EDGE_FALLING_EDGE 0x00000001u
N#define CYVAL_TCPWM_CNT_STOP_EDGE_BOTH_EDGES 0x00000002u
N#define CYVAL_TCPWM_CNT_STOP_EDGE_NO_EDGE_DET 0x00000003u
N#define CYFLD_TCPWM_CNT_START_EDGE__OFFSET 0x00000008u
N#define CYFLD_TCPWM_CNT_START_EDGE__SIZE 0x00000002u
N#define CYVAL_TCPWM_CNT_START_EDGE_RISING_EDGE 0x00000000u
N#define CYVAL_TCPWM_CNT_START_EDGE_FALLING_EDGE 0x00000001u
N#define CYVAL_TCPWM_CNT_START_EDGE_BOTH_EDGES 0x00000002u
N#define CYVAL_TCPWM_CNT_START_EDGE_NO_EDGE_DET 0x00000003u
N#define CYREG_TCPWM_CNT0_TR_CTRL2 0x40200128u
N#define CYFLD_TCPWM_CNT_CC_MATCH_MODE__OFFSET 0x00000000u
N#define CYFLD_TCPWM_CNT_CC_MATCH_MODE__SIZE 0x00000002u
N#define CYVAL_TCPWM_CNT_CC_MATCH_MODE_SET 0x00000000u
N#define CYVAL_TCPWM_CNT_CC_MATCH_MODE_CLEAR 0x00000001u
N#define CYVAL_TCPWM_CNT_CC_MATCH_MODE_INVERT 0x00000002u
N#define CYVAL_TCPWM_CNT_CC_MATCH_MODE_NO_CHANGE 0x00000003u
N#define CYFLD_TCPWM_CNT_OVERFLOW_MODE__OFFSET 0x00000002u
N#define CYFLD_TCPWM_CNT_OVERFLOW_MODE__SIZE 0x00000002u
N#define CYVAL_TCPWM_CNT_OVERFLOW_MODE_SET 0x00000000u
N#define CYVAL_TCPWM_CNT_OVERFLOW_MODE_CLEAR 0x00000001u
N#define CYVAL_TCPWM_CNT_OVERFLOW_MODE_INVERT 0x00000002u
N#define CYVAL_TCPWM_CNT_OVERFLOW_MODE_NO_CHANGE 0x00000003u
N#define CYFLD_TCPWM_CNT_UNDERFLOW_MODE__OFFSET 0x00000004u
N#define CYFLD_TCPWM_CNT_UNDERFLOW_MODE__SIZE 0x00000002u
N#define CYVAL_TCPWM_CNT_UNDERFLOW_MODE_SET 0x00000000u
N#define CYVAL_TCPWM_CNT_UNDERFLOW_MODE_CLEAR 0x00000001u
N#define CYVAL_TCPWM_CNT_UNDERFLOW_MODE_INVERT 0x00000002u
N#define CYVAL_TCPWM_CNT_UNDERFLOW_MODE_NO_CHANGE 0x00000003u
N#define CYREG_TCPWM_CNT0_INTR 0x40200130u
N#define CYFLD_TCPWM_CNT_TC__OFFSET 0x00000000u
N#define CYFLD_TCPWM_CNT_TC__SIZE 0x00000001u
N#define CYFLD_TCPWM_CNT_CC_MATCH__OFFSET 0x00000001u
N#define CYFLD_TCPWM_CNT_CC_MATCH__SIZE 0x00000001u
N#define CYREG_TCPWM_CNT0_INTR_SET 0x40200134u
N#define CYREG_TCPWM_CNT0_INTR_MASK 0x40200138u
N#define CYREG_TCPWM_CNT0_INTR_MASKED 0x4020013cu
N#define CYDEV_TCPWM_CNT1_BASE 0x40200140u
N#define CYDEV_TCPWM_CNT1_SIZE 0x00000040u
N#define CYREG_TCPWM_CNT1_CTRL 0x40200140u
N#define CYREG_TCPWM_CNT1_STATUS 0x40200144u
N#define CYREG_TCPWM_CNT1_COUNTER 0x40200148u
N#define CYREG_TCPWM_CNT1_CC 0x4020014cu
N#define CYREG_TCPWM_CNT1_CC_BUFF 0x40200150u
N#define CYREG_TCPWM_CNT1_PERIOD 0x40200154u
N#define CYREG_TCPWM_CNT1_PERIOD_BUFF 0x40200158u
N#define CYREG_TCPWM_CNT1_TR_CTRL0 0x40200160u
N#define CYREG_TCPWM_CNT1_TR_CTRL1 0x40200164u
N#define CYREG_TCPWM_CNT1_TR_CTRL2 0x40200168u
N#define CYREG_TCPWM_CNT1_INTR 0x40200170u
N#define CYREG_TCPWM_CNT1_INTR_SET 0x40200174u
N#define CYREG_TCPWM_CNT1_INTR_MASK 0x40200178u
N#define CYREG_TCPWM_CNT1_INTR_MASKED 0x4020017cu
N#define CYDEV_TCPWM_CNT2_BASE 0x40200180u
N#define CYDEV_TCPWM_CNT2_SIZE 0x00000040u
N#define CYREG_TCPWM_CNT2_CTRL 0x40200180u
N#define CYREG_TCPWM_CNT2_STATUS 0x40200184u
N#define CYREG_TCPWM_CNT2_COUNTER 0x40200188u
N#define CYREG_TCPWM_CNT2_CC 0x4020018cu
N#define CYREG_TCPWM_CNT2_CC_BUFF 0x40200190u
N#define CYREG_TCPWM_CNT2_PERIOD 0x40200194u
N#define CYREG_TCPWM_CNT2_PERIOD_BUFF 0x40200198u
N#define CYREG_TCPWM_CNT2_TR_CTRL0 0x402001a0u
N#define CYREG_TCPWM_CNT2_TR_CTRL1 0x402001a4u
N#define CYREG_TCPWM_CNT2_TR_CTRL2 0x402001a8u
N#define CYREG_TCPWM_CNT2_INTR 0x402001b0u
N#define CYREG_TCPWM_CNT2_INTR_SET 0x402001b4u
N#define CYREG_TCPWM_CNT2_INTR_MASK 0x402001b8u
N#define CYREG_TCPWM_CNT2_INTR_MASKED 0x402001bcu
N#define CYDEV_TCPWM_CNT3_BASE 0x402001c0u
N#define CYDEV_TCPWM_CNT3_SIZE 0x00000040u
N#define CYREG_TCPWM_CNT3_CTRL 0x402001c0u
N#define CYREG_TCPWM_CNT3_STATUS 0x402001c4u
N#define CYREG_TCPWM_CNT3_COUNTER 0x402001c8u
N#define CYREG_TCPWM_CNT3_CC 0x402001ccu
N#define CYREG_TCPWM_CNT3_CC_BUFF 0x402001d0u
N#define CYREG_TCPWM_CNT3_PERIOD 0x402001d4u
N#define CYREG_TCPWM_CNT3_PERIOD_BUFF 0x402001d8u
N#define CYREG_TCPWM_CNT3_TR_CTRL0 0x402001e0u
N#define CYREG_TCPWM_CNT3_TR_CTRL1 0x402001e4u
N#define CYREG_TCPWM_CNT3_TR_CTRL2 0x402001e8u
N#define CYREG_TCPWM_CNT3_INTR 0x402001f0u
N#define CYREG_TCPWM_CNT3_INTR_SET 0x402001f4u
N#define CYREG_TCPWM_CNT3_INTR_MASK 0x402001f8u
N#define CYREG_TCPWM_CNT3_INTR_MASKED 0x402001fcu
N#define CYDEV_TCPWM_CNT4_BASE 0x40200200u
N#define CYDEV_TCPWM_CNT4_SIZE 0x00000040u
N#define CYREG_TCPWM_CNT4_CTRL 0x40200200u
N#define CYREG_TCPWM_CNT4_STATUS 0x40200204u
N#define CYREG_TCPWM_CNT4_COUNTER 0x40200208u
N#define CYREG_TCPWM_CNT4_CC 0x4020020cu
N#define CYREG_TCPWM_CNT4_CC_BUFF 0x40200210u
N#define CYREG_TCPWM_CNT4_PERIOD 0x40200214u
N#define CYREG_TCPWM_CNT4_PERIOD_BUFF 0x40200218u
N#define CYREG_TCPWM_CNT4_TR_CTRL0 0x40200220u
N#define CYREG_TCPWM_CNT4_TR_CTRL1 0x40200224u
N#define CYREG_TCPWM_CNT4_TR_CTRL2 0x40200228u
N#define CYREG_TCPWM_CNT4_INTR 0x40200230u
N#define CYREG_TCPWM_CNT4_INTR_SET 0x40200234u
N#define CYREG_TCPWM_CNT4_INTR_MASK 0x40200238u
N#define CYREG_TCPWM_CNT4_INTR_MASKED 0x4020023cu
N#define CYDEV_TCPWM_CNT5_BASE 0x40200240u
N#define CYDEV_TCPWM_CNT5_SIZE 0x00000040u
N#define CYREG_TCPWM_CNT5_CTRL 0x40200240u
N#define CYREG_TCPWM_CNT5_STATUS 0x40200244u
N#define CYREG_TCPWM_CNT5_COUNTER 0x40200248u
N#define CYREG_TCPWM_CNT5_CC 0x4020024cu
N#define CYREG_TCPWM_CNT5_CC_BUFF 0x40200250u
N#define CYREG_TCPWM_CNT5_PERIOD 0x40200254u
N#define CYREG_TCPWM_CNT5_PERIOD_BUFF 0x40200258u
N#define CYREG_TCPWM_CNT5_TR_CTRL0 0x40200260u
N#define CYREG_TCPWM_CNT5_TR_CTRL1 0x40200264u
N#define CYREG_TCPWM_CNT5_TR_CTRL2 0x40200268u
N#define CYREG_TCPWM_CNT5_INTR 0x40200270u
N#define CYREG_TCPWM_CNT5_INTR_SET 0x40200274u
N#define CYREG_TCPWM_CNT5_INTR_MASK 0x40200278u
N#define CYREG_TCPWM_CNT5_INTR_MASKED 0x4020027cu
N#define CYDEV_TCPWM_CNT6_BASE 0x40200280u
N#define CYDEV_TCPWM_CNT6_SIZE 0x00000040u
N#define CYREG_TCPWM_CNT6_CTRL 0x40200280u
N#define CYREG_TCPWM_CNT6_STATUS 0x40200284u
N#define CYREG_TCPWM_CNT6_COUNTER 0x40200288u
N#define CYREG_TCPWM_CNT6_CC 0x4020028cu
N#define CYREG_TCPWM_CNT6_CC_BUFF 0x40200290u
N#define CYREG_TCPWM_CNT6_PERIOD 0x40200294u
N#define CYREG_TCPWM_CNT6_PERIOD_BUFF 0x40200298u
N#define CYREG_TCPWM_CNT6_TR_CTRL0 0x402002a0u
N#define CYREG_TCPWM_CNT6_TR_CTRL1 0x402002a4u
N#define CYREG_TCPWM_CNT6_TR_CTRL2 0x402002a8u
N#define CYREG_TCPWM_CNT6_INTR 0x402002b0u
N#define CYREG_TCPWM_CNT6_INTR_SET 0x402002b4u
N#define CYREG_TCPWM_CNT6_INTR_MASK 0x402002b8u
N#define CYREG_TCPWM_CNT6_INTR_MASKED 0x402002bcu
N#define CYDEV_TCPWM_CNT7_BASE 0x402002c0u
N#define CYDEV_TCPWM_CNT7_SIZE 0x00000040u
N#define CYREG_TCPWM_CNT7_CTRL 0x402002c0u
N#define CYREG_TCPWM_CNT7_STATUS 0x402002c4u
N#define CYREG_TCPWM_CNT7_COUNTER 0x402002c8u
N#define CYREG_TCPWM_CNT7_CC 0x402002ccu
N#define CYREG_TCPWM_CNT7_CC_BUFF 0x402002d0u
N#define CYREG_TCPWM_CNT7_PERIOD 0x402002d4u
N#define CYREG_TCPWM_CNT7_PERIOD_BUFF 0x402002d8u
N#define CYREG_TCPWM_CNT7_TR_CTRL0 0x402002e0u
N#define CYREG_TCPWM_CNT7_TR_CTRL1 0x402002e4u
N#define CYREG_TCPWM_CNT7_TR_CTRL2 0x402002e8u
N#define CYREG_TCPWM_CNT7_INTR 0x402002f0u
N#define CYREG_TCPWM_CNT7_INTR_SET 0x402002f4u
N#define CYREG_TCPWM_CNT7_INTR_MASK 0x402002f8u
N#define CYREG_TCPWM_CNT7_INTR_MASKED 0x402002fcu
N#define CYDEV_WCO_BASE 0x40220000u
N#define CYDEV_WCO_SIZE 0x00010000u
N#define CYREG_WCO_CONFIG 0x40220000u
N#define CYFLD_WCO_LPM_EN__OFFSET 0x00000000u
N#define CYFLD_WCO_LPM_EN__SIZE 0x00000001u
N#define CYFLD_WCO_LPM_AUTO__OFFSET 0x00000001u
N#define CYFLD_WCO_LPM_AUTO__SIZE 0x00000001u
N#define CYFLD_WCO_EXT_INPUT_EN__OFFSET 0x00000002u
N#define CYFLD_WCO_EXT_INPUT_EN__SIZE 0x00000001u
N#define CYFLD_WCO_ENBUS__OFFSET 0x00000010u
N#define CYFLD_WCO_ENBUS__SIZE 0x00000008u
N#define CYFLD_WCO_DPLL_ENABLE__OFFSET 0x0000001eu
N#define CYFLD_WCO_DPLL_ENABLE__SIZE 0x00000001u
N#define CYFLD_WCO_IP_ENABLE__OFFSET 0x0000001fu
N#define CYFLD_WCO_IP_ENABLE__SIZE 0x00000001u
N#define CYREG_WCO_STATUS 0x40220004u
N#define CYFLD_WCO_OUT_BLNK_A__OFFSET 0x00000000u
N#define CYFLD_WCO_OUT_BLNK_A__SIZE 0x00000001u
N#define CYREG_WCO_DPLL 0x40220008u
N#define CYFLD_WCO_DPLL_MULT__OFFSET 0x00000000u
N#define CYFLD_WCO_DPLL_MULT__SIZE 0x0000000bu
N#define CYFLD_WCO_DPLL_LF_IGAIN__OFFSET 0x00000010u
N#define CYFLD_WCO_DPLL_LF_IGAIN__SIZE 0x00000003u
N#define CYFLD_WCO_DPLL_LF_PGAIN__OFFSET 0x00000013u
N#define CYFLD_WCO_DPLL_LF_PGAIN__SIZE 0x00000003u
N#define CYFLD_WCO_DPLL_LF_LIMIT__OFFSET 0x00000016u
N#define CYFLD_WCO_DPLL_LF_LIMIT__SIZE 0x00000008u
N#define CYREG_WCO_WDT_CTRLOW 0x40220200u
N#define CYFLD_WCO_WDT_CTR0__OFFSET 0x00000000u
N#define CYFLD_WCO_WDT_CTR0__SIZE 0x00000010u
N#define CYFLD_WCO_WDT_CTR1__OFFSET 0x00000010u
N#define CYFLD_WCO_WDT_CTR1__SIZE 0x00000010u
N#define CYREG_WCO_WDT_CTRHIGH 0x40220204u
N#define CYFLD_WCO_WDT_CTR2__OFFSET 0x00000000u
N#define CYFLD_WCO_WDT_CTR2__SIZE 0x00000020u
N#define CYREG_WCO_WDT_MATCH 0x40220208u
N#define CYFLD_WCO_WDT_MATCH0__OFFSET 0x00000000u
N#define CYFLD_WCO_WDT_MATCH0__SIZE 0x00000010u
N#define CYFLD_WCO_WDT_MATCH1__OFFSET 0x00000010u
N#define CYFLD_WCO_WDT_MATCH1__SIZE 0x00000010u
N#define CYREG_WCO_WDT_CONFIG 0x4022020cu
N#define CYFLD_WCO_WDT_MODE0__OFFSET 0x00000000u
N#define CYFLD_WCO_WDT_MODE0__SIZE 0x00000002u
N#define CYVAL_WCO_WDT_MODE0_NOTHING 0x00000000u
N#define CYVAL_WCO_WDT_MODE0_INT 0x00000001u
N#define CYVAL_WCO_WDT_MODE0_RESET 0x00000002u
N#define CYVAL_WCO_WDT_MODE0_INT_THEN_RESET 0x00000003u
N#define CYFLD_WCO_WDT_CLEAR0__OFFSET 0x00000002u
N#define CYFLD_WCO_WDT_CLEAR0__SIZE 0x00000001u
N#define CYFLD_WCO_WDT_CASCADE0_1__OFFSET 0x00000003u
N#define CYFLD_WCO_WDT_CASCADE0_1__SIZE 0x00000001u
N#define CYFLD_WCO_WDT_MODE1__OFFSET 0x00000008u
N#define CYFLD_WCO_WDT_MODE1__SIZE 0x00000002u
N#define CYVAL_WCO_WDT_MODE1_NOTHING 0x00000000u
N#define CYVAL_WCO_WDT_MODE1_INT 0x00000001u
N#define CYVAL_WCO_WDT_MODE1_RESET 0x00000002u
N#define CYVAL_WCO_WDT_MODE1_INT_THEN_RESET 0x00000003u
N#define CYFLD_WCO_WDT_CLEAR1__OFFSET 0x0000000au
N#define CYFLD_WCO_WDT_CLEAR1__SIZE 0x00000001u
N#define CYFLD_WCO_WDT_CASCADE1_2__OFFSET 0x0000000bu
N#define CYFLD_WCO_WDT_CASCADE1_2__SIZE 0x00000001u
N#define CYFLD_WCO_WDT_MODE2__OFFSET 0x00000010u
N#define CYFLD_WCO_WDT_MODE2__SIZE 0x00000001u
N#define CYVAL_WCO_WDT_MODE2_NOTHING 0x00000000u
N#define CYVAL_WCO_WDT_MODE2_INT 0x00000001u
N#define CYFLD_WCO_WDT_BITS2__OFFSET 0x00000018u
N#define CYFLD_WCO_WDT_BITS2__SIZE 0x00000005u
N#define CYFLD_WCO_LFCLK_SEL__OFFSET 0x0000001eu
N#define CYFLD_WCO_LFCLK_SEL__SIZE 0x00000002u
N#define CYREG_WCO_WDT_CONTROL 0x40220210u
N#define CYFLD_WCO_WDT_ENABLE0__OFFSET 0x00000000u
N#define CYFLD_WCO_WDT_ENABLE0__SIZE 0x00000001u
N#define CYFLD_WCO_WDT_ENABLED0__OFFSET 0x00000001u
N#define CYFLD_WCO_WDT_ENABLED0__SIZE 0x00000001u
N#define CYFLD_WCO_WDT_INT0__OFFSET 0x00000002u
N#define CYFLD_WCO_WDT_INT0__SIZE 0x00000001u
N#define CYFLD_WCO_WDT_RESET0__OFFSET 0x00000003u
N#define CYFLD_WCO_WDT_RESET0__SIZE 0x00000001u
N#define CYFLD_WCO_WDT_ENABLE1__OFFSET 0x00000008u
N#define CYFLD_WCO_WDT_ENABLE1__SIZE 0x00000001u
N#define CYFLD_WCO_WDT_ENABLED1__OFFSET 0x00000009u
N#define CYFLD_WCO_WDT_ENABLED1__SIZE 0x00000001u
N#define CYFLD_WCO_WDT_INT1__OFFSET 0x0000000au
N#define CYFLD_WCO_WDT_INT1__SIZE 0x00000001u
N#define CYFLD_WCO_WDT_RESET1__OFFSET 0x0000000bu
N#define CYFLD_WCO_WDT_RESET1__SIZE 0x00000001u
N#define CYFLD_WCO_WDT_ENABLE2__OFFSET 0x00000010u
N#define CYFLD_WCO_WDT_ENABLE2__SIZE 0x00000001u
N#define CYFLD_WCO_WDT_ENABLED2__OFFSET 0x00000011u
N#define CYFLD_WCO_WDT_ENABLED2__SIZE 0x00000001u
N#define CYFLD_WCO_WDT_INT2__OFFSET 0x00000012u
N#define CYFLD_WCO_WDT_INT2__SIZE 0x00000001u
N#define CYFLD_WCO_WDT_RESET2__OFFSET 0x00000013u
N#define CYFLD_WCO_WDT_RESET2__SIZE 0x00000001u
N#define CYREG_WCO_WDT_CLKEN 0x40220214u
N#define CYFLD_WCO_CLK_WCO_EN_FOR_WDT__OFFSET 0x00000000u
N#define CYFLD_WCO_CLK_WCO_EN_FOR_WDT__SIZE 0x00000001u
N#define CYFLD_WCO_CLK_ILO_EN_FOR_WDT__OFFSET 0x00000001u
N#define CYFLD_WCO_CLK_ILO_EN_FOR_WDT__SIZE 0x00000001u
N#define CYREG_WCO_TRIM 0x40220f00u
N#define CYFLD_WCO_XGM__OFFSET 0x00000000u
N#define CYFLD_WCO_XGM__SIZE 0x00000003u
N#define CYFLD_WCO_LPM_GM__OFFSET 0x00000004u
N#define CYFLD_WCO_LPM_GM__SIZE 0x00000002u
N#define CYDEV_SCB0_BASE 0x40240000u
N#define CYDEV_SCB0_SIZE 0x00010000u
N#define CYREG_SCB0_CTRL 0x40240000u
N#define CYFLD_SCB_OVS__OFFSET 0x00000000u
N#define CYFLD_SCB_OVS__SIZE 0x00000004u
N#define CYFLD_SCB_EC_AM_MODE__OFFSET 0x00000008u
N#define CYFLD_SCB_EC_AM_MODE__SIZE 0x00000001u
N#define CYFLD_SCB_EC_OP_MODE__OFFSET 0x00000009u
N#define CYFLD_SCB_EC_OP_MODE__SIZE 0x00000001u
N#define CYFLD_SCB_EZ_MODE__OFFSET 0x0000000au
N#define CYFLD_SCB_EZ_MODE__SIZE 0x00000001u
N#define CYFLD_SCB_BYTE_MODE__OFFSET 0x0000000bu
N#define CYFLD_SCB_BYTE_MODE__SIZE 0x00000001u
N#define CYFLD_SCB_ADDR_ACCEPT__OFFSET 0x00000010u
N#define CYFLD_SCB_ADDR_ACCEPT__SIZE 0x00000001u
N#define CYFLD_SCB_BLOCK__OFFSET 0x00000011u
N#define CYFLD_SCB_BLOCK__SIZE 0x00000001u
N#define CYFLD_SCB_MODE__OFFSET 0x00000018u
N#define CYFLD_SCB_MODE__SIZE 0x00000002u
N#define CYVAL_SCB_MODE_I2C 0x00000000u
N#define CYVAL_SCB_MODE_SPI 0x00000001u
N#define CYVAL_SCB_MODE_UART 0x00000002u
N#define CYFLD_SCB_ENABLED__OFFSET 0x0000001fu
N#define CYFLD_SCB_ENABLED__SIZE 0x00000001u
N#define CYREG_SCB0_STATUS 0x40240004u
N#define CYFLD_SCB_EC_BUSY__OFFSET 0x00000000u
N#define CYFLD_SCB_EC_BUSY__SIZE 0x00000001u
N#define CYREG_SCB0_SPI_CTRL 0x40240020u
N#define CYFLD_SCB_CONTINUOUS__OFFSET 0x00000000u
N#define CYFLD_SCB_CONTINUOUS__SIZE 0x00000001u
N#define CYFLD_SCB_SELECT_PRECEDE__OFFSET 0x00000001u
N#define CYFLD_SCB_SELECT_PRECEDE__SIZE 0x00000001u
N#define CYFLD_SCB_CPHA__OFFSET 0x00000002u
N#define CYFLD_SCB_CPHA__SIZE 0x00000001u
N#define CYFLD_SCB_CPOL__OFFSET 0x00000003u
N#define CYFLD_SCB_CPOL__SIZE 0x00000001u
N#define CYFLD_SCB_LATE_MISO_SAMPLE__OFFSET 0x00000004u
N#define CYFLD_SCB_LATE_MISO_SAMPLE__SIZE 0x00000001u
N#define CYFLD_SCB_SCLK_CONTINUOUS__OFFSET 0x00000005u
N#define CYFLD_SCB_SCLK_CONTINUOUS__SIZE 0x00000001u
N#define CYFLD_SCB_SSEL_POLARITY0__OFFSET 0x00000008u
N#define CYFLD_SCB_SSEL_POLARITY0__SIZE 0x00000001u
N#define CYFLD_SCB_SSEL_POLARITY1__OFFSET 0x00000009u
N#define CYFLD_SCB_SSEL_POLARITY1__SIZE 0x00000001u
N#define CYFLD_SCB_SSEL_POLARITY2__OFFSET 0x0000000au
N#define CYFLD_SCB_SSEL_POLARITY2__SIZE 0x00000001u
N#define CYFLD_SCB_SSEL_POLARITY3__OFFSET 0x0000000bu
N#define CYFLD_SCB_SSEL_POLARITY3__SIZE 0x00000001u
N#define CYFLD_SCB_LOOPBACK__OFFSET 0x00000010u
N#define CYFLD_SCB_LOOPBACK__SIZE 0x00000001u
N#define CYFLD_SCB_SLAVE_SELECT__OFFSET 0x0000001au
N#define CYFLD_SCB_SLAVE_SELECT__SIZE 0x00000002u
N#define CYFLD_SCB_MASTER_MODE__OFFSET 0x0000001fu
N#define CYFLD_SCB_MASTER_MODE__SIZE 0x00000001u
N#define CYREG_SCB0_SPI_STATUS 0x40240024u
N#define CYFLD_SCB_BUS_BUSY__OFFSET 0x00000000u
N#define CYFLD_SCB_BUS_BUSY__SIZE 0x00000001u
N#define CYFLD_SCB_SPI_EC_BUSY__OFFSET 0x00000001u
N#define CYFLD_SCB_SPI_EC_BUSY__SIZE 0x00000001u
N#define CYFLD_SCB_CURR_EZ_ADDR__OFFSET 0x00000008u
N#define CYFLD_SCB_CURR_EZ_ADDR__SIZE 0x00000008u
N#define CYFLD_SCB_BASE_EZ_ADDR__OFFSET 0x00000010u
N#define CYFLD_SCB_BASE_EZ_ADDR__SIZE 0x00000008u
N#define CYREG_SCB0_UART_CTRL 0x40240040u
N#define CYREG_SCB0_UART_TX_CTRL 0x40240044u
N#define CYFLD_SCB_STOP_BITS__OFFSET 0x00000000u
N#define CYFLD_SCB_STOP_BITS__SIZE 0x00000003u
N#define CYFLD_SCB_PARITY__OFFSET 0x00000004u
N#define CYFLD_SCB_PARITY__SIZE 0x00000001u
N#define CYFLD_SCB_PARITY_ENABLED__OFFSET 0x00000005u
N#define CYFLD_SCB_PARITY_ENABLED__SIZE 0x00000001u
N#define CYFLD_SCB_RETRY_ON_NACK__OFFSET 0x00000008u
N#define CYFLD_SCB_RETRY_ON_NACK__SIZE 0x00000001u
N#define CYREG_SCB0_UART_RX_CTRL 0x40240048u
N#define CYFLD_SCB_POLARITY__OFFSET 0x00000006u
N#define CYFLD_SCB_POLARITY__SIZE 0x00000001u
N#define CYFLD_SCB_DROP_ON_PARITY_ERROR__OFFSET 0x00000008u
N#define CYFLD_SCB_DROP_ON_PARITY_ERROR__SIZE 0x00000001u
N#define CYFLD_SCB_DROP_ON_FRAME_ERROR__OFFSET 0x00000009u
N#define CYFLD_SCB_DROP_ON_FRAME_ERROR__SIZE 0x00000001u
N#define CYFLD_SCB_MP_MODE__OFFSET 0x0000000au
N#define CYFLD_SCB_MP_MODE__SIZE 0x00000001u
N#define CYFLD_SCB_LIN_MODE__OFFSET 0x0000000cu
N#define CYFLD_SCB_LIN_MODE__SIZE 0x00000001u
N#define CYFLD_SCB_SKIP_START__OFFSET 0x0000000du
N#define CYFLD_SCB_SKIP_START__SIZE 0x00000001u
N#define CYFLD_SCB_BREAK_WIDTH__OFFSET 0x00000010u
N#define CYFLD_SCB_BREAK_WIDTH__SIZE 0x00000004u
N#define CYREG_SCB0_UART_RX_STATUS 0x4024004cu
N#define CYFLD_SCB_BR_COUNTER__OFFSET 0x00000000u
N#define CYFLD_SCB_BR_COUNTER__SIZE 0x0000000cu
N#define CYREG_SCB0_UART_FLOW_CTRL 0x40240050u
N#define CYFLD_SCB_TRIGGER_LEVEL__OFFSET 0x00000000u
N#define CYFLD_SCB_TRIGGER_LEVEL__SIZE 0x00000004u
N#define CYFLD_SCB_RTS_POLARITY__OFFSET 0x00000010u
N#define CYFLD_SCB_RTS_POLARITY__SIZE 0x00000001u
N#define CYFLD_SCB_CTS_POLARITY__OFFSET 0x00000018u
N#define CYFLD_SCB_CTS_POLARITY__SIZE 0x00000001u
N#define CYFLD_SCB_CTS_ENABLED__OFFSET 0x00000019u
N#define CYFLD_SCB_CTS_ENABLED__SIZE 0x00000001u
N#define CYREG_SCB0_I2C_CTRL 0x40240060u
N#define CYFLD_SCB_HIGH_PHASE_OVS__OFFSET 0x00000000u
N#define CYFLD_SCB_HIGH_PHASE_OVS__SIZE 0x00000004u
N#define CYFLD_SCB_LOW_PHASE_OVS__OFFSET 0x00000004u
N#define CYFLD_SCB_LOW_PHASE_OVS__SIZE 0x00000004u
N#define CYFLD_SCB_M_READY_DATA_ACK__OFFSET 0x00000008u
N#define CYFLD_SCB_M_READY_DATA_ACK__SIZE 0x00000001u
N#define CYFLD_SCB_M_NOT_READY_DATA_NACK__OFFSET 0x00000009u
N#define CYFLD_SCB_M_NOT_READY_DATA_NACK__SIZE 0x00000001u
N#define CYFLD_SCB_S_GENERAL_IGNORE__OFFSET 0x0000000bu
N#define CYFLD_SCB_S_GENERAL_IGNORE__SIZE 0x00000001u
N#define CYFLD_SCB_S_READY_ADDR_ACK__OFFSET 0x0000000cu
N#define CYFLD_SCB_S_READY_ADDR_ACK__SIZE 0x00000001u
N#define CYFLD_SCB_S_READY_DATA_ACK__OFFSET 0x0000000du
N#define CYFLD_SCB_S_READY_DATA_ACK__SIZE 0x00000001u
N#define CYFLD_SCB_S_NOT_READY_ADDR_NACK__OFFSET 0x0000000eu
N#define CYFLD_SCB_S_NOT_READY_ADDR_NACK__SIZE 0x00000001u
N#define CYFLD_SCB_S_NOT_READY_DATA_NACK__OFFSET 0x0000000fu
N#define CYFLD_SCB_S_NOT_READY_DATA_NACK__SIZE 0x00000001u
N#define CYFLD_SCB_SLAVE_MODE__OFFSET 0x0000001eu
N#define CYFLD_SCB_SLAVE_MODE__SIZE 0x00000001u
N#define CYREG_SCB0_I2C_STATUS 0x40240064u
N#define CYFLD_SCB_I2C_EC_BUSY__OFFSET 0x00000001u
N#define CYFLD_SCB_I2C_EC_BUSY__SIZE 0x00000001u
N#define CYFLD_SCB_S_READ__OFFSET 0x00000004u
N#define CYFLD_SCB_S_READ__SIZE 0x00000001u
N#define CYFLD_SCB_M_READ__OFFSET 0x00000005u
N#define CYFLD_SCB_M_READ__SIZE 0x00000001u
N#define CYREG_SCB0_I2C_M_CMD 0x40240068u
N#define CYFLD_SCB_M_START__OFFSET 0x00000000u
N#define CYFLD_SCB_M_START__SIZE 0x00000001u
N#define CYFLD_SCB_M_START_ON_IDLE__OFFSET 0x00000001u
N#define CYFLD_SCB_M_START_ON_IDLE__SIZE 0x00000001u
N#define CYFLD_SCB_M_ACK__OFFSET 0x00000002u
N#define CYFLD_SCB_M_ACK__SIZE 0x00000001u
N#define CYFLD_SCB_M_NACK__OFFSET 0x00000003u
N#define CYFLD_SCB_M_NACK__SIZE 0x00000001u
N#define CYFLD_SCB_M_STOP__OFFSET 0x00000004u
N#define CYFLD_SCB_M_STOP__SIZE 0x00000001u
N#define CYREG_SCB0_I2C_S_CMD 0x4024006cu
N#define CYFLD_SCB_S_ACK__OFFSET 0x00000000u
N#define CYFLD_SCB_S_ACK__SIZE 0x00000001u
N#define CYFLD_SCB_S_NACK__OFFSET 0x00000001u
N#define CYFLD_SCB_S_NACK__SIZE 0x00000001u
N#define CYREG_SCB0_I2C_CFG 0x40240070u
N#define CYFLD_SCB_SDA_IN_FILT_TRIM__OFFSET 0x00000000u
N#define CYFLD_SCB_SDA_IN_FILT_TRIM__SIZE 0x00000002u
N#define CYFLD_SCB_SDA_IN_FILT_SEL__OFFSET 0x00000004u
N#define CYFLD_SCB_SDA_IN_FILT_SEL__SIZE 0x00000001u
N#define CYFLD_SCB_SCL_IN_FILT_TRIM__OFFSET 0x00000008u
N#define CYFLD_SCB_SCL_IN_FILT_TRIM__SIZE 0x00000002u
N#define CYFLD_SCB_SCL_IN_FILT_SEL__OFFSET 0x0000000cu
N#define CYFLD_SCB_SCL_IN_FILT_SEL__SIZE 0x00000001u
N#define CYFLD_SCB_SDA_OUT_FILT0_TRIM__OFFSET 0x00000010u
N#define CYFLD_SCB_SDA_OUT_FILT0_TRIM__SIZE 0x00000002u
N#define CYFLD_SCB_SDA_OUT_FILT1_TRIM__OFFSET 0x00000012u
N#define CYFLD_SCB_SDA_OUT_FILT1_TRIM__SIZE 0x00000002u
N#define CYFLD_SCB_SDA_OUT_FILT2_TRIM__OFFSET 0x00000014u
N#define CYFLD_SCB_SDA_OUT_FILT2_TRIM__SIZE 0x00000002u
N#define CYFLD_SCB_SDA_OUT_FILT_SEL__OFFSET 0x0000001cu
N#define CYFLD_SCB_SDA_OUT_FILT_SEL__SIZE 0x00000002u
N#define CYREG_SCB0_TX_CTRL 0x40240200u
N#define CYFLD_SCB_DATA_WIDTH__OFFSET 0x00000000u
N#define CYFLD_SCB_DATA_WIDTH__SIZE 0x00000004u
N#define CYFLD_SCB_MSB_FIRST__OFFSET 0x00000008u
N#define CYFLD_SCB_MSB_FIRST__SIZE 0x00000001u
N#define CYREG_SCB0_TX_FIFO_CTRL 0x40240204u
N#define CYFLD_SCB_CLEAR__OFFSET 0x00000010u
N#define CYFLD_SCB_CLEAR__SIZE 0x00000001u
N#define CYFLD_SCB_FREEZE__OFFSET 0x00000011u
N#define CYFLD_SCB_FREEZE__SIZE 0x00000001u
N#define CYREG_SCB0_TX_FIFO_STATUS 0x40240208u
N#define CYFLD_SCB_USED__OFFSET 0x00000000u
N#define CYFLD_SCB_USED__SIZE 0x00000005u
N#define CYFLD_SCB_SR_VALID__OFFSET 0x0000000fu
N#define CYFLD_SCB_SR_VALID__SIZE 0x00000001u
N#define CYFLD_SCB_RD_PTR__OFFSET 0x00000010u
N#define CYFLD_SCB_RD_PTR__SIZE 0x00000004u
N#define CYFLD_SCB_WR_PTR__OFFSET 0x00000018u
N#define CYFLD_SCB_WR_PTR__SIZE 0x00000004u
N#define CYREG_SCB0_TX_FIFO_WR 0x40240240u
N#define CYFLD_SCB_DATA__OFFSET 0x00000000u
N#define CYFLD_SCB_DATA__SIZE 0x00000010u
N#define CYREG_SCB0_RX_CTRL 0x40240300u
N#define CYFLD_SCB_MEDIAN__OFFSET 0x00000009u
N#define CYFLD_SCB_MEDIAN__SIZE 0x00000001u
N#define CYREG_SCB0_RX_FIFO_CTRL 0x40240304u
N#define CYREG_SCB0_RX_FIFO_STATUS 0x40240308u
N#define CYREG_SCB0_RX_MATCH 0x40240310u
N#define CYFLD_SCB_ADDR__OFFSET 0x00000000u
N#define CYFLD_SCB_ADDR__SIZE 0x00000008u
N#define CYFLD_SCB_MASK__OFFSET 0x00000010u
N#define CYFLD_SCB_MASK__SIZE 0x00000008u
N#define CYREG_SCB0_RX_FIFO_RD 0x40240340u
N#define CYREG_SCB0_RX_FIFO_RD_SILENT 0x40240344u
N#define CYREG_SCB0_EZ_DATA0 0x40240400u
N#define CYFLD_SCB_EZ_DATA__OFFSET 0x00000000u
N#define CYFLD_SCB_EZ_DATA__SIZE 0x00000008u
N#define CYREG_SCB0_EZ_DATA1 0x40240404u
N#define CYREG_SCB0_EZ_DATA2 0x40240408u
N#define CYREG_SCB0_EZ_DATA3 0x4024040cu
N#define CYREG_SCB0_EZ_DATA4 0x40240410u
N#define CYREG_SCB0_EZ_DATA5 0x40240414u
N#define CYREG_SCB0_EZ_DATA6 0x40240418u
N#define CYREG_SCB0_EZ_DATA7 0x4024041cu
N#define CYREG_SCB0_EZ_DATA8 0x40240420u
N#define CYREG_SCB0_EZ_DATA9 0x40240424u
N#define CYREG_SCB0_EZ_DATA10 0x40240428u
N#define CYREG_SCB0_EZ_DATA11 0x4024042cu
N#define CYREG_SCB0_EZ_DATA12 0x40240430u
N#define CYREG_SCB0_EZ_DATA13 0x40240434u
N#define CYREG_SCB0_EZ_DATA14 0x40240438u
N#define CYREG_SCB0_EZ_DATA15 0x4024043cu
N#define CYREG_SCB0_EZ_DATA16 0x40240440u
N#define CYREG_SCB0_EZ_DATA17 0x40240444u
N#define CYREG_SCB0_EZ_DATA18 0x40240448u
N#define CYREG_SCB0_EZ_DATA19 0x4024044cu
N#define CYREG_SCB0_EZ_DATA20 0x40240450u
N#define CYREG_SCB0_EZ_DATA21 0x40240454u
N#define CYREG_SCB0_EZ_DATA22 0x40240458u
N#define CYREG_SCB0_EZ_DATA23 0x4024045cu
N#define CYREG_SCB0_EZ_DATA24 0x40240460u
N#define CYREG_SCB0_EZ_DATA25 0x40240464u
N#define CYREG_SCB0_EZ_DATA26 0x40240468u
N#define CYREG_SCB0_EZ_DATA27 0x4024046cu
N#define CYREG_SCB0_EZ_DATA28 0x40240470u
N#define CYREG_SCB0_EZ_DATA29 0x40240474u
N#define CYREG_SCB0_EZ_DATA30 0x40240478u
N#define CYREG_SCB0_EZ_DATA31 0x4024047cu
N#define CYREG_SCB0_INTR_CAUSE 0x40240e00u
N#define CYFLD_SCB_M__OFFSET 0x00000000u
N#define CYFLD_SCB_M__SIZE 0x00000001u
N#define CYFLD_SCB_S__OFFSET 0x00000001u
N#define CYFLD_SCB_S__SIZE 0x00000001u
N#define CYFLD_SCB_TX__OFFSET 0x00000002u
N#define CYFLD_SCB_TX__SIZE 0x00000001u
N#define CYFLD_SCB_RX__OFFSET 0x00000003u
N#define CYFLD_SCB_RX__SIZE 0x00000001u
N#define CYFLD_SCB_I2C_EC__OFFSET 0x00000004u
N#define CYFLD_SCB_I2C_EC__SIZE 0x00000001u
N#define CYFLD_SCB_SPI_EC__OFFSET 0x00000005u
N#define CYFLD_SCB_SPI_EC__SIZE 0x00000001u
N#define CYREG_SCB0_INTR_I2C_EC 0x40240e80u
N#define CYFLD_SCB_WAKE_UP__OFFSET 0x00000000u
N#define CYFLD_SCB_WAKE_UP__SIZE 0x00000001u
N#define CYFLD_SCB_EZ_STOP__OFFSET 0x00000001u
N#define CYFLD_SCB_EZ_STOP__SIZE 0x00000001u
N#define CYFLD_SCB_EZ_WRITE_STOP__OFFSET 0x00000002u
N#define CYFLD_SCB_EZ_WRITE_STOP__SIZE 0x00000001u
N#define CYFLD_SCB_EZ_READ_STOP__OFFSET 0x00000003u
N#define CYFLD_SCB_EZ_READ_STOP__SIZE 0x00000001u
N#define CYREG_SCB0_INTR_I2C_EC_MASK 0x40240e88u
N#define CYREG_SCB0_INTR_I2C_EC_MASKED 0x40240e8cu
N#define CYREG_SCB0_INTR_SPI_EC 0x40240ec0u
N#define CYREG_SCB0_INTR_SPI_EC_MASK 0x40240ec8u
N#define CYREG_SCB0_INTR_SPI_EC_MASKED 0x40240eccu
N#define CYREG_SCB0_INTR_M 0x40240f00u
N#define CYFLD_SCB_I2C_ARB_LOST__OFFSET 0x00000000u
N#define CYFLD_SCB_I2C_ARB_LOST__SIZE 0x00000001u
N#define CYFLD_SCB_I2C_NACK__OFFSET 0x00000001u
N#define CYFLD_SCB_I2C_NACK__SIZE 0x00000001u
N#define CYFLD_SCB_I2C_ACK__OFFSET 0x00000002u
N#define CYFLD_SCB_I2C_ACK__SIZE 0x00000001u
N#define CYFLD_SCB_I2C_STOP__OFFSET 0x00000004u
N#define CYFLD_SCB_I2C_STOP__SIZE 0x00000001u
N#define CYFLD_SCB_I2C_BUS_ERROR__OFFSET 0x00000008u
N#define CYFLD_SCB_I2C_BUS_ERROR__SIZE 0x00000001u
N#define CYFLD_SCB_SPI_DONE__OFFSET 0x00000009u
N#define CYFLD_SCB_SPI_DONE__SIZE 0x00000001u
N#define CYREG_SCB0_INTR_M_SET 0x40240f04u
N#define CYREG_SCB0_INTR_M_MASK 0x40240f08u
N#define CYREG_SCB0_INTR_M_MASKED 0x40240f0cu
N#define CYREG_SCB0_INTR_S 0x40240f40u
N#define CYFLD_SCB_I2C_WRITE_STOP__OFFSET 0x00000003u
N#define CYFLD_SCB_I2C_WRITE_STOP__SIZE 0x00000001u
N#define CYFLD_SCB_I2C_START__OFFSET 0x00000005u
N#define CYFLD_SCB_I2C_START__SIZE 0x00000001u
N#define CYFLD_SCB_I2C_ADDR_MATCH__OFFSET 0x00000006u
N#define CYFLD_SCB_I2C_ADDR_MATCH__SIZE 0x00000001u
N#define CYFLD_SCB_I2C_GENERAL__OFFSET 0x00000007u
N#define CYFLD_SCB_I2C_GENERAL__SIZE 0x00000001u
N#define CYFLD_SCB_SPI_EZ_WRITE_STOP__OFFSET 0x00000009u
N#define CYFLD_SCB_SPI_EZ_WRITE_STOP__SIZE 0x00000001u
N#define CYFLD_SCB_SPI_EZ_STOP__OFFSET 0x0000000au
N#define CYFLD_SCB_SPI_EZ_STOP__SIZE 0x00000001u
N#define CYFLD_SCB_SPI_BUS_ERROR__OFFSET 0x0000000bu
N#define CYFLD_SCB_SPI_BUS_ERROR__SIZE 0x00000001u
N#define CYREG_SCB0_INTR_S_SET 0x40240f44u
N#define CYREG_SCB0_INTR_S_MASK 0x40240f48u
N#define CYREG_SCB0_INTR_S_MASKED 0x40240f4cu
N#define CYREG_SCB0_INTR_TX 0x40240f80u
N#define CYFLD_SCB_TRIGGER__OFFSET 0x00000000u
N#define CYFLD_SCB_TRIGGER__SIZE 0x00000001u
N#define CYFLD_SCB_NOT_FULL__OFFSET 0x00000001u
N#define CYFLD_SCB_NOT_FULL__SIZE 0x00000001u
N#define CYFLD_SCB_EMPTY__OFFSET 0x00000004u
N#define CYFLD_SCB_EMPTY__SIZE 0x00000001u
N#define CYFLD_SCB_OVERFLOW__OFFSET 0x00000005u
N#define CYFLD_SCB_OVERFLOW__SIZE 0x00000001u
N#define CYFLD_SCB_UNDERFLOW__OFFSET 0x00000006u
N#define CYFLD_SCB_UNDERFLOW__SIZE 0x00000001u
N#define CYFLD_SCB_BLOCKED__OFFSET 0x00000007u
N#define CYFLD_SCB_BLOCKED__SIZE 0x00000001u
N#define CYFLD_SCB_UART_NACK__OFFSET 0x00000008u
N#define CYFLD_SCB_UART_NACK__SIZE 0x00000001u
N#define CYFLD_SCB_UART_DONE__OFFSET 0x00000009u
N#define CYFLD_SCB_UART_DONE__SIZE 0x00000001u
N#define CYFLD_SCB_UART_ARB_LOST__OFFSET 0x0000000au
N#define CYFLD_SCB_UART_ARB_LOST__SIZE 0x00000001u
N#define CYREG_SCB0_INTR_TX_SET 0x40240f84u
N#define CYREG_SCB0_INTR_TX_MASK 0x40240f88u
N#define CYREG_SCB0_INTR_TX_MASKED 0x40240f8cu
N#define CYREG_SCB0_INTR_RX 0x40240fc0u
N#define CYFLD_SCB_NOT_EMPTY__OFFSET 0x00000002u
N#define CYFLD_SCB_NOT_EMPTY__SIZE 0x00000001u
N#define CYFLD_SCB_FULL__OFFSET 0x00000003u
N#define CYFLD_SCB_FULL__SIZE 0x00000001u
N#define CYFLD_SCB_FRAME_ERROR__OFFSET 0x00000008u
N#define CYFLD_SCB_FRAME_ERROR__SIZE 0x00000001u
N#define CYFLD_SCB_PARITY_ERROR__OFFSET 0x00000009u
N#define CYFLD_SCB_PARITY_ERROR__SIZE 0x00000001u
N#define CYFLD_SCB_BAUD_DETECT__OFFSET 0x0000000au
N#define CYFLD_SCB_BAUD_DETECT__SIZE 0x00000001u
N#define CYFLD_SCB_BREAK_DETECT__OFFSET 0x0000000bu
N#define CYFLD_SCB_BREAK_DETECT__SIZE 0x00000001u
N#define CYREG_SCB0_INTR_RX_SET 0x40240fc4u
N#define CYREG_SCB0_INTR_RX_MASK 0x40240fc8u
N#define CYREG_SCB0_INTR_RX_MASKED 0x40240fccu
N#define CYDEV_SCB1_BASE 0x40250000u
N#define CYDEV_SCB1_SIZE 0x00010000u
N#define CYREG_SCB1_CTRL 0x40250000u
N#define CYREG_SCB1_STATUS 0x40250004u
N#define CYREG_SCB1_SPI_CTRL 0x40250020u
N#define CYREG_SCB1_SPI_STATUS 0x40250024u
N#define CYREG_SCB1_UART_CTRL 0x40250040u
N#define CYREG_SCB1_UART_TX_CTRL 0x40250044u
N#define CYREG_SCB1_UART_RX_CTRL 0x40250048u
N#define CYREG_SCB1_UART_RX_STATUS 0x4025004cu
N#define CYREG_SCB1_UART_FLOW_CTRL 0x40250050u
N#define CYREG_SCB1_I2C_CTRL 0x40250060u
N#define CYREG_SCB1_I2C_STATUS 0x40250064u
N#define CYREG_SCB1_I2C_M_CMD 0x40250068u
N#define CYREG_SCB1_I2C_S_CMD 0x4025006cu
N#define CYREG_SCB1_I2C_CFG 0x40250070u
N#define CYREG_SCB1_TX_CTRL 0x40250200u
N#define CYREG_SCB1_TX_FIFO_CTRL 0x40250204u
N#define CYREG_SCB1_TX_FIFO_STATUS 0x40250208u
N#define CYREG_SCB1_TX_FIFO_WR 0x40250240u
N#define CYREG_SCB1_RX_CTRL 0x40250300u
N#define CYREG_SCB1_RX_FIFO_CTRL 0x40250304u
N#define CYREG_SCB1_RX_FIFO_STATUS 0x40250308u
N#define CYREG_SCB1_RX_MATCH 0x40250310u
N#define CYREG_SCB1_RX_FIFO_RD 0x40250340u
N#define CYREG_SCB1_RX_FIFO_RD_SILENT 0x40250344u
N#define CYREG_SCB1_EZ_DATA0 0x40250400u
N#define CYREG_SCB1_EZ_DATA1 0x40250404u
N#define CYREG_SCB1_EZ_DATA2 0x40250408u
N#define CYREG_SCB1_EZ_DATA3 0x4025040cu
N#define CYREG_SCB1_EZ_DATA4 0x40250410u
N#define CYREG_SCB1_EZ_DATA5 0x40250414u
N#define CYREG_SCB1_EZ_DATA6 0x40250418u
N#define CYREG_SCB1_EZ_DATA7 0x4025041cu
N#define CYREG_SCB1_EZ_DATA8 0x40250420u
N#define CYREG_SCB1_EZ_DATA9 0x40250424u
N#define CYREG_SCB1_EZ_DATA10 0x40250428u
N#define CYREG_SCB1_EZ_DATA11 0x4025042cu
N#define CYREG_SCB1_EZ_DATA12 0x40250430u
N#define CYREG_SCB1_EZ_DATA13 0x40250434u
N#define CYREG_SCB1_EZ_DATA14 0x40250438u
N#define CYREG_SCB1_EZ_DATA15 0x4025043cu
N#define CYREG_SCB1_EZ_DATA16 0x40250440u
N#define CYREG_SCB1_EZ_DATA17 0x40250444u
N#define CYREG_SCB1_EZ_DATA18 0x40250448u
N#define CYREG_SCB1_EZ_DATA19 0x4025044cu
N#define CYREG_SCB1_EZ_DATA20 0x40250450u
N#define CYREG_SCB1_EZ_DATA21 0x40250454u
N#define CYREG_SCB1_EZ_DATA22 0x40250458u
N#define CYREG_SCB1_EZ_DATA23 0x4025045cu
N#define CYREG_SCB1_EZ_DATA24 0x40250460u
N#define CYREG_SCB1_EZ_DATA25 0x40250464u
N#define CYREG_SCB1_EZ_DATA26 0x40250468u
N#define CYREG_SCB1_EZ_DATA27 0x4025046cu
N#define CYREG_SCB1_EZ_DATA28 0x40250470u
N#define CYREG_SCB1_EZ_DATA29 0x40250474u
N#define CYREG_SCB1_EZ_DATA30 0x40250478u
N#define CYREG_SCB1_EZ_DATA31 0x4025047cu
N#define CYREG_SCB1_INTR_CAUSE 0x40250e00u
N#define CYREG_SCB1_INTR_I2C_EC 0x40250e80u
N#define CYREG_SCB1_INTR_I2C_EC_MASK 0x40250e88u
N#define CYREG_SCB1_INTR_I2C_EC_MASKED 0x40250e8cu
N#define CYREG_SCB1_INTR_SPI_EC 0x40250ec0u
N#define CYREG_SCB1_INTR_SPI_EC_MASK 0x40250ec8u
N#define CYREG_SCB1_INTR_SPI_EC_MASKED 0x40250eccu
N#define CYREG_SCB1_INTR_M 0x40250f00u
N#define CYREG_SCB1_INTR_M_SET 0x40250f04u
N#define CYREG_SCB1_INTR_M_MASK 0x40250f08u
N#define CYREG_SCB1_INTR_M_MASKED 0x40250f0cu
N#define CYREG_SCB1_INTR_S 0x40250f40u
N#define CYREG_SCB1_INTR_S_SET 0x40250f44u
N#define CYREG_SCB1_INTR_S_MASK 0x40250f48u
N#define CYREG_SCB1_INTR_S_MASKED 0x40250f4cu
N#define CYREG_SCB1_INTR_TX 0x40250f80u
N#define CYREG_SCB1_INTR_TX_SET 0x40250f84u
N#define CYREG_SCB1_INTR_TX_MASK 0x40250f88u
N#define CYREG_SCB1_INTR_TX_MASKED 0x40250f8cu
N#define CYREG_SCB1_INTR_RX 0x40250fc0u
N#define CYREG_SCB1_INTR_RX_SET 0x40250fc4u
N#define CYREG_SCB1_INTR_RX_MASK 0x40250fc8u
N#define CYREG_SCB1_INTR_RX_MASKED 0x40250fccu
N#define CYDEV_SCB2_BASE 0x40260000u
N#define CYDEV_SCB2_SIZE 0x00010000u
N#define CYREG_SCB2_CTRL 0x40260000u
N#define CYREG_SCB2_STATUS 0x40260004u
N#define CYREG_SCB2_SPI_CTRL 0x40260020u
N#define CYREG_SCB2_SPI_STATUS 0x40260024u
N#define CYREG_SCB2_UART_CTRL 0x40260040u
N#define CYREG_SCB2_UART_TX_CTRL 0x40260044u
N#define CYREG_SCB2_UART_RX_CTRL 0x40260048u
N#define CYREG_SCB2_UART_RX_STATUS 0x4026004cu
N#define CYREG_SCB2_UART_FLOW_CTRL 0x40260050u
N#define CYREG_SCB2_I2C_CTRL 0x40260060u
N#define CYREG_SCB2_I2C_STATUS 0x40260064u
N#define CYREG_SCB2_I2C_M_CMD 0x40260068u
N#define CYREG_SCB2_I2C_S_CMD 0x4026006cu
N#define CYREG_SCB2_I2C_CFG 0x40260070u
N#define CYREG_SCB2_TX_CTRL 0x40260200u
N#define CYREG_SCB2_TX_FIFO_CTRL 0x40260204u
N#define CYREG_SCB2_TX_FIFO_STATUS 0x40260208u
N#define CYREG_SCB2_TX_FIFO_WR 0x40260240u
N#define CYREG_SCB2_RX_CTRL 0x40260300u
N#define CYREG_SCB2_RX_FIFO_CTRL 0x40260304u
N#define CYREG_SCB2_RX_FIFO_STATUS 0x40260308u
N#define CYREG_SCB2_RX_MATCH 0x40260310u
N#define CYREG_SCB2_RX_FIFO_RD 0x40260340u
N#define CYREG_SCB2_RX_FIFO_RD_SILENT 0x40260344u
N#define CYREG_SCB2_EZ_DATA0 0x40260400u
N#define CYREG_SCB2_EZ_DATA1 0x40260404u
N#define CYREG_SCB2_EZ_DATA2 0x40260408u
N#define CYREG_SCB2_EZ_DATA3 0x4026040cu
N#define CYREG_SCB2_EZ_DATA4 0x40260410u
N#define CYREG_SCB2_EZ_DATA5 0x40260414u
N#define CYREG_SCB2_EZ_DATA6 0x40260418u
N#define CYREG_SCB2_EZ_DATA7 0x4026041cu
N#define CYREG_SCB2_EZ_DATA8 0x40260420u
N#define CYREG_SCB2_EZ_DATA9 0x40260424u
N#define CYREG_SCB2_EZ_DATA10 0x40260428u
N#define CYREG_SCB2_EZ_DATA11 0x4026042cu
N#define CYREG_SCB2_EZ_DATA12 0x40260430u
N#define CYREG_SCB2_EZ_DATA13 0x40260434u
N#define CYREG_SCB2_EZ_DATA14 0x40260438u
N#define CYREG_SCB2_EZ_DATA15 0x4026043cu
N#define CYREG_SCB2_EZ_DATA16 0x40260440u
N#define CYREG_SCB2_EZ_DATA17 0x40260444u
N#define CYREG_SCB2_EZ_DATA18 0x40260448u
N#define CYREG_SCB2_EZ_DATA19 0x4026044cu
N#define CYREG_SCB2_EZ_DATA20 0x40260450u
N#define CYREG_SCB2_EZ_DATA21 0x40260454u
N#define CYREG_SCB2_EZ_DATA22 0x40260458u
N#define CYREG_SCB2_EZ_DATA23 0x4026045cu
N#define CYREG_SCB2_EZ_DATA24 0x40260460u
N#define CYREG_SCB2_EZ_DATA25 0x40260464u
N#define CYREG_SCB2_EZ_DATA26 0x40260468u
N#define CYREG_SCB2_EZ_DATA27 0x4026046cu
N#define CYREG_SCB2_EZ_DATA28 0x40260470u
N#define CYREG_SCB2_EZ_DATA29 0x40260474u
N#define CYREG_SCB2_EZ_DATA30 0x40260478u
N#define CYREG_SCB2_EZ_DATA31 0x4026047cu
N#define CYREG_SCB2_INTR_CAUSE 0x40260e00u
N#define CYREG_SCB2_INTR_I2C_EC 0x40260e80u
N#define CYREG_SCB2_INTR_I2C_EC_MASK 0x40260e88u
N#define CYREG_SCB2_INTR_I2C_EC_MASKED 0x40260e8cu
N#define CYREG_SCB2_INTR_SPI_EC 0x40260ec0u
N#define CYREG_SCB2_INTR_SPI_EC_MASK 0x40260ec8u
N#define CYREG_SCB2_INTR_SPI_EC_MASKED 0x40260eccu
N#define CYREG_SCB2_INTR_M 0x40260f00u
N#define CYREG_SCB2_INTR_M_SET 0x40260f04u
N#define CYREG_SCB2_INTR_M_MASK 0x40260f08u
N#define CYREG_SCB2_INTR_M_MASKED 0x40260f0cu
N#define CYREG_SCB2_INTR_S 0x40260f40u
N#define CYREG_SCB2_INTR_S_SET 0x40260f44u
N#define CYREG_SCB2_INTR_S_MASK 0x40260f48u
N#define CYREG_SCB2_INTR_S_MASKED 0x40260f4cu
N#define CYREG_SCB2_INTR_TX 0x40260f80u
N#define CYREG_SCB2_INTR_TX_SET 0x40260f84u
N#define CYREG_SCB2_INTR_TX_MASK 0x40260f88u
N#define CYREG_SCB2_INTR_TX_MASKED 0x40260f8cu
N#define CYREG_SCB2_INTR_RX 0x40260fc0u
N#define CYREG_SCB2_INTR_RX_SET 0x40260fc4u
N#define CYREG_SCB2_INTR_RX_MASK 0x40260fc8u
N#define CYREG_SCB2_INTR_RX_MASKED 0x40260fccu
N#define CYDEV_SCB3_BASE 0x40270000u
N#define CYDEV_SCB3_SIZE 0x00010000u
N#define CYREG_SCB3_CTRL 0x40270000u
N#define CYREG_SCB3_STATUS 0x40270004u
N#define CYREG_SCB3_SPI_CTRL 0x40270020u
N#define CYREG_SCB3_SPI_STATUS 0x40270024u
N#define CYREG_SCB3_UART_CTRL 0x40270040u
N#define CYREG_SCB3_UART_TX_CTRL 0x40270044u
N#define CYREG_SCB3_UART_RX_CTRL 0x40270048u
N#define CYREG_SCB3_UART_RX_STATUS 0x4027004cu
N#define CYREG_SCB3_UART_FLOW_CTRL 0x40270050u
N#define CYREG_SCB3_I2C_CTRL 0x40270060u
N#define CYREG_SCB3_I2C_STATUS 0x40270064u
N#define CYREG_SCB3_I2C_M_CMD 0x40270068u
N#define CYREG_SCB3_I2C_S_CMD 0x4027006cu
N#define CYREG_SCB3_I2C_CFG 0x40270070u
N#define CYREG_SCB3_TX_CTRL 0x40270200u
N#define CYREG_SCB3_TX_FIFO_CTRL 0x40270204u
N#define CYREG_SCB3_TX_FIFO_STATUS 0x40270208u
N#define CYREG_SCB3_TX_FIFO_WR 0x40270240u
N#define CYREG_SCB3_RX_CTRL 0x40270300u
N#define CYREG_SCB3_RX_FIFO_CTRL 0x40270304u
N#define CYREG_SCB3_RX_FIFO_STATUS 0x40270308u
N#define CYREG_SCB3_RX_MATCH 0x40270310u
N#define CYREG_SCB3_RX_FIFO_RD 0x40270340u
N#define CYREG_SCB3_RX_FIFO_RD_SILENT 0x40270344u
N#define CYREG_SCB3_EZ_DATA0 0x40270400u
N#define CYREG_SCB3_EZ_DATA1 0x40270404u
N#define CYREG_SCB3_EZ_DATA2 0x40270408u
N#define CYREG_SCB3_EZ_DATA3 0x4027040cu
N#define CYREG_SCB3_EZ_DATA4 0x40270410u
N#define CYREG_SCB3_EZ_DATA5 0x40270414u
N#define CYREG_SCB3_EZ_DATA6 0x40270418u
N#define CYREG_SCB3_EZ_DATA7 0x4027041cu
N#define CYREG_SCB3_EZ_DATA8 0x40270420u
N#define CYREG_SCB3_EZ_DATA9 0x40270424u
N#define CYREG_SCB3_EZ_DATA10 0x40270428u
N#define CYREG_SCB3_EZ_DATA11 0x4027042cu
N#define CYREG_SCB3_EZ_DATA12 0x40270430u
N#define CYREG_SCB3_EZ_DATA13 0x40270434u
N#define CYREG_SCB3_EZ_DATA14 0x40270438u
N#define CYREG_SCB3_EZ_DATA15 0x4027043cu
N#define CYREG_SCB3_EZ_DATA16 0x40270440u
N#define CYREG_SCB3_EZ_DATA17 0x40270444u
N#define CYREG_SCB3_EZ_DATA18 0x40270448u
N#define CYREG_SCB3_EZ_DATA19 0x4027044cu
N#define CYREG_SCB3_EZ_DATA20 0x40270450u
N#define CYREG_SCB3_EZ_DATA21 0x40270454u
N#define CYREG_SCB3_EZ_DATA22 0x40270458u
N#define CYREG_SCB3_EZ_DATA23 0x4027045cu
N#define CYREG_SCB3_EZ_DATA24 0x40270460u
N#define CYREG_SCB3_EZ_DATA25 0x40270464u
N#define CYREG_SCB3_EZ_DATA26 0x40270468u
N#define CYREG_SCB3_EZ_DATA27 0x4027046cu
N#define CYREG_SCB3_EZ_DATA28 0x40270470u
N#define CYREG_SCB3_EZ_DATA29 0x40270474u
N#define CYREG_SCB3_EZ_DATA30 0x40270478u
N#define CYREG_SCB3_EZ_DATA31 0x4027047cu
N#define CYREG_SCB3_INTR_CAUSE 0x40270e00u
N#define CYREG_SCB3_INTR_I2C_EC 0x40270e80u
N#define CYREG_SCB3_INTR_I2C_EC_MASK 0x40270e88u
N#define CYREG_SCB3_INTR_I2C_EC_MASKED 0x40270e8cu
N#define CYREG_SCB3_INTR_SPI_EC 0x40270ec0u
N#define CYREG_SCB3_INTR_SPI_EC_MASK 0x40270ec8u
N#define CYREG_SCB3_INTR_SPI_EC_MASKED 0x40270eccu
N#define CYREG_SCB3_INTR_M 0x40270f00u
N#define CYREG_SCB3_INTR_M_SET 0x40270f04u
N#define CYREG_SCB3_INTR_M_MASK 0x40270f08u
N#define CYREG_SCB3_INTR_M_MASKED 0x40270f0cu
N#define CYREG_SCB3_INTR_S 0x40270f40u
N#define CYREG_SCB3_INTR_S_SET 0x40270f44u
N#define CYREG_SCB3_INTR_S_MASK 0x40270f48u
N#define CYREG_SCB3_INTR_S_MASKED 0x40270f4cu
N#define CYREG_SCB3_INTR_TX 0x40270f80u
N#define CYREG_SCB3_INTR_TX_SET 0x40270f84u
N#define CYREG_SCB3_INTR_TX_MASK 0x40270f88u
N#define CYREG_SCB3_INTR_TX_MASKED 0x40270f8cu
N#define CYREG_SCB3_INTR_RX 0x40270fc0u
N#define CYREG_SCB3_INTR_RX_SET 0x40270fc4u
N#define CYREG_SCB3_INTR_RX_MASK 0x40270fc8u
N#define CYREG_SCB3_INTR_RX_MASKED 0x40270fccu
N#define CYDEV_SCB4_BASE 0x40280000u
N#define CYDEV_SCB4_SIZE 0x00010000u
N#define CYREG_SCB4_CTRL 0x40280000u
N#define CYREG_SCB4_STATUS 0x40280004u
N#define CYREG_SCB4_SPI_CTRL 0x40280020u
N#define CYREG_SCB4_SPI_STATUS 0x40280024u
N#define CYREG_SCB4_UART_CTRL 0x40280040u
N#define CYREG_SCB4_UART_TX_CTRL 0x40280044u
N#define CYREG_SCB4_UART_RX_CTRL 0x40280048u
N#define CYREG_SCB4_UART_RX_STATUS 0x4028004cu
N#define CYREG_SCB4_UART_FLOW_CTRL 0x40280050u
N#define CYREG_SCB4_I2C_CTRL 0x40280060u
N#define CYREG_SCB4_I2C_STATUS 0x40280064u
N#define CYREG_SCB4_I2C_M_CMD 0x40280068u
N#define CYREG_SCB4_I2C_S_CMD 0x4028006cu
N#define CYREG_SCB4_I2C_CFG 0x40280070u
N#define CYREG_SCB4_TX_CTRL 0x40280200u
N#define CYREG_SCB4_TX_FIFO_CTRL 0x40280204u
N#define CYREG_SCB4_TX_FIFO_STATUS 0x40280208u
N#define CYREG_SCB4_TX_FIFO_WR 0x40280240u
N#define CYREG_SCB4_RX_CTRL 0x40280300u
N#define CYREG_SCB4_RX_FIFO_CTRL 0x40280304u
N#define CYREG_SCB4_RX_FIFO_STATUS 0x40280308u
N#define CYREG_SCB4_RX_MATCH 0x40280310u
N#define CYREG_SCB4_RX_FIFO_RD 0x40280340u
N#define CYREG_SCB4_RX_FIFO_RD_SILENT 0x40280344u
N#define CYREG_SCB4_EZ_DATA0 0x40280400u
N#define CYREG_SCB4_EZ_DATA1 0x40280404u
N#define CYREG_SCB4_EZ_DATA2 0x40280408u
N#define CYREG_SCB4_EZ_DATA3 0x4028040cu
N#define CYREG_SCB4_EZ_DATA4 0x40280410u
N#define CYREG_SCB4_EZ_DATA5 0x40280414u
N#define CYREG_SCB4_EZ_DATA6 0x40280418u
N#define CYREG_SCB4_EZ_DATA7 0x4028041cu
N#define CYREG_SCB4_EZ_DATA8 0x40280420u
N#define CYREG_SCB4_EZ_DATA9 0x40280424u
N#define CYREG_SCB4_EZ_DATA10 0x40280428u
N#define CYREG_SCB4_EZ_DATA11 0x4028042cu
N#define CYREG_SCB4_EZ_DATA12 0x40280430u
N#define CYREG_SCB4_EZ_DATA13 0x40280434u
N#define CYREG_SCB4_EZ_DATA14 0x40280438u
N#define CYREG_SCB4_EZ_DATA15 0x4028043cu
N#define CYREG_SCB4_EZ_DATA16 0x40280440u
N#define CYREG_SCB4_EZ_DATA17 0x40280444u
N#define CYREG_SCB4_EZ_DATA18 0x40280448u
N#define CYREG_SCB4_EZ_DATA19 0x4028044cu
N#define CYREG_SCB4_EZ_DATA20 0x40280450u
N#define CYREG_SCB4_EZ_DATA21 0x40280454u
N#define CYREG_SCB4_EZ_DATA22 0x40280458u
N#define CYREG_SCB4_EZ_DATA23 0x4028045cu
N#define CYREG_SCB4_EZ_DATA24 0x40280460u
N#define CYREG_SCB4_EZ_DATA25 0x40280464u
N#define CYREG_SCB4_EZ_DATA26 0x40280468u
N#define CYREG_SCB4_EZ_DATA27 0x4028046cu
N#define CYREG_SCB4_EZ_DATA28 0x40280470u
N#define CYREG_SCB4_EZ_DATA29 0x40280474u
N#define CYREG_SCB4_EZ_DATA30 0x40280478u
N#define CYREG_SCB4_EZ_DATA31 0x4028047cu
N#define CYREG_SCB4_INTR_CAUSE 0x40280e00u
N#define CYREG_SCB4_INTR_I2C_EC 0x40280e80u
N#define CYREG_SCB4_INTR_I2C_EC_MASK 0x40280e88u
N#define CYREG_SCB4_INTR_I2C_EC_MASKED 0x40280e8cu
N#define CYREG_SCB4_INTR_SPI_EC 0x40280ec0u
N#define CYREG_SCB4_INTR_SPI_EC_MASK 0x40280ec8u
N#define CYREG_SCB4_INTR_SPI_EC_MASKED 0x40280eccu
N#define CYREG_SCB4_INTR_M 0x40280f00u
N#define CYREG_SCB4_INTR_M_SET 0x40280f04u
N#define CYREG_SCB4_INTR_M_MASK 0x40280f08u
N#define CYREG_SCB4_INTR_M_MASKED 0x40280f0cu
N#define CYREG_SCB4_INTR_S 0x40280f40u
N#define CYREG_SCB4_INTR_S_SET 0x40280f44u
N#define CYREG_SCB4_INTR_S_MASK 0x40280f48u
N#define CYREG_SCB4_INTR_S_MASKED 0x40280f4cu
N#define CYREG_SCB4_INTR_TX 0x40280f80u
N#define CYREG_SCB4_INTR_TX_SET 0x40280f84u
N#define CYREG_SCB4_INTR_TX_MASK 0x40280f88u
N#define CYREG_SCB4_INTR_TX_MASKED 0x40280f8cu
N#define CYREG_SCB4_INTR_RX 0x40280fc0u
N#define CYREG_SCB4_INTR_RX_SET 0x40280fc4u
N#define CYREG_SCB4_INTR_RX_MASK 0x40280fc8u
N#define CYREG_SCB4_INTR_RX_MASKED 0x40280fccu
N#define CYDEV_CSD_BASE 0x40290000u
N#define CYDEV_CSD_SIZE 0x00001000u
N#define CYREG_CSD_CONFIG 0x40290000u
N#define CYFLD_CSD_LOW_VDDA__OFFSET 0x00000003u
N#define CYFLD_CSD_LOW_VDDA__SIZE 0x00000001u
N#define CYFLD_CSD_FILTER_DELAY__OFFSET 0x00000004u
N#define CYFLD_CSD_FILTER_DELAY__SIZE 0x00000003u
N#define CYFLD_CSD_SHIELD_DELAY__OFFSET 0x00000008u
N#define CYFLD_CSD_SHIELD_DELAY__SIZE 0x00000002u
N#define CYVAL_CSD_SHIELD_DELAY_OFF 0x00000000u
N#define CYVAL_CSD_SHIELD_DELAY_D5NS 0x00000001u
N#define CYVAL_CSD_SHIELD_DELAY_D10NS 0x00000002u
N#define CYVAL_CSD_SHIELD_DELAY_D20NS 0x00000003u
N#define CYFLD_CSD_SENSE_EN__OFFSET 0x0000000cu
N#define CYFLD_CSD_SENSE_EN__SIZE 0x00000001u
N#define CYFLD_CSD_CHARGE_MODE__OFFSET 0x0000000eu
N#define CYFLD_CSD_CHARGE_MODE__SIZE 0x00000001u
N#define CYVAL_CSD_CHARGE_MODE_CHARGE_OFF 0x00000000u
N#define CYVAL_CSD_CHARGE_MODE_CHARGE_IO 0x00000001u
N#define CYFLD_CSD_FULL_WAVE__OFFSET 0x00000011u
N#define CYFLD_CSD_FULL_WAVE__SIZE 0x00000001u
N#define CYVAL_CSD_FULL_WAVE_HALFWAVE 0x00000000u
N#define CYVAL_CSD_FULL_WAVE_FULLWAVE 0x00000001u
N#define CYFLD_CSD_MUTUAL_CAP__OFFSET 0x00000012u
N#define CYFLD_CSD_MUTUAL_CAP__SIZE 0x00000001u
N#define CYVAL_CSD_MUTUAL_CAP_SELFCAP 0x00000000u
N#define CYVAL_CSD_MUTUAL_CAP_MUTUALCAP 0x00000001u
N#define CYFLD_CSD_CSX_DUAL_CNT__OFFSET 0x00000013u
N#define CYFLD_CSD_CSX_DUAL_CNT__SIZE 0x00000001u
N#define CYVAL_CSD_CSX_DUAL_CNT_ONE 0x00000000u
N#define CYVAL_CSD_CSX_DUAL_CNT_TWO 0x00000001u
N#define CYFLD_CSD_DSI_COUNT_SEL__OFFSET 0x00000018u
N#define CYFLD_CSD_DSI_COUNT_SEL__SIZE 0x00000001u
N#define CYVAL_CSD_DSI_COUNT_SEL_CSD_RESULT 0x00000000u
N#define CYVAL_CSD_DSI_COUNT_SEL_ADC_RESULT 0x00000001u
N#define CYFLD_CSD_DSI_SAMPLE_EN__OFFSET 0x00000019u
N#define CYFLD_CSD_DSI_SAMPLE_EN__SIZE 0x00000001u
N#define CYFLD_CSD_SAMPLE_SYNC__OFFSET 0x0000001au
N#define CYFLD_CSD_SAMPLE_SYNC__SIZE 0x00000001u
N#define CYFLD_CSD_DSI_SENSE_EN__OFFSET 0x0000001bu
N#define CYFLD_CSD_DSI_SENSE_EN__SIZE 0x00000001u
N#define CYFLD_CSD_LP_MODE__OFFSET 0x0000001eu
N#define CYFLD_CSD_LP_MODE__SIZE 0x00000001u
N#define CYFLD_CSD_ENABLE__OFFSET 0x0000001fu
N#define CYFLD_CSD_ENABLE__SIZE 0x00000001u
N#define CYREG_CSD_SPARE 0x40290004u
N#define CYFLD_CSD_SPARE__OFFSET 0x00000000u
N#define CYFLD_CSD_SPARE__SIZE 0x00000004u
N#define CYREG_CSD_STATUS 0x40290080u
N#define CYFLD_CSD_CSD_CHARGE__OFFSET 0x00000000u
N#define CYFLD_CSD_CSD_CHARGE__SIZE 0x00000001u
N#define CYFLD_CSD_CSD_SENSE__OFFSET 0x00000001u
N#define CYFLD_CSD_CSD_SENSE__SIZE 0x00000001u
N#define CYFLD_CSD_HSCMP_OUT__OFFSET 0x00000002u
N#define CYFLD_CSD_HSCMP_OUT__SIZE 0x00000001u
N#define CYVAL_CSD_HSCMP_OUT_C_LT_VREF 0x00000000u
N#define CYVAL_CSD_HSCMP_OUT_C_GT_VREF 0x00000001u
N#define CYFLD_CSD_CSDCMP_OUT__OFFSET 0x00000003u
N#define CYFLD_CSD_CSDCMP_OUT__SIZE 0x00000001u
N#define CYREG_CSD_STAT_SEQ 0x40290084u
N#define CYFLD_CSD_SEQ_STATE__OFFSET 0x00000000u
N#define CYFLD_CSD_SEQ_STATE__SIZE 0x00000003u
N#define CYFLD_CSD_ADC_STATE__OFFSET 0x00000010u
N#define CYFLD_CSD_ADC_STATE__SIZE 0x00000003u
N#define CYREG_CSD_STAT_CNTS 0x40290088u
N#define CYFLD_CSD_NUM_CONV__OFFSET 0x00000000u
N#define CYFLD_CSD_NUM_CONV__SIZE 0x00000010u
N#define CYREG_CSD_STAT_HCNT 0x4029008cu
N#define CYFLD_CSD_CNT__OFFSET 0x00000000u
N#define CYFLD_CSD_CNT__SIZE 0x00000010u
N#define CYREG_CSD_RESULT_VAL1 0x402900d0u
N#define CYFLD_CSD_VALUE__OFFSET 0x00000000u
N#define CYFLD_CSD_VALUE__SIZE 0x00000010u
N#define CYFLD_CSD_BAD_CONVS__OFFSET 0x00000010u
N#define CYFLD_CSD_BAD_CONVS__SIZE 0x00000008u
N#define CYREG_CSD_RESULT_VAL2 0x402900d4u
N#define CYREG_CSD_ADC_RES 0x402900e0u
N#define CYFLD_CSD_VIN_CNT__OFFSET 0x00000000u
N#define CYFLD_CSD_VIN_CNT__SIZE 0x00000010u
N#define CYFLD_CSD_HSCMP_POL__OFFSET 0x00000010u
N#define CYFLD_CSD_HSCMP_POL__SIZE 0x00000001u
N#define CYFLD_CSD_ADC_OVERFLOW__OFFSET 0x0000001eu
N#define CYFLD_CSD_ADC_OVERFLOW__SIZE 0x00000001u
N#define CYFLD_CSD_ADC_ABORT__OFFSET 0x0000001fu
N#define CYFLD_CSD_ADC_ABORT__SIZE 0x00000001u
N#define CYREG_CSD_INTR 0x402900f0u
N#define CYFLD_CSD_SAMPLE__OFFSET 0x00000001u
N#define CYFLD_CSD_SAMPLE__SIZE 0x00000001u
N#define CYFLD_CSD_INIT__OFFSET 0x00000002u
N#define CYFLD_CSD_INIT__SIZE 0x00000001u
N#define CYFLD_CSD_ADC_RES__OFFSET 0x00000008u
N#define CYFLD_CSD_ADC_RES__SIZE 0x00000001u
N#define CYREG_CSD_INTR_SET 0x402900f4u
N#define CYREG_CSD_INTR_MASK 0x402900f8u
N#define CYREG_CSD_INTR_MASKED 0x402900fcu
N#define CYREG_CSD_HSCMP 0x40290180u
N#define CYFLD_CSD_HSCMP_EN__OFFSET 0x00000000u
N#define CYFLD_CSD_HSCMP_EN__SIZE 0x00000001u
N#define CYVAL_CSD_HSCMP_EN_OFF 0x00000000u
N#define CYVAL_CSD_HSCMP_EN_ON 0x00000001u
N#define CYFLD_CSD_HSCMP_INVERT__OFFSET 0x00000004u
N#define CYFLD_CSD_HSCMP_INVERT__SIZE 0x00000001u
N#define CYFLD_CSD_AZ_EN__OFFSET 0x0000001fu
N#define CYFLD_CSD_AZ_EN__SIZE 0x00000001u
N#define CYREG_CSD_AMBUF 0x40290184u
N#define CYFLD_CSD_PWR_MODE__OFFSET 0x00000000u
N#define CYFLD_CSD_PWR_MODE__SIZE 0x00000002u
N#define CYVAL_CSD_PWR_MODE_OFF 0x00000000u
N#define CYVAL_CSD_PWR_MODE_NORM 0x00000001u
N#define CYVAL_CSD_PWR_MODE_HI 0x00000002u
N#define CYREG_CSD_REFGEN 0x40290188u
N#define CYFLD_CSD_REFGEN_EN__OFFSET 0x00000000u
N#define CYFLD_CSD_REFGEN_EN__SIZE 0x00000001u
N#define CYVAL_CSD_REFGEN_EN_OFF 0x00000000u
N#define CYVAL_CSD_REFGEN_EN_ON 0x00000001u
N#define CYFLD_CSD_BYPASS__OFFSET 0x00000004u
N#define CYFLD_CSD_BYPASS__SIZE 0x00000001u
N#define CYFLD_CSD_VDDA_EN__OFFSET 0x00000005u
N#define CYFLD_CSD_VDDA_EN__SIZE 0x00000001u
N#define CYFLD_CSD_RES_EN__OFFSET 0x00000006u
N#define CYFLD_CSD_RES_EN__SIZE 0x00000001u
N#define CYFLD_CSD_GAIN__OFFSET 0x00000008u
N#define CYFLD_CSD_GAIN__SIZE 0x00000005u
N#define CYFLD_CSD_VREFLO_SEL__OFFSET 0x00000010u
N#define CYFLD_CSD_VREFLO_SEL__SIZE 0x00000005u
N#define CYFLD_CSD_VREFLO_INT__OFFSET 0x00000017u
N#define CYFLD_CSD_VREFLO_INT__SIZE 0x00000001u
N#define CYREG_CSD_CSDCMP 0x4029018cu
N#define CYFLD_CSD_CSDCMP_EN__OFFSET 0x00000000u
N#define CYFLD_CSD_CSDCMP_EN__SIZE 0x00000001u
N#define CYVAL_CSD_CSDCMP_EN_OFF 0x00000000u
N#define CYVAL_CSD_CSDCMP_EN_ON 0x00000001u
N#define CYFLD_CSD_POLARITY_SEL__OFFSET 0x00000004u
N#define CYFLD_CSD_POLARITY_SEL__SIZE 0x00000002u
N#define CYVAL_CSD_POLARITY_SEL_IDACA_POL 0x00000000u
N#define CYVAL_CSD_POLARITY_SEL_IDACB_POL 0x00000001u
N#define CYVAL_CSD_POLARITY_SEL_DUAL_POL 0x00000002u
N#define CYFLD_CSD_CMP_PHASE__OFFSET 0x00000008u
N#define CYFLD_CSD_CMP_PHASE__SIZE 0x00000002u
N#define CYVAL_CSD_CMP_PHASE_FULL 0x00000000u
N#define CYVAL_CSD_CMP_PHASE_PHI1 0x00000001u
N#define CYVAL_CSD_CMP_PHASE_PHI2 0x00000002u
N#define CYVAL_CSD_CMP_PHASE_PHI1_2 0x00000003u
N#define CYFLD_CSD_CMP_MODE__OFFSET 0x0000001cu
N#define CYFLD_CSD_CMP_MODE__SIZE 0x00000001u
N#define CYVAL_CSD_CMP_MODE_CSD 0x00000000u
N#define CYVAL_CSD_CMP_MODE_GP 0x00000001u
N#define CYFLD_CSD_FEEDBACK_MODE__OFFSET 0x0000001du
N#define CYFLD_CSD_FEEDBACK_MODE__SIZE 0x00000001u
N#define CYVAL_CSD_FEEDBACK_MODE_FLOP 0x00000000u
N#define CYVAL_CSD_FEEDBACK_MODE_COMP 0x00000001u
N#define CYREG_CSD_IDACA 0x402901c0u
N#define CYFLD_CSD_VAL__OFFSET 0x00000000u
N#define CYFLD_CSD_VAL__SIZE 0x00000007u
N#define CYFLD_CSD_POL_DYN__OFFSET 0x00000007u
N#define CYFLD_CSD_POL_DYN__SIZE 0x00000001u
N#define CYVAL_CSD_POL_DYN_STATIC 0x00000000u
N#define CYVAL_CSD_POL_DYN_DYNAMIC 0x00000001u
N#define CYFLD_CSD_POLARITY__OFFSET 0x00000008u
N#define CYFLD_CSD_POLARITY__SIZE 0x00000002u
N#define CYVAL_CSD_POLARITY_VSSA_SRC 0x00000000u
N#define CYVAL_CSD_POLARITY_VDDA_SNK 0x00000001u
N#define CYVAL_CSD_POLARITY_SENSE 0x00000002u
N#define CYVAL_CSD_POLARITY_SENSE_INV 0x00000003u
N#define CYFLD_CSD_BAL_MODE__OFFSET 0x0000000au
N#define CYFLD_CSD_BAL_MODE__SIZE 0x00000002u
N#define CYVAL_CSD_BAL_MODE_FULL 0x00000000u
N#define CYVAL_CSD_BAL_MODE_PHI1 0x00000001u
N#define CYVAL_CSD_BAL_MODE_PHI2 0x00000002u
N#define CYVAL_CSD_BAL_MODE_PHI1_2 0x00000003u
N#define CYFLD_CSD_LEG1_MODE__OFFSET 0x00000010u
N#define CYFLD_CSD_LEG1_MODE__SIZE 0x00000002u
N#define CYVAL_CSD_LEG1_MODE_GP_STATIC 0x00000000u
N#define CYVAL_CSD_LEG1_MODE_GP 0x00000001u
N#define CYVAL_CSD_LEG1_MODE_CSD_STATIC 0x00000002u
N#define CYVAL_CSD_LEG1_MODE_CSD 0x00000003u
N#define CYFLD_CSD_LEG2_MODE__OFFSET 0x00000012u
N#define CYFLD_CSD_LEG2_MODE__SIZE 0x00000002u
N#define CYVAL_CSD_LEG2_MODE_GP_STATIC 0x00000000u
N#define CYVAL_CSD_LEG2_MODE_GP 0x00000001u
N#define CYVAL_CSD_LEG2_MODE_CSD_STATIC 0x00000002u
N#define CYVAL_CSD_LEG2_MODE_CSD 0x00000003u
N#define CYFLD_CSD_DSI_CTRL_EN__OFFSET 0x00000015u
N#define CYFLD_CSD_DSI_CTRL_EN__SIZE 0x00000001u
N#define CYFLD_CSD_RANGE__OFFSET 0x00000016u
N#define CYFLD_CSD_RANGE__SIZE 0x00000002u
N#define CYVAL_CSD_RANGE_IDAC_LO 0x00000000u
N#define CYVAL_CSD_RANGE_IDAC_MED 0x00000001u
N#define CYVAL_CSD_RANGE_IDAC_HI 0x00000002u
N#define CYVAL_CSD_RANGE_IDAC_MED2 0x00000003u
N#define CYFLD_CSD_LEG1_EN__OFFSET 0x00000018u
N#define CYFLD_CSD_LEG1_EN__SIZE 0x00000001u
N#define CYFLD_CSD_LEG2_EN__OFFSET 0x00000019u
N#define CYFLD_CSD_LEG2_EN__SIZE 0x00000001u
N#define CYREG_CSD_IDACB 0x402901c4u
N#define CYFLD_CSD_LEG3_EN__OFFSET 0x0000001au
N#define CYFLD_CSD_LEG3_EN__SIZE 0x00000001u
N#define CYREG_CSD_SW_RES 0x402901f0u
N#define CYFLD_CSD_RES_HCAV__OFFSET 0x00000000u
N#define CYFLD_CSD_RES_HCAV__SIZE 0x00000002u
N#define CYVAL_CSD_RES_HCAV_LOW 0x00000000u
N#define CYVAL_CSD_RES_HCAV_MED 0x00000001u
N#define CYVAL_CSD_RES_HCAV_HIGH 0x00000002u
N#define CYVAL_CSD_RES_HCAV_LOWEMI 0x00000003u
N#define CYFLD_CSD_RES_HCAG__OFFSET 0x00000002u
N#define CYFLD_CSD_RES_HCAG__SIZE 0x00000002u
N#define CYFLD_CSD_RES_HCBV__OFFSET 0x00000004u
N#define CYFLD_CSD_RES_HCBV__SIZE 0x00000002u
N#define CYFLD_CSD_RES_HCBG__OFFSET 0x00000006u
N#define CYFLD_CSD_RES_HCBG__SIZE 0x00000002u
N#define CYFLD_CSD_RES_F1PM__OFFSET 0x00000010u
N#define CYFLD_CSD_RES_F1PM__SIZE 0x00000002u
N#define CYVAL_CSD_RES_F1PM_LOW 0x00000000u
N#define CYVAL_CSD_RES_F1PM_MED 0x00000001u
N#define CYVAL_CSD_RES_F1PM_HIGH 0x00000002u
N#define CYVAL_CSD_RES_F1PM_RESERVED 0x00000003u
N#define CYFLD_CSD_RES_F2PT__OFFSET 0x00000012u
N#define CYFLD_CSD_RES_F2PT__SIZE 0x00000002u
N#define CYREG_CSD_SENSE_PERIOD 0x40290200u
N#define CYFLD_CSD_SENSE_DIV__OFFSET 0x00000000u
N#define CYFLD_CSD_SENSE_DIV__SIZE 0x0000000cu
N#define CYFLD_CSD_LFSR_SIZE__OFFSET 0x00000010u
N#define CYFLD_CSD_LFSR_SIZE__SIZE 0x00000003u
N#define CYVAL_CSD_LFSR_SIZE_OFF 0x00000000u
N#define CYVAL_CSD_LFSR_SIZE_6B 0x00000001u
N#define CYVAL_CSD_LFSR_SIZE_7B 0x00000002u
N#define CYVAL_CSD_LFSR_SIZE_9B 0x00000003u
N#define CYVAL_CSD_LFSR_SIZE_10B 0x00000004u
N#define CYVAL_CSD_LFSR_SIZE_8B 0x00000005u
N#define CYVAL_CSD_LFSR_SIZE_12B 0x00000006u
N#define CYFLD_CSD_LFSR_SCALE__OFFSET 0x00000014u
N#define CYFLD_CSD_LFSR_SCALE__SIZE 0x00000004u
N#define CYFLD_CSD_LFSR_CLEAR__OFFSET 0x00000018u
N#define CYFLD_CSD_LFSR_CLEAR__SIZE 0x00000001u
N#define CYFLD_CSD_SEL_LFSR_MSB__OFFSET 0x00000019u
N#define CYFLD_CSD_SEL_LFSR_MSB__SIZE 0x00000001u
N#define CYFLD_CSD_LFSR_BITS__OFFSET 0x0000001au
N#define CYFLD_CSD_LFSR_BITS__SIZE 0x00000002u
N#define CYVAL_CSD_LFSR_BITS_2B 0x00000000u
N#define CYVAL_CSD_LFSR_BITS_3B 0x00000001u
N#define CYVAL_CSD_LFSR_BITS_4B 0x00000002u
N#define CYVAL_CSD_LFSR_BITS_5B 0x00000003u
N#define CYREG_CSD_SENSE_DUTY 0x40290204u
N#define CYFLD_CSD_SENSE_WIDTH__OFFSET 0x00000000u
N#define CYFLD_CSD_SENSE_WIDTH__SIZE 0x0000000cu
N#define CYFLD_CSD_SENSE_POL__OFFSET 0x00000010u
N#define CYFLD_CSD_SENSE_POL__SIZE 0x00000001u
N#define CYFLD_CSD_OVERLAP_PHI1__OFFSET 0x00000012u
N#define CYFLD_CSD_OVERLAP_PHI1__SIZE 0x00000001u
N#define CYFLD_CSD_OVERLAP_PHI2__OFFSET 0x00000013u
N#define CYFLD_CSD_OVERLAP_PHI2__SIZE 0x00000001u
N#define CYREG_CSD_SW_HS_P_SEL 0x40290280u
N#define CYFLD_CSD_SW_HMPM__OFFSET 0x00000000u
N#define CYFLD_CSD_SW_HMPM__SIZE 0x00000001u
N#define CYFLD_CSD_SW_HMPT__OFFSET 0x00000004u
N#define CYFLD_CSD_SW_HMPT__SIZE 0x00000001u
N#define CYFLD_CSD_SW_HMPS__OFFSET 0x00000008u
N#define CYFLD_CSD_SW_HMPS__SIZE 0x00000001u
N#define CYFLD_CSD_SW_HMMA__OFFSET 0x0000000cu
N#define CYFLD_CSD_SW_HMMA__SIZE 0x00000001u
N#define CYFLD_CSD_SW_HMMB__OFFSET 0x00000010u
N#define CYFLD_CSD_SW_HMMB__SIZE 0x00000001u
N#define CYFLD_CSD_SW_HMCA__OFFSET 0x00000014u
N#define CYFLD_CSD_SW_HMCA__SIZE 0x00000001u
N#define CYFLD_CSD_SW_HMCB__OFFSET 0x00000018u
N#define CYFLD_CSD_SW_HMCB__SIZE 0x00000001u
N#define CYFLD_CSD_SW_HMRH__OFFSET 0x0000001cu
N#define CYFLD_CSD_SW_HMRH__SIZE 0x00000001u
N#define CYREG_CSD_SW_HS_N_SEL 0x40290284u
N#define CYFLD_CSD_SW_HCCC__OFFSET 0x00000010u
N#define CYFLD_CSD_SW_HCCC__SIZE 0x00000001u
N#define CYFLD_CSD_SW_HCCD__OFFSET 0x00000014u
N#define CYFLD_CSD_SW_HCCD__SIZE 0x00000001u
N#define CYFLD_CSD_SW_HCRH__OFFSET 0x00000018u
N#define CYFLD_CSD_SW_HCRH__SIZE 0x00000003u
N#define CYFLD_CSD_SW_HCRL__OFFSET 0x0000001cu
N#define CYFLD_CSD_SW_HCRL__SIZE 0x00000003u
N#define CYREG_CSD_SW_SHIELD_SEL 0x40290288u
N#define CYFLD_CSD_SW_HCAV__OFFSET 0x00000000u
N#define CYFLD_CSD_SW_HCAV__SIZE 0x00000003u
N#define CYFLD_CSD_SW_HCAG__OFFSET 0x00000004u
N#define CYFLD_CSD_SW_HCAG__SIZE 0x00000003u
N#define CYFLD_CSD_SW_HCBV__OFFSET 0x00000008u
N#define CYFLD_CSD_SW_HCBV__SIZE 0x00000003u
N#define CYFLD_CSD_SW_HCBG__OFFSET 0x0000000cu
N#define CYFLD_CSD_SW_HCBG__SIZE 0x00000003u
N#define CYFLD_CSD_SW_HCCV__OFFSET 0x00000010u
N#define CYFLD_CSD_SW_HCCV__SIZE 0x00000001u
N#define CYFLD_CSD_SW_HCCG__OFFSET 0x00000014u
N#define CYFLD_CSD_SW_HCCG__SIZE 0x00000001u
N#define CYREG_CSD_SW_HS_P_SEL1 0x4029028cu
N#define CYFLD_CSD_SW_HMRE__OFFSET 0x00000000u
N#define CYFLD_CSD_SW_HMRE__SIZE 0x00000001u
N#define CYREG_CSD_SW_AMUXBUF_SEL 0x40290290u
N#define CYFLD_CSD_SW_IRBY__OFFSET 0x00000004u
N#define CYFLD_CSD_SW_IRBY__SIZE 0x00000001u
N#define CYFLD_CSD_SW_IRLB__OFFSET 0x00000008u
N#define CYFLD_CSD_SW_IRLB__SIZE 0x00000001u
N#define CYFLD_CSD_SW_ICA__OFFSET 0x0000000cu
N#define CYFLD_CSD_SW_ICA__SIZE 0x00000001u
N#define CYFLD_CSD_SW_ICB__OFFSET 0x00000010u
N#define CYFLD_CSD_SW_ICB__SIZE 0x00000003u
N#define CYFLD_CSD_SW_IRLI__OFFSET 0x00000014u
N#define CYFLD_CSD_SW_IRLI__SIZE 0x00000001u
N#define CYFLD_CSD_SW_IRH__OFFSET 0x00000018u
N#define CYFLD_CSD_SW_IRH__SIZE 0x00000001u
N#define CYFLD_CSD_SW_IRL__OFFSET 0x0000001cu
N#define CYFLD_CSD_SW_IRL__SIZE 0x00000001u
N#define CYREG_CSD_SW_BYP_SEL 0x40290294u
N#define CYFLD_CSD_SW_BYA__OFFSET 0x0000000cu
N#define CYFLD_CSD_SW_BYA__SIZE 0x00000001u
N#define CYFLD_CSD_SW_BYB__OFFSET 0x00000010u
N#define CYFLD_CSD_SW_BYB__SIZE 0x00000001u
N#define CYFLD_CSD_SW_CBCC__OFFSET 0x00000014u
N#define CYFLD_CSD_SW_CBCC__SIZE 0x00000001u
N#define CYREG_CSD_SW_CMP_P_SEL 0x402902a0u
N#define CYFLD_CSD_SW_SFPM__OFFSET 0x00000000u
N#define CYFLD_CSD_SW_SFPM__SIZE 0x00000003u
N#define CYFLD_CSD_SW_SFPT__OFFSET 0x00000004u
N#define CYFLD_CSD_SW_SFPT__SIZE 0x00000003u
N#define CYFLD_CSD_SW_SFPS__OFFSET 0x00000008u
N#define CYFLD_CSD_SW_SFPS__SIZE 0x00000003u
N#define CYFLD_CSD_SW_SFMA__OFFSET 0x0000000cu
N#define CYFLD_CSD_SW_SFMA__SIZE 0x00000001u
N#define CYFLD_CSD_SW_SFMB__OFFSET 0x00000010u
N#define CYFLD_CSD_SW_SFMB__SIZE 0x00000001u
N#define CYFLD_CSD_SW_SFCA__OFFSET 0x00000014u
N#define CYFLD_CSD_SW_SFCA__SIZE 0x00000001u
N#define CYFLD_CSD_SW_SFCB__OFFSET 0x00000018u
N#define CYFLD_CSD_SW_SFCB__SIZE 0x00000001u
N#define CYREG_CSD_SW_CMP_N_SEL 0x402902a4u
N#define CYFLD_CSD_SW_SCRH__OFFSET 0x00000018u
N#define CYFLD_CSD_SW_SCRH__SIZE 0x00000003u
N#define CYFLD_CSD_SW_SCRL__OFFSET 0x0000001cu
N#define CYFLD_CSD_SW_SCRL__SIZE 0x00000003u
N#define CYREG_CSD_SW_REFGEN_SEL 0x402902a8u
N#define CYFLD_CSD_SW_IAIB__OFFSET 0x00000000u
N#define CYFLD_CSD_SW_IAIB__SIZE 0x00000001u
N#define CYFLD_CSD_SW_IBCB__OFFSET 0x00000004u
N#define CYFLD_CSD_SW_IBCB__SIZE 0x00000001u
N#define CYFLD_CSD_SW_SGMB__OFFSET 0x00000010u
N#define CYFLD_CSD_SW_SGMB__SIZE 0x00000001u
N#define CYFLD_CSD_SW_SGRE__OFFSET 0x00000018u
N#define CYFLD_CSD_SW_SGRE__SIZE 0x00000001u
N#define CYFLD_CSD_SW_SGR__OFFSET 0x0000001cu
N#define CYFLD_CSD_SW_SGR__SIZE 0x00000001u
N#define CYREG_CSD_SW_FW_MOD_SEL 0x402902b0u
N#define CYFLD_CSD_SW_F1PM__OFFSET 0x00000000u
N#define CYFLD_CSD_SW_F1PM__SIZE 0x00000001u
N#define CYFLD_CSD_SW_F1MA__OFFSET 0x00000008u
N#define CYFLD_CSD_SW_F1MA__SIZE 0x00000003u
N#define CYFLD_CSD_SW_F1CA__OFFSET 0x00000010u
N#define CYFLD_CSD_SW_F1CA__SIZE 0x00000003u
N#define CYFLD_CSD_SW_C1CC__OFFSET 0x00000014u
N#define CYFLD_CSD_SW_C1CC__SIZE 0x00000001u
N#define CYFLD_CSD_SW_C1CD__OFFSET 0x00000018u
N#define CYFLD_CSD_SW_C1CD__SIZE 0x00000001u
N#define CYFLD_CSD_SW_C1F1__OFFSET 0x0000001cu
N#define CYFLD_CSD_SW_C1F1__SIZE 0x00000001u
N#define CYREG_CSD_SW_FW_TANK_SEL 0x402902b4u
N#define CYFLD_CSD_SW_F2PT__OFFSET 0x00000004u
N#define CYFLD_CSD_SW_F2PT__SIZE 0x00000001u
N#define CYFLD_CSD_SW_F2MA__OFFSET 0x00000008u
N#define CYFLD_CSD_SW_F2MA__SIZE 0x00000003u
N#define CYFLD_CSD_SW_F2CA__OFFSET 0x0000000cu
N#define CYFLD_CSD_SW_F2CA__SIZE 0x00000003u
N#define CYFLD_CSD_SW_F2CB__OFFSET 0x00000010u
N#define CYFLD_CSD_SW_F2CB__SIZE 0x00000003u
N#define CYFLD_CSD_SW_C2CC__OFFSET 0x00000014u
N#define CYFLD_CSD_SW_C2CC__SIZE 0x00000001u
N#define CYFLD_CSD_SW_C2CD__OFFSET 0x00000018u
N#define CYFLD_CSD_SW_C2CD__SIZE 0x00000001u
N#define CYFLD_CSD_SW_C2F2__OFFSET 0x0000001cu
N#define CYFLD_CSD_SW_C2F2__SIZE 0x00000001u
N#define CYREG_CSD_SW_DSI_SEL 0x402902c0u
N#define CYFLD_CSD_DSI_CSH_TANK__OFFSET 0x00000000u
N#define CYFLD_CSD_DSI_CSH_TANK__SIZE 0x00000003u
N#define CYFLD_CSD_DSI_CMOD__OFFSET 0x00000004u
N#define CYFLD_CSD_DSI_CMOD__SIZE 0x00000003u
N#define CYREG_CSD_SEQ_TIME 0x40290300u
N#define CYFLD_CSD_AZ_TIME__OFFSET 0x00000000u
N#define CYFLD_CSD_AZ_TIME__SIZE 0x00000008u
N#define CYREG_CSD_SEQ_INIT_CNT 0x40290310u
N#define CYFLD_CSD_CONV_CNT__OFFSET 0x00000000u
N#define CYFLD_CSD_CONV_CNT__SIZE 0x00000010u
N#define CYREG_CSD_SEQ_NORM_CNT 0x40290314u
N#define CYREG_CSD_ADC_CTL 0x40290320u
N#define CYFLD_CSD_ADC_TIME__OFFSET 0x00000000u
N#define CYFLD_CSD_ADC_TIME__SIZE 0x00000008u
N#define CYFLD_CSD_ADC_MODE__OFFSET 0x00000010u
N#define CYFLD_CSD_ADC_MODE__SIZE 0x00000002u
N#define CYVAL_CSD_ADC_MODE_OFF 0x00000000u
N#define CYVAL_CSD_ADC_MODE_VREF_CNT 0x00000001u
N#define CYVAL_CSD_ADC_MODE_VREF_BY2_CNT 0x00000002u
N#define CYVAL_CSD_ADC_MODE_VIN_CNT 0x00000003u
N#define CYREG_CSD_SEQ_START 0x40290340u
N#define CYFLD_CSD_START__OFFSET 0x00000000u
N#define CYFLD_CSD_START__SIZE 0x00000001u
N#define CYFLD_CSD_SEQ_MODE__OFFSET 0x00000001u
N#define CYFLD_CSD_SEQ_MODE__SIZE 0x00000001u
N#define CYFLD_CSD_ABORT__OFFSET 0x00000003u
N#define CYFLD_CSD_ABORT__SIZE 0x00000001u
N#define CYFLD_CSD_DSI_START_EN__OFFSET 0x00000004u
N#define CYFLD_CSD_DSI_START_EN__SIZE 0x00000001u
N#define CYFLD_CSD_AZ0_SKIP__OFFSET 0x00000008u
N#define CYFLD_CSD_AZ0_SKIP__SIZE 0x00000001u
N#define CYFLD_CSD_AZ1_SKIP__OFFSET 0x00000009u
N#define CYFLD_CSD_AZ1_SKIP__SIZE 0x00000001u
N#define CYDEV_LCD_BASE 0x402a0000u
N#define CYDEV_LCD_SIZE 0x00010000u
N#define CYREG_LCD_ID 0x402a0000u
N#define CYFLD_LCD_ID__OFFSET 0x00000000u
N#define CYFLD_LCD_ID__SIZE 0x00000010u
N#define CYFLD_LCD_REVISION__OFFSET 0x00000010u
N#define CYFLD_LCD_REVISION__SIZE 0x00000010u
N#define CYREG_LCD_DIVIDER 0x402a0004u
N#define CYFLD_LCD_SUBFR_DIV__OFFSET 0x00000000u
N#define CYFLD_LCD_SUBFR_DIV__SIZE 0x00000010u
N#define CYFLD_LCD_DEAD_DIV__OFFSET 0x00000010u
N#define CYFLD_LCD_DEAD_DIV__SIZE 0x00000010u
N#define CYREG_LCD_CONTROL 0x402a0008u
N#define CYFLD_LCD_LS_EN__OFFSET 0x00000000u
N#define CYFLD_LCD_LS_EN__SIZE 0x00000001u
N#define CYFLD_LCD_HS_EN__OFFSET 0x00000001u
N#define CYFLD_LCD_HS_EN__SIZE 0x00000001u
N#define CYFLD_LCD_LCD_MODE__OFFSET 0x00000002u
N#define CYFLD_LCD_LCD_MODE__SIZE 0x00000001u
N#define CYVAL_LCD_LCD_MODE_LS 0x00000000u
N#define CYVAL_LCD_LCD_MODE_HS 0x00000001u
N#define CYFLD_LCD_TYPE__OFFSET 0x00000003u
N#define CYFLD_LCD_TYPE__SIZE 0x00000001u
N#define CYVAL_LCD_TYPE_TYPE_A 0x00000000u
N#define CYVAL_LCD_TYPE_TYPE_B 0x00000001u
N#define CYFLD_LCD_OP_MODE__OFFSET 0x00000004u
N#define CYFLD_LCD_OP_MODE__SIZE 0x00000001u
N#define CYVAL_LCD_OP_MODE_PWM 0x00000000u
N#define CYVAL_LCD_OP_MODE_CORRELATION 0x00000001u
N#define CYFLD_LCD_BIAS__OFFSET 0x00000005u
N#define CYFLD_LCD_BIAS__SIZE 0x00000002u
N#define CYVAL_LCD_BIAS_HALF 0x00000000u
N#define CYVAL_LCD_BIAS_THIRD 0x00000001u
N#define CYVAL_LCD_BIAS_FOURTH 0x00000002u
N#define CYVAL_LCD_BIAS_FIFTH 0x00000003u
N#define CYFLD_LCD_COM_NUM__OFFSET 0x00000008u
N#define CYFLD_LCD_COM_NUM__SIZE 0x00000004u
N#define CYFLD_LCD_LS_EN_STAT__OFFSET 0x0000001fu
N#define CYFLD_LCD_LS_EN_STAT__SIZE 0x00000001u
N#define CYREG_LCD_DATA00 0x402a0100u
N#define CYFLD_LCD_DATA__OFFSET 0x00000000u
N#define CYFLD_LCD_DATA__SIZE 0x00000020u
N#define CYREG_LCD_DATA01 0x402a0104u
N#define CYREG_LCD_DATA02 0x402a0108u
N#define CYREG_LCD_DATA03 0x402a010cu
N#define CYREG_LCD_DATA04 0x402a0110u
N#define CYREG_LCD_DATA05 0x402a0114u
N#define CYREG_LCD_DATA06 0x402a0118u
N#define CYREG_LCD_DATA07 0x402a011cu
N#define CYREG_LCD_DATA10 0x402a0200u
N#define CYREG_LCD_DATA11 0x402a0204u
N#define CYREG_LCD_DATA12 0x402a0208u
N#define CYREG_LCD_DATA13 0x402a020cu
N#define CYREG_LCD_DATA14 0x402a0210u
N#define CYREG_LCD_DATA15 0x402a0214u
N#define CYREG_LCD_DATA16 0x402a0218u
N#define CYREG_LCD_DATA17 0x402a021cu
N#define CYDEV_LPCOMP_BASE 0x402b0000u
N#define CYDEV_LPCOMP_SIZE 0x00010000u
N#define CYREG_LPCOMP_ID 0x402b0000u
N#define CYFLD_LPCOMP_ID__OFFSET 0x00000000u
N#define CYFLD_LPCOMP_ID__SIZE 0x00000010u
N#define CYFLD_LPCOMP_REVISION__OFFSET 0x00000010u
N#define CYFLD_LPCOMP_REVISION__SIZE 0x00000010u
N#define CYREG_LPCOMP_CONFIG 0x402b0004u
N#define CYFLD_LPCOMP_MODE1__OFFSET 0x00000000u
N#define CYFLD_LPCOMP_MODE1__SIZE 0x00000002u
N#define CYVAL_LPCOMP_MODE1_SLOW 0x00000000u
N#define CYVAL_LPCOMP_MODE1_FAST 0x00000001u
N#define CYVAL_LPCOMP_MODE1_ULP 0x00000002u
N#define CYFLD_LPCOMP_HYST1__OFFSET 0x00000002u
N#define CYFLD_LPCOMP_HYST1__SIZE 0x00000001u
N#define CYFLD_LPCOMP_FILTER1__OFFSET 0x00000003u
N#define CYFLD_LPCOMP_FILTER1__SIZE 0x00000001u
N#define CYFLD_LPCOMP_INTTYPE1__OFFSET 0x00000004u
N#define CYFLD_LPCOMP_INTTYPE1__SIZE 0x00000002u
N#define CYVAL_LPCOMP_INTTYPE1_DISABLE 0x00000000u
N#define CYVAL_LPCOMP_INTTYPE1_RISING 0x00000001u
N#define CYVAL_LPCOMP_INTTYPE1_FALLING 0x00000002u
N#define CYVAL_LPCOMP_INTTYPE1_BOTH 0x00000003u
N#define CYFLD_LPCOMP_OUT1__OFFSET 0x00000006u
N#define CYFLD_LPCOMP_OUT1__SIZE 0x00000001u
N#define CYFLD_LPCOMP_ENABLE1__OFFSET 0x00000007u
N#define CYFLD_LPCOMP_ENABLE1__SIZE 0x00000001u
N#define CYFLD_LPCOMP_MODE2__OFFSET 0x00000008u
N#define CYFLD_LPCOMP_MODE2__SIZE 0x00000002u
N#define CYVAL_LPCOMP_MODE2_SLOW 0x00000000u
N#define CYVAL_LPCOMP_MODE2_FAST 0x00000001u
N#define CYVAL_LPCOMP_MODE2_ULP 0x00000002u
N#define CYFLD_LPCOMP_HYST2__OFFSET 0x0000000au
N#define CYFLD_LPCOMP_HYST2__SIZE 0x00000001u
N#define CYFLD_LPCOMP_FILTER2__OFFSET 0x0000000bu
N#define CYFLD_LPCOMP_FILTER2__SIZE 0x00000001u
N#define CYFLD_LPCOMP_INTTYPE2__OFFSET 0x0000000cu
N#define CYFLD_LPCOMP_INTTYPE2__SIZE 0x00000002u
N#define CYVAL_LPCOMP_INTTYPE2_DISABLE 0x00000000u
N#define CYVAL_LPCOMP_INTTYPE2_RISING 0x00000001u
N#define CYVAL_LPCOMP_INTTYPE2_FALLING 0x00000002u
N#define CYVAL_LPCOMP_INTTYPE2_BOTH 0x00000003u
N#define CYFLD_LPCOMP_OUT2__OFFSET 0x0000000eu
N#define CYFLD_LPCOMP_OUT2__SIZE 0x00000001u
N#define CYFLD_LPCOMP_ENABLE2__OFFSET 0x0000000fu
N#define CYFLD_LPCOMP_ENABLE2__SIZE 0x00000001u
N#define CYFLD_LPCOMP_DSI_BYPASS1__OFFSET 0x00000010u
N#define CYFLD_LPCOMP_DSI_BYPASS1__SIZE 0x00000001u
N#define CYFLD_LPCOMP_DSI_LEVEL1__OFFSET 0x00000011u
N#define CYFLD_LPCOMP_DSI_LEVEL1__SIZE 0x00000001u
N#define CYFLD_LPCOMP_DSI_BYPASS2__OFFSET 0x00000014u
N#define CYFLD_LPCOMP_DSI_BYPASS2__SIZE 0x00000001u
N#define CYFLD_LPCOMP_DSI_LEVEL2__OFFSET 0x00000015u
N#define CYFLD_LPCOMP_DSI_LEVEL2__SIZE 0x00000001u
N#define CYREG_LPCOMP_DFT 0x402b0008u
N#define CYFLD_LPCOMP_CAL_EN__OFFSET 0x00000000u
N#define CYFLD_LPCOMP_CAL_EN__SIZE 0x00000001u
N#define CYFLD_LPCOMP_BYPASS__OFFSET 0x00000001u
N#define CYFLD_LPCOMP_BYPASS__SIZE 0x00000001u
N#define CYREG_LPCOMP_INTR 0x402b0010u
N#define CYFLD_LPCOMP_COMP1__OFFSET 0x00000000u
N#define CYFLD_LPCOMP_COMP1__SIZE 0x00000001u
N#define CYFLD_LPCOMP_COMP2__OFFSET 0x00000001u
N#define CYFLD_LPCOMP_COMP2__SIZE 0x00000001u
N#define CYREG_LPCOMP_INTR_SET 0x402b0014u
N#define CYREG_LPCOMP_INTR_MASK 0x402b0018u
N#define CYFLD_LPCOMP_COMP1_MASK__OFFSET 0x00000000u
N#define CYFLD_LPCOMP_COMP1_MASK__SIZE 0x00000001u
N#define CYFLD_LPCOMP_COMP2_MASK__OFFSET 0x00000001u
N#define CYFLD_LPCOMP_COMP2_MASK__SIZE 0x00000001u
N#define CYREG_LPCOMP_INTR_MASKED 0x402b001cu
N#define CYFLD_LPCOMP_COMP1_MASKED__OFFSET 0x00000000u
N#define CYFLD_LPCOMP_COMP1_MASKED__SIZE 0x00000001u
N#define CYFLD_LPCOMP_COMP2_MASKED__OFFSET 0x00000001u
N#define CYFLD_LPCOMP_COMP2_MASKED__SIZE 0x00000001u
N#define CYREG_LPCOMP_TRIM1 0x402bff00u
N#define CYFLD_LPCOMP_COMP1_TRIMA__OFFSET 0x00000000u
N#define CYFLD_LPCOMP_COMP1_TRIMA__SIZE 0x00000005u
N#define CYREG_LPCOMP_TRIM2 0x402bff04u
N#define CYFLD_LPCOMP_COMP1_TRIMB__OFFSET 0x00000000u
N#define CYFLD_LPCOMP_COMP1_TRIMB__SIZE 0x00000005u
N#define CYREG_LPCOMP_TRIM3 0x402bff08u
N#define CYFLD_LPCOMP_COMP2_TRIMA__OFFSET 0x00000000u
N#define CYFLD_LPCOMP_COMP2_TRIMA__SIZE 0x00000005u
N#define CYREG_LPCOMP_TRIM4 0x402bff0cu
N#define CYFLD_LPCOMP_COMP2_TRIMB__OFFSET 0x00000000u
N#define CYFLD_LPCOMP_COMP2_TRIMB__SIZE 0x00000005u
N#define CYDEV_CRYPTO_BASE 0x402c0000u
N#define CYDEV_CRYPTO_SIZE 0x00010000u
N#define CYREG_CRYPTO_CTL 0x402c0000u
N#define CYFLD_CRYPTO_OPCODE__OFFSET 0x00000000u
N#define CYFLD_CRYPTO_OPCODE__SIZE 0x00000005u
N#define CYVAL_CRYPTO_OPCODE_AES_FORWARD 0x00000000u
N#define CYVAL_CRYPTO_OPCODE_AES_INVERSE 0x00000001u
N#define CYVAL_CRYPTO_OPCODE_SHA 0x00000010u
N#define CYVAL_CRYPTO_OPCODE_CRC 0x00000018u
N#define CYFLD_CRYPTO_ENABLED__OFFSET 0x0000001fu
N#define CYFLD_CRYPTO_ENABLED__SIZE 0x00000001u
N#define CYREG_CRYPTO_STATUS 0x402c0004u
N#define CYFLD_CRYPTO_BUSY__OFFSET 0x00000000u
N#define CYFLD_CRYPTO_BUSY__SIZE 0x00000001u
N#define CYREG_CRYPTO_CMD 0x402c0008u
N#define CYFLD_CRYPTO_START__OFFSET 0x00000000u
N#define CYFLD_CRYPTO_START__SIZE 0x00000001u
N#define CYREG_CRYPTO_TR_CTL0 0x402c0280u
N#define CYFLD_CRYPTO_SAMPLE_CLOCK_DIV__OFFSET 0x00000000u
N#define CYFLD_CRYPTO_SAMPLE_CLOCK_DIV__SIZE 0x00000008u
N#define CYFLD_CRYPTO_RED_CLOCK_DIV__OFFSET 0x00000008u
N#define CYFLD_CRYPTO_RED_CLOCK_DIV__SIZE 0x00000008u
N#define CYFLD_CRYPTO_INIT_DELAY__OFFSET 0x00000010u
N#define CYFLD_CRYPTO_INIT_DELAY__SIZE 0x00000008u
N#define CYFLD_CRYPTO_VON_NEUMANN_CORR__OFFSET 0x00000018u
N#define CYFLD_CRYPTO_VON_NEUMANN_CORR__SIZE 0x00000001u
N#define CYFLD_CRYPTO_STOP_ON_AP_DETECT__OFFSET 0x0000001cu
N#define CYFLD_CRYPTO_STOP_ON_AP_DETECT__SIZE 0x00000001u
N#define CYFLD_CRYPTO_STOP_ON_RC_DETECT__OFFSET 0x0000001du
N#define CYFLD_CRYPTO_STOP_ON_RC_DETECT__SIZE 0x00000001u
N#define CYREG_CRYPTO_TR_CTL1 0x402c0284u
N#define CYFLD_CRYPTO_DATA_BIT_SIZE__OFFSET 0x00000000u
N#define CYFLD_CRYPTO_DATA_BIT_SIZE__SIZE 0x00000006u
N#define CYREG_CRYPTO_TR_RESULT0 0x402c0288u
N#define CYFLD_CRYPTO_DATA32__OFFSET 0x00000000u
N#define CYFLD_CRYPTO_DATA32__SIZE 0x00000020u
N#define CYREG_CRYPTO_TR_RESULT1 0x402c028cu
N#define CYREG_CRYPTO_TR_CMD 0x402c0290u
N#define CYFLD_CRYPTO_START_RO11__OFFSET 0x00000000u
N#define CYFLD_CRYPTO_START_RO11__SIZE 0x00000001u
N#define CYFLD_CRYPTO_START_RO15__OFFSET 0x00000001u
N#define CYFLD_CRYPTO_START_RO15__SIZE 0x00000001u
N#define CYFLD_CRYPTO_START_GARO15__OFFSET 0x00000002u
N#define CYFLD_CRYPTO_START_GARO15__SIZE 0x00000001u
N#define CYFLD_CRYPTO_START_GARO31__OFFSET 0x00000003u
N#define CYFLD_CRYPTO_START_GARO31__SIZE 0x00000001u
N#define CYFLD_CRYPTO_START_FIRO15__OFFSET 0x00000004u
N#define CYFLD_CRYPTO_START_FIRO15__SIZE 0x00000001u
N#define CYFLD_CRYPTO_START_FIRO31__OFFSET 0x00000005u
N#define CYFLD_CRYPTO_START_FIRO31__SIZE 0x00000001u
N#define CYREG_CRYPTO_TR_GARO_CTL 0x402c02a0u
N#define CYFLD_CRYPTO_POLYNOMIAL31__OFFSET 0x00000000u
N#define CYFLD_CRYPTO_POLYNOMIAL31__SIZE 0x0000001fu
N#define CYREG_CRYPTO_TR_FIRO_CTL 0x402c02a4u
N#define CYREG_CRYPTO_TR_MON_CTL 0x402c02c0u
N#define CYFLD_CRYPTO_BITSTREAM_SEL__OFFSET 0x00000000u
N#define CYFLD_CRYPTO_BITSTREAM_SEL__SIZE 0x00000002u
N#define CYREG_CRYPTO_TR_MON_CMD 0x402c02c8u
N#define CYFLD_CRYPTO_START_AP__OFFSET 0x00000000u
N#define CYFLD_CRYPTO_START_AP__SIZE 0x00000001u
N#define CYFLD_CRYPTO_START_RC__OFFSET 0x00000001u
N#define CYFLD_CRYPTO_START_RC__SIZE 0x00000001u
N#define CYREG_CRYPTO_TR_MON_RC_CTL 0x402c02d0u
N#define CYFLD_CRYPTO_CUTOFF_COUNT8__OFFSET 0x00000000u
N#define CYFLD_CRYPTO_CUTOFF_COUNT8__SIZE 0x00000008u
N#define CYREG_CRYPTO_TR_MON_RC_STATUS0 0x402c02d8u
N#define CYFLD_CRYPTO_BIT__OFFSET 0x00000000u
N#define CYFLD_CRYPTO_BIT__SIZE 0x00000001u
N#define CYREG_CRYPTO_TR_MON_RC_STATUS1 0x402c02dcu
N#define CYFLD_CRYPTO_REP_COUNT__OFFSET 0x00000000u
N#define CYFLD_CRYPTO_REP_COUNT__SIZE 0x00000008u
N#define CYREG_CRYPTO_TR_MON_AP_CTL 0x402c02e0u
N#define CYFLD_CRYPTO_CUTOFF_COUNT16__OFFSET 0x00000000u
N#define CYFLD_CRYPTO_CUTOFF_COUNT16__SIZE 0x00000010u
N#define CYFLD_CRYPTO_WINDOW_SIZE__OFFSET 0x00000010u
N#define CYFLD_CRYPTO_WINDOW_SIZE__SIZE 0x00000010u
N#define CYREG_CRYPTO_TR_MON_AP_STATUS0 0x402c02e8u
N#define CYREG_CRYPTO_TR_MON_AP_STATUS1 0x402c02ecu
N#define CYFLD_CRYPTO_OCC_COUNT__OFFSET 0x00000000u
N#define CYFLD_CRYPTO_OCC_COUNT__SIZE 0x00000010u
N#define CYFLD_CRYPTO_WINDOW_INDEX__OFFSET 0x00000010u
N#define CYFLD_CRYPTO_WINDOW_INDEX__SIZE 0x00000010u
N#define CYREG_CRYPTO_INTR 0x402c07c0u
N#define CYFLD_CRYPTO_DONE__OFFSET 0x00000000u
N#define CYFLD_CRYPTO_DONE__SIZE 0x00000001u
N#define CYFLD_CRYPTO_ACCESS_ERROR__OFFSET 0x00000001u
N#define CYFLD_CRYPTO_ACCESS_ERROR__SIZE 0x00000001u
N#define CYFLD_CRYPTO_TR_INITIALIZED__OFFSET 0x00000006u
N#define CYFLD_CRYPTO_TR_INITIALIZED__SIZE 0x00000001u
N#define CYFLD_CRYPTO_TR_DATA_AVAILABLE__OFFSET 0x00000007u
N#define CYFLD_CRYPTO_TR_DATA_AVAILABLE__SIZE 0x00000001u
N#define CYFLD_CRYPTO_TR_AP_DETECT__OFFSET 0x00000008u
N#define CYFLD_CRYPTO_TR_AP_DETECT__SIZE 0x00000001u
N#define CYFLD_CRYPTO_TR_RC_DETECT__OFFSET 0x00000009u
N#define CYFLD_CRYPTO_TR_RC_DETECT__SIZE 0x00000001u
N#define CYREG_CRYPTO_INTR_SET 0x402c07c4u
N#define CYREG_CRYPTO_INTR_MASK 0x402c07c8u
N#define CYREG_CRYPTO_INTR_MASKED 0x402c07ccu
N#define CYREG_CRYPTO_MEM_BUFF0 0x402c0800u
N#define CYREG_CRYPTO_MEM_BUFF1 0x402c0804u
N#define CYREG_CRYPTO_MEM_BUFF2 0x402c0808u
N#define CYREG_CRYPTO_MEM_BUFF3 0x402c080cu
N#define CYREG_CRYPTO_MEM_BUFF4 0x402c0810u
N#define CYREG_CRYPTO_MEM_BUFF5 0x402c0814u
N#define CYREG_CRYPTO_MEM_BUFF6 0x402c0818u
N#define CYREG_CRYPTO_MEM_BUFF7 0x402c081cu
N#define CYREG_CRYPTO_MEM_BUFF8 0x402c0820u
N#define CYREG_CRYPTO_MEM_BUFF9 0x402c0824u
N#define CYREG_CRYPTO_MEM_BUFF10 0x402c0828u
N#define CYREG_CRYPTO_MEM_BUFF11 0x402c082cu
N#define CYREG_CRYPTO_MEM_BUFF12 0x402c0830u
N#define CYREG_CRYPTO_MEM_BUFF13 0x402c0834u
N#define CYREG_CRYPTO_MEM_BUFF14 0x402c0838u
N#define CYREG_CRYPTO_MEM_BUFF15 0x402c083cu
N#define CYREG_CRYPTO_MEM_BUFF16 0x402c0840u
N#define CYREG_CRYPTO_MEM_BUFF17 0x402c0844u
N#define CYREG_CRYPTO_MEM_BUFF18 0x402c0848u
N#define CYREG_CRYPTO_MEM_BUFF19 0x402c084cu
N#define CYREG_CRYPTO_MEM_BUFF20 0x402c0850u
N#define CYREG_CRYPTO_MEM_BUFF21 0x402c0854u
N#define CYREG_CRYPTO_MEM_BUFF22 0x402c0858u
N#define CYREG_CRYPTO_MEM_BUFF23 0x402c085cu
N#define CYREG_CRYPTO_MEM_BUFF24 0x402c0860u
N#define CYREG_CRYPTO_MEM_BUFF25 0x402c0864u
N#define CYREG_CRYPTO_MEM_BUFF26 0x402c0868u
N#define CYREG_CRYPTO_MEM_BUFF27 0x402c086cu
N#define CYREG_CRYPTO_MEM_BUFF28 0x402c0870u
N#define CYREG_CRYPTO_MEM_BUFF29 0x402c0874u
N#define CYREG_CRYPTO_MEM_BUFF30 0x402c0878u
N#define CYREG_CRYPTO_MEM_BUFF31 0x402c087cu
N#define CYREG_CRYPTO_MEM_BUFF32 0x402c0880u
N#define CYREG_CRYPTO_MEM_BUFF33 0x402c0884u
N#define CYREG_CRYPTO_MEM_BUFF34 0x402c0888u
N#define CYREG_CRYPTO_MEM_BUFF35 0x402c088cu
N#define CYREG_CRYPTO_MEM_BUFF36 0x402c0890u
N#define CYREG_CRYPTO_MEM_BUFF37 0x402c0894u
N#define CYREG_CRYPTO_MEM_BUFF38 0x402c0898u
N#define CYREG_CRYPTO_MEM_BUFF39 0x402c089cu
N#define CYREG_CRYPTO_MEM_BUFF40 0x402c08a0u
N#define CYREG_CRYPTO_MEM_BUFF41 0x402c08a4u
N#define CYREG_CRYPTO_MEM_BUFF42 0x402c08a8u
N#define CYREG_CRYPTO_MEM_BUFF43 0x402c08acu
N#define CYREG_CRYPTO_MEM_BUFF44 0x402c08b0u
N#define CYREG_CRYPTO_MEM_BUFF45 0x402c08b4u
N#define CYREG_CRYPTO_MEM_BUFF46 0x402c08b8u
N#define CYREG_CRYPTO_MEM_BUFF47 0x402c08bcu
N#define CYREG_CRYPTO_MEM_BUFF48 0x402c08c0u
N#define CYREG_CRYPTO_MEM_BUFF49 0x402c08c4u
N#define CYREG_CRYPTO_MEM_BUFF50 0x402c08c8u
N#define CYREG_CRYPTO_MEM_BUFF51 0x402c08ccu
N#define CYREG_CRYPTO_MEM_BUFF52 0x402c08d0u
N#define CYREG_CRYPTO_MEM_BUFF53 0x402c08d4u
N#define CYREG_CRYPTO_MEM_BUFF54 0x402c08d8u
N#define CYREG_CRYPTO_MEM_BUFF55 0x402c08dcu
N#define CYREG_CRYPTO_MEM_BUFF56 0x402c08e0u
N#define CYREG_CRYPTO_MEM_BUFF57 0x402c08e4u
N#define CYREG_CRYPTO_MEM_BUFF58 0x402c08e8u
N#define CYREG_CRYPTO_MEM_BUFF59 0x402c08ecu
N#define CYREG_CRYPTO_MEM_BUFF60 0x402c08f0u
N#define CYREG_CRYPTO_MEM_BUFF61 0x402c08f4u
N#define CYREG_CRYPTO_MEM_BUFF62 0x402c08f8u
N#define CYREG_CRYPTO_MEM_BUFF63 0x402c08fcu
N#define CYREG_CRYPTO_PRIV_BUF 0x402cff00u
N#define CYFLD_CRYPTO_BUF_PRIV_LIMIT__OFFSET 0x00000000u
N#define CYFLD_CRYPTO_BUF_PRIV_LIMIT__SIZE 0x00000003u
N#define CYDEV_CAN_BASE 0x402e0000u
N#define CYDEV_CAN_SIZE 0x00010000u
N#define CYREG_CAN_INT_STATUS 0x402e0000u
N#define CYFLD_CAN_ARB_LOSS__OFFSET 0x00000002u
N#define CYFLD_CAN_ARB_LOSS__SIZE 0x00000001u
N#define CYFLD_CAN_OVR_LOAD__OFFSET 0x00000003u
N#define CYFLD_CAN_OVR_LOAD__SIZE 0x00000001u
N#define CYFLD_CAN_BIT_ERR__OFFSET 0x00000004u
N#define CYFLD_CAN_BIT_ERR__SIZE 0x00000001u
N#define CYFLD_CAN_STUFF_ERR__OFFSET 0x00000005u
N#define CYFLD_CAN_STUFF_ERR__SIZE 0x00000001u
N#define CYFLD_CAN_ACK_ERR__OFFSET 0x00000006u
N#define CYFLD_CAN_ACK_ERR__SIZE 0x00000001u
N#define CYFLD_CAN_FORM_ERR__OFFSET 0x00000007u
N#define CYFLD_CAN_FORM_ERR__SIZE 0x00000001u
N#define CYFLD_CAN_CRC_ERR__OFFSET 0x00000008u
N#define CYFLD_CAN_CRC_ERR__SIZE 0x00000001u
N#define CYFLD_CAN_BUS_OFF__OFFSET 0x00000009u
N#define CYFLD_CAN_BUS_OFF__SIZE 0x00000001u
N#define CYFLD_CAN_RX_MSG_LOSS__OFFSET 0x0000000au
N#define CYFLD_CAN_RX_MSG_LOSS__SIZE 0x00000001u
N#define CYFLD_CAN_TX_MSG__OFFSET 0x0000000bu
N#define CYFLD_CAN_TX_MSG__SIZE 0x00000001u
N#define CYFLD_CAN_RX_MSG__OFFSET 0x0000000cu
N#define CYFLD_CAN_RX_MSG__SIZE 0x00000001u
N#define CYFLD_CAN_RTR_MSG__OFFSET 0x0000000du
N#define CYFLD_CAN_RTR_MSG__SIZE 0x00000001u
N#define CYFLD_CAN_STUCK_AT_0__OFFSET 0x0000000eu
N#define CYFLD_CAN_STUCK_AT_0__SIZE 0x00000001u
N#define CYFLD_CAN_SST_FAILURE__OFFSET 0x0000000fu
N#define CYFLD_CAN_SST_FAILURE__SIZE 0x00000001u
N#define CYREG_CAN_INT_EBL 0x402e0004u
N#define CYFLD_CAN_GLOBAL_INT_ENBL__OFFSET 0x00000000u
N#define CYFLD_CAN_GLOBAL_INT_ENBL__SIZE 0x00000001u
N#define CYFLD_CAN_ARB_LOSS_ENBL__OFFSET 0x00000002u
N#define CYFLD_CAN_ARB_LOSS_ENBL__SIZE 0x00000001u
N#define CYFLD_CAN_OVR_LOAD_ENBL__OFFSET 0x00000003u
N#define CYFLD_CAN_OVR_LOAD_ENBL__SIZE 0x00000001u
N#define CYFLD_CAN_BIT_ERR_ENBL__OFFSET 0x00000004u
N#define CYFLD_CAN_BIT_ERR_ENBL__SIZE 0x00000001u
N#define CYFLD_CAN_STUFF_ERR_ENBL__OFFSET 0x00000005u
N#define CYFLD_CAN_STUFF_ERR_ENBL__SIZE 0x00000001u
N#define CYFLD_CAN_ACK_ERR_ENBL__OFFSET 0x00000006u
N#define CYFLD_CAN_ACK_ERR_ENBL__SIZE 0x00000001u
N#define CYFLD_CAN_FORM_ERR_ENBL__OFFSET 0x00000007u
N#define CYFLD_CAN_FORM_ERR_ENBL__SIZE 0x00000001u
N#define CYFLD_CAN_CRC_ERR_ENBL__OFFSET 0x00000008u
N#define CYFLD_CAN_CRC_ERR_ENBL__SIZE 0x00000001u
N#define CYFLD_CAN_BUS_OFF_ENBL__OFFSET 0x00000009u
N#define CYFLD_CAN_BUS_OFF_ENBL__SIZE 0x00000001u
N#define CYFLD_CAN_TX_MSG_ENBL__OFFSET 0x0000000bu
N#define CYFLD_CAN_TX_MSG_ENBL__SIZE 0x00000001u
N#define CYFLD_CAN_RX_MSG_ENBl__OFFSET 0x0000000cu
N#define CYFLD_CAN_RX_MSG_ENBl__SIZE 0x00000001u
N#define CYFLD_CAN_RTR_MSG_ENBL__OFFSET 0x0000000du
N#define CYFLD_CAN_RTR_MSG_ENBL__SIZE 0x00000001u
N#define CYFLD_CAN_STUCK_AT_0_ENBL__OFFSET 0x0000000eu
N#define CYFLD_CAN_STUCK_AT_0_ENBL__SIZE 0x00000001u
N#define CYFLD_CAN_SST_FAILURE_ENBL__OFFSET 0x0000000fu
N#define CYFLD_CAN_SST_FAILURE_ENBL__SIZE 0x00000001u
N#define CYREG_CAN_BUFFER_STATUS 0x402e0008u
N#define CYFLD_CAN_RX0_MSG_AV__OFFSET 0x00000000u
N#define CYFLD_CAN_RX0_MSG_AV__SIZE 0x00000001u
N#define CYFLD_CAN_RX1_MSG_AV__OFFSET 0x00000001u
N#define CYFLD_CAN_RX1_MSG_AV__SIZE 0x00000001u
N#define CYFLD_CAN_RX2_MSG_AV__OFFSET 0x00000002u
N#define CYFLD_CAN_RX2_MSG_AV__SIZE 0x00000001u
N#define CYFLD_CAN_RX3_MSG_AV__OFFSET 0x00000003u
N#define CYFLD_CAN_RX3_MSG_AV__SIZE 0x00000001u
N#define CYFLD_CAN_RX4_MSG_AV__OFFSET 0x00000004u
N#define CYFLD_CAN_RX4_MSG_AV__SIZE 0x00000001u
N#define CYFLD_CAN_RX5_MSG_AV__OFFSET 0x00000005u
N#define CYFLD_CAN_RX5_MSG_AV__SIZE 0x00000001u
N#define CYFLD_CAN_RX6_MSG_AV__OFFSET 0x00000006u
N#define CYFLD_CAN_RX6_MSG_AV__SIZE 0x00000001u
N#define CYFLD_CAN_RX7_MSG_AV__OFFSET 0x00000007u
N#define CYFLD_CAN_RX7_MSG_AV__SIZE 0x00000001u
N#define CYFLD_CAN_RX8_MSG_AV__OFFSET 0x00000008u
N#define CYFLD_CAN_RX8_MSG_AV__SIZE 0x00000001u
N#define CYFLD_CAN_RX9_MSG_AV__OFFSET 0x00000009u
N#define CYFLD_CAN_RX9_MSG_AV__SIZE 0x00000001u
N#define CYFLD_CAN_RX10_MSG_AV__OFFSET 0x0000000au
N#define CYFLD_CAN_RX10_MSG_AV__SIZE 0x00000001u
N#define CYFLD_CAN_RX11_MSG_AV__OFFSET 0x0000000bu
N#define CYFLD_CAN_RX11_MSG_AV__SIZE 0x00000001u
N#define CYFLD_CAN_RX12_MSG_AV__OFFSET 0x0000000cu
N#define CYFLD_CAN_RX12_MSG_AV__SIZE 0x00000001u
N#define CYFLD_CAN_RX13_MSG_AV__OFFSET 0x0000000du
N#define CYFLD_CAN_RX13_MSG_AV__SIZE 0x00000001u
N#define CYFLD_CAN_RX14_MSG_AV__OFFSET 0x0000000eu
N#define CYFLD_CAN_RX14_MSG_AV__SIZE 0x00000001u
N#define CYFLD_CAN_RX15_MSG_AV__OFFSET 0x0000000fu
N#define CYFLD_CAN_RX15_MSG_AV__SIZE 0x00000001u
N#define CYFLD_CAN_TX0_REQ_PEND__OFFSET 0x00000010u
N#define CYFLD_CAN_TX0_REQ_PEND__SIZE 0x00000001u
N#define CYFLD_CAN_TX1_REQ_PEND__OFFSET 0x00000011u
N#define CYFLD_CAN_TX1_REQ_PEND__SIZE 0x00000001u
N#define CYFLD_CAN_TX2_REQ_PEND__OFFSET 0x00000012u
N#define CYFLD_CAN_TX2_REQ_PEND__SIZE 0x00000001u
N#define CYFLD_CAN_TX3_REQ_PEND__OFFSET 0x00000013u
N#define CYFLD_CAN_TX3_REQ_PEND__SIZE 0x00000001u
N#define CYFLD_CAN_TX4_REQ_PEND__OFFSET 0x00000014u
N#define CYFLD_CAN_TX4_REQ_PEND__SIZE 0x00000001u
N#define CYFLD_CAN_TX5_REQ_PEND__OFFSET 0x00000015u
N#define CYFLD_CAN_TX5_REQ_PEND__SIZE 0x00000001u
N#define CYFLD_CAN_TX6_REQ_PEND__OFFSET 0x00000016u
N#define CYFLD_CAN_TX6_REQ_PEND__SIZE 0x00000001u
N#define CYFLD_CAN_TX7_REQ_PEND__OFFSET 0x00000017u
N#define CYFLD_CAN_TX7_REQ_PEND__SIZE 0x00000001u
N#define CYREG_CAN_ERROR_STATUS 0x402e000cu
N#define CYFLD_CAN_TX_ERR_CNT__OFFSET 0x00000000u
N#define CYFLD_CAN_TX_ERR_CNT__SIZE 0x00000008u
N#define CYFLD_CAN_RX_ERR_CNT__OFFSET 0x00000008u
N#define CYFLD_CAN_RX_ERR_CNT__SIZE 0x00000008u
N#define CYFLD_CAN_ERROR_STATE__OFFSET 0x00000010u
N#define CYFLD_CAN_ERROR_STATE__SIZE 0x00000002u
N#define CYFLD_CAN_TXGTE96__OFFSET 0x00000012u
N#define CYFLD_CAN_TXGTE96__SIZE 0x00000001u
N#define CYFLD_CAN_RXGTE96__OFFSET 0x00000013u
N#define CYFLD_CAN_RXGTE96__SIZE 0x00000001u
N#define CYREG_CAN_COMMAND 0x402e0010u
N#define CYFLD_CAN_RUN__OFFSET 0x00000000u
N#define CYFLD_CAN_RUN__SIZE 0x00000001u
N#define CYFLD_CAN_LISTEN__OFFSET 0x00000001u
N#define CYFLD_CAN_LISTEN__SIZE 0x00000001u
N#define CYFLD_CAN_LOOPBACK_TEST__OFFSET 0x00000002u
N#define CYFLD_CAN_LOOPBACK_TEST__SIZE 0x00000001u
N#define CYFLD_CAN_SRAM_TEST__OFFSET 0x00000003u
N#define CYFLD_CAN_SRAM_TEST__SIZE 0x00000001u
N#define CYFLD_CAN_IP_REV_NUMBER__OFFSET 0x00000010u
N#define CYFLD_CAN_IP_REV_NUMBER__SIZE 0x00000008u
N#define CYFLD_CAN_IP_MINOR_VERSION__OFFSET 0x00000018u
N#define CYFLD_CAN_IP_MINOR_VERSION__SIZE 0x00000004u
N#define CYFLD_CAN_IP_MAJOR_VERSION__OFFSET 0x0000001cu
N#define CYFLD_CAN_IP_MAJOR_VERSION__SIZE 0x00000004u
N#define CYREG_CAN_CONFIG 0x402e0014u
N#define CYFLD_CAN_EDGE_MODE__OFFSET 0x00000000u
N#define CYFLD_CAN_EDGE_MODE__SIZE 0x00000001u
N#define CYFLD_CAN_SAMPLING_MODE__OFFSET 0x00000001u
N#define CYFLD_CAN_SAMPLING_MODE__SIZE 0x00000001u
N#define CYFLD_CAN_CFG_SJW__OFFSET 0x00000002u
N#define CYFLD_CAN_CFG_SJW__SIZE 0x00000002u
N#define CYFLD_CAN_AUTO_RESTART__OFFSET 0x00000004u
N#define CYFLD_CAN_AUTO_RESTART__SIZE 0x00000001u
N#define CYFLD_CAN_CFG_TSEG2__OFFSET 0x00000005u
N#define CYFLD_CAN_CFG_TSEG2__SIZE 0x00000003u
N#define CYFLD_CAN_CFG_TSEG1__OFFSET 0x00000008u
N#define CYFLD_CAN_CFG_TSEG1__SIZE 0x00000004u
N#define CYFLD_CAN_CFG_ARBITER__OFFSET 0x0000000cu
N#define CYFLD_CAN_CFG_ARBITER__SIZE 0x00000001u
N#define CYFLD_CAN_SWAP_ENDIAN__OFFSET 0x0000000du
N#define CYFLD_CAN_SWAP_ENDIAN__SIZE 0x00000001u
N#define CYFLD_CAN_ECR_MODE__OFFSET 0x0000000eu
N#define CYFLD_CAN_ECR_MODE__SIZE 0x00000001u
N#define CYFLD_CAN_CFG_BITRATE__OFFSET 0x00000010u
N#define CYFLD_CAN_CFG_BITRATE__SIZE 0x0000000fu
N#define CYREG_CAN_ECR 0x402e0018u
N#define CYFLD_CAN_ECR_STATUS__OFFSET 0x00000000u
N#define CYFLD_CAN_ECR_STATUS__SIZE 0x00000001u
N#define CYFLD_CAN_ERROR_TYPE__OFFSET 0x00000001u
N#define CYFLD_CAN_ERROR_TYPE__SIZE 0x00000003u
N#define CYFLD_CAN_RX_MODE__OFFSET 0x00000004u
N#define CYFLD_CAN_RX_MODE__SIZE 0x00000001u
N#define CYFLD_CAN_TX_MODE__OFFSET 0x00000005u
N#define CYFLD_CAN_TX_MODE__SIZE 0x00000001u
N#define CYFLD_CAN_BIT__OFFSET 0x00000006u
N#define CYFLD_CAN_BIT__SIZE 0x00000006u
N#define CYFLD_CAN_Field__OFFSET 0x0000000cu
N#define CYFLD_CAN_Field__SIZE 0x00000005u
N#define CYDEV_CAN_CAN_TX0_BASE 0x402e0020u
N#define CYDEV_CAN_CAN_TX0_SIZE 0x00000010u
N#define CYREG_CAN_CAN_TX0_CONTROL 0x402e0020u
N#define CYFLD_CAN_CAN_TX_TX_REQ__OFFSET 0x00000000u
N#define CYFLD_CAN_CAN_TX_TX_REQ__SIZE 0x00000001u
N#define CYFLD_CAN_CAN_TX_TX_ABORT__OFFSET 0x00000001u
N#define CYFLD_CAN_CAN_TX_TX_ABORT__SIZE 0x00000001u
N#define CYFLD_CAN_CAN_TX_TX_INT_EBL__OFFSET 0x00000002u
N#define CYFLD_CAN_CAN_TX_TX_INT_EBL__SIZE 0x00000001u
N#define CYFLD_CAN_CAN_TX_WPNL__OFFSET 0x00000003u
N#define CYFLD_CAN_CAN_TX_WPNL__SIZE 0x00000001u
N#define CYFLD_CAN_CAN_TX_DLC__OFFSET 0x00000010u
N#define CYFLD_CAN_CAN_TX_DLC__SIZE 0x00000004u
N#define CYFLD_CAN_CAN_TX_IDE__OFFSET 0x00000014u
N#define CYFLD_CAN_CAN_TX_IDE__SIZE 0x00000001u
N#define CYFLD_CAN_CAN_TX_RTR__OFFSET 0x00000015u
N#define CYFLD_CAN_CAN_TX_RTR__SIZE 0x00000001u
N#define CYFLD_CAN_CAN_TX_WPNH__OFFSET 0x00000017u
N#define CYFLD_CAN_CAN_TX_WPNH__SIZE 0x00000001u
N#define CYREG_CAN_CAN_TX0_ID 0x402e0024u
N#define CYFLD_CAN_CAN_TX_ID__OFFSET 0x00000003u
N#define CYFLD_CAN_CAN_TX_ID__SIZE 0x0000001du
N#define CYREG_CAN_CAN_TX0_DATA_HIGH 0x402e0028u
N#define CYFLD_CAN_CAN_TX_DATA__OFFSET 0x00000000u
N#define CYFLD_CAN_CAN_TX_DATA__SIZE 0x00000020u
N#define CYREG_CAN_CAN_TX0_DATA_LOW 0x402e002cu
N#define CYDEV_CAN_CAN_TX1_BASE 0x402e0030u
N#define CYDEV_CAN_CAN_TX1_SIZE 0x00000010u
N#define CYREG_CAN_CAN_TX1_CONTROL 0x402e0030u
N#define CYREG_CAN_CAN_TX1_ID 0x402e0034u
N#define CYREG_CAN_CAN_TX1_DATA_HIGH 0x402e0038u
N#define CYREG_CAN_CAN_TX1_DATA_LOW 0x402e003cu
N#define CYDEV_CAN_CAN_TX2_BASE 0x402e0040u
N#define CYDEV_CAN_CAN_TX2_SIZE 0x00000010u
N#define CYREG_CAN_CAN_TX2_CONTROL 0x402e0040u
N#define CYREG_CAN_CAN_TX2_ID 0x402e0044u
N#define CYREG_CAN_CAN_TX2_DATA_HIGH 0x402e0048u
N#define CYREG_CAN_CAN_TX2_DATA_LOW 0x402e004cu
N#define CYDEV_CAN_CAN_TX3_BASE 0x402e0050u
N#define CYDEV_CAN_CAN_TX3_SIZE 0x00000010u
N#define CYREG_CAN_CAN_TX3_CONTROL 0x402e0050u
N#define CYREG_CAN_CAN_TX3_ID 0x402e0054u
N#define CYREG_CAN_CAN_TX3_DATA_HIGH 0x402e0058u
N#define CYREG_CAN_CAN_TX3_DATA_LOW 0x402e005cu
N#define CYDEV_CAN_CAN_TX4_BASE 0x402e0060u
N#define CYDEV_CAN_CAN_TX4_SIZE 0x00000010u
N#define CYREG_CAN_CAN_TX4_CONTROL 0x402e0060u
N#define CYREG_CAN_CAN_TX4_ID 0x402e0064u
N#define CYREG_CAN_CAN_TX4_DATA_HIGH 0x402e0068u
N#define CYREG_CAN_CAN_TX4_DATA_LOW 0x402e006cu
N#define CYDEV_CAN_CAN_TX5_BASE 0x402e0070u
N#define CYDEV_CAN_CAN_TX5_SIZE 0x00000010u
N#define CYREG_CAN_CAN_TX5_CONTROL 0x402e0070u
N#define CYREG_CAN_CAN_TX5_ID 0x402e0074u
N#define CYREG_CAN_CAN_TX5_DATA_HIGH 0x402e0078u
N#define CYREG_CAN_CAN_TX5_DATA_LOW 0x402e007cu
N#define CYDEV_CAN_CAN_TX6_BASE 0x402e0080u
N#define CYDEV_CAN_CAN_TX6_SIZE 0x00000010u
N#define CYREG_CAN_CAN_TX6_CONTROL 0x402e0080u
N#define CYREG_CAN_CAN_TX6_ID 0x402e0084u
N#define CYREG_CAN_CAN_TX6_DATA_HIGH 0x402e0088u
N#define CYREG_CAN_CAN_TX6_DATA_LOW 0x402e008cu
N#define CYDEV_CAN_CAN_TX7_BASE 0x402e0090u
N#define CYDEV_CAN_CAN_TX7_SIZE 0x00000010u
N#define CYREG_CAN_CAN_TX7_CONTROL 0x402e0090u
N#define CYREG_CAN_CAN_TX7_ID 0x402e0094u
N#define CYREG_CAN_CAN_TX7_DATA_HIGH 0x402e0098u
N#define CYREG_CAN_CAN_TX7_DATA_LOW 0x402e009cu
N#define CYDEV_CAN_CAN_RX0_BASE 0x402e00a0u
N#define CYDEV_CAN_CAN_RX0_SIZE 0x00000020u
N#define CYREG_CAN_CAN_RX0_CONTROL 0x402e00a0u
N#define CYFLD_CAN_CAN_RX_MSG_AV_RTRSENT__OFFSET 0x00000000u
N#define CYFLD_CAN_CAN_RX_MSG_AV_RTRSENT__SIZE 0x00000001u
N#define CYFLD_CAN_CAN_RX_RTR_REPLY_PEND__OFFSET 0x00000001u
N#define CYFLD_CAN_CAN_RX_RTR_REPLY_PEND__SIZE 0x00000001u
N#define CYFLD_CAN_CAN_RX_RTR_ABORT__OFFSET 0x00000002u
N#define CYFLD_CAN_CAN_RX_RTR_ABORT__SIZE 0x00000001u
N#define CYFLD_CAN_CAN_RX_BUFFER_EN__OFFSET 0x00000003u
N#define CYFLD_CAN_CAN_RX_BUFFER_EN__SIZE 0x00000001u
N#define CYFLD_CAN_CAN_RX_RTR_REPLY__OFFSET 0x00000004u
N#define CYFLD_CAN_CAN_RX_RTR_REPLY__SIZE 0x00000001u
N#define CYFLD_CAN_CAN_RX_RX_INT_EBL__OFFSET 0x00000005u
N#define CYFLD_CAN_CAN_RX_RX_INT_EBL__SIZE 0x00000001u
N#define CYFLD_CAN_CAN_RX_LINK_FLAG__OFFSET 0x00000006u
N#define CYFLD_CAN_CAN_RX_LINK_FLAG__SIZE 0x00000001u
N#define CYFLD_CAN_CAN_RX_WPNL__OFFSET 0x00000007u
N#define CYFLD_CAN_CAN_RX_WPNL__SIZE 0x00000001u
N#define CYFLD_CAN_CAN_RX_DLC__OFFSET 0x00000010u
N#define CYFLD_CAN_CAN_RX_DLC__SIZE 0x00000004u
N#define CYFLD_CAN_CAN_RX_IDE_FMT__OFFSET 0x00000014u
N#define CYFLD_CAN_CAN_RX_IDE_FMT__SIZE 0x00000001u
N#define CYFLD_CAN_CAN_RX_RTR_MSG__OFFSET 0x00000015u
N#define CYFLD_CAN_CAN_RX_RTR_MSG__SIZE 0x00000001u
N#define CYFLD_CAN_CAN_RX_WPNH__OFFSET 0x00000017u
N#define CYFLD_CAN_CAN_RX_WPNH__SIZE 0x00000001u
N#define CYREG_CAN_CAN_RX0_ID 0x402e00a4u
N#define CYFLD_CAN_CAN_RX_ID__OFFSET 0x00000003u
N#define CYFLD_CAN_CAN_RX_ID__SIZE 0x0000001du
N#define CYREG_CAN_CAN_RX0_DATA_HIGH 0x402e00a8u
N#define CYFLD_CAN_CAN_RX_DATA__OFFSET 0x00000000u
N#define CYFLD_CAN_CAN_RX_DATA__SIZE 0x00000020u
N#define CYREG_CAN_CAN_RX0_DATA_LOW 0x402e00acu
N#define CYREG_CAN_CAN_RX0_AMR 0x402e00b0u
N#define CYFLD_CAN_CAN_RX_RTR__OFFSET 0x00000001u
N#define CYFLD_CAN_CAN_RX_RTR__SIZE 0x00000001u
N#define CYFLD_CAN_CAN_RX_IDE__OFFSET 0x00000002u
N#define CYFLD_CAN_CAN_RX_IDE__SIZE 0x00000001u
N#define CYREG_CAN_CAN_RX0_ACR 0x402e00b4u
N#define CYREG_CAN_CAN_RX0_AMR_DATA 0x402e00b8u
N#define CYFLD_CAN_CAN_RX_DATAL__OFFSET 0x00000000u
N#define CYFLD_CAN_CAN_RX_DATAL__SIZE 0x00000010u
N#define CYREG_CAN_CAN_RX0_ACR_DATA 0x402e00bcu
N#define CYDEV_CAN_CAN_RX1_BASE 0x402e00c0u
N#define CYDEV_CAN_CAN_RX1_SIZE 0x00000020u
N#define CYREG_CAN_CAN_RX1_CONTROL 0x402e00c0u
N#define CYREG_CAN_CAN_RX1_ID 0x402e00c4u
N#define CYREG_CAN_CAN_RX1_DATA_HIGH 0x402e00c8u
N#define CYREG_CAN_CAN_RX1_DATA_LOW 0x402e00ccu
N#define CYREG_CAN_CAN_RX1_AMR 0x402e00d0u
N#define CYREG_CAN_CAN_RX1_ACR 0x402e00d4u
N#define CYREG_CAN_CAN_RX1_AMR_DATA 0x402e00d8u
N#define CYREG_CAN_CAN_RX1_ACR_DATA 0x402e00dcu
N#define CYDEV_CAN_CAN_RX2_BASE 0x402e00e0u
N#define CYDEV_CAN_CAN_RX2_SIZE 0x00000020u
N#define CYREG_CAN_CAN_RX2_CONTROL 0x402e00e0u
N#define CYREG_CAN_CAN_RX2_ID 0x402e00e4u
N#define CYREG_CAN_CAN_RX2_DATA_HIGH 0x402e00e8u
N#define CYREG_CAN_CAN_RX2_DATA_LOW 0x402e00ecu
N#define CYREG_CAN_CAN_RX2_AMR 0x402e00f0u
N#define CYREG_CAN_CAN_RX2_ACR 0x402e00f4u
N#define CYREG_CAN_CAN_RX2_AMR_DATA 0x402e00f8u
N#define CYREG_CAN_CAN_RX2_ACR_DATA 0x402e00fcu
N#define CYDEV_CAN_CAN_RX3_BASE 0x402e0100u
N#define CYDEV_CAN_CAN_RX3_SIZE 0x00000020u
N#define CYREG_CAN_CAN_RX3_CONTROL 0x402e0100u
N#define CYREG_CAN_CAN_RX3_ID 0x402e0104u
N#define CYREG_CAN_CAN_RX3_DATA_HIGH 0x402e0108u
N#define CYREG_CAN_CAN_RX3_DATA_LOW 0x402e010cu
N#define CYREG_CAN_CAN_RX3_AMR 0x402e0110u
N#define CYREG_CAN_CAN_RX3_ACR 0x402e0114u
N#define CYREG_CAN_CAN_RX3_AMR_DATA 0x402e0118u
N#define CYREG_CAN_CAN_RX3_ACR_DATA 0x402e011cu
N#define CYDEV_CAN_CAN_RX4_BASE 0x402e0120u
N#define CYDEV_CAN_CAN_RX4_SIZE 0x00000020u
N#define CYREG_CAN_CAN_RX4_CONTROL 0x402e0120u
N#define CYREG_CAN_CAN_RX4_ID 0x402e0124u
N#define CYREG_CAN_CAN_RX4_DATA_HIGH 0x402e0128u
N#define CYREG_CAN_CAN_RX4_DATA_LOW 0x402e012cu
N#define CYREG_CAN_CAN_RX4_AMR 0x402e0130u
N#define CYREG_CAN_CAN_RX4_ACR 0x402e0134u
N#define CYREG_CAN_CAN_RX4_AMR_DATA 0x402e0138u
N#define CYREG_CAN_CAN_RX4_ACR_DATA 0x402e013cu
N#define CYDEV_CAN_CAN_RX5_BASE 0x402e0140u
N#define CYDEV_CAN_CAN_RX5_SIZE 0x00000020u
N#define CYREG_CAN_CAN_RX5_CONTROL 0x402e0140u
N#define CYREG_CAN_CAN_RX5_ID 0x402e0144u
N#define CYREG_CAN_CAN_RX5_DATA_HIGH 0x402e0148u
N#define CYREG_CAN_CAN_RX5_DATA_LOW 0x402e014cu
N#define CYREG_CAN_CAN_RX5_AMR 0x402e0150u
N#define CYREG_CAN_CAN_RX5_ACR 0x402e0154u
N#define CYREG_CAN_CAN_RX5_AMR_DATA 0x402e0158u
N#define CYREG_CAN_CAN_RX5_ACR_DATA 0x402e015cu
N#define CYDEV_CAN_CAN_RX6_BASE 0x402e0160u
N#define CYDEV_CAN_CAN_RX6_SIZE 0x00000020u
N#define CYREG_CAN_CAN_RX6_CONTROL 0x402e0160u
N#define CYREG_CAN_CAN_RX6_ID 0x402e0164u
N#define CYREG_CAN_CAN_RX6_DATA_HIGH 0x402e0168u
N#define CYREG_CAN_CAN_RX6_DATA_LOW 0x402e016cu
N#define CYREG_CAN_CAN_RX6_AMR 0x402e0170u
N#define CYREG_CAN_CAN_RX6_ACR 0x402e0174u
N#define CYREG_CAN_CAN_RX6_AMR_DATA 0x402e0178u
N#define CYREG_CAN_CAN_RX6_ACR_DATA 0x402e017cu
N#define CYDEV_CAN_CAN_RX7_BASE 0x402e0180u
N#define CYDEV_CAN_CAN_RX7_SIZE 0x00000020u
N#define CYREG_CAN_CAN_RX7_CONTROL 0x402e0180u
N#define CYREG_CAN_CAN_RX7_ID 0x402e0184u
N#define CYREG_CAN_CAN_RX7_DATA_HIGH 0x402e0188u
N#define CYREG_CAN_CAN_RX7_DATA_LOW 0x402e018cu
N#define CYREG_CAN_CAN_RX7_AMR 0x402e0190u
N#define CYREG_CAN_CAN_RX7_ACR 0x402e0194u
N#define CYREG_CAN_CAN_RX7_AMR_DATA 0x402e0198u
N#define CYREG_CAN_CAN_RX7_ACR_DATA 0x402e019cu
N#define CYDEV_CAN_CAN_RX8_BASE 0x402e01a0u
N#define CYDEV_CAN_CAN_RX8_SIZE 0x00000020u
N#define CYREG_CAN_CAN_RX8_CONTROL 0x402e01a0u
N#define CYREG_CAN_CAN_RX8_ID 0x402e01a4u
N#define CYREG_CAN_CAN_RX8_DATA_HIGH 0x402e01a8u
N#define CYREG_CAN_CAN_RX8_DATA_LOW 0x402e01acu
N#define CYREG_CAN_CAN_RX8_AMR 0x402e01b0u
N#define CYREG_CAN_CAN_RX8_ACR 0x402e01b4u
N#define CYREG_CAN_CAN_RX8_AMR_DATA 0x402e01b8u
N#define CYREG_CAN_CAN_RX8_ACR_DATA 0x402e01bcu
N#define CYDEV_CAN_CAN_RX9_BASE 0x402e01c0u
N#define CYDEV_CAN_CAN_RX9_SIZE 0x00000020u
N#define CYREG_CAN_CAN_RX9_CONTROL 0x402e01c0u
N#define CYREG_CAN_CAN_RX9_ID 0x402e01c4u
N#define CYREG_CAN_CAN_RX9_DATA_HIGH 0x402e01c8u
N#define CYREG_CAN_CAN_RX9_DATA_LOW 0x402e01ccu
N#define CYREG_CAN_CAN_RX9_AMR 0x402e01d0u
N#define CYREG_CAN_CAN_RX9_ACR 0x402e01d4u
N#define CYREG_CAN_CAN_RX9_AMR_DATA 0x402e01d8u
N#define CYREG_CAN_CAN_RX9_ACR_DATA 0x402e01dcu
N#define CYDEV_CAN_CAN_RX10_BASE 0x402e01e0u
N#define CYDEV_CAN_CAN_RX10_SIZE 0x00000020u
N#define CYREG_CAN_CAN_RX10_CONTROL 0x402e01e0u
N#define CYREG_CAN_CAN_RX10_ID 0x402e01e4u
N#define CYREG_CAN_CAN_RX10_DATA_HIGH 0x402e01e8u
N#define CYREG_CAN_CAN_RX10_DATA_LOW 0x402e01ecu
N#define CYREG_CAN_CAN_RX10_AMR 0x402e01f0u
N#define CYREG_CAN_CAN_RX10_ACR 0x402e01f4u
N#define CYREG_CAN_CAN_RX10_AMR_DATA 0x402e01f8u
N#define CYREG_CAN_CAN_RX10_ACR_DATA 0x402e01fcu
N#define CYDEV_CAN_CAN_RX11_BASE 0x402e0200u
N#define CYDEV_CAN_CAN_RX11_SIZE 0x00000020u
N#define CYREG_CAN_CAN_RX11_CONTROL 0x402e0200u
N#define CYREG_CAN_CAN_RX11_ID 0x402e0204u
N#define CYREG_CAN_CAN_RX11_DATA_HIGH 0x402e0208u
N#define CYREG_CAN_CAN_RX11_DATA_LOW 0x402e020cu
N#define CYREG_CAN_CAN_RX11_AMR 0x402e0210u
N#define CYREG_CAN_CAN_RX11_ACR 0x402e0214u
N#define CYREG_CAN_CAN_RX11_AMR_DATA 0x402e0218u
N#define CYREG_CAN_CAN_RX11_ACR_DATA 0x402e021cu
N#define CYDEV_CAN_CAN_RX12_BASE 0x402e0220u
N#define CYDEV_CAN_CAN_RX12_SIZE 0x00000020u
N#define CYREG_CAN_CAN_RX12_CONTROL 0x402e0220u
N#define CYREG_CAN_CAN_RX12_ID 0x402e0224u
N#define CYREG_CAN_CAN_RX12_DATA_HIGH 0x402e0228u
N#define CYREG_CAN_CAN_RX12_DATA_LOW 0x402e022cu
N#define CYREG_CAN_CAN_RX12_AMR 0x402e0230u
N#define CYREG_CAN_CAN_RX12_ACR 0x402e0234u
N#define CYREG_CAN_CAN_RX12_AMR_DATA 0x402e0238u
N#define CYREG_CAN_CAN_RX12_ACR_DATA 0x402e023cu
N#define CYDEV_CAN_CAN_RX13_BASE 0x402e0240u
N#define CYDEV_CAN_CAN_RX13_SIZE 0x00000020u
N#define CYREG_CAN_CAN_RX13_CONTROL 0x402e0240u
N#define CYREG_CAN_CAN_RX13_ID 0x402e0244u
N#define CYREG_CAN_CAN_RX13_DATA_HIGH 0x402e0248u
N#define CYREG_CAN_CAN_RX13_DATA_LOW 0x402e024cu
N#define CYREG_CAN_CAN_RX13_AMR 0x402e0250u
N#define CYREG_CAN_CAN_RX13_ACR 0x402e0254u
N#define CYREG_CAN_CAN_RX13_AMR_DATA 0x402e0258u
N#define CYREG_CAN_CAN_RX13_ACR_DATA 0x402e025cu
N#define CYDEV_CAN_CAN_RX14_BASE 0x402e0260u
N#define CYDEV_CAN_CAN_RX14_SIZE 0x00000020u
N#define CYREG_CAN_CAN_RX14_CONTROL 0x402e0260u
N#define CYREG_CAN_CAN_RX14_ID 0x402e0264u
N#define CYREG_CAN_CAN_RX14_DATA_HIGH 0x402e0268u
N#define CYREG_CAN_CAN_RX14_DATA_LOW 0x402e026cu
N#define CYREG_CAN_CAN_RX14_AMR 0x402e0270u
N#define CYREG_CAN_CAN_RX14_ACR 0x402e0274u
N#define CYREG_CAN_CAN_RX14_AMR_DATA 0x402e0278u
N#define CYREG_CAN_CAN_RX14_ACR_DATA 0x402e027cu
N#define CYDEV_CAN_CAN_RX15_BASE 0x402e0280u
N#define CYDEV_CAN_CAN_RX15_SIZE 0x00000020u
N#define CYREG_CAN_CAN_RX15_CONTROL 0x402e0280u
N#define CYREG_CAN_CAN_RX15_ID 0x402e0284u
N#define CYREG_CAN_CAN_RX15_DATA_HIGH 0x402e0288u
N#define CYREG_CAN_CAN_RX15_DATA_LOW 0x402e028cu
N#define CYREG_CAN_CAN_RX15_AMR 0x402e0290u
N#define CYREG_CAN_CAN_RX15_ACR 0x402e0294u
N#define CYREG_CAN_CAN_RX15_AMR_DATA 0x402e0298u
N#define CYREG_CAN_CAN_RX15_ACR_DATA 0x402e029cu
N#define CYREG_CAN_CNTL 0x402e0400u
N#define CYFLD_CAN_TT_ENABLE__OFFSET 0x00000000u
N#define CYFLD_CAN_TT_ENABLE__SIZE 0x00000001u
N#define CYFLD_CAN_IP_ENABLE__OFFSET 0x0000001fu
N#define CYFLD_CAN_IP_ENABLE__SIZE 0x00000001u
N#define CYREG_CAN_TTCAN_COUNTER 0x402e0404u
N#define CYFLD_CAN_LOCAL_TIME__OFFSET 0x00000010u
N#define CYFLD_CAN_LOCAL_TIME__SIZE 0x00000010u
N#define CYREG_CAN_TTCAN_COMPARE 0x402e0408u
N#define CYFLD_CAN_TIME_MARK__OFFSET 0x00000010u
N#define CYFLD_CAN_TIME_MARK__SIZE 0x00000010u
N#define CYREG_CAN_TTCAN_CAPTURE 0x402e040cu
N#define CYFLD_CAN_SYNC_MARK__OFFSET 0x00000010u
N#define CYFLD_CAN_SYNC_MARK__SIZE 0x00000010u
N#define CYREG_CAN_TTCAN_TIMING 0x402e0410u
N#define CYREG_CAN_INTR_CAN 0x402e0414u
N#define CYFLD_CAN_INT_STATUS__OFFSET 0x00000000u
N#define CYFLD_CAN_INT_STATUS__SIZE 0x00000001u
N#define CYFLD_CAN_TT_COMPARE__OFFSET 0x00000001u
N#define CYFLD_CAN_TT_COMPARE__SIZE 0x00000001u
N#define CYFLD_CAN_TT_CAPTURE__OFFSET 0x00000002u
N#define CYFLD_CAN_TT_CAPTURE__SIZE 0x00000001u
N#define CYREG_CAN_INTR_CAN_SET 0x402e0418u
N#define CYREG_CAN_INTR_CAN_MASK 0x402e041cu
N#define CYREG_CAN_INTR_CAN_MASKED 0x402e0420u
N#define CYDEV_EXCO_BASE 0x402f0000u
N#define CYDEV_EXCO_SIZE 0x00010000u
N#define CYREG_EXCO_CLK_SELECT 0x402f0000u
N#define CYFLD_EXCO_CLK_SELECT__OFFSET 0x00000000u
N#define CYFLD_EXCO_CLK_SELECT__SIZE 0x00000001u
N#define CYFLD_EXCO_REF_SEL__OFFSET 0x00000001u
N#define CYFLD_EXCO_REF_SEL__SIZE 0x00000001u
N#define CYREG_EXCO_ECO_CONFIG 0x402f0008u
N#define CYFLD_EXCO_CLK_EN__OFFSET 0x00000000u
N#define CYFLD_EXCO_CLK_EN__SIZE 0x00000001u
N#define CYFLD_EXCO_AGC_EN__OFFSET 0x00000001u
N#define CYFLD_EXCO_AGC_EN__SIZE 0x00000001u
N#define CYFLD_EXCO_ENABLE__OFFSET 0x0000001fu
N#define CYFLD_EXCO_ENABLE__SIZE 0x00000001u
N#define CYREG_EXCO_ECO_STATUS 0x402f000cu
N#define CYFLD_EXCO_WATCHDOG_ERROR__OFFSET 0x00000000u
N#define CYFLD_EXCO_WATCHDOG_ERROR__SIZE 0x00000001u
N#define CYREG_EXCO_PLL_CONFIG 0x402f0014u
N#define CYFLD_EXCO_FEEDBACK_DIV__OFFSET 0x00000000u
N#define CYFLD_EXCO_FEEDBACK_DIV__SIZE 0x00000008u
N#define CYFLD_EXCO_REFERENCE_DIV__OFFSET 0x00000008u
N#define CYFLD_EXCO_REFERENCE_DIV__SIZE 0x00000006u
N#define CYFLD_EXCO_OUTPUT_DIV__OFFSET 0x0000000eu
N#define CYFLD_EXCO_OUTPUT_DIV__SIZE 0x00000002u
N#define CYVAL_EXCO_OUTPUT_DIV_PASS 0x00000000u
N#define CYVAL_EXCO_OUTPUT_DIV_DIV2 0x00000001u
N#define CYVAL_EXCO_OUTPUT_DIV_DIV4 0x00000002u
N#define CYVAL_EXCO_OUTPUT_DIV_DIV8 0x00000003u
N#define CYFLD_EXCO_ICP_SEL__OFFSET 0x00000010u
N#define CYFLD_EXCO_ICP_SEL__SIZE 0x00000003u
N#define CYFLD_EXCO_BYPASS_SEL__OFFSET 0x00000014u
N#define CYFLD_EXCO_BYPASS_SEL__SIZE 0x00000002u
N#define CYVAL_EXCO_BYPASS_SEL_AUTO 0x00000000u
N#define CYVAL_EXCO_BYPASS_SEL_AUTO1 0x00000001u
N#define CYVAL_EXCO_BYPASS_SEL_PLL_REF 0x00000002u
N#define CYVAL_EXCO_BYPASS_SEL_PLL_OUT 0x00000003u
N#define CYFLD_EXCO_ISOLATE_N__OFFSET 0x0000001eu
N#define CYFLD_EXCO_ISOLATE_N__SIZE 0x00000001u
N#define CYREG_EXCO_PLL_STATUS 0x402f0018u
N#define CYFLD_EXCO_LOCKED__OFFSET 0x00000000u
N#define CYFLD_EXCO_LOCKED__SIZE 0x00000001u
N#define CYREG_EXCO_PLL_TEST 0x402f001cu
N#define CYFLD_EXCO_TEST_MODE__OFFSET 0x00000000u
N#define CYFLD_EXCO_TEST_MODE__SIZE 0x00000003u
N#define CYVAL_EXCO_TEST_MODE_NORMAL 0x00000000u
N#define CYVAL_EXCO_TEST_MODE_TEST_VC_LKG 0x00000001u
N#define CYVAL_EXCO_TEST_MODE_TEST_CP_DN 0x00000002u
N#define CYVAL_EXCO_TEST_MODE_TEST_CP_UP 0x00000003u
N#define CYVAL_EXCO_TEST_MODE_USER_EXT_FL 0x00000004u
N#define CYVAL_EXCO_TEST_MODE_TEST_CTR_PQ 0x00000005u
N#define CYVAL_EXCO_TEST_MODE_TEST_LD_DLY 0x00000006u
N#define CYVAL_EXCO_TEST_MODE_TEST_CTR_ALT 0x00000007u
N#define CYFLD_EXCO_FAST_LOCK_EN__OFFSET 0x00000003u
N#define CYFLD_EXCO_FAST_LOCK_EN__SIZE 0x00000001u
N#define CYFLD_EXCO_UNLOCK_OCCURRED__OFFSET 0x00000004u
N#define CYFLD_EXCO_UNLOCK_OCCURRED__SIZE 0x00000001u
N#define CYREG_EXCO_EXCO_PGM_CLK 0x402f0020u
N#define CYFLD_EXCO_CLK_ECO__OFFSET 0x00000001u
N#define CYFLD_EXCO_CLK_ECO__SIZE 0x00000001u
N#define CYFLD_EXCO_CLK_PLL0_IN__OFFSET 0x00000002u
N#define CYFLD_EXCO_CLK_PLL0_IN__SIZE 0x00000001u
N#define CYFLD_EXCO_CLK_PLL0_OUT__OFFSET 0x00000003u
N#define CYFLD_EXCO_CLK_PLL0_OUT__SIZE 0x00000001u
N#define CYFLD_EXCO_EN_CLK_PLL0__OFFSET 0x00000004u
N#define CYFLD_EXCO_EN_CLK_PLL0__SIZE 0x00000001u
N#define CYREG_EXCO_ECO_TRIM0 0x402fff00u
N#define CYFLD_EXCO_WDTRIM__OFFSET 0x00000000u
N#define CYFLD_EXCO_WDTRIM__SIZE 0x00000002u
N#define CYFLD_EXCO_ATRIM__OFFSET 0x00000002u
N#define CYFLD_EXCO_ATRIM__SIZE 0x00000003u
N#define CYREG_EXCO_ECO_TRIM1 0x402fff04u
N#define CYFLD_EXCO_FTRIM__OFFSET 0x00000000u
N#define CYFLD_EXCO_FTRIM__SIZE 0x00000002u
N#define CYFLD_EXCO_RTRIM__OFFSET 0x00000002u
N#define CYFLD_EXCO_RTRIM__SIZE 0x00000002u
N#define CYFLD_EXCO_GTRIM__OFFSET 0x00000004u
N#define CYFLD_EXCO_GTRIM__SIZE 0x00000002u
N#define CYREG_EXCO_ECO_TRIM2 0x402fff08u
N#define CYFLD_EXCO_ITRIM__OFFSET 0x00000000u
N#define CYFLD_EXCO_ITRIM__SIZE 0x00000006u
N#define CYREG_EXCO_PLL_TRIM 0x402fff0cu
N#define CYFLD_EXCO_VCO_GAIN__OFFSET 0x00000000u
N#define CYFLD_EXCO_VCO_GAIN__SIZE 0x00000002u
N#define CYFLD_EXCO_LOCK_WINDOW__OFFSET 0x00000002u
N#define CYFLD_EXCO_LOCK_WINDOW__SIZE 0x00000002u
N#define CYVAL_EXCO_LOCK_WINDOW_DELAY_25NS 0x00000000u
N#define CYVAL_EXCO_LOCK_WINDOW_DELAY_50NS 0x00000001u
N#define CYVAL_EXCO_LOCK_WINDOW_DELAY_75NS 0x00000002u
N#define CYVAL_EXCO_LOCK_WINDOW_DELAY_100NS 0x00000003u
N#define CYFLD_EXCO_LOCK_DELAY__OFFSET 0x00000004u
N#define CYFLD_EXCO_LOCK_DELAY__SIZE 0x00000002u
N#define CYVAL_EXCO_LOCK_DELAY_PFD_CLK_16 0x00000000u
N#define CYVAL_EXCO_LOCK_DELAY_PFD_CLK_32 0x00000001u
N#define CYVAL_EXCO_LOCK_DELAY_PFD_CLK_48 0x00000002u
N#define CYVAL_EXCO_LOCK_DELAY_PFD_CLK_64 0x00000003u
N#define CYDEV_CTBM0_BASE 0x40300000u
N#define CYDEV_CTBM0_SIZE 0x00010000u
N#define CYREG_CTBM0_CTB_CTRL 0x40300000u
N#define CYFLD_CTBM_DEEPSLEEP_ON__OFFSET 0x0000001eu
N#define CYFLD_CTBM_DEEPSLEEP_ON__SIZE 0x00000001u
N#define CYFLD_CTBM_ENABLED__OFFSET 0x0000001fu
N#define CYFLD_CTBM_ENABLED__SIZE 0x00000001u
N#define CYREG_CTBM0_OA_RES0_CTRL 0x40300004u
N#define CYFLD_CTBM_OA0_PWR_MODE__OFFSET 0x00000000u
N#define CYFLD_CTBM_OA0_PWR_MODE__SIZE 0x00000002u
N#define CYVAL_CTBM_OA0_PWR_MODE_OFF 0x00000000u
N#define CYVAL_CTBM_OA0_PWR_MODE_LOW 0x00000001u
N#define CYVAL_CTBM_OA0_PWR_MODE_MEDIUM 0x00000002u
N#define CYVAL_CTBM_OA0_PWR_MODE_HIGH 0x00000003u
N#define CYFLD_CTBM_OA0_DRIVE_STR_SEL__OFFSET 0x00000002u
N#define CYFLD_CTBM_OA0_DRIVE_STR_SEL__SIZE 0x00000001u
N#define CYFLD_CTBM_OA0_COMP_EN__OFFSET 0x00000004u
N#define CYFLD_CTBM_OA0_COMP_EN__SIZE 0x00000001u
N#define CYFLD_CTBM_OA0_HYST_EN__OFFSET 0x00000005u
N#define CYFLD_CTBM_OA0_HYST_EN__SIZE 0x00000001u
N#define CYFLD_CTBM_OA0_BYPASS_DSI_SYNC__OFFSET 0x00000006u
N#define CYFLD_CTBM_OA0_BYPASS_DSI_SYNC__SIZE 0x00000001u
N#define CYFLD_CTBM_OA0_DSI_LEVEL__OFFSET 0x00000007u
N#define CYFLD_CTBM_OA0_DSI_LEVEL__SIZE 0x00000001u
N#define CYFLD_CTBM_OA0_COMPINT__OFFSET 0x00000008u
N#define CYFLD_CTBM_OA0_COMPINT__SIZE 0x00000002u
N#define CYVAL_CTBM_OA0_COMPINT_DISABLE 0x00000000u
N#define CYVAL_CTBM_OA0_COMPINT_RISING 0x00000001u
N#define CYVAL_CTBM_OA0_COMPINT_FALLING 0x00000002u
N#define CYVAL_CTBM_OA0_COMPINT_BOTH 0x00000003u
N#define CYFLD_CTBM_OA0_PUMP_EN__OFFSET 0x0000000bu
N#define CYFLD_CTBM_OA0_PUMP_EN__SIZE 0x00000001u
N#define CYREG_CTBM0_OA_RES1_CTRL 0x40300008u
N#define CYFLD_CTBM_OA1_PWR_MODE__OFFSET 0x00000000u
N#define CYFLD_CTBM_OA1_PWR_MODE__SIZE 0x00000002u
N#define CYFLD_CTBM_OA1_DRIVE_STR_SEL__OFFSET 0x00000002u
N#define CYFLD_CTBM_OA1_DRIVE_STR_SEL__SIZE 0x00000001u
N#define CYFLD_CTBM_OA1_COMP_EN__OFFSET 0x00000004u
N#define CYFLD_CTBM_OA1_COMP_EN__SIZE 0x00000001u
N#define CYFLD_CTBM_OA1_HYST_EN__OFFSET 0x00000005u
N#define CYFLD_CTBM_OA1_HYST_EN__SIZE 0x00000001u
N#define CYFLD_CTBM_OA1_BYPASS_DSI_SYNC__OFFSET 0x00000006u
N#define CYFLD_CTBM_OA1_BYPASS_DSI_SYNC__SIZE 0x00000001u
N#define CYFLD_CTBM_OA1_DSI_LEVEL__OFFSET 0x00000007u
N#define CYFLD_CTBM_OA1_DSI_LEVEL__SIZE 0x00000001u
N#define CYFLD_CTBM_OA1_COMPINT__OFFSET 0x00000008u
N#define CYFLD_CTBM_OA1_COMPINT__SIZE 0x00000002u
N#define CYVAL_CTBM_OA1_COMPINT_DISABLE 0x00000000u
N#define CYVAL_CTBM_OA1_COMPINT_RISING 0x00000001u
N#define CYVAL_CTBM_OA1_COMPINT_FALLING 0x00000002u
N#define CYVAL_CTBM_OA1_COMPINT_BOTH 0x00000003u
N#define CYFLD_CTBM_OA1_PUMP_EN__OFFSET 0x0000000bu
N#define CYFLD_CTBM_OA1_PUMP_EN__SIZE 0x00000001u
N#define CYREG_CTBM0_COMP_STAT 0x4030000cu
N#define CYFLD_CTBM_OA0_COMP__OFFSET 0x00000000u
N#define CYFLD_CTBM_OA0_COMP__SIZE 0x00000001u
N#define CYFLD_CTBM_OA1_COMP__OFFSET 0x00000010u
N#define CYFLD_CTBM_OA1_COMP__SIZE 0x00000001u
N#define CYREG_CTBM0_INTR 0x40300020u
N#define CYFLD_CTBM_COMP0__OFFSET 0x00000000u
N#define CYFLD_CTBM_COMP0__SIZE 0x00000001u
N#define CYFLD_CTBM_COMP1__OFFSET 0x00000001u
N#define CYFLD_CTBM_COMP1__SIZE 0x00000001u
N#define CYREG_CTBM0_INTR_SET 0x40300024u
N#define CYFLD_CTBM_COMP0_SET__OFFSET 0x00000000u
N#define CYFLD_CTBM_COMP0_SET__SIZE 0x00000001u
N#define CYFLD_CTBM_COMP1_SET__OFFSET 0x00000001u
N#define CYFLD_CTBM_COMP1_SET__SIZE 0x00000001u
N#define CYREG_CTBM0_INTR_MASK 0x40300028u
N#define CYFLD_CTBM_COMP0_MASK__OFFSET 0x00000000u
N#define CYFLD_CTBM_COMP0_MASK__SIZE 0x00000001u
N#define CYFLD_CTBM_COMP1_MASK__OFFSET 0x00000001u
N#define CYFLD_CTBM_COMP1_MASK__SIZE 0x00000001u
N#define CYREG_CTBM0_INTR_MASKED 0x4030002cu
N#define CYFLD_CTBM_COMP0_MASKED__OFFSET 0x00000000u
N#define CYFLD_CTBM_COMP0_MASKED__SIZE 0x00000001u
N#define CYFLD_CTBM_COMP1_MASKED__OFFSET 0x00000001u
N#define CYFLD_CTBM_COMP1_MASKED__SIZE 0x00000001u
N#define CYREG_CTBM0_DFT_CTRL 0x40300030u
N#define CYFLD_CTBM_DFT_MODE__OFFSET 0x00000000u
N#define CYFLD_CTBM_DFT_MODE__SIZE 0x00000003u
N#define CYFLD_CTBM_DFT_EN__OFFSET 0x0000001fu
N#define CYFLD_CTBM_DFT_EN__SIZE 0x00000001u
N#define CYREG_CTBM0_OA0_SW 0x40300080u
N#define CYFLD_CTBM_OA0P_A00__OFFSET 0x00000000u
N#define CYFLD_CTBM_OA0P_A00__SIZE 0x00000001u
N#define CYFLD_CTBM_OA0P_A20__OFFSET 0x00000002u
N#define CYFLD_CTBM_OA0P_A20__SIZE 0x00000001u
N#define CYFLD_CTBM_OA0P_A30__OFFSET 0x00000003u
N#define CYFLD_CTBM_OA0P_A30__SIZE 0x00000001u
N#define CYFLD_CTBM_OA0M_A11__OFFSET 0x00000008u
N#define CYFLD_CTBM_OA0M_A11__SIZE 0x00000001u
N#define CYFLD_CTBM_OA0M_A81__OFFSET 0x0000000eu
N#define CYFLD_CTBM_OA0M_A81__SIZE 0x00000001u
N#define CYFLD_CTBM_OA0O_D51__OFFSET 0x00000012u
N#define CYFLD_CTBM_OA0O_D51__SIZE 0x00000001u
N#define CYFLD_CTBM_OA0O_D81__OFFSET 0x00000015u
N#define CYFLD_CTBM_OA0O_D81__SIZE 0x00000001u
N#define CYREG_CTBM0_OA0_SW_CLEAR 0x40300084u
N#define CYREG_CTBM0_OA1_SW 0x40300088u
N#define CYFLD_CTBM_OA1P_A03__OFFSET 0x00000000u
N#define CYFLD_CTBM_OA1P_A03__SIZE 0x00000001u
N#define CYFLD_CTBM_OA1P_A13__OFFSET 0x00000001u
N#define CYFLD_CTBM_OA1P_A13__SIZE 0x00000001u
N#define CYFLD_CTBM_OA1P_A43__OFFSET 0x00000004u
N#define CYFLD_CTBM_OA1P_A43__SIZE 0x00000001u
N#define CYFLD_CTBM_OA1M_A22__OFFSET 0x00000008u
N#define CYFLD_CTBM_OA1M_A22__SIZE 0x00000001u
N#define CYFLD_CTBM_OA1M_A82__OFFSET 0x0000000eu
N#define CYFLD_CTBM_OA1M_A82__SIZE 0x00000001u
N#define CYFLD_CTBM_OA1O_D52__OFFSET 0x00000012u
N#define CYFLD_CTBM_OA1O_D52__SIZE 0x00000001u
N#define CYFLD_CTBM_OA1O_D62__OFFSET 0x00000013u
N#define CYFLD_CTBM_OA1O_D62__SIZE 0x00000001u
N#define CYFLD_CTBM_OA1O_D82__OFFSET 0x00000015u
N#define CYFLD_CTBM_OA1O_D82__SIZE 0x00000001u
N#define CYREG_CTBM0_OA1_SW_CLEAR 0x4030008cu
N#define CYREG_CTBM0_CTB_SW_HW_CTRL 0x403000c0u
N#define CYFLD_CTBM_P2_HW_CTRL__OFFSET 0x00000002u
N#define CYFLD_CTBM_P2_HW_CTRL__SIZE 0x00000001u
N#define CYFLD_CTBM_P3_HW_CTRL__OFFSET 0x00000003u
N#define CYFLD_CTBM_P3_HW_CTRL__SIZE 0x00000001u
N#define CYREG_CTBM0_CTB_SW_STATUS 0x403000c4u
N#define CYFLD_CTBM_OA0O_D51_STAT__OFFSET 0x0000001cu
N#define CYFLD_CTBM_OA0O_D51_STAT__SIZE 0x00000001u
N#define CYFLD_CTBM_OA1O_D52_STAT__OFFSET 0x0000001du
N#define CYFLD_CTBM_OA1O_D52_STAT__SIZE 0x00000001u
N#define CYFLD_CTBM_OA1O_D62_STAT__OFFSET 0x0000001eu
N#define CYFLD_CTBM_OA1O_D62_STAT__SIZE 0x00000001u
N#define CYREG_CTBM0_OA0_OFFSET_TRIM 0x40300f00u
N#define CYFLD_CTBM_OA0_OFFSET_TRIM__OFFSET 0x00000000u
N#define CYFLD_CTBM_OA0_OFFSET_TRIM__SIZE 0x00000006u
N#define CYREG_CTBM0_OA0_SLOPE_OFFSET_TRIM 0x40300f04u
N#define CYFLD_CTBM_OA0_SLOPE_OFFSET_TRIM__OFFSET 0x00000000u
N#define CYFLD_CTBM_OA0_SLOPE_OFFSET_TRIM__SIZE 0x00000006u
N#define CYREG_CTBM0_OA0_COMP_TRIM 0x40300f08u
N#define CYFLD_CTBM_OA0_COMP_TRIM__OFFSET 0x00000000u
N#define CYFLD_CTBM_OA0_COMP_TRIM__SIZE 0x00000002u
N#define CYREG_CTBM0_OA1_OFFSET_TRIM 0x40300f0cu
N#define CYFLD_CTBM_OA1_OFFSET_TRIM__OFFSET 0x00000000u
N#define CYFLD_CTBM_OA1_OFFSET_TRIM__SIZE 0x00000006u
N#define CYREG_CTBM0_OA1_SLOPE_OFFSET_TRIM 0x40300f10u
N#define CYFLD_CTBM_OA1_SLOPE_OFFSET_TRIM__OFFSET 0x00000000u
N#define CYFLD_CTBM_OA1_SLOPE_OFFSET_TRIM__SIZE 0x00000006u
N#define CYREG_CTBM0_OA1_COMP_TRIM 0x40300f14u
N#define CYFLD_CTBM_OA1_COMP_TRIM__OFFSET 0x00000000u
N#define CYFLD_CTBM_OA1_COMP_TRIM__SIZE 0x00000002u
N#define CYDEV_SAR_BASE 0x403a0000u
N#define CYDEV_SAR_SIZE 0x00010000u
N#define CYREG_SAR_CTRL 0x403a0000u
N#define CYFLD_SAR_VREF_SEL__OFFSET 0x00000004u
N#define CYFLD_SAR_VREF_SEL__SIZE 0x00000003u
N#define CYVAL_SAR_VREF_SEL_VREF0 0x00000000u
N#define CYVAL_SAR_VREF_SEL_VREF1 0x00000001u
N#define CYVAL_SAR_VREF_SEL_VREF2 0x00000002u
N#define CYVAL_SAR_VREF_SEL_VREF_AROUTE 0x00000003u
N#define CYVAL_SAR_VREF_SEL_VBGR 0x00000004u
N#define CYVAL_SAR_VREF_SEL_VREF_EXT 0x00000005u
N#define CYVAL_SAR_VREF_SEL_VDDA_DIV_2 0x00000006u
N#define CYVAL_SAR_VREF_SEL_VDDA 0x00000007u
N#define CYFLD_SAR_VREF_BYP_CAP_EN__OFFSET 0x00000007u
N#define CYFLD_SAR_VREF_BYP_CAP_EN__SIZE 0x00000001u
N#define CYFLD_SAR_NEG_SEL__OFFSET 0x00000009u
N#define CYFLD_SAR_NEG_SEL__SIZE 0x00000003u
N#define CYVAL_SAR_NEG_SEL_VSSA_KELVIN 0x00000000u
N#define CYVAL_SAR_NEG_SEL_ART_VSSA 0x00000001u
N#define CYVAL_SAR_NEG_SEL_P1 0x00000002u
N#define CYVAL_SAR_NEG_SEL_P3 0x00000003u
N#define CYVAL_SAR_NEG_SEL_P5 0x00000004u
N#define CYVAL_SAR_NEG_SEL_P7 0x00000005u
N#define CYVAL_SAR_NEG_SEL_ACORE 0x00000006u
N#define CYVAL_SAR_NEG_SEL_VREF 0x00000007u
N#define CYFLD_SAR_SAR_HW_CTRL_NEGVREF__OFFSET 0x0000000du
N#define CYFLD_SAR_SAR_HW_CTRL_NEGVREF__SIZE 0x00000001u
N#define CYFLD_SAR_PWR_CTRL_VREF__OFFSET 0x0000000eu
N#define CYFLD_SAR_PWR_CTRL_VREF__SIZE 0x00000002u
N#define CYVAL_SAR_PWR_CTRL_VREF_NORMAL_PWR 0x00000000u
N#define CYVAL_SAR_PWR_CTRL_VREF_HALF_PWR 0x00000001u
N#define CYVAL_SAR_PWR_CTRL_VREF_THIRD_PWR 0x00000002u
N#define CYVAL_SAR_PWR_CTRL_VREF_QUARTER_PWR 0x00000003u
N#define CYFLD_SAR_SPARE__OFFSET 0x00000010u
N#define CYFLD_SAR_SPARE__SIZE 0x00000004u
N#define CYFLD_SAR_BOOSTPUMP_EN__OFFSET 0x00000014u
N#define CYFLD_SAR_BOOSTPUMP_EN__SIZE 0x00000001u
N#define CYFLD_SAR_ICONT_LV__OFFSET 0x00000018u
N#define CYFLD_SAR_ICONT_LV__SIZE 0x00000002u
N#define CYVAL_SAR_ICONT_LV_NORMAL_PWR 0x00000000u
N#define CYVAL_SAR_ICONT_LV_HALF_PWR 0x00000001u
N#define CYVAL_SAR_ICONT_LV_MORE_PWR 0x00000002u
N#define CYVAL_SAR_ICONT_LV_QUARTER_PWR 0x00000003u
N#define CYFLD_SAR_DEEPSLEEP_ON__OFFSET 0x0000001bu
N#define CYFLD_SAR_DEEPSLEEP_ON__SIZE 0x00000001u
N#define CYFLD_SAR_DSI_SYNC_CONFIG__OFFSET 0x0000001cu
N#define CYFLD_SAR_DSI_SYNC_CONFIG__SIZE 0x00000001u
N#define CYFLD_SAR_DSI_MODE__OFFSET 0x0000001du
N#define CYFLD_SAR_DSI_MODE__SIZE 0x00000001u
N#define CYFLD_SAR_SWITCH_DISABLE__OFFSET 0x0000001eu
N#define CYFLD_SAR_SWITCH_DISABLE__SIZE 0x00000001u
N#define CYFLD_SAR_ENABLED__OFFSET 0x0000001fu
N#define CYFLD_SAR_ENABLED__SIZE 0x00000001u
N#define CYREG_SAR_SAMPLE_CTRL 0x403a0004u
N#define CYFLD_SAR_SUB_RESOLUTION__OFFSET 0x00000000u
N#define CYFLD_SAR_SUB_RESOLUTION__SIZE 0x00000001u
N#define CYVAL_SAR_SUB_RESOLUTION_8B 0x00000000u
N#define CYVAL_SAR_SUB_RESOLUTION_10B 0x00000001u
N#define CYFLD_SAR_LEFT_ALIGN__OFFSET 0x00000001u
N#define CYFLD_SAR_LEFT_ALIGN__SIZE 0x00000001u
N#define CYFLD_SAR_SINGLE_ENDED_SIGNED__OFFSET 0x00000002u
N#define CYFLD_SAR_SINGLE_ENDED_SIGNED__SIZE 0x00000001u
N#define CYVAL_SAR_SINGLE_ENDED_SIGNED_UNSIGNED 0x00000000u
N#define CYVAL_SAR_SINGLE_ENDED_SIGNED_SIGNED 0x00000001u
N#define CYFLD_SAR_DIFFERENTIAL_SIGNED__OFFSET 0x00000003u
N#define CYFLD_SAR_DIFFERENTIAL_SIGNED__SIZE 0x00000001u
N#define CYVAL_SAR_DIFFERENTIAL_SIGNED_UNSIGNED 0x00000000u
N#define CYVAL_SAR_DIFFERENTIAL_SIGNED_SIGNED 0x00000001u
N#define CYFLD_SAR_AVG_CNT__OFFSET 0x00000004u
N#define CYFLD_SAR_AVG_CNT__SIZE 0x00000003u
N#define CYFLD_SAR_AVG_SHIFT__OFFSET 0x00000007u
N#define CYFLD_SAR_AVG_SHIFT__SIZE 0x00000001u
N#define CYFLD_SAR_CONTINUOUS__OFFSET 0x00000010u
N#define CYFLD_SAR_CONTINUOUS__SIZE 0x00000001u
N#define CYFLD_SAR_DSI_TRIGGER_EN__OFFSET 0x00000011u
N#define CYFLD_SAR_DSI_TRIGGER_EN__SIZE 0x00000001u
N#define CYFLD_SAR_DSI_TRIGGER_LEVEL__OFFSET 0x00000012u
N#define CYFLD_SAR_DSI_TRIGGER_LEVEL__SIZE 0x00000001u
N#define CYFLD_SAR_DSI_SYNC_TRIGGER__OFFSET 0x00000013u
N#define CYFLD_SAR_DSI_SYNC_TRIGGER__SIZE 0x00000001u
N#define CYFLD_SAR_EOS_DSI_OUT_EN__OFFSET 0x0000001fu
N#define CYFLD_SAR_EOS_DSI_OUT_EN__SIZE 0x00000001u
N#define CYREG_SAR_SAMPLE_TIME01 0x403a0010u
N#define CYFLD_SAR_SAMPLE_TIME0__OFFSET 0x00000000u
N#define CYFLD_SAR_SAMPLE_TIME0__SIZE 0x0000000au
N#define CYFLD_SAR_SAMPLE_TIME1__OFFSET 0x00000010u
N#define CYFLD_SAR_SAMPLE_TIME1__SIZE 0x0000000au
N#define CYREG_SAR_SAMPLE_TIME23 0x403a0014u
N#define CYFLD_SAR_SAMPLE_TIME2__OFFSET 0x00000000u
N#define CYFLD_SAR_SAMPLE_TIME2__SIZE 0x0000000au
N#define CYFLD_SAR_SAMPLE_TIME3__OFFSET 0x00000010u
N#define CYFLD_SAR_SAMPLE_TIME3__SIZE 0x0000000au
N#define CYREG_SAR_RANGE_THRES 0x403a0018u
N#define CYFLD_SAR_RANGE_LOW__OFFSET 0x00000000u
N#define CYFLD_SAR_RANGE_LOW__SIZE 0x00000010u
N#define CYFLD_SAR_RANGE_HIGH__OFFSET 0x00000010u
N#define CYFLD_SAR_RANGE_HIGH__SIZE 0x00000010u
N#define CYREG_SAR_RANGE_COND 0x403a001cu
N#define CYFLD_SAR_RANGE_COND__OFFSET 0x0000001eu
N#define CYFLD_SAR_RANGE_COND__SIZE 0x00000002u
N#define CYVAL_SAR_RANGE_COND_BELOW 0x00000000u
N#define CYVAL_SAR_RANGE_COND_INSIDE 0x00000001u
N#define CYVAL_SAR_RANGE_COND_ABOVE 0x00000002u
N#define CYVAL_SAR_RANGE_COND_OUTSIDE 0x00000003u
N#define CYREG_SAR_CHAN_EN 0x403a0020u
N#define CYFLD_SAR_CHAN_EN__OFFSET 0x00000000u
N#define CYFLD_SAR_CHAN_EN__SIZE 0x00000010u
N#define CYREG_SAR_START_CTRL 0x403a0024u
N#define CYFLD_SAR_FW_TRIGGER__OFFSET 0x00000000u
N#define CYFLD_SAR_FW_TRIGGER__SIZE 0x00000001u
N#define CYREG_SAR_DFT_CTRL 0x403a0030u
N#define CYFLD_SAR_DLY_INC__OFFSET 0x00000000u
N#define CYFLD_SAR_DLY_INC__SIZE 0x00000001u
N#define CYFLD_SAR_HIZ__OFFSET 0x00000001u
N#define CYFLD_SAR_HIZ__SIZE 0x00000001u
N#define CYFLD_SAR_DFT_INC__OFFSET 0x00000010u
N#define CYFLD_SAR_DFT_INC__SIZE 0x00000004u
N#define CYFLD_SAR_DFT_OUTC__OFFSET 0x00000014u
N#define CYFLD_SAR_DFT_OUTC__SIZE 0x00000003u
N#define CYFLD_SAR_SEL_CSEL_DFT__OFFSET 0x00000018u
N#define CYFLD_SAR_SEL_CSEL_DFT__SIZE 0x00000004u
N#define CYFLD_SAR_EN_CSEL_DFT__OFFSET 0x0000001cu
N#define CYFLD_SAR_EN_CSEL_DFT__SIZE 0x00000001u
N#define CYFLD_SAR_DCEN__OFFSET 0x0000001du
N#define CYFLD_SAR_DCEN__SIZE 0x00000001u
N#define CYFLD_SAR_ADFT_OVERRIDE__OFFSET 0x0000001fu
N#define CYFLD_SAR_ADFT_OVERRIDE__SIZE 0x00000001u
N#define CYREG_SAR_CHAN_CONFIG0 0x403a0080u
N#define CYFLD_SAR_PIN_ADDR__OFFSET 0x00000000u
N#define CYFLD_SAR_PIN_ADDR__SIZE 0x00000003u
N#define CYFLD_SAR_PORT_ADDR__OFFSET 0x00000004u
N#define CYFLD_SAR_PORT_ADDR__SIZE 0x00000003u
N#define CYVAL_SAR_PORT_ADDR_SARMUX 0x00000000u
N#define CYVAL_SAR_PORT_ADDR_CTB0 0x00000001u
N#define CYVAL_SAR_PORT_ADDR_CTB1 0x00000002u
N#define CYVAL_SAR_PORT_ADDR_CTB2 0x00000003u
N#define CYVAL_SAR_PORT_ADDR_CTB3 0x00000004u
N#define CYVAL_SAR_PORT_ADDR_AROUTE_VIRT2 0x00000005u
N#define CYVAL_SAR_PORT_ADDR_AROUTE_VIRT1 0x00000006u
N#define CYVAL_SAR_PORT_ADDR_SARMUX_VIRT 0x00000007u
N#define CYFLD_SAR_DIFFERENTIAL_EN__OFFSET 0x00000008u
N#define CYFLD_SAR_DIFFERENTIAL_EN__SIZE 0x00000001u
N#define CYFLD_SAR_RESOLUTION__OFFSET 0x00000009u
N#define CYFLD_SAR_RESOLUTION__SIZE 0x00000001u
N#define CYVAL_SAR_RESOLUTION_MAXRES 0x00000000u
N#define CYVAL_SAR_RESOLUTION_SUBRES 0x00000001u
N#define CYFLD_SAR_AVG_EN__OFFSET 0x0000000au
N#define CYFLD_SAR_AVG_EN__SIZE 0x00000001u
N#define CYFLD_SAR_SAMPLE_TIME_SEL__OFFSET 0x0000000cu
N#define CYFLD_SAR_SAMPLE_TIME_SEL__SIZE 0x00000002u
N#define CYFLD_SAR_DSI_OUT_EN__OFFSET 0x0000001fu
N#define CYFLD_SAR_DSI_OUT_EN__SIZE 0x00000001u
N#define CYREG_SAR_CHAN_CONFIG1 0x403a0084u
N#define CYREG_SAR_CHAN_CONFIG2 0x403a0088u
N#define CYREG_SAR_CHAN_CONFIG3 0x403a008cu
N#define CYREG_SAR_CHAN_CONFIG4 0x403a0090u
N#define CYREG_SAR_CHAN_CONFIG5 0x403a0094u
N#define CYREG_SAR_CHAN_CONFIG6 0x403a0098u
N#define CYREG_SAR_CHAN_CONFIG7 0x403a009cu
N#define CYREG_SAR_CHAN_CONFIG8 0x403a00a0u
N#define CYREG_SAR_CHAN_CONFIG9 0x403a00a4u
N#define CYREG_SAR_CHAN_CONFIG10 0x403a00a8u
N#define CYREG_SAR_CHAN_CONFIG11 0x403a00acu
N#define CYREG_SAR_CHAN_CONFIG12 0x403a00b0u
N#define CYREG_SAR_CHAN_CONFIG13 0x403a00b4u
N#define CYREG_SAR_CHAN_CONFIG14 0x403a00b8u
N#define CYREG_SAR_CHAN_CONFIG15 0x403a00bcu
N#define CYREG_SAR_CHAN_WORK0 0x403a0100u
N#define CYFLD_SAR_WORK__OFFSET 0x00000000u
N#define CYFLD_SAR_WORK__SIZE 0x00000010u
N#define CYFLD_SAR_CHAN_WORK_VALID_MIR__OFFSET 0x0000001fu
N#define CYFLD_SAR_CHAN_WORK_VALID_MIR__SIZE 0x00000001u
N#define CYREG_SAR_CHAN_WORK1 0x403a0104u
N#define CYREG_SAR_CHAN_WORK2 0x403a0108u
N#define CYREG_SAR_CHAN_WORK3 0x403a010cu
N#define CYREG_SAR_CHAN_WORK4 0x403a0110u
N#define CYREG_SAR_CHAN_WORK5 0x403a0114u
N#define CYREG_SAR_CHAN_WORK6 0x403a0118u
N#define CYREG_SAR_CHAN_WORK7 0x403a011cu
N#define CYREG_SAR_CHAN_WORK8 0x403a0120u
N#define CYREG_SAR_CHAN_WORK9 0x403a0124u
N#define CYREG_SAR_CHAN_WORK10 0x403a0128u
N#define CYREG_SAR_CHAN_WORK11 0x403a012cu
N#define CYREG_SAR_CHAN_WORK12 0x403a0130u
N#define CYREG_SAR_CHAN_WORK13 0x403a0134u
N#define CYREG_SAR_CHAN_WORK14 0x403a0138u
N#define CYREG_SAR_CHAN_WORK15 0x403a013cu
N#define CYREG_SAR_CHAN_RESULT0 0x403a0180u
N#define CYFLD_SAR_RESULT__OFFSET 0x00000000u
N#define CYFLD_SAR_RESULT__SIZE 0x00000010u
N#define CYFLD_SAR_SATURATE_INTR_MIR__OFFSET 0x0000001du
N#define CYFLD_SAR_SATURATE_INTR_MIR__SIZE 0x00000001u
N#define CYFLD_SAR_RANGE_INTR_MIR__OFFSET 0x0000001eu
N#define CYFLD_SAR_RANGE_INTR_MIR__SIZE 0x00000001u
N#define CYFLD_SAR_CHAN_RESULT_VALID_MIR__OFFSET 0x0000001fu
N#define CYFLD_SAR_CHAN_RESULT_VALID_MIR__SIZE 0x00000001u
N#define CYREG_SAR_CHAN_RESULT1 0x403a0184u
N#define CYREG_SAR_CHAN_RESULT2 0x403a0188u
N#define CYREG_SAR_CHAN_RESULT3 0x403a018cu
N#define CYREG_SAR_CHAN_RESULT4 0x403a0190u
N#define CYREG_SAR_CHAN_RESULT5 0x403a0194u
N#define CYREG_SAR_CHAN_RESULT6 0x403a0198u
N#define CYREG_SAR_CHAN_RESULT7 0x403a019cu
N#define CYREG_SAR_CHAN_RESULT8 0x403a01a0u
N#define CYREG_SAR_CHAN_RESULT9 0x403a01a4u
N#define CYREG_SAR_CHAN_RESULT10 0x403a01a8u
N#define CYREG_SAR_CHAN_RESULT11 0x403a01acu
N#define CYREG_SAR_CHAN_RESULT12 0x403a01b0u
N#define CYREG_SAR_CHAN_RESULT13 0x403a01b4u
N#define CYREG_SAR_CHAN_RESULT14 0x403a01b8u
N#define CYREG_SAR_CHAN_RESULT15 0x403a01bcu
N#define CYREG_SAR_CHAN_WORK_VALID 0x403a0200u
N#define CYFLD_SAR_CHAN_WORK_VALID__OFFSET 0x00000000u
N#define CYFLD_SAR_CHAN_WORK_VALID__SIZE 0x00000010u
N#define CYREG_SAR_CHAN_RESULT_VALID 0x403a0204u
N#define CYFLD_SAR_CHAN_RESULT_VALID__OFFSET 0x00000000u
N#define CYFLD_SAR_CHAN_RESULT_VALID__SIZE 0x00000010u
N#define CYREG_SAR_STATUS 0x403a0208u
N#define CYFLD_SAR_CUR_CHAN__OFFSET 0x00000000u
N#define CYFLD_SAR_CUR_CHAN__SIZE 0x00000005u
N#define CYFLD_SAR_SW_VREF_NEG__OFFSET 0x0000001eu
N#define CYFLD_SAR_SW_VREF_NEG__SIZE 0x00000001u
N#define CYFLD_SAR_BUSY__OFFSET 0x0000001fu
N#define CYFLD_SAR_BUSY__SIZE 0x00000001u
N#define CYREG_SAR_AVG_STAT 0x403a020cu
N#define CYFLD_SAR_CUR_AVG_ACCU__OFFSET 0x00000000u
N#define CYFLD_SAR_CUR_AVG_ACCU__SIZE 0x00000014u
N#define CYFLD_SAR_CUR_AVG_CNT__OFFSET 0x00000018u
N#define CYFLD_SAR_CUR_AVG_CNT__SIZE 0x00000008u
N#define CYREG_SAR_INTR 0x403a0210u
N#define CYFLD_SAR_EOS_INTR__OFFSET 0x00000000u
N#define CYFLD_SAR_EOS_INTR__SIZE 0x00000001u
N#define CYFLD_SAR_OVERFLOW_INTR__OFFSET 0x00000001u
N#define CYFLD_SAR_OVERFLOW_INTR__SIZE 0x00000001u
N#define CYFLD_SAR_FW_COLLISION_INTR__OFFSET 0x00000002u
N#define CYFLD_SAR_FW_COLLISION_INTR__SIZE 0x00000001u
N#define CYFLD_SAR_DSI_COLLISION_INTR__OFFSET 0x00000003u
N#define CYFLD_SAR_DSI_COLLISION_INTR__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_EOC_INTR__OFFSET 0x00000004u
N#define CYFLD_SAR_INJ_EOC_INTR__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_SATURATE_INTR__OFFSET 0x00000005u
N#define CYFLD_SAR_INJ_SATURATE_INTR__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_RANGE_INTR__OFFSET 0x00000006u
N#define CYFLD_SAR_INJ_RANGE_INTR__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_COLLISION_INTR__OFFSET 0x00000007u
N#define CYFLD_SAR_INJ_COLLISION_INTR__SIZE 0x00000001u
N#define CYREG_SAR_INTR_SET 0x403a0214u
N#define CYFLD_SAR_EOS_SET__OFFSET 0x00000000u
N#define CYFLD_SAR_EOS_SET__SIZE 0x00000001u
N#define CYFLD_SAR_OVERFLOW_SET__OFFSET 0x00000001u
N#define CYFLD_SAR_OVERFLOW_SET__SIZE 0x00000001u
N#define CYFLD_SAR_FW_COLLISION_SET__OFFSET 0x00000002u
N#define CYFLD_SAR_FW_COLLISION_SET__SIZE 0x00000001u
N#define CYFLD_SAR_DSI_COLLISION_SET__OFFSET 0x00000003u
N#define CYFLD_SAR_DSI_COLLISION_SET__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_EOC_SET__OFFSET 0x00000004u
N#define CYFLD_SAR_INJ_EOC_SET__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_SATURATE_SET__OFFSET 0x00000005u
N#define CYFLD_SAR_INJ_SATURATE_SET__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_RANGE_SET__OFFSET 0x00000006u
N#define CYFLD_SAR_INJ_RANGE_SET__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_COLLISION_SET__OFFSET 0x00000007u
N#define CYFLD_SAR_INJ_COLLISION_SET__SIZE 0x00000001u
N#define CYREG_SAR_INTR_MASK 0x403a0218u
N#define CYFLD_SAR_EOS_MASK__OFFSET 0x00000000u
N#define CYFLD_SAR_EOS_MASK__SIZE 0x00000001u
N#define CYFLD_SAR_OVERFLOW_MASK__OFFSET 0x00000001u
N#define CYFLD_SAR_OVERFLOW_MASK__SIZE 0x00000001u
N#define CYFLD_SAR_FW_COLLISION_MASK__OFFSET 0x00000002u
N#define CYFLD_SAR_FW_COLLISION_MASK__SIZE 0x00000001u
N#define CYFLD_SAR_DSI_COLLISION_MASK__OFFSET 0x00000003u
N#define CYFLD_SAR_DSI_COLLISION_MASK__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_EOC_MASK__OFFSET 0x00000004u
N#define CYFLD_SAR_INJ_EOC_MASK__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_SATURATE_MASK__OFFSET 0x00000005u
N#define CYFLD_SAR_INJ_SATURATE_MASK__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_RANGE_MASK__OFFSET 0x00000006u
N#define CYFLD_SAR_INJ_RANGE_MASK__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_COLLISION_MASK__OFFSET 0x00000007u
N#define CYFLD_SAR_INJ_COLLISION_MASK__SIZE 0x00000001u
N#define CYREG_SAR_INTR_MASKED 0x403a021cu
N#define CYFLD_SAR_EOS_MASKED__OFFSET 0x00000000u
N#define CYFLD_SAR_EOS_MASKED__SIZE 0x00000001u
N#define CYFLD_SAR_OVERFLOW_MASKED__OFFSET 0x00000001u
N#define CYFLD_SAR_OVERFLOW_MASKED__SIZE 0x00000001u
N#define CYFLD_SAR_FW_COLLISION_MASKED__OFFSET 0x00000002u
N#define CYFLD_SAR_FW_COLLISION_MASKED__SIZE 0x00000001u
N#define CYFLD_SAR_DSI_COLLISION_MASKED__OFFSET 0x00000003u
N#define CYFLD_SAR_DSI_COLLISION_MASKED__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_EOC_MASKED__OFFSET 0x00000004u
N#define CYFLD_SAR_INJ_EOC_MASKED__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_SATURATE_MASKED__OFFSET 0x00000005u
N#define CYFLD_SAR_INJ_SATURATE_MASKED__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_RANGE_MASKED__OFFSET 0x00000006u
N#define CYFLD_SAR_INJ_RANGE_MASKED__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_COLLISION_MASKED__OFFSET 0x00000007u
N#define CYFLD_SAR_INJ_COLLISION_MASKED__SIZE 0x00000001u
N#define CYREG_SAR_SATURATE_INTR 0x403a0220u
N#define CYFLD_SAR_SATURATE_INTR__OFFSET 0x00000000u
N#define CYFLD_SAR_SATURATE_INTR__SIZE 0x00000010u
N#define CYREG_SAR_SATURATE_INTR_SET 0x403a0224u
N#define CYFLD_SAR_SATURATE_SET__OFFSET 0x00000000u
N#define CYFLD_SAR_SATURATE_SET__SIZE 0x00000010u
N#define CYREG_SAR_SATURATE_INTR_MASK 0x403a0228u
N#define CYFLD_SAR_SATURATE_MASK__OFFSET 0x00000000u
N#define CYFLD_SAR_SATURATE_MASK__SIZE 0x00000010u
N#define CYREG_SAR_SATURATE_INTR_MASKED 0x403a022cu
N#define CYFLD_SAR_SATURATE_MASKED__OFFSET 0x00000000u
N#define CYFLD_SAR_SATURATE_MASKED__SIZE 0x00000010u
N#define CYREG_SAR_RANGE_INTR 0x403a0230u
N#define CYFLD_SAR_RANGE_INTR__OFFSET 0x00000000u
N#define CYFLD_SAR_RANGE_INTR__SIZE 0x00000010u
N#define CYREG_SAR_RANGE_INTR_SET 0x403a0234u
N#define CYFLD_SAR_RANGE_SET__OFFSET 0x00000000u
N#define CYFLD_SAR_RANGE_SET__SIZE 0x00000010u
N#define CYREG_SAR_RANGE_INTR_MASK 0x403a0238u
N#define CYFLD_SAR_RANGE_MASK__OFFSET 0x00000000u
N#define CYFLD_SAR_RANGE_MASK__SIZE 0x00000010u
N#define CYREG_SAR_RANGE_INTR_MASKED 0x403a023cu
N#define CYFLD_SAR_RANGE_MASKED__OFFSET 0x00000000u
N#define CYFLD_SAR_RANGE_MASKED__SIZE 0x00000010u
N#define CYREG_SAR_INTR_CAUSE 0x403a0240u
N#define CYFLD_SAR_EOS_MASKED_MIR__OFFSET 0x00000000u
N#define CYFLD_SAR_EOS_MASKED_MIR__SIZE 0x00000001u
N#define CYFLD_SAR_OVERFLOW_MASKED_MIR__OFFSET 0x00000001u
N#define CYFLD_SAR_OVERFLOW_MASKED_MIR__SIZE 0x00000001u
N#define CYFLD_SAR_FW_COLLISION_MASKED_MIR__OFFSET 0x00000002u
N#define CYFLD_SAR_FW_COLLISION_MASKED_MIR__SIZE 0x00000001u
N#define CYFLD_SAR_DSI_COLLISION_MASKED_MIR__OFFSET 0x00000003u
N#define CYFLD_SAR_DSI_COLLISION_MASKED_MIR__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_EOC_MASKED_MIR__OFFSET 0x00000004u
N#define CYFLD_SAR_INJ_EOC_MASKED_MIR__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_SATURATE_MASKED_MIR__OFFSET 0x00000005u
N#define CYFLD_SAR_INJ_SATURATE_MASKED_MIR__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_RANGE_MASKED_MIR__OFFSET 0x00000006u
N#define CYFLD_SAR_INJ_RANGE_MASKED_MIR__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_COLLISION_MASKED_MIR__OFFSET 0x00000007u
N#define CYFLD_SAR_INJ_COLLISION_MASKED_MIR__SIZE 0x00000001u
N#define CYFLD_SAR_SATURATE_MASKED_RED__OFFSET 0x0000001eu
N#define CYFLD_SAR_SATURATE_MASKED_RED__SIZE 0x00000001u
N#define CYFLD_SAR_RANGE_MASKED_RED__OFFSET 0x0000001fu
N#define CYFLD_SAR_RANGE_MASKED_RED__SIZE 0x00000001u
N#define CYREG_SAR_INJ_CHAN_CONFIG 0x403a0280u
N#define CYFLD_SAR_INJ_PIN_ADDR__OFFSET 0x00000000u
N#define CYFLD_SAR_INJ_PIN_ADDR__SIZE 0x00000003u
N#define CYFLD_SAR_INJ_PORT_ADDR__OFFSET 0x00000004u
N#define CYFLD_SAR_INJ_PORT_ADDR__SIZE 0x00000003u
N#define CYVAL_SAR_INJ_PORT_ADDR_SARMUX 0x00000000u
N#define CYVAL_SAR_INJ_PORT_ADDR_CTB0 0x00000001u
N#define CYVAL_SAR_INJ_PORT_ADDR_CTB1 0x00000002u
N#define CYVAL_SAR_INJ_PORT_ADDR_CTB2 0x00000003u
N#define CYVAL_SAR_INJ_PORT_ADDR_CTB3 0x00000004u
N#define CYVAL_SAR_INJ_PORT_ADDR_AROUTE_VIRT 0x00000006u
N#define CYVAL_SAR_INJ_PORT_ADDR_SARMUX_VIRT 0x00000007u
N#define CYFLD_SAR_INJ_DIFFERENTIAL_EN__OFFSET 0x00000008u
N#define CYFLD_SAR_INJ_DIFFERENTIAL_EN__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_RESOLUTION__OFFSET 0x00000009u
N#define CYFLD_SAR_INJ_RESOLUTION__SIZE 0x00000001u
N#define CYVAL_SAR_INJ_RESOLUTION_12B 0x00000000u
N#define CYVAL_SAR_INJ_RESOLUTION_SUBRES 0x00000001u
N#define CYFLD_SAR_INJ_AVG_EN__OFFSET 0x0000000au
N#define CYFLD_SAR_INJ_AVG_EN__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_SAMPLE_TIME_SEL__OFFSET 0x0000000cu
N#define CYFLD_SAR_INJ_SAMPLE_TIME_SEL__SIZE 0x00000002u
N#define CYFLD_SAR_INJ_TAILGATING__OFFSET 0x0000001eu
N#define CYFLD_SAR_INJ_TAILGATING__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_START_EN__OFFSET 0x0000001fu
N#define CYFLD_SAR_INJ_START_EN__SIZE 0x00000001u
N#define CYREG_SAR_INJ_RESULT 0x403a0290u
N#define CYFLD_SAR_INJ_RESULT__OFFSET 0x00000000u
N#define CYFLD_SAR_INJ_RESULT__SIZE 0x00000010u
N#define CYFLD_SAR_INJ_COLLISION_INTR_MIR__OFFSET 0x0000001cu
N#define CYFLD_SAR_INJ_COLLISION_INTR_MIR__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_SATURATE_INTR_MIR__OFFSET 0x0000001du
N#define CYFLD_SAR_INJ_SATURATE_INTR_MIR__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_RANGE_INTR_MIR__OFFSET 0x0000001eu
N#define CYFLD_SAR_INJ_RANGE_INTR_MIR__SIZE 0x00000001u
N#define CYFLD_SAR_INJ_EOC_INTR_MIR__OFFSET 0x0000001fu
N#define CYFLD_SAR_INJ_EOC_INTR_MIR__SIZE 0x00000001u
N#define CYREG_SAR_MUX_SWITCH0 0x403a0300u
N#define CYFLD_SAR_MUX_FW_P0_VPLUS__OFFSET 0x00000000u
N#define CYFLD_SAR_MUX_FW_P0_VPLUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_P1_VPLUS__OFFSET 0x00000001u
N#define CYFLD_SAR_MUX_FW_P1_VPLUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_P2_VPLUS__OFFSET 0x00000002u
N#define CYFLD_SAR_MUX_FW_P2_VPLUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_P3_VPLUS__OFFSET 0x00000003u
N#define CYFLD_SAR_MUX_FW_P3_VPLUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_P4_VPLUS__OFFSET 0x00000004u
N#define CYFLD_SAR_MUX_FW_P4_VPLUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_P5_VPLUS__OFFSET 0x00000005u
N#define CYFLD_SAR_MUX_FW_P5_VPLUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_P6_VPLUS__OFFSET 0x00000006u
N#define CYFLD_SAR_MUX_FW_P6_VPLUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_P7_VPLUS__OFFSET 0x00000007u
N#define CYFLD_SAR_MUX_FW_P7_VPLUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_P0_VMINUS__OFFSET 0x00000008u
N#define CYFLD_SAR_MUX_FW_P0_VMINUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_P1_VMINUS__OFFSET 0x00000009u
N#define CYFLD_SAR_MUX_FW_P1_VMINUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_P2_VMINUS__OFFSET 0x0000000au
N#define CYFLD_SAR_MUX_FW_P2_VMINUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_P3_VMINUS__OFFSET 0x0000000bu
N#define CYFLD_SAR_MUX_FW_P3_VMINUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_P4_VMINUS__OFFSET 0x0000000cu
N#define CYFLD_SAR_MUX_FW_P4_VMINUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_P5_VMINUS__OFFSET 0x0000000du
N#define CYFLD_SAR_MUX_FW_P5_VMINUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_P6_VMINUS__OFFSET 0x0000000eu
N#define CYFLD_SAR_MUX_FW_P6_VMINUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_P7_VMINUS__OFFSET 0x0000000fu
N#define CYFLD_SAR_MUX_FW_P7_VMINUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_VSSA_VMINUS__OFFSET 0x00000010u
N#define CYFLD_SAR_MUX_FW_VSSA_VMINUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_TEMP_VPLUS__OFFSET 0x00000011u
N#define CYFLD_SAR_MUX_FW_TEMP_VPLUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_AMUXBUSA_VPLUS__OFFSET 0x00000012u
N#define CYFLD_SAR_MUX_FW_AMUXBUSA_VPLUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_AMUXBUSB_VPLUS__OFFSET 0x00000013u
N#define CYFLD_SAR_MUX_FW_AMUXBUSB_VPLUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_AMUXBUSA_VMINUS__OFFSET 0x00000014u
N#define CYFLD_SAR_MUX_FW_AMUXBUSA_VMINUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_AMUXBUSB_VMINUS__OFFSET 0x00000015u
N#define CYFLD_SAR_MUX_FW_AMUXBUSB_VMINUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_SARBUS0_VPLUS__OFFSET 0x00000016u
N#define CYFLD_SAR_MUX_FW_SARBUS0_VPLUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_SARBUS1_VPLUS__OFFSET 0x00000017u
N#define CYFLD_SAR_MUX_FW_SARBUS1_VPLUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_SARBUS0_VMINUS__OFFSET 0x00000018u
N#define CYFLD_SAR_MUX_FW_SARBUS0_VMINUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_SARBUS1_VMINUS__OFFSET 0x00000019u
N#define CYFLD_SAR_MUX_FW_SARBUS1_VMINUS__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_P4_COREIO0__OFFSET 0x0000001au
N#define CYFLD_SAR_MUX_FW_P4_COREIO0__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_P5_COREIO1__OFFSET 0x0000001bu
N#define CYFLD_SAR_MUX_FW_P5_COREIO1__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_P6_COREIO2__OFFSET 0x0000001cu
N#define CYFLD_SAR_MUX_FW_P6_COREIO2__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_P7_COREIO3__OFFSET 0x0000001du
N#define CYFLD_SAR_MUX_FW_P7_COREIO3__SIZE 0x00000001u
N#define CYREG_SAR_MUX_SWITCH_CLEAR0 0x403a0304u
N#define CYREG_SAR_MUX_SWITCH1 0x403a0308u
N#define CYFLD_SAR_MUX_FW_P4_DFT_INP__OFFSET 0x00000000u
N#define CYFLD_SAR_MUX_FW_P4_DFT_INP__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_P5_DFT_INM__OFFSET 0x00000001u
N#define CYFLD_SAR_MUX_FW_P5_DFT_INM__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_ADFT0_SARBUS0__OFFSET 0x00000002u
N#define CYFLD_SAR_MUX_FW_ADFT0_SARBUS0__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_FW_ADFT1_SARBUS1__OFFSET 0x00000003u
N#define CYFLD_SAR_MUX_FW_ADFT1_SARBUS1__SIZE 0x00000001u
N#define CYREG_SAR_MUX_SWITCH_CLEAR1 0x403a030cu
N#define CYREG_SAR_MUX_SWITCH_HW_CTRL 0x403a0340u
N#define CYFLD_SAR_MUX_HW_CTRL_P0__OFFSET 0x00000000u
N#define CYFLD_SAR_MUX_HW_CTRL_P0__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_HW_CTRL_P1__OFFSET 0x00000001u
N#define CYFLD_SAR_MUX_HW_CTRL_P1__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_HW_CTRL_P2__OFFSET 0x00000002u
N#define CYFLD_SAR_MUX_HW_CTRL_P2__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_HW_CTRL_P3__OFFSET 0x00000003u
N#define CYFLD_SAR_MUX_HW_CTRL_P3__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_HW_CTRL_P4__OFFSET 0x00000004u
N#define CYFLD_SAR_MUX_HW_CTRL_P4__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_HW_CTRL_P5__OFFSET 0x00000005u
N#define CYFLD_SAR_MUX_HW_CTRL_P5__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_HW_CTRL_P6__OFFSET 0x00000006u
N#define CYFLD_SAR_MUX_HW_CTRL_P6__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_HW_CTRL_P7__OFFSET 0x00000007u
N#define CYFLD_SAR_MUX_HW_CTRL_P7__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_HW_CTRL_VSSA__OFFSET 0x00000010u
N#define CYFLD_SAR_MUX_HW_CTRL_VSSA__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_HW_CTRL_TEMP__OFFSET 0x00000011u
N#define CYFLD_SAR_MUX_HW_CTRL_TEMP__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_HW_CTRL_AMUXBUSA__OFFSET 0x00000012u
N#define CYFLD_SAR_MUX_HW_CTRL_AMUXBUSA__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_HW_CTRL_AMUXBUSB__OFFSET 0x00000013u
N#define CYFLD_SAR_MUX_HW_CTRL_AMUXBUSB__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_HW_CTRL_SARBUS0__OFFSET 0x00000016u
N#define CYFLD_SAR_MUX_HW_CTRL_SARBUS0__SIZE 0x00000001u
N#define CYFLD_SAR_MUX_HW_CTRL_SARBUS1__OFFSET 0x00000017u
N#define CYFLD_SAR_MUX_HW_CTRL_SARBUS1__SIZE 0x00000001u
N#define CYREG_SAR_MUX_SWITCH_STATUS 0x403a0348u
N#define CYREG_SAR_PUMP_CTRL 0x403a0380u
N#define CYFLD_SAR_CLOCK_SEL__OFFSET 0x00000000u
N#define CYFLD_SAR_CLOCK_SEL__SIZE 0x00000001u
N#define CYREG_SAR_ANA_TRIM 0x403a0f00u
N#define CYFLD_SAR_CAP_TRIM__OFFSET 0x00000000u
N#define CYFLD_SAR_CAP_TRIM__SIZE 0x00000003u
N#define CYFLD_SAR_TRIMUNIT__OFFSET 0x00000003u
N#define CYFLD_SAR_TRIMUNIT__SIZE 0x00000001u
N#define CYREG_SAR_WOUNDING 0x403a0f04u
N#define CYFLD_SAR_WOUND_RESOLUTION__OFFSET 0x00000000u
N#define CYFLD_SAR_WOUND_RESOLUTION__SIZE 0x00000002u
N#define CYVAL_SAR_WOUND_RESOLUTION_12BIT 0x00000000u
N#define CYVAL_SAR_WOUND_RESOLUTION_10BIT 0x00000001u
N#define CYVAL_SAR_WOUND_RESOLUTION_8BIT 0x00000002u
N#define CYVAL_SAR_WOUND_RESOLUTION_8BIT_TOO 0x00000003u
N#define CYDEV_PASS_BASE 0x403f0000u
N#define CYDEV_PASS_SIZE 0x00010000u
N#define CYREG_PASS_INTR_CAUSE 0x403f0000u
N#define CYFLD_PASS_CTB0_INT__OFFSET 0x00000000u
N#define CYFLD_PASS_CTB0_INT__SIZE 0x00000001u
N#define CYREG_PASS_DFT_CTRL 0x403f0030u
N#define CYFLD_PASS_DSAB_ADFT_RES_EN__OFFSET 0x00000000u
N#define CYFLD_PASS_DSAB_ADFT_RES_EN__SIZE 0x00000001u
N#define CYREG_PASS_PASS_CTRL 0x403f0108u
N#define CYFLD_PASS_PMPCLK_BYP__OFFSET 0x00000000u
N#define CYFLD_PASS_PMPCLK_BYP__SIZE 0x00000001u
N#define CYFLD_PASS_PMPCLK_SRC__OFFSET 0x00000001u
N#define CYFLD_PASS_PMPCLK_SRC__SIZE 0x00000001u
N#define CYFLD_PASS_RMB_BITS__OFFSET 0x00000008u
N#define CYFLD_PASS_RMB_BITS__SIZE 0x00000008u
N#define CYDEV_PASS_DSAB_BASE 0x403f0e00u
N#define CYDEV_PASS_DSAB_SIZE 0x00000100u
N#define CYREG_PASS_DSAB_DSAB_CTRL 0x403f0e00u
N#define CYFLD_PASS_DSAB_CURRENT_SEL__OFFSET 0x00000000u
N#define CYFLD_PASS_DSAB_CURRENT_SEL__SIZE 0x00000006u
N#define CYFLD_PASS_DSAB_SEL_OUT__OFFSET 0x00000008u
N#define CYFLD_PASS_DSAB_SEL_OUT__SIZE 0x00000004u
N#define CYFLD_PASS_DSAB_REF_SWAP_EN__OFFSET 0x00000010u
N#define CYFLD_PASS_DSAB_REF_SWAP_EN__SIZE 0x00000004u
N#define CYFLD_PASS_DSAB_BYPASS_MODE_EN__OFFSET 0x00000018u
N#define CYFLD_PASS_DSAB_BYPASS_MODE_EN__SIZE 0x00000001u
N#define CYFLD_PASS_DSAB_STARTUP_RM__OFFSET 0x0000001cu
N#define CYFLD_PASS_DSAB_STARTUP_RM__SIZE 0x00000001u
N#define CYFLD_PASS_DSAB_ENABLED__OFFSET 0x0000001fu
N#define CYFLD_PASS_DSAB_ENABLED__SIZE 0x00000001u
N#define CYREG_PASS_DSAB_DSAB_DFT 0x403f0e04u
N#define CYFLD_PASS_DSAB_EN_DFT__OFFSET 0x00000000u
N#define CYFLD_PASS_DSAB_EN_DFT__SIZE 0x00000004u
N#define CYREG_PASS_DSAB_TRIM 0x403f0f00u
N#define CYFLD_PASS_IBIAS_TRIM__OFFSET 0x00000000u
N#define CYFLD_PASS_IBIAS_TRIM__SIZE 0x00000004u
N#define CYFLD_PASS_DSAB_RMB_BITS__OFFSET 0x00000004u
N#define CYFLD_PASS_DSAB_RMB_BITS__SIZE 0x00000002u
N#define CYDEV_CM0P_BASE 0xe0000000u
N#define CYDEV_CM0P_SIZE 0x00100000u
N#define CYREG_CM0P_DWT_PID4 0xe0001fd0u
N#define CYFLD_CM0P_VALUE__OFFSET 0x00000000u
N#define CYFLD_CM0P_VALUE__SIZE 0x00000020u
N#define CYREG_CM0P_DWT_PID0 0xe0001fe0u
N#define CYREG_CM0P_DWT_PID1 0xe0001fe4u
N#define CYREG_CM0P_DWT_PID2 0xe0001fe8u
N#define CYREG_CM0P_DWT_PID3 0xe0001fecu
N#define CYREG_CM0P_DWT_CID0 0xe0001ff0u
N#define CYREG_CM0P_DWT_CID1 0xe0001ff4u
N#define CYREG_CM0P_DWT_CID2 0xe0001ff8u
N#define CYREG_CM0P_DWT_CID3 0xe0001ffcu
N#define CYREG_CM0P_BP_PID4 0xe0002fd0u
N#define CYREG_CM0P_BP_PID0 0xe0002fe0u
N#define CYREG_CM0P_BP_PID1 0xe0002fe4u
N#define CYREG_CM0P_BP_PID2 0xe0002fe8u
N#define CYREG_CM0P_BP_PID3 0xe0002fecu
N#define CYREG_CM0P_BP_CID0 0xe0002ff0u
N#define CYREG_CM0P_BP_CID1 0xe0002ff4u
N#define CYREG_CM0P_BP_CID2 0xe0002ff8u
N#define CYREG_CM0P_BP_CID3 0xe0002ffcu
N#define CYREG_CM0P_SYST_CSR 0xe000e010u
N#define CYFLD_CM0P_ENABLE__OFFSET 0x00000000u
N#define CYFLD_CM0P_ENABLE__SIZE 0x00000001u
N#define CYFLD_CM0P_TICKINT__OFFSET 0x00000001u
N#define CYFLD_CM0P_TICKINT__SIZE 0x00000001u
N#define CYFLD_CM0P_CLKSOURCE__OFFSET 0x00000002u
N#define CYFLD_CM0P_CLKSOURCE__SIZE 0x00000001u
N#define CYFLD_CM0P_COUNTFLAG__OFFSET 0x00000010u
N#define CYFLD_CM0P_COUNTFLAG__SIZE 0x00000001u
N#define CYREG_CM0P_SYST_RVR 0xe000e014u
N#define CYFLD_CM0P_RELOAD__OFFSET 0x00000000u
N#define CYFLD_CM0P_RELOAD__SIZE 0x00000018u
N#define CYREG_CM0P_SYST_CVR 0xe000e018u
N#define CYFLD_CM0P_CURRENT__OFFSET 0x00000000u
N#define CYFLD_CM0P_CURRENT__SIZE 0x00000018u
N#define CYREG_CM0P_SYST_CALIB 0xe000e01cu
N#define CYFLD_CM0P_TENMS__OFFSET 0x00000000u
N#define CYFLD_CM0P_TENMS__SIZE 0x00000018u
N#define CYFLD_CM0P_SKEW__OFFSET 0x0000001eu
N#define CYFLD_CM0P_SKEW__SIZE 0x00000001u
N#define CYFLD_CM0P_NOREF__OFFSET 0x0000001fu
N#define CYFLD_CM0P_NOREF__SIZE 0x00000001u
N#define CYREG_CM0P_ISER 0xe000e100u
N#define CYFLD_CM0P_SETENA__OFFSET 0x00000000u
N#define CYFLD_CM0P_SETENA__SIZE 0x00000020u
N#define CYREG_CM0P_ICER 0xe000e180u
N#define CYFLD_CM0P_CLRENA__OFFSET 0x00000000u
N#define CYFLD_CM0P_CLRENA__SIZE 0x00000020u
N#define CYREG_CM0P_ISPR 0xe000e200u
N#define CYFLD_CM0P_SETPEND__OFFSET 0x00000000u
N#define CYFLD_CM0P_SETPEND__SIZE 0x00000020u
N#define CYREG_CM0P_ICPR 0xe000e280u
N#define CYFLD_CM0P_CLRPEND__OFFSET 0x00000000u
N#define CYFLD_CM0P_CLRPEND__SIZE 0x00000020u
N#define CYREG_CM0P_IPR0 0xe000e400u
N#define CYFLD_CM0P_PRI_N0__OFFSET 0x00000006u
N#define CYFLD_CM0P_PRI_N0__SIZE 0x00000002u
N#define CYFLD_CM0P_PRI_N1__OFFSET 0x0000000eu
N#define CYFLD_CM0P_PRI_N1__SIZE 0x00000002u
N#define CYFLD_CM0P_PRI_N2__OFFSET 0x00000016u
N#define CYFLD_CM0P_PRI_N2__SIZE 0x00000002u
N#define CYFLD_CM0P_PRI_N3__OFFSET 0x0000001eu
N#define CYFLD_CM0P_PRI_N3__SIZE 0x00000002u
N#define CYREG_CM0P_IPR1 0xe000e404u
N#define CYREG_CM0P_IPR2 0xe000e408u
N#define CYREG_CM0P_IPR3 0xe000e40cu
N#define CYREG_CM0P_IPR4 0xe000e410u
N#define CYREG_CM0P_IPR5 0xe000e414u
N#define CYREG_CM0P_IPR6 0xe000e418u
N#define CYREG_CM0P_IPR7 0xe000e41cu
N#define CYREG_CM0P_CPUID 0xe000ed00u
N#define CYFLD_CM0P_REVISION__OFFSET 0x00000000u
N#define CYFLD_CM0P_REVISION__SIZE 0x00000004u
N#define CYFLD_CM0P_PARTNO__OFFSET 0x00000004u
N#define CYFLD_CM0P_PARTNO__SIZE 0x0000000cu
N#define CYFLD_CM0P_CONSTANT__OFFSET 0x00000010u
N#define CYFLD_CM0P_CONSTANT__SIZE 0x00000004u
N#define CYFLD_CM0P_VARIANT__OFFSET 0x00000014u
N#define CYFLD_CM0P_VARIANT__SIZE 0x00000004u
N#define CYFLD_CM0P_IMPLEMENTER__OFFSET 0x00000018u
N#define CYFLD_CM0P_IMPLEMENTER__SIZE 0x00000008u
N#define CYREG_CM0P_ICSR 0xe000ed04u
N#define CYFLD_CM0P_VECTACTIVE__OFFSET 0x00000000u
N#define CYFLD_CM0P_VECTACTIVE__SIZE 0x00000009u
N#define CYFLD_CM0P_VECTPENDING__OFFSET 0x0000000cu
N#define CYFLD_CM0P_VECTPENDING__SIZE 0x00000009u
N#define CYFLD_CM0P_ISRPENDING__OFFSET 0x00000016u
N#define CYFLD_CM0P_ISRPENDING__SIZE 0x00000001u
N#define CYFLD_CM0P_ISRPREEMPT__OFFSET 0x00000017u
N#define CYFLD_CM0P_ISRPREEMPT__SIZE 0x00000001u
N#define CYFLD_CM0P_PENDSTCLR__OFFSET 0x00000019u
N#define CYFLD_CM0P_PENDSTCLR__SIZE 0x00000001u
N#define CYFLD_CM0P_PENDSTSETb__OFFSET 0x0000001au
N#define CYFLD_CM0P_PENDSTSETb__SIZE 0x00000001u
N#define CYFLD_CM0P_PENDSVCLR__OFFSET 0x0000001bu
N#define CYFLD_CM0P_PENDSVCLR__SIZE 0x00000001u
N#define CYFLD_CM0P_PENDSVSET__OFFSET 0x0000001cu
N#define CYFLD_CM0P_PENDSVSET__SIZE 0x00000001u
N#define CYFLD_CM0P_NMIPENDSET__OFFSET 0x0000001fu
N#define CYFLD_CM0P_NMIPENDSET__SIZE 0x00000001u
N#define CYREG_CM0P_VTOR 0xe000ed08u
N#define CYFLD_CM0P_TBLOFF__OFFSET 0x00000008u
N#define CYFLD_CM0P_TBLOFF__SIZE 0x00000018u
N#define CYREG_CM0P_AIRCR 0xe000ed0cu
N#define CYFLD_CM0P_VECTCLRACTIVE__OFFSET 0x00000001u
N#define CYFLD_CM0P_VECTCLRACTIVE__SIZE 0x00000001u
N#define CYFLD_CM0P_SYSRESETREQ__OFFSET 0x00000002u
N#define CYFLD_CM0P_SYSRESETREQ__SIZE 0x00000001u
N#define CYFLD_CM0P_ENDIANNESS__OFFSET 0x0000000fu
N#define CYFLD_CM0P_ENDIANNESS__SIZE 0x00000001u
N#define CYFLD_CM0P_VECTKEY__OFFSET 0x00000010u
N#define CYFLD_CM0P_VECTKEY__SIZE 0x00000010u
N#define CYREG_CM0P_SCR 0xe000ed10u
N#define CYFLD_CM0P_SLEEPONEXIT__OFFSET 0x00000001u
N#define CYFLD_CM0P_SLEEPONEXIT__SIZE 0x00000001u
N#define CYFLD_CM0P_SLEEPDEEP__OFFSET 0x00000002u
N#define CYFLD_CM0P_SLEEPDEEP__SIZE 0x00000001u
N#define CYFLD_CM0P_SEVONPEND__OFFSET 0x00000004u
N#define CYFLD_CM0P_SEVONPEND__SIZE 0x00000001u
N#define CYREG_CM0P_CCR 0xe000ed14u
N#define CYFLD_CM0P_UNALIGN_TRP__OFFSET 0x00000003u
N#define CYFLD_CM0P_UNALIGN_TRP__SIZE 0x00000001u
N#define CYFLD_CM0P_STKALIGN__OFFSET 0x00000009u
N#define CYFLD_CM0P_STKALIGN__SIZE 0x00000001u
N#define CYREG_CM0P_SHPR2 0xe000ed1cu
N#define CYFLD_CM0P_PRI_11__OFFSET 0x0000001eu
N#define CYFLD_CM0P_PRI_11__SIZE 0x00000002u
N#define CYREG_CM0P_SHPR3 0xe000ed20u
N#define CYFLD_CM0P_PRI_14__OFFSET 0x00000016u
N#define CYFLD_CM0P_PRI_14__SIZE 0x00000002u
N#define CYFLD_CM0P_PRI_15__OFFSET 0x0000001eu
N#define CYFLD_CM0P_PRI_15__SIZE 0x00000002u
N#define CYREG_CM0P_SHCSR 0xe000ed24u
N#define CYFLD_CM0P_SVCALLPENDED__OFFSET 0x0000000fu
N#define CYFLD_CM0P_SVCALLPENDED__SIZE 0x00000001u
N#define CYREG_CM0P_SCS_PID4 0xe000efd0u
N#define CYREG_CM0P_SCS_PID0 0xe000efe0u
N#define CYREG_CM0P_SCS_PID1 0xe000efe4u
N#define CYREG_CM0P_SCS_PID2 0xe000efe8u
N#define CYREG_CM0P_SCS_PID3 0xe000efecu
N#define CYREG_CM0P_SCS_CID0 0xe000eff0u
N#define CYREG_CM0P_SCS_CID1 0xe000eff4u
N#define CYREG_CM0P_SCS_CID2 0xe000eff8u
N#define CYREG_CM0P_SCS_CID3 0xe000effcu
N#define CYREG_CM0P_ROM_SCS 0xe00ff000u
N#define CYREG_CM0P_ROM_DWT 0xe00ff004u
N#define CYREG_CM0P_ROM_BPU 0xe00ff008u
N#define CYREG_CM0P_ROM_END 0xe00ff00cu
N#define CYREG_CM0P_ROM_CSMT 0xe00fffccu
N#define CYREG_CM0P_ROM_PID4 0xe00fffd0u
N#define CYREG_CM0P_ROM_PID0 0xe00fffe0u
N#define CYREG_CM0P_ROM_PID1 0xe00fffe4u
N#define CYREG_CM0P_ROM_PID2 0xe00fffe8u
N#define CYREG_CM0P_ROM_PID3 0xe00fffecu
N#define CYREG_CM0P_ROM_CID0 0xe00ffff0u
N#define CYREG_CM0P_ROM_CID1 0xe00ffff4u
N#define CYREG_CM0P_ROM_CID2 0xe00ffff8u
N#define CYREG_CM0P_ROM_CID3 0xe00ffffcu
N#define CYDEV_ROMTABLE_BASE 0xf0000000u
N#define CYDEV_ROMTABLE_SIZE 0x00001000u
N#define CYREG_ROMTABLE_ADDR 0xf0000000u
N#define CYFLD_ROMTABLE_PRESENT__OFFSET 0x00000000u
N#define CYFLD_ROMTABLE_PRESENT__SIZE 0x00000001u
N#define CYFLD_ROMTABLE_FORMAT_32BIT__OFFSET 0x00000001u
N#define CYFLD_ROMTABLE_FORMAT_32BIT__SIZE 0x00000001u
N#define CYFLD_ROMTABLE_ADDR_OFFSET__OFFSET 0x0000000cu
N#define CYFLD_ROMTABLE_ADDR_OFFSET__SIZE 0x00000014u
N#define CYREG_ROMTABLE_DID 0xf0000fccu
N#define CYFLD_ROMTABLE_VALUE__OFFSET 0x00000000u
N#define CYFLD_ROMTABLE_VALUE__SIZE 0x00000020u
N#define CYREG_ROMTABLE_PID4 0xf0000fd0u
N#define CYFLD_ROMTABLE_JEP_CONTINUATION__OFFSET 0x00000000u
N#define CYFLD_ROMTABLE_JEP_CONTINUATION__SIZE 0x00000004u
N#define CYFLD_ROMTABLE_COUNT__OFFSET 0x00000004u
N#define CYFLD_ROMTABLE_COUNT__SIZE 0x00000004u
N#define CYREG_ROMTABLE_PID5 0xf0000fd4u
N#define CYREG_ROMTABLE_PID6 0xf0000fd8u
N#define CYREG_ROMTABLE_PID7 0xf0000fdcu
N#define CYREG_ROMTABLE_PID0 0xf0000fe0u
N#define CYFLD_ROMTABLE_PN_MIN__OFFSET 0x00000000u
N#define CYFLD_ROMTABLE_PN_MIN__SIZE 0x00000008u
N#define CYREG_ROMTABLE_PID1 0xf0000fe4u
N#define CYFLD_ROMTABLE_PN_MAJ__OFFSET 0x00000000u
N#define CYFLD_ROMTABLE_PN_MAJ__SIZE 0x00000004u
N#define CYFLD_ROMTABLE_JEPID_MIN__OFFSET 0x00000004u
N#define CYFLD_ROMTABLE_JEPID_MIN__SIZE 0x00000004u
N#define CYREG_ROMTABLE_PID2 0xf0000fe8u
N#define CYFLD_ROMTABLE_JEPID_MAJ__OFFSET 0x00000000u
N#define CYFLD_ROMTABLE_JEPID_MAJ__SIZE 0x00000003u
N#define CYFLD_ROMTABLE_REV__OFFSET 0x00000004u
N#define CYFLD_ROMTABLE_REV__SIZE 0x00000004u
N#define CYREG_ROMTABLE_PID3 0xf0000fecu
N#define CYFLD_ROMTABLE_CM__OFFSET 0x00000000u
N#define CYFLD_ROMTABLE_CM__SIZE 0x00000004u
N#define CYFLD_ROMTABLE_REV_AND__OFFSET 0x00000004u
N#define CYFLD_ROMTABLE_REV_AND__SIZE 0x00000004u
N#define CYREG_ROMTABLE_CID0 0xf0000ff0u
N#define CYREG_ROMTABLE_CID1 0xf0000ff4u
N#define CYREG_ROMTABLE_CID2 0xf0000ff8u
N#define CYREG_ROMTABLE_CID3 0xf0000ffcu
N#define CYDEV_FLS_SECTOR_SIZE 0x00020000u
N#define CYDEV_FLS_ROW_SIZE 0x00000100u
N#endif /* CYDEVICE_TRM_H */
L 20 "Generated_Source\PSoC4\cyfitter.h" 2
N
N/* ADC */
N#define ADC_cy_psoc4_sar__CLOCK_DIV_ID 0x00000043u
N#define ADC_cy_psoc4_sar__SAR_ANA_TRIM CYREG_SAR_ANA_TRIM
N#define ADC_cy_psoc4_sar__SAR_AVG_STAT CYREG_SAR_AVG_STAT
N#define ADC_cy_psoc4_sar__SAR_CHAN_CONFIG00 CYREG_SAR_CHAN_CONFIG0
N#define ADC_cy_psoc4_sar__SAR_CHAN_CONFIG01 CYREG_SAR_CHAN_CONFIG1
N#define ADC_cy_psoc4_sar__SAR_CHAN_CONFIG02 CYREG_SAR_CHAN_CONFIG2
N#define ADC_cy_psoc4_sar__SAR_CHAN_CONFIG03 CYREG_SAR_CHAN_CONFIG3
N#define ADC_cy_psoc4_sar__SAR_CHAN_CONFIG04 CYREG_SAR_CHAN_CONFIG4
N#define ADC_cy_psoc4_sar__SAR_CHAN_CONFIG05 CYREG_SAR_CHAN_CONFIG5
N#define ADC_cy_psoc4_sar__SAR_CHAN_CONFIG06 CYREG_SAR_CHAN_CONFIG6
N#define ADC_cy_psoc4_sar__SAR_CHAN_CONFIG07 CYREG_SAR_CHAN_CONFIG7
N#define ADC_cy_psoc4_sar__SAR_CHAN_CONFIG08 CYREG_SAR_CHAN_CONFIG8
N#define ADC_cy_psoc4_sar__SAR_CHAN_CONFIG09 CYREG_SAR_CHAN_CONFIG9
N#define ADC_cy_psoc4_sar__SAR_CHAN_CONFIG10 CYREG_SAR_CHAN_CONFIG10
N#define ADC_cy_psoc4_sar__SAR_CHAN_CONFIG11 CYREG_SAR_CHAN_CONFIG11
N#define ADC_cy_psoc4_sar__SAR_CHAN_CONFIG12 CYREG_SAR_CHAN_CONFIG12
N#define ADC_cy_psoc4_sar__SAR_CHAN_CONFIG13 CYREG_SAR_CHAN_CONFIG13
N#define ADC_cy_psoc4_sar__SAR_CHAN_CONFIG14 CYREG_SAR_CHAN_CONFIG14
N#define ADC_cy_psoc4_sar__SAR_CHAN_CONFIG15 CYREG_SAR_CHAN_CONFIG15
N#define ADC_cy_psoc4_sar__SAR_CHAN_EN CYREG_SAR_CHAN_EN
N#define ADC_cy_psoc4_sar__SAR_CHAN_RESULT_VALID CYREG_SAR_CHAN_RESULT_VALID
N#define ADC_cy_psoc4_sar__SAR_CHAN_RESULT00 CYREG_SAR_CHAN_RESULT0
N#define ADC_cy_psoc4_sar__SAR_CHAN_RESULT01 CYREG_SAR_CHAN_RESULT1
N#define ADC_cy_psoc4_sar__SAR_CHAN_RESULT02 CYREG_SAR_CHAN_RESULT2
N#define ADC_cy_psoc4_sar__SAR_CHAN_RESULT03 CYREG_SAR_CHAN_RESULT3
N#define ADC_cy_psoc4_sar__SAR_CHAN_RESULT04 CYREG_SAR_CHAN_RESULT4
N#define ADC_cy_psoc4_sar__SAR_CHAN_RESULT05 CYREG_SAR_CHAN_RESULT5
N#define ADC_cy_psoc4_sar__SAR_CHAN_RESULT06 CYREG_SAR_CHAN_RESULT6
N#define ADC_cy_psoc4_sar__SAR_CHAN_RESULT07 CYREG_SAR_CHAN_RESULT7
N#define ADC_cy_psoc4_sar__SAR_CHAN_RESULT08 CYREG_SAR_CHAN_RESULT8
N#define ADC_cy_psoc4_sar__SAR_CHAN_RESULT09 CYREG_SAR_CHAN_RESULT9
N#define ADC_cy_psoc4_sar__SAR_CHAN_RESULT10 CYREG_SAR_CHAN_RESULT10
N#define ADC_cy_psoc4_sar__SAR_CHAN_RESULT11 CYREG_SAR_CHAN_RESULT11
N#define ADC_cy_psoc4_sar__SAR_CHAN_RESULT12 CYREG_SAR_CHAN_RESULT12
N#define ADC_cy_psoc4_sar__SAR_CHAN_RESULT13 CYREG_SAR_CHAN_RESULT13
N#define ADC_cy_psoc4_sar__SAR_CHAN_RESULT14 CYREG_SAR_CHAN_RESULT14
N#define ADC_cy_psoc4_sar__SAR_CHAN_RESULT15 CYREG_SAR_CHAN_RESULT15
N#define ADC_cy_psoc4_sar__SAR_CHAN_WORK_VALID CYREG_SAR_CHAN_WORK_VALID
N#define ADC_cy_psoc4_sar__SAR_CHAN_WORK00 CYREG_SAR_CHAN_WORK0
N#define ADC_cy_psoc4_sar__SAR_CHAN_WORK01 CYREG_SAR_CHAN_WORK1
N#define ADC_cy_psoc4_sar__SAR_CHAN_WORK02 CYREG_SAR_CHAN_WORK2
N#define ADC_cy_psoc4_sar__SAR_CHAN_WORK03 CYREG_SAR_CHAN_WORK3
N#define ADC_cy_psoc4_sar__SAR_CHAN_WORK04 CYREG_SAR_CHAN_WORK4
N#define ADC_cy_psoc4_sar__SAR_CHAN_WORK05 CYREG_SAR_CHAN_WORK5
N#define ADC_cy_psoc4_sar__SAR_CHAN_WORK06 CYREG_SAR_CHAN_WORK6
N#define ADC_cy_psoc4_sar__SAR_CHAN_WORK07 CYREG_SAR_CHAN_WORK7
N#define ADC_cy_psoc4_sar__SAR_CHAN_WORK08 CYREG_SAR_CHAN_WORK8
N#define ADC_cy_psoc4_sar__SAR_CHAN_WORK09 CYREG_SAR_CHAN_WORK9
N#define ADC_cy_psoc4_sar__SAR_CHAN_WORK10 CYREG_SAR_CHAN_WORK10
N#define ADC_cy_psoc4_sar__SAR_CHAN_WORK11 CYREG_SAR_CHAN_WORK11
N#define ADC_cy_psoc4_sar__SAR_CHAN_WORK12 CYREG_SAR_CHAN_WORK12
N#define ADC_cy_psoc4_sar__SAR_CHAN_WORK13 CYREG_SAR_CHAN_WORK13
N#define ADC_cy_psoc4_sar__SAR_CHAN_WORK14 CYREG_SAR_CHAN_WORK14
N#define ADC_cy_psoc4_sar__SAR_CHAN_WORK15 CYREG_SAR_CHAN_WORK15
N#define ADC_cy_psoc4_sar__SAR_CTRL CYREG_SAR_CTRL
N#define ADC_cy_psoc4_sar__SAR_DFT_CTRL CYREG_SAR_DFT_CTRL
N#define ADC_cy_psoc4_sar__SAR_INTR CYREG_SAR_INTR
N#define ADC_cy_psoc4_sar__SAR_INTR_CAUSE CYREG_SAR_INTR_CAUSE
N#define ADC_cy_psoc4_sar__SAR_INTR_MASK CYREG_SAR_INTR_MASK
N#define ADC_cy_psoc4_sar__SAR_INTR_MASKED CYREG_SAR_INTR_MASKED
N#define ADC_cy_psoc4_sar__SAR_INTR_SET CYREG_SAR_INTR_SET
N#define ADC_cy_psoc4_sar__SAR_MUX_SWITCH_CLEAR0 CYREG_SAR_MUX_SWITCH_CLEAR0
N#define ADC_cy_psoc4_sar__SAR_MUX_SWITCH_CLEAR1 CYREG_SAR_MUX_SWITCH_CLEAR1
N#define ADC_cy_psoc4_sar__SAR_MUX_SWITCH_HW_CTRL CYREG_SAR_MUX_SWITCH_HW_CTRL
N#define ADC_cy_psoc4_sar__SAR_MUX_SWITCH_STATUS CYREG_SAR_MUX_SWITCH_STATUS
N#define ADC_cy_psoc4_sar__SAR_MUX_SWITCH0 CYREG_SAR_MUX_SWITCH0
N#define ADC_cy_psoc4_sar__SAR_MUX_SWITCH1 CYREG_SAR_MUX_SWITCH1
N#define ADC_cy_psoc4_sar__SAR_NUMBER 0u
N#define ADC_cy_psoc4_sar__SAR_PUMP_CTRL CYREG_SAR_PUMP_CTRL
N#define ADC_cy_psoc4_sar__SAR_RANGE_COND CYREG_SAR_RANGE_COND
N#define ADC_cy_psoc4_sar__SAR_RANGE_INTR CYREG_SAR_RANGE_INTR
N#define ADC_cy_psoc4_sar__SAR_RANGE_INTR_MASK CYREG_SAR_RANGE_INTR_MASK
N#define ADC_cy_psoc4_sar__SAR_RANGE_INTR_MASKED CYREG_SAR_RANGE_INTR_MASKED
N#define ADC_cy_psoc4_sar__SAR_RANGE_INTR_SET CYREG_SAR_RANGE_INTR_SET
N#define ADC_cy_psoc4_sar__SAR_RANGE_THRES CYREG_SAR_RANGE_THRES
N#define ADC_cy_psoc4_sar__SAR_SAMPLE_CTRL CYREG_SAR_SAMPLE_CTRL
N#define ADC_cy_psoc4_sar__SAR_SAMPLE_TIME01 CYREG_SAR_SAMPLE_TIME01
N#define ADC_cy_psoc4_sar__SAR_SAMPLE_TIME23 CYREG_SAR_SAMPLE_TIME23
N#define ADC_cy_psoc4_sar__SAR_SATURATE_INTR CYREG_SAR_SATURATE_INTR
N#define ADC_cy_psoc4_sar__SAR_SATURATE_INTR_MASK CYREG_SAR_SATURATE_INTR_MASK
N#define ADC_cy_psoc4_sar__SAR_SATURATE_INTR_MASKED CYREG_SAR_SATURATE_INTR_MASKED
N#define ADC_cy_psoc4_sar__SAR_SATURATE_INTR_SET CYREG_SAR_SATURATE_INTR_SET
N#define ADC_cy_psoc4_sar__SAR_START_CTRL CYREG_SAR_START_CTRL
N#define ADC_cy_psoc4_sar__SAR_STATUS CYREG_SAR_STATUS
N#define ADC_cy_psoc4_sar__SAR_WOUNDING CYREG_SAR_WOUNDING
N#define ADC_cy_psoc4_sarmux_8__CH_0_PIN 3
N#define ADC_cy_psoc4_sarmux_8__CH_0_PORT 1
N#define ADC_cy_psoc4_sarmux_8__CH_1_PIN 6
N#define ADC_cy_psoc4_sarmux_8__CH_1_PORT 0
N#define ADC_cy_psoc4_sarmux_8__CH_2_PIN 2
N#define ADC_cy_psoc4_sarmux_8__CH_2_PORT 1
N#define ADC_cy_psoc4_sarmux_8__SAR_AVG_STAT CYREG_SAR_AVG_STAT
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_CONFIG00 CYREG_SAR_CHAN_CONFIG0
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_CONFIG01 CYREG_SAR_CHAN_CONFIG1
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_CONFIG02 CYREG_SAR_CHAN_CONFIG2
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_CONFIG03 CYREG_SAR_CHAN_CONFIG3
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_CONFIG04 CYREG_SAR_CHAN_CONFIG4
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_CONFIG05 CYREG_SAR_CHAN_CONFIG5
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_CONFIG06 CYREG_SAR_CHAN_CONFIG6
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_CONFIG07 CYREG_SAR_CHAN_CONFIG7
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_CONFIG08 CYREG_SAR_CHAN_CONFIG8
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_CONFIG09 CYREG_SAR_CHAN_CONFIG9
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_CONFIG10 CYREG_SAR_CHAN_CONFIG10
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_CONFIG11 CYREG_SAR_CHAN_CONFIG11
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_CONFIG12 CYREG_SAR_CHAN_CONFIG12
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_CONFIG13 CYREG_SAR_CHAN_CONFIG13
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_CONFIG14 CYREG_SAR_CHAN_CONFIG14
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_CONFIG15 CYREG_SAR_CHAN_CONFIG15
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_EN CYREG_SAR_CHAN_EN
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_RESULT_VALID CYREG_SAR_CHAN_RESULT_VALID
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_RESULT00 CYREG_SAR_CHAN_RESULT0
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_RESULT01 CYREG_SAR_CHAN_RESULT1
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_RESULT02 CYREG_SAR_CHAN_RESULT2
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_RESULT03 CYREG_SAR_CHAN_RESULT3
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_RESULT04 CYREG_SAR_CHAN_RESULT4
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_RESULT05 CYREG_SAR_CHAN_RESULT5
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_RESULT06 CYREG_SAR_CHAN_RESULT6
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_RESULT07 CYREG_SAR_CHAN_RESULT7
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_RESULT08 CYREG_SAR_CHAN_RESULT8
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_RESULT09 CYREG_SAR_CHAN_RESULT9
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_RESULT10 CYREG_SAR_CHAN_RESULT10
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_RESULT11 CYREG_SAR_CHAN_RESULT11
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_RESULT12 CYREG_SAR_CHAN_RESULT12
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_RESULT13 CYREG_SAR_CHAN_RESULT13
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_RESULT14 CYREG_SAR_CHAN_RESULT14
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_RESULT15 CYREG_SAR_CHAN_RESULT15
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_WORK_VALID CYREG_SAR_CHAN_WORK_VALID
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_WORK00 CYREG_SAR_CHAN_WORK0
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_WORK01 CYREG_SAR_CHAN_WORK1
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_WORK02 CYREG_SAR_CHAN_WORK2
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_WORK03 CYREG_SAR_CHAN_WORK3
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_WORK04 CYREG_SAR_CHAN_WORK4
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_WORK05 CYREG_SAR_CHAN_WORK5
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_WORK06 CYREG_SAR_CHAN_WORK6
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_WORK07 CYREG_SAR_CHAN_WORK7
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_WORK08 CYREG_SAR_CHAN_WORK8
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_WORK09 CYREG_SAR_CHAN_WORK9
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_WORK10 CYREG_SAR_CHAN_WORK10
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_WORK11 CYREG_SAR_CHAN_WORK11
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_WORK12 CYREG_SAR_CHAN_WORK12
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_WORK13 CYREG_SAR_CHAN_WORK13
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_WORK14 CYREG_SAR_CHAN_WORK14
N#define ADC_cy_psoc4_sarmux_8__SAR_CHAN_WORK15 CYREG_SAR_CHAN_WORK15
N#define ADC_cy_psoc4_sarmux_8__SAR_INJ_CHAN_CONFIG CYREG_SAR_INJ_CHAN_CONFIG
N#define ADC_cy_psoc4_sarmux_8__SAR_INJ_RESULT CYREG_SAR_INJ_RESULT
N#define ADC_cy_psoc4_sarmux_8__SAR_MUX_SWITCH_CLEAR0 CYREG_SAR_MUX_SWITCH_CLEAR0
N#define ADC_cy_psoc4_sarmux_8__SAR_MUX_SWITCH_CLEAR1 CYREG_SAR_MUX_SWITCH_CLEAR1
N#define ADC_cy_psoc4_sarmux_8__SAR_MUX_SWITCH_HW_CTRL CYREG_SAR_MUX_SWITCH_HW_CTRL
N#define ADC_cy_psoc4_sarmux_8__SAR_MUX_SWITCH_STATUS CYREG_SAR_MUX_SWITCH_STATUS
N#define ADC_cy_psoc4_sarmux_8__SAR_MUX_SWITCH0 CYREG_SAR_MUX_SWITCH0
N#define ADC_cy_psoc4_sarmux_8__SAR_MUX_SWITCH1 CYREG_SAR_MUX_SWITCH1
N#define ADC_cy_psoc4_sarmux_8__SAR_START_CTRL CYREG_SAR_START_CTRL
N#define ADC_cy_psoc4_sarmux_8__VNEG0 0
N#define ADC_intClock__CTRL_REGISTER CYREG_PERI_PCLK_CTL18
N#define ADC_intClock__DIV_ID 0x00000043u
N#define ADC_intClock__DIV_REGISTER CYREG_PERI_DIV_16_CTL3
N#define ADC_intClock__PA_DIV_ID 0x000000FFu
N#define ADC_IRQ__INTC_CLR_EN_REG CYREG_CM0P_ICER
N#define ADC_IRQ__INTC_CLR_PD_REG CYREG_CM0P_ICPR
N#define ADC_IRQ__INTC_MASK 0x2000000u
N#define ADC_IRQ__INTC_NUMBER 25u
N#define ADC_IRQ__INTC_PRIOR_MASK 0xC000u
N#define ADC_IRQ__INTC_PRIOR_NUM 3u
N#define ADC_IRQ__INTC_PRIOR_REG CYREG_CM0P_IPR6
N#define ADC_IRQ__INTC_SET_EN_REG CYREG_CM0P_ISER
N#define ADC_IRQ__INTC_SET_PD_REG CYREG_CM0P_ISPR
N
N/* TEST */
N#define TEST__0__DR CYREG_GPIO_PRT0_DR
N#define TEST__0__DR_CLR CYREG_GPIO_PRT0_DR_CLR
N#define TEST__0__DR_INV CYREG_GPIO_PRT0_DR_INV
N#define TEST__0__DR_SET CYREG_GPIO_PRT0_DR_SET
N#define TEST__0__HSIOM CYREG_HSIOM_PORT_SEL0
N#define TEST__0__HSIOM_MASK 0xF0000000u
N#define TEST__0__HSIOM_SHIFT 28u
N#define TEST__0__INTCFG CYREG_GPIO_PRT0_INTR_CFG
N#define TEST__0__INTR CYREG_GPIO_PRT0_INTR
N#define TEST__0__INTR_CFG CYREG_GPIO_PRT0_INTR_CFG
N#define TEST__0__INTSTAT CYREG_GPIO_PRT0_INTR
N#define TEST__0__MASK 0x80u
N#define TEST__0__PC CYREG_GPIO_PRT0_PC
N#define TEST__0__PC2 CYREG_GPIO_PRT0_PC2
N#define TEST__0__PORT 0u
N#define TEST__0__PS CYREG_GPIO_PRT0_PS
N#define TEST__0__SHIFT 7u
N#define TEST__DR CYREG_GPIO_PRT0_DR
N#define TEST__DR_CLR CYREG_GPIO_PRT0_DR_CLR
N#define TEST__DR_INV CYREG_GPIO_PRT0_DR_INV
N#define TEST__DR_SET CYREG_GPIO_PRT0_DR_SET
N#define TEST__INTCFG CYREG_GPIO_PRT0_INTR_CFG
N#define TEST__INTR CYREG_GPIO_PRT0_INTR
N#define TEST__INTR_CFG CYREG_GPIO_PRT0_INTR_CFG
N#define TEST__INTSTAT CYREG_GPIO_PRT0_INTR
N#define TEST__MASK 0x80u
N#define TEST__PC CYREG_GPIO_PRT0_PC
N#define TEST__PC2 CYREG_GPIO_PRT0_PC2
N#define TEST__PORT 0u
N#define TEST__PS CYREG_GPIO_PRT0_PS
N#define TEST__SHIFT 7u
N
N/* isr_1 */
N#define isr_1__INTC_CLR_EN_REG CYREG_CM0P_ICER
N#define isr_1__INTC_CLR_PD_REG CYREG_CM0P_ICPR
N#define isr_1__INTC_MASK 0x01u
N#define isr_1__INTC_NUMBER 0u
N#define isr_1__INTC_PRIOR_MASK 0xC0u
N#define isr_1__INTC_PRIOR_NUM 3u
N#define isr_1__INTC_PRIOR_REG CYREG_CM0P_IPR0
N#define isr_1__INTC_SET_EN_REG CYREG_CM0P_ISER
N#define isr_1__INTC_SET_PD_REG CYREG_CM0P_ISPR
N
N/* isr_2 */
N#define isr_2__INTC_CLR_EN_REG CYREG_CM0P_ICER
N#define isr_2__INTC_CLR_PD_REG CYREG_CM0P_ICPR
N#define isr_2__INTC_MASK 0x02u
N#define isr_2__INTC_NUMBER 1u
N#define isr_2__INTC_PRIOR_MASK 0xC000u
N#define isr_2__INTC_PRIOR_NUM 3u
N#define isr_2__INTC_PRIOR_REG CYREG_CM0P_IPR0
N#define isr_2__INTC_SET_EN_REG CYREG_CM0P_ISER
N#define isr_2__INTC_SET_PD_REG CYREG_CM0P_ISPR
N
N/* I2C_ST */
N#define I2C_ST__0__DR CYREG_GPIO_PRT5_DR
N#define I2C_ST__0__DR_CLR CYREG_GPIO_PRT5_DR_CLR
N#define I2C_ST__0__DR_INV CYREG_GPIO_PRT5_DR_INV
N#define I2C_ST__0__DR_SET CYREG_GPIO_PRT5_DR_SET
N#define I2C_ST__0__HSIOM CYREG_HSIOM_PORT_SEL5
N#define I2C_ST__0__HSIOM_MASK 0xF0000000u
N#define I2C_ST__0__HSIOM_SHIFT 28u
N#define I2C_ST__0__INTCFG CYREG_GPIO_PRT5_INTR_CFG
N#define I2C_ST__0__INTR CYREG_GPIO_PRT5_INTR
N#define I2C_ST__0__INTR_CFG CYREG_GPIO_PRT5_INTR_CFG
N#define I2C_ST__0__INTSTAT CYREG_GPIO_PRT5_INTR
N#define I2C_ST__0__MASK 0x80u
N#define I2C_ST__0__PC CYREG_GPIO_PRT5_PC
N#define I2C_ST__0__PC2 CYREG_GPIO_PRT5_PC2
N#define I2C_ST__0__PORT 5u
N#define I2C_ST__0__PS CYREG_GPIO_PRT5_PS
N#define I2C_ST__0__SHIFT 7u
N#define I2C_ST__DR CYREG_GPIO_PRT5_DR
N#define I2C_ST__DR_CLR CYREG_GPIO_PRT5_DR_CLR
N#define I2C_ST__DR_INV CYREG_GPIO_PRT5_DR_INV
N#define I2C_ST__DR_SET CYREG_GPIO_PRT5_DR_SET
N#define I2C_ST__INTCFG CYREG_GPIO_PRT5_INTR_CFG
N#define I2C_ST__INTR CYREG_GPIO_PRT5_INTR
N#define I2C_ST__INTR_CFG CYREG_GPIO_PRT5_INTR_CFG
N#define I2C_ST__INTSTAT CYREG_GPIO_PRT5_INTR
N#define I2C_ST__MASK 0x80u
N#define I2C_ST__PC CYREG_GPIO_PRT5_PC
N#define I2C_ST__PC2 CYREG_GPIO_PRT5_PC2
N#define I2C_ST__PORT 5u
N#define I2C_ST__PS CYREG_GPIO_PRT5_PS
N#define I2C_ST__SHIFT 7u
N
N/* RF_ADC */
N#define RF_ADC__0__DR CYREG_GPIO_PRT2_DR
N#define RF_ADC__0__DR_CLR CYREG_GPIO_PRT2_DR_CLR
N#define RF_ADC__0__DR_INV CYREG_GPIO_PRT2_DR_INV
N#define RF_ADC__0__DR_SET CYREG_GPIO_PRT2_DR_SET
N#define RF_ADC__0__HSIOM CYREG_HSIOM_PORT_SEL2
N#define RF_ADC__0__HSIOM_MASK 0xF0000000u
N#define RF_ADC__0__HSIOM_SHIFT 28u
N#define RF_ADC__0__INTCFG CYREG_GPIO_PRT2_INTR_CFG
N#define RF_ADC__0__INTR CYREG_GPIO_PRT2_INTR
N#define RF_ADC__0__INTR_CFG CYREG_GPIO_PRT2_INTR_CFG
N#define RF_ADC__0__INTSTAT CYREG_GPIO_PRT2_INTR
N#define RF_ADC__0__MASK 0x80u
N#define RF_ADC__0__PC CYREG_GPIO_PRT2_PC
N#define RF_ADC__0__PC2 CYREG_GPIO_PRT2_PC2
N#define RF_ADC__0__PORT 2u
N#define RF_ADC__0__PS CYREG_GPIO_PRT2_PS
N#define RF_ADC__0__SHIFT 7u
N#define RF_ADC__DR CYREG_GPIO_PRT2_DR
N#define RF_ADC__DR_CLR CYREG_GPIO_PRT2_DR_CLR
N#define RF_ADC__DR_INV CYREG_GPIO_PRT2_DR_INV
N#define RF_ADC__DR_SET CYREG_GPIO_PRT2_DR_SET
N#define RF_ADC__INTCFG CYREG_GPIO_PRT2_INTR_CFG
N#define RF_ADC__INTR CYREG_GPIO_PRT2_INTR
N#define RF_ADC__INTR_CFG CYREG_GPIO_PRT2_INTR_CFG
N#define RF_ADC__INTSTAT CYREG_GPIO_PRT2_INTR
N#define RF_ADC__MASK 0x80u
N#define RF_ADC__PC CYREG_GPIO_PRT2_PC
N#define RF_ADC__PC2 CYREG_GPIO_PRT2_PC2
N#define RF_ADC__PORT 2u
N#define RF_ADC__PS CYREG_GPIO_PRT2_PS
N#define RF_ADC__SHIFT 7u
N
N/* BAT_ADC */
N#define BAT_ADC__0__DR CYREG_GPIO_PRT2_DR
N#define BAT_ADC__0__DR_CLR CYREG_GPIO_PRT2_DR_CLR
N#define BAT_ADC__0__DR_INV CYREG_GPIO_PRT2_DR_INV
N#define BAT_ADC__0__DR_SET CYREG_GPIO_PRT2_DR_SET
N#define BAT_ADC__0__HSIOM CYREG_HSIOM_PORT_SEL2
N#define BAT_ADC__0__HSIOM_MASK 0x00F00000u
N#define BAT_ADC__0__HSIOM_SHIFT 20u
N#define BAT_ADC__0__INTCFG CYREG_GPIO_PRT2_INTR_CFG
N#define BAT_ADC__0__INTR CYREG_GPIO_PRT2_INTR
N#define BAT_ADC__0__INTR_CFG CYREG_GPIO_PRT2_INTR_CFG
N#define BAT_ADC__0__INTSTAT CYREG_GPIO_PRT2_INTR
N#define BAT_ADC__0__MASK 0x20u
N#define BAT_ADC__0__PC CYREG_GPIO_PRT2_PC
N#define BAT_ADC__0__PC2 CYREG_GPIO_PRT2_PC2
N#define BAT_ADC__0__PORT 2u
N#define BAT_ADC__0__PS CYREG_GPIO_PRT2_PS
N#define BAT_ADC__0__SHIFT 5u
N#define BAT_ADC__DR CYREG_GPIO_PRT2_DR
N#define BAT_ADC__DR_CLR CYREG_GPIO_PRT2_DR_CLR
N#define BAT_ADC__DR_INV CYREG_GPIO_PRT2_DR_INV
N#define BAT_ADC__DR_SET CYREG_GPIO_PRT2_DR_SET
N#define BAT_ADC__INTCFG CYREG_GPIO_PRT2_INTR_CFG
N#define BAT_ADC__INTR CYREG_GPIO_PRT2_INTR
N#define BAT_ADC__INTR_CFG CYREG_GPIO_PRT2_INTR_CFG
N#define BAT_ADC__INTSTAT CYREG_GPIO_PRT2_INTR
N#define BAT_ADC__MASK 0x20u
N#define BAT_ADC__PC CYREG_GPIO_PRT2_PC
N#define BAT_ADC__PC2 CYREG_GPIO_PRT2_PC2
N#define BAT_ADC__PORT 2u
N#define BAT_ADC__PS CYREG_GPIO_PRT2_PS
N#define BAT_ADC__SHIFT 5u
N
N/* I2C_SCL */
N#define I2C_SCL__0__DR CYREG_GPIO_PRT7_DR
N#define I2C_SCL__0__DR_CLR CYREG_GPIO_PRT7_DR_CLR
N#define I2C_SCL__0__DR_INV CYREG_GPIO_PRT7_DR_INV
N#define I2C_SCL__0__DR_SET CYREG_GPIO_PRT7_DR_SET
N#define I2C_SCL__0__HSIOM CYREG_HSIOM_PORT_SEL7
N#define I2C_SCL__0__HSIOM_MASK 0x000000F0u
N#define I2C_SCL__0__HSIOM_SHIFT 4u
N#define I2C_SCL__0__INTCFG CYREG_GPIO_PRT7_INTR_CFG
N#define I2C_SCL__0__INTR CYREG_GPIO_PRT7_INTR
N#define I2C_SCL__0__INTR_CFG CYREG_GPIO_PRT7_INTR_CFG
N#define I2C_SCL__0__INTSTAT CYREG_GPIO_PRT7_INTR
N#define I2C_SCL__0__MASK 0x02u
N#define I2C_SCL__0__PC CYREG_GPIO_PRT7_PC
N#define I2C_SCL__0__PC2 CYREG_GPIO_PRT7_PC2
N#define I2C_SCL__0__PORT 7u
N#define I2C_SCL__0__PS CYREG_GPIO_PRT7_PS
N#define I2C_SCL__0__SHIFT 1u
N#define I2C_SCL__DR CYREG_GPIO_PRT7_DR
N#define I2C_SCL__DR_CLR CYREG_GPIO_PRT7_DR_CLR
N#define I2C_SCL__DR_INV CYREG_GPIO_PRT7_DR_INV
N#define I2C_SCL__DR_SET CYREG_GPIO_PRT7_DR_SET
N#define I2C_SCL__INTCFG CYREG_GPIO_PRT7_INTR_CFG
N#define I2C_SCL__INTR CYREG_GPIO_PRT7_INTR
N#define I2C_SCL__INTR_CFG CYREG_GPIO_PRT7_INTR_CFG
N#define I2C_SCL__INTSTAT CYREG_GPIO_PRT7_INTR
N#define I2C_SCL__MASK 0x02u
N#define I2C_SCL__PC CYREG_GPIO_PRT7_PC
N#define I2C_SCL__PC2 CYREG_GPIO_PRT7_PC2
N#define I2C_SCL__PORT 7u
N#define I2C_SCL__PS CYREG_GPIO_PRT7_PS
N#define I2C_SCL__SHIFT 1u
N
N/* I2C_SDA */
N#define I2C_SDA__0__DR CYREG_GPIO_PRT7_DR
N#define I2C_SDA__0__DR_CLR CYREG_GPIO_PRT7_DR_CLR
N#define I2C_SDA__0__DR_INV CYREG_GPIO_PRT7_DR_INV
N#define I2C_SDA__0__DR_SET CYREG_GPIO_PRT7_DR_SET
N#define I2C_SDA__0__HSIOM CYREG_HSIOM_PORT_SEL7
N#define I2C_SDA__0__HSIOM_MASK 0x0000000Fu
N#define I2C_SDA__0__HSIOM_SHIFT 0u
N#define I2C_SDA__0__INTCFG CYREG_GPIO_PRT7_INTR_CFG
N#define I2C_SDA__0__INTR CYREG_GPIO_PRT7_INTR
N#define I2C_SDA__0__INTR_CFG CYREG_GPIO_PRT7_INTR_CFG
N#define I2C_SDA__0__INTSTAT CYREG_GPIO_PRT7_INTR
N#define I2C_SDA__0__MASK 0x01u
N#define I2C_SDA__0__PC CYREG_GPIO_PRT7_PC
N#define I2C_SDA__0__PC2 CYREG_GPIO_PRT7_PC2
N#define I2C_SDA__0__PORT 7u
N#define I2C_SDA__0__PS CYREG_GPIO_PRT7_PS
N#define I2C_SDA__0__SHIFT 0u
N#define I2C_SDA__DR CYREG_GPIO_PRT7_DR
N#define I2C_SDA__DR_CLR CYREG_GPIO_PRT7_DR_CLR
N#define I2C_SDA__DR_INV CYREG_GPIO_PRT7_DR_INV
N#define I2C_SDA__DR_SET CYREG_GPIO_PRT7_DR_SET
N#define I2C_SDA__INTCFG CYREG_GPIO_PRT7_INTR_CFG
N#define I2C_SDA__INTR CYREG_GPIO_PRT7_INTR
N#define I2C_SDA__INTR_CFG CYREG_GPIO_PRT7_INTR_CFG
N#define I2C_SDA__INTSTAT CYREG_GPIO_PRT7_INTR
N#define I2C_SDA__MASK 0x01u
N#define I2C_SDA__PC CYREG_GPIO_PRT7_PC
N#define I2C_SDA__PC2 CYREG_GPIO_PRT7_PC2
N#define I2C_SDA__PORT 7u
N#define I2C_SDA__PS CYREG_GPIO_PRT7_PS
N#define I2C_SDA__SHIFT 0u
N
N/* OLED_DC */
N#define OLED_DC__0__DR CYREG_GPIO_PRT5_DR
N#define OLED_DC__0__DR_CLR CYREG_GPIO_PRT5_DR_CLR
N#define OLED_DC__0__DR_INV CYREG_GPIO_PRT5_DR_INV
N#define OLED_DC__0__DR_SET CYREG_GPIO_PRT5_DR_SET
N#define OLED_DC__0__HSIOM CYREG_HSIOM_PORT_SEL5
N#define OLED_DC__0__HSIOM_MASK 0x0000F000u
N#define OLED_DC__0__HSIOM_SHIFT 12u
N#define OLED_DC__0__INTCFG CYREG_GPIO_PRT5_INTR_CFG
N#define OLED_DC__0__INTR CYREG_GPIO_PRT5_INTR
N#define OLED_DC__0__INTR_CFG CYREG_GPIO_PRT5_INTR_CFG
N#define OLED_DC__0__INTSTAT CYREG_GPIO_PRT5_INTR
N#define OLED_DC__0__MASK 0x08u
N#define OLED_DC__0__PC CYREG_GPIO_PRT5_PC
N#define OLED_DC__0__PC2 CYREG_GPIO_PRT5_PC2
N#define OLED_DC__0__PORT 5u
N#define OLED_DC__0__PS CYREG_GPIO_PRT5_PS
N#define OLED_DC__0__SHIFT 3u
N#define OLED_DC__DR CYREG_GPIO_PRT5_DR
N#define OLED_DC__DR_CLR CYREG_GPIO_PRT5_DR_CLR
N#define OLED_DC__DR_INV CYREG_GPIO_PRT5_DR_INV
N#define OLED_DC__DR_SET CYREG_GPIO_PRT5_DR_SET
N#define OLED_DC__INTCFG CYREG_GPIO_PRT5_INTR_CFG
N#define OLED_DC__INTR CYREG_GPIO_PRT5_INTR
N#define OLED_DC__INTR_CFG CYREG_GPIO_PRT5_INTR_CFG
N#define OLED_DC__INTSTAT CYREG_GPIO_PRT5_INTR
N#define OLED_DC__MASK 0x08u
N#define OLED_DC__PC CYREG_GPIO_PRT5_PC
N#define OLED_DC__PC2 CYREG_GPIO_PRT5_PC2
N#define OLED_DC__PORT 5u
N#define OLED_DC__PS CYREG_GPIO_PRT5_PS
N#define OLED_DC__SHIFT 3u
N
N/* OP1_INT */
N#define OP1_INT__0__DR CYREG_GPIO_PRT0_DR
N#define OP1_INT__0__DR_CLR CYREG_GPIO_PRT0_DR_CLR
N#define OP1_INT__0__DR_INV CYREG_GPIO_PRT0_DR_INV
N#define OP1_INT__0__DR_SET CYREG_GPIO_PRT0_DR_SET
N#define OP1_INT__0__HSIOM CYREG_HSIOM_PORT_SEL0
N#define OP1_INT__0__HSIOM_MASK 0x0F000000u
N#define OP1_INT__0__HSIOM_SHIFT 24u
N#define OP1_INT__0__INTCFG CYREG_GPIO_PRT0_INTR_CFG
N#define OP1_INT__0__INTR CYREG_GPIO_PRT0_INTR
N#define OP1_INT__0__INTR_CFG CYREG_GPIO_PRT0_INTR_CFG
N#define OP1_INT__0__INTSTAT CYREG_GPIO_PRT0_INTR
N#define OP1_INT__0__MASK 0x40u
N#define OP1_INT__0__PC CYREG_GPIO_PRT0_PC
N#define OP1_INT__0__PC2 CYREG_GPIO_PRT0_PC2
N#define OP1_INT__0__PORT 0u
N#define OP1_INT__0__PS CYREG_GPIO_PRT0_PS
N#define OP1_INT__0__SHIFT 6u
N#define OP1_INT__DR CYREG_GPIO_PRT0_DR
N#define OP1_INT__DR_CLR CYREG_GPIO_PRT0_DR_CLR
N#define OP1_INT__DR_INV CYREG_GPIO_PRT0_DR_INV
N#define OP1_INT__DR_SET CYREG_GPIO_PRT0_DR_SET
N#define OP1_INT__INTCFG CYREG_GPIO_PRT0_INTR_CFG
N#define OP1_INT__INTR CYREG_GPIO_PRT0_INTR
N#define OP1_INT__INTR_CFG CYREG_GPIO_PRT0_INTR_CFG
N#define OP1_INT__INTSTAT CYREG_GPIO_PRT0_INTR
N#define OP1_INT__MASK 0x40u
N#define OP1_INT__PC CYREG_GPIO_PRT0_PC
N#define OP1_INT__PC2 CYREG_GPIO_PRT0_PC2
N#define OP1_INT__PORT 0u
N#define OP1_INT__PS CYREG_GPIO_PRT0_PS
N#define OP1_INT__SHIFT 6u
N
N/* OP3_INT */
N#define OP3_INT__0__DR CYREG_GPIO_PRT5_DR
N#define OP3_INT__0__DR_CLR CYREG_GPIO_PRT5_DR_CLR
N#define OP3_INT__0__DR_INV CYREG_GPIO_PRT5_DR_INV
N#define OP3_INT__0__DR_SET CYREG_GPIO_PRT5_DR_SET
N#define OP3_INT__0__HSIOM CYREG_HSIOM_PORT_SEL5
N#define OP3_INT__0__HSIOM_MASK 0x00000F00u
N#define OP3_INT__0__HSIOM_SHIFT 8u
N#define OP3_INT__0__INTCFG CYREG_GPIO_PRT5_INTR_CFG
N#define OP3_INT__0__INTR CYREG_GPIO_PRT5_INTR
N#define OP3_INT__0__INTR_CFG CYREG_GPIO_PRT5_INTR_CFG
N#define OP3_INT__0__INTSTAT CYREG_GPIO_PRT5_INTR
N#define OP3_INT__0__MASK 0x04u
N#define OP3_INT__0__PC CYREG_GPIO_PRT5_PC
N#define OP3_INT__0__PC2 CYREG_GPIO_PRT5_PC2
N#define OP3_INT__0__PORT 5u
N#define OP3_INT__0__PS CYREG_GPIO_PRT5_PS
N#define OP3_INT__0__SHIFT 2u
N#define OP3_INT__DR CYREG_GPIO_PRT5_DR
N#define OP3_INT__DR_CLR CYREG_GPIO_PRT5_DR_CLR
N#define OP3_INT__DR_INV CYREG_GPIO_PRT5_DR_INV
N#define OP3_INT__DR_SET CYREG_GPIO_PRT5_DR_SET
N#define OP3_INT__INTCFG CYREG_GPIO_PRT5_INTR_CFG
N#define OP3_INT__INTR CYREG_GPIO_PRT5_INTR
N#define OP3_INT__INTR_CFG CYREG_GPIO_PRT5_INTR_CFG
N#define OP3_INT__INTSTAT CYREG_GPIO_PRT5_INTR
N#define OP3_INT__MASK 0x04u
N#define OP3_INT__PC CYREG_GPIO_PRT5_PC
N#define OP3_INT__PC2 CYREG_GPIO_PRT5_PC2
N#define OP3_INT__PORT 5u
N#define OP3_INT__PS CYREG_GPIO_PRT5_PS
N#define OP3_INT__SHIFT 2u
N
N/* isr_wdt */
N#define isr_wdt__INTC_CLR_EN_REG CYREG_CM0P_ICER
N#define isr_wdt__INTC_CLR_PD_REG CYREG_CM0P_ICPR
N#define isr_wdt__INTC_MASK 0x40u
N#define isr_wdt__INTC_NUMBER 6u
N#define isr_wdt__INTC_PRIOR_MASK 0xC00000u
N#define isr_wdt__INTC_PRIOR_NUM 3u
N#define isr_wdt__INTC_PRIOR_REG CYREG_CM0P_IPR1
N#define isr_wdt__INTC_SET_EN_REG CYREG_CM0P_ISER
N#define isr_wdt__INTC_SET_PD_REG CYREG_CM0P_ISPR
N
N/* CapSense */
N#define CapSense_Cmod__0__DR CYREG_GPIO_PRT4_DR
N#define CapSense_Cmod__0__DR_CLR CYREG_GPIO_PRT4_DR_CLR
N#define CapSense_Cmod__0__DR_INV CYREG_GPIO_PRT4_DR_INV
N#define CapSense_Cmod__0__DR_SET CYREG_GPIO_PRT4_DR_SET
N#define CapSense_Cmod__0__HSIOM CYREG_HSIOM_PORT_SEL4
N#define CapSense_Cmod__0__HSIOM_MASK 0x00000F00u
N#define CapSense_Cmod__0__HSIOM_SHIFT 8u
N#define CapSense_Cmod__0__INTCFG CYREG_GPIO_PRT4_INTR_CFG
N#define CapSense_Cmod__0__INTR CYREG_GPIO_PRT4_INTR
N#define CapSense_Cmod__0__INTR_CFG CYREG_GPIO_PRT4_INTR_CFG
N#define CapSense_Cmod__0__INTSTAT CYREG_GPIO_PRT4_INTR
N#define CapSense_Cmod__0__MASK 0x04u
N#define CapSense_Cmod__0__PC CYREG_GPIO_PRT4_PC
N#define CapSense_Cmod__0__PC2 CYREG_GPIO_PRT4_PC2
N#define CapSense_Cmod__0__PORT 4u
N#define CapSense_Cmod__0__PS CYREG_GPIO_PRT4_PS
N#define CapSense_Cmod__0__SHIFT 2u
N#define CapSense_Cmod__Cmod__DR CYREG_GPIO_PRT4_DR
N#define CapSense_Cmod__Cmod__DR_CLR CYREG_GPIO_PRT4_DR_CLR
N#define CapSense_Cmod__Cmod__DR_INV CYREG_GPIO_PRT4_DR_INV
N#define CapSense_Cmod__Cmod__DR_SET CYREG_GPIO_PRT4_DR_SET
N#define CapSense_Cmod__Cmod__INTCFG CYREG_GPIO_PRT4_INTR_CFG
N#define CapSense_Cmod__Cmod__INTR CYREG_GPIO_PRT4_INTR
N#define CapSense_Cmod__Cmod__INTR_CFG CYREG_GPIO_PRT4_INTR_CFG
N#define CapSense_Cmod__Cmod__INTSTAT CYREG_GPIO_PRT4_INTR
N#define CapSense_Cmod__Cmod__MASK 0x04u
N#define CapSense_Cmod__Cmod__PC CYREG_GPIO_PRT4_PC
N#define CapSense_Cmod__Cmod__PC2 CYREG_GPIO_PRT4_PC2
N#define CapSense_Cmod__Cmod__PORT 4u
N#define CapSense_Cmod__Cmod__PS CYREG_GPIO_PRT4_PS
N#define CapSense_Cmod__Cmod__SHIFT 2u
N#define CapSense_Cmod__DR CYREG_GPIO_PRT4_DR
N#define CapSense_Cmod__DR_CLR CYREG_GPIO_PRT4_DR_CLR
N#define CapSense_Cmod__DR_INV CYREG_GPIO_PRT4_DR_INV
N#define CapSense_Cmod__DR_SET CYREG_GPIO_PRT4_DR_SET
N#define CapSense_Cmod__INTCFG CYREG_GPIO_PRT4_INTR_CFG
N#define CapSense_Cmod__INTR CYREG_GPIO_PRT4_INTR
N#define CapSense_Cmod__INTR_CFG CYREG_GPIO_PRT4_INTR_CFG
N#define CapSense_Cmod__INTSTAT CYREG_GPIO_PRT4_INTR
N#define CapSense_Cmod__MASK 0x04u
N#define CapSense_Cmod__PC CYREG_GPIO_PRT4_PC
N#define CapSense_Cmod__PC2 CYREG_GPIO_PRT4_PC2
N#define CapSense_Cmod__PORT 4u
N#define CapSense_Cmod__PS CYREG_GPIO_PRT4_PS
N#define CapSense_Cmod__SHIFT 2u
N#define CapSense_CSD__ADC_CTL CYREG_CSD_ADC_CTL
N#define CapSense_CSD__CMOD_PAD 1u
N#define CapSense_CSD__CSD_CONFIG CYREG_CSD_CONFIG
N#define CapSense_CSD__CSD_INTR CYREG_CSD_INTR
N#define CapSense_CSD__CSD_INTR_SET CYREG_CSD_INTR_SET
N#define CapSense_CSD__CSD_NUMBER 0u
N#define CapSense_CSD__CSD_STATUS CYREG_CSD_STATUS
N#define CapSense_CSD__CSDCMP CYREG_CSD_CSDCMP
N#define CapSense_CSD__CSH_TANK_PAD 2u
N#define CapSense_CSD__CSHIELD_PAD 4u
N#define CapSense_CSD__DEDICATED_IO0 CapSense_CSD__CMOD_PAD
N#define CapSense_CSD__HSCMP CYREG_CSD_HSCMP
N#define CapSense_CSD__INTR_MASK CYREG_CSD_INTR_MASK
N#define CapSense_CSD__REFGEN CYREG_CSD_REFGEN
N#define CapSense_CSD__RESULT_VAL1 CYREG_CSD_RESULT_VAL1
N#define CapSense_CSD__RESULT_VAL2 CYREG_CSD_RESULT_VAL2
N#define CapSense_CSD__SENSE_DUTY CYREG_CSD_SENSE_DUTY
N#define CapSense_CSD__SENSE_PERIOD CYREG_CSD_SENSE_PERIOD
N#define CapSense_CSD__SEQ_INIT_CNT CYREG_CSD_SEQ_INIT_CNT
N#define CapSense_CSD__SEQ_NORM_CNT CYREG_CSD_SEQ_NORM_CNT
N#define CapSense_CSD__SEQ_START CYREG_CSD_SEQ_START
N#define CapSense_CSD__SEQ_TIME CYREG_CSD_SEQ_TIME
N#define CapSense_CSD__SW_AMUXBUF_SEL CYREG_CSD_SW_AMUXBUF_SEL
N#define CapSense_CSD__SW_BYP_SEL CYREG_CSD_SW_BYP_SEL
N#define CapSense_CSD__SW_CMP_N_SEL CYREG_CSD_SW_CMP_N_SEL
N#define CapSense_CSD__SW_CMP_P_SEL CYREG_CSD_SW_CMP_P_SEL
N#define CapSense_CSD__SW_DSI_SEL CYREG_CSD_SW_DSI_SEL
N#define CapSense_CSD__SW_FW_MOD_SEL CYREG_CSD_SW_FW_MOD_SEL
N#define CapSense_CSD__SW_FW_TANK_SEL CYREG_CSD_SW_FW_TANK_SEL
N#define CapSense_CSD__SW_HS_N_SEL CYREG_CSD_SW_HS_N_SEL
N#define CapSense_CSD__SW_HS_P_SEL CYREG_CSD_SW_HS_P_SEL
N#define CapSense_CSD__SW_REFGEN_SEL CYREG_CSD_SW_REFGEN_SEL
N#define CapSense_CSD__SW_RES CYREG_CSD_SW_RES
N#define CapSense_CSD__SW_SHIELD_SEL CYREG_CSD_SW_SHIELD_SEL
N#define CapSense_CSD__VREF_EXT_PAD 8u
N#define CapSense_IDACComp__CONFIG CYREG_CSD_CONFIG
N#define CapSense_IDACComp__IDAC CYREG_CSD_IDACB
N#define CapSense_IDACComp__POSITION 1u
N#define CapSense_IDACMod__CONFIG CYREG_CSD_CONFIG
N#define CapSense_IDACMod__IDAC CYREG_CSD_IDACA
N#define CapSense_IDACMod__POSITION 0u
N#define CapSense_ISR__INTC_CLR_EN_REG CYREG_CM0P_ICER
N#define CapSense_ISR__INTC_CLR_PD_REG CYREG_CM0P_ICPR
N#define CapSense_ISR__INTC_MASK 0x10000u
N#define CapSense_ISR__INTC_NUMBER 16u
N#define CapSense_ISR__INTC_PRIOR_MASK 0xC0u
N#define CapSense_ISR__INTC_PRIOR_NUM 1u
N#define CapSense_ISR__INTC_PRIOR_REG CYREG_CM0P_IPR4
N#define CapSense_ISR__INTC_SET_EN_REG CYREG_CM0P_ISER
N#define CapSense_ISR__INTC_SET_PD_REG CYREG_CM0P_ISPR
N#define CapSense_ModClk__CTRL_REGISTER CYREG_PERI_PCLK_CTL5
N#define CapSense_ModClk__DIV_ID 0x00000040u
N#define CapSense_ModClk__DIV_REGISTER CYREG_PERI_DIV_16_CTL0
N#define CapSense_ModClk__PA_DIV_ID 0x000000FFu
N#define CapSense_Sns__0__DR CYREG_GPIO_PRT4_DR
N#define CapSense_Sns__0__DR_CLR CYREG_GPIO_PRT4_DR_CLR
N#define CapSense_Sns__0__DR_INV CYREG_GPIO_PRT4_DR_INV
N#define CapSense_Sns__0__DR_SET CYREG_GPIO_PRT4_DR_SET
N#define CapSense_Sns__0__HSIOM CYREG_HSIOM_PORT_SEL4
N#define CapSense_Sns__0__HSIOM_MASK 0x0000F000u
N#define CapSense_Sns__0__HSIOM_SHIFT 12u
N#define CapSense_Sns__0__INTCFG CYREG_GPIO_PRT4_INTR_CFG
N#define CapSense_Sns__0__INTR CYREG_GPIO_PRT4_INTR
N#define CapSense_Sns__0__INTR_CFG CYREG_GPIO_PRT4_INTR_CFG
N#define CapSense_Sns__0__INTSTAT CYREG_GPIO_PRT4_INTR
N#define CapSense_Sns__0__MASK 0x08u
N#define CapSense_Sns__0__PC CYREG_GPIO_PRT4_PC
N#define CapSense_Sns__0__PC2 CYREG_GPIO_PRT4_PC2
N#define CapSense_Sns__0__PORT 4u
N#define CapSense_Sns__0__PS CYREG_GPIO_PRT4_PS
N#define CapSense_Sns__0__SHIFT 3u
N#define CapSense_Sns__1__DR CYREG_GPIO_PRT4_DR
N#define CapSense_Sns__1__DR_CLR CYREG_GPIO_PRT4_DR_CLR
N#define CapSense_Sns__1__DR_INV CYREG_GPIO_PRT4_DR_INV
N#define CapSense_Sns__1__DR_SET CYREG_GPIO_PRT4_DR_SET
N#define CapSense_Sns__1__HSIOM CYREG_HSIOM_PORT_SEL4
N#define CapSense_Sns__1__HSIOM_MASK 0x0000000Fu
N#define CapSense_Sns__1__HSIOM_SHIFT 0u
N#define CapSense_Sns__1__INTCFG CYREG_GPIO_PRT4_INTR_CFG
N#define CapSense_Sns__1__INTR CYREG_GPIO_PRT4_INTR
N#define CapSense_Sns__1__INTR_CFG CYREG_GPIO_PRT4_INTR_CFG
N#define CapSense_Sns__1__INTSTAT CYREG_GPIO_PRT4_INTR
N#define CapSense_Sns__1__MASK 0x01u
N#define CapSense_Sns__1__PC CYREG_GPIO_PRT4_PC
N#define CapSense_Sns__1__PC2 CYREG_GPIO_PRT4_PC2
N#define CapSense_Sns__1__PORT 4u
N#define CapSense_Sns__1__PS CYREG_GPIO_PRT4_PS
N#define CapSense_Sns__1__SHIFT 0u
N#define CapSense_Sns__10__DR CYREG_GPIO_PRT6_DR
N#define CapSense_Sns__10__DR_CLR CYREG_GPIO_PRT6_DR_CLR
N#define CapSense_Sns__10__DR_INV CYREG_GPIO_PRT6_DR_INV
N#define CapSense_Sns__10__DR_SET CYREG_GPIO_PRT6_DR_SET
N#define CapSense_Sns__10__HSIOM CYREG_HSIOM_PORT_SEL6
N#define CapSense_Sns__10__HSIOM_MASK 0x000F0000u
N#define CapSense_Sns__10__HSIOM_SHIFT 16u
N#define CapSense_Sns__10__INTCFG CYREG_GPIO_PRT6_INTR_CFG
N#define CapSense_Sns__10__INTR CYREG_GPIO_PRT6_INTR
N#define CapSense_Sns__10__INTR_CFG CYREG_GPIO_PRT6_INTR_CFG
N#define CapSense_Sns__10__INTSTAT CYREG_GPIO_PRT6_INTR
N#define CapSense_Sns__10__MASK 0x10u
N#define CapSense_Sns__10__PC CYREG_GPIO_PRT6_PC
N#define CapSense_Sns__10__PC2 CYREG_GPIO_PRT6_PC2
N#define CapSense_Sns__10__PORT 6u
N#define CapSense_Sns__10__PS CYREG_GPIO_PRT6_PS
N#define CapSense_Sns__10__SHIFT 4u
N#define CapSense_Sns__11__DR CYREG_GPIO_PRT6_DR
N#define CapSense_Sns__11__DR_CLR CYREG_GPIO_PRT6_DR_CLR
N#define CapSense_Sns__11__DR_INV CYREG_GPIO_PRT6_DR_INV
N#define CapSense_Sns__11__DR_SET CYREG_GPIO_PRT6_DR_SET
N#define CapSense_Sns__11__HSIOM CYREG_HSIOM_PORT_SEL6
N#define CapSense_Sns__11__HSIOM_MASK 0x00000F00u
N#define CapSense_Sns__11__HSIOM_SHIFT 8u
N#define CapSense_Sns__11__INTCFG CYREG_GPIO_PRT6_INTR_CFG
N#define CapSense_Sns__11__INTR CYREG_GPIO_PRT6_INTR
N#define CapSense_Sns__11__INTR_CFG CYREG_GPIO_PRT6_INTR_CFG
N#define CapSense_Sns__11__INTSTAT CYREG_GPIO_PRT6_INTR
N#define CapSense_Sns__11__MASK 0x04u
N#define CapSense_Sns__11__PC CYREG_GPIO_PRT6_PC
N#define CapSense_Sns__11__PC2 CYREG_GPIO_PRT6_PC2
N#define CapSense_Sns__11__PORT 6u
N#define CapSense_Sns__11__PS CYREG_GPIO_PRT6_PS
N#define CapSense_Sns__11__SHIFT 2u
N#define CapSense_Sns__2__DR CYREG_GPIO_PRT4_DR
N#define CapSense_Sns__2__DR_CLR CYREG_GPIO_PRT4_DR_CLR
N#define CapSense_Sns__2__DR_INV CYREG_GPIO_PRT4_DR_INV
N#define CapSense_Sns__2__DR_SET CYREG_GPIO_PRT4_DR_SET
N#define CapSense_Sns__2__HSIOM CYREG_HSIOM_PORT_SEL4
N#define CapSense_Sns__2__HSIOM_MASK 0x000000F0u
N#define CapSense_Sns__2__HSIOM_SHIFT 4u
N#define CapSense_Sns__2__INTCFG CYREG_GPIO_PRT4_INTR_CFG
N#define CapSense_Sns__2__INTR CYREG_GPIO_PRT4_INTR
N#define CapSense_Sns__2__INTR_CFG CYREG_GPIO_PRT4_INTR_CFG
N#define CapSense_Sns__2__INTSTAT CYREG_GPIO_PRT4_INTR
N#define CapSense_Sns__2__MASK 0x02u
N#define CapSense_Sns__2__PC CYREG_GPIO_PRT4_PC
N#define CapSense_Sns__2__PC2 CYREG_GPIO_PRT4_PC2
N#define CapSense_Sns__2__PORT 4u
N#define CapSense_Sns__2__PS CYREG_GPIO_PRT4_PS
N#define CapSense_Sns__2__SHIFT 1u
N#define CapSense_Sns__3__DR CYREG_GPIO_PRT3_DR
N#define CapSense_Sns__3__DR_CLR CYREG_GPIO_PRT3_DR_CLR
N#define CapSense_Sns__3__DR_INV CYREG_GPIO_PRT3_DR_INV
N#define CapSense_Sns__3__DR_SET CYREG_GPIO_PRT3_DR_SET
N#define CapSense_Sns__3__HSIOM CYREG_HSIOM_PORT_SEL3
N#define CapSense_Sns__3__HSIOM_MASK 0xF0000000u
N#define CapSense_Sns__3__HSIOM_SHIFT 28u
N#define CapSense_Sns__3__INTCFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__3__INTR CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__3__INTR_CFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__3__INTSTAT CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__3__MASK 0x80u
N#define CapSense_Sns__3__PC CYREG_GPIO_PRT3_PC
N#define CapSense_Sns__3__PC2 CYREG_GPIO_PRT3_PC2
N#define CapSense_Sns__3__PORT 3u
N#define CapSense_Sns__3__PS CYREG_GPIO_PRT3_PS
N#define CapSense_Sns__3__SHIFT 7u
N#define CapSense_Sns__4__DR CYREG_GPIO_PRT3_DR
N#define CapSense_Sns__4__DR_CLR CYREG_GPIO_PRT3_DR_CLR
N#define CapSense_Sns__4__DR_INV CYREG_GPIO_PRT3_DR_INV
N#define CapSense_Sns__4__DR_SET CYREG_GPIO_PRT3_DR_SET
N#define CapSense_Sns__4__HSIOM CYREG_HSIOM_PORT_SEL3
N#define CapSense_Sns__4__HSIOM_MASK 0x0F000000u
N#define CapSense_Sns__4__HSIOM_SHIFT 24u
N#define CapSense_Sns__4__INTCFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__4__INTR CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__4__INTR_CFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__4__INTSTAT CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__4__MASK 0x40u
N#define CapSense_Sns__4__PC CYREG_GPIO_PRT3_PC
N#define CapSense_Sns__4__PC2 CYREG_GPIO_PRT3_PC2
N#define CapSense_Sns__4__PORT 3u
N#define CapSense_Sns__4__PS CYREG_GPIO_PRT3_PS
N#define CapSense_Sns__4__SHIFT 6u
N#define CapSense_Sns__5__DR CYREG_GPIO_PRT3_DR
N#define CapSense_Sns__5__DR_CLR CYREG_GPIO_PRT3_DR_CLR
N#define CapSense_Sns__5__DR_INV CYREG_GPIO_PRT3_DR_INV
N#define CapSense_Sns__5__DR_SET CYREG_GPIO_PRT3_DR_SET
N#define CapSense_Sns__5__HSIOM CYREG_HSIOM_PORT_SEL3
N#define CapSense_Sns__5__HSIOM_MASK 0x00F00000u
N#define CapSense_Sns__5__HSIOM_SHIFT 20u
N#define CapSense_Sns__5__INTCFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__5__INTR CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__5__INTR_CFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__5__INTSTAT CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__5__MASK 0x20u
N#define CapSense_Sns__5__PC CYREG_GPIO_PRT3_PC
N#define CapSense_Sns__5__PC2 CYREG_GPIO_PRT3_PC2
N#define CapSense_Sns__5__PORT 3u
N#define CapSense_Sns__5__PS CYREG_GPIO_PRT3_PS
N#define CapSense_Sns__5__SHIFT 5u
N#define CapSense_Sns__6__DR CYREG_GPIO_PRT3_DR
N#define CapSense_Sns__6__DR_CLR CYREG_GPIO_PRT3_DR_CLR
N#define CapSense_Sns__6__DR_INV CYREG_GPIO_PRT3_DR_INV
N#define CapSense_Sns__6__DR_SET CYREG_GPIO_PRT3_DR_SET
N#define CapSense_Sns__6__HSIOM CYREG_HSIOM_PORT_SEL3
N#define CapSense_Sns__6__HSIOM_MASK 0x000F0000u
N#define CapSense_Sns__6__HSIOM_SHIFT 16u
N#define CapSense_Sns__6__INTCFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__6__INTR CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__6__INTR_CFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__6__INTSTAT CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__6__MASK 0x10u
N#define CapSense_Sns__6__PC CYREG_GPIO_PRT3_PC
N#define CapSense_Sns__6__PC2 CYREG_GPIO_PRT3_PC2
N#define CapSense_Sns__6__PORT 3u
N#define CapSense_Sns__6__PS CYREG_GPIO_PRT3_PS
N#define CapSense_Sns__6__SHIFT 4u
N#define CapSense_Sns__7__DR CYREG_GPIO_PRT3_DR
N#define CapSense_Sns__7__DR_CLR CYREG_GPIO_PRT3_DR_CLR
N#define CapSense_Sns__7__DR_INV CYREG_GPIO_PRT3_DR_INV
N#define CapSense_Sns__7__DR_SET CYREG_GPIO_PRT3_DR_SET
N#define CapSense_Sns__7__HSIOM CYREG_HSIOM_PORT_SEL3
N#define CapSense_Sns__7__HSIOM_MASK 0x000000F0u
N#define CapSense_Sns__7__HSIOM_SHIFT 4u
N#define CapSense_Sns__7__INTCFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__7__INTR CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__7__INTR_CFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__7__INTSTAT CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__7__MASK 0x02u
N#define CapSense_Sns__7__PC CYREG_GPIO_PRT3_PC
N#define CapSense_Sns__7__PC2 CYREG_GPIO_PRT3_PC2
N#define CapSense_Sns__7__PORT 3u
N#define CapSense_Sns__7__PS CYREG_GPIO_PRT3_PS
N#define CapSense_Sns__7__SHIFT 1u
N#define CapSense_Sns__8__DR CYREG_GPIO_PRT3_DR
N#define CapSense_Sns__8__DR_CLR CYREG_GPIO_PRT3_DR_CLR
N#define CapSense_Sns__8__DR_INV CYREG_GPIO_PRT3_DR_INV
N#define CapSense_Sns__8__DR_SET CYREG_GPIO_PRT3_DR_SET
N#define CapSense_Sns__8__HSIOM CYREG_HSIOM_PORT_SEL3
N#define CapSense_Sns__8__HSIOM_MASK 0x0000000Fu
N#define CapSense_Sns__8__HSIOM_SHIFT 0u
N#define CapSense_Sns__8__INTCFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__8__INTR CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__8__INTR_CFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__8__INTSTAT CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__8__MASK 0x01u
N#define CapSense_Sns__8__PC CYREG_GPIO_PRT3_PC
N#define CapSense_Sns__8__PC2 CYREG_GPIO_PRT3_PC2
N#define CapSense_Sns__8__PORT 3u
N#define CapSense_Sns__8__PS CYREG_GPIO_PRT3_PS
N#define CapSense_Sns__8__SHIFT 0u
N#define CapSense_Sns__9__DR CYREG_GPIO_PRT6_DR
N#define CapSense_Sns__9__DR_CLR CYREG_GPIO_PRT6_DR_CLR
N#define CapSense_Sns__9__DR_INV CYREG_GPIO_PRT6_DR_INV
N#define CapSense_Sns__9__DR_SET CYREG_GPIO_PRT6_DR_SET
N#define CapSense_Sns__9__HSIOM CYREG_HSIOM_PORT_SEL6
N#define CapSense_Sns__9__HSIOM_MASK 0x00F00000u
N#define CapSense_Sns__9__HSIOM_SHIFT 20u
N#define CapSense_Sns__9__INTCFG CYREG_GPIO_PRT6_INTR_CFG
N#define CapSense_Sns__9__INTR CYREG_GPIO_PRT6_INTR
N#define CapSense_Sns__9__INTR_CFG CYREG_GPIO_PRT6_INTR_CFG
N#define CapSense_Sns__9__INTSTAT CYREG_GPIO_PRT6_INTR
N#define CapSense_Sns__9__MASK 0x20u
N#define CapSense_Sns__9__PC CYREG_GPIO_PRT6_PC
N#define CapSense_Sns__9__PC2 CYREG_GPIO_PRT6_PC2
N#define CapSense_Sns__9__PORT 6u
N#define CapSense_Sns__9__PS CYREG_GPIO_PRT6_PS
N#define CapSense_Sns__9__SHIFT 5u
N#define CapSense_Sns__Button0_Sns0__DR CYREG_GPIO_PRT4_DR
N#define CapSense_Sns__Button0_Sns0__DR_CLR CYREG_GPIO_PRT4_DR_CLR
N#define CapSense_Sns__Button0_Sns0__DR_INV CYREG_GPIO_PRT4_DR_INV
N#define CapSense_Sns__Button0_Sns0__DR_SET CYREG_GPIO_PRT4_DR_SET
N#define CapSense_Sns__Button0_Sns0__INTCFG CYREG_GPIO_PRT4_INTR_CFG
N#define CapSense_Sns__Button0_Sns0__INTR CYREG_GPIO_PRT4_INTR
N#define CapSense_Sns__Button0_Sns0__INTR_CFG CYREG_GPIO_PRT4_INTR_CFG
N#define CapSense_Sns__Button0_Sns0__INTSTAT CYREG_GPIO_PRT4_INTR
N#define CapSense_Sns__Button0_Sns0__MASK 0x08u
N#define CapSense_Sns__Button0_Sns0__PC CYREG_GPIO_PRT4_PC
N#define CapSense_Sns__Button0_Sns0__PC2 CYREG_GPIO_PRT4_PC2
N#define CapSense_Sns__Button0_Sns0__PORT 4u
N#define CapSense_Sns__Button0_Sns0__PS CYREG_GPIO_PRT4_PS
N#define CapSense_Sns__Button0_Sns0__SHIFT 3u
N#define CapSense_Sns__Button1_Sns0__DR CYREG_GPIO_PRT4_DR
N#define CapSense_Sns__Button1_Sns0__DR_CLR CYREG_GPIO_PRT4_DR_CLR
N#define CapSense_Sns__Button1_Sns0__DR_INV CYREG_GPIO_PRT4_DR_INV
N#define CapSense_Sns__Button1_Sns0__DR_SET CYREG_GPIO_PRT4_DR_SET
N#define CapSense_Sns__Button1_Sns0__INTCFG CYREG_GPIO_PRT4_INTR_CFG
N#define CapSense_Sns__Button1_Sns0__INTR CYREG_GPIO_PRT4_INTR
N#define CapSense_Sns__Button1_Sns0__INTR_CFG CYREG_GPIO_PRT4_INTR_CFG
N#define CapSense_Sns__Button1_Sns0__INTSTAT CYREG_GPIO_PRT4_INTR
N#define CapSense_Sns__Button1_Sns0__MASK 0x01u
N#define CapSense_Sns__Button1_Sns0__PC CYREG_GPIO_PRT4_PC
N#define CapSense_Sns__Button1_Sns0__PC2 CYREG_GPIO_PRT4_PC2
N#define CapSense_Sns__Button1_Sns0__PORT 4u
N#define CapSense_Sns__Button1_Sns0__PS CYREG_GPIO_PRT4_PS
N#define CapSense_Sns__Button1_Sns0__SHIFT 0u
N#define CapSense_Sns__Button10_Sns0__DR CYREG_GPIO_PRT6_DR
N#define CapSense_Sns__Button10_Sns0__DR_CLR CYREG_GPIO_PRT6_DR_CLR
N#define CapSense_Sns__Button10_Sns0__DR_INV CYREG_GPIO_PRT6_DR_INV
N#define CapSense_Sns__Button10_Sns0__DR_SET CYREG_GPIO_PRT6_DR_SET
N#define CapSense_Sns__Button10_Sns0__INTCFG CYREG_GPIO_PRT6_INTR_CFG
N#define CapSense_Sns__Button10_Sns0__INTR CYREG_GPIO_PRT6_INTR
N#define CapSense_Sns__Button10_Sns0__INTR_CFG CYREG_GPIO_PRT6_INTR_CFG
N#define CapSense_Sns__Button10_Sns0__INTSTAT CYREG_GPIO_PRT6_INTR
N#define CapSense_Sns__Button10_Sns0__MASK 0x10u
N#define CapSense_Sns__Button10_Sns0__PC CYREG_GPIO_PRT6_PC
N#define CapSense_Sns__Button10_Sns0__PC2 CYREG_GPIO_PRT6_PC2
N#define CapSense_Sns__Button10_Sns0__PORT 6u
N#define CapSense_Sns__Button10_Sns0__PS CYREG_GPIO_PRT6_PS
N#define CapSense_Sns__Button10_Sns0__SHIFT 4u
N#define CapSense_Sns__Button11_Sns0__DR CYREG_GPIO_PRT6_DR
N#define CapSense_Sns__Button11_Sns0__DR_CLR CYREG_GPIO_PRT6_DR_CLR
N#define CapSense_Sns__Button11_Sns0__DR_INV CYREG_GPIO_PRT6_DR_INV
N#define CapSense_Sns__Button11_Sns0__DR_SET CYREG_GPIO_PRT6_DR_SET
N#define CapSense_Sns__Button11_Sns0__INTCFG CYREG_GPIO_PRT6_INTR_CFG
N#define CapSense_Sns__Button11_Sns0__INTR CYREG_GPIO_PRT6_INTR
N#define CapSense_Sns__Button11_Sns0__INTR_CFG CYREG_GPIO_PRT6_INTR_CFG
N#define CapSense_Sns__Button11_Sns0__INTSTAT CYREG_GPIO_PRT6_INTR
N#define CapSense_Sns__Button11_Sns0__MASK 0x04u
N#define CapSense_Sns__Button11_Sns0__PC CYREG_GPIO_PRT6_PC
N#define CapSense_Sns__Button11_Sns0__PC2 CYREG_GPIO_PRT6_PC2
N#define CapSense_Sns__Button11_Sns0__PORT 6u
N#define CapSense_Sns__Button11_Sns0__PS CYREG_GPIO_PRT6_PS
N#define CapSense_Sns__Button11_Sns0__SHIFT 2u
N#define CapSense_Sns__Button2_Sns0__DR CYREG_GPIO_PRT4_DR
N#define CapSense_Sns__Button2_Sns0__DR_CLR CYREG_GPIO_PRT4_DR_CLR
N#define CapSense_Sns__Button2_Sns0__DR_INV CYREG_GPIO_PRT4_DR_INV
N#define CapSense_Sns__Button2_Sns0__DR_SET CYREG_GPIO_PRT4_DR_SET
N#define CapSense_Sns__Button2_Sns0__INTCFG CYREG_GPIO_PRT4_INTR_CFG
N#define CapSense_Sns__Button2_Sns0__INTR CYREG_GPIO_PRT4_INTR
N#define CapSense_Sns__Button2_Sns0__INTR_CFG CYREG_GPIO_PRT4_INTR_CFG
N#define CapSense_Sns__Button2_Sns0__INTSTAT CYREG_GPIO_PRT4_INTR
N#define CapSense_Sns__Button2_Sns0__MASK 0x02u
N#define CapSense_Sns__Button2_Sns0__PC CYREG_GPIO_PRT4_PC
N#define CapSense_Sns__Button2_Sns0__PC2 CYREG_GPIO_PRT4_PC2
N#define CapSense_Sns__Button2_Sns0__PORT 4u
N#define CapSense_Sns__Button2_Sns0__PS CYREG_GPIO_PRT4_PS
N#define CapSense_Sns__Button2_Sns0__SHIFT 1u
N#define CapSense_Sns__Button3_Sns0__DR CYREG_GPIO_PRT3_DR
N#define CapSense_Sns__Button3_Sns0__DR_CLR CYREG_GPIO_PRT3_DR_CLR
N#define CapSense_Sns__Button3_Sns0__DR_INV CYREG_GPIO_PRT3_DR_INV
N#define CapSense_Sns__Button3_Sns0__DR_SET CYREG_GPIO_PRT3_DR_SET
N#define CapSense_Sns__Button3_Sns0__INTCFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__Button3_Sns0__INTR CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__Button3_Sns0__INTR_CFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__Button3_Sns0__INTSTAT CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__Button3_Sns0__MASK 0x80u
N#define CapSense_Sns__Button3_Sns0__PC CYREG_GPIO_PRT3_PC
N#define CapSense_Sns__Button3_Sns0__PC2 CYREG_GPIO_PRT3_PC2
N#define CapSense_Sns__Button3_Sns0__PORT 3u
N#define CapSense_Sns__Button3_Sns0__PS CYREG_GPIO_PRT3_PS
N#define CapSense_Sns__Button3_Sns0__SHIFT 7u
N#define CapSense_Sns__Button4_Sns0__DR CYREG_GPIO_PRT3_DR
N#define CapSense_Sns__Button4_Sns0__DR_CLR CYREG_GPIO_PRT3_DR_CLR
N#define CapSense_Sns__Button4_Sns0__DR_INV CYREG_GPIO_PRT3_DR_INV
N#define CapSense_Sns__Button4_Sns0__DR_SET CYREG_GPIO_PRT3_DR_SET
N#define CapSense_Sns__Button4_Sns0__INTCFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__Button4_Sns0__INTR CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__Button4_Sns0__INTR_CFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__Button4_Sns0__INTSTAT CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__Button4_Sns0__MASK 0x40u
N#define CapSense_Sns__Button4_Sns0__PC CYREG_GPIO_PRT3_PC
N#define CapSense_Sns__Button4_Sns0__PC2 CYREG_GPIO_PRT3_PC2
N#define CapSense_Sns__Button4_Sns0__PORT 3u
N#define CapSense_Sns__Button4_Sns0__PS CYREG_GPIO_PRT3_PS
N#define CapSense_Sns__Button4_Sns0__SHIFT 6u
N#define CapSense_Sns__Button5_Sns0__DR CYREG_GPIO_PRT3_DR
N#define CapSense_Sns__Button5_Sns0__DR_CLR CYREG_GPIO_PRT3_DR_CLR
N#define CapSense_Sns__Button5_Sns0__DR_INV CYREG_GPIO_PRT3_DR_INV
N#define CapSense_Sns__Button5_Sns0__DR_SET CYREG_GPIO_PRT3_DR_SET
N#define CapSense_Sns__Button5_Sns0__INTCFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__Button5_Sns0__INTR CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__Button5_Sns0__INTR_CFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__Button5_Sns0__INTSTAT CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__Button5_Sns0__MASK 0x20u
N#define CapSense_Sns__Button5_Sns0__PC CYREG_GPIO_PRT3_PC
N#define CapSense_Sns__Button5_Sns0__PC2 CYREG_GPIO_PRT3_PC2
N#define CapSense_Sns__Button5_Sns0__PORT 3u
N#define CapSense_Sns__Button5_Sns0__PS CYREG_GPIO_PRT3_PS
N#define CapSense_Sns__Button5_Sns0__SHIFT 5u
N#define CapSense_Sns__Button6_Sns0__DR CYREG_GPIO_PRT3_DR
N#define CapSense_Sns__Button6_Sns0__DR_CLR CYREG_GPIO_PRT3_DR_CLR
N#define CapSense_Sns__Button6_Sns0__DR_INV CYREG_GPIO_PRT3_DR_INV
N#define CapSense_Sns__Button6_Sns0__DR_SET CYREG_GPIO_PRT3_DR_SET
N#define CapSense_Sns__Button6_Sns0__INTCFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__Button6_Sns0__INTR CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__Button6_Sns0__INTR_CFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__Button6_Sns0__INTSTAT CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__Button6_Sns0__MASK 0x10u
N#define CapSense_Sns__Button6_Sns0__PC CYREG_GPIO_PRT3_PC
N#define CapSense_Sns__Button6_Sns0__PC2 CYREG_GPIO_PRT3_PC2
N#define CapSense_Sns__Button6_Sns0__PORT 3u
N#define CapSense_Sns__Button6_Sns0__PS CYREG_GPIO_PRT3_PS
N#define CapSense_Sns__Button6_Sns0__SHIFT 4u
N#define CapSense_Sns__Button7_Sns0__DR CYREG_GPIO_PRT3_DR
N#define CapSense_Sns__Button7_Sns0__DR_CLR CYREG_GPIO_PRT3_DR_CLR
N#define CapSense_Sns__Button7_Sns0__DR_INV CYREG_GPIO_PRT3_DR_INV
N#define CapSense_Sns__Button7_Sns0__DR_SET CYREG_GPIO_PRT3_DR_SET
N#define CapSense_Sns__Button7_Sns0__INTCFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__Button7_Sns0__INTR CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__Button7_Sns0__INTR_CFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__Button7_Sns0__INTSTAT CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__Button7_Sns0__MASK 0x02u
N#define CapSense_Sns__Button7_Sns0__PC CYREG_GPIO_PRT3_PC
N#define CapSense_Sns__Button7_Sns0__PC2 CYREG_GPIO_PRT3_PC2
N#define CapSense_Sns__Button7_Sns0__PORT 3u
N#define CapSense_Sns__Button7_Sns0__PS CYREG_GPIO_PRT3_PS
N#define CapSense_Sns__Button7_Sns0__SHIFT 1u
N#define CapSense_Sns__Button8_Sns0__DR CYREG_GPIO_PRT3_DR
N#define CapSense_Sns__Button8_Sns0__DR_CLR CYREG_GPIO_PRT3_DR_CLR
N#define CapSense_Sns__Button8_Sns0__DR_INV CYREG_GPIO_PRT3_DR_INV
N#define CapSense_Sns__Button8_Sns0__DR_SET CYREG_GPIO_PRT3_DR_SET
N#define CapSense_Sns__Button8_Sns0__INTCFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__Button8_Sns0__INTR CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__Button8_Sns0__INTR_CFG CYREG_GPIO_PRT3_INTR_CFG
N#define CapSense_Sns__Button8_Sns0__INTSTAT CYREG_GPIO_PRT3_INTR
N#define CapSense_Sns__Button8_Sns0__MASK 0x01u
N#define CapSense_Sns__Button8_Sns0__PC CYREG_GPIO_PRT3_PC
N#define CapSense_Sns__Button8_Sns0__PC2 CYREG_GPIO_PRT3_PC2
N#define CapSense_Sns__Button8_Sns0__PORT 3u
N#define CapSense_Sns__Button8_Sns0__PS CYREG_GPIO_PRT3_PS
N#define CapSense_Sns__Button8_Sns0__SHIFT 0u
N#define CapSense_Sns__Button9_Sns0__DR CYREG_GPIO_PRT6_DR
N#define CapSense_Sns__Button9_Sns0__DR_CLR CYREG_GPIO_PRT6_DR_CLR
N#define CapSense_Sns__Button9_Sns0__DR_INV CYREG_GPIO_PRT6_DR_INV
N#define CapSense_Sns__Button9_Sns0__DR_SET CYREG_GPIO_PRT6_DR_SET
N#define CapSense_Sns__Button9_Sns0__INTCFG CYREG_GPIO_PRT6_INTR_CFG
N#define CapSense_Sns__Button9_Sns0__INTR CYREG_GPIO_PRT6_INTR
N#define CapSense_Sns__Button9_Sns0__INTR_CFG CYREG_GPIO_PRT6_INTR_CFG
N#define CapSense_Sns__Button9_Sns0__INTSTAT CYREG_GPIO_PRT6_INTR
N#define CapSense_Sns__Button9_Sns0__MASK 0x20u
N#define CapSense_Sns__Button9_Sns0__PC CYREG_GPIO_PRT6_PC
N#define CapSense_Sns__Button9_Sns0__PC2 CYREG_GPIO_PRT6_PC2
N#define CapSense_Sns__Button9_Sns0__PORT 6u
N#define CapSense_Sns__Button9_Sns0__PS CYREG_GPIO_PRT6_PS
N#define CapSense_Sns__Button9_Sns0__SHIFT 5u
N
N/* LOCK_INT */
N#define LOCK_INT__0__DR CYREG_GPIO_PRT0_DR
N#define LOCK_INT__0__DR_CLR CYREG_GPIO_PRT0_DR_CLR
N#define LOCK_INT__0__DR_INV CYREG_GPIO_PRT0_DR_INV
N#define LOCK_INT__0__DR_SET CYREG_GPIO_PRT0_DR_SET
N#define LOCK_INT__0__HSIOM CYREG_HSIOM_PORT_SEL0
N#define LOCK_INT__0__HSIOM_MASK 0x0000000Fu
N#define LOCK_INT__0__HSIOM_SHIFT 0u
N#define LOCK_INT__0__INTCFG CYREG_GPIO_PRT0_INTR_CFG
N#define LOCK_INT__0__INTR CYREG_GPIO_PRT0_INTR
N#define LOCK_INT__0__INTR_CFG CYREG_GPIO_PRT0_INTR_CFG
N#define LOCK_INT__0__INTSTAT CYREG_GPIO_PRT0_INTR
N#define LOCK_INT__0__MASK 0x01u
N#define LOCK_INT__0__PC CYREG_GPIO_PRT0_PC
N#define LOCK_INT__0__PC2 CYREG_GPIO_PRT0_PC2
N#define LOCK_INT__0__PORT 0u
N#define LOCK_INT__0__PS CYREG_GPIO_PRT0_PS
N#define LOCK_INT__0__SHIFT 0u
N#define LOCK_INT__1__DR CYREG_GPIO_PRT0_DR
N#define LOCK_INT__1__DR_CLR CYREG_GPIO_PRT0_DR_CLR
N#define LOCK_INT__1__DR_INV CYREG_GPIO_PRT0_DR_INV
N#define LOCK_INT__1__DR_SET CYREG_GPIO_PRT0_DR_SET
N#define LOCK_INT__1__HSIOM CYREG_HSIOM_PORT_SEL0
N#define LOCK_INT__1__HSIOM_MASK 0x000000F0u
N#define LOCK_INT__1__HSIOM_SHIFT 4u
N#define LOCK_INT__1__INTCFG CYREG_GPIO_PRT0_INTR_CFG
N#define LOCK_INT__1__INTR CYREG_GPIO_PRT0_INTR
N#define LOCK_INT__1__INTR_CFG CYREG_GPIO_PRT0_INTR_CFG
N#define LOCK_INT__1__INTSTAT CYREG_GPIO_PRT0_INTR
N#define LOCK_INT__1__MASK 0x02u
N#define LOCK_INT__1__PC CYREG_GPIO_PRT0_PC
N#define LOCK_INT__1__PC2 CYREG_GPIO_PRT0_PC2
N#define LOCK_INT__1__PORT 0u
N#define LOCK_INT__1__PS CYREG_GPIO_PRT0_PS
N#define LOCK_INT__1__SHIFT 1u
N#define LOCK_INT__2__DR CYREG_GPIO_PRT0_DR
N#define LOCK_INT__2__DR_CLR CYREG_GPIO_PRT0_DR_CLR
N#define LOCK_INT__2__DR_INV CYREG_GPIO_PRT0_DR_INV
N#define LOCK_INT__2__DR_SET CYREG_GPIO_PRT0_DR_SET
N#define LOCK_INT__2__HSIOM CYREG_HSIOM_PORT_SEL0
N#define LOCK_INT__2__HSIOM_MASK 0x00000F00u
N#define LOCK_INT__2__HSIOM_SHIFT 8u
N#define LOCK_INT__2__INTCFG CYREG_GPIO_PRT0_INTR_CFG
N#define LOCK_INT__2__INTR CYREG_GPIO_PRT0_INTR
N#define LOCK_INT__2__INTR_CFG CYREG_GPIO_PRT0_INTR_CFG
N#define LOCK_INT__2__INTSTAT CYREG_GPIO_PRT0_INTR
N#define LOCK_INT__2__MASK 0x04u
N#define LOCK_INT__2__PC CYREG_GPIO_PRT0_PC
N#define LOCK_INT__2__PC2 CYREG_GPIO_PRT0_PC2
N#define LOCK_INT__2__PORT 0u
N#define LOCK_INT__2__PS CYREG_GPIO_PRT0_PS
N#define LOCK_INT__2__SHIFT 2u
N#define LOCK_INT__3__DR CYREG_GPIO_PRT0_DR
N#define LOCK_INT__3__DR_CLR CYREG_GPIO_PRT0_DR_CLR
N#define LOCK_INT__3__DR_INV CYREG_GPIO_PRT0_DR_INV
N#define LOCK_INT__3__DR_SET CYREG_GPIO_PRT0_DR_SET
N#define LOCK_INT__3__HSIOM CYREG_HSIOM_PORT_SEL0
N#define LOCK_INT__3__HSIOM_MASK 0x0000F000u
N#define LOCK_INT__3__HSIOM_SHIFT 12u
N#define LOCK_INT__3__INTCFG CYREG_GPIO_PRT0_INTR_CFG
N#define LOCK_INT__3__INTR CYREG_GPIO_PRT0_INTR
N#define LOCK_INT__3__INTR_CFG CYREG_GPIO_PRT0_INTR_CFG
N#define LOCK_INT__3__INTSTAT CYREG_GPIO_PRT0_INTR
N#define LOCK_INT__3__MASK 0x08u
N#define LOCK_INT__3__PC CYREG_GPIO_PRT0_PC
N#define LOCK_INT__3__PC2 CYREG_GPIO_PRT0_PC2
N#define LOCK_INT__3__PORT 0u
N#define LOCK_INT__3__PS CYREG_GPIO_PRT0_PS
N#define LOCK_INT__3__SHIFT 3u
N#define LOCK_INT__DR CYREG_GPIO_PRT0_DR
N#define LOCK_INT__DR_CLR CYREG_GPIO_PRT0_DR_CLR
N#define LOCK_INT__DR_INV CYREG_GPIO_PRT0_DR_INV
N#define LOCK_INT__DR_SET CYREG_GPIO_PRT0_DR_SET
N#define LOCK_INT__INTCFG CYREG_GPIO_PRT0_INTR_CFG
N#define LOCK_INT__INTR CYREG_GPIO_PRT0_INTR
N#define LOCK_INT__INTR_CFG CYREG_GPIO_PRT0_INTR_CFG
N#define LOCK_INT__INTSTAT CYREG_GPIO_PRT0_INTR
N#define LOCK_INT__LOCK_BNT_INT__DR CYREG_GPIO_PRT0_DR
N#define LOCK_INT__LOCK_BNT_INT__DR_CLR CYREG_GPIO_PRT0_DR_CLR
N#define LOCK_INT__LOCK_BNT_INT__DR_INV CYREG_GPIO_PRT0_DR_INV
N#define LOCK_INT__LOCK_BNT_INT__DR_SET CYREG_GPIO_PRT0_DR_SET
N#define LOCK_INT__LOCK_BNT_INT__INTCFG CYREG_GPIO_PRT0_INTR_CFG
N#define LOCK_INT__LOCK_BNT_INT__INTR CYREG_GPIO_PRT0_INTR
N#define LOCK_INT__LOCK_BNT_INT__INTR_CFG CYREG_GPIO_PRT0_INTR_CFG
N#define LOCK_INT__LOCK_BNT_INT__INTSTAT CYREG_GPIO_PRT0_INTR
N#define LOCK_INT__LOCK_BNT_INT__MASK 0x02u
N#define LOCK_INT__LOCK_BNT_INT__PC CYREG_GPIO_PRT0_PC
N#define LOCK_INT__LOCK_BNT_INT__PC2 CYREG_GPIO_PRT0_PC2
N#define LOCK_INT__LOCK_BNT_INT__PORT 0u
N#define LOCK_INT__LOCK_BNT_INT__PS CYREG_GPIO_PRT0_PS
N#define LOCK_INT__LOCK_BNT_INT__SHIFT 1u
N#define LOCK_INT__LOCK_MODE_INT__DR CYREG_GPIO_PRT0_DR
N#define LOCK_INT__LOCK_MODE_INT__DR_CLR CYREG_GPIO_PRT0_DR_CLR
N#define LOCK_INT__LOCK_MODE_INT__DR_INV CYREG_GPIO_PRT0_DR_INV
N#define LOCK_INT__LOCK_MODE_INT__DR_SET CYREG_GPIO_PRT0_DR_SET
N#define LOCK_INT__LOCK_MODE_INT__INTCFG CYREG_GPIO_PRT0_INTR_CFG
N#define LOCK_INT__LOCK_MODE_INT__INTR CYREG_GPIO_PRT0_INTR
N#define LOCK_INT__LOCK_MODE_INT__INTR_CFG CYREG_GPIO_PRT0_INTR_CFG
N#define LOCK_INT__LOCK_MODE_INT__INTSTAT CYREG_GPIO_PRT0_INTR
N#define LOCK_INT__LOCK_MODE_INT__MASK 0x04u
N#define LOCK_INT__LOCK_MODE_INT__PC CYREG_GPIO_PRT0_PC
N#define LOCK_INT__LOCK_MODE_INT__PC2 CYREG_GPIO_PRT0_PC2
N#define LOCK_INT__LOCK_MODE_INT__PORT 0u
N#define LOCK_INT__LOCK_MODE_INT__PS CYREG_GPIO_PRT0_PS
N#define LOCK_INT__LOCK_MODE_INT__SHIFT 2u
N#define LOCK_INT__LOCK_SLOT_INT__DR CYREG_GPIO_PRT0_DR
N#define LOCK_INT__LOCK_SLOT_INT__DR_CLR CYREG_GPIO_PRT0_DR_CLR
N#define LOCK_INT__LOCK_SLOT_INT__DR_INV CYREG_GPIO_PRT0_DR_INV
N#define LOCK_INT__LOCK_SLOT_INT__DR_SET CYREG_GPIO_PRT0_DR_SET
N#define LOCK_INT__LOCK_SLOT_INT__INTCFG CYREG_GPIO_PRT0_INTR_CFG
N#define LOCK_INT__LOCK_SLOT_INT__INTR CYREG_GPIO_PRT0_INTR
N#define LOCK_INT__LOCK_SLOT_INT__INTR_CFG CYREG_GPIO_PRT0_INTR_CFG
N#define LOCK_INT__LOCK_SLOT_INT__INTSTAT CYREG_GPIO_PRT0_INTR
N#define LOCK_INT__LOCK_SLOT_INT__MASK 0x08u
N#define LOCK_INT__LOCK_SLOT_INT__PC CYREG_GPIO_PRT0_PC
N#define LOCK_INT__LOCK_SLOT_INT__PC2 CYREG_GPIO_PRT0_PC2
N#define LOCK_INT__LOCK_SLOT_INT__PORT 0u
N#define LOCK_INT__LOCK_SLOT_INT__PS CYREG_GPIO_PRT0_PS
N#define LOCK_INT__LOCK_SLOT_INT__SHIFT 3u
N#define LOCK_INT__MASK 0x0Fu
N#define LOCK_INT__OP2INT__DR CYREG_GPIO_PRT0_DR
N#define LOCK_INT__OP2INT__DR_CLR CYREG_GPIO_PRT0_DR_CLR
N#define LOCK_INT__OP2INT__DR_INV CYREG_GPIO_PRT0_DR_INV
N#define LOCK_INT__OP2INT__DR_SET CYREG_GPIO_PRT0_DR_SET
N#define LOCK_INT__OP2INT__INTCFG CYREG_GPIO_PRT0_INTR_CFG
N#define LOCK_INT__OP2INT__INTR CYREG_GPIO_PRT0_INTR
N#define LOCK_INT__OP2INT__INTR_CFG CYREG_GPIO_PRT0_INTR_CFG
N#define LOCK_INT__OP2INT__INTSTAT CYREG_GPIO_PRT0_INTR
N#define LOCK_INT__OP2INT__MASK 0x01u
N#define LOCK_INT__OP2INT__PC CYREG_GPIO_PRT0_PC
N#define LOCK_INT__OP2INT__PC2 CYREG_GPIO_PRT0_PC2
N#define LOCK_INT__OP2INT__PORT 0u
N#define LOCK_INT__OP2INT__PS CYREG_GPIO_PRT0_PS
N#define LOCK_INT__OP2INT__SHIFT 0u
N#define LOCK_INT__PC CYREG_GPIO_PRT0_PC
N#define LOCK_INT__PC2 CYREG_GPIO_PRT0_PC2
N#define LOCK_INT__PORT 0u
N#define LOCK_INT__PS CYREG_GPIO_PRT0_PS
N#define LOCK_INT__SHIFT 0u
N#define LOCK_INT__SNAP CYREG_GPIO_PRT0_INTR
N
N/* MOTO_ADC */
N#define MOTO_ADC__0__DR CYREG_GPIO_PRT2_DR
N#define MOTO_ADC__0__DR_CLR CYREG_GPIO_PRT2_DR_CLR
N#define MOTO_ADC__0__DR_INV CYREG_GPIO_PRT2_DR_INV
N#define MOTO_ADC__0__DR_SET CYREG_GPIO_PRT2_DR_SET
N#define MOTO_ADC__0__HSIOM CYREG_HSIOM_PORT_SEL2
N#define MOTO_ADC__0__HSIOM_MASK 0x0F000000u
N#define MOTO_ADC__0__HSIOM_SHIFT 24u
N#define MOTO_ADC__0__INTCFG CYREG_GPIO_PRT2_INTR_CFG
N#define MOTO_ADC__0__INTR CYREG_GPIO_PRT2_INTR
N#define MOTO_ADC__0__INTR_CFG CYREG_GPIO_PRT2_INTR_CFG
N#define MOTO_ADC__0__INTSTAT CYREG_GPIO_PRT2_INTR
N#define MOTO_ADC__0__MASK 0x40u
N#define MOTO_ADC__0__PC CYREG_GPIO_PRT2_PC
N#define MOTO_ADC__0__PC2 CYREG_GPIO_PRT2_PC2
N#define MOTO_ADC__0__PORT 2u
N#define MOTO_ADC__0__PS CYREG_GPIO_PRT2_PS
N#define MOTO_ADC__0__SHIFT 6u
N#define MOTO_ADC__DR CYREG_GPIO_PRT2_DR
N#define MOTO_ADC__DR_CLR CYREG_GPIO_PRT2_DR_CLR
N#define MOTO_ADC__DR_INV CYREG_GPIO_PRT2_DR_INV
N#define MOTO_ADC__DR_SET CYREG_GPIO_PRT2_DR_SET
N#define MOTO_ADC__INTCFG CYREG_GPIO_PRT2_INTR_CFG
N#define MOTO_ADC__INTR CYREG_GPIO_PRT2_INTR
N#define MOTO_ADC__INTR_CFG CYREG_GPIO_PRT2_INTR_CFG
N#define MOTO_ADC__INTSTAT CYREG_GPIO_PRT2_INTR
N#define MOTO_ADC__MASK 0x40u
N#define MOTO_ADC__PC CYREG_GPIO_PRT2_PC
N#define MOTO_ADC__PC2 CYREG_GPIO_PRT2_PC2
N#define MOTO_ADC__PORT 2u
N#define MOTO_ADC__PS CYREG_GPIO_PRT2_PS
N#define MOTO_ADC__SHIFT 6u
N
N/* Opamp_Rf */
N#define Opamp_Rf_cy_psoc4_abuf__COMP_STAT CYREG_CTBM0_COMP_STAT
N#define Opamp_Rf_cy_psoc4_abuf__COMP_STAT_SHIFT 0u
N#define Opamp_Rf_cy_psoc4_abuf__CTBM_CTB_CTRL CYREG_CTBM0_CTB_CTRL
N#define Opamp_Rf_cy_psoc4_abuf__INTR CYREG_CTBM0_INTR
N#define Opamp_Rf_cy_psoc4_abuf__INTR_MASK CYREG_CTBM0_INTR_MASK
N#define Opamp_Rf_cy_psoc4_abuf__INTR_MASK_SHIFT 0u
N#define Opamp_Rf_cy_psoc4_abuf__INTR_MASKED CYREG_CTBM0_INTR_MASKED
N#define Opamp_Rf_cy_psoc4_abuf__INTR_MASKED_SHIFT 0u
N#define Opamp_Rf_cy_psoc4_abuf__INTR_SET CYREG_CTBM0_INTR_SET
N#define Opamp_Rf_cy_psoc4_abuf__INTR_SET_SHIFT 0u
N#define Opamp_Rf_cy_psoc4_abuf__INTR_SHIFT 0u
N#define Opamp_Rf_cy_psoc4_abuf__OA_COMP_TRIM CYREG_CTBM0_OA0_COMP_TRIM
N#define Opamp_Rf_cy_psoc4_abuf__OA_NUMBER 0u
N#define Opamp_Rf_cy_psoc4_abuf__OA_OFFSET_TRIM CYREG_CTBM0_OA0_OFFSET_TRIM
N#define Opamp_Rf_cy_psoc4_abuf__OA_RES_CTRL CYREG_CTBM0_OA_RES0_CTRL
N#define Opamp_Rf_cy_psoc4_abuf__OA_SLOPE_OFFSET_TRIM CYREG_CTBM0_OA0_SLOPE_OFFSET_TRIM
N#define Opamp_Rf_cy_psoc4_abuf__OA_SW CYREG_CTBM0_OA0_SW
N#define Opamp_Rf_cy_psoc4_abuf__OA_SW_CLEAR CYREG_CTBM0_OA0_SW_CLEAR
N
N/* GPIO_ISR1 */
N#define GPIO_ISR1__0__DR CYREG_GPIO_PRT1_DR
N#define GPIO_ISR1__0__DR_CLR CYREG_GPIO_PRT1_DR_CLR
N#define GPIO_ISR1__0__DR_INV CYREG_GPIO_PRT1_DR_INV
N#define GPIO_ISR1__0__DR_SET CYREG_GPIO_PRT1_DR_SET
N#define GPIO_ISR1__0__HSIOM CYREG_HSIOM_PORT_SEL1
N#define GPIO_ISR1__0__HSIOM_MASK 0x00000F00u
N#define GPIO_ISR1__0__HSIOM_SHIFT 8u
N#define GPIO_ISR1__0__INTCFG CYREG_GPIO_PRT1_INTR_CFG
N#define GPIO_ISR1__0__INTR CYREG_GPIO_PRT1_INTR
N#define GPIO_ISR1__0__INTR_CFG CYREG_GPIO_PRT1_INTR_CFG
N#define GPIO_ISR1__0__INTSTAT CYREG_GPIO_PRT1_INTR
N#define GPIO_ISR1__0__MASK 0x04u
N#define GPIO_ISR1__0__PC CYREG_GPIO_PRT1_PC
N#define GPIO_ISR1__0__PC2 CYREG_GPIO_PRT1_PC2
N#define GPIO_ISR1__0__PORT 1u
N#define GPIO_ISR1__0__PS CYREG_GPIO_PRT1_PS
N#define GPIO_ISR1__0__SHIFT 2u
N#define GPIO_ISR1__1__DR CYREG_GPIO_PRT1_DR
N#define GPIO_ISR1__1__DR_CLR CYREG_GPIO_PRT1_DR_CLR
N#define GPIO_ISR1__1__DR_INV CYREG_GPIO_PRT1_DR_INV
N#define GPIO_ISR1__1__DR_SET CYREG_GPIO_PRT1_DR_SET
N#define GPIO_ISR1__1__HSIOM CYREG_HSIOM_PORT_SEL1
N#define GPIO_ISR1__1__HSIOM_MASK 0x0000F000u
N#define GPIO_ISR1__1__HSIOM_SHIFT 12u
N#define GPIO_ISR1__1__INTCFG CYREG_GPIO_PRT1_INTR_CFG
N#define GPIO_ISR1__1__INTR CYREG_GPIO_PRT1_INTR
N#define GPIO_ISR1__1__INTR_CFG CYREG_GPIO_PRT1_INTR_CFG
N#define GPIO_ISR1__1__INTSTAT CYREG_GPIO_PRT1_INTR
N#define GPIO_ISR1__1__MASK 0x08u
N#define GPIO_ISR1__1__PC CYREG_GPIO_PRT1_PC
N#define GPIO_ISR1__1__PC2 CYREG_GPIO_PRT1_PC2
N#define GPIO_ISR1__1__PORT 1u
N#define GPIO_ISR1__1__PS CYREG_GPIO_PRT1_PS
N#define GPIO_ISR1__1__SHIFT 3u
N#define GPIO_ISR1__2__DR CYREG_GPIO_PRT1_DR
N#define GPIO_ISR1__2__DR_CLR CYREG_GPIO_PRT1_DR_CLR
N#define GPIO_ISR1__2__DR_INV CYREG_GPIO_PRT1_DR_INV
N#define GPIO_ISR1__2__DR_SET CYREG_GPIO_PRT1_DR_SET
N#define GPIO_ISR1__2__HSIOM CYREG_HSIOM_PORT_SEL1
N#define GPIO_ISR1__2__HSIOM_MASK 0x000F0000u
N#define GPIO_ISR1__2__HSIOM_SHIFT 16u
N#define GPIO_ISR1__2__INTCFG CYREG_GPIO_PRT1_INTR_CFG
N#define GPIO_ISR1__2__INTR CYREG_GPIO_PRT1_INTR
N#define GPIO_ISR1__2__INTR_CFG CYREG_GPIO_PRT1_INTR_CFG
N#define GPIO_ISR1__2__INTSTAT CYREG_GPIO_PRT1_INTR
N#define GPIO_ISR1__2__MASK 0x10u
N#define GPIO_ISR1__2__PC CYREG_GPIO_PRT1_PC
N#define GPIO_ISR1__2__PC2 CYREG_GPIO_PRT1_PC2
N#define GPIO_ISR1__2__PORT 1u
N#define GPIO_ISR1__2__PS CYREG_GPIO_PRT1_PS
N#define GPIO_ISR1__2__SHIFT 4u
N#define GPIO_ISR1__3__DR CYREG_GPIO_PRT1_DR
N#define GPIO_ISR1__3__DR_CLR CYREG_GPIO_PRT1_DR_CLR
N#define GPIO_ISR1__3__DR_INV CYREG_GPIO_PRT1_DR_INV
N#define GPIO_ISR1__3__DR_SET CYREG_GPIO_PRT1_DR_SET
N#define GPIO_ISR1__3__HSIOM CYREG_HSIOM_PORT_SEL1
N#define GPIO_ISR1__3__HSIOM_MASK 0x00F00000u
N#define GPIO_ISR1__3__HSIOM_SHIFT 20u
N#define GPIO_ISR1__3__INTCFG CYREG_GPIO_PRT1_INTR_CFG
N#define GPIO_ISR1__3__INTR CYREG_GPIO_PRT1_INTR
N#define GPIO_ISR1__3__INTR_CFG CYREG_GPIO_PRT1_INTR_CFG
N#define GPIO_ISR1__3__INTSTAT CYREG_GPIO_PRT1_INTR
N#define GPIO_ISR1__3__MASK 0x20u
N#define GPIO_ISR1__3__PC CYREG_GPIO_PRT1_PC
N#define GPIO_ISR1__3__PC2 CYREG_GPIO_PRT1_PC2
N#define GPIO_ISR1__3__PORT 1u
N#define GPIO_ISR1__3__PS CYREG_GPIO_PRT1_PS
N#define GPIO_ISR1__3__SHIFT 5u
N#define GPIO_ISR1__BLE_INT__DR CYREG_GPIO_PRT1_DR
N#define GPIO_ISR1__BLE_INT__DR_CLR CYREG_GPIO_PRT1_DR_CLR
N#define GPIO_ISR1__BLE_INT__DR_INV CYREG_GPIO_PRT1_DR_INV
N#define GPIO_ISR1__BLE_INT__DR_SET CYREG_GPIO_PRT1_DR_SET
N#define GPIO_ISR1__BLE_INT__INTCFG CYREG_GPIO_PRT1_INTR_CFG
N#define GPIO_ISR1__BLE_INT__INTR CYREG_GPIO_PRT1_INTR
N#define GPIO_ISR1__BLE_INT__INTR_CFG CYREG_GPIO_PRT1_INTR_CFG
N#define GPIO_ISR1__BLE_INT__INTSTAT CYREG_GPIO_PRT1_INTR
N#define GPIO_ISR1__BLE_INT__MASK 0x10u
N#define GPIO_ISR1__BLE_INT__PC CYREG_GPIO_PRT1_PC
N#define GPIO_ISR1__BLE_INT__PC2 CYREG_GPIO_PRT1_PC2
N#define GPIO_ISR1__BLE_INT__PORT 1u
N#define GPIO_ISR1__BLE_INT__PS CYREG_GPIO_PRT1_PS
N#define GPIO_ISR1__BLE_INT__SHIFT 4u
N#define GPIO_ISR1__DR CYREG_GPIO_PRT1_DR
N#define GPIO_ISR1__DR_CLR CYREG_GPIO_PRT1_DR_CLR
N#define GPIO_ISR1__DR_INV CYREG_GPIO_PRT1_DR_INV
N#define GPIO_ISR1__DR_SET CYREG_GPIO_PRT1_DR_SET
N#define GPIO_ISR1__EXT_UART_2_INT__DR CYREG_GPIO_PRT1_DR
N#define GPIO_ISR1__EXT_UART_2_INT__DR_CLR CYREG_GPIO_PRT1_DR_CLR
N#define GPIO_ISR1__EXT_UART_2_INT__DR_INV CYREG_GPIO_PRT1_DR_INV
N#define GPIO_ISR1__EXT_UART_2_INT__DR_SET CYREG_GPIO_PRT1_DR_SET
N#define GPIO_ISR1__EXT_UART_2_INT__INTCFG CYREG_GPIO_PRT1_INTR_CFG
N#define GPIO_ISR1__EXT_UART_2_INT__INTR CYREG_GPIO_PRT1_INTR
N#define GPIO_ISR1__EXT_UART_2_INT__INTR_CFG CYREG_GPIO_PRT1_INTR_CFG
N#define GPIO_ISR1__EXT_UART_2_INT__INTSTAT CYREG_GPIO_PRT1_INTR
N#define GPIO_ISR1__EXT_UART_2_INT__MASK 0x08u
N#define GPIO_ISR1__EXT_UART_2_INT__PC CYREG_GPIO_PRT1_PC
N#define GPIO_ISR1__EXT_UART_2_INT__PC2 CYREG_GPIO_PRT1_PC2
N#define GPIO_ISR1__EXT_UART_2_INT__PORT 1u
N#define GPIO_ISR1__EXT_UART_2_INT__PS CYREG_GPIO_PRT1_PS
N#define GPIO_ISR1__EXT_UART_2_INT__SHIFT 3u
N#define GPIO_ISR1__FPC_UART_0_INT__DR CYREG_GPIO_PRT1_DR
N#define GPIO_ISR1__FPC_UART_0_INT__DR_CLR CYREG_GPIO_PRT1_DR_CLR
N#define GPIO_ISR1__FPC_UART_0_INT__DR_INV CYREG_GPIO_PRT1_DR_INV
N#define GPIO_ISR1__FPC_UART_0_INT__DR_SET CYREG_GPIO_PRT1_DR_SET
N#define GPIO_ISR1__FPC_UART_0_INT__INTCFG CYREG_GPIO_PRT1_INTR_CFG
N#define GPIO_ISR1__FPC_UART_0_INT__INTR CYREG_GPIO_PRT1_INTR
N#define GPIO_ISR1__FPC_UART_0_INT__INTR_CFG CYREG_GPIO_PRT1_INTR_CFG
N#define GPIO_ISR1__FPC_UART_0_INT__INTSTAT CYREG_GPIO_PRT1_INTR
N#define GPIO_ISR1__FPC_UART_0_INT__MASK 0x20u
N#define GPIO_ISR1__FPC_UART_0_INT__PC CYREG_GPIO_PRT1_PC
N#define GPIO_ISR1__FPC_UART_0_INT__PC2 CYREG_GPIO_PRT1_PC2
N#define GPIO_ISR1__FPC_UART_0_INT__PORT 1u
N#define GPIO_ISR1__FPC_UART_0_INT__PS CYREG_GPIO_PRT1_PS
N#define GPIO_ISR1__FPC_UART_0_INT__SHIFT 5u
N#define GPIO_ISR1__INTCFG CYREG_GPIO_PRT1_INTR_CFG
N#define GPIO_ISR1__INTR CYREG_GPIO_PRT1_INTR
N#define GPIO_ISR1__INTR_CFG CYREG_GPIO_PRT1_INTR_CFG
N#define GPIO_ISR1__INTSTAT CYREG_GPIO_PRT1_INTR
N#define GPIO_ISR1__KEY_INT__DR CYREG_GPIO_PRT1_DR
N#define GPIO_ISR1__KEY_INT__DR_CLR CYREG_GPIO_PRT1_DR_CLR
N#define GPIO_ISR1__KEY_INT__DR_INV CYREG_GPIO_PRT1_DR_INV
N#define GPIO_ISR1__KEY_INT__DR_SET CYREG_GPIO_PRT1_DR_SET
N#define GPIO_ISR1__KEY_INT__INTCFG CYREG_GPIO_PRT1_INTR_CFG
N#define GPIO_ISR1__KEY_INT__INTR CYREG_GPIO_PRT1_INTR
N#define GPIO_ISR1__KEY_INT__INTR_CFG CYREG_GPIO_PRT1_INTR_CFG
N#define GPIO_ISR1__KEY_INT__INTSTAT CYREG_GPIO_PRT1_INTR
N#define GPIO_ISR1__KEY_INT__MASK 0x04u
N#define GPIO_ISR1__KEY_INT__PC CYREG_GPIO_PRT1_PC
N#define GPIO_ISR1__KEY_INT__PC2 CYREG_GPIO_PRT1_PC2
N#define GPIO_ISR1__KEY_INT__PORT 1u
N#define GPIO_ISR1__KEY_INT__PS CYREG_GPIO_PRT1_PS
N#define GPIO_ISR1__KEY_INT__SHIFT 2u
N#define GPIO_ISR1__MASK 0x3Cu
N#define GPIO_ISR1__PC CYREG_GPIO_PRT1_PC
N#define GPIO_ISR1__PC2 CYREG_GPIO_PRT1_PC2
N#define GPIO_ISR1__PORT 1u
N#define GPIO_ISR1__PS CYREG_GPIO_PRT1_PS
N#define GPIO_ISR1__SHIFT 2u
N#define GPIO_ISR1__SNAP CYREG_GPIO_PRT1_INTR
N
N/* Opamp_Bat */
N#define Opamp_Bat_cy_psoc4_abuf__COMP_STAT CYREG_CTBM0_COMP_STAT
N#define Opamp_Bat_cy_psoc4_abuf__COMP_STAT_SHIFT 16u
N#define Opamp_Bat_cy_psoc4_abuf__CTBM_CTB_CTRL CYREG_CTBM0_CTB_CTRL
N#define Opamp_Bat_cy_psoc4_abuf__INTR CYREG_CTBM0_INTR
N#define Opamp_Bat_cy_psoc4_abuf__INTR_MASK CYREG_CTBM0_INTR_MASK
N#define Opamp_Bat_cy_psoc4_abuf__INTR_MASK_SHIFT 1u
N#define Opamp_Bat_cy_psoc4_abuf__INTR_MASKED CYREG_CTBM0_INTR_MASKED
N#define Opamp_Bat_cy_psoc4_abuf__INTR_MASKED_SHIFT 1u
N#define Opamp_Bat_cy_psoc4_abuf__INTR_SET CYREG_CTBM0_INTR_SET
N#define Opamp_Bat_cy_psoc4_abuf__INTR_SET_SHIFT 1u
N#define Opamp_Bat_cy_psoc4_abuf__INTR_SHIFT 1u
N#define Opamp_Bat_cy_psoc4_abuf__OA_COMP_TRIM CYREG_CTBM0_OA1_COMP_TRIM
N#define Opamp_Bat_cy_psoc4_abuf__OA_NUMBER 1u
N#define Opamp_Bat_cy_psoc4_abuf__OA_OFFSET_TRIM CYREG_CTBM0_OA1_OFFSET_TRIM
N#define Opamp_Bat_cy_psoc4_abuf__OA_RES_CTRL CYREG_CTBM0_OA_RES1_CTRL
N#define Opamp_Bat_cy_psoc4_abuf__OA_SLOPE_OFFSET_TRIM CYREG_CTBM0_OA1_SLOPE_OFFSET_TRIM
N#define Opamp_Bat_cy_psoc4_abuf__OA_SW CYREG_CTBM0_OA1_SW
N#define Opamp_Bat_cy_psoc4_abuf__OA_SW_CLEAR CYREG_CTBM0_OA1_SW_CLEAR
N
N/* CARD_RESET */
N#define CARD_RESET__0__DR CYREG_GPIO_PRT5_DR
N#define CARD_RESET__0__DR_CLR CYREG_GPIO_PRT5_DR_CLR
N#define CARD_RESET__0__DR_INV CYREG_GPIO_PRT5_DR_INV
N#define CARD_RESET__0__DR_SET CYREG_GPIO_PRT5_DR_SET
N#define CARD_RESET__0__HSIOM CYREG_HSIOM_PORT_SEL5
N#define CARD_RESET__0__HSIOM_MASK 0x00F00000u
N#define CARD_RESET__0__HSIOM_SHIFT 20u
N#define CARD_RESET__0__INTCFG CYREG_GPIO_PRT5_INTR_CFG
N#define CARD_RESET__0__INTR CYREG_GPIO_PRT5_INTR
N#define CARD_RESET__0__INTR_CFG CYREG_GPIO_PRT5_INTR_CFG
N#define CARD_RESET__0__INTSTAT CYREG_GPIO_PRT5_INTR
N#define CARD_RESET__0__MASK 0x20u
N#define CARD_RESET__0__PC CYREG_GPIO_PRT5_PC
N#define CARD_RESET__0__PC2 CYREG_GPIO_PRT5_PC2
N#define CARD_RESET__0__PORT 5u
N#define CARD_RESET__0__PS CYREG_GPIO_PRT5_PS
N#define CARD_RESET__0__SHIFT 5u
N#define CARD_RESET__DR CYREG_GPIO_PRT5_DR
N#define CARD_RESET__DR_CLR CYREG_GPIO_PRT5_DR_CLR
N#define CARD_RESET__DR_INV CYREG_GPIO_PRT5_DR_INV
N#define CARD_RESET__DR_SET CYREG_GPIO_PRT5_DR_SET
N#define CARD_RESET__INTCFG CYREG_GPIO_PRT5_INTR_CFG
N#define CARD_RESET__INTR CYREG_GPIO_PRT5_INTR
N#define CARD_RESET__INTR_CFG CYREG_GPIO_PRT5_INTR_CFG
N#define CARD_RESET__INTSTAT CYREG_GPIO_PRT5_INTR
N#define CARD_RESET__MASK 0x20u
N#define CARD_RESET__PC CYREG_GPIO_PRT5_PC
N#define CARD_RESET__PC2 CYREG_GPIO_PRT5_PC2
N#define CARD_RESET__PORT 5u
N#define CARD_RESET__PS CYREG_GPIO_PRT5_PS
N#define CARD_RESET__SHIFT 5u
N
N/* SPI_1_CARD */
N#define SPI_1_CARD_miso_m__0__DR CYREG_GPIO_PRT4_DR
N#define SPI_1_CARD_miso_m__0__DR_CLR CYREG_GPIO_PRT4_DR_CLR
N#define SPI_1_CARD_miso_m__0__DR_INV CYREG_GPIO_PRT4_DR_INV
N#define SPI_1_CARD_miso_m__0__DR_SET CYREG_GPIO_PRT4_DR_SET
N#define SPI_1_CARD_miso_m__0__HSIOM CYREG_HSIOM_PORT_SEL4
N#define SPI_1_CARD_miso_m__0__HSIOM_GPIO 0u
N#define SPI_1_CARD_miso_m__0__HSIOM_MASK 0x00F00000u
N#define SPI_1_CARD_miso_m__0__HSIOM_SHIFT 20u
N#define SPI_1_CARD_miso_m__0__HSIOM_SPI 14u
N#define SPI_1_CARD_miso_m__0__HSIOM_SPI_MISO 14u
N#define SPI_1_CARD_miso_m__0__HSIOM_UART 9u
N#define SPI_1_CARD_miso_m__0__HSIOM_UART_TX 9u
N#define SPI_1_CARD_miso_m__0__INTCFG CYREG_GPIO_PRT4_INTR_CFG
N#define SPI_1_CARD_miso_m__0__INTR CYREG_GPIO_PRT4_INTR
N#define SPI_1_CARD_miso_m__0__INTR_CFG CYREG_GPIO_PRT4_INTR_CFG
N#define SPI_1_CARD_miso_m__0__INTSTAT CYREG_GPIO_PRT4_INTR
N#define SPI_1_CARD_miso_m__0__MASK 0x20u
N#define SPI_1_CARD_miso_m__0__PC CYREG_GPIO_PRT4_PC
N#define SPI_1_CARD_miso_m__0__PC2 CYREG_GPIO_PRT4_PC2
N#define SPI_1_CARD_miso_m__0__PORT 4u
N#define SPI_1_CARD_miso_m__0__PS CYREG_GPIO_PRT4_PS
N#define SPI_1_CARD_miso_m__0__SHIFT 5u
N#define SPI_1_CARD_miso_m__DR CYREG_GPIO_PRT4_DR
N#define SPI_1_CARD_miso_m__DR_CLR CYREG_GPIO_PRT4_DR_CLR
N#define SPI_1_CARD_miso_m__DR_INV CYREG_GPIO_PRT4_DR_INV
N#define SPI_1_CARD_miso_m__DR_SET CYREG_GPIO_PRT4_DR_SET
N#define SPI_1_CARD_miso_m__INTCFG CYREG_GPIO_PRT4_INTR_CFG
N#define SPI_1_CARD_miso_m__INTR CYREG_GPIO_PRT4_INTR
N#define SPI_1_CARD_miso_m__INTR_CFG CYREG_GPIO_PRT4_INTR_CFG
N#define SPI_1_CARD_miso_m__INTSTAT CYREG_GPIO_PRT4_INTR
N#define SPI_1_CARD_miso_m__MASK 0x20u
N#define SPI_1_CARD_miso_m__PC CYREG_GPIO_PRT4_PC
N#define SPI_1_CARD_miso_m__PC2 CYREG_GPIO_PRT4_PC2
N#define SPI_1_CARD_miso_m__PORT 4u
N#define SPI_1_CARD_miso_m__PS CYREG_GPIO_PRT4_PS
N#define SPI_1_CARD_miso_m__SHIFT 5u
N#define SPI_1_CARD_mosi_m__0__DR CYREG_GPIO_PRT4_DR
N#define SPI_1_CARD_mosi_m__0__DR_CLR CYREG_GPIO_PRT4_DR_CLR
N#define SPI_1_CARD_mosi_m__0__DR_INV CYREG_GPIO_PRT4_DR_INV
N#define SPI_1_CARD_mosi_m__0__DR_SET CYREG_GPIO_PRT4_DR_SET
N#define SPI_1_CARD_mosi_m__0__HSIOM CYREG_HSIOM_PORT_SEL4
N#define SPI_1_CARD_mosi_m__0__HSIOM_GPIO 0u
N#define SPI_1_CARD_mosi_m__0__HSIOM_MASK 0x000F0000u
N#define SPI_1_CARD_mosi_m__0__HSIOM_SHIFT 16u
N#define SPI_1_CARD_mosi_m__0__HSIOM_SPI 14u
N#define SPI_1_CARD_mosi_m__0__HSIOM_SPI_MOSI 14u
N#define SPI_1_CARD_mosi_m__0__HSIOM_UART 9u
N#define SPI_1_CARD_mosi_m__0__HSIOM_UART_RX 9u
N#define SPI_1_CARD_mosi_m__0__INTCFG CYREG_GPIO_PRT4_INTR_CFG
N#define SPI_1_CARD_mosi_m__0__INTR CYREG_GPIO_PRT4_INTR
N#define SPI_1_CARD_mosi_m__0__INTR_CFG CYREG_GPIO_PRT4_INTR_CFG
N#define SPI_1_CARD_mosi_m__0__INTSTAT CYREG_GPIO_PRT4_INTR
N#define SPI_1_CARD_mosi_m__0__MASK 0x10u
N#define SPI_1_CARD_mosi_m__0__PC CYREG_GPIO_PRT4_PC
N#define SPI_1_CARD_mosi_m__0__PC2 CYREG_GPIO_PRT4_PC2
N#define SPI_1_CARD_mosi_m__0__PORT 4u
N#define SPI_1_CARD_mosi_m__0__PS CYREG_GPIO_PRT4_PS
N#define SPI_1_CARD_mosi_m__0__SHIFT 4u
N#define SPI_1_CARD_mosi_m__DR CYREG_GPIO_PRT4_DR
N#define SPI_1_CARD_mosi_m__DR_CLR CYREG_GPIO_PRT4_DR_CLR
N#define SPI_1_CARD_mosi_m__DR_INV CYREG_GPIO_PRT4_DR_INV
N#define SPI_1_CARD_mosi_m__DR_SET CYREG_GPIO_PRT4_DR_SET
N#define SPI_1_CARD_mosi_m__INTCFG CYREG_GPIO_PRT4_INTR_CFG
N#define SPI_1_CARD_mosi_m__INTR CYREG_GPIO_PRT4_INTR
N#define SPI_1_CARD_mosi_m__INTR_CFG CYREG_GPIO_PRT4_INTR_CFG
N#define SPI_1_CARD_mosi_m__INTSTAT CYREG_GPIO_PRT4_INTR
N#define SPI_1_CARD_mosi_m__MASK 0x10u
N#define SPI_1_CARD_mosi_m__PC CYREG_GPIO_PRT4_PC
N#define SPI_1_CARD_mosi_m__PC2 CYREG_GPIO_PRT4_PC2
N#define SPI_1_CARD_mosi_m__PORT 4u
N#define SPI_1_CARD_mosi_m__PS CYREG_GPIO_PRT4_PS
N#define SPI_1_CARD_mosi_m__SHIFT 4u
N#define SPI_1_CARD_SCB__CTRL CYREG_SCB4_CTRL
N#define SPI_1_CARD_SCB__EZ_DATA0 CYREG_SCB4_EZ_DATA0
N#define SPI_1_CARD_SCB__EZ_DATA1 CYREG_SCB4_EZ_DATA1
N#define SPI_1_CARD_SCB__EZ_DATA10 CYREG_SCB4_EZ_DATA10
N#define SPI_1_CARD_SCB__EZ_DATA11 CYREG_SCB4_EZ_DATA11
N#define SPI_1_CARD_SCB__EZ_DATA12 CYREG_SCB4_EZ_DATA12
N#define SPI_1_CARD_SCB__EZ_DATA13 CYREG_SCB4_EZ_DATA13
N#define SPI_1_CARD_SCB__EZ_DATA14 CYREG_SCB4_EZ_DATA14
N#define SPI_1_CARD_SCB__EZ_DATA15 CYREG_SCB4_EZ_DATA15
N#define SPI_1_CARD_SCB__EZ_DATA16 CYREG_SCB4_EZ_DATA16
N#define SPI_1_CARD_SCB__EZ_DATA17 CYREG_SCB4_EZ_DATA17
N#define SPI_1_CARD_SCB__EZ_DATA18 CYREG_SCB4_EZ_DATA18
N#define SPI_1_CARD_SCB__EZ_DATA19 CYREG_SCB4_EZ_DATA19
N#define SPI_1_CARD_SCB__EZ_DATA2 CYREG_SCB4_EZ_DATA2
N#define SPI_1_CARD_SCB__EZ_DATA20 CYREG_SCB4_EZ_DATA20
N#define SPI_1_CARD_SCB__EZ_DATA21 CYREG_SCB4_EZ_DATA21
N#define SPI_1_CARD_SCB__EZ_DATA22 CYREG_SCB4_EZ_DATA22
N#define SPI_1_CARD_SCB__EZ_DATA23 CYREG_SCB4_EZ_DATA23
N#define SPI_1_CARD_SCB__EZ_DATA24 CYREG_SCB4_EZ_DATA24
N#define SPI_1_CARD_SCB__EZ_DATA25 CYREG_SCB4_EZ_DATA25
N#define SPI_1_CARD_SCB__EZ_DATA26 CYREG_SCB4_EZ_DATA26
N#define SPI_1_CARD_SCB__EZ_DATA27 CYREG_SCB4_EZ_DATA27
N#define SPI_1_CARD_SCB__EZ_DATA28 CYREG_SCB4_EZ_DATA28
N#define SPI_1_CARD_SCB__EZ_DATA29 CYREG_SCB4_EZ_DATA29
N#define SPI_1_CARD_SCB__EZ_DATA3 CYREG_SCB4_EZ_DATA3
N#define SPI_1_CARD_SCB__EZ_DATA30 CYREG_SCB4_EZ_DATA30
N#define SPI_1_CARD_SCB__EZ_DATA31 CYREG_SCB4_EZ_DATA31
N#define SPI_1_CARD_SCB__EZ_DATA4 CYREG_SCB4_EZ_DATA4
N#define SPI_1_CARD_SCB__EZ_DATA5 CYREG_SCB4_EZ_DATA5
N#define SPI_1_CARD_SCB__EZ_DATA6 CYREG_SCB4_EZ_DATA6
N#define SPI_1_CARD_SCB__EZ_DATA7 CYREG_SCB4_EZ_DATA7
N#define SPI_1_CARD_SCB__EZ_DATA8 CYREG_SCB4_EZ_DATA8
N#define SPI_1_CARD_SCB__EZ_DATA9 CYREG_SCB4_EZ_DATA9
N#define SPI_1_CARD_SCB__I2C_CFG CYREG_SCB4_I2C_CFG
N#define SPI_1_CARD_SCB__I2C_CTRL CYREG_SCB4_I2C_CTRL
N#define SPI_1_CARD_SCB__I2C_M_CMD CYREG_SCB4_I2C_M_CMD
N#define SPI_1_CARD_SCB__I2C_S_CMD CYREG_SCB4_I2C_S_CMD
N#define SPI_1_CARD_SCB__I2C_STATUS CYREG_SCB4_I2C_STATUS
N#define SPI_1_CARD_SCB__INTR_CAUSE CYREG_SCB4_INTR_CAUSE
N#define SPI_1_CARD_SCB__INTR_I2C_EC CYREG_SCB4_INTR_I2C_EC
N#define SPI_1_CARD_SCB__INTR_I2C_EC_MASK CYREG_SCB4_INTR_I2C_EC_MASK
N#define SPI_1_CARD_SCB__INTR_I2C_EC_MASKED CYREG_SCB4_INTR_I2C_EC_MASKED
N#define SPI_1_CARD_SCB__INTR_M CYREG_SCB4_INTR_M
N#define SPI_1_CARD_SCB__INTR_M_MASK CYREG_SCB4_INTR_M_MASK
N#define SPI_1_CARD_SCB__INTR_M_MASKED CYREG_SCB4_INTR_M_MASKED
N#define SPI_1_CARD_SCB__INTR_M_SET CYREG_SCB4_INTR_M_SET
N#define SPI_1_CARD_SCB__INTR_RX CYREG_SCB4_INTR_RX
N#define SPI_1_CARD_SCB__INTR_RX_MASK CYREG_SCB4_INTR_RX_MASK
N#define SPI_1_CARD_SCB__INTR_RX_MASKED CYREG_SCB4_INTR_RX_MASKED
N#define SPI_1_CARD_SCB__INTR_RX_SET CYREG_SCB4_INTR_RX_SET
N#define SPI_1_CARD_SCB__INTR_S CYREG_SCB4_INTR_S
N#define SPI_1_CARD_SCB__INTR_S_MASK CYREG_SCB4_INTR_S_MASK
N#define SPI_1_CARD_SCB__INTR_S_MASKED CYREG_SCB4_INTR_S_MASKED
N#define SPI_1_CARD_SCB__INTR_S_SET CYREG_SCB4_INTR_S_SET
N#define SPI_1_CARD_SCB__INTR_SPI_EC CYREG_SCB4_INTR_SPI_EC
N#define SPI_1_CARD_SCB__INTR_SPI_EC_MASK CYREG_SCB4_INTR_SPI_EC_MASK
N#define SPI_1_CARD_SCB__INTR_SPI_EC_MASKED CYREG_SCB4_INTR_SPI_EC_MASKED
N#define SPI_1_CARD_SCB__INTR_TX CYREG_SCB4_INTR_TX
N#define SPI_1_CARD_SCB__INTR_TX_MASK CYREG_SCB4_INTR_TX_MASK
N#define SPI_1_CARD_SCB__INTR_TX_MASKED CYREG_SCB4_INTR_TX_MASKED
N#define SPI_1_CARD_SCB__INTR_TX_SET CYREG_SCB4_INTR_TX_SET
N#define SPI_1_CARD_SCB__RX_CTRL CYREG_SCB4_RX_CTRL
N#define SPI_1_CARD_SCB__RX_FIFO_CTRL CYREG_SCB4_RX_FIFO_CTRL
N#define SPI_1_CARD_SCB__RX_FIFO_RD CYREG_SCB4_RX_FIFO_RD
N#define SPI_1_CARD_SCB__RX_FIFO_RD_SILENT CYREG_SCB4_RX_FIFO_RD_SILENT
N#define SPI_1_CARD_SCB__RX_FIFO_STATUS CYREG_SCB4_RX_FIFO_STATUS
N#define SPI_1_CARD_SCB__RX_MATCH CYREG_SCB4_RX_MATCH
N#define SPI_1_CARD_SCB__SPI_CTRL CYREG_SCB4_SPI_CTRL
N#define SPI_1_CARD_SCB__SPI_STATUS CYREG_SCB4_SPI_STATUS
N#define SPI_1_CARD_SCB__SS0_POSISTION 0u
N#define SPI_1_CARD_SCB__SS1_POSISTION 1u
N#define SPI_1_CARD_SCB__SS2_POSISTION 2u
N#define SPI_1_CARD_SCB__SS3_POSISTION 3u
N#define SPI_1_CARD_SCB__STATUS CYREG_SCB4_STATUS
N#define SPI_1_CARD_SCB__TX_CTRL CYREG_SCB4_TX_CTRL
N#define SPI_1_CARD_SCB__TX_FIFO_CTRL CYREG_SCB4_TX_FIFO_CTRL
N#define SPI_1_CARD_SCB__TX_FIFO_STATUS CYREG_SCB4_TX_FIFO_STATUS
N#define SPI_1_CARD_SCB__TX_FIFO_WR CYREG_SCB4_TX_FIFO_WR
N#define SPI_1_CARD_SCB__UART_CTRL CYREG_SCB4_UART_CTRL
N#define SPI_1_CARD_SCB__UART_FLOW_CTRL CYREG_SCB4_UART_FLOW_CTRL
N#define SPI_1_CARD_SCB__UART_RX_CTRL CYREG_SCB4_UART_RX_CTRL
N#define SPI_1_CARD_SCB__UART_RX_STATUS CYREG_SCB4_UART_RX_STATUS
N#define SPI_1_CARD_SCB__UART_TX_CTRL CYREG_SCB4_UART_TX_CTRL
N#define SPI_1_CARD_SCBCLK__CTRL_REGISTER CYREG_PERI_PCLK_CTL4
N#define SPI_1_CARD_SCBCLK__DIV_ID 0x00000041u
N#define SPI_1_CARD_SCBCLK__DIV_REGISTER CYREG_PERI_DIV_16_CTL1
N#define SPI_1_CARD_SCBCLK__PA_DIV_ID 0x000000FFu
N#define SPI_1_CARD_sclk_m__0__DR CYREG_GPIO_PRT4_DR
N#define SPI_1_CARD_sclk_m__0__DR_CLR CYREG_GPIO_PRT4_DR_CLR
N#define SPI_1_CARD_sclk_m__0__DR_INV CYREG_GPIO_PRT4_DR_INV
N#define SPI_1_CARD_sclk_m__0__DR_SET CYREG_GPIO_PRT4_DR_SET
N#define SPI_1_CARD_sclk_m__0__HSIOM CYREG_HSIOM_PORT_SEL4
N#define SPI_1_CARD_sclk_m__0__HSIOM_GPIO 0u
N#define SPI_1_CARD_sclk_m__0__HSIOM_MASK 0x0F000000u
N#define SPI_1_CARD_sclk_m__0__HSIOM_SHIFT 24u
N#define SPI_1_CARD_sclk_m__0__HSIOM_SPI 14u
N#define SPI_1_CARD_sclk_m__0__HSIOM_SPI_CLK 14u
N#define SPI_1_CARD_sclk_m__0__HSIOM_UART 9u
N#define SPI_1_CARD_sclk_m__0__HSIOM_UART_CTS 9u
N#define SPI_1_CARD_sclk_m__0__INTCFG CYREG_GPIO_PRT4_INTR_CFG
N#define SPI_1_CARD_sclk_m__0__INTR CYREG_GPIO_PRT4_INTR
N#define SPI_1_CARD_sclk_m__0__INTR_CFG CYREG_GPIO_PRT4_INTR_CFG
N#define SPI_1_CARD_sclk_m__0__INTSTAT CYREG_GPIO_PRT4_INTR
N#define SPI_1_CARD_sclk_m__0__MASK 0x40u
N#define SPI_1_CARD_sclk_m__0__PC CYREG_GPIO_PRT4_PC
N#define SPI_1_CARD_sclk_m__0__PC2 CYREG_GPIO_PRT4_PC2
N#define SPI_1_CARD_sclk_m__0__PORT 4u
N#define SPI_1_CARD_sclk_m__0__PS CYREG_GPIO_PRT4_PS
N#define SPI_1_CARD_sclk_m__0__SHIFT 6u
N#define SPI_1_CARD_sclk_m__DR CYREG_GPIO_PRT4_DR
N#define SPI_1_CARD_sclk_m__DR_CLR CYREG_GPIO_PRT4_DR_CLR
N#define SPI_1_CARD_sclk_m__DR_INV CYREG_GPIO_PRT4_DR_INV
N#define SPI_1_CARD_sclk_m__DR_SET CYREG_GPIO_PRT4_DR_SET
N#define SPI_1_CARD_sclk_m__INTCFG CYREG_GPIO_PRT4_INTR_CFG
N#define SPI_1_CARD_sclk_m__INTR CYREG_GPIO_PRT4_INTR
N#define SPI_1_CARD_sclk_m__INTR_CFG CYREG_GPIO_PRT4_INTR_CFG
N#define SPI_1_CARD_sclk_m__INTSTAT CYREG_GPIO_PRT4_INTR
N#define SPI_1_CARD_sclk_m__MASK 0x40u
N#define SPI_1_CARD_sclk_m__PC CYREG_GPIO_PRT4_PC
N#define SPI_1_CARD_sclk_m__PC2 CYREG_GPIO_PRT4_PC2
N#define SPI_1_CARD_sclk_m__PORT 4u
N#define SPI_1_CARD_sclk_m__PS CYREG_GPIO_PRT4_PS
N#define SPI_1_CARD_sclk_m__SHIFT 6u
N#define SPI_1_CARD_ss0_m__0__DR CYREG_GPIO_PRT4_DR
N#define SPI_1_CARD_ss0_m__0__DR_CLR CYREG_GPIO_PRT4_DR_CLR
N#define SPI_1_CARD_ss0_m__0__DR_INV CYREG_GPIO_PRT4_DR_INV
N#define SPI_1_CARD_ss0_m__0__DR_SET CYREG_GPIO_PRT4_DR_SET
N#define SPI_1_CARD_ss0_m__0__HSIOM CYREG_HSIOM_PORT_SEL4
N#define SPI_1_CARD_ss0_m__0__HSIOM_GPIO 0u
N#define SPI_1_CARD_ss0_m__0__HSIOM_MASK 0xF0000000u
N#define SPI_1_CARD_ss0_m__0__HSIOM_SHIFT 28u
N#define SPI_1_CARD_ss0_m__0__HSIOM_SPI 14u
N#define SPI_1_CARD_ss0_m__0__HSIOM_SPI_SELECT0 14u
N#define SPI_1_CARD_ss0_m__0__HSIOM_UART 9u
N#define SPI_1_CARD_ss0_m__0__HSIOM_UART_RTS 9u
N#define SPI_1_CARD_ss0_m__0__INTCFG CYREG_GPIO_PRT4_INTR_CFG
N#define SPI_1_CARD_ss0_m__0__INTR CYREG_GPIO_PRT4_INTR
N#define SPI_1_CARD_ss0_m__0__INTR_CFG CYREG_GPIO_PRT4_INTR_CFG
N#define SPI_1_CARD_ss0_m__0__INTSTAT CYREG_GPIO_PRT4_INTR
N#define SPI_1_CARD_ss0_m__0__MASK 0x80u
N#define SPI_1_CARD_ss0_m__0__PC CYREG_GPIO_PRT4_PC
N#define SPI_1_CARD_ss0_m__0__PC2 CYREG_GPIO_PRT4_PC2
N#define SPI_1_CARD_ss0_m__0__PORT 4u
N#define SPI_1_CARD_ss0_m__0__PS CYREG_GPIO_PRT4_PS
N#define SPI_1_CARD_ss0_m__0__SHIFT 7u
N#define SPI_1_CARD_ss0_m__DR CYREG_GPIO_PRT4_DR
N#define SPI_1_CARD_ss0_m__DR_CLR CYREG_GPIO_PRT4_DR_CLR
N#define SPI_1_CARD_ss0_m__DR_INV CYREG_GPIO_PRT4_DR_INV
N#define SPI_1_CARD_ss0_m__DR_SET CYREG_GPIO_PRT4_DR_SET
N#define SPI_1_CARD_ss0_m__INTCFG CYREG_GPIO_PRT4_INTR_CFG
N#define SPI_1_CARD_ss0_m__INTR CYREG_GPIO_PRT4_INTR
N#define SPI_1_CARD_ss0_m__INTR_CFG CYREG_GPIO_PRT4_INTR_CFG
N#define SPI_1_CARD_ss0_m__INTSTAT CYREG_GPIO_PRT4_INTR
N#define SPI_1_CARD_ss0_m__MASK 0x80u
N#define SPI_1_CARD_ss0_m__PC CYREG_GPIO_PRT4_PC
N#define SPI_1_CARD_ss0_m__PC2 CYREG_GPIO_PRT4_PC2
N#define SPI_1_CARD_ss0_m__PORT 4u
N#define SPI_1_CARD_ss0_m__PS CYREG_GPIO_PRT4_PS
N#define SPI_1_CARD_ss0_m__SHIFT 7u
N
N/* UART_0_FPC */
N#define UART_0_FPC_rx__0__DR CYREG_GPIO_PRT6_DR
N#define UART_0_FPC_rx__0__DR_CLR CYREG_GPIO_PRT6_DR_CLR
N#define UART_0_FPC_rx__0__DR_INV CYREG_GPIO_PRT6_DR_INV
N#define UART_0_FPC_rx__0__DR_SET CYREG_GPIO_PRT6_DR_SET
N#define UART_0_FPC_rx__0__HSIOM CYREG_HSIOM_PORT_SEL6
N#define UART_0_FPC_rx__0__HSIOM_GPIO 0u
N#define UART_0_FPC_rx__0__HSIOM_I2C 14u
N#define UART_0_FPC_rx__0__HSIOM_I2C_SCL 14u
N#define UART_0_FPC_rx__0__HSIOM_MASK 0x0000000Fu
N#define UART_0_FPC_rx__0__HSIOM_SHIFT 0u
N#define UART_0_FPC_rx__0__HSIOM_SPI 15u
N#define UART_0_FPC_rx__0__HSIOM_SPI_MOSI 15u
N#define UART_0_FPC_rx__0__HSIOM_UART 9u
N#define UART_0_FPC_rx__0__HSIOM_UART_RX 9u
N#define UART_0_FPC_rx__0__INTCFG CYREG_GPIO_PRT6_INTR_CFG
N#define UART_0_FPC_rx__0__INTR CYREG_GPIO_PRT6_INTR
N#define UART_0_FPC_rx__0__INTR_CFG CYREG_GPIO_PRT6_INTR_CFG
N#define UART_0_FPC_rx__0__INTSTAT CYREG_GPIO_PRT6_INTR
N#define UART_0_FPC_rx__0__MASK 0x01u
N#define UART_0_FPC_rx__0__PC CYREG_GPIO_PRT6_PC
N#define UART_0_FPC_rx__0__PC2 CYREG_GPIO_PRT6_PC2
N#define UART_0_FPC_rx__0__PORT 6u
N#define UART_0_FPC_rx__0__PS CYREG_GPIO_PRT6_PS
N#define UART_0_FPC_rx__0__SHIFT 0u
N#define UART_0_FPC_rx__DR CYREG_GPIO_PRT6_DR
N#define UART_0_FPC_rx__DR_CLR CYREG_GPIO_PRT6_DR_CLR
N#define UART_0_FPC_rx__DR_INV CYREG_GPIO_PRT6_DR_INV
N#define UART_0_FPC_rx__DR_SET CYREG_GPIO_PRT6_DR_SET
N#define UART_0_FPC_rx__INTCFG CYREG_GPIO_PRT6_INTR_CFG
N#define UART_0_FPC_rx__INTR CYREG_GPIO_PRT6_INTR
N#define UART_0_FPC_rx__INTR_CFG CYREG_GPIO_PRT6_INTR_CFG
N#define UART_0_FPC_rx__INTSTAT CYREG_GPIO_PRT6_INTR
N#define UART_0_FPC_rx__MASK 0x01u
N#define UART_0_FPC_rx__PC CYREG_GPIO_PRT6_PC
N#define UART_0_FPC_rx__PC2 CYREG_GPIO_PRT6_PC2
N#define UART_0_FPC_rx__PORT 6u
N#define UART_0_FPC_rx__PS CYREG_GPIO_PRT6_PS
N#define UART_0_FPC_rx__SHIFT 0u
N#define UART_0_FPC_SCB__CTRL CYREG_SCB3_CTRL
N#define UART_0_FPC_SCB__EZ_DATA0 CYREG_SCB3_EZ_DATA0
N#define UART_0_FPC_SCB__EZ_DATA1 CYREG_SCB3_EZ_DATA1
N#define UART_0_FPC_SCB__EZ_DATA10 CYREG_SCB3_EZ_DATA10
N#define UART_0_FPC_SCB__EZ_DATA11 CYREG_SCB3_EZ_DATA11
N#define UART_0_FPC_SCB__EZ_DATA12 CYREG_SCB3_EZ_DATA12
N#define UART_0_FPC_SCB__EZ_DATA13 CYREG_SCB3_EZ_DATA13
N#define UART_0_FPC_SCB__EZ_DATA14 CYREG_SCB3_EZ_DATA14
N#define UART_0_FPC_SCB__EZ_DATA15 CYREG_SCB3_EZ_DATA15
N#define UART_0_FPC_SCB__EZ_DATA16 CYREG_SCB3_EZ_DATA16
N#define UART_0_FPC_SCB__EZ_DATA17 CYREG_SCB3_EZ_DATA17
N#define UART_0_FPC_SCB__EZ_DATA18 CYREG_SCB3_EZ_DATA18
N#define UART_0_FPC_SCB__EZ_DATA19 CYREG_SCB3_EZ_DATA19
N#define UART_0_FPC_SCB__EZ_DATA2 CYREG_SCB3_EZ_DATA2
N#define UART_0_FPC_SCB__EZ_DATA20 CYREG_SCB3_EZ_DATA20
N#define UART_0_FPC_SCB__EZ_DATA21 CYREG_SCB3_EZ_DATA21
N#define UART_0_FPC_SCB__EZ_DATA22 CYREG_SCB3_EZ_DATA22
N#define UART_0_FPC_SCB__EZ_DATA23 CYREG_SCB3_EZ_DATA23
N#define UART_0_FPC_SCB__EZ_DATA24 CYREG_SCB3_EZ_DATA24
N#define UART_0_FPC_SCB__EZ_DATA25 CYREG_SCB3_EZ_DATA25
N#define UART_0_FPC_SCB__EZ_DATA26 CYREG_SCB3_EZ_DATA26
N#define UART_0_FPC_SCB__EZ_DATA27 CYREG_SCB3_EZ_DATA27
N#define UART_0_FPC_SCB__EZ_DATA28 CYREG_SCB3_EZ_DATA28
N#define UART_0_FPC_SCB__EZ_DATA29 CYREG_SCB3_EZ_DATA29
N#define UART_0_FPC_SCB__EZ_DATA3 CYREG_SCB3_EZ_DATA3
N#define UART_0_FPC_SCB__EZ_DATA30 CYREG_SCB3_EZ_DATA30
N#define UART_0_FPC_SCB__EZ_DATA31 CYREG_SCB3_EZ_DATA31
N#define UART_0_FPC_SCB__EZ_DATA4 CYREG_SCB3_EZ_DATA4
N#define UART_0_FPC_SCB__EZ_DATA5 CYREG_SCB3_EZ_DATA5
N#define UART_0_FPC_SCB__EZ_DATA6 CYREG_SCB3_EZ_DATA6
N#define UART_0_FPC_SCB__EZ_DATA7 CYREG_SCB3_EZ_DATA7
N#define UART_0_FPC_SCB__EZ_DATA8 CYREG_SCB3_EZ_DATA8
N#define UART_0_FPC_SCB__EZ_DATA9 CYREG_SCB3_EZ_DATA9
N#define UART_0_FPC_SCB__I2C_CFG CYREG_SCB3_I2C_CFG
N#define UART_0_FPC_SCB__I2C_CTRL CYREG_SCB3_I2C_CTRL
N#define UART_0_FPC_SCB__I2C_M_CMD CYREG_SCB3_I2C_M_CMD
N#define UART_0_FPC_SCB__I2C_S_CMD CYREG_SCB3_I2C_S_CMD
N#define UART_0_FPC_SCB__I2C_STATUS CYREG_SCB3_I2C_STATUS
N#define UART_0_FPC_SCB__INTR_CAUSE CYREG_SCB3_INTR_CAUSE
N#define UART_0_FPC_SCB__INTR_I2C_EC CYREG_SCB3_INTR_I2C_EC
N#define UART_0_FPC_SCB__INTR_I2C_EC_MASK CYREG_SCB3_INTR_I2C_EC_MASK
N#define UART_0_FPC_SCB__INTR_I2C_EC_MASKED CYREG_SCB3_INTR_I2C_EC_MASKED
N#define UART_0_FPC_SCB__INTR_M CYREG_SCB3_INTR_M
N#define UART_0_FPC_SCB__INTR_M_MASK CYREG_SCB3_INTR_M_MASK
N#define UART_0_FPC_SCB__INTR_M_MASKED CYREG_SCB3_INTR_M_MASKED
N#define UART_0_FPC_SCB__INTR_M_SET CYREG_SCB3_INTR_M_SET
N#define UART_0_FPC_SCB__INTR_RX CYREG_SCB3_INTR_RX
N#define UART_0_FPC_SCB__INTR_RX_MASK CYREG_SCB3_INTR_RX_MASK
N#define UART_0_FPC_SCB__INTR_RX_MASKED CYREG_SCB3_INTR_RX_MASKED
N#define UART_0_FPC_SCB__INTR_RX_SET CYREG_SCB3_INTR_RX_SET
N#define UART_0_FPC_SCB__INTR_S CYREG_SCB3_INTR_S
N#define UART_0_FPC_SCB__INTR_S_MASK CYREG_SCB3_INTR_S_MASK
N#define UART_0_FPC_SCB__INTR_S_MASKED CYREG_SCB3_INTR_S_MASKED
N#define UART_0_FPC_SCB__INTR_S_SET CYREG_SCB3_INTR_S_SET
N#define UART_0_FPC_SCB__INTR_SPI_EC CYREG_SCB3_INTR_SPI_EC
N#define UART_0_FPC_SCB__INTR_SPI_EC_MASK CYREG_SCB3_INTR_SPI_EC_MASK
N#define UART_0_FPC_SCB__INTR_SPI_EC_MASKED CYREG_SCB3_INTR_SPI_EC_MASKED
N#define UART_0_FPC_SCB__INTR_TX CYREG_SCB3_INTR_TX
N#define UART_0_FPC_SCB__INTR_TX_MASK CYREG_SCB3_INTR_TX_MASK
N#define UART_0_FPC_SCB__INTR_TX_MASKED CYREG_SCB3_INTR_TX_MASKED
N#define UART_0_FPC_SCB__INTR_TX_SET CYREG_SCB3_INTR_TX_SET
N#define UART_0_FPC_SCB__RX_CTRL CYREG_SCB3_RX_CTRL
N#define UART_0_FPC_SCB__RX_FIFO_CTRL CYREG_SCB3_RX_FIFO_CTRL
N#define UART_0_FPC_SCB__RX_FIFO_RD CYREG_SCB3_RX_FIFO_RD
N#define UART_0_FPC_SCB__RX_FIFO_RD_SILENT CYREG_SCB3_RX_FIFO_RD_SILENT
N#define UART_0_FPC_SCB__RX_FIFO_STATUS CYREG_SCB3_RX_FIFO_STATUS
N#define UART_0_FPC_SCB__RX_MATCH CYREG_SCB3_RX_MATCH
N#define UART_0_FPC_SCB__SPI_CTRL CYREG_SCB3_SPI_CTRL
N#define UART_0_FPC_SCB__SPI_STATUS CYREG_SCB3_SPI_STATUS
N#define UART_0_FPC_SCB__SS0_POSISTION 0u
N#define UART_0_FPC_SCB__SS1_POSISTION 1u
N#define UART_0_FPC_SCB__SS2_POSISTION 2u
N#define UART_0_FPC_SCB__SS3_POSISTION 3u
N#define UART_0_FPC_SCB__STATUS CYREG_SCB3_STATUS
N#define UART_0_FPC_SCB__TX_CTRL CYREG_SCB3_TX_CTRL
N#define UART_0_FPC_SCB__TX_FIFO_CTRL CYREG_SCB3_TX_FIFO_CTRL
N#define UART_0_FPC_SCB__TX_FIFO_STATUS CYREG_SCB3_TX_FIFO_STATUS
N#define UART_0_FPC_SCB__TX_FIFO_WR CYREG_SCB3_TX_FIFO_WR
N#define UART_0_FPC_SCB__UART_CTRL CYREG_SCB3_UART_CTRL
N#define UART_0_FPC_SCB__UART_FLOW_CTRL CYREG_SCB3_UART_FLOW_CTRL
N#define UART_0_FPC_SCB__UART_RX_CTRL CYREG_SCB3_UART_RX_CTRL
N#define UART_0_FPC_SCB__UART_RX_STATUS CYREG_SCB3_UART_RX_STATUS
N#define UART_0_FPC_SCB__UART_TX_CTRL CYREG_SCB3_UART_TX_CTRL
N#define UART_0_FPC_SCB_IRQ__INTC_CLR_EN_REG CYREG_CM0P_ICER
N#define UART_0_FPC_SCB_IRQ__INTC_CLR_PD_REG CYREG_CM0P_ICPR
N#define UART_0_FPC_SCB_IRQ__INTC_MASK 0x400u
N#define UART_0_FPC_SCB_IRQ__INTC_NUMBER 10u
N#define UART_0_FPC_SCB_IRQ__INTC_PRIOR_MASK 0xC00000u
N#define UART_0_FPC_SCB_IRQ__INTC_PRIOR_NUM 3u
N#define UART_0_FPC_SCB_IRQ__INTC_PRIOR_REG CYREG_CM0P_IPR2
N#define UART_0_FPC_SCB_IRQ__INTC_SET_EN_REG CYREG_CM0P_ISER
N#define UART_0_FPC_SCB_IRQ__INTC_SET_PD_REG CYREG_CM0P_ISPR
N#define UART_0_FPC_SCBCLK__CTRL_REGISTER CYREG_PERI_PCLK_CTL3
N#define UART_0_FPC_SCBCLK__DIV_ID 0x00000045u
N#define UART_0_FPC_SCBCLK__DIV_REGISTER CYREG_PERI_DIV_16_CTL5
N#define UART_0_FPC_SCBCLK__PA_DIV_ID 0x000000FFu
N#define UART_0_FPC_tx__0__DR CYREG_GPIO_PRT6_DR
N#define UART_0_FPC_tx__0__DR_CLR CYREG_GPIO_PRT6_DR_CLR
N#define UART_0_FPC_tx__0__DR_INV CYREG_GPIO_PRT6_DR_INV
N#define UART_0_FPC_tx__0__DR_SET CYREG_GPIO_PRT6_DR_SET
N#define UART_0_FPC_tx__0__HSIOM CYREG_HSIOM_PORT_SEL6
N#define UART_0_FPC_tx__0__HSIOM_GPIO 0u
N#define UART_0_FPC_tx__0__HSIOM_I2C 14u
N#define UART_0_FPC_tx__0__HSIOM_I2C_SDA 14u
N#define UART_0_FPC_tx__0__HSIOM_MASK 0x000000F0u
N#define UART_0_FPC_tx__0__HSIOM_SHIFT 4u
N#define UART_0_FPC_tx__0__HSIOM_SPI 15u
N#define UART_0_FPC_tx__0__HSIOM_SPI_MISO 15u
N#define UART_0_FPC_tx__0__HSIOM_UART 9u
N#define UART_0_FPC_tx__0__HSIOM_UART_TX 9u
N#define UART_0_FPC_tx__0__INTCFG CYREG_GPIO_PRT6_INTR_CFG
N#define UART_0_FPC_tx__0__INTR CYREG_GPIO_PRT6_INTR
N#define UART_0_FPC_tx__0__INTR_CFG CYREG_GPIO_PRT6_INTR_CFG
N#define UART_0_FPC_tx__0__INTSTAT CYREG_GPIO_PRT6_INTR
N#define UART_0_FPC_tx__0__MASK 0x02u
N#define UART_0_FPC_tx__0__PC CYREG_GPIO_PRT6_PC
N#define UART_0_FPC_tx__0__PC2 CYREG_GPIO_PRT6_PC2
N#define UART_0_FPC_tx__0__PORT 6u
N#define UART_0_FPC_tx__0__PS CYREG_GPIO_PRT6_PS
N#define UART_0_FPC_tx__0__SHIFT 1u
N#define UART_0_FPC_tx__DR CYREG_GPIO_PRT6_DR
N#define UART_0_FPC_tx__DR_CLR CYREG_GPIO_PRT6_DR_CLR
N#define UART_0_FPC_tx__DR_INV CYREG_GPIO_PRT6_DR_INV
N#define UART_0_FPC_tx__DR_SET CYREG_GPIO_PRT6_DR_SET
N#define UART_0_FPC_tx__INTCFG CYREG_GPIO_PRT6_INTR_CFG
N#define UART_0_FPC_tx__INTR CYREG_GPIO_PRT6_INTR
N#define UART_0_FPC_tx__INTR_CFG CYREG_GPIO_PRT6_INTR_CFG
N#define UART_0_FPC_tx__INTSTAT CYREG_GPIO_PRT6_INTR
N#define UART_0_FPC_tx__MASK 0x02u
N#define UART_0_FPC_tx__PC CYREG_GPIO_PRT6_PC
N#define UART_0_FPC_tx__PC2 CYREG_GPIO_PRT6_PC2
N#define UART_0_FPC_tx__PORT 6u
N#define UART_0_FPC_tx__PS CYREG_GPIO_PRT6_PS
N#define UART_0_FPC_tx__SHIFT 1u
N
N/* UART_1_BLE */
N#define UART_1_BLE_rx__0__DR CYREG_GPIO_PRT1_DR
N#define UART_1_BLE_rx__0__DR_CLR CYREG_GPIO_PRT1_DR_CLR
N#define UART_1_BLE_rx__0__DR_INV CYREG_GPIO_PRT1_DR_INV
N#define UART_1_BLE_rx__0__DR_SET CYREG_GPIO_PRT1_DR_SET
N#define UART_1_BLE_rx__0__HSIOM CYREG_HSIOM_PORT_SEL1
N#define UART_1_BLE_rx__0__HSIOM_GPIO 0u
N#define UART_1_BLE_rx__0__HSIOM_I2C 14u
N#define UART_1_BLE_rx__0__HSIOM_I2C_SCL 14u
N#define UART_1_BLE_rx__0__HSIOM_MASK 0x0000000Fu
N#define UART_1_BLE_rx__0__HSIOM_SHIFT 0u
N#define UART_1_BLE_rx__0__HSIOM_SPI 15u
N#define UART_1_BLE_rx__0__HSIOM_SPI_MOSI 15u
N#define UART_1_BLE_rx__0__HSIOM_UART 9u
N#define UART_1_BLE_rx__0__HSIOM_UART_RX 9u
N#define UART_1_BLE_rx__0__INTCFG CYREG_GPIO_PRT1_INTR_CFG
N#define UART_1_BLE_rx__0__INTR CYREG_GPIO_PRT1_INTR
N#define UART_1_BLE_rx__0__INTR_CFG CYREG_GPIO_PRT1_INTR_CFG
N#define UART_1_BLE_rx__0__INTSTAT CYREG_GPIO_PRT1_INTR
N#define UART_1_BLE_rx__0__MASK 0x01u
N#define UART_1_BLE_rx__0__PC CYREG_GPIO_PRT1_PC
N#define UART_1_BLE_rx__0__PC2 CYREG_GPIO_PRT1_PC2
N#define UART_1_BLE_rx__0__PORT 1u
N#define UART_1_BLE_rx__0__PS CYREG_GPIO_PRT1_PS
N#define UART_1_BLE_rx__0__SHIFT 0u
N#define UART_1_BLE_rx__DR CYREG_GPIO_PRT1_DR
N#define UART_1_BLE_rx__DR_CLR CYREG_GPIO_PRT1_DR_CLR
N#define UART_1_BLE_rx__DR_INV CYREG_GPIO_PRT1_DR_INV
N#define UART_1_BLE_rx__DR_SET CYREG_GPIO_PRT1_DR_SET
N#define UART_1_BLE_rx__INTCFG CYREG_GPIO_PRT1_INTR_CFG
N#define UART_1_BLE_rx__INTR CYREG_GPIO_PRT1_INTR
N#define UART_1_BLE_rx__INTR_CFG CYREG_GPIO_PRT1_INTR_CFG
N#define UART_1_BLE_rx__INTSTAT CYREG_GPIO_PRT1_INTR
N#define UART_1_BLE_rx__MASK 0x01u
N#define UART_1_BLE_rx__PC CYREG_GPIO_PRT1_PC
N#define UART_1_BLE_rx__PC2 CYREG_GPIO_PRT1_PC2
N#define UART_1_BLE_rx__PORT 1u
N#define UART_1_BLE_rx__PS CYREG_GPIO_PRT1_PS
N#define UART_1_BLE_rx__SHIFT 0u
N#define UART_1_BLE_SCB__CTRL CYREG_SCB0_CTRL
N#define UART_1_BLE_SCB__EZ_DATA0 CYREG_SCB0_EZ_DATA0
N#define UART_1_BLE_SCB__EZ_DATA1 CYREG_SCB0_EZ_DATA1
N#define UART_1_BLE_SCB__EZ_DATA10 CYREG_SCB0_EZ_DATA10
N#define UART_1_BLE_SCB__EZ_DATA11 CYREG_SCB0_EZ_DATA11
N#define UART_1_BLE_SCB__EZ_DATA12 CYREG_SCB0_EZ_DATA12
N#define UART_1_BLE_SCB__EZ_DATA13 CYREG_SCB0_EZ_DATA13
N#define UART_1_BLE_SCB__EZ_DATA14 CYREG_SCB0_EZ_DATA14
N#define UART_1_BLE_SCB__EZ_DATA15 CYREG_SCB0_EZ_DATA15
N#define UART_1_BLE_SCB__EZ_DATA16 CYREG_SCB0_EZ_DATA16
N#define UART_1_BLE_SCB__EZ_DATA17 CYREG_SCB0_EZ_DATA17
N#define UART_1_BLE_SCB__EZ_DATA18 CYREG_SCB0_EZ_DATA18
N#define UART_1_BLE_SCB__EZ_DATA19 CYREG_SCB0_EZ_DATA19
N#define UART_1_BLE_SCB__EZ_DATA2 CYREG_SCB0_EZ_DATA2
N#define UART_1_BLE_SCB__EZ_DATA20 CYREG_SCB0_EZ_DATA20
N#define UART_1_BLE_SCB__EZ_DATA21 CYREG_SCB0_EZ_DATA21
N#define UART_1_BLE_SCB__EZ_DATA22 CYREG_SCB0_EZ_DATA22
N#define UART_1_BLE_SCB__EZ_DATA23 CYREG_SCB0_EZ_DATA23
N#define UART_1_BLE_SCB__EZ_DATA24 CYREG_SCB0_EZ_DATA24
N#define UART_1_BLE_SCB__EZ_DATA25 CYREG_SCB0_EZ_DATA25
N#define UART_1_BLE_SCB__EZ_DATA26 CYREG_SCB0_EZ_DATA26
N#define UART_1_BLE_SCB__EZ_DATA27 CYREG_SCB0_EZ_DATA27
N#define UART_1_BLE_SCB__EZ_DATA28 CYREG_SCB0_EZ_DATA28
N#define UART_1_BLE_SCB__EZ_DATA29 CYREG_SCB0_EZ_DATA29
N#define UART_1_BLE_SCB__EZ_DATA3 CYREG_SCB0_EZ_DATA3
N#define UART_1_BLE_SCB__EZ_DATA30 CYREG_SCB0_EZ_DATA30
N#define UART_1_BLE_SCB__EZ_DATA31 CYREG_SCB0_EZ_DATA31
N#define UART_1_BLE_SCB__EZ_DATA4 CYREG_SCB0_EZ_DATA4
N#define UART_1_BLE_SCB__EZ_DATA5 CYREG_SCB0_EZ_DATA5
N#define UART_1_BLE_SCB__EZ_DATA6 CYREG_SCB0_EZ_DATA6
N#define UART_1_BLE_SCB__EZ_DATA7 CYREG_SCB0_EZ_DATA7
N#define UART_1_BLE_SCB__EZ_DATA8 CYREG_SCB0_EZ_DATA8
N#define UART_1_BLE_SCB__EZ_DATA9 CYREG_SCB0_EZ_DATA9
N#define UART_1_BLE_SCB__I2C_CFG CYREG_SCB0_I2C_CFG
N#define UART_1_BLE_SCB__I2C_CTRL CYREG_SCB0_I2C_CTRL
N#define UART_1_BLE_SCB__I2C_M_CMD CYREG_SCB0_I2C_M_CMD
N#define UART_1_BLE_SCB__I2C_S_CMD CYREG_SCB0_I2C_S_CMD
N#define UART_1_BLE_SCB__I2C_STATUS CYREG_SCB0_I2C_STATUS
N#define UART_1_BLE_SCB__INTR_CAUSE CYREG_SCB0_INTR_CAUSE
N#define UART_1_BLE_SCB__INTR_I2C_EC CYREG_SCB0_INTR_I2C_EC
N#define UART_1_BLE_SCB__INTR_I2C_EC_MASK CYREG_SCB0_INTR_I2C_EC_MASK
N#define UART_1_BLE_SCB__INTR_I2C_EC_MASKED CYREG_SCB0_INTR_I2C_EC_MASKED
N#define UART_1_BLE_SCB__INTR_M CYREG_SCB0_INTR_M
N#define UART_1_BLE_SCB__INTR_M_MASK CYREG_SCB0_INTR_M_MASK
N#define UART_1_BLE_SCB__INTR_M_MASKED CYREG_SCB0_INTR_M_MASKED
N#define UART_1_BLE_SCB__INTR_M_SET CYREG_SCB0_INTR_M_SET
N#define UART_1_BLE_SCB__INTR_RX CYREG_SCB0_INTR_RX
N#define UART_1_BLE_SCB__INTR_RX_MASK CYREG_SCB0_INTR_RX_MASK
N#define UART_1_BLE_SCB__INTR_RX_MASKED CYREG_SCB0_INTR_RX_MASKED
N#define UART_1_BLE_SCB__INTR_RX_SET CYREG_SCB0_INTR_RX_SET
N#define UART_1_BLE_SCB__INTR_S CYREG_SCB0_INTR_S
N#define UART_1_BLE_SCB__INTR_S_MASK CYREG_SCB0_INTR_S_MASK
N#define UART_1_BLE_SCB__INTR_S_MASKED CYREG_SCB0_INTR_S_MASKED
N#define UART_1_BLE_SCB__INTR_S_SET CYREG_SCB0_INTR_S_SET
N#define UART_1_BLE_SCB__INTR_SPI_EC CYREG_SCB0_INTR_SPI_EC
N#define UART_1_BLE_SCB__INTR_SPI_EC_MASK CYREG_SCB0_INTR_SPI_EC_MASK
N#define UART_1_BLE_SCB__INTR_SPI_EC_MASKED CYREG_SCB0_INTR_SPI_EC_MASKED
N#define UART_1_BLE_SCB__INTR_TX CYREG_SCB0_INTR_TX
N#define UART_1_BLE_SCB__INTR_TX_MASK CYREG_SCB0_INTR_TX_MASK
N#define UART_1_BLE_SCB__INTR_TX_MASKED CYREG_SCB0_INTR_TX_MASKED
N#define UART_1_BLE_SCB__INTR_TX_SET CYREG_SCB0_INTR_TX_SET
N#define UART_1_BLE_SCB__RX_CTRL CYREG_SCB0_RX_CTRL
N#define UART_1_BLE_SCB__RX_FIFO_CTRL CYREG_SCB0_RX_FIFO_CTRL
N#define UART_1_BLE_SCB__RX_FIFO_RD CYREG_SCB0_RX_FIFO_RD
N#define UART_1_BLE_SCB__RX_FIFO_RD_SILENT CYREG_SCB0_RX_FIFO_RD_SILENT
N#define UART_1_BLE_SCB__RX_FIFO_STATUS CYREG_SCB0_RX_FIFO_STATUS
N#define UART_1_BLE_SCB__RX_MATCH CYREG_SCB0_RX_MATCH
N#define UART_1_BLE_SCB__SPI_CTRL CYREG_SCB0_SPI_CTRL
N#define UART_1_BLE_SCB__SPI_STATUS CYREG_SCB0_SPI_STATUS
N#define UART_1_BLE_SCB__SS0_POSISTION 0u
N#define UART_1_BLE_SCB__SS1_POSISTION 1u
N#define UART_1_BLE_SCB__SS2_POSISTION 2u
N#define UART_1_BLE_SCB__SS3_POSISTION 3u
N#define UART_1_BLE_SCB__STATUS CYREG_SCB0_STATUS
N#define UART_1_BLE_SCB__TX_CTRL CYREG_SCB0_TX_CTRL
N#define UART_1_BLE_SCB__TX_FIFO_CTRL CYREG_SCB0_TX_FIFO_CTRL
N#define UART_1_BLE_SCB__TX_FIFO_STATUS CYREG_SCB0_TX_FIFO_STATUS
N#define UART_1_BLE_SCB__TX_FIFO_WR CYREG_SCB0_TX_FIFO_WR
N#define UART_1_BLE_SCB__UART_CTRL CYREG_SCB0_UART_CTRL
N#define UART_1_BLE_SCB__UART_FLOW_CTRL CYREG_SCB0_UART_FLOW_CTRL
N#define UART_1_BLE_SCB__UART_RX_CTRL CYREG_SCB0_UART_RX_CTRL
N#define UART_1_BLE_SCB__UART_RX_STATUS CYREG_SCB0_UART_RX_STATUS
N#define UART_1_BLE_SCB__UART_TX_CTRL CYREG_SCB0_UART_TX_CTRL
N#define UART_1_BLE_SCB_IRQ__INTC_CLR_EN_REG CYREG_CM0P_ICER
N#define UART_1_BLE_SCB_IRQ__INTC_CLR_PD_REG CYREG_CM0P_ICPR
N#define UART_1_BLE_SCB_IRQ__INTC_MASK 0x80u
N#define UART_1_BLE_SCB_IRQ__INTC_NUMBER 7u
N#define UART_1_BLE_SCB_IRQ__INTC_PRIOR_MASK 0xC0000000u
N#define UART_1_BLE_SCB_IRQ__INTC_PRIOR_NUM 3u
N#define UART_1_BLE_SCB_IRQ__INTC_PRIOR_REG CYREG_CM0P_IPR1
N#define UART_1_BLE_SCB_IRQ__INTC_SET_EN_REG CYREG_CM0P_ISER
N#define UART_1_BLE_SCB_IRQ__INTC_SET_PD_REG CYREG_CM0P_ISPR
N#define UART_1_BLE_SCBCLK__CTRL_REGISTER CYREG_PERI_PCLK_CTL0
N#define UART_1_BLE_SCBCLK__DIV_ID 0x00000046u
N#define UART_1_BLE_SCBCLK__DIV_REGISTER CYREG_PERI_DIV_16_CTL6
N#define UART_1_BLE_SCBCLK__PA_DIV_ID 0x000000FFu
N#define UART_1_BLE_tx__0__DR CYREG_GPIO_PRT1_DR
N#define UART_1_BLE_tx__0__DR_CLR CYREG_GPIO_PRT1_DR_CLR
N#define UART_1_BLE_tx__0__DR_INV CYREG_GPIO_PRT1_DR_INV
N#define UART_1_BLE_tx__0__DR_SET CYREG_GPIO_PRT1_DR_SET
N#define UART_1_BLE_tx__0__HSIOM CYREG_HSIOM_PORT_SEL1
N#define UART_1_BLE_tx__0__HSIOM_GPIO 0u
N#define UART_1_BLE_tx__0__HSIOM_I2C 14u
N#define UART_1_BLE_tx__0__HSIOM_I2C_SDA 14u
N#define UART_1_BLE_tx__0__HSIOM_MASK 0x000000F0u
N#define UART_1_BLE_tx__0__HSIOM_SHIFT 4u
N#define UART_1_BLE_tx__0__HSIOM_SPI 15u
N#define UART_1_BLE_tx__0__HSIOM_SPI_MISO 15u
N#define UART_1_BLE_tx__0__HSIOM_UART 9u
N#define UART_1_BLE_tx__0__HSIOM_UART_TX 9u
N#define UART_1_BLE_tx__0__INTCFG CYREG_GPIO_PRT1_INTR_CFG
N#define UART_1_BLE_tx__0__INTR CYREG_GPIO_PRT1_INTR
N#define UART_1_BLE_tx__0__INTR_CFG CYREG_GPIO_PRT1_INTR_CFG
N#define UART_1_BLE_tx__0__INTSTAT CYREG_GPIO_PRT1_INTR
N#define UART_1_BLE_tx__0__MASK 0x02u
N#define UART_1_BLE_tx__0__PC CYREG_GPIO_PRT1_PC
N#define UART_1_BLE_tx__0__PC2 CYREG_GPIO_PRT1_PC2
N#define UART_1_BLE_tx__0__PORT 1u
N#define UART_1_BLE_tx__0__PS CYREG_GPIO_PRT1_PS
N#define UART_1_BLE_tx__0__SHIFT 1u
N#define UART_1_BLE_tx__DR CYREG_GPIO_PRT1_DR
N#define UART_1_BLE_tx__DR_CLR CYREG_GPIO_PRT1_DR_CLR
N#define UART_1_BLE_tx__DR_INV CYREG_GPIO_PRT1_DR_INV
N#define UART_1_BLE_tx__DR_SET CYREG_GPIO_PRT1_DR_SET
N#define UART_1_BLE_tx__INTCFG CYREG_GPIO_PRT1_INTR_CFG
N#define UART_1_BLE_tx__INTR CYREG_GPIO_PRT1_INTR
N#define UART_1_BLE_tx__INTR_CFG CYREG_GPIO_PRT1_INTR_CFG
N#define UART_1_BLE_tx__INTSTAT CYREG_GPIO_PRT1_INTR
N#define UART_1_BLE_tx__MASK 0x02u
N#define UART_1_BLE_tx__PC CYREG_GPIO_PRT1_PC
N#define UART_1_BLE_tx__PC2 CYREG_GPIO_PRT1_PC2
N#define UART_1_BLE_tx__PORT 1u
N#define UART_1_BLE_tx__PS CYREG_GPIO_PRT1_PS
N#define UART_1_BLE_tx__SHIFT 1u
N
N/* UART_2_EXT */
N#define UART_2_EXT_rx__0__DR CYREG_GPIO_PRT5_DR
N#define UART_2_EXT_rx__0__DR_CLR CYREG_GPIO_PRT5_DR_CLR
N#define UART_2_EXT_rx__0__DR_INV CYREG_GPIO_PRT5_DR_INV
N#define UART_2_EXT_rx__0__DR_SET CYREG_GPIO_PRT5_DR_SET
N#define UART_2_EXT_rx__0__HSIOM CYREG_HSIOM_PORT_SEL5
N#define UART_2_EXT_rx__0__HSIOM_GPIO 0u
N#define UART_2_EXT_rx__0__HSIOM_I2C 14u
N#define UART_2_EXT_rx__0__HSIOM_I2C_SCL 14u
N#define UART_2_EXT_rx__0__HSIOM_MASK 0x0000000Fu
N#define UART_2_EXT_rx__0__HSIOM_SHIFT 0u
N#define UART_2_EXT_rx__0__HSIOM_SPI 15u
N#define UART_2_EXT_rx__0__HSIOM_SPI_MOSI 15u
N#define UART_2_EXT_rx__0__HSIOM_UART 11u
N#define UART_2_EXT_rx__0__HSIOM_UART_RX 11u
N#define UART_2_EXT_rx__0__INTCFG CYREG_GPIO_PRT5_INTR_CFG
N#define UART_2_EXT_rx__0__INTR CYREG_GPIO_PRT5_INTR
N#define UART_2_EXT_rx__0__INTR_CFG CYREG_GPIO_PRT5_INTR_CFG
N#define UART_2_EXT_rx__0__INTSTAT CYREG_GPIO_PRT5_INTR
N#define UART_2_EXT_rx__0__MASK 0x01u
N#define UART_2_EXT_rx__0__PC CYREG_GPIO_PRT5_PC
N#define UART_2_EXT_rx__0__PC2 CYREG_GPIO_PRT5_PC2
N#define UART_2_EXT_rx__0__PORT 5u
N#define UART_2_EXT_rx__0__PS CYREG_GPIO_PRT5_PS
N#define UART_2_EXT_rx__0__SHIFT 0u
N#define UART_2_EXT_rx__DR CYREG_GPIO_PRT5_DR
N#define UART_2_EXT_rx__DR_CLR CYREG_GPIO_PRT5_DR_CLR
N#define UART_2_EXT_rx__DR_INV CYREG_GPIO_PRT5_DR_INV
N#define UART_2_EXT_rx__DR_SET CYREG_GPIO_PRT5_DR_SET
N#define UART_2_EXT_rx__INTCFG CYREG_GPIO_PRT5_INTR_CFG
N#define UART_2_EXT_rx__INTR CYREG_GPIO_PRT5_INTR
N#define UART_2_EXT_rx__INTR_CFG CYREG_GPIO_PRT5_INTR_CFG
N#define UART_2_EXT_rx__INTSTAT CYREG_GPIO_PRT5_INTR
N#define UART_2_EXT_rx__MASK 0x01u
N#define UART_2_EXT_rx__PC CYREG_GPIO_PRT5_PC
N#define UART_2_EXT_rx__PC2 CYREG_GPIO_PRT5_PC2
N#define UART_2_EXT_rx__PORT 5u
N#define UART_2_EXT_rx__PS CYREG_GPIO_PRT5_PS
N#define UART_2_EXT_rx__SHIFT 0u
N#define UART_2_EXT_SCB__CTRL CYREG_SCB2_CTRL
N#define UART_2_EXT_SCB__EZ_DATA0 CYREG_SCB2_EZ_DATA0
N#define UART_2_EXT_SCB__EZ_DATA1 CYREG_SCB2_EZ_DATA1
N#define UART_2_EXT_SCB__EZ_DATA10 CYREG_SCB2_EZ_DATA10
N#define UART_2_EXT_SCB__EZ_DATA11 CYREG_SCB2_EZ_DATA11
N#define UART_2_EXT_SCB__EZ_DATA12 CYREG_SCB2_EZ_DATA12
N#define UART_2_EXT_SCB__EZ_DATA13 CYREG_SCB2_EZ_DATA13
N#define UART_2_EXT_SCB__EZ_DATA14 CYREG_SCB2_EZ_DATA14
N#define UART_2_EXT_SCB__EZ_DATA15 CYREG_SCB2_EZ_DATA15
N#define UART_2_EXT_SCB__EZ_DATA16 CYREG_SCB2_EZ_DATA16
N#define UART_2_EXT_SCB__EZ_DATA17 CYREG_SCB2_EZ_DATA17
N#define UART_2_EXT_SCB__EZ_DATA18 CYREG_SCB2_EZ_DATA18
N#define UART_2_EXT_SCB__EZ_DATA19 CYREG_SCB2_EZ_DATA19
N#define UART_2_EXT_SCB__EZ_DATA2 CYREG_SCB2_EZ_DATA2
N#define UART_2_EXT_SCB__EZ_DATA20 CYREG_SCB2_EZ_DATA20
N#define UART_2_EXT_SCB__EZ_DATA21 CYREG_SCB2_EZ_DATA21
N#define UART_2_EXT_SCB__EZ_DATA22 CYREG_SCB2_EZ_DATA22
N#define UART_2_EXT_SCB__EZ_DATA23 CYREG_SCB2_EZ_DATA23
N#define UART_2_EXT_SCB__EZ_DATA24 CYREG_SCB2_EZ_DATA24
N#define UART_2_EXT_SCB__EZ_DATA25 CYREG_SCB2_EZ_DATA25
N#define UART_2_EXT_SCB__EZ_DATA26 CYREG_SCB2_EZ_DATA26
N#define UART_2_EXT_SCB__EZ_DATA27 CYREG_SCB2_EZ_DATA27
N#define UART_2_EXT_SCB__EZ_DATA28 CYREG_SCB2_EZ_DATA28
N#define UART_2_EXT_SCB__EZ_DATA29 CYREG_SCB2_EZ_DATA29
N#define UART_2_EXT_SCB__EZ_DATA3 CYREG_SCB2_EZ_DATA3
N#define UART_2_EXT_SCB__EZ_DATA30 CYREG_SCB2_EZ_DATA30
N#define UART_2_EXT_SCB__EZ_DATA31 CYREG_SCB2_EZ_DATA31
N#define UART_2_EXT_SCB__EZ_DATA4 CYREG_SCB2_EZ_DATA4
N#define UART_2_EXT_SCB__EZ_DATA5 CYREG_SCB2_EZ_DATA5
N#define UART_2_EXT_SCB__EZ_DATA6 CYREG_SCB2_EZ_DATA6
N#define UART_2_EXT_SCB__EZ_DATA7 CYREG_SCB2_EZ_DATA7
N#define UART_2_EXT_SCB__EZ_DATA8 CYREG_SCB2_EZ_DATA8
N#define UART_2_EXT_SCB__EZ_DATA9 CYREG_SCB2_EZ_DATA9
N#define UART_2_EXT_SCB__I2C_CFG CYREG_SCB2_I2C_CFG
N#define UART_2_EXT_SCB__I2C_CTRL CYREG_SCB2_I2C_CTRL
N#define UART_2_EXT_SCB__I2C_M_CMD CYREG_SCB2_I2C_M_CMD
N#define UART_2_EXT_SCB__I2C_S_CMD CYREG_SCB2_I2C_S_CMD
N#define UART_2_EXT_SCB__I2C_STATUS CYREG_SCB2_I2C_STATUS
N#define UART_2_EXT_SCB__INTR_CAUSE CYREG_SCB2_INTR_CAUSE
N#define UART_2_EXT_SCB__INTR_I2C_EC CYREG_SCB2_INTR_I2C_EC
N#define UART_2_EXT_SCB__INTR_I2C_EC_MASK CYREG_SCB2_INTR_I2C_EC_MASK
N#define UART_2_EXT_SCB__INTR_I2C_EC_MASKED CYREG_SCB2_INTR_I2C_EC_MASKED
N#define UART_2_EXT_SCB__INTR_M CYREG_SCB2_INTR_M
N#define UART_2_EXT_SCB__INTR_M_MASK CYREG_SCB2_INTR_M_MASK
N#define UART_2_EXT_SCB__INTR_M_MASKED CYREG_SCB2_INTR_M_MASKED
N#define UART_2_EXT_SCB__INTR_M_SET CYREG_SCB2_INTR_M_SET
N#define UART_2_EXT_SCB__INTR_RX CYREG_SCB2_INTR_RX
N#define UART_2_EXT_SCB__INTR_RX_MASK CYREG_SCB2_INTR_RX_MASK
N#define UART_2_EXT_SCB__INTR_RX_MASKED CYREG_SCB2_INTR_RX_MASKED
N#define UART_2_EXT_SCB__INTR_RX_SET CYREG_SCB2_INTR_RX_SET
N#define UART_2_EXT_SCB__INTR_S CYREG_SCB2_INTR_S
N#define UART_2_EXT_SCB__INTR_S_MASK CYREG_SCB2_INTR_S_MASK
N#define UART_2_EXT_SCB__INTR_S_MASKED CYREG_SCB2_INTR_S_MASKED
N#define UART_2_EXT_SCB__INTR_S_SET CYREG_SCB2_INTR_S_SET
N#define UART_2_EXT_SCB__INTR_SPI_EC CYREG_SCB2_INTR_SPI_EC
N#define UART_2_EXT_SCB__INTR_SPI_EC_MASK CYREG_SCB2_INTR_SPI_EC_MASK
N#define UART_2_EXT_SCB__INTR_SPI_EC_MASKED CYREG_SCB2_INTR_SPI_EC_MASKED
N#define UART_2_EXT_SCB__INTR_TX CYREG_SCB2_INTR_TX
N#define UART_2_EXT_SCB__INTR_TX_MASK CYREG_SCB2_INTR_TX_MASK
N#define UART_2_EXT_SCB__INTR_TX_MASKED CYREG_SCB2_INTR_TX_MASKED
N#define UART_2_EXT_SCB__INTR_TX_SET CYREG_SCB2_INTR_TX_SET
N#define UART_2_EXT_SCB__RX_CTRL CYREG_SCB2_RX_CTRL
N#define UART_2_EXT_SCB__RX_FIFO_CTRL CYREG_SCB2_RX_FIFO_CTRL
N#define UART_2_EXT_SCB__RX_FIFO_RD CYREG_SCB2_RX_FIFO_RD
N#define UART_2_EXT_SCB__RX_FIFO_RD_SILENT CYREG_SCB2_RX_FIFO_RD_SILENT
N#define UART_2_EXT_SCB__RX_FIFO_STATUS CYREG_SCB2_RX_FIFO_STATUS
N#define UART_2_EXT_SCB__RX_MATCH CYREG_SCB2_RX_MATCH
N#define UART_2_EXT_SCB__SPI_CTRL CYREG_SCB2_SPI_CTRL
N#define UART_2_EXT_SCB__SPI_STATUS CYREG_SCB2_SPI_STATUS
N#define UART_2_EXT_SCB__SS0_POSISTION 0u
N#define UART_2_EXT_SCB__SS1_POSISTION 1u
N#define UART_2_EXT_SCB__SS2_POSISTION 2u
N#define UART_2_EXT_SCB__SS3_POSISTION 3u
N#define UART_2_EXT_SCB__STATUS CYREG_SCB2_STATUS
N#define UART_2_EXT_SCB__TX_CTRL CYREG_SCB2_TX_CTRL
N#define UART_2_EXT_SCB__TX_FIFO_CTRL CYREG_SCB2_TX_FIFO_CTRL
N#define UART_2_EXT_SCB__TX_FIFO_STATUS CYREG_SCB2_TX_FIFO_STATUS
N#define UART_2_EXT_SCB__TX_FIFO_WR CYREG_SCB2_TX_FIFO_WR
N#define UART_2_EXT_SCB__UART_CTRL CYREG_SCB2_UART_CTRL
N#define UART_2_EXT_SCB__UART_FLOW_CTRL CYREG_SCB2_UART_FLOW_CTRL
N#define UART_2_EXT_SCB__UART_RX_CTRL CYREG_SCB2_UART_RX_CTRL
N#define UART_2_EXT_SCB__UART_RX_STATUS CYREG_SCB2_UART_RX_STATUS
N#define UART_2_EXT_SCB__UART_TX_CTRL CYREG_SCB2_UART_TX_CTRL
N#define UART_2_EXT_SCB_IRQ__INTC_CLR_EN_REG CYREG_CM0P_ICER
N#define UART_2_EXT_SCB_IRQ__INTC_CLR_PD_REG CYREG_CM0P_ICPR
N#define UART_2_EXT_SCB_IRQ__INTC_MASK 0x200u
N#define UART_2_EXT_SCB_IRQ__INTC_NUMBER 9u
N#define UART_2_EXT_SCB_IRQ__INTC_PRIOR_MASK 0xC000u
N#define UART_2_EXT_SCB_IRQ__INTC_PRIOR_NUM 3u
N#define UART_2_EXT_SCB_IRQ__INTC_PRIOR_REG CYREG_CM0P_IPR2
N#define UART_2_EXT_SCB_IRQ__INTC_SET_EN_REG CYREG_CM0P_ISER
N#define UART_2_EXT_SCB_IRQ__INTC_SET_PD_REG CYREG_CM0P_ISPR
N#define UART_2_EXT_SCBCLK__CTRL_REGISTER CYREG_PERI_PCLK_CTL2
N#define UART_2_EXT_SCBCLK__DIV_ID 0x00000044u
N#define UART_2_EXT_SCBCLK__DIV_REGISTER CYREG_PERI_DIV_16_CTL4
N#define UART_2_EXT_SCBCLK__PA_DIV_ID 0x000000FFu
N#define UART_2_EXT_tx__0__DR CYREG_GPIO_PRT5_DR
N#define UART_2_EXT_tx__0__DR_CLR CYREG_GPIO_PRT5_DR_CLR
N#define UART_2_EXT_tx__0__DR_INV CYREG_GPIO_PRT5_DR_INV
N#define UART_2_EXT_tx__0__DR_SET CYREG_GPIO_PRT5_DR_SET
N#define UART_2_EXT_tx__0__HSIOM CYREG_HSIOM_PORT_SEL5
N#define UART_2_EXT_tx__0__HSIOM_GPIO 0u
N#define UART_2_EXT_tx__0__HSIOM_I2C 14u
N#define UART_2_EXT_tx__0__HSIOM_I2C_SDA 14u
N#define UART_2_EXT_tx__0__HSIOM_MASK 0x000000F0u
N#define UART_2_EXT_tx__0__HSIOM_SHIFT 4u
N#define UART_2_EXT_tx__0__HSIOM_SPI 15u
N#define UART_2_EXT_tx__0__HSIOM_SPI_MISO 15u
N#define UART_2_EXT_tx__0__HSIOM_UART 11u
N#define UART_2_EXT_tx__0__HSIOM_UART_TX 11u
N#define UART_2_EXT_tx__0__INTCFG CYREG_GPIO_PRT5_INTR_CFG
N#define UART_2_EXT_tx__0__INTR CYREG_GPIO_PRT5_INTR
N#define UART_2_EXT_tx__0__INTR_CFG CYREG_GPIO_PRT5_INTR_CFG
N#define UART_2_EXT_tx__0__INTSTAT CYREG_GPIO_PRT5_INTR
N#define UART_2_EXT_tx__0__MASK 0x02u
N#define UART_2_EXT_tx__0__PC CYREG_GPIO_PRT5_PC
N#define UART_2_EXT_tx__0__PC2 CYREG_GPIO_PRT5_PC2
N#define UART_2_EXT_tx__0__PORT 5u
N#define UART_2_EXT_tx__0__PS CYREG_GPIO_PRT5_PS
N#define UART_2_EXT_tx__0__SHIFT 1u
N#define UART_2_EXT_tx__DR CYREG_GPIO_PRT5_DR
N#define UART_2_EXT_tx__DR_CLR CYREG_GPIO_PRT5_DR_CLR
N#define UART_2_EXT_tx__DR_INV CYREG_GPIO_PRT5_DR_INV
N#define UART_2_EXT_tx__DR_SET CYREG_GPIO_PRT5_DR_SET
N#define UART_2_EXT_tx__INTCFG CYREG_GPIO_PRT5_INTR_CFG
N#define UART_2_EXT_tx__INTR CYREG_GPIO_PRT5_INTR
N#define UART_2_EXT_tx__INTR_CFG CYREG_GPIO_PRT5_INTR_CFG
N#define UART_2_EXT_tx__INTSTAT CYREG_GPIO_PRT5_INTR
N#define UART_2_EXT_tx__MASK 0x02u
N#define UART_2_EXT_tx__PC CYREG_GPIO_PRT5_PC
N#define UART_2_EXT_tx__PC2 CYREG_GPIO_PRT5_PC2
N#define UART_2_EXT_tx__PORT 5u
N#define UART_2_EXT_tx__PS CYREG_GPIO_PRT5_PS
N#define UART_2_EXT_tx__SHIFT 1u
N
N/* VOICE_BUSY */
N#define VOICE_BUSY__0__DR CYREG_GPIO_PRT5_DR
N#define VOICE_BUSY__0__DR_CLR CYREG_GPIO_PRT5_DR_CLR
N#define VOICE_BUSY__0__DR_INV CYREG_GPIO_PRT5_DR_INV
N#define VOICE_BUSY__0__DR_SET CYREG_GPIO_PRT5_DR_SET
N#define VOICE_BUSY__0__HSIOM CYREG_HSIOM_PORT_SEL5
N#define VOICE_BUSY__0__HSIOM_MASK 0x0F000000u
N#define VOICE_BUSY__0__HSIOM_SHIFT 24u
N#define VOICE_BUSY__0__INTCFG CYREG_GPIO_PRT5_INTR_CFG
N#define VOICE_BUSY__0__INTR CYREG_GPIO_PRT5_INTR
N#define VOICE_BUSY__0__INTR_CFG CYREG_GPIO_PRT5_INTR_CFG
N#define VOICE_BUSY__0__INTSTAT CYREG_GPIO_PRT5_INTR
N#define VOICE_BUSY__0__MASK 0x40u
N#define VOICE_BUSY__0__PC CYREG_GPIO_PRT5_PC
N#define VOICE_BUSY__0__PC2 CYREG_GPIO_PRT5_PC2
N#define VOICE_BUSY__0__PORT 5u
N#define VOICE_BUSY__0__PS CYREG_GPIO_PRT5_PS
N#define VOICE_BUSY__0__SHIFT 6u
N#define VOICE_BUSY__DR CYREG_GPIO_PRT5_DR
N#define VOICE_BUSY__DR_CLR CYREG_GPIO_PRT5_DR_CLR
N#define VOICE_BUSY__DR_INV CYREG_GPIO_PRT5_DR_INV
N#define VOICE_BUSY__DR_SET CYREG_GPIO_PRT5_DR_SET
N#define VOICE_BUSY__INTCFG CYREG_GPIO_PRT5_INTR_CFG
N#define VOICE_BUSY__INTR CYREG_GPIO_PRT5_INTR
N#define VOICE_BUSY__INTR_CFG CYREG_GPIO_PRT5_INTR_CFG
N#define VOICE_BUSY__INTSTAT CYREG_GPIO_PRT5_INTR
N#define VOICE_BUSY__MASK 0x40u
N#define VOICE_BUSY__PC CYREG_GPIO_PRT5_PC
N#define VOICE_BUSY__PC2 CYREG_GPIO_PRT5_PC2
N#define VOICE_BUSY__PORT 5u
N#define VOICE_BUSY__PS CYREG_GPIO_PRT5_PS
N#define VOICE_BUSY__SHIFT 6u
N
N/* VOICE_DATA */
N#define VOICE_DATA__0__DR CYREG_GPIO_PRT1_DR
N#define VOICE_DATA__0__DR_CLR CYREG_GPIO_PRT1_DR_CLR
N#define VOICE_DATA__0__DR_INV CYREG_GPIO_PRT1_DR_INV
N#define VOICE_DATA__0__DR_SET CYREG_GPIO_PRT1_DR_SET
N#define VOICE_DATA__0__HSIOM CYREG_HSIOM_PORT_SEL1
N#define VOICE_DATA__0__HSIOM_MASK 0xF0000000u
N#define VOICE_DATA__0__HSIOM_SHIFT 28u
N#define VOICE_DATA__0__INTCFG CYREG_GPIO_PRT1_INTR_CFG
N#define VOICE_DATA__0__INTR CYREG_GPIO_PRT1_INTR
N#define VOICE_DATA__0__INTR_CFG CYREG_GPIO_PRT1_INTR_CFG
N#define VOICE_DATA__0__INTSTAT CYREG_GPIO_PRT1_INTR
N#define VOICE_DATA__0__MASK 0x80u
N#define VOICE_DATA__0__PC CYREG_GPIO_PRT1_PC
N#define VOICE_DATA__0__PC2 CYREG_GPIO_PRT1_PC2
N#define VOICE_DATA__0__PORT 1u
N#define VOICE_DATA__0__PS CYREG_GPIO_PRT1_PS
N#define VOICE_DATA__0__SHIFT 7u
N#define VOICE_DATA__DR CYREG_GPIO_PRT1_DR
N#define VOICE_DATA__DR_CLR CYREG_GPIO_PRT1_DR_CLR
N#define VOICE_DATA__DR_INV CYREG_GPIO_PRT1_DR_INV
N#define VOICE_DATA__DR_SET CYREG_GPIO_PRT1_DR_SET
N#define VOICE_DATA__INTCFG CYREG_GPIO_PRT1_INTR_CFG
N#define VOICE_DATA__INTR CYREG_GPIO_PRT1_INTR
N#define VOICE_DATA__INTR_CFG CYREG_GPIO_PRT1_INTR_CFG
N#define VOICE_DATA__INTSTAT CYREG_GPIO_PRT1_INTR
N#define VOICE_DATA__MASK 0x80u
N#define VOICE_DATA__PC CYREG_GPIO_PRT1_PC
N#define VOICE_DATA__PC2 CYREG_GPIO_PRT1_PC2
N#define VOICE_DATA__PORT 1u
N#define VOICE_DATA__PS CYREG_GPIO_PRT1_PS
N#define VOICE_DATA__SHIFT 7u
N
N/* COVER_CHK_INT */
N#define COVER_CHK_INT__0__DR CYREG_GPIO_PRT1_DR
N#define COVER_CHK_INT__0__DR_CLR CYREG_GPIO_PRT1_DR_CLR
N#define COVER_CHK_INT__0__DR_INV CYREG_GPIO_PRT1_DR_INV
N#define COVER_CHK_INT__0__DR_SET CYREG_GPIO_PRT1_DR_SET
N#define COVER_CHK_INT__0__HSIOM CYREG_HSIOM_PORT_SEL1
N#define COVER_CHK_INT__0__HSIOM_MASK 0x0F000000u
N#define COVER_CHK_INT__0__HSIOM_SHIFT 24u
N#define COVER_CHK_INT__0__INTCFG CYREG_GPIO_PRT1_INTR_CFG
N#define COVER_CHK_INT__0__INTR CYREG_GPIO_PRT1_INTR
N#define COVER_CHK_INT__0__INTR_CFG CYREG_GPIO_PRT1_INTR_CFG
N#define COVER_CHK_INT__0__INTSTAT CYREG_GPIO_PRT1_INTR
N#define COVER_CHK_INT__0__MASK 0x40u
N#define COVER_CHK_INT__0__PC CYREG_GPIO_PRT1_PC
N#define COVER_CHK_INT__0__PC2 CYREG_GPIO_PRT1_PC2
N#define COVER_CHK_INT__0__PORT 1u
N#define COVER_CHK_INT__0__PS CYREG_GPIO_PRT1_PS
N#define COVER_CHK_INT__0__SHIFT 6u
N#define COVER_CHK_INT__DR CYREG_GPIO_PRT1_DR
N#define COVER_CHK_INT__DR_CLR CYREG_GPIO_PRT1_DR_CLR
N#define COVER_CHK_INT__DR_INV CYREG_GPIO_PRT1_DR_INV
N#define COVER_CHK_INT__DR_SET CYREG_GPIO_PRT1_DR_SET
N#define COVER_CHK_INT__INTCFG CYREG_GPIO_PRT1_INTR_CFG
N#define COVER_CHK_INT__INTR CYREG_GPIO_PRT1_INTR
N#define COVER_CHK_INT__INTR_CFG CYREG_GPIO_PRT1_INTR_CFG
N#define COVER_CHK_INT__INTSTAT CYREG_GPIO_PRT1_INTR
N#define COVER_CHK_INT__MASK 0x40u
N#define COVER_CHK_INT__PC CYREG_GPIO_PRT1_PC
N#define COVER_CHK_INT__PC2 CYREG_GPIO_PRT1_PC2
N#define COVER_CHK_INT__PORT 1u
N#define COVER_CHK_INT__PS CYREG_GPIO_PRT1_PS
N#define COVER_CHK_INT__SHIFT 6u
N
N/* SPI_0_OLED_FLASH */
N#define SPI_0_OLED_FLASH_miso_m__0__DR CYREG_GPIO_PRT2_DR
N#define SPI_0_OLED_FLASH_miso_m__0__DR_CLR CYREG_GPIO_PRT2_DR_CLR
N#define SPI_0_OLED_FLASH_miso_m__0__DR_INV CYREG_GPIO_PRT2_DR_INV
N#define SPI_0_OLED_FLASH_miso_m__0__DR_SET CYREG_GPIO_PRT2_DR_SET
N#define SPI_0_OLED_FLASH_miso_m__0__HSIOM CYREG_HSIOM_PORT_SEL2
N#define SPI_0_OLED_FLASH_miso_m__0__HSIOM_GPIO 0u
N#define SPI_0_OLED_FLASH_miso_m__0__HSIOM_I2C 14u
N#define SPI_0_OLED_FLASH_miso_m__0__HSIOM_I2C_SDA 14u
N#define SPI_0_OLED_FLASH_miso_m__0__HSIOM_MASK 0x000000F0u
N#define SPI_0_OLED_FLASH_miso_m__0__HSIOM_SHIFT 4u
N#define SPI_0_OLED_FLASH_miso_m__0__HSIOM_SPI 15u
N#define SPI_0_OLED_FLASH_miso_m__0__HSIOM_SPI_MISO 15u
N#define SPI_0_OLED_FLASH_miso_m__0__INTCFG CYREG_GPIO_PRT2_INTR_CFG
N#define SPI_0_OLED_FLASH_miso_m__0__INTR CYREG_GPIO_PRT2_INTR
N#define SPI_0_OLED_FLASH_miso_m__0__INTR_CFG CYREG_GPIO_PRT2_INTR_CFG
N#define SPI_0_OLED_FLASH_miso_m__0__INTSTAT CYREG_GPIO_PRT2_INTR
N#define SPI_0_OLED_FLASH_miso_m__0__MASK 0x02u
N#define SPI_0_OLED_FLASH_miso_m__0__PC CYREG_GPIO_PRT2_PC
N#define SPI_0_OLED_FLASH_miso_m__0__PC2 CYREG_GPIO_PRT2_PC2
N#define SPI_0_OLED_FLASH_miso_m__0__PORT 2u
N#define SPI_0_OLED_FLASH_miso_m__0__PS CYREG_GPIO_PRT2_PS
N#define SPI_0_OLED_FLASH_miso_m__0__SHIFT 1u
N#define SPI_0_OLED_FLASH_miso_m__DR CYREG_GPIO_PRT2_DR
N#define SPI_0_OLED_FLASH_miso_m__DR_CLR CYREG_GPIO_PRT2_DR_CLR
N#define SPI_0_OLED_FLASH_miso_m__DR_INV CYREG_GPIO_PRT2_DR_INV
N#define SPI_0_OLED_FLASH_miso_m__DR_SET CYREG_GPIO_PRT2_DR_SET
N#define SPI_0_OLED_FLASH_miso_m__INTCFG CYREG_GPIO_PRT2_INTR_CFG
N#define SPI_0_OLED_FLASH_miso_m__INTR CYREG_GPIO_PRT2_INTR
N#define SPI_0_OLED_FLASH_miso_m__INTR_CFG CYREG_GPIO_PRT2_INTR_CFG
N#define SPI_0_OLED_FLASH_miso_m__INTSTAT CYREG_GPIO_PRT2_INTR
N#define SPI_0_OLED_FLASH_miso_m__MASK 0x02u
N#define SPI_0_OLED_FLASH_miso_m__PC CYREG_GPIO_PRT2_PC
N#define SPI_0_OLED_FLASH_miso_m__PC2 CYREG_GPIO_PRT2_PC2
N#define SPI_0_OLED_FLASH_miso_m__PORT 2u
N#define SPI_0_OLED_FLASH_miso_m__PS CYREG_GPIO_PRT2_PS
N#define SPI_0_OLED_FLASH_miso_m__SHIFT 1u
N#define SPI_0_OLED_FLASH_mosi_m__0__DR CYREG_GPIO_PRT2_DR
N#define SPI_0_OLED_FLASH_mosi_m__0__DR_CLR CYREG_GPIO_PRT2_DR_CLR
N#define SPI_0_OLED_FLASH_mosi_m__0__DR_INV CYREG_GPIO_PRT2_DR_INV
N#define SPI_0_OLED_FLASH_mosi_m__0__DR_SET CYREG_GPIO_PRT2_DR_SET
N#define SPI_0_OLED_FLASH_mosi_m__0__HSIOM CYREG_HSIOM_PORT_SEL2
N#define SPI_0_OLED_FLASH_mosi_m__0__HSIOM_GPIO 0u
N#define SPI_0_OLED_FLASH_mosi_m__0__HSIOM_I2C 14u
N#define SPI_0_OLED_FLASH_mosi_m__0__HSIOM_I2C_SCL 14u
N#define SPI_0_OLED_FLASH_mosi_m__0__HSIOM_MASK 0x0000000Fu
N#define SPI_0_OLED_FLASH_mosi_m__0__HSIOM_SHIFT 0u
N#define SPI_0_OLED_FLASH_mosi_m__0__HSIOM_SPI 15u
N#define SPI_0_OLED_FLASH_mosi_m__0__HSIOM_SPI_MOSI 15u
N#define SPI_0_OLED_FLASH_mosi_m__0__INTCFG CYREG_GPIO_PRT2_INTR_CFG
N#define SPI_0_OLED_FLASH_mosi_m__0__INTR CYREG_GPIO_PRT2_INTR
N#define SPI_0_OLED_FLASH_mosi_m__0__INTR_CFG CYREG_GPIO_PRT2_INTR_CFG
N#define SPI_0_OLED_FLASH_mosi_m__0__INTSTAT CYREG_GPIO_PRT2_INTR
N#define SPI_0_OLED_FLASH_mosi_m__0__MASK 0x01u
N#define SPI_0_OLED_FLASH_mosi_m__0__PC CYREG_GPIO_PRT2_PC
N#define SPI_0_OLED_FLASH_mosi_m__0__PC2 CYREG_GPIO_PRT2_PC2
N#define SPI_0_OLED_FLASH_mosi_m__0__PORT 2u
N#define SPI_0_OLED_FLASH_mosi_m__0__PS CYREG_GPIO_PRT2_PS
N#define SPI_0_OLED_FLASH_mosi_m__0__SHIFT 0u
N#define SPI_0_OLED_FLASH_mosi_m__DR CYREG_GPIO_PRT2_DR
N#define SPI_0_OLED_FLASH_mosi_m__DR_CLR CYREG_GPIO_PRT2_DR_CLR
N#define SPI_0_OLED_FLASH_mosi_m__DR_INV CYREG_GPIO_PRT2_DR_INV
N#define SPI_0_OLED_FLASH_mosi_m__DR_SET CYREG_GPIO_PRT2_DR_SET
N#define SPI_0_OLED_FLASH_mosi_m__INTCFG CYREG_GPIO_PRT2_INTR_CFG
N#define SPI_0_OLED_FLASH_mosi_m__INTR CYREG_GPIO_PRT2_INTR
N#define SPI_0_OLED_FLASH_mosi_m__INTR_CFG CYREG_GPIO_PRT2_INTR_CFG
N#define SPI_0_OLED_FLASH_mosi_m__INTSTAT CYREG_GPIO_PRT2_INTR
N#define SPI_0_OLED_FLASH_mosi_m__MASK 0x01u
N#define SPI_0_OLED_FLASH_mosi_m__PC CYREG_GPIO_PRT2_PC
N#define SPI_0_OLED_FLASH_mosi_m__PC2 CYREG_GPIO_PRT2_PC2
N#define SPI_0_OLED_FLASH_mosi_m__PORT 2u
N#define SPI_0_OLED_FLASH_mosi_m__PS CYREG_GPIO_PRT2_PS
N#define SPI_0_OLED_FLASH_mosi_m__SHIFT 0u
N#define SPI_0_OLED_FLASH_SCB__CTRL CYREG_SCB1_CTRL
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA0 CYREG_SCB1_EZ_DATA0
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA1 CYREG_SCB1_EZ_DATA1
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA10 CYREG_SCB1_EZ_DATA10
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA11 CYREG_SCB1_EZ_DATA11
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA12 CYREG_SCB1_EZ_DATA12
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA13 CYREG_SCB1_EZ_DATA13
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA14 CYREG_SCB1_EZ_DATA14
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA15 CYREG_SCB1_EZ_DATA15
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA16 CYREG_SCB1_EZ_DATA16
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA17 CYREG_SCB1_EZ_DATA17
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA18 CYREG_SCB1_EZ_DATA18
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA19 CYREG_SCB1_EZ_DATA19
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA2 CYREG_SCB1_EZ_DATA2
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA20 CYREG_SCB1_EZ_DATA20
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA21 CYREG_SCB1_EZ_DATA21
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA22 CYREG_SCB1_EZ_DATA22
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA23 CYREG_SCB1_EZ_DATA23
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA24 CYREG_SCB1_EZ_DATA24
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA25 CYREG_SCB1_EZ_DATA25
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA26 CYREG_SCB1_EZ_DATA26
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA27 CYREG_SCB1_EZ_DATA27
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA28 CYREG_SCB1_EZ_DATA28
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA29 CYREG_SCB1_EZ_DATA29
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA3 CYREG_SCB1_EZ_DATA3
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA30 CYREG_SCB1_EZ_DATA30
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA31 CYREG_SCB1_EZ_DATA31
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA4 CYREG_SCB1_EZ_DATA4
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA5 CYREG_SCB1_EZ_DATA5
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA6 CYREG_SCB1_EZ_DATA6
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA7 CYREG_SCB1_EZ_DATA7
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA8 CYREG_SCB1_EZ_DATA8
N#define SPI_0_OLED_FLASH_SCB__EZ_DATA9 CYREG_SCB1_EZ_DATA9
N#define SPI_0_OLED_FLASH_SCB__I2C_CFG CYREG_SCB1_I2C_CFG
N#define SPI_0_OLED_FLASH_SCB__I2C_CTRL CYREG_SCB1_I2C_CTRL
N#define SPI_0_OLED_FLASH_SCB__I2C_M_CMD CYREG_SCB1_I2C_M_CMD
N#define SPI_0_OLED_FLASH_SCB__I2C_S_CMD CYREG_SCB1_I2C_S_CMD
N#define SPI_0_OLED_FLASH_SCB__I2C_STATUS CYREG_SCB1_I2C_STATUS
N#define SPI_0_OLED_FLASH_SCB__INTR_CAUSE CYREG_SCB1_INTR_CAUSE
N#define SPI_0_OLED_FLASH_SCB__INTR_I2C_EC CYREG_SCB1_INTR_I2C_EC
N#define SPI_0_OLED_FLASH_SCB__INTR_I2C_EC_MASK CYREG_SCB1_INTR_I2C_EC_MASK
N#define SPI_0_OLED_FLASH_SCB__INTR_I2C_EC_MASKED CYREG_SCB1_INTR_I2C_EC_MASKED
N#define SPI_0_OLED_FLASH_SCB__INTR_M CYREG_SCB1_INTR_M
N#define SPI_0_OLED_FLASH_SCB__INTR_M_MASK CYREG_SCB1_INTR_M_MASK
N#define SPI_0_OLED_FLASH_SCB__INTR_M_MASKED CYREG_SCB1_INTR_M_MASKED
N#define SPI_0_OLED_FLASH_SCB__INTR_M_SET CYREG_SCB1_INTR_M_SET
N#define SPI_0_OLED_FLASH_SCB__INTR_RX CYREG_SCB1_INTR_RX
N#define SPI_0_OLED_FLASH_SCB__INTR_RX_MASK CYREG_SCB1_INTR_RX_MASK
N#define SPI_0_OLED_FLASH_SCB__INTR_RX_MASKED CYREG_SCB1_INTR_RX_MASKED
N#define SPI_0_OLED_FLASH_SCB__INTR_RX_SET CYREG_SCB1_INTR_RX_SET
N#define SPI_0_OLED_FLASH_SCB__INTR_S CYREG_SCB1_INTR_S
N#define SPI_0_OLED_FLASH_SCB__INTR_S_MASK CYREG_SCB1_INTR_S_MASK
N#define SPI_0_OLED_FLASH_SCB__INTR_S_MASKED CYREG_SCB1_INTR_S_MASKED
N#define SPI_0_OLED_FLASH_SCB__INTR_S_SET CYREG_SCB1_INTR_S_SET
N#define SPI_0_OLED_FLASH_SCB__INTR_SPI_EC CYREG_SCB1_INTR_SPI_EC
N#define SPI_0_OLED_FLASH_SCB__INTR_SPI_EC_MASK CYREG_SCB1_INTR_SPI_EC_MASK
N#define SPI_0_OLED_FLASH_SCB__INTR_SPI_EC_MASKED CYREG_SCB1_INTR_SPI_EC_MASKED
N#define SPI_0_OLED_FLASH_SCB__INTR_TX CYREG_SCB1_INTR_TX
N#define SPI_0_OLED_FLASH_SCB__INTR_TX_MASK CYREG_SCB1_INTR_TX_MASK
N#define SPI_0_OLED_FLASH_SCB__INTR_TX_MASKED CYREG_SCB1_INTR_TX_MASKED
N#define SPI_0_OLED_FLASH_SCB__INTR_TX_SET CYREG_SCB1_INTR_TX_SET
N#define SPI_0_OLED_FLASH_SCB__RX_CTRL CYREG_SCB1_RX_CTRL
N#define SPI_0_OLED_FLASH_SCB__RX_FIFO_CTRL CYREG_SCB1_RX_FIFO_CTRL
N#define SPI_0_OLED_FLASH_SCB__RX_FIFO_RD CYREG_SCB1_RX_FIFO_RD
N#define SPI_0_OLED_FLASH_SCB__RX_FIFO_RD_SILENT CYREG_SCB1_RX_FIFO_RD_SILENT
N#define SPI_0_OLED_FLASH_SCB__RX_FIFO_STATUS CYREG_SCB1_RX_FIFO_STATUS
N#define SPI_0_OLED_FLASH_SCB__RX_MATCH CYREG_SCB1_RX_MATCH
N#define SPI_0_OLED_FLASH_SCB__SPI_CTRL CYREG_SCB1_SPI_CTRL
N#define SPI_0_OLED_FLASH_SCB__SPI_STATUS CYREG_SCB1_SPI_STATUS
N#define SPI_0_OLED_FLASH_SCB__SS0_POSISTION 0u
N#define SPI_0_OLED_FLASH_SCB__SS1_POSISTION 1u
N#define SPI_0_OLED_FLASH_SCB__SS2_POSISTION 2u
N#define SPI_0_OLED_FLASH_SCB__SS3_POSISTION 3u
N#define SPI_0_OLED_FLASH_SCB__STATUS CYREG_SCB1_STATUS
N#define SPI_0_OLED_FLASH_SCB__TX_CTRL CYREG_SCB1_TX_CTRL
N#define SPI_0_OLED_FLASH_SCB__TX_FIFO_CTRL CYREG_SCB1_TX_FIFO_CTRL
N#define SPI_0_OLED_FLASH_SCB__TX_FIFO_STATUS CYREG_SCB1_TX_FIFO_STATUS
N#define SPI_0_OLED_FLASH_SCB__TX_FIFO_WR CYREG_SCB1_TX_FIFO_WR
N#define SPI_0_OLED_FLASH_SCB__UART_CTRL CYREG_SCB1_UART_CTRL
N#define SPI_0_OLED_FLASH_SCB__UART_FLOW_CTRL CYREG_SCB1_UART_FLOW_CTRL
N#define SPI_0_OLED_FLASH_SCB__UART_RX_CTRL CYREG_SCB1_UART_RX_CTRL
N#define SPI_0_OLED_FLASH_SCB__UART_RX_STATUS CYREG_SCB1_UART_RX_STATUS
N#define SPI_0_OLED_FLASH_SCB__UART_TX_CTRL CYREG_SCB1_UART_TX_CTRL
N#define SPI_0_OLED_FLASH_SCBCLK__CTRL_REGISTER CYREG_PERI_PCLK_CTL1
N#define SPI_0_OLED_FLASH_SCBCLK__DIV_ID 0x00000042u
N#define SPI_0_OLED_FLASH_SCBCLK__DIV_REGISTER CYREG_PERI_DIV_16_CTL2
N#define SPI_0_OLED_FLASH_SCBCLK__PA_DIV_ID 0x000000FFu
N#define SPI_0_OLED_FLASH_sclk_m__0__DR CYREG_GPIO_PRT2_DR
N#define SPI_0_OLED_FLASH_sclk_m__0__DR_CLR CYREG_GPIO_PRT2_DR_CLR
N#define SPI_0_OLED_FLASH_sclk_m__0__DR_INV CYREG_GPIO_PRT2_DR_INV
N#define SPI_0_OLED_FLASH_sclk_m__0__DR_SET CYREG_GPIO_PRT2_DR_SET
N#define SPI_0_OLED_FLASH_sclk_m__0__HSIOM CYREG_HSIOM_PORT_SEL2
N#define SPI_0_OLED_FLASH_sclk_m__0__HSIOM_GPIO 0u
N#define SPI_0_OLED_FLASH_sclk_m__0__HSIOM_MASK 0x00000F00u
N#define SPI_0_OLED_FLASH_sclk_m__0__HSIOM_SHIFT 8u
N#define SPI_0_OLED_FLASH_sclk_m__0__HSIOM_SPI 15u
N#define SPI_0_OLED_FLASH_sclk_m__0__HSIOM_SPI_CLK 15u
N#define SPI_0_OLED_FLASH_sclk_m__0__INTCFG CYREG_GPIO_PRT2_INTR_CFG
N#define SPI_0_OLED_FLASH_sclk_m__0__INTR CYREG_GPIO_PRT2_INTR
N#define SPI_0_OLED_FLASH_sclk_m__0__INTR_CFG CYREG_GPIO_PRT2_INTR_CFG
N#define SPI_0_OLED_FLASH_sclk_m__0__INTSTAT CYREG_GPIO_PRT2_INTR
N#define SPI_0_OLED_FLASH_sclk_m__0__MASK 0x04u
N#define SPI_0_OLED_FLASH_sclk_m__0__PC CYREG_GPIO_PRT2_PC
N#define SPI_0_OLED_FLASH_sclk_m__0__PC2 CYREG_GPIO_PRT2_PC2
N#define SPI_0_OLED_FLASH_sclk_m__0__PORT 2u
N#define SPI_0_OLED_FLASH_sclk_m__0__PS CYREG_GPIO_PRT2_PS
N#define SPI_0_OLED_FLASH_sclk_m__0__SHIFT 2u
N#define SPI_0_OLED_FLASH_sclk_m__DR CYREG_GPIO_PRT2_DR
N#define SPI_0_OLED_FLASH_sclk_m__DR_CLR CYREG_GPIO_PRT2_DR_CLR
N#define SPI_0_OLED_FLASH_sclk_m__DR_INV CYREG_GPIO_PRT2_DR_INV
N#define SPI_0_OLED_FLASH_sclk_m__DR_SET CYREG_GPIO_PRT2_DR_SET
N#define SPI_0_OLED_FLASH_sclk_m__INTCFG CYREG_GPIO_PRT2_INTR_CFG
N#define SPI_0_OLED_FLASH_sclk_m__INTR CYREG_GPIO_PRT2_INTR
N#define SPI_0_OLED_FLASH_sclk_m__INTR_CFG CYREG_GPIO_PRT2_INTR_CFG
N#define SPI_0_OLED_FLASH_sclk_m__INTSTAT CYREG_GPIO_PRT2_INTR
N#define SPI_0_OLED_FLASH_sclk_m__MASK 0x04u
N#define SPI_0_OLED_FLASH_sclk_m__PC CYREG_GPIO_PRT2_PC
N#define SPI_0_OLED_FLASH_sclk_m__PC2 CYREG_GPIO_PRT2_PC2
N#define SPI_0_OLED_FLASH_sclk_m__PORT 2u
N#define SPI_0_OLED_FLASH_sclk_m__PS CYREG_GPIO_PRT2_PS
N#define SPI_0_OLED_FLASH_sclk_m__SHIFT 2u
N#define SPI_0_OLED_FLASH_ss0_m__0__DR CYREG_GPIO_PRT2_DR
N#define SPI_0_OLED_FLASH_ss0_m__0__DR_CLR CYREG_GPIO_PRT2_DR_CLR
N#define SPI_0_OLED_FLASH_ss0_m__0__DR_INV CYREG_GPIO_PRT2_DR_INV
N#define SPI_0_OLED_FLASH_ss0_m__0__DR_SET CYREG_GPIO_PRT2_DR_SET
N#define SPI_0_OLED_FLASH_ss0_m__0__HSIOM CYREG_HSIOM_PORT_SEL2
N#define SPI_0_OLED_FLASH_ss0_m__0__HSIOM_GPIO 0u
N#define SPI_0_OLED_FLASH_ss0_m__0__HSIOM_MASK 0x0000F000u
N#define SPI_0_OLED_FLASH_ss0_m__0__HSIOM_SHIFT 12u
N#define SPI_0_OLED_FLASH_ss0_m__0__HSIOM_SPI 15u
N#define SPI_0_OLED_FLASH_ss0_m__0__HSIOM_SPI_SELECT0 15u
N#define SPI_0_OLED_FLASH_ss0_m__0__INTCFG CYREG_GPIO_PRT2_INTR_CFG
N#define SPI_0_OLED_FLASH_ss0_m__0__INTR CYREG_GPIO_PRT2_INTR
N#define SPI_0_OLED_FLASH_ss0_m__0__INTR_CFG CYREG_GPIO_PRT2_INTR_CFG
N#define SPI_0_OLED_FLASH_ss0_m__0__INTSTAT CYREG_GPIO_PRT2_INTR
N#define SPI_0_OLED_FLASH_ss0_m__0__MASK 0x08u
N#define SPI_0_OLED_FLASH_ss0_m__0__PC CYREG_GPIO_PRT2_PC
N#define SPI_0_OLED_FLASH_ss0_m__0__PC2 CYREG_GPIO_PRT2_PC2
N#define SPI_0_OLED_FLASH_ss0_m__0__PORT 2u
N#define SPI_0_OLED_FLASH_ss0_m__0__PS CYREG_GPIO_PRT2_PS
N#define SPI_0_OLED_FLASH_ss0_m__0__SHIFT 3u
N#define SPI_0_OLED_FLASH_ss0_m__DR CYREG_GPIO_PRT2_DR
N#define SPI_0_OLED_FLASH_ss0_m__DR_CLR CYREG_GPIO_PRT2_DR_CLR
N#define SPI_0_OLED_FLASH_ss0_m__DR_INV CYREG_GPIO_PRT2_DR_INV
N#define SPI_0_OLED_FLASH_ss0_m__DR_SET CYREG_GPIO_PRT2_DR_SET
N#define SPI_0_OLED_FLASH_ss0_m__INTCFG CYREG_GPIO_PRT2_INTR_CFG
N#define SPI_0_OLED_FLASH_ss0_m__INTR CYREG_GPIO_PRT2_INTR
N#define SPI_0_OLED_FLASH_ss0_m__INTR_CFG CYREG_GPIO_PRT2_INTR_CFG
N#define SPI_0_OLED_FLASH_ss0_m__INTSTAT CYREG_GPIO_PRT2_INTR
N#define SPI_0_OLED_FLASH_ss0_m__MASK 0x08u
N#define SPI_0_OLED_FLASH_ss0_m__PC CYREG_GPIO_PRT2_PC
N#define SPI_0_OLED_FLASH_ss0_m__PC2 CYREG_GPIO_PRT2_PC2
N#define SPI_0_OLED_FLASH_ss0_m__PORT 2u
N#define SPI_0_OLED_FLASH_ss0_m__PS CYREG_GPIO_PRT2_PS
N#define SPI_0_OLED_FLASH_ss0_m__SHIFT 3u
N#define SPI_0_OLED_FLASH_ss1_m__0__DR CYREG_GPIO_PRT2_DR
N#define SPI_0_OLED_FLASH_ss1_m__0__DR_CLR CYREG_GPIO_PRT2_DR_CLR
N#define SPI_0_OLED_FLASH_ss1_m__0__DR_INV CYREG_GPIO_PRT2_DR_INV
N#define SPI_0_OLED_FLASH_ss1_m__0__DR_SET CYREG_GPIO_PRT2_DR_SET
N#define SPI_0_OLED_FLASH_ss1_m__0__HSIOM CYREG_HSIOM_PORT_SEL2
N#define SPI_0_OLED_FLASH_ss1_m__0__HSIOM_GPIO 0u
N#define SPI_0_OLED_FLASH_ss1_m__0__HSIOM_MASK 0x000F0000u
N#define SPI_0_OLED_FLASH_ss1_m__0__HSIOM_SHIFT 16u
N#define SPI_0_OLED_FLASH_ss1_m__0__HSIOM_SPI 15u
N#define SPI_0_OLED_FLASH_ss1_m__0__HSIOM_SPI_SELECT1 15u
N#define SPI_0_OLED_FLASH_ss1_m__0__INTCFG CYREG_GPIO_PRT2_INTR_CFG
N#define SPI_0_OLED_FLASH_ss1_m__0__INTR CYREG_GPIO_PRT2_INTR
N#define SPI_0_OLED_FLASH_ss1_m__0__INTR_CFG CYREG_GPIO_PRT2_INTR_CFG
N#define SPI_0_OLED_FLASH_ss1_m__0__INTSTAT CYREG_GPIO_PRT2_INTR
N#define SPI_0_OLED_FLASH_ss1_m__0__MASK 0x10u
N#define SPI_0_OLED_FLASH_ss1_m__0__PC CYREG_GPIO_PRT2_PC
N#define SPI_0_OLED_FLASH_ss1_m__0__PC2 CYREG_GPIO_PRT2_PC2
N#define SPI_0_OLED_FLASH_ss1_m__0__PORT 2u
N#define SPI_0_OLED_FLASH_ss1_m__0__PS CYREG_GPIO_PRT2_PS
N#define SPI_0_OLED_FLASH_ss1_m__0__SHIFT 4u
N#define SPI_0_OLED_FLASH_ss1_m__DR CYREG_GPIO_PRT2_DR
N#define SPI_0_OLED_FLASH_ss1_m__DR_CLR CYREG_GPIO_PRT2_DR_CLR
N#define SPI_0_OLED_FLASH_ss1_m__DR_INV CYREG_GPIO_PRT2_DR_INV
N#define SPI_0_OLED_FLASH_ss1_m__DR_SET CYREG_GPIO_PRT2_DR_SET
N#define SPI_0_OLED_FLASH_ss1_m__INTCFG CYREG_GPIO_PRT2_INTR_CFG
N#define SPI_0_OLED_FLASH_ss1_m__INTR CYREG_GPIO_PRT2_INTR
N#define SPI_0_OLED_FLASH_ss1_m__INTR_CFG CYREG_GPIO_PRT2_INTR_CFG
N#define SPI_0_OLED_FLASH_ss1_m__INTSTAT CYREG_GPIO_PRT2_INTR
N#define SPI_0_OLED_FLASH_ss1_m__MASK 0x10u
N#define SPI_0_OLED_FLASH_ss1_m__PC CYREG_GPIO_PRT2_PC
N#define SPI_0_OLED_FLASH_ss1_m__PC2 CYREG_GPIO_PRT2_PC2
N#define SPI_0_OLED_FLASH_ss1_m__PORT 2u
N#define SPI_0_OLED_FLASH_ss1_m__PS CYREG_GPIO_PRT2_PS
N#define SPI_0_OLED_FLASH_ss1_m__SHIFT 4u
N
N/* Miscellaneous */
N#define CY_PROJECT_NAME "LOCK"
N#define CY_VERSION "PSoC Creator  4.2"
N#define CYDEV_BANDGAP_VOLTAGE 1.200
N#define CYDEV_BCLK__HFCLK__HZ 48000000U
N#define CYDEV_BCLK__HFCLK__KHZ 48000U
N#define CYDEV_BCLK__HFCLK__MHZ 48U
N#define CYDEV_BCLK__SYSCLK__HZ 48000000U
N#define CYDEV_BCLK__SYSCLK__KHZ 48000U
N#define CYDEV_BCLK__SYSCLK__MHZ 48U
N#define CYDEV_CHIP_DIE_LEOPARD 1u
N#define CYDEV_CHIP_DIE_PSOC4A 18u
N#define CYDEV_CHIP_DIE_PSOC5LP 2u
N#define CYDEV_CHIP_DIE_PSOC5TM 3u
N#define CYDEV_CHIP_DIE_TMA4 4u
N#define CYDEV_CHIP_DIE_UNKNOWN 0u
N#define CYDEV_CHIP_FAMILY_FM0P 5u
N#define CYDEV_CHIP_FAMILY_FM3 6u
N#define CYDEV_CHIP_FAMILY_FM4 7u
N#define CYDEV_CHIP_FAMILY_PSOC3 1u
N#define CYDEV_CHIP_FAMILY_PSOC4 2u
N#define CYDEV_CHIP_FAMILY_PSOC5 3u
N#define CYDEV_CHIP_FAMILY_PSOC6 4u
N#define CYDEV_CHIP_FAMILY_UNKNOWN 0u
N#define CYDEV_CHIP_FAMILY_USED CYDEV_CHIP_FAMILY_PSOC4
N#define CYDEV_CHIP_JTAG_ID 0x257011B5u
N#define CYDEV_CHIP_MEMBER_3A 1u
N#define CYDEV_CHIP_MEMBER_4A 18u
N#define CYDEV_CHIP_MEMBER_4D 13u
N#define CYDEV_CHIP_MEMBER_4E 6u
N#define CYDEV_CHIP_MEMBER_4F 19u
N#define CYDEV_CHIP_MEMBER_4G 4u
N#define CYDEV_CHIP_MEMBER_4H 17u
N#define CYDEV_CHIP_MEMBER_4I 23u
N#define CYDEV_CHIP_MEMBER_4J 14u
N#define CYDEV_CHIP_MEMBER_4K 15u
N#define CYDEV_CHIP_MEMBER_4L 22u
N#define CYDEV_CHIP_MEMBER_4M 21u
N#define CYDEV_CHIP_MEMBER_4N 10u
N#define CYDEV_CHIP_MEMBER_4O 7u
N#define CYDEV_CHIP_MEMBER_4P 20u
N#define CYDEV_CHIP_MEMBER_4Q 12u
N#define CYDEV_CHIP_MEMBER_4R 8u
N#define CYDEV_CHIP_MEMBER_4S 11u
N#define CYDEV_CHIP_MEMBER_4T 9u
N#define CYDEV_CHIP_MEMBER_4U 5u
N#define CYDEV_CHIP_MEMBER_4V 16u
N#define CYDEV_CHIP_MEMBER_5A 3u
N#define CYDEV_CHIP_MEMBER_5B 2u
N#define CYDEV_CHIP_MEMBER_6A 24u
N#define CYDEV_CHIP_MEMBER_FM3 28u
N#define CYDEV_CHIP_MEMBER_FM4 29u
N#define CYDEV_CHIP_MEMBER_PDL_FM0P_TYPE1 25u
N#define CYDEV_CHIP_MEMBER_PDL_FM0P_TYPE2 26u
N#define CYDEV_CHIP_MEMBER_PDL_FM0P_TYPE3 27u
N#define CYDEV_CHIP_MEMBER_UNKNOWN 0u
N#define CYDEV_CHIP_MEMBER_USED CYDEV_CHIP_MEMBER_4V
N#define CYDEV_CHIP_DIE_EXPECT CYDEV_CHIP_MEMBER_USED
N#define CYDEV_CHIP_DIE_ACTUAL CYDEV_CHIP_DIE_EXPECT
N#define CYDEV_CHIP_REV_LEOPARD_ES1 0u
N#define CYDEV_CHIP_REV_LEOPARD_ES2 1u
N#define CYDEV_CHIP_REV_LEOPARD_ES3 3u
N#define CYDEV_CHIP_REV_LEOPARD_PRODUCTION 3u
N#define CYDEV_CHIP_REV_PSOC4A_ES0 17u
N#define CYDEV_CHIP_REV_PSOC4A_PRODUCTION 17u
N#define CYDEV_CHIP_REV_PSOC5LP_ES0 0u
N#define CYDEV_CHIP_REV_PSOC5LP_PRODUCTION 0u
N#define CYDEV_CHIP_REV_PSOC5TM_ES0 0u
N#define CYDEV_CHIP_REV_PSOC5TM_ES1 1u
N#define CYDEV_CHIP_REV_PSOC5TM_PRODUCTION 1u
N#define CYDEV_CHIP_REV_TMA4_ES 17u
N#define CYDEV_CHIP_REV_TMA4_ES2 33u
N#define CYDEV_CHIP_REV_TMA4_PRODUCTION 17u
N#define CYDEV_CHIP_REVISION_3A_ES1 0u
N#define CYDEV_CHIP_REVISION_3A_ES2 1u
N#define CYDEV_CHIP_REVISION_3A_ES3 3u
N#define CYDEV_CHIP_REVISION_3A_PRODUCTION 3u
N#define CYDEV_CHIP_REVISION_4A_ES0 17u
N#define CYDEV_CHIP_REVISION_4A_PRODUCTION 17u
N#define CYDEV_CHIP_REVISION_4D_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_4E_CCG2_NO_USBPD 0u
N#define CYDEV_CHIP_REVISION_4E_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_4F_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_4F_PRODUCTION_256DMA 0u
N#define CYDEV_CHIP_REVISION_4F_PRODUCTION_256K 0u
N#define CYDEV_CHIP_REVISION_4G_ES 17u
N#define CYDEV_CHIP_REVISION_4G_ES2 33u
N#define CYDEV_CHIP_REVISION_4G_PRODUCTION 17u
N#define CYDEV_CHIP_REVISION_4H_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_4I_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_4J_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_4K_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_4L_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_4M_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_4N_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_4O_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_4P_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_4Q_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_4R_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_4S_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_4T_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_4U_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_4V_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_5A_ES0 0u
N#define CYDEV_CHIP_REVISION_5A_ES1 1u
N#define CYDEV_CHIP_REVISION_5A_PRODUCTION 1u
N#define CYDEV_CHIP_REVISION_5B_ES0 0u
N#define CYDEV_CHIP_REVISION_5B_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_6A_ES 17u
N#define CYDEV_CHIP_REVISION_6A_NO_UDB 33u
N#define CYDEV_CHIP_REVISION_6A_PRODUCTION 33u
N#define CYDEV_CHIP_REVISION_FM3_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_FM4_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_PDL_FM0P_TYPE1_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_PDL_FM0P_TYPE2_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_PDL_FM0P_TYPE3_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_USED CYDEV_CHIP_REVISION_4V_PRODUCTION
N#define CYDEV_CHIP_REV_EXPECT CYDEV_CHIP_REVISION_USED
N#define CYDEV_CONFIG_READ_ACCELERATOR 1
N#define CYDEV_CONFIG_UNUSED_IO_AllowButWarn 0
N#define CYDEV_CONFIG_UNUSED_IO_AllowWithInfo 1
N#define CYDEV_CONFIG_UNUSED_IO_Disallowed 2
N#define CYDEV_CONFIG_UNUSED_IO CYDEV_CONFIG_UNUSED_IO_Disallowed
N#define CYDEV_CONFIGURATION_COMPRESSED 1
N#define CYDEV_CONFIGURATION_MODE_COMPRESSED 0
N#define CYDEV_CONFIGURATION_MODE CYDEV_CONFIGURATION_MODE_COMPRESSED
N#define CYDEV_CONFIGURATION_MODE_DMA 2
N#define CYDEV_CONFIGURATION_MODE_UNCOMPRESSED 1
N#define CYDEV_DEBUG_PROTECT_KILL 4
N#define CYDEV_DEBUG_PROTECT_OPEN 1
N#define CYDEV_DEBUG_PROTECT CYDEV_DEBUG_PROTECT_OPEN
N#define CYDEV_DEBUG_PROTECT_PROTECTED 2
N#define CYDEV_DEBUGGING_DPS_Disable 3
N#define CYDEV_DEBUGGING_DPS_SWD 2
N#define CYDEV_DEBUGGING_DPS CYDEV_DEBUGGING_DPS_SWD
N#define CYDEV_DEBUGGING_ENABLE 1
N#define CYDEV_DFT_SELECT_CLK0 8u
N#define CYDEV_DFT_SELECT_CLK1 9u
N#define CYDEV_DMA_CHANNELS_AVAILABLE 8
N#define CYDEV_HEAP_SIZE 0x80
N#define CYDEV_IMO_TRIMMED_BY_USB 0u
N#define CYDEV_IMO_TRIMMED_BY_WCO 0u
N#define CYDEV_INTR_NUMBER_DMA 14u
N#define CYDEV_IS_EXPORTING_CODE 0
N#define CYDEV_IS_IMPORTING_CODE 0
N#define CYDEV_PROJ_TYPE 0
N#define CYDEV_PROJ_TYPE_BOOTLOADER 1
N#define CYDEV_PROJ_TYPE_LAUNCHER 5
N#define CYDEV_PROJ_TYPE_LOADABLE 2
N#define CYDEV_PROJ_TYPE_LOADABLEANDBOOTLOADER 4
N#define CYDEV_PROJ_TYPE_MULTIAPPBOOTLOADER 3
N#define CYDEV_PROJ_TYPE_STANDARD 0
N#define CYDEV_RTC_SOURCE_DIV 32768
N#define CYDEV_RTC_SOURCE_WDT 2u
N#define CYDEV_STACK_SIZE 0x0800
N#define CYDEV_TIMER2_DIV 32768
N#define CYDEV_USE_BUNDLED_CMSIS 1
N#define CYDEV_VARIABLE_VDDA 1
N#define CYDEV_VDDA 3.3
N#define CYDEV_VDDA_MV 3300
N#define CYDEV_VDDD 3.3
N#define CYDEV_VDDD_MV 3300
N#define CYDEV_WDT_GENERATE_ISR 1u
N#define CYIPBLOCK_m0s8cpussv3_VERSION 1
N#define CYIPBLOCK_m0s8crypto_VERSION 2
N#define CYIPBLOCK_m0s8csdv2_VERSION 2
N#define CYIPBLOCK_m0s8exco_VERSION 1
N#define CYIPBLOCK_m0s8ioss_VERSION 1
N#define CYIPBLOCK_m0s8lcd_VERSION 2
N#define CYIPBLOCK_m0s8lpcomp_VERSION 2
N#define CYIPBLOCK_m0s8pass4a_VERSION 1
N#define CYIPBLOCK_m0s8peri_VERSION 1
N#define CYIPBLOCK_m0s8scb_VERSION 2
N#define CYIPBLOCK_m0s8tcpwm_VERSION 2
N#define CYIPBLOCK_m0s8wco_VERSION 1
N#define CYIPBLOCK_s8srsslt_VERSION 1
N#define DMA_CHANNELS_USED__MASK 0u
N#define CYDEV_BOOTLOADER_ENABLE 0
N
N#endif /* INCLUDED_CYFITTER_H */
L 38 "Generated_Source\PSoC4\cytypes.h" 2
N
N
N#if defined( __ICCARM__ )
X#if 0L
S    /* Suppress warning for multiple volatile variables in an expression. */
S    /* This is common in component code and usage is not order dependent. */
S    #pragma diag_suppress=Pa082
N#endif  /* defined( __ICCARM__ ) */
N
N
N/***************************************
N* Conditional Compilation Parameters
N***************************************/
N
N
N/*******************************************************************************
N* FAMILY encodes the overall architectural family
N*******************************************************************************/
N#define CY_PSOC3 (CYDEV_CHIP_FAMILY_USED == CYDEV_CHIP_FAMILY_PSOC3)
N#define CY_PSOC4 (CYDEV_CHIP_FAMILY_USED == CYDEV_CHIP_FAMILY_PSOC4)
N#define CY_PSOC5 (CYDEV_CHIP_FAMILY_USED == CYDEV_CHIP_FAMILY_PSOC5)
N
N
N/*******************************************************************************
N* MEMBER encodes both the family and the detailed architecture
N*******************************************************************************/
N#ifdef CYDEV_CHIP_MEMBER_4D
N    #define CY_PSOC4_4000   (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4D)
N#else
S    #define CY_PSOC4_4000   (0u != 0u)
N#endif  /* CYDEV_CHIP_MEMBER_4D */
N
N#define CY_PSOC4_4100       (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4A)
N#define CY_PSOC4_4200       (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4A)
N
N#ifdef CYDEV_CHIP_MEMBER_4F
N    #define CY_PSOC4_4100BL (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4F)
N    #define CY_PSOC4_4200BL (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4F)
N#else
S    #define CY_PSOC4_4100BL (0u != 0u)
S    #define CY_PSOC4_4200BL (0u != 0u)
N#endif  /* CYDEV_CHIP_MEMBER_4F */
N
N#ifdef CYDEV_CHIP_MEMBER_4M
N    #define CY_PSOC4_4100M (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4M)
N    #define CY_PSOC4_4200M (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4M)
N#else
S    #define CY_PSOC4_4100M (0u != 0u)
S    #define CY_PSOC4_4200M (0u != 0u)
N#endif  /* CYDEV_CHIP_MEMBER_4M */
N
N#ifdef CYDEV_CHIP_MEMBER_4H
N    #define CY_PSOC4_4200D (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4H)
N#else
S    #define CY_PSOC4_4200D (0u != 0u)
N#endif  /* CYDEV_CHIP_MEMBER_4H */
N
N#ifdef CYDEV_CHIP_MEMBER_4L
N    #define CY_PSOC4_4200L (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4L)
N#else
S    #define CY_PSOC4_4200L (0u != 0u)
N#endif  /* CYDEV_CHIP_MEMBER_4L */
N
N#ifdef CYDEV_CHIP_MEMBER_4U
N    #define CY_PSOC4_4000U (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4U)
N#else
S    #define CY_PSOC4_4000U (0u != 0u)
N#endif  /* CYDEV_CHIP_MEMBER_4U */
N
N#ifdef CYDEV_CHIP_MEMBER_4J
N    #define CY_PSOC4_4000S (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4J)
N#else
S    #define CY_PSOC4_4000S (0u != 0u)
N#endif  /* CYDEV_CHIP_MEMBER_4J */
N
N#ifdef CYDEV_CHIP_MEMBER_4K
N    #define CY_PSOC4_4100S (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4K)
N#else
S    #define CY_PSOC4_4100S (0u != 0u)
N#endif  /* CYDEV_CHIP_MEMBER_4K */
N
N#ifdef CYDEV_CHIP_MEMBER_4I
N    #define CY_PSOC4_4400 (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4I)
N#else
S    #define CY_PSOC4_4400 (0u != 0u)
N#endif  /* CYDEV_CHIP_MEMBER_4I */
N
N#ifdef CYDEV_CHIP_MEMBER_4E
N    #define CY_CCG2 (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4E)
N#else
S    #define CY_CCG2 (0u != 0u)
N#endif  /* CYDEV_CHIP_MEMBER_4E */
N
N#ifdef CYDEV_CHIP_MEMBER_4O
N    #define CY_CCG3 (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4O)
N#else
S    #define CY_CCG3 (0u != 0u)
N#endif  /* CYDEV_CHIP_MEMBER_4O */
N
N#ifdef CYDEV_CHIP_MEMBER_4R
N    #define CY_CCG3PA (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4R)
N#else
S    #define CY_CCG3PA (0u != 0u)
N#endif  /* CYDEV_CHIP_MEMBER_4R */
N
N#ifdef CYDEV_CHIP_MEMBER_4N
N    #define CY_CCG4 (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4N)
N#else
S    #define CY_CCG4 (0u != 0u)
N#endif  /* CYDEV_CHIP_MEMBER_4N */
N
N#ifdef CYDEV_CHIP_MEMBER_4S
N    #define CY_CCG5 (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4S)
N#else
S    #define CY_CCG5 (0u != 0u)
N#endif  /* CYDEV_CHIP_MEMBER_4S */
N
N#ifdef CYDEV_CHIP_MEMBER_4P
N    #define CY_PSOC4_4100BLII (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4P)
N    #define CY_PSOC4_4200BLII (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4P)
N#else
S    #define CY_PSOC4_4100BLII (0u != 0u)
S    #define CY_PSOC4_4200BLII (0u != 0u)
N#endif  /* CYDEV_CHIP_MEMBER_4P */
N
N#ifdef CYDEV_CHIP_MEMBER_4V
N    #define CY_PSOC4_4100MS (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4V)
N    #define CY_PSOC4_4100MS (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4V)
N#else
S    #define CY_PSOC4_4100MS (0u != 0u)
S    #define CY_PSOC4_4100MS (0u != 0u)
N#endif  /* CYDEV_CHIP_MEMBER_4V */
N
N#define CY_IP_HOBTO_DEVICE      (!(0 == 1))
N
N
N/*******************************************************************************
N* IP blocks
N*******************************************************************************/
N#if (CY_PSOC4)
X#if ((2u == 2u))
N
N    /* Using SRSSv2 or SRS-Lite */
N    #if (CY_IP_HOBTO_DEVICE)
X    #if ((!(0 == 1)))
N        #define CY_IP_SRSSV2            (0 != 0)
N        #define CY_IP_SRSSLT            (!CY_IP_SRSSV2)
N    #else
S        #define CY_IP_SRSSV2            (0 == 0)
S        #define CY_IP_SRSSLT            (!CY_IP_SRSSV2)
N    #endif  /* (CY_IP_HOBTO_DEVICE) */
N
N    #if (CY_IP_HOBTO_DEVICE)
X    #if ((!(0 == 1)))
N        #define CY_IP_CPUSSV3           (1 == 1)
N        #define CY_IP_CPUSSV2           (0 == 1)
N        #define CY_IP_CPUSS             (0 == 1)
N    #else
S        #define CY_IP_CPUSSV3           (0 != 0)
S        #define CY_IP_CPUSSV2           (0 != 0)
S        #define CY_IP_CPUSS             (0 == 0)
N    #endif  /* (CY_IP_HOBTO_DEVICE) */
N
N    /* CM0 present or CM0+ present (1=CM0, 0=CM0+) */
N    #if (CY_IP_HOBTO_DEVICE)
X    #if ((!(0 == 1)))
N        #if (CY_IP_CPUSSV2)
X        #if ((0 == 1))
S            #define CY_IP_CPUSS_CM0         (0 == 0)
N        #else   /* CY_IP_CPUSSV3 */
N            #define CY_IP_CPUSS_CM0         (0 == 1)
N        #endif  /* (CY_IP_CPUSSV2) */
N        #define CY_IP_CPUSS_CM0PLUS         (!CY_IP_CPUSS_CM0)
N    #else
S        #define CY_IP_CPUSS_CM0             (0 == 0)
S        #define CY_IP_CPUSS_CM0PLUS         (0 != 0)
N    #endif  /* (CY_IP_HOBTO_DEVICE) */
N
N
N    /* Flash memory present or not (1=Flash present, 0=Flash not present) */
N    #if (CY_IP_HOBTO_DEVICE)
X    #if ((!(0 == 1)))
N        #define CY_IP_CPUSS_FLASHC_PRESENT      (0 == 0)
N    #else
S        #define CY_IP_CPUSS_FLASHC_PRESENT      (0 != 0)
N    #endif  /* (CY_IP_HOBTO_DEVICE) */
N
N
N    /* Product uses FLASH-Lite or regular FLASH */
N    #if (CY_IP_HOBTO_DEVICE)
X    #if ((!(0 == 1)))
N        #if (CY_IP_CPUSSV2)
X        #if ((0 == 1))
S            #define CY_IP_FM                (-1 == 0)
S            #define CY_IP_FMLT              (-1 == 1)
S            #define CY_IP_FS                (-1 == 2)
S            #define CY_IP_FSLT              (-1 == 3)
N        #else   /* CY_IP_CPUSSV3 */
N            #define CY_IP_FM                (3 == 0)
N            #define CY_IP_FMLT              (3 == 1)
N            #define CY_IP_FS                (3 == 2)
N            #define CY_IP_FSLT              (3 == 3)
N        #endif  /* (CY_IP_CPUSSV2) */
N    #else
S        #define CY_IP_FM                (!CY_IP_FMLT)       /* Regular FLASH */
S        #define CY_IP_FMLT              (0 != 0)            /* FLASH-Lite */
S        #define CY_IP_FS                (0 != 0)            /* FS */
S        #define CY_IP_FSLT              (0 != 0)            /* FSLT */
N    #endif  /* (CY_IP_HOBTO_DEVICE) */
N
N
N    /* Enable simultaneous execution/programming in multi-macro devices */
N    #if (CY_IP_HOBTO_DEVICE)
X    #if ((!(0 == 1)))
N        #if (CY_IP_CPUSSV2)
X        #if ((0 == 1))
S            #define CY_IP_FLASH_PARALLEL_PGM_EN (-1 == 1)
N        #else   /* CY_IP_CPUSSV3 */
N            #define CY_IP_FLASH_PARALLEL_PGM_EN (0 == 1)
N        #endif  /* (CY_IP_CPUSSV2) */
N    #else
S        #define CY_IP_FLASH_PARALLEL_PGM_EN     (0u != 0u)
N    #endif  /* (CY_IP_HOBTO_DEVICE) */
N
N
N    /* Number of Flash macros used in the device (0, 1 or 2) */
N    #if (CY_IP_HOBTO_DEVICE)
X    #if ((!(0 == 1)))
N        #if (CY_IP_CPUSSV2)
X        #if ((0 == 1))
S            #define CY_IP_FLASH_MACROS (-1u)
N        #else   /* CY_IP_CPUSSV3 */
N            #define CY_IP_FLASH_MACROS (1u)
N        #endif  /* (CY_IP_CPUSSV2) */
N    #else
S        #define CY_IP_FLASH_MACROS     (1u)
N    #endif  /* (CY_IP_HOBTO_DEVICE) */
N
N    /* Number of interrupt request inputs to CM0 */
N    #if (CY_IP_HOBTO_DEVICE)
X    #if ((!(0 == 1)))
N        #if (CY_IP_CPUSSV2)
X        #if ((0 == 1))
S            #define CY_IP_INT_NR            (-1u)
N        #else   /* CY_IP_CPUSSV3 */
N            #define CY_IP_INT_NR            (28u)
N        #endif  /* (CY_IP_CPUSSV2) */
N    #else
S        #define CY_IP_INT_NR            (32u)
N    #endif  /* (CY_IP_HOBTO_DEVICE) */
N
N
N    /* Presence of the BLESS IP block */
N    #if (CY_IP_HOBTO_DEVICE)
X    #if ((!(0 == 1)))
N        #define CY_IP_BLESS             (0 != 0)
N        #define CY_IP_BLESSV3           (CYIPBLOCK_m0s8bless_VERSION == 3)
N    #else
S        #define CY_IP_BLESS             (0 != 0)
S        #define CY_IP_BLESSV3           (0 != 0)
N    #endif  /* (CY_IP_HOBTO_DEVICE) */
N
N    #if (CY_IP_HOBTO_DEVICE)
X    #if ((!(0 == 1)))
N        #define CY_IP_USBDEV            (0 != 0)
N    #else
S        #define CY_IP_USBDEV            (0 != 0)
N    #endif  /* (CY_IP_HOBTO_DEVICE) */
N
N
N    /***************************************************************************
N    * Devices with the SPCIF_SYNCHRONOUS parameter set to one will not use
N    * the 36MHz Oscillator for Flash operation. Instead, flash write function
N    * ensures that the charge pump clock and the higher frequency clock (HFCLK)
N    * are set to the IMO at 48MHz prior to writing the flash.
N    ***************************************************************************/
N    #if (CY_IP_HOBTO_DEVICE)
X    #if ((!(0 == 1)))
N        #if (CY_IP_CPUSSV2)
X        #if ((0 == 1))
S            #define CY_IP_SPCIF_SYNCHRONOUS     (-1 == 1)
N        #else   /* CY_IP_CPUSSV3 */
N            #define CY_IP_SPCIF_SYNCHRONOUS     (1 == 1)
N        #endif  /* (CY_IP_CPUSSV2) */
N    #else
S        #define CY_IP_SPCIF_SYNCHRONOUS     (0 != 0)
N    #endif  /* (CY_IP_HOBTO_DEVICE) */
N
N    /* Watch Crystal Oscillator (WCO) is present (32kHz) */
N    #if (CY_IP_HOBTO_DEVICE)
X    #if ((!(0 == 1)))
N        #if (CY_IP_BLESS)
X        #if ((0 != 0))
S            #define CY_IP_WCO_WCO           (0 != 0)
S            #define CY_IP_WCO_SRSSV2        (0 != 0)
S            #if (CY_IP_BLESSV3)
S                #define CY_IP_WCO_WCOV2     (0 == 0)
S                #define CY_IP_WCO_BLESS     (0 != 0)                
S            #else
S                #define CY_IP_WCO_WCOV2     (0 != 0)
S                #define CY_IP_WCO_BLESS     (0 == 0)
S            #endif
N        #else
N            #define CY_IP_WCO_BLESS         (0 != 0)
N            #define CY_IP_WCO_WCO           (1 == 1)
N            #define CY_IP_WCO_WCOV2         (0 != 0)
N            #define CY_IP_WCO_SRSSV2        (-1 == 1)
N        #endif  /* (CY_IP_BLESS) */
N    #else
S        #define CY_IP_WCO_BLESS             (0 != 0)
S        #define CY_IP_WCO_WCO               (0 != 0)
S        #define CY_IP_WCO_WCOV2             (0 != 0)
S        #define CY_IP_WCO_SRSSV2            (0 != 0)
N    #endif  /* (CY_IP_HOBTO_DEVICE) */
N
N    #define CY_IP_WCO   (CY_IP_WCO_BLESS || CY_IP_WCO_WCO || CY_IP_WCO_WCOV2 || CY_IP_WCO_SRSSV2)
N
N    /* External Crystal Oscillator is present (high frequency) */
N    #if (CY_IP_HOBTO_DEVICE)
X    #if ((!(0 == 1)))
N        #if (CY_IP_BLESS)
X        #if ((0 != 0))
S            #define CY_IP_ECO_SRSSV2        (0 != 0)
S            #define CY_IP_ECO_SRSSLT        (0 != 0)
S            
S            #if (CY_IP_BLESSV3)
S                #define CY_IP_ECO_BLESS     (0 != 0)
S                #define CY_IP_ECO_BLESSV3   (0 == 0)
S            #else
S                #define CY_IP_ECO_BLESS     (0 == 0)
S                #define CY_IP_ECO_BLESSV3   (0 != 0)
S            #endif
N        #else
N            #define CY_IP_ECO_BLESS         (0 != 0)
N            #define CY_IP_ECO_BLESSV3       (0 != 0)
N            #define CY_IP_ECO_SRSSV2        (-1 == 1)
N            #define CY_IP_ECO_SRSSLT        ((1 != 0) && (1 != 0))
N        #endif  /* (CY_IP_BLESS) */
N    #else
S        #define CY_IP_ECO_BLESS             (0 != 0)
S        #define CY_IP_ECO_BLESSV3           (0 != 0)
S        #define CY_IP_ECO_SRSSV2            (0 != 0)
S        #define CY_IP_ECO_SRSSLT            (0 != 0)
N    #endif  /* (CY_IP_HOBTO_DEVICE) */
N
N    #define CY_IP_ECO   (CY_IP_ECO_BLESS || CY_IP_ECO_SRSSV2 || CY_IP_ECO_BLESSV3 || CY_IP_ECO_SRSSLT)
N
N    /* PLL is present */
N    #if (CY_IP_HOBTO_DEVICE)
X    #if ((!(0 == 1)))
N        #if(CY_IP_SRSSV2)
X        #if((0 != 0))
S            #define CY_IP_PLL           ((-1 != 0) || \
S                                          (-1 != 0)) 
X            #define CY_IP_PLL           ((-1 != 0) ||                                           (-1 != 0)) 
S
S            #define CY_IP_PLL_NR        (-1u + \
S                                          -1u)
X            #define CY_IP_PLL_NR        (-1u +                                           -1u)
S        
N        #elif (CY_IP_SRSSLT)
X        #elif ((!(0 != 0)))
N            #define CY_IP_PLL           (1 == 1)
N
N            #define CY_IP_PLL_NR        (1)
N        #else
S            #define CY_IP_PLL           (0 != 0)
S            #define CY_IP_PLL_NR        (0)
N        #endif /* (CY_IP_SRSSV2) */
N    #else
S        #define CY_IP_PLL           (0 != 0)
S        #define CY_IP_PLL_NR        (0)
N    #endif  /* (CY_IP_HOBTO_DEVICE) */
N
N    /* Clock Source clk_lf implemented in SysTick Counter. When 0, not implemented, 1=implemented */
N    #if (CY_IP_HOBTO_DEVICE)
X    #if ((!(0 == 1)))
N        #if (CY_IP_CPUSSV2)
X        #if ((0 == 1))
S            #define CY_SYSTICK_LFCLK_SOURCE     (-1 != 0)
N        #else   /* CY_IP_CPUSSV3 */
N            #define CY_SYSTICK_LFCLK_SOURCE     (1 != 0)
N        #endif  /* (CY_IP_CPUSSV2) */
N    #else
S        #define CY_SYSTICK_LFCLK_SOURCE     (0 != 0)
N    #endif  /* (CY_IP_HOBTO_DEVICE) */
N
N
N    /* Flash Macro 0 has extra rows */
N    #if (CY_IP_HOBTO_DEVICE)
X    #if ((!(0 == 1)))
N        #ifdef CYREG_SFLASH_MACRO_0_FREE_SFLASH0
N            #define CY_SFLASH_XTRA_ROWS         (0 == 0)
N        #else
S            #define CY_SFLASH_XTRA_ROWS         (0 != 0)
N        #endif /* CYREG_SFLASH_MACRO_0_FREE_SFLASH0 */
N
N    #else
S        #define CY_SFLASH_XTRA_ROWS         (0 != 0)
N    #endif  /* (CY_IP_HOBTO_DEVICE) */
N
N
N    #if (CY_IP_USBDEV)
X    #if ((0 != 0))
S        #define CY_IP_IMO_TRIMMABLE_BY_USB  (0 == 0)
N    #else
N        #define CY_IP_IMO_TRIMMABLE_BY_USB  (0 != 0)
N    #endif  /* (CY_IP_USBDEV) */
N
N
N    #if (CY_IP_WCO_WCO || CY_IP_WCO_SRSSV2)
X    #if ((1 == 1) || (-1 == 1))
N        #define CY_IP_IMO_TRIMMABLE_BY_WCO  (0 == 0)
N    #else
S        #define CY_IP_IMO_TRIMMABLE_BY_WCO  (0 != 0)
N    #endif  /* (CY_IP_WCO_WCO || CY_IP_WCO_SRSSV2) */
N
N
N    /* DW/DMA Controller present (0=No, 1=Yes) */
N    #if (CY_IP_HOBTO_DEVICE)
X    #if ((!(0 == 1)))
N        #if (CY_IP_CPUSSV2)
X        #if ((0 == 1))
S            #define CY_IP_DMAC_PRESENT      (-1 == 1)
N        #else
N            #define CY_IP_DMAC_PRESENT      (1 == 1)
N        #endif  /* (CY_IP_CPUSSV2) */
N    #else
S        #define CY_IP_DMAC_PRESENT          (0 != 0)
N    #endif  /* (CY_IP_HOBTO_DEVICE) */
N
N    #if (CY_IP_HOBTO_DEVICE)
X    #if ((!(0 == 1)))
N        #define CY_IP_PASS                  (0 == 1)
N    #else
S        #define CY_IP_PASS                  (0 != 0)
N    #endif  /* (CY_IP_HOBTO_DEVICE) */
N
N
N
N	/* Number of external slave ports on System Interconnect */
N    #if (CY_IP_HOBTO_DEVICE)
X    #if ((!(0 == 1)))
N        #if (CY_IP_CPUSSV2)
X        #if ((0 == 1))
S            #define CY_IP_SL_NR             (-1)
N        #else
N            #define CY_IP_SL_NR             (3)
N        #endif  /* (CY_IP_CPUSSV2) */
N    #else
S        #define CY_IP_SL_NR                 (0)
N    #endif  /* (CY_IP_HOBTO_DEVICE) */
N
N#else
S
S    #if (CY_PSOC3)
S        #define CY_SYSTICK_LFCLK_SOURCE     (0 != 0)
S    #else /* PSoC 5LP */
S        #define CY_SYSTICK_LFCLK_SOURCE     (0 == 0)
S    #endif /* (CY_PSOC3) */
S
N#endif  /* (CY_PSOC4) */
N
N
N/*******************************************************************************
N* The components version defines. Available started from cy_boot 4.20
N* Use the following construction in order to identify cy_boot version:
N* (defined(CY_BOOT_VERSION) && CY_BOOT_VERSION >= CY_BOOT_4_20)
N*******************************************************************************/
N#define CY_BOOT_4_20            (420u)
N#define CY_BOOT_5_0             (500u)
N#define CY_BOOT_5_10            (510u)
N#define CY_BOOT_5_20            (520u)
N#define CY_BOOT_5_30            (530u)
N#define CY_BOOT_5_40            (540u)
N#define CY_BOOT_5_50            (550u)
N#define CY_BOOT_5_60            (560u)
N#define CY_BOOT_5_70            (570u)
N#define CY_BOOT_VERSION         (CY_BOOT_5_70)
N
N
N/*******************************************************************************
N*   Base Types. Acceptable types from MISRA-C specifying signedness and size.
N*******************************************************************************/
Ntypedef unsigned char   uint8;
Ntypedef unsigned short  uint16;
Ntypedef unsigned long   uint32;
Ntypedef signed   char   int8;
Ntypedef signed   short  int16;
Ntypedef signed   long   int32;
Ntypedef          float  float32;
N
N#if(!CY_PSOC3)
X#if(!(2u == 1u))
N
N    typedef               double float64;
N    typedef          long long   int64;
N    typedef unsigned long long   uint64;
N
N#endif  /* (!CY_PSOC3) */
N
N/* Signed or unsigned depending on compiler selection */
Ntypedef          char   char8;
N
N
N/*******************************************************************************
N*   Memory address functions prototypes
N*******************************************************************************/
N#if(CY_PSOC3)
X#if((2u == 1u))
S
S    /***************************************************************************
S    * Prototypes for absolute memory address functions (cymem.a51) with built-in
S    * endian conversion. These functions should be called through the
S    * CY_GET_XTND_REGxx and CY_SET_XTND_REGxx macros.
S    ***************************************************************************/
S    extern uint8  cyread8       (const volatile void far *addr);
S    extern void   cywrite8      (volatile void far *addr, uint8 value);
S
S    extern uint16 cyread16      (const volatile void far *addr);
S    extern uint16 cyread16_nodpx(const volatile void far *addr);
S
S    extern void   cywrite16      (volatile void far *addr, uint16 value);
S    extern void   cywrite16_nodpx(volatile void far *addr, uint16 value);
S
S    extern uint32 cyread24      (const volatile void far *addr);
S    extern uint32 cyread24_nodpx(const volatile void far *addr);
S
S    extern void   cywrite24      (volatile void far *addr, uint32 value);
S    extern void   cywrite24_nodpx(volatile void far *addr, uint32 value);
S
S    extern uint32 cyread32      (const volatile void far *addr);
S    extern uint32 cyread32_nodpx(const volatile void far *addr);
S
S    extern void   cywrite32      (volatile void far *addr, uint32 value);
S    extern void   cywrite32_nodpx(volatile void far *addr, uint32 value);
S
S
S    /***************************************************************************
S    * Memory access routines from cymem.a51 for the generated device
S    * configuration code. These functions may be subject to change in future
S    * revisions of the cy_boot component and they are not available for all
S    * devices. Most code should use memset or memcpy instead.
S    ***************************************************************************/
S    void cymemzero(void far *addr, uint16 size);
S    void cyconfigcpy(uint16 size, const void far *src, void far *dest) large;
S    void cyconfigcpycode(uint16 size, const void code *src, void far *dest);
S
S    #define CYCONFIGCPY_DECLARED    (1)
S
N#else
N
N    /* Prototype for function to set 24-bit register. Located at cyutils.c */
N    extern void     CySetReg24(uint32 volatile * addr, uint32 value);
N
N    #if(CY_PSOC4)
X    #if((2u == 2u))
N
N        extern uint32 CyGetReg24(uint32 const volatile * addr);
N
N    #endif  /* (CY_PSOC4) */
N
N#endif  /* (CY_PSOC3) */
N
N
N/*******************************************************************************
N*   Memory model definitions. To allow code to be 8051-ARM agnostic.
N*******************************************************************************/
N#if(CY_PSOC3)
X#if((2u == 1u))
S
S    #define CYBDATA     bdata
S    #define CYBIT       bit
S    #define CYCODE      code
S    #define CYCOMPACT   compact
S    #define CYDATA      data
S    #define CYFAR       far
S    #define CYIDATA     idata
S    #define CYLARGE     large
S    #define CYPDATA     pdata
S    #define CYREENTRANT reentrant
S    #define CYSMALL     small
S    #define CYXDATA     xdata
S    #define XDATA       xdata
S
S    #define CY_NOINIT
S
N#else
N
N    #define CYBDATA
N    #define CYBIT      uint8
N    #define CYCODE
N    #define CYCOMPACT
N    #define CYDATA
N    #define CYFAR
N    #define CYIDATA
N    #define CYLARGE
N    #define CYPDATA
N    #define CYREENTRANT
N    #define CYSMALL
N    #define CYXDATA
N    #define XDATA
N
N    #if defined(__ARMCC_VERSION)
X    #if 1L
N
N        #define CY_NOINIT           __attribute__ ((section(".noinit"), zero_init))
N        #define CY_NORETURN         __attribute__ ((noreturn))
N        #define CY_SECTION(name)    __attribute__ ((section(name)))
N
N        /* Specifies a minimum alignment (in bytes) for variables of the
N        *  specified type.
N        */
N        #define CY_ALIGN(align)     __align(align)
N
N
N        /* Attached to an enum, struct, or union type definition, specified that
N        *  the minimum required memory be used to represent the type.
N        */
N        #define CY_PACKED
N        #define CY_PACKED_ATTR      __attribute__ ((packed))
N        #define CY_INLINE           __inline
N    #elif defined (__GNUC__)
S
S        #define CY_NOINIT           __attribute__ ((section(".noinit")))
S        #define CY_NORETURN         __attribute__ ((noreturn))
S        #define CY_SECTION(name)    __attribute__ ((section(name)))
S        #define CY_ALIGN(align)     __attribute__ ((aligned(align)))
S        #define CY_PACKED
S        #define CY_PACKED_ATTR      __attribute__ ((packed))
S        #define CY_INLINE           inline
S    #elif defined (__ICCARM__)
S
S        #define CY_NOINIT           __no_init
S        #define CY_NORETURN         __noreturn
S        #define CY_PACKED           __packed
S        #define CY_PACKED_ATTR
S        #define CY_INLINE           inline
N    #endif  /* (__ARMCC_VERSION) */
N
N#endif  /* (CY_PSOC3) */
N
N
N#if(CY_PSOC3)
X#if((2u == 1u))
S
S    /* 8051 naturally returns 8 bit value. */
S    typedef unsigned char cystatus;
S
N#else
N
N    /* ARM naturally returns 32 bit value. */
N    typedef unsigned long cystatus;
N
N#endif  /* (CY_PSOC3) */
N
N
N/*******************************************************************************
N*  Hardware Register Types.
N*******************************************************************************/
Ntypedef volatile uint8  CYXDATA reg8;
Xtypedef volatile uint8   reg8;
Ntypedef volatile uint16 CYXDATA reg16;
Xtypedef volatile uint16  reg16;
Ntypedef volatile uint32 CYXDATA reg32;
Xtypedef volatile uint32  reg32;
N
N
N/*******************************************************************************
N*  Interrupt Types and Macros
N*******************************************************************************/
N#if(CY_PSOC3)
X#if((2u == 1u))
S
S    #define CY_ISR(FuncName)        void FuncName (void) interrupt 0
S    #define CY_ISR_PROTO(FuncName)  void FuncName (void)
S    typedef void (CYCODE * cyisraddress)(void);
S
N#else
N
N    #define CY_ISR(FuncName)        void FuncName (void)
N    #define CY_ISR_PROTO(FuncName)  void FuncName (void)
N    typedef void (* cyisraddress)(void);
N
N    #if defined (__ICCARM__)
X    #if 0L
S        typedef union { cyisraddress __fun; void * __ptr; } intvec_elem;
N    #endif  /* defined (__ICCARM__) */
N
N#endif  /* (CY_PSOC3) */
N
N
N#define CY_M_PI                         (3.14159265358979323846264338327)
N
N
N/**
N* \addtogroup group_register_access
NA library of macros provides read and write access to the registers of the device. These macros are used with the
Ndefined values made available in the generated cydevice_trm.h and cyfitter.h files. Access to registers should be made
Nusing these macros and not the functions that are used to implement the macros. This allows for device independent code
Ngeneration.
N
NThe PSoC 4 processor architecture use little endian ordering.
N
NSRAM and Flash storage in all architectures is done using the endianness of the architecture and compilers. However,
Nthe registers in all these chips are laid out in little endian order. These macros allow register accesses to match this
Nlittle endian ordering. If you perform operations on multi-byte registers without using these macros, you must consider
Nthe byte ordering of the specific architecture. Examples include usage of DMA to transfer between memory and registers,
Nas well as function calls that are passed an array of bytes in memory.
N
NThe PSoC 4 requires these accesses to be aligned to the width of the transaction.
N
NThe PSoC 4 requires peripheral register accesses to match the hardware register size. Otherwise, the peripheral might
Nignore the transfer and Hard Fault exception will be generated.
N
N*/
N
N/** @} group_register_access */
N
N
N/**
N* \addtogroup group_register_access_macros Register Access
N* \ingroup group_register_access
N* @{
N*/
N
N#if(CY_PSOC3)
X#if((2u == 1u))
S    /*******************************************************************************
S    * Macro Name: CY_GET_REG8(addr)
S    ****************************************************************************//**
S    *
S    * Reads the 8-bit value from the specified register.
S    *
S    * \param reg Register address.
S    *
S    * \return Read value.
S    *
S    *******************************************************************************/
S    #define CY_GET_REG8(addr)               (*((const reg8 *)(addr)))
S
S
S    /*******************************************************************************
S    * Macro Name: CY_SET_REG8(addr, value)
S    ****************************************************************************//**
S    *
S    * Writes the 8-bit value to the specified register.
S    *
S    * \param reg Register address.
S    * \param value Value to write.
S    *
S    *******************************************************************************/
S    #define CY_SET_REG8(addr, value)        (*((reg8 *)(addr))  = (uint8)(value))
S
S
S    /*******************************************************************************
S    * Macro Name: CY_GET_REG16(addr)
S    ****************************************************************************//**
S    *
S    * Reads the 16-bit value from the specified register. This macro implements the
S    * byte swapping required for proper operation.
S    *
S    * \param reg Register address.
S    *
S    * \return Read value.
S    *
S    *******************************************************************************/
S    #define CY_GET_REG16(addr)              cyread16_nodpx ((const volatile void far *)(const reg16 *)(addr))
S
S
S    /*******************************************************************************
S    * Macro Name: CY_SET_REG16(addr, value)
S    ****************************************************************************//**
S    *
S    * Writes the 16-bit value to the specified register. This macro implements the
S    * byte swapping required for proper operation.
S    *
S    * \param reg Register address.
S    * \param value Value to write.
S    *
S    *******************************************************************************/
S    #define CY_SET_REG16(addr, value)       cywrite16_nodpx((volatile void far *)(reg16 *)(addr), value)
S
S
S    /*******************************************************************************
S    * Macro Name: CY_GET_REG24(addr)
S    ****************************************************************************//**
S    *
S    * Reads the 24-bit value from the specified register. This macro implements the
S    * byte swapping required for proper operation.
S    *
S    * \param reg Register address.
S    *
S    * \return Read value.
S    *
S    *******************************************************************************/
S    #define CY_GET_REG24(addr)              cyread24_nodpx ((const volatile void far *)(const reg32 *)(addr))
S
S
S    /*******************************************************************************
S    * Macro Name: CY_SET_REG24(addr, value)
S    ****************************************************************************//**
S    *
S    * Writes the 24-bit value to the specified register. This macro implements the
S    * byte swapping required for proper operation.
S    *
S    * \param reg Register address.
S    * \param value Value to write.
S    *
S    *******************************************************************************/
S    #define CY_SET_REG24(addr, value)       cywrite24_nodpx((volatile void far *)(reg32 *)(addr),value)
S
S
S    /*******************************************************************************
S    * Macro Name: CY_GET_REG32(addr)
S    ****************************************************************************//**
S    *
S    * Reads the 32-bit value from the specified register. This macro implements the
S    * byte swapping required for proper operation.
S    *
S    * \param reg Register address.
S    *
S    * \return Read value.
S    *
S    *******************************************************************************/
S    #define CY_GET_REG32(addr)              cyread32_nodpx ((const volatile void far *)(const reg32 *)(addr))
S
S
S    /*******************************************************************************
S    * Macro Name: CY_SET_REG32(addr, value)
S    ****************************************************************************//**
S    *
S    * Writes the 32-bit value to the specified register. This macro implements the
S    * byte swapping required for proper operation.
S    *
S    * \param reg Register address.
S    * \param value Value to write.
S    *
S    *******************************************************************************/
S    #define CY_SET_REG32(addr, value)       cywrite32_nodpx((volatile void far *)(reg32 *)(addr), value)
S
S
S    /*******************************************************************************
S    * Macro Name: CY_GET_XTND_REG8(addr)
S    ****************************************************************************//**
S    *
S    * Reads the 8-bit value from the specified register.
S    * Identical to \ref CY_GET_REG8 for PSoC 4.
S    *
S    * \param reg Register address.
S    *
S    * \return Read value.
S    *
S    *******************************************************************************/
S    #define CY_GET_XTND_REG8(addr)          cyread8((const volatile void far *)(addr))
S
S
S    /*******************************************************************************
S    * Macro Name: CY_SET_XTND_REG8(addr, value)
S    ****************************************************************************//**
S    *
S    * Writes the 8-bit value to the specified register.
S    * Identical to \ref CY_SET_REG8 for PSoC 4.
S    *
S    * \param reg Register address.
S    * \param value Value to write.
S    *
S    *******************************************************************************/
S    #define CY_SET_XTND_REG8(addr, value)   cywrite8((volatile void far *)(addr), value)
S
S
S    /*******************************************************************************
S    * Macro Name: CY_GET_XTND_REG16(addr)
S    ****************************************************************************//**
S    *
S    * Reads the 16-bit value from the specified register. This macro implements the
S    * byte swapping required for proper operation. Identical to \ref CY_GET_REG16
S    * for PSoC 4.
S    *
S    * \param reg Register address.
S    *
S    * \return Read value.
S    *
S    *******************************************************************************/
S    #define CY_GET_XTND_REG16(addr)         cyread16((const volatile void far *)(addr))
S
S
S    /*******************************************************************************
S    * Macro Name: CY_SET_XTND_REG16(addr, value)
S    ****************************************************************************//**
S    *
S    * Writes the 16-bit value to the specified register. This macro implements the
S    * byte swapping required for proper operation. Identical to \ref CY_SET_REG16
S    * for PSoC 4.
S    *
S    * \param reg Register address.
S    * \param value Value to write.
S    *
S    *******************************************************************************/
S    #define CY_SET_XTND_REG16(addr, value)  cywrite16((volatile void far *)(addr), value)
S
S
S    /*******************************************************************************
S    * Macro Name: CY_GET_XTND_REG24(addr)
S    ****************************************************************************//**
S    *
S    * Reads the 24-bit value from the specified register. This macro implements the
S    * byte swapping required for proper operation. Identical to \ref CY_GET_REG24
S    * for PSoC 4.
S    *
S    * \param reg Register address.
S    *
S    * \return Read value.
S    *
S    *******************************************************************************/
S    #define CY_GET_XTND_REG24(addr)         cyread24((const volatile void far *)(addr))
S
S
S    /*******************************************************************************
S    * Macro Name: CY_SET_XTND_REG24(addr, value)
S    ****************************************************************************//**
S    *
S    * Writes the 24-bit value to the specified register. This macro implements the
S    * byte swapping required for proper operation. Identical to \ref CY_SET_REG24
S    * for PSoC 4.
S    *
S    * \param reg Register address.
S    * \param value Value to write.
S    *
S    *******************************************************************************/
S    #define CY_SET_XTND_REG24(addr, value)  cywrite24((volatile void far *)(addr), value)
S
S
S    /*******************************************************************************
S    * Macro Name: CY_GET_XTND_REG32(addr)
S    ****************************************************************************//**
S    *
S    * Reads the 32-bit value from the specified register. This macro implements the
S    * byte swapping required for proper operation. Identical to \ref CY_GET_REG32
S    * for PSoC 4.
S    *
S    * \param reg Register address.
S    *
S    * \return Read value.
S    *
S    *******************************************************************************/
S    #define CY_GET_XTND_REG32(addr)         cyread32((const volatile void far *)(addr))
S
S
S    /*******************************************************************************
S    * Macro Name: CY_SET_XTND_REG32(addr, value)
S    ****************************************************************************//**
S    *
S    * Writes the 32-bit value to the specified register. This macro implements the
S    * byte swapping required for proper operation. Identical to \ref CY_SET_REG32
S    * for PSoC 4.
S    *
S    * \param reg Register address.
S    * \param value Value to write.
S    *
S    *******************************************************************************/
S    #define CY_SET_XTND_REG32(addr, value)  cywrite32((volatile void far *)(addr), value)
S
N#else
N
N    #define CY_GET_REG8(addr)               (*((const reg8 *)(addr)))
N    #define CY_SET_REG8(addr, value)        (*((reg8 *)(addr))  = (uint8)(value))
N
N    #define CY_GET_REG16(addr)              (*((const reg16 *)(addr)))
N    #define CY_SET_REG16(addr, value)       (*((reg16 *)(addr)) = (uint16)(value))
N
N
N    #define CY_SET_REG24(addr, value)       CySetReg24((reg32 *) (addr), (value))
N    #if(CY_PSOC4)
X    #if((2u == 2u))
N        #define CY_GET_REG24(addr)          CyGetReg24((const reg32 *) (addr))
N    #else
S        #define CY_GET_REG24(addr)          (*((const reg32 *)(addr)) & 0x00FFFFFFu)
N    #endif  /* (CY_PSOC4) */
N
N
N    #define CY_GET_REG32(addr)              (*((const reg32 *)(addr)))
N    #define CY_SET_REG32(addr, value)       (*((reg32 *)(addr)) = (uint32)(value))
N
N    /* To allow code to be 8051-ARM agnostic. */
N    #define CY_GET_XTND_REG8(addr)          CY_GET_REG8(addr)
N    #define CY_SET_XTND_REG8(addr, value)   CY_SET_REG8(addr, value)
N
N    #define CY_GET_XTND_REG16(addr)         CY_GET_REG16(addr)
N    #define CY_SET_XTND_REG16(addr, value)  CY_SET_REG16(addr, value)
N
N    #define CY_GET_XTND_REG24(addr)         CY_GET_REG24(addr)
N    #define CY_SET_XTND_REG24(addr, value)  CY_SET_REG24(addr, value)
N
N    #define CY_GET_XTND_REG32(addr)         CY_GET_REG32(addr)
N    #define CY_SET_XTND_REG32(addr, value)  CY_SET_REG32(addr, value)
N
N#endif  /* (CY_PSOC3) */
N/** @} group_register_access_macros */
N
N
N/**
N* \addtogroup group_register_access_bits Bit Manipulation
N* \ingroup group_register_access
N* @{
N*/
N
N#if(CY_PSOC4)
X#if((2u == 2u))
N
N    /*******************************************************************************
N    * Macro Name: CY_GET_FIELD_MASK(regSize, bitFieldName)
N    ****************************************************************************//**
N    *
N    * Returns the bit field mask for the specified register size and bit field
N    * name.
N    *
N    * \param regSize Size of the register in bits.
N    * \param bitFieldName Fully qualified name of the bit field. The biFieldName
N    *  is automatically appended with __OFFSET and __SIZE by the macro for usage.
N    *
N    * \return Returns the bit mask.
N    *
N    *******************************************************************************/
N    #define CY_GET_FIELD_MASK(regSize, bitFieldName) \
N        ((((uint ## regSize) 0xFFFFFFFFu << ((uint32)(regSize) - bitFieldName ## __SIZE - bitFieldName ## __OFFSET)) >>\
N         ((uint32)(regSize) - bitFieldName ## __SIZE)) << bitFieldName ## __OFFSET)
X    #define CY_GET_FIELD_MASK(regSize, bitFieldName)         ((((uint ## regSize) 0xFFFFFFFFu << ((uint32)(regSize) - bitFieldName ## __SIZE - bitFieldName ## __OFFSET)) >>         ((uint32)(regSize) - bitFieldName ## __SIZE)) << bitFieldName ## __OFFSET)
N
N
N    /*******************************************************************************
N    * Macro Name: CY_GET_REG8_FIELD(registerName, bitFieldName)
N    ****************************************************************************//**
N    *
N    * Reads the specified bit field value from the specified 8-bit register.
N    *
N    * The macro operation is not atomic. It is not guaranteed that the shared
N    * register will remain uncorrupted during simultaneous read-modify-write
N    * operation performed by two threads (main and interrupt threads). To
N    * guarantee data integrity in such cases, the macro should be invoked while
N    * the specific interrupt is disabled or within a critical section (all
N    * interrupts are disabled).
N    *
N    * Using this macro on 32-bit and 16-bit width registers will generate a
N    * hard fault exception. Examples of 8-bit registers are the UDB registers.
N    *
N    * \param registerName: The fully qualified name of the PSoC 4 device register.
N    * \param bitFieldName: fully qualified name of the bit field. The biFieldName is
N    * automatically appended with __OFFSET and __SIZE by the macro for usage.
N    *
N    * For fully qualified names of the register and bit fields and the possible
N    * values the field can take, please, refer to a respective PSoC family
N    * register TRM.
N    *
N    * \return Zero if the specified bit field is zero, and a non-zero value,
N    * otherwise. The return value is of type uint32.
N    *
N    *******************************************************************************/
N    #define CY_GET_REG8_FIELD(registerName, bitFieldName) \
N         ((CY_GET_REG8((registerName)) >> bitFieldName ## __OFFSET) & (~(0xFFu << bitFieldName ## __SIZE)))
X    #define CY_GET_REG8_FIELD(registerName, bitFieldName)          ((CY_GET_REG8((registerName)) >> bitFieldName ## __OFFSET) & (~(0xFFu << bitFieldName ## __SIZE)))
N
N
N    /*******************************************************************************
N    * Macro Name: CY_SET_REG8_FIELD(registerName, bitFieldName, value)
N    ****************************************************************************//**
N    *
N    * Sets the specified bit field value of the specified 8-bit register to the
N    * required value.
N    *
N    * The macro operation is not atomic. It is not guaranteed that the shared
N    * register remains uncorrupted during simultaneous read-modify-write
N    * operation performed by two threads (main and interrupt threads). To
N    * guarantee data integrity in such cases, the macro should be invoked while
N    * the specific interrupt is disabled or within a critical section (all
N    * interrupts are disabled).
N    *
N    * Using this macro on the 32-bit and 16-bit width registers, generates a
N    * hard fault exception. Examples of 8-bit registers are the UDB registers.
N    *
N    * \param registerName The fully qualified name of the PSoC 4 device register.
N    * \param bitFieldName fully qualified name of the bit field. The biFieldName is
N    * automatically appended with __OFFSET and __SIZE by the macro for usage.
N    * \param value The value that the field must be configured for.
N    *
N    * For fully qualified names of the register and bit fields and the possible
N    * values the field can take, please, refer to a respective PSoC family
N    * register TRM.
N    *
N    *******************************************************************************/
N    #define CY_SET_REG8_FIELD(registerName, bitFieldName, value) \
N        CY_SET_REG8((registerName), \
N        ((CY_GET_REG8((registerName))                 & ~CY_GET_FIELD_MASK(8, bitFieldName)) | \
N        (((uint8)(value) << bitFieldName ## __OFFSET) &  CY_GET_FIELD_MASK(8, bitFieldName))))
X    #define CY_SET_REG8_FIELD(registerName, bitFieldName, value)         CY_SET_REG8((registerName),         ((CY_GET_REG8((registerName))                 & ~CY_GET_FIELD_MASK(8, bitFieldName)) |         (((uint8)(value) << bitFieldName ## __OFFSET) &  CY_GET_FIELD_MASK(8, bitFieldName))))
N
N
N    /*******************************************************************************
N    * Macro Name: CY_CLEAR_REG8_FIELD(registerName, bitFieldName)
N    ****************************************************************************//**
N    *
N    * Clears the specified bit field of the specified 8-bit register.
N    *
N    * The macro operation is not atomic. It is not guaranteed that the shared
N    * register remains uncorrupted during simultaneous read-modify-write
N    * operation performed by two threads (main and interrupt threads). To
N    * guarantee data integrity in such cases, the macro should be invoked while
N    * the specific interrupt is disabled or within a critical section (all
N    * interrupts are disabled).
N    *
N    * Using this macro on the 32-bit and 16-bit width registers generates a
N    * hard fault exception. Examples of 8-bit registers are the UDB registers.
N    *
N    * \param registerName The fully qualified name of the PSoC 4 device register.
N    * \param bitFieldName fully qualified name of the bit field. The biFieldName is
N    * automatically appended with __OFFSET and __SIZE by the macro for usage.
N    *
N    * For fully qualified names of the register and bit fields and the
N    * possible values the field can take, please, refer to a respective PSoC
N    * family register TRM.
N    *
N    *******************************************************************************/
N    #define CY_CLEAR_REG8_FIELD(registerName, bitFieldName) \
N        (CY_SET_REG8((registerName), (CY_GET_REG8((registerName)) & ~CY_GET_FIELD_MASK(8, bitFieldName))))
X    #define CY_CLEAR_REG8_FIELD(registerName, bitFieldName)         (CY_SET_REG8((registerName), (CY_GET_REG8((registerName)) & ~CY_GET_FIELD_MASK(8, bitFieldName))))
N
N
N    /*******************************************************************************
N    * Macro Name: CY_GET_REG16_FIELD(registerName, bitFieldName)
N    ****************************************************************************//**
N    *
N    * Reads the specified bit field value from the specified 16-bit register.
N    *
N    * The macro operation is not atomic. It is not guaranteed that the shared
N    * register remains uncorrupted during simultaneous read-modify-write
N    * operation performed by two threads (main and interrupt threads). To
N    * guarantee data integrity in such cases, the macro should be invoked while
N    * the specific interrupt is disabled or within a critical section (all
N    * interrupts are disabled).
N    *
N    * Using this macro on the 32-bit and 16-bit width registers generates a
N    * hardfault exception. Examples of 8-bit registers are the UDB registers.
N    *
N    * \param registerName The fully qualified name of the PSoC 4 device register.
N    * \param bitFieldName fully qualified name of the bit field. The biFieldName is
N    * automatically appended with __OFFSET and __SIZE by the macro for usage.
N    *
N    * For fully qualified names of the register and bit fields and the
N    * possible values the field can take, please, refer to a respective PSoC
N    * family register TRM.
N    *
N    * \return Zero if the specified bit field is zero, and a non-zero value,
N    * otherwise. The return value is of type uint32.
N    *
N    *******************************************************************************/
N    #define CY_GET_REG16_FIELD(registerName, bitFieldName) \
N         ((CY_GET_REG16((registerName)) >> bitFieldName ## __OFFSET) & (~(0xFFFFu << bitFieldName ## __SIZE)))
X    #define CY_GET_REG16_FIELD(registerName, bitFieldName)          ((CY_GET_REG16((registerName)) >> bitFieldName ## __OFFSET) & (~(0xFFFFu << bitFieldName ## __SIZE)))
N
N
N    /*******************************************************************************
N    * Macro Name: CY_SET_REG16_FIELD(registerName, bitFieldName, value)
N    ****************************************************************************//**
N    *
N    * Sets the specified bit field value of the specified 16-bit register to the
N    * required value.
N    *
N    * The macro operation is not atomic. It is not guaranteed that the shared
N    * register remains uncorrupted during simultaneous read-modify-write operation
N    * performed by two threads (main and interrupt threads). To guarantee data
N    * integrity in such cases, the macro should be invoked while the specific
N    * interrupt is disabled or within a critical section (all interrupts are
N    * disabled).
N    *
N    * Using this macro on the 32-bit and 16-bit width registers generates a hard
N    * fault exception. Examples of 8-bit registers are the UDB registers.
N    *
N    * \param registerNam The fully qualified name of the PSoC 4 device register.
N    * \param bitFieldName: fully qualified name of the bit field. The biFieldName is
N    * automatically appended with __OFFSET and __SIZE by the macro for usage.
N    * \param value The value that the field must be configured for.
N    *
N    * For fully qualified names of the register and bit fields and the possible
N    * values the field can take, please, refer to a respective PSoC family
N    * register TRM.
N    *
N    *******************************************************************************/
N    #define CY_SET_REG16_FIELD(registerName, bitFieldName, value) \
N        CY_SET_REG16((registerName), \
N        ((CY_GET_REG16((registerName))                 & ~CY_GET_FIELD_MASK(16, bitFieldName)) | \
N        (((uint16)(value) << bitFieldName ## __OFFSET) &  CY_GET_FIELD_MASK(16, bitFieldName))))
X    #define CY_SET_REG16_FIELD(registerName, bitFieldName, value)         CY_SET_REG16((registerName),         ((CY_GET_REG16((registerName))                 & ~CY_GET_FIELD_MASK(16, bitFieldName)) |         (((uint16)(value) << bitFieldName ## __OFFSET) &  CY_GET_FIELD_MASK(16, bitFieldName))))
N
N
N    /*******************************************************************************
N    * Macro Name: CY_CLEAR_REG16_FIELD(registerName, bitFieldName)
N    ****************************************************************************//**
N    *
N    * Clears the specified bit field of the specified 16-bit register.
N    *
N    * The macro operation is not atomic. It is not guaranteed that the shared
N    * register remains uncorrupted during simultaneous read-modify-write operation
N    * performed by two threads (main and interrupt threads). To guarantee data
N    * integrity in such cases, the macro should be invoked while the specific
N    * interrupt is disabled or within a critical section (all interrupts are
N    * disabled).
N    *
N    * Using this macro on the 32-bit and 16-bit width registers generates a hard
N    * fault exception. Examples of 8-bit registers are the UDB registers.
N    *
N    * \param registerName: The fully qualified name of the PSoC 4 device register.
N    * \param bitFieldName: fully qualified name of the bit field. The biFieldName is
N    * automatically appended with __OFFSET and __SIZE by the macro for usage.
N    *
N    * For fully qualified names of the register and bit fields and the possible
N    * values the field can take, please, refer to a respective PSoC family register
N    * TRM.
N    *
N    *******************************************************************************/
N    #define CY_CLEAR_REG16_FIELD(registerName, bitFieldName)\
N        (CY_SET_REG16((registerName), (CY_GET_REG16((registerName)) & ~CY_GET_FIELD_MASK(16, bitFieldName))))
X    #define CY_CLEAR_REG16_FIELD(registerName, bitFieldName)        (CY_SET_REG16((registerName), (CY_GET_REG16((registerName)) & ~CY_GET_FIELD_MASK(16, bitFieldName))))
N
N
N    /*******************************************************************************
N    * Macro Name: CY_GET_REG32_FIELD(registerName, bitFieldName)
N    ****************************************************************************//**
N    *
N    * Reads the specified bit field value from the specified 32-bit register.
N    *
N    * The macro operation is not atomic. It is not guaranteed that the shared
N    * register remains uncorrupted during simultaneous read-modify-write operation
N    * performed by two threads (main and interrupt threads). To guarantee data
N    * integrity in such cases, the macro should be invoked while the specific
N    * interrupt is disabled or within a critical section (all interrupts are
N    * disabled).
N    *
N    * Using this macro on the 16-bit and 8-bit width registers generates a hard
N    * fault exception.
N    *
N    * \param registerName The fully qualified name of the PSoC 4 device register.
N    * \param bitFieldName The Fully qualified name of the bit field. The
N    * biFieldName is automatically appended with __OFFSET and __SIZE by the macro
N    * for usage.
N    *
N    * For fully qualified names of the register and bit fields, please, refer to
N    * a respective PSoC family register TRM.
N    *
N    * \return Zero if the specified bit field is zero, and a non-zero value, otherwise.
N    * The return value is of type uint32.
N    *
N    *******************************************************************************/
N    #define CY_GET_REG32_FIELD(registerName, bitFieldName) \
N          ((CY_GET_REG32((registerName)) >> bitFieldName ## __OFFSET) & (~(0xFFFFFFFFu << bitFieldName ## __SIZE)))
X    #define CY_GET_REG32_FIELD(registerName, bitFieldName)           ((CY_GET_REG32((registerName)) >> bitFieldName ## __OFFSET) & (~(0xFFFFFFFFu << bitFieldName ## __SIZE)))
N
N
N    /*******************************************************************************
N    * Macro Name: CY_SET_REG32_FIELD(registerName, bitFieldName, value)
N    ****************************************************************************//**
N    *
N    * Sets the specified bit field value of the specified 32-bit register to the
N    * required value.
N    *
N    * The macro operation is not atomic. It is not guaranteed that the shared
N    * register remains uncorrupted during simultaneous read-modify-write operation
N    * performed by two threads (main and interrupt threads). To guarantee data
N    * integrity in such cases, the macro should be invoked while the specific
N    * interrupt is disabled or within a critical section (all interrupts are
N    * disabled).
N    *
N    * Using this macro on the 16-bit and 8-bit width registers generates a hard
N    * fault exception.
N    *
N    * \param registerName The fully qualified name of the PSoC 4 device register.
N    * \param bitFieldName The fully qualified name of the bit field. The
N    * biFieldName is automatically appended with __OFFSET and __SIZE by the macro
N    * for usage.
N    * \param value The value that the field must be configured for.
N    *
N    * For fully qualified names of the register and bit fields and the possible
N    * values the field can take, please, refer to a respective PSoC family register
N    * TRM.
N    *
N    *******************************************************************************/
N    #define CY_SET_REG32_FIELD(registerName, bitFieldName, value) \
N        CY_SET_REG32((registerName), \
N        ((CY_GET_REG32((registerName))                 & ~CY_GET_FIELD_MASK(32, bitFieldName)) | \
N        (((uint32)(value) << bitFieldName ## __OFFSET) &  CY_GET_FIELD_MASK(32, bitFieldName))))
X    #define CY_SET_REG32_FIELD(registerName, bitFieldName, value)         CY_SET_REG32((registerName),         ((CY_GET_REG32((registerName))                 & ~CY_GET_FIELD_MASK(32, bitFieldName)) |         (((uint32)(value) << bitFieldName ## __OFFSET) &  CY_GET_FIELD_MASK(32, bitFieldName))))
N
N
N    /*******************************************************************************
N    * Macro Name: CY_CLEAR_REG32_FIELD(registerName, bitFieldName)
N    ****************************************************************************//**
N    *
N    * Clears the specified bit field of the specified 32-bit register.
N    *
N    * The macro operation is not atomic. It is not guaranteed that the shared
N    * register remains uncorrupted during simultaneous read-modify-write operation
N    * performed by two threads (main and interrupt threads). To guarantee data
N    * integrity in such cases, the macro should be invoked while the specific
N    * interrupt is disabled or within a critical section (all interrupts are
N    * disabled).
N    *
N    * Using this macro on the 16-bit and 8-bit width registers generates a hard
N    * fault exception.
N	*
N    * \param registerName The fully qualified name of the PSoC 4 device register.
N    * \param bitFieldName The fully qualified name of the bit field. The
N    * biFieldName is automatically appended with __OFFSET and __SIZE by the macro
N    * for usage.
N    *
N    * For fully qualified names of the register and bit fields and the possible
N    * values the field can take, please, refer to a respective PSoC family register
N    * TRM.
N    *
N    *******************************************************************************/
N    #define CY_CLEAR_REG32_FIELD(registerName, bitFieldName) \
N        (CY_SET_REG32((registerName), (CY_GET_REG32((registerName)) & ~CY_GET_FIELD_MASK(32, bitFieldName))))
X    #define CY_CLEAR_REG32_FIELD(registerName, bitFieldName)         (CY_SET_REG32((registerName), (CY_GET_REG32((registerName)) & ~CY_GET_FIELD_MASK(32, bitFieldName))))
N
N
N    /*******************************************************************************
N    * Macro Name: CY_GET_FIELD(regValue, bitFieldName)
N    ****************************************************************************//**
N    *
N    * Reads the specified bit field value from the given 32-bit value.
N    *
N    * The macro operation is not atomic. It is not guaranteed that the shared
N    * register remains uncorrupted during simultaneous read-modify-write operation
N    * performed by two threads (main and interrupt threads). To guarantee data
N    * integrity in such cases, the macro should be invoked while the specific
N    * interrupt is disabled or within a critical section (all interrupts are
N    * disabled).
N    *
N    * This macro has to be used in conjunction with \ref CY_GET_REG32 for atomic
N    * reads.
N    *
N    * \param regValue The value as read by \ref CY_GET_REG32.
N    * \param bitFieldName The fully qualified name of the bit field. The
N    * biFieldName is automatically appended with __OFFSET and __SIZE by the macro
N    * for usage.
N    *
N    * For fully qualified names of the bit field and the possible values the field
N    * can take, please, refer to a respective PSoC family register TRM.
N    *
N    * \return Zero if the specified bit field is zero, and a non-zero value,
N    * otherwise. The return value is of type uint32.
N    *
N    *******************************************************************************/
N    #define CY_GET_FIELD(regValue, bitFieldName) \
N        (((regValue) >> bitFieldName ## __OFFSET) & (~(0xFFFFFFFFu << bitFieldName ## __SIZE)))
X    #define CY_GET_FIELD(regValue, bitFieldName)         (((regValue) >> bitFieldName ## __OFFSET) & (~(0xFFFFFFFFu << bitFieldName ## __SIZE)))
N
N
N    /*******************************************************************************
N    * Macro Name: CY_SET_FIELD(regValue, bitFieldName, value)
N    ****************************************************************************//**
N    *
N    * Sets the specified bit field value within a given 32-bit value.
N    *
N    * The macro operation is not atomic. It is not guaranteed that the shared
N    * register remains uncorrupted during simultaneous read-modify-write operation
N    * performed by two threads (main and interrupt threads). To guarantee data
N    * integrity in such cases, the macro should be invoked while the specific
N    * interrupt is disabled or within a critical section (all interrupts are
N    * disabled).
N    *
N    * This macro has to be used in conjunction with \ref CY_GET_REG32 for atomic
N    * reads and \ref CY_SET_REG32 for atomic writes.
N    *
N    * \param regValue The value as read by \ref CY_GET_REG32.
N    * \param bitFieldName The fully qualified name of the bit field. The
N    * biFieldName is automatically appended with __OFFSET and __SIZE by the macro
N    * for usage.
N    * \param value The value that the field must be configured for.
N    *
N    * For fully qualified names of the bit field and the possible values the field
N    * can take, please, refer to the respective PSoC family register TRM.
N    *
N    *******************************************************************************/
N    #define CY_SET_FIELD(regValue, bitFieldName, value) \
N        ((regValue) = \
N        ((((uint32)(value) & (~(0xFFFFFFu << bitFieldName ## __SIZE))) << bitFieldName ## __OFFSET)) | \
N        ((uint32)(regValue) & (((~(0xFFu << bitFieldName ## __SIZE))) << bitFieldName ## __OFFSET)))
X    #define CY_SET_FIELD(regValue, bitFieldName, value)         ((regValue) =         ((((uint32)(value) & (~(0xFFFFFFu << bitFieldName ## __SIZE))) << bitFieldName ## __OFFSET)) |         ((uint32)(regValue) & (((~(0xFFu << bitFieldName ## __SIZE))) << bitFieldName ## __OFFSET)))
N
N#endif  /* (CY_PSOC4) */
N
N/** @} group_register_access_bits */
N
N
N/*******************************************************************************
N*  Data manipulation defines
N*******************************************************************************/
N
N/* Get 8 bits of 16 bit value. */
N#define LO8(x)                  ((uint8) ((x) & 0xFFu))
N#define HI8(x)                  ((uint8) ((uint16)(x) >> 8))
N
N/* Get 16 bits of 32 bit value. */
N#define LO16(x)                 ((uint16) ((x) & 0xFFFFu))
N#define HI16(x)                 ((uint16) ((uint32)(x) >> 16))
N
N/* Swap the byte ordering of 32 bit value */
N#define CYSWAP_ENDIAN32(x)  \
N        ((uint32)((((x) >> 24) & 0x000000FFu) | (((x) & 0x00FF0000u) >> 8) | (((x) & 0x0000FF00u) << 8) | ((x) << 24)))
X#define CYSWAP_ENDIAN32(x)          ((uint32)((((x) >> 24) & 0x000000FFu) | (((x) & 0x00FF0000u) >> 8) | (((x) & 0x0000FF00u) << 8) | ((x) << 24)))
N
N/* Swap the byte ordering of 16 bit value */
N#define CYSWAP_ENDIAN16(x)      ((uint16)(((x) << 8) | (((x) >> 8) & 0x00FFu)))
N
N
N/*******************************************************************************
N* Defines the standard return values used in PSoC content. A function is
N* not limited to these return values but can use them when returning standard
N* error values. Return values can be overloaded if documented in the function
N* header. On the 8051 a function can use a larger return type but still use the
N* defined return codes.
N*
N* Zero is successful, all other values indicate some form of failure. 1 - 0x7F -
N* standard defined values; 0x80 - ...  - user or content defined values.
N*******************************************************************************/
N#define CYRET_SUCCESS           (0x00u)           /* Successful */
N#define CYRET_BAD_PARAM         (0x01u)           /* One or more invalid parameters */
N#define CYRET_INVALID_OBJECT    (0x02u)           /* Invalid object specified */
N#define CYRET_MEMORY            (0x03u)           /* Memory related failure */
N#define CYRET_LOCKED            (0x04u)           /* Resource lock failure */
N#define CYRET_EMPTY             (0x05u)           /* No more objects available */
N#define CYRET_BAD_DATA          (0x06u)           /* Bad data received (CRC or other error check) */
N#define CYRET_STARTED           (0x07u)           /* Operation started, but not necessarily completed yet */
N#define CYRET_FINISHED          (0x08u)           /* Operation completed */
N#define CYRET_CANCELED          (0x09u)           /* Operation canceled */
N#define CYRET_TIMEOUT           (0x10u)           /* Operation timed out */
N#define CYRET_INVALID_STATE     (0x11u)           /* Operation not setup or is in an improper state */
N#define CYRET_UNKNOWN           ((cystatus) 0xFFFFFFFFu)    /* Unknown failure */
N
N
N/*******************************************************************************
N*   Intrinsic Defines: Processor NOP instruction
N*******************************************************************************/
N#if(CY_PSOC3)
X#if((2u == 1u))
S
S    #define CY_NOP          _nop_()
S
N#else
N
N    #if defined(__ARMCC_VERSION)
X    #if 1L
N
N        /* RealView */
N        #define CY_NOP      __nop()
N
N    #else
S
S        /* GCC */
S        #define CY_NOP      __asm("NOP\n")
S
N    #endif  /* defined(__ARMCC_VERSION) */
N
N#endif  /* (CY_PSOC3) */
N
N
N/*******************************************************************************
N* The following code is OBSOLETE and must not be used starting from cy_boot 5.10
N*
N* If the obsoleted macro definitions intended for use in the application use the
N* following scheme, redefine your own versions of these definitions:
N*    #ifdef <OBSOLETED_DEFINE>
N*        #undef  <OBSOLETED_DEFINE>
N*        #define <OBSOLETED_DEFINE>      (<New Value>)
N*    #endif
N*
N* Note: Redefine obsoleted macro definitions with caution. They might still be
N*       used in the application and their modification might lead to unexpected
N*       consequences.
N*******************************************************************************/
N#define CY_IP_S8FS      CY_IP_FS
N
N
N/*******************************************************************************
N* The following code is OBSOLETE and must not be used starting from cy_boot 3.10
N*******************************************************************************/
N#define CY_UDB_V0           (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_5A)
N#define CY_UDB_V1           (!CY_UDB_V0)
N#define CY_PSOC4A  (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4A)
N#ifdef CYDEV_CHIP_MEMBER_4D
N    #define CY_PSOC4D   (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4D)
N    #define CY_PSOC4SF  (CY_PSOC4D)
N#else
S    #define CY_PSOC4D   (0u != 0u)
S    #define CY_PSOC4SF  (CY_PSOC4D)
N#endif  /* CYDEV_CHIP_MEMBER_4D */
N#define CY_PSOC5A  (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_5A)
N#ifdef CYDEV_CHIP_MEMBER_5B
N    #define CY_PSOC5LP  (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_5B)
N#else
S    #define CY_PSOC5LP  (0u != 0u)
N#endif  /* CYDEV_CHIP_MEMBER_5B */
N
N#if (!CY_PSOC4)
X#if (!(2u == 2u))
S
S    /* Device is PSoC 3 and the revision is ES2 or earlier */
S    #define CY_PSOC3_ES2 ((CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_3A) && \
S        (CYDEV_CHIP_REVISION_USED <= CYDEV_CHIP_REVISION_3A_ES2))
X    #define CY_PSOC3_ES2 ((CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_3A) &&         (CYDEV_CHIP_REVISION_USED <= CYDEV_CHIP_REVISION_3A_ES2))
S
S    /* Device is PSoC 3 and the revision is ES3 or later */
S    #define CY_PSOC3_ES3 ((CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_3A) && \
S        (CYDEV_CHIP_REVISION_USED >= CYDEV_CHIP_REVISION_3A_ES3))
X    #define CY_PSOC3_ES3 ((CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_3A) &&         (CYDEV_CHIP_REVISION_USED >= CYDEV_CHIP_REVISION_3A_ES3))
S
S    /* Device is PSoC 5 and the revision is ES1 or earlier */
S    #define CY_PSOC5_ES1 (CY_PSOC5A && \
S        (CYDEV_CHIP_REVISION_USED <= CYDEV_CHIP_REVISION_5A_ES1))
X    #define CY_PSOC5_ES1 (CY_PSOC5A &&         (CYDEV_CHIP_REVISION_USED <= CYDEV_CHIP_REVISION_5A_ES1))
S
S    /* Device is PSoC 5 and the revision is ES2 or later */
S    #define CY_PSOC5_ES2 (CY_PSOC5A && \
S        (CYDEV_CHIP_REVISION_USED > CYDEV_CHIP_REVISION_5A_ES1))
X    #define CY_PSOC5_ES2 (CY_PSOC5A &&         (CYDEV_CHIP_REVISION_USED > CYDEV_CHIP_REVISION_5A_ES1))
S
N#endif  /* (!CY_PSOC4) */
N
N#endif  /* CY_BOOT_CYTYPES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\cyfitter_cfg.h" 2
N
Nextern void cyfitter_cfg(void);
N
N/* Analog Set/Unset methods */
Nextern void SetAnalogRoutingPumps(uint8 enabled);
N
N
N#endif /* CYFITTER_CFG_H */
N
N/*[]*/
L 18 "Generated_Source\PSoC4\project.h" 2
N#include "cydevice_trm.h"
N#include "cyfitter.h"
N#include "cydisabledsheets.h"
L 1 "Generated_Source\PSoC4\cydisabledsheets.h" 1
N#ifndef INCLUDED_CYDISABLEDSHEETS_H
N#define INCLUDED_CYDISABLEDSHEETS_H
N
N
N#endif /* INCLUDED_CYDISABLEDSHEETS_H */
L 21 "Generated_Source\PSoC4\project.h" 2
N#include "UART_1_BLE.h"
L 1 "Generated_Source\PSoC4\UART_1_BLE.h" 1
N/***************************************************************************//**
N* \file UART_1_BLE.h
N* \version 4.0
N*
N* \brief
N*  This file provides constants and parameter values for the SCB Component.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_UART_1_BLE_H)
X#if !0L
N#define CY_SCB_UART_1_BLE_H
N
N#include <cydevice_trm.h>
N#include <cyfitter.h>
N#include <cytypes.h>
N#include <CyLib.h>
L 1 "Generated_Source\PSoC4\CyLib.h" 1
N/***************************************************************************//**
N* \file CyLib.h
N* \version 5.70
N*
N* \brief Provides a system API for the clocking, and interrupts.
N*
N* \note Documentation of the API's in this file is located in the System
N* Reference Guide provided with PSoC Creator.
N*
N********************************************************************************
N* \copyright
N* Copyright 2008-2018, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_BOOT_CYLIB_H)
X#if !0L
N#define CY_BOOT_CYLIB_H
N
N#include "cytypes.h"
N#include "cydevice_trm.h"
N#include "CyLFClk.h"
L 1 "Generated_Source\PSoC4\CyLFClk.h" 1
N/***************************************************************************//**
N* \file .h
N* \version 1.20
N*
N* \brief
N*  This file provides the source code to API for the lfclk and wdt.
N*
N********************************************************************************
N* \copyright
N* Copyright 2008-2017, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N
N#if !defined(CY_LFCLK_CYLIB_H)
X#if !0L
N#define CY_LFCLK_CYLIB_H
N
N#include "cytypes.h"
N#include "cydevice_trm.h"
N
N#define CY_IP_WCO_WDT_EN           (1 == 1)
N
Ntypedef enum
N{
N    CY_SYS_TIMER_WAIT = 0u,
N    CY_SYS_TIMER_INTERRUPT = 1u
N} cy_sys_timer_delaytype_enum;
N
N
N/***************************************
N*    Function Prototypes
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
N/* Clocks API */
Nvoid CySysClkIloStart(void);
Nvoid CySysClkIloStop(void);
N/** @} general */
N
N/**
N* \addtogroup group_compensate
N* @{
N*/
Ncystatus CySysClkIloCompensate(uint32 desiredDelay, uint32 *compensatedCycles);
Nvoid CySysClkIloStartMeasurement(void);
Nvoid CySysClkIloStopMeasurement(void);
N/** @} compensate */
N
N#if(CY_IP_SRSSV2 && (!CY_IP_CPUSS))
X#if((0 != 0) && (!(0 == 1)))
S    /**
S    * \addtogroup group_compensate
S    * @{
S    */
S    cystatus CySysClkIloTrim(uint32 mode, int32 *iloAccuracyInPPT);
S    cystatus CySysClkIloRestoreFactoryTrim(void);
S    /** @} compensate */
S    cystatus CySysClkIloUpdateTrimReg(int32* iloAccuracyInPPT);
N#endif /* (CY_IP_SRSSV2 && (!CY_IP_CPUSS)) */
N
N#if(CY_IP_SRSSV2 && CY_IP_WCO)
X#if((0 != 0) && ((0 != 0) || (1 == 1) || (0 != 0) || (-1 == 1)))
S    /**
S    * \addtogroup group_general
S    * @{
S    */
S    void CySysClkSetLfclkSource(uint32 source);
S    /** @} group_general */
N#endif /* (CY_IP_SRSSV2 && CY_IP_WCO) */
N
N#if (CY_IP_WCO)
X#if (((0 != 0) || (1 == 1) || (0 != 0) || (-1 == 1)))
N    /**
N    * \addtogroup group_wco
N    * @{
N    */
N    void   CySysClkWcoStart(void);
N    void   CySysClkWcoStop(void);
N    uint32 CySysClkWcoSetPowerMode(uint32 mode);
N    void CySysClkWcoClockOutSelect(uint32 clockSel);
N    /** @} wco */
N
N    uint32 CySysClkWcoEnabled(void);
N
N#endif /* (CY_IP_WCO) */
N
Ntypedef void (*cyWdtCallback)(void);
N
N#if (CY_IP_SRSSLT && CY_IP_WCO && CY_IP_WCO_WDT_EN)
X#if ((!(0 != 0)) && ((0 != 0) || (1 == 1) || (0 != 0) || (-1 == 1)) && (1 == 1))
N
N    typedef void (*cyTimerCallback)(void);
N#endif /* (CY_IP_SRSSLT && CY_IP_WCO && CY_IP_WCO_WDT_EN) */
N
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S    /**
S    * \addtogroup group_wdtsrssv2
S    * @{
S    */
S    /* WDT API */
S    void   CySysWdtLock(void);
S    void   CySysWdtUnlock(void);
S    void   CySysWdtSetMode(uint32 counterNum, uint32 mode);
S    uint32 CySysWdtGetMode(uint32 counterNum);
S    uint32 CySysWdtGetEnabledStatus(uint32 counterNum);
S    void   CySysWdtSetClearOnMatch(uint32 counterNum, uint32 enable);
S    uint32 CySysWdtGetClearOnMatch(uint32 counterNum);
S    void   CySysWdtEnable(uint32 counterMask);
S    void   CySysWdtDisable(uint32 counterMask);
S    void   CySysWdtSetCascade(uint32 cascadeMask);
S    uint32 CySysWdtGetCascade(void);
S    void   CySysWdtSetMatch(uint32 counterNum, uint32 match);
S    void   CySysWdtSetToggleBit(uint32 bits);
S    uint32 CySysWdtGetToggleBit(void);
S    uint32 CySysWdtGetMatch(uint32 counterNum);
S    uint32 CySysWdtGetCount(uint32 counterNum);
S    uint32 CySysWdtGetInterruptSource(void);
S    void   CySysWdtClearInterrupt(uint32 counterMask);
S    void   CySysWdtResetCounters(uint32 countersMask);
S    cyWdtCallback  CySysWdtSetInterruptCallback(uint32 counterNum, cyWdtCallback function);
S    cyWdtCallback  CySysWdtGetInterruptCallback(uint32 counterNum);
S    void   CySysTimerDelay(uint32 counterNum, cy_sys_timer_delaytype_enum delayType, uint32 delay);
S    void   CySysTimerDelayUntilMatch(uint32 counterNum, cy_sys_timer_delaytype_enum delayType, uint32 match);
S    void   CySysWatchdogFeed(uint32 counterNum);
S    void   CySysWdtEnableCounterIsr(uint32 counterNum);
S    void   CySysWdtDisableCounterIsr(uint32 counterNum);
S    void   CySysWdtIsr(void);
S    /** @} wdtsrssv2 */
N#else
N    /**
N    * \addtogroup group_wdtsrsslite
N    * @{
N    */
N    /* WDT API */
N    uint32 CySysWdtGetEnabledStatus(void);
N    void   CySysWdtEnable(void);
N    void   CySysWdtDisable(void);
N    void   CySysWdtSetMatch(uint32 match);
N    uint32 CySysWdtGetMatch(void);
N    uint32 CySysWdtGetCount(void);
N    void   CySysWdtSetIgnoreBits(uint32 bitsNum);
N    uint32 CySysWdtGetIgnoreBits(void);
N    void   CySysWdtClearInterrupt(void);
N    void   CySysWdtMaskInterrupt(void);
N    void   CySysWdtUnmaskInterrupt(void);
N    cyWdtCallback CySysWdtSetInterruptCallback(cyWdtCallback function);
N    cyWdtCallback CySysWdtGetInterruptCallback(void);
N    void   CySysWdtIsr(void);
N    /** @} wdtsrsslite*/
N#endif  /* (CY_IP_SRSSV2) */
N
N
N#if(CY_IP_SRSSLT && CY_IP_WCO && CY_IP_WCO_WDT_EN)
X#if((!(0 != 0)) && ((0 != 0) || (1 == 1) || (0 != 0) || (-1 == 1)) && (1 == 1))
N    /**
N    * \addtogroup group_deepsleepwdt
N    * @{
N    */
N    /* WCO WDT APIs */
N    void   CySysClkSetTimerSource(uint32 source);
N    void   CySysTimerSetMode(uint32 counterNum, uint32 mode);
N    uint32 CySysTimerGetMode(uint32 counterNum);
N    uint32 CySysTimerGetEnabledStatus(uint32 counterNum);
N    void   CySysTimerSetClearOnMatch(uint32 counterNum, uint32 enable);
N    uint32 CySysTimerGetClearOnMatch(uint32 counterNum);
N    void   CySysTimerEnable(uint32 counterMask);
N    void   CySysTimerDisable(uint32 counterMask);
N    void   CySysTimerSetCascade(uint32 cascadeMask);
N    uint32 CySysTimerGetCascade(void);
N    void   CySysTimerSetMatch(uint32 counterNum, uint32 match);
N    void   CySysTimerSetToggleBit(uint32 bits);
N    uint32 CySysTimerGetToggleBit(void);
N    uint32 CySysTimerGetMatch(uint32 counterNum);
N    uint32 CySysTimerGetCount(uint32 counterNum);
N    uint32 CySysTimerGetInterruptSource(void);
N    void   CySysTimerClearInterrupt(uint32 counterMask);
N    cyTimerCallback CySysTimerSetInterruptCallback(uint32 counterNum, cyTimerCallback function);
N    cyTimerCallback CySysTimerGetInterruptCallback(uint32 counterNum);
N    void   CySysTimerDelay(uint32 counterNum, cy_sys_timer_delaytype_enum delayType, uint32 delay);
N    void   CySysTimerDelayUntilMatch(uint32 counterNum, cy_sys_timer_delaytype_enum delayType, uint32 match);
N    void   CySysTimerResetCounters(uint32 countersMask);
N    void   CySysTimerEnableIsr(uint32 counterNum);
N    void   CySysTimerDisableIsr(uint32 counterNum);
N    void   CySysTimerIsr(void);
N    /** @} deepsleepwdt */
N#endif /* (CY_IP_SRSSLT && CY_IP_WCO && CY_IP_WCO_WDT_EN) */
N
N
N/*******************************************************************************
N* API Constants
N*******************************************************************************/
N#define CY_SYS_UINT16_MAX_VAL    (0xFFFFu)
N
N
N/*******************************************************************************
N* Clock API Constants
N*******************************************************************************/
N
N/* CySysClkIloStart()/CySysClkIloStop() - implementation definitions */
N#define CY_SYS_CLK_ILO_CONFIG_ENABLE                    ((uint32)(( uint32 )0x01u << 31u))
N#define CY_SYS_CLK_DFT_SELECT_DEFAULT_MASK              ((uint32)(( uint32 )0x0fu << 8u ))
N
N/* CySysClkIloCompensate() - one ILO clock in uS multiplied on thousand */
N#if (CY_IP_SRSSV2)
X#if ((0 != 0))
S    #define CY_SYS_CLK_ILO_PERIOD_PPH                   ((uint32) (0x0C35u))
N#else
N    #define CY_SYS_CLK_ILO_PERIOD_PPH                   ((uint32) (0x09C4u))
N#endif /* (CY_IP_SRSSV2) */
N
N/* CySysClkIloCompensate() - implementation definitions */
N#define CY_SYS_CLK_ILO_CALIBR_COMPLETE_MASK             ((uint32)(( uint32 )0x01u << 31u))
N#define CY_SYS_CLK_ILO_DFT_LSB_MASK                     ((uint32)(0x00000FFFu))
N#define CY_SYS_CLK_TRIM_OR_COMP_STARTED                 (1u)
N#define CY_SYS_CLK_TRIM_OR_COMP_FINISHED                (0u)
N#define CY_SYS_CLK_COEF_PHUNDRED                        ((uint32) (0x64u))
N#define CY_SYS_CLK_HALF_OF_CLOCK                        ((uint32) ((uint32) CY_SYS_CLK_ILO_PERIOD_PPH >> 2u))
N
N/* CySysClkIloCompensate() - maximum value of desiredDelay argument */
N#if (CY_IP_SRSSV2)
X#if ((0 != 0))
S    #define CY_SYS_CLK_MAX_DELAY_US                     ((uint32) (0xEE6B2800u))
S    #define CY_SYS_CLK_ILO_PERIOD                       ((uint32) (0x1Fu))
S    #define CY_SYS_CLK_ILO_FREQ_2MSB                    ((uint32) 5u)
N#else
N    #define CY_SYS_CLK_MAX_DELAY_US                     ((uint32) (0x1E8480u))
N    #define CY_SYS_CLK_ILO_FREQ_2MSB                    ((uint32) (0x28u ))
N
N    /**********************************************************************************
N    * CySysClkIloCompensate() - value to walk over oversamling in calculations with 
N    * srsslite. The oversample can be obtained when ilo frequency in equal 80 KHz and
N    * desired clocks are 80 000 clocks.
N    **********************************************************************************/
N    #define CY_SYS_CLK_MAX_LITE_NUMBER                     ((uint32) 53600u)
N#endif /* (CY_IP_SRSSV2) */
N
N#define CY_SYS_CLK_ILO_FREQ_3LSB                       ((uint32) (0x3E8u))
N#define CY_SYS_CLK_DELAY_COUNTS_LIMIT                  ((uint32) (0xD160u))
N#define CY_SYS_CLK_MIN_DELAY_US                        ((uint32) (0x64u))
N
N/* CySysClkSetLfclkSource() - parameter definitions */
N#if (CY_IP_SRSSV2 && CY_IP_WCO)
X#if ((0 != 0) && ((0 != 0) || (1 == 1) || (0 != 0) || (-1 == 1)))
S
S    /** Internal Low Frequency (32 kHz) Oscillator (ILO) */
S    #define CY_SYS_CLK_LFCLK_SRC_ILO                    (0u)
S
S    /** Low Frequency Watch Crystal Oscillator (WCO) */
S    #define CY_SYS_CLK_LFCLK_SRC_WCO                    ((uint32)(( uint32 )0x01u << 30u))
N#endif /* (CY_IP_SRSSV2 && CY_IP_WCO) */
N
N
N#if (CY_IP_WCO)
X#if (((0 != 0) || (1 == 1) || (0 != 0) || (-1 == 1)))
N
N    /* CySysClkSetLfclkSource() - implementation definitions */
N    #define CY_SYS_CLK_LFCLK_SEL_MASK                   ((uint32)(( uint32 )0x03u << 30u))
N#endif /* (CY_IP_WCO) */
N
N/* CySysClkSetTimerSource() - implementation definitions */
N#if (CY_IP_SRSSLT && CY_IP_WCO && CY_IP_WCO_WDT_EN)
X#if ((!(0 != 0)) && ((0 != 0) || (1 == 1) || (0 != 0) || (-1 == 1)) && (1 == 1))
N    #define CY_SYS_CLK_TIMER_SEL_MASK                   ((uint32)(( uint32 )0x03u << 30u))
N#endif /* (CY_IP_SRSSLT && CY_IP_WCO && CY_IP_WCO_WDT_EN) */
N
N/* CySysClkSetTimerSource() - parameter definitions */
N#if (CY_IP_SRSSLT && CY_IP_WCO && CY_IP_WCO_WDT_EN)
X#if ((!(0 != 0)) && ((0 != 0) || (1 == 1) || (0 != 0) || (-1 == 1)) && (1 == 1))
N
N    /** Internal Low Frequency (32 kHz) Oscillator (ILO) */
N    #define CY_SYS_CLK_TIMER_SRC_ILO                (0u)
N
N    /** Low Frequency Watch Crystal Oscillator (WCO) */
N    #define CY_SYS_CLK_TIMER_SRC_WCO                ((uint32)(( uint32 )0x01u << 30u))
N#endif /* (CY_IP_SRSSLT && CY_IP_WCO && CY_IP_WCO_WDT_EN) */
N
N/* CySysClkWcoClockOutSelect() - parameter definitions */
N#if (CY_IP_WCO)
X#if (((0 != 0) || (1 == 1) || (0 != 0) || (-1 == 1)))
N
N    /** Selects External crystal as WCOs clock source */
N    #define CY_SYS_CLK_WCO_SEL_CRYSTAL                  (1u)
N
N    /** Selects External clock input on wco_in pin as WCOs clock source */
N    #define CY_SYS_CLK_WCO_SEL_PIN                      (0u)
N#endif /* (CY_IP_WCO) */
N
N/* CySysClkWcoClockOutSelect() - implementation definitions */
N#if (CY_IP_WCO)
X#if (((0 != 0) || (1 == 1) || (0 != 0) || (-1 == 1)))
N    #define CY_SYS_CLK_WCO_SELECT_PIN_MASK              ((uint32)(( uint32 )0x01u << 2u))
N    #define CY_SYS_CLK_WCO_SELECT_PIN_OFFSET            ((uint32) 0x02u)
N#endif /* (CY_IP_WCO) */
N
N/* CySysClkIloRestoreFactoryTrim() - implementation definitions */
N#if (CY_IP_SRSSV2 && CY_IP_WCO && (!CY_IP_CPUSS))
X#if ((0 != 0) && ((0 != 0) || (1 == 1) || (0 != 0) || (-1 == 1)) && (!(0 == 1)))
S    #define CY_SYS_CLK_ILO_TRIM_DEFAULT_VALUE           ((uint8 )(0xF0u))
S    #define CY_SYS_CLK_ILO_TRIM_DEFAULT_MASK            ((uint32)((uint32)0x01u << 3u))
S    #define CY_SYS_CLK_ILO_TRIM_MASK                    ((uint32)(0x0Fu))
N#endif /* (CY_IP_SRSSV2 && CY_IP_WCO && (!CY_IP_CPUSS)) */
N
N/* CySysIloTrim() - parameter definitions and macros*/
N#if (CY_IP_SRSSV2 && CY_IP_WCO && (!CY_IP_CPUSS))
X#if ((0 != 0) && ((0 != 0) || (1 == 1) || (0 != 0) || (-1 == 1)) && (!(0 == 1)))
S    #define CY_SYS_CLK_BLOCKING                         (0u)
S    #define CY_SYS_CLK_NON_BLOCKING                     (1u)
S    #define CY_SYS_CLK_PERTHOUSAND                      ((uint32) 0x000003E8u )
S    #define CY_SYS_CLK_ABS_MACRO(x)                     ((0 > (x)) ? (-(x)) : (x))
S    #define CY_SYS_CLK_ERROR_RANGE                      ((uint32) 0x38u)
S    #define CY_SYS_CLK_TIMEOUT                          ((uint8 ) 0x05u)
S
S    /* ILO error step is 7,37 % error range */
S    #define CY_SYS_CLK_ERROR_STEP                       (( int32) 0x02E1u)
S    #define CY_SYS_CLK_ERROR_COEF                       ((uint32) 0x0Au)
N#endif /* (CY_IP_SRSSV2 && CY_IP_WCO && (!CY_IP_CPUSS)) */
N
N#if (CY_IP_WCO)
X#if (((0 != 0) || (1 == 1) || (0 != 0) || (-1 == 1)))
N
N    /* WCO Configuration Register */
N    #define CY_SYS_CLK_WCO_CONFIG_LPM_EN                (( uint32 )(( uint32 )0x01u <<  0u))
N    #define CY_SYS_CLK_WCO_CONFIG_LPM_AUTO              (( uint32 )(( uint32 )0x01u <<  1u))
N    #define CY_SYS_CLK_WCO_CONFIG_LPM_ENABLE            (( uint32 )(( uint32 )0x01u << 31u))
N
N    /* WCO Status Register */
N    #define CY_SYS_CLK_WCO_STATUS_OUT_BLNK_A            (( uint32 )(( uint32 )0x01u <<  0u))
N
N    /* WCO Trim Register */
N    #define CY_SYS_CLK_WCO_TRIM_XGM_MASK                (( uint32 ) 0x07u)
N    #define CY_SYS_CLK_WCO_TRIM_XGM_SHIFT               (( uint32 ) 0x00u)
N
N    #define CY_SYS_CLK_WCO_TRIM_XGM_3370NA              (( uint32 ) 0x00u)
N    #define CY_SYS_CLK_WCO_TRIM_XGM_2620NA              (( uint32 ) 0x01u)
N    #define CY_SYS_CLK_WCO_TRIM_XGM_2250NA              (( uint32 ) 0x02u)
N    #define CY_SYS_CLK_WCO_TRIM_XGM_1500NA              (( uint32 ) 0x03u)
N    #define CY_SYS_CLK_WCO_TRIM_XGM_1870NA              (( uint32 ) 0x04u)
N    #define CY_SYS_CLK_WCO_TRIM_XGM_1120NA              (( uint32 ) 0x05u)
N    #define CY_SYS_CLK_WCO_TRIM_XGM_750NA               (( uint32 ) 0x06u)
N    #define CY_SYS_CLK_WCO_TRIM_XGM_0NA                 (( uint32 ) 0x07u)
N
N    #define CY_SYS_CLK_WCO_TRIM_GM_MASK                 (( uint32 )(( uint32 )0x03u << 4u))
N    #define CY_SYS_CLK_WCO_TRIM_GM_SHIFT                (( uint32 ) 0x04u)
N    #define CY_SYS_CLK_WCO_TRIM_GM_HPM                  (( uint32 ) 0x01u)
N    #define CY_SYS_CLK_WCO_TRIM_GM_LPM                  (( uint32 ) 0x02u)
N#endif  /* (CY_IP_WCO) */
N
N
N/*******************************************************************************
N* WDT API Constants
N*******************************************************************************/
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S
S    #define CY_SYS_WDT_MODE_NONE                (0u)
S    #define CY_SYS_WDT_MODE_INT                 (1u)
S    #define CY_SYS_WDT_MODE_RESET               (2u)
S    #define CY_SYS_WDT_MODE_INT_RESET           (3u)
S
S    #define CY_SYS_WDT_COUNTER0_MASK            ((uint32)((uint32)0x01u))           /**< Counter 0 */
S    #define CY_SYS_WDT_COUNTER1_MASK            ((uint32)((uint32)0x01u << 8u))     /**< Counter 1 */
S    #define CY_SYS_WDT_COUNTER2_MASK            ((uint32)((uint32)0x01u << 16u))    /**< Counter 2 */
S
S    #define CY_SYS_WDT_CASCADE_NONE             ((uint32)0x00u)             /**< Neither */
S    #define CY_SYS_WDT_CASCADE_01               ((uint32)0x01u << 3u)       /**< Cascade 01 */
S    #define CY_SYS_WDT_CASCADE_12               ((uint32)0x01u << 11u)      /**< Cascade 12 */
S
S    #define CY_SYS_WDT_COUNTER0_INT             ((uint32)0x01u << 2u)
S    #define CY_SYS_WDT_COUNTER1_INT             ((uint32)0x01u << 10u)
S    #define CY_SYS_WDT_COUNTER2_INT             ((uint32)0x01u << 18u)
S
S    #define CY_SYS_WDT_COUNTER0_RESET           ((uint32)0x01u << 3u)       /**< Counter 0 */
S    #define CY_SYS_WDT_COUNTER1_RESET           ((uint32)0x01u << 11u)      /**< Counter 1 */
S    #define CY_SYS_WDT_COUNTER2_RESET           ((uint32)0x01u << 19u)      /**< Counter 2 */
S
S    #define CY_SYS_WDT_COUNTERS_RESET           (CY_SYS_WDT_COUNTER0_RESET |\
S                                                 CY_SYS_WDT_COUNTER1_RESET |\
S                                                 CY_SYS_WDT_COUNTER2_RESET)
X    #define CY_SYS_WDT_COUNTERS_RESET           (CY_SYS_WDT_COUNTER0_RESET |                                                 CY_SYS_WDT_COUNTER1_RESET |                                                 CY_SYS_WDT_COUNTER2_RESET)
S
S    #define CY_SYS_WDT_COUNTER0                 (0x00u)
S    #define CY_SYS_WDT_COUNTER1                 (0x01u)
S    #define CY_SYS_WDT_COUNTER2                 (0x02u)
S
S    #define CY_SYS_WDT_COUNTER0_OFFSET          (0x00u)
S    #define CY_SYS_WDT_COUNTER1_OFFSET          (0x02u)
S    #define CY_SYS_WDT_COUNTER2_OFFSET          (0x04u)
S
S    #define CY_SYS_WDT_MODE_MASK                ((uint32)(0x03u))
S
S    #define CY_SYS_WDT_CONFIG_BITS2_MASK        (uint32)(0x1Fu)
S    #define CY_SYS_WDT_CONFIG_BITS2_POS         (uint32)(24u)
S    #define CY_SYS_WDT_LOWER_16BITS_MASK        (uint32)(0x0000FFFFu)
S    #define CY_SYS_WDT_HIGHER_16BITS_MASK       (uint32)(0xFFFF0000u)
S    #define CY_SYS_WDT_COUNTERS_MAX             (0x03u)
S    #define CY_SYS_WDT_CNT_SHIFT                (0x08u)
S    #define CY_SYS_WDT_CNT_MATCH_CLR_SHIFT      (0x02u)
S    #define CY_SYS_WDT_CNT_STTS_SHIFT           (0x01u)
S    #define CY_SYS_WDT_CNT_MATCH_SHIFT          (0x10u)
S
S    #define CY_SYS_WDT_CLK_LOCK_BITS_MASK       ((uint32)0x03u << 14u)
S    #define CY_SYS_WDT_CLK_LOCK_BIT0            ((uint32)0x01u << 14u)
S    #define CY_SYS_WDT_CLK_LOCK_BIT1            ((uint32)0x01u << 15u)
S
S    #define CY_WDT_NUM_OF_WDT                   (3u)
S    #define CY_WDT_NUM_OF_CALLBACKS             (3u)
S
N    #else
N        #define CY_WDT_NUM_OF_WDT               (1u)
N        #define CY_WDT_NUM_OF_CALLBACKS         (3u)
N        #define CY_SYS_WDT_KEY                  ((uint32)(0xACED8865u))
N        #define CY_SYS_WDT_MATCH_MASK           ((uint32)(0x0000FFFFu))
N        #define CY_SYS_WDT_IGNORE_BITS_MASK     ((uint32)(0x000F0000u))
N        #define CY_SYS_WDT_IGNORE_BITS_SHIFT    ((uint32)(16u))
N        #define CY_SYS_WDT_LOWER_BIT_MASK       ((uint32)(0x00000001u))
N
N        #define CY_SYS_WDT_COUNTER0             (0x00u)
N
N#endif /* (CY_IP_SRSSV2) */
N
N#if (CY_IP_SRSSV2 && CY_IP_WCO)
X#if ((0 != 0) && ((0 != 0) || (1 == 1) || (0 != 0) || (-1 == 1)))
S    #define CY_SYS_WDT_1LFCLK_ILO_DELAY_US    ((uint16)( 67u))
S    #define CY_SYS_WDT_3LFCLK_ILO_DELAY_US    ((uint16)(201u))
S    #define CY_SYS_WDT_1LFCLK_WCO_DELAY_US    ((uint16)( 31u))
S    #define CY_SYS_WDT_3LFCLK_WCO_DELAY_US    ((uint16)( 93u))
S
S    #define CY_SYS_WDT_1LFCLK_DELAY_US      \
S        ((CY_SYS_CLK_LFCLK_SRC_ILO == (CY_SYS_WDT_CONFIG_REG & CY_SYS_CLK_LFCLK_SEL_MASK)) ? \
S                                            (CY_SYS_WDT_1LFCLK_ILO_DELAY_US) : \
S                                            (CY_SYS_WDT_1LFCLK_WCO_DELAY_US))
X    #define CY_SYS_WDT_1LFCLK_DELAY_US              ((CY_SYS_CLK_LFCLK_SRC_ILO == (CY_SYS_WDT_CONFIG_REG & CY_SYS_CLK_LFCLK_SEL_MASK)) ?                                             (CY_SYS_WDT_1LFCLK_ILO_DELAY_US) :                                             (CY_SYS_WDT_1LFCLK_WCO_DELAY_US))
S
S    #define CY_SYS_WDT_3LFCLK_DELAY_US      \
S        ((CY_SYS_CLK_LFCLK_SRC_ILO == (CY_SYS_WDT_CONFIG_REG & CY_SYS_CLK_LFCLK_SEL_MASK)) ? \
S                                            (CY_SYS_WDT_3LFCLK_ILO_DELAY_US) : \
S                                            (CY_SYS_WDT_3LFCLK_WCO_DELAY_US))
X    #define CY_SYS_WDT_3LFCLK_DELAY_US              ((CY_SYS_CLK_LFCLK_SRC_ILO == (CY_SYS_WDT_CONFIG_REG & CY_SYS_CLK_LFCLK_SEL_MASK)) ?                                             (CY_SYS_WDT_3LFCLK_ILO_DELAY_US) :                                             (CY_SYS_WDT_3LFCLK_WCO_DELAY_US))
N    #else
N        #define CY_SYS_WDT_1LFCLK_DELAY_US      ((uint16)  (67u))
N        #define CY_SYS_WDT_3LFCLK_DELAY_US      ((uint16) (201u))
N#endif /* (CY_IP_SRSSV2 && CY_IP_WCO) */
N
N#if (CY_IP_SRSSLT && CY_IP_WCO && CY_IP_WCO_WDT_EN)
X#if ((!(0 != 0)) && ((0 != 0) || (1 == 1) || (0 != 0) || (-1 == 1)) && (1 == 1))
N
N    #define CY_SYS_TIMER_MODE_NONE              (0u)
N    #define CY_SYS_TIMER_MODE_INT               (1u)
N
N    #define CY_SYS_TIMER0_MASK                  ((uint32)((uint32)0x01u))           /**< Counter 0 */
N    #define CY_SYS_TIMER1_MASK                  ((uint32)((uint32)0x01u << 8u))     /**< Counter 1 */
N    #define CY_SYS_TIMER2_MASK                  ((uint32)((uint32)0x01u << 16u))    /**< Counter 2 */
N
N    #define CY_SYS_TIMER0_RESET                 ((uint32)0x01u << 3u)       /**< Counter 0 */
N    #define CY_SYS_TIMER1_RESET                 ((uint32)0x01u << 11u)      /**< Counter 1 */
N    #define CY_SYS_TIMER2_RESET                 ((uint32)0x01u << 19u)      /**< Counter 2 */
N
N    #define CY_SYS_TIMER_RESET                  (CY_SYS_TIMER0_RESET |\
N                                                 CY_SYS_TIMER1_RESET |\
N                                                 CY_SYS_TIMER2_RESET)
X    #define CY_SYS_TIMER_RESET                  (CY_SYS_TIMER0_RESET |                                                 CY_SYS_TIMER1_RESET |                                                 CY_SYS_TIMER2_RESET)
N
N    #define CY_SYS_TIMER_CASCADE_NONE           ((uint32)0x00u)             /**< Neither */
N    #define CY_SYS_TIMER_CASCADE_01             ((uint32)0x01u << 3u)       /**< Cascade 01 */
N    #define CY_SYS_TIMER_CASCADE_12             ((uint32)0x01u << 11u)      /**< Cascade 12 */
N
N    #define CY_SYS_TIMER0_INT                   ((uint32)0x01u << 2u)
N    #define CY_SYS_TIMER1_INT                   ((uint32)0x01u << 10u)
N    #define CY_SYS_TIMER2_INT                   ((uint32)0x01u << 18u)
N
N    #define CY_SYS_TIMER0                       (0x00u)
N    #define CY_SYS_TIMER1                       (0x01u)
N    #define CY_SYS_TIMER2                       (0x02u)
N
N    #define CY_SYS_TIMER_MODE_MASK              ((uint32)(0x01u))
N
N    #define CY_SYS_TIMER_CONFIG_BITS2_MASK      (uint32)(0x1Fu)
N    #define CY_SYS_TIMER_CONFIG_BITS2_POS       (uint32)(24u)
N    #define CY_SYS_TIMER_LOWER_16BITS_MASK      (uint32)(0x0000FFFFu)
N    #define CY_SYS_TIMER_HIGHER_16BITS_MASK     (uint32)(0xFFFF0000u)
N    #define CY_SYS_TIMER_COUNTERS_MAX           (0x03u)
N    #define CY_SYS_TIMER_CNT_SHIFT              (0x08u)
N    #define CY_SYS_TIMER_CNT_MATCH_CLR_SHIFT    (0x02u)
N    #define CY_SYS_TIMER_CNT_STTS_SHIFT         (0x01u)
N    #define CY_SYS_TIMER_CNT_MATCH_SHIFT        (0x10u)
N
N    #define CY_SYS_NUM_OF_TIMERS                (3u)
N
N    #define CY_SYS_SET_NEW_TIMER_SOURCE_ILO     ((uint16)(0x02u))
N    #define CY_SYS_SET_NEW_TIMER_SOURCE_WCO     ((uint16)(0x01u))
N    #define CY_SYS_WCO_WDT_CLKEN_RESET_MASK     ((uint32)(0x03u))
N
N    #define CY_SYS_TIMER_1ILO_DELAY_US          ((uint16)( 67u))
N    #define CY_SYS_TIMER_4ILO_DELAY_US          ((uint16)(268u))
N    #define CY_SYS_TIMER_3ILO_DELAY_US          ((uint16)(201u))
N
N    #define CY_SYS_TIMER_1WCO_DELAY_US          ((uint16)( 31u))
N    #define CY_SYS_TIMER_4WCO_DELAY_US          ((uint16)(124u))
N    #define CY_SYS_TIMER_3WCO_DELAY_US          ((uint16)( 93u))
N
N    #define CY_SYS_1TIMER_DELAY_US      \
N        ((CY_SYS_CLK_TIMER_SRC_ILO == (CY_SYS_WCO_WDT_CONFIG_REG & CY_SYS_CLK_TIMER_SEL_MASK)) ? \
N                                            (CY_SYS_TIMER_1ILO_DELAY_US) : \
N                                            (CY_SYS_TIMER_1WCO_DELAY_US))
X    #define CY_SYS_1TIMER_DELAY_US              ((CY_SYS_CLK_TIMER_SRC_ILO == (CY_SYS_WCO_WDT_CONFIG_REG & CY_SYS_CLK_TIMER_SEL_MASK)) ?                                             (CY_SYS_TIMER_1ILO_DELAY_US) :                                             (CY_SYS_TIMER_1WCO_DELAY_US))
N
N    #define CY_SYS_4TIMER_DELAY_US      \
N        ((CY_SYS_CLK_TIMER_SRC_ILO == (CY_SYS_WCO_WDT_CONFIG_REG & CY_SYS_CLK_TIMER_SEL_MASK)) ? \
N                                            (CY_SYS_TIMER_4WCO_DELAY_US) : \
N                                            (CY_SYS_TIMER_4ILO_DELAY_US))
X    #define CY_SYS_4TIMER_DELAY_US              ((CY_SYS_CLK_TIMER_SRC_ILO == (CY_SYS_WCO_WDT_CONFIG_REG & CY_SYS_CLK_TIMER_SEL_MASK)) ?                                             (CY_SYS_TIMER_4WCO_DELAY_US) :                                             (CY_SYS_TIMER_4ILO_DELAY_US))
N
N    #define CY_SYS_3TIMER_DELAY_US      \
N        ((CY_SYS_CLK_TIMER_SRC_ILO == (CY_SYS_WCO_WDT_CONFIG_REG & CY_SYS_CLK_TIMER_SEL_MASK)) ? \
N                                            (CY_SYS_TIMER_3ILO_DELAY_US) : \
N                                            (CY_SYS_TIMER_3WCO_DELAY_US))
X    #define CY_SYS_3TIMER_DELAY_US              ((CY_SYS_CLK_TIMER_SRC_ILO == (CY_SYS_WCO_WDT_CONFIG_REG & CY_SYS_CLK_TIMER_SEL_MASK)) ?                                             (CY_SYS_TIMER_3ILO_DELAY_US) :                                             (CY_SYS_TIMER_3WCO_DELAY_US))
N
N    #define CY_SYS_SET_CURRENT_TIMER_SOURCE_BIT      \
N        ((CY_SYS_CLK_TIMER_SRC_ILO == (CY_SYS_WCO_WDT_CONFIG_REG & CY_SYS_CLK_TIMER_SEL_MASK)) ? \
N                                            (CY_SYS_SET_NEW_TIMER_SOURCE_ILO) : \
N                                            (CY_SYS_SET_NEW_TIMER_SOURCE_WCO))
X    #define CY_SYS_SET_CURRENT_TIMER_SOURCE_BIT              ((CY_SYS_CLK_TIMER_SRC_ILO == (CY_SYS_WCO_WDT_CONFIG_REG & CY_SYS_CLK_TIMER_SEL_MASK)) ?                                             (CY_SYS_SET_NEW_TIMER_SOURCE_ILO) :                                             (CY_SYS_SET_NEW_TIMER_SOURCE_WCO))
N
N#endif /* (CY_IP_SRSSLT && CY_IP_WCO && CY_IP_WCO_WDT_EN) */
N
N/* CySysClkWcoSetPowerMode() */
N#define CY_SYS_CLK_WCO_HPM                              (0x0u)     /**< WCO High power mode */
N
N#if(CY_IP_BLESS)
X#if((0 != 0))
S    #define CY_SYS_CLK_WCO_LPM                          (0x1u)     /**< WCO Low power mode */
N#endif /* (CY_IP_BLESS) */
N
N
N/*******************************************************************************
N*       Trim Registers Constants 
N********************************************************************************/
N#define CY_SYS_CLK_SYS_CLK_DEVIDER                  ((uint32)0x0Au)
N#define CY_SYS_CLK_SEL_ILO_DFT_SOURCE               ((uint32)0x00000100u)
N#define CY_SYS_CLK_FOURBITS_MAX                     (( int32)0x0f)
N#define CY_SYS_CLK_HALF_OF_STEP                     (( int32)((uint32) CY_SYS_CLK_ERROR_STEP >> 1u))
N
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S    #define CY_SYS_CLK_ILO_DESIRED_FREQ_HZ          (32000u)
S    #define CY_SYS_CLK_DFT_SELSIZE                  ((uint32) 0x3F)
N#else
N    #define CY_SYS_CLK_ILO_DESIRED_FREQ_HZ          (40000u)
N    #define CY_SYS_CLK_DFT_SELSIZE                  ((uint32) 0x0F)
N#endif /* (CY_IP_SRSSV2) */
N
N#define CY_SYS_TST_DDFT_CTRL_REG_DEFAULT_MASK    ((uint32)((CY_SYS_CLK_DFT_SELSIZE << 8u) | (CY_SYS_CLK_DFT_SELSIZE )))
N#define CY_SYS_TST_DDFT_SELECT_CLK1              ((uint32) ((uint32) CYDEV_DFT_SELECT_CLK1 << 8u))
N#define CY_SYS_TST_DDFT_CTRL_REG_SEL2_CLK1       ((uint32) (CY_SYS_TST_DDFT_SELECT_CLK1 | CYDEV_DFT_SELECT_CLK0))
N
N
N/*******************************************************************************
N*       Trim Registers 
N********************************************************************************/
N/* DFT TST Control Register*/
N#define CY_SYS_TST_DDFT_CTRL_REG                         (*(reg32*) CYREG_TST_DDFT_CTRL)
N#define CY_SYS_CNT_CTRL_PTR                              ( (reg32*) CYREG_TST_DDFT_CTRL)
N
N/* DFT TST Counter 1 Register*/
N#define CY_SYS_CNT_REG1_REG                              (*(reg32*) CYREG_TST_TRIM_CNTR1)
N#define CY_SYS_CNT_REG1_PTR                              ( (reg32*) CYREG_TST_TRIM_CNTR1)
N
N/* DFT TST Counter 2 Register*/
N#define CY_SYS_CNT_REG2_REG                              (*(reg32*) CYREG_TST_TRIM_CNTR2)
N#define CY_SYS_CNT_REG2_PTR                              ( (reg32*) CYREG_TST_TRIM_CNTR2)
N
N/* DFT Muxes Configuration Register*/
N#define CY_SYS_CLK_DFT_REG                               (*(reg32*) CYREG_CLK_DFT_SELECT)
N#define CY_SYS_CLK_DFT_PTR                               ( (reg32*) CYREG_CLK_DFT_SELECT)
N
N/* ILO Configuration Register*/
N#define CY_SYS_CLK_ILO_CONFIG_REG                        (*(reg32 *) CYREG_CLK_ILO_CONFIG)
N#define CY_SYS_CLK_ILO_CONFIG_PTR                        ( (reg32 *) CYREG_CLK_ILO_CONFIG)
N
N/* ILO Trim Register*/
N#if(CY_IP_SRSSV2 && CY_IP_WCO)
X#if((0 != 0) && ((0 != 0) || (1 == 1) || (0 != 0) || (-1 == 1)))
S    #define CY_SYS_CLK_ILO_TRIM_REG                      (*(reg32 *) CYREG_CLK_ILO_TRIM)
S    #define CY_SYS_CLK_ILO_TRIM_PTR                      ( (reg32 *) CYREG_CLK_ILO_TRIM)
N#endif  /* (CY_IP_SRSSV2) && CY_IP_WCO*/
N
N#if (CY_IP_WCO)
X#if (((0 != 0) || (1 == 1) || (0 != 0) || (-1 == 1)))
N    #if (CY_IP_BLESS)
X    #if ((0 != 0))
S
S        /* WCO Status Register */
S        #define CY_SYS_CLK_WCO_STATUS_REG               (*(reg32 *) CYREG_BLE_BLESS_WCO_STATUS)
S        #define CY_SYS_CLK_WCO_STATUS_PTR               ( (reg32 *) CYREG_BLE_BLESS_WCO_STATUS)
S
S        /* WCO Configuration Register */
S        #define CY_SYS_CLK_WCO_CONFIG_REG               (*(reg32 *) CYREG_BLE_BLESS_WCO_CONFIG)
S        #define CY_SYS_CLK_WCO_CONFIG_PTR               ( (reg32 *) CYREG_BLE_BLESS_WCO_CONFIG)
S
S        /* WCO Trim Register */
S        #define CY_SYS_CLK_WCO_TRIM_REG                 (*(reg32 *) CYREG_BLE_BLESS_WCO_TRIM)
S        #define CY_SYS_CLK_WCO_TRIM_PTR                 ( (reg32 *) CYREG_BLE_BLESS_WCO_TRIM)
N    #else
N
N        /* WCO Status Register */
N        #define CY_SYS_CLK_WCO_STATUS_REG               (*(reg32 *) CYREG_WCO_STATUS)
N        #define CY_SYS_CLK_WCO_STATUS_PTR               ( (reg32 *) CYREG_WCO_STATUS)
N
N        /* WCO Configuration Register */
N        #define CY_SYS_CLK_WCO_CONFIG_REG               (*(reg32 *) CYREG_WCO_CONFIG)
N        #define CY_SYS_CLK_WCO_CONFIG_PTR               ( (reg32 *) CYREG_WCO_CONFIG)
N
N        /* WCO Trim Register */
N        #define CY_SYS_CLK_WCO_TRIM_REG                 (*(reg32 *) CYREG_WCO_TRIM)
N        #define CY_SYS_CLK_WCO_TRIM_PTR                 ( (reg32 *) CYREG_WCO_TRIM)
N    #endif /* (CY_IP_BLESS) */
N#endif  /* (CY_IP_WCO) */
N
N
N/*******************************************************************************
N* WDT API Registers
N*******************************************************************************/
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S    #define CY_SYS_WDT_CTRLOW_REG               (*(reg32 *) CYREG_WDT_CTRLOW)
S    #define CY_SYS_WDT_CTRLOW_PTR               ( (reg32 *) CYREG_WDT_CTRLOW)
S
S    #define CY_SYS_WDT_CTRHIGH_REG              (*(reg32 *) CYREG_WDT_CTRHIGH)
S    #define CY_SYS_WDT_CTRHIGH_PTR              ( (reg32 *) CYREG_WDT_CTRHIGH)
S
S    #define CY_SYS_WDT_MATCH_REG                (*(reg32 *) CYREG_WDT_MATCH)
S    #define CY_SYS_WDT_MATCH_PTR                ( (reg32 *) CYREG_WDT_MATCH)
S
S    #define CY_SYS_WDT_CONFIG_REG               (*(reg32 *) CYREG_WDT_CONFIG)
S    #define CY_SYS_WDT_CONFIG_PTR               ( (reg32 *) CYREG_WDT_CONFIG)
S
S    #define CY_SYS_WDT_CONTROL_REG              (*(reg32 *) CYREG_WDT_CONTROL)
S    #define CY_SYS_WDT_CONTROL_PTR              ( (reg32 *) CYREG_WDT_CONTROL)
N#else
N    #define CY_SYS_WDT_DISABLE_KEY_REG          (*(reg32 *) CYREG_WDT_DISABLE_KEY)
N    #define CY_SYS_WDT_DISABLE_KEY_PTR          ( (reg32 *) CYREG_WDT_DISABLE_KEY)
N
N    #define CY_SYS_WDT_MATCH_REG                (*(reg32 *) CYREG_WDT_MATCH)
N    #define CY_SYS_WDT_MATCH_PTR                ( (reg32 *) CYREG_WDT_MATCH)
N
N    #define CY_SYS_WDT_COUNTER_REG              (*(reg32 *) CYREG_WDT_COUNTER)
N    #define CY_SYS_WDT_COUNTER_PTR              ( (reg32 *) CYREG_WDT_COUNTER)
N
N    #define CY_SYS_SRSS_INTR_REG                (*(reg32 *) CYREG_SRSS_INTR)
N    #define CY_SYS_SRSS_INTR_PTR                ( (reg32 *) CYREG_SRSS_INTR)
N
N    #define CY_SYS_SRSS_INTR_MASK_REG           (*(reg32 *) CYREG_SRSS_INTR_MASK)
N    #define CY_SYS_SRSS_INTR_MASK_PTR           ( (reg32 *) CYREG_SRSS_INTR_MASK)
N#endif  /* (CY_IP_SRSSV2) */
N
N#if (CY_IP_SRSSLT && CY_IP_WCO && CY_IP_WCO_WDT_EN)
X#if ((!(0 != 0)) && ((0 != 0) || (1 == 1) || (0 != 0) || (-1 == 1)) && (1 == 1))
N    #define CY_SYS_WCO_WDT_CTRLOW_REG           (*(reg32 *) CYREG_WCO_WDT_CTRLOW)
N    #define CY_SYS_WCO_WDT_CTRLOW_PTR           ( (reg32 *) CYREG_WCO_WDT_CTRLOW)
N
N    #define CY_SYS_WCO_WDT_CTRHIGH_REG          (*(reg32 *) CYREG_WCO_WDT_CTRHIGH)
N    #define CY_SYS_WCO_WDT_CTRHIGH_PTR          ( (reg32 *) CYREG_WCO_WDT_CTRHIGH)
N
N    #define CY_SYS_WCO_WDT_MATCH_REG            (*(reg32 *) CYREG_WCO_WDT_MATCH)
N    #define CY_SYS_WCO_WDT_MATCH_PTR            ( (reg32 *) CYREG_WCO_WDT_MATCH)
N
N    #define CY_SYS_WCO_WDT_CONFIG_REG           (*(reg32 *) CYREG_WCO_WDT_CONFIG)
N    #define CY_SYS_WCO_WDT_CONFIG_PTR           ( (reg32 *) CYREG_WCO_WDT_CONFIG)
N
N    #define CY_SYS_WCO_WDT_CONTROL_REG          (*(reg32 *) CYREG_WCO_WDT_CONTROL)
N    #define CY_SYS_WCO_WDT_CONTROL_PTR          ( (reg32 *) CYREG_WCO_WDT_CONTROL)
N
N    #define CY_SYS_WCO_WDT_CLKEN_REG            (*(reg32 *) CYREG_WCO_WDT_CLKEN)
N    #define CY_SYS_WCO_WDT_CLKEN_PTR            ( (reg32 *) CYREG_WCO_WDT_CLKEN)
N#endif /* (CY_IP_SRSSLT && CY_IP_WCO && CY_IP_WCO_WDT_EN) */
N
N#if (CY_IP_WCO)
X#if (((0 != 0) || (1 == 1) || (0 != 0) || (-1 == 1)))
N
N    /*******************************************************************************
N    * Function Name: CySysClkWcoSetHighPowerMode
N    ********************************************************************************
N    *
N    * Summary:
N    *  Sets the high power mode for the 32 KHz WCO.
N    *
N    *******************************************************************************/
N    static CY_INLINE void CySysClkWcoSetHighPowerMode(void)
X    static __inline void CySysClkWcoSetHighPowerMode(void)
N    {
N        /* Switch off low power mode for WCO */
N        CY_SYS_CLK_WCO_CONFIG_REG &= (uint32) ~CY_SYS_CLK_WCO_CONFIG_LPM_EN;
X        (*(reg32 *) 0x40220000u) &= (uint32) ~(( uint32 )(( uint32 )0x01u << 0u));
N
N        /* Switch off auto low power mode in WCO */
N        CY_SYS_CLK_WCO_CONFIG_REG &= ((uint32)~CY_SYS_CLK_WCO_CONFIG_LPM_AUTO);
X        (*(reg32 *) 0x40220000u) &= ((uint32)~(( uint32 )(( uint32 )0x01u << 1u)));
N
N        /* Restore WCO trim register HPM settings */
N        CY_SYS_CLK_WCO_TRIM_REG = (CY_SYS_CLK_WCO_TRIM_REG & (uint32)(~CY_SYS_CLK_WCO_TRIM_GM_MASK)) \
N                    | (uint32)(CY_SYS_CLK_WCO_TRIM_GM_HPM << CY_SYS_CLK_WCO_TRIM_GM_SHIFT);
X        (*(reg32 *) 0x40220f00u) = ((*(reg32 *) 0x40220f00u) & (uint32)(~(( uint32 )(( uint32 )0x03u << 4u))))                     | (uint32)((( uint32 ) 0x01u) << (( uint32 ) 0x04u));
N        CY_SYS_CLK_WCO_TRIM_REG = (CY_SYS_CLK_WCO_TRIM_REG & (uint32)(~CY_SYS_CLK_WCO_TRIM_XGM_MASK)) \
N                    | (uint32)(CY_SYS_CLK_WCO_TRIM_XGM_2620NA << CY_SYS_CLK_WCO_TRIM_XGM_SHIFT);
X        (*(reg32 *) 0x40220f00u) = ((*(reg32 *) 0x40220f00u) & (uint32)(~(( uint32 ) 0x07u)))                     | (uint32)((( uint32 ) 0x01u) << (( uint32 ) 0x00u));
N    }
N
N    #if(CY_IP_BLESS)
X    #if((0 != 0))
S        /*******************************************************************************
S        * Function Name: CySysClkWcoSetLowPowerMode
S        ********************************************************************************
S        *
S        * Summary:
S        *  Sets the low power mode for the 32 KHz WCO.
S        *
S        *  Note LPM available only for PSoC 4100 BLE / PSoC4 4200 BLE
S        *******************************************************************************/
S        static CY_INLINE void CySysClkWcoSetLowPowerMode(void)
S        {
S            /* Switch off auto low power mode in WCO */
S            CY_SYS_CLK_WCO_CONFIG_REG &= ((uint32)~CY_SYS_CLK_WCO_CONFIG_LPM_AUTO);
S
S            /* Change WCO trim register settings to LPM */
S            CY_SYS_CLK_WCO_TRIM_REG = (CY_SYS_CLK_WCO_TRIM_REG & (uint32)(~CY_SYS_CLK_WCO_TRIM_XGM_MASK)) \
S                        | (uint32)(CY_SYS_CLK_WCO_TRIM_XGM_2250NA << CY_SYS_CLK_WCO_TRIM_XGM_SHIFT);
X            CY_SYS_CLK_WCO_TRIM_REG = (CY_SYS_CLK_WCO_TRIM_REG & (uint32)(~CY_SYS_CLK_WCO_TRIM_XGM_MASK))                         | (uint32)(CY_SYS_CLK_WCO_TRIM_XGM_2250NA << CY_SYS_CLK_WCO_TRIM_XGM_SHIFT);
S            CY_SYS_CLK_WCO_TRIM_REG = (CY_SYS_CLK_WCO_TRIM_REG & (uint32)(~CY_SYS_CLK_WCO_TRIM_GM_MASK)) \
S                        | (uint32)(CY_SYS_CLK_WCO_TRIM_GM_LPM << CY_SYS_CLK_WCO_TRIM_GM_SHIFT);
X            CY_SYS_CLK_WCO_TRIM_REG = (CY_SYS_CLK_WCO_TRIM_REG & (uint32)(~CY_SYS_CLK_WCO_TRIM_GM_MASK))                         | (uint32)(CY_SYS_CLK_WCO_TRIM_GM_LPM << CY_SYS_CLK_WCO_TRIM_GM_SHIFT);
S
S            /* Switch on low power mode for WCO */
S            CY_SYS_CLK_WCO_CONFIG_REG |= CY_SYS_CLK_WCO_CONFIG_LPM_EN;
S        }
N    #endif /* (CY_IP_BLESS) */
N
N#endif /* (CY_IP_WCO) */
N
N
N/* These defines are intended to maintain the backward compatibility for
N * projects which use cy_boot_v4_20 or earlier.
N*/
N#define CySysWdtWriteMode           CySysWdtSetMode
N#define CySysWdtReadMode            CySysWdtGetMode
N#define CySysWdtWriteClearOnMatch   CySysWdtSetClearOnMatch
N#define CySysWdtReadClearOnMatch    CySysWdtGetClearOnMatch
N#define CySysWdtReadEnabledStatus   CySysWdtGetEnabledStatus
N#define CySysWdtWriteCascade        CySysWdtSetCascade
N#define CySysWdtReadCascade         CySysWdtGetCascade
N#define CySysWdtWriteMatch          CySysWdtSetMatch
N#define CySysWdtWriteToggleBit      CySysWdtSetToggleBit
N#define CySysWdtReadToggleBit       CySysWdtGetToggleBit
N#define CySysWdtReadMatch           CySysWdtGetMatch
N#define CySysWdtReadCount           CySysWdtGetCount
N#define CySysWdtWriteIgnoreBits     CySysWdtSetIgnoreBits
N#define CySysWdtReadIgnoreBits      CySysWdtGetIgnoreBits
N#define CySysWdtSetIsrCallback      CySysWdtSetInterruptCallback
N#define CySysWdtGetIsrCallback      CySysWdtGetInterruptCallback
N
N#endif /* (CY_LFCLK_CYLIB_H) */
N
N/* [] END OF FILE */
L 24 "Generated_Source\PSoC4\CyLib.h" 2
N
N#include <string.h>
L 1 "D:\Keil_v5\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 26 "Generated_Source\PSoC4\CyLib.h" 2
N#include <limits.h>
L 1 "D:\Keil_v5\ARM\ARMCC\bin\..\include\limits.h" 1
N/* limits.h: ANSI 'C' (X3J11 Oct 88) library header, section 2.2.4.2 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991-1997 ARM Limited. All rights reserved         */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __limits_h
N#define __limits_h
N#define __ARMCLIB_VERSION 5060019
N
N#define CHAR_BIT 8
N    /* max number of bits for smallest object that is not a bit-field (byte) */
N#define SCHAR_MIN (-128)
N    /* mimimum value for an object of type signed char */
N#define SCHAR_MAX 127
N    /* maximum value for an object of type signed char */
N#define UCHAR_MAX 255
N    /* maximum value for an object of type unsigned char */
N#ifdef __FEATURE_SIGNED_CHAR
N  #define CHAR_MIN (-128)
N      /* minimum value for an object of type char */
N  #define CHAR_MAX 127
N      /* maximum value for an object of type char */
N#else
S  #define CHAR_MIN 0
S      /* minimum value for an object of type char */
S  #define CHAR_MAX 255
S      /* maximum value for an object of type char */
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
Sextern const int __aeabi_MB_LEN_MAX;
S#define MB_LEN_MAX (__aeabi_MB_LEN_MAX)
N#else
N#define MB_LEN_MAX 6
N#endif
N    /* maximum number of bytes in a multibyte character, */
N    /* for any supported locale */
N
N#define SHRT_MIN  (-0x8000)
N    /* minimum value for an object of type short int */
N#define SHRT_MAX  0x7fff
N    /* maximum value for an object of type short int */
N#define USHRT_MAX 65535
N    /* maximum value for an object of type unsigned short int */
N#define INT_MIN   (~0x7fffffff)  /* -2147483648 and 0x80000000 are unsigned */
N    /* minimum value for an object of type int */
N#define INT_MAX   0x7fffffff
N    /* maximum value for an object of type int */
N#define UINT_MAX  0xffffffffU
N    /* maximum value for an object of type unsigned int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define LONG_MIN  (~0x7fffffffffffffffL)
N#else
N  #define LONG_MIN  (~0x7fffffffL)
N#endif
N    /* minimum value for an object of type long int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define LONG_MAX  0x7fffffffffffffffL
N#else
N  #define LONG_MAX  0x7fffffffL
N#endif
N    /* maximum value for an object of type long int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define ULONG_MAX 0xffffffffffffffffUL
N#else
N  #define ULONG_MAX 0xffffffffUL
N#endif
N    /* maximum value for an object of type unsigned long int */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N  #define LLONG_MIN  (~0x7fffffffffffffffLL)
N      /* minimum value for an object of type long long int */
N  #define LLONG_MAX    0x7fffffffffffffffLL
N      /* maximum value for an object of type long long int */
N  #define ULLONG_MAX   0xffffffffffffffffULL
N      /* maximum value for an object of type unsigned long int */
N#endif
N
N#endif
N
N/* end of limits.h */
N
L 27 "Generated_Source\PSoC4\CyLib.h" 2
N#include <ctype.h>
L 1 "D:\Keil_v5\ARM\ARMCC\bin\..\include\ctype.h" 1
N/* ctype.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.3 */
N/* Copyright (C) Codemist Ltd. 1988-1993.                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.03 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/*
N * ctype.h declares several functions useful for testing and mapping
N * characters. In all cases the argument is an int, the value of which shall
N * be representable as an unsigned char or shall equal the value of the
N * macro EOF. If the argument has any other value, the behaviour is undefined.
N */
N
N#ifndef __ctype_h
N#define __ctype_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE_DEF inline
N#elif defined(__GNUC__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif 0L || (1L && 199901L <= 199901L)
N#define _ARMABI_INLINE_DEF static inline
N#elif defined(_USE_STATIC_INLINE)
S#define _ARMABI_INLINE_DEF static __inline
S#else
S#define _ARMABI_INLINE_DEF __inline
N#endif
N
N  #ifndef __CTYPE_DECLS
N  #define __CTYPE_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/* AEABI portable ctype flag bits */
N#define _ABI_A    1       /* alphabetic        */
N#define _ABI_X    2       /* A-F, a-f and 0-9  */
N#define _ABI_P    4       /* punctuation       */
N#define _ABI_B    8       /* blank             */
N#define _ABI_S   16       /* white space       */
N#define _ABI_L   32       /* lower case letter */
N#define _ABI_U   64       /* upper case letter */
N#define _ABI_C  128       /* control chars     */
N
N/* ARM internal ctype flag bits */
N/* N.B. - keep in step with <ctype.c> */
N
N/*
N * __ARM_CT_A (alphabetic) is required because characters in some locales
N * (e.g. Japanese) can be alphabetic but neither uppercase nor
N * lowercase. Unfortunately there wasn't a bit free for this, so
N * instead we've defined __ARM_CT_A as __ARM_CT_N+__ARM_CT_X (on the grounds that this
N * was a previously unused combination). Hence some of the ctype
N * predicates below are slightly less than obvious in
N * implementation.
N */
N#define __ARM_CT_S 1            /* whitespace           */
N#define __ARM_CT_P 2            /* punctuation          */
N#define __ARM_CT_B 4            /* blank                */
N#define __ARM_CT_L 8            /* lower case letter    */
N#define __ARM_CT_U 16           /* upper case letter    */
N#define __ARM_CT_N 32           /* (decimal) digit      */
N#define __ARM_CT_C 64           /* control chars        */
N#define __ARM_CT_X 128          /* A-F and a-f          */
N#define __ARM_CT_A (__ARM_CT_N+__ARM_CT_X)    /* alphabetic           */
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S
Sextern int (isalnum)(int /*c*/);
Sextern int (isalpha)(int /*c*/);
Sextern int (isblank)(int /*c*/);
Sextern int (iscntrl)(int /*c*/);
Sextern int (isdigit)(int /*c*/);
Sextern int (isgraph)(int /*c*/);
Sextern int (islower)(int /*c*/);
Sextern int (isprint)(int /*c*/);
Sextern int (ispunct)(int /*c*/);
Sextern int (isspace)(int /*c*/);
Sextern int (isupper)(int /*c*/);
Sextern int (isxdigit)(int /*c*/);
S
S/* Mandatory character attribute arrays indexed from 0 to 256 */
Sextern unsigned char const __aeabi_ctype_table_C[257];  /* "C" locale */
Sextern unsigned char const __aeabi_ctype_table_[257];   /* default locale */
S         /* The default locale might be the C locale */
S/* Optional character attribute arrays indexed from 0 to 256.        */
S/* These do not have to be provided by every execution environment   */
S/* but, if provided, shall be provided with these names and meaning. */
Sextern unsigned char const __aeabi_ctype_table_ISO8859_1[257];
Sextern unsigned char const __aeabi_ctype_table_SJIS[257];
Sextern unsigned char const __aeabi_ctype_table_BIG5[257];
Sextern unsigned char const __aeabi_ctype_table_UTF8[257];
S#ifdef _AEABI_LC_CTYPE
S# define _AEABI_CTYPE_TABLE(_X) __aeabi_ctype_table_ ## _X
S# define _AEABI_CTYPE(_X) _AEABI_CTYPE_TABLE(_X)
S# define __aeabi_ctype_table _AEABI_CTYPE(_AEABI_LC_CTYPE)
S#else
S# define __aeabi_ctype_table __aeabi_ctype_table_
S#endif
S
S#define isspace(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_S)
S#define isalpha(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_A)
S#define isalnum(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 30) /* test for _ABI_A and _ABI_X */
S#define isprint(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 28) /* test for _ABI_A, _ABI_X, _ABI_P and _ABI_B */
S#define isupper(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_U)
S#define islower(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_L)
S#define isxdigit(x) ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_X)
S#define isgraph(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 29) /* test for _ABI_A, _ABI_X and _ABI_P */
S#define iscntrl(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_C)
S#define ispunct(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_P)
S#define isdigit(c)  (((unsigned)(c) - '0') < 10)
S
N#else /* __AEABI_PORTABILITY_LEVEL */
N
Nextern _ARMABI_PURE unsigned char **__rt_ctype_table(void);
Xextern __declspec(__nothrow) __attribute__((const)) unsigned char **__rt_ctype_table(void);
N
N#define __arm_ctype (*__CLIBNS __rt_ctype_table())
N
N#ifdef __cplusplus
S    inline int isalnum(int __c) { return (__arm_ctype[__c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_N)); }
N#else
N    #define isalnum(c) (__arm_ctype[c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_N))
N    extern int (isalnum)(int /*c*/);
N#endif
N    /* non-0 iff c is alphabetic or numeric */
N
N#ifdef __cplusplus
S    inline int isalpha(int __c) { return (__arm_ctype[__c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_X)); }
N#else
N    #define isalpha(c) (__arm_ctype[c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_X))
N    extern int (isalpha)(int /*c*/);
N#endif
N    /* non-0 iff c is alphabetic */
N
N#ifdef __cplusplus
S    inline int iscntrl(int __c) { return (__arm_ctype[__c] & __ARM_CT_C); }
N#else
N    #define iscntrl(c) (__arm_ctype[c] & __ARM_CT_C)
N    extern int (iscntrl)(int /*c*/);
N#endif
N    /* non-0 iff c is a control character - in the "C" locale */
N    /*       this means (c < ' ') || (c > '~')                */
N
N/* isdigit must test for the presence of _only_ __ARM_CT_N, not just __ARM_CT_N at all. */
N#ifdef __cplusplus
S    inline int isdigit(int __c) { return (__arm_ctype[__c] == __ARM_CT_N); }
N#else
N    #define isdigit(c) (__arm_ctype[c] == __ARM_CT_N)
N    extern int (isdigit)(int /*c*/);
N#endif
N    /* non-0 iff c is a decimal digit */
N
N    extern int (isblank)(int /*c*/);
N    /* non-0 iff c is ' ', '\t' or some other locale-specific, */
N    /* word-separating character (there are no others in "C"   */
N    /* locale) */
N
N#ifdef __cplusplus
S    inline int isgraph(int __c) {return(__arm_ctype[__c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_X+__ARM_CT_P));}
N#else
N    #define isgraph(c) (__arm_ctype[c]&(__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_X+__ARM_CT_P))
N    extern int (isgraph)(int /*c*/);
N#endif
N    /* non-0 iff c is any printing character other than ' ' */
N
N#ifdef __cplusplus
S    inline int islower(int __c) { return (__arm_ctype[__c] & __ARM_CT_L); }
N#else
N    #define islower(c) (__arm_ctype[c] & __ARM_CT_L)
N    extern int (islower)(int /*c*/);
N#endif
N    /* non-0 iff c is a lower-case letter */
N
N#ifdef __cplusplus
S    inline int isprint(int __c) { return (__arm_ctype[__c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_P+__ARM_CT_B)); }
N#else
N    #define isprint(c) (__arm_ctype[c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_P+__ARM_CT_B))
N    extern int (isprint)(int /*c*/);
N#endif
N    /* non-0 iff c is a printing character - in the "C" locale */
N    /*       this means 0x20 (space) -> 0x7E (tilde)           */
N
N#ifdef __cplusplus
S    inline int ispunct(int __c) { return (__arm_ctype[__c] & __ARM_CT_P); }
N#else
N    #define ispunct(c) (__arm_ctype[c] & __ARM_CT_P)
N    extern int (ispunct)(int /*c*/);
N#endif
N    /* non-0 iff c is a non-space, non-alpha-numeric, printing character */
N
N#ifdef __cplusplus
S    inline int isspace(int __c) { return (__arm_ctype[__c] & __ARM_CT_S); }
N#else
N    #define isspace(c) (__arm_ctype[c] & __ARM_CT_S)
N    extern int (isspace)(int /*c*/);
N#endif
N    /* non-0 iff c is a white-space char: ' ', '\f', '\n', '\r', '\t', '\v'. */
N
N#ifdef __cplusplus
S    inline int isupper(int __c) { return (__arm_ctype[__c] & __ARM_CT_U); }
N#else
N    #define isupper(c) (__arm_ctype[c] & __ARM_CT_U)
N    extern int (isupper)(int /*c*/);
N#endif
N    /* non-0 iff c is an upper-case letter */
N
N/* isxdigit must test for the presence of __ARM_CT_N or __ARM_CT_X but not both. */
N/* This helper function avoids needing to evaluate c twice. */
N
N_ARMABI_INLINE_DEF int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }
Xstatic inline int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }
N#ifdef __cplusplus
S    inline int isxdigit(int __c){return __isxdigit_helper(__arm_ctype[__c]) & __ARM_CT_X;}
N#else
N    #define isxdigit(c) (__isxdigit_helper(__arm_ctype[c]) & __ARM_CT_X)
N    extern int (isxdigit)(int /*c*/);
N#endif
N    /* non-0 iff c is a digit, in 'a'..'f', or in 'A'..'F' */
N
N#endif /* __AEABI_PORTABILITY_LEVEL */
N
Nextern int tolower(int /*c*/);
N    /* if c is an upper-case letter then return the corresponding */
N    /* lower-case letter, otherwise return c.                     */
N
Nextern int toupper(int /*c*/);
N    /* if c is an lower-case letter then return the corresponding */
N    /* upper-case letter, otherwise return c.                     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __CTYPE_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __CTYPE_NO_EXPORTS
S      using ::std::isalnum;
S      using ::std::isalpha;
S      using ::std::iscntrl;
S      using ::std::isdigit;
S      using ::std::isblank;
S      using ::std::isgraph;
S      using ::std::islower;
S      using ::std::isprint;
S      using ::std::ispunct;
S      using ::std::isspace;
S      using ::std::isupper;
S      using ::std::isxdigit;
S      using ::std::tolower;
S      using ::std::toupper;
S    #endif /* __CTYPE_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of ctype.h */
N
L 28 "Generated_Source\PSoC4\CyLib.h" 2
N
N
N/**
N* \addtogroup group_clocking
N
NPSoC devices supported by PSoC Creator have flexible clocking capabilities. These clocking capabilities are
Ncontrolled in PSoC Creator by selections within the Design-Wide Resources settings, connectivity of clocking signals on
Nthe design schematic, and API calls that can modify the clocking at runtime. The clocking API is provided in the CyLib.c
Nand CyLib.h files.
N
NThis section describes how PSoC Creator maps clocks onto the device and provides guidance on clocking methodologies that
Nare optimized for the PSoC architecture.
N
N
N\section section_clocking_modes Power Modes
NThe IMO is available in Active and Sleep modes. It is automatically disabled/enabled for the proper Deep Sleep and
NHibernate mode entry/exit. The IMO is disabled during Deep Sleep and Hibernate modes.
N
NThe EXTCLK is available in Active and Sleep modes. The system will enter/exit Deep Sleep and Hibernate using external
Nclock. The device will re-enable the IMO if it was enabled before entering Deep Sleep or Hibernate, but it does not wait
Nfor the IMO before starting the CPU. After entering Active mode, the IMO may take an additional 2 us to begin toggling.
NThe IMO will startup cleanly without glitches, but any dependency should account for this extra startup time. If
Ndesired, firmware may increase wakeup hold-off using \ref CySysPmSetWakeupHoldoff() function to include this 2 us and
Nensure the IMO is toggling by the time Active mode is reached.
N
NThe ILO is available in all modes except Hibernate and Stop.
N
N
N
N\section section_clocking_connectivity Clock Connectivity
NThe PSoC architecture includes flexible clock generation logic. Refer to the Technical Reference Manual for a detailed
Ndescription of all the clocking sources available in a particular device. The usage of these various clocking sources
Ncan be categorized by how those clocks are connected to elements of a design.
N
N\section section_clocking_runtime_changing Changing Clocks in Run-time
N
N\subsection section_clocking_runtime_changing_impact Impact on Components Operation
NThe components with internal clocks are directly impacted by the change of the system clock frequencies or sources. The
Ncomponents clock frequencies obtained using design-time dividers. The run-time change of components clock source will
Ncorrespondingly change the internal component clock.  Refer to the component datasheet for the details.
N
N\subsection section_clocking_runtime_adjust CyDelay APIs
NThe CyDelay APIs implement simple software-based delay loops. The loops compensate for system clock frequency. The
N\ref CyDelayFreq() function must be called in order to adjust \ref CyDelay(), \ref CyDelayUs() and \ref CyDelayCycles()
Nfunctions to the new system clock value.
N
N\subsection section_clocking_runtime_cache Cache Configuration
NIf the CPU clock frequency increases during device operation, the number of clock cycles cache will wait before sampling
Ndata coming back from Flash should be adjusted. If the CPU clock frequency decreases, the number of clock cycles can be
Nalso adjusted to improve CPU performance. See CySysFlashSetWaitCycles() for PSoC 4 for more information.
N
N*/
N
N
N/**
N* \addtogroup group_clocking_hfclk High-Frequency Clocking API
N* \ingroup group_clocking
N* @{
N*/
Nvoid CySysClkImoStart(void);
Nvoid CySysClkImoStop(void);
Nvoid CySysClkWriteHfclkDirect(uint32 clkSelect);
N
N#if (CY_IP_IMO_TRIMMABLE_BY_WCO)
X#if ((0 == 0))
N    void CySysClkImoEnableWcoLock(void);
N    void CySysClkImoDisableWcoLock(void);
N    uint32 CySysClkImoGetWcoLock(void);
N#endif /* (CY_IP_IMO_TRIMMABLE_BY_WCO) */
N
N#if (CY_IP_IMO_TRIMMABLE_BY_USB)
X#if ((0 != 0))
S    void CySysClkImoEnableUsbLock(void);
S    void CySysClkImoDisableUsbLock(void);
S    uint32 CySysClkImoGetUsbLock(void);
N#endif  /* (CY_IP_IMO_TRIMMABLE_BY_USB) */
N
N#if (CY_IP_SRSSLT)
X#if ((!(0 != 0)))
N    void CySysClkWriteHfclkDiv(uint32 divider);
N#endif /* (CY_IP_SRSSLT) */
N
Nvoid CySysClkWriteSysclkDiv(uint32 divider);
Nvoid CySysClkWriteImoFreq(uint32 freq);
Nuint32 CySysClkGetSysclkSource(void);
Nvoid CySysEnablePumpClock(uint32 enable);
N
N/** @} group_clocking_hfclk */
N
N
N/**
N* \addtogroup group_clocking_lfclk Low-Frequency Clocking API
N* \ingroup group_clocking
N* \detailed For PSoC 4 devices, the CyLFClk (low-frequency clock) APIs are located in separate files
N* (CyLFClk.h/CyLFClk.c). See the CyLFClk Component Datasheet available from the System Reference Guides item of the
N* PSoC Creator Help menu.
N* @{
N*/
N/** @} group_clocking_lfclk */
N
N
N/**
N* \addtogroup group_clocking_eco External Crystal Oscillator (ECO) API
N* \ingroup group_clocking
N* @{
N*/
N#if (CY_IP_ECO)
X#if (((0 != 0) || (-1 == 1) || (0 != 0) || ((1 != 0) && (1 != 0))))
N    cystatus CySysClkEcoStart(uint32 timeoutUs);
N    void     CySysClkEcoStop(void);
N    uint32   CySysClkEcoReadStatus(void);
N
N    #if (CY_IP_ECO_BLESS || CY_IP_ECO_BLESSV3)
X    #if ((0 != 0) || (0 != 0))
S        void CySysClkWriteEcoDiv(uint32 divider);
N    #endif /* (CY_IP_ECO_BLESS || CY_IP_ECO_BLESSV3) */
N
N    #if (CY_IP_ECO_SRSSV2 || CY_IP_ECO_SRSSLT)
X    #if ((-1 == 1) || ((1 != 0) && (1 != 0)))
N        void CySysClkConfigureEcoTrim(uint32 wDTrim, uint32 aTrim, uint32 fTrim, uint32 rTrim, uint32 gTrim);
N        cystatus CySysClkConfigureEcoDrive(uint32 freq, uint32 cLoad, uint32 esr, uint32 maxAmplitude);
N    #endif /* (CY_IP_ECO_SRSSV2 || CY_IP_ECO_SRSSLT) */
N#endif  /* (CY_IP_ECO) */
N/** @} group_clocking_eco */
N
N
N/**
N* \addtogroup group_clocking_pll Phase-Locked Loop (PLL) API
N* \ingroup group_clocking
N* @{
N*/
N#if (CY_IP_PLL)
X#if ((1 == 1))
N    cystatus CySysClkPllStart(uint32 pll, uint32 wait);
N    void     CySysClkPllStop(uint32 pll);
N    cystatus CySysClkPllSetPQ(uint32 pll, uint32 feedback, uint32 reference, uint32 current);
N    cystatus CySysClkPllSetFrequency(uint32 pll, uint32 inputFreq, uint32 pllFreq, uint32 divider, uint32 freqTol);
N    void     CySysClkPllSetSource(uint32 pll, uint32 source);
N    cystatus CySysClkPllSetOutputDivider(uint32 pll, uint32 divider);
N    void CySysClkPllSetBypassMode(uint32 pll, uint32 bypass);
N    uint32 CySysClkPllGetUnlockStatus(uint32 pll);
N    uint32 CySysClkPllGetLockStatus(uint32 pll);
N#endif /* (CY_IP_PLL) */
N/** @} group_clocking_pll */
N
N
N/**
N* \addtogroup group_api_lvd_functions Low Voltage Detection API
N* @{
N*/
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S    void   CySysLvdEnable(uint32 threshold);
S    void   CySysLvdDisable(void);
S    uint32 CySysLvdGetInterruptSource(void);
S    void   CySysLvdClearInterrupt(void);
N#endif  /* (CY_IP_SRSSV2) */
N/** @} group_api_lvd_functions */
N
N
N/**
N* \addtogroup group_interrupts Interrupt API
N* \brief The APIs in this chapter apply to all architectures except as noted. The Interrupts API is provided in the
N* CyLib.c and CyLib.h files. Refer also to the Interrupt component datasheet for more information about interrupts.
N* @{
N*/
Ncyisraddress CyIntSetSysVector(uint8 number, cyisraddress address);
Ncyisraddress CyIntGetSysVector(uint8 number);
N
Ncyisraddress CyIntSetVector(uint8 number, cyisraddress address);
Ncyisraddress CyIntGetVector(uint8 number);
N
Nvoid   CyIntSetPriority(uint8 number, uint8 priority);
Nuint8  CyIntGetPriority(uint8 number);
N
Nvoid   CyIntEnable(uint8 number);
Nuint8  CyIntGetState(uint8 number);
Nvoid   CyIntDisable(uint8 number);
N
Nvoid   CyIntSetPending(uint8 number);
Nvoid   CyIntClearPending(uint8 number);
N
Nuint32 CyDisableInts(void);
Nvoid   CyEnableInts(uint32 mask);
N/** @} group_interrupts */
N
N
N/**
N* \addtogroup group_api_delay_functions Delay API
N* @{
N*/
N/* Do not use these definitions directly in your application */
Nextern uint32 cydelayFreqHz;
Nextern uint32 cydelayFreqKhz;
Nextern uint8  cydelayFreqMhz;
Nextern uint32 cydelay32kMs;
N
Nvoid  CyDelay(uint32 milliseconds);
Nvoid  CyDelayUs(uint16 microseconds);
Nvoid  CyDelayFreq(uint32 freq);
Nvoid  CyDelayCycles(uint32 cycles);
N/** @} group_api_delay_functions */
N
N
N/**
N* \addtogroup group_api_system_functions System API
N* @{
N*/
Nvoid  CySoftwareReset(void);
Nuint8 CyEnterCriticalSection(void);
Nvoid  CyExitCriticalSection(uint8 savedIntrStatus);
Nvoid  CyHalt(uint8 reason);
Nuint32 CySysGetResetReason(uint32 reason);
Nvoid CyGetUniqueId(uint32* uniqueId);
N
N/* Default interrupt handler */
NCY_ISR_PROTO(IntDefaultHandler);
Xvoid IntDefaultHandler (void);
N/** @} group_api_system_functions */
N
N
N/**
N* \addtogroup group_api_systick_functions System Timer (SysTick) API
N* @{
N*/
N
Ntypedef void (*cySysTickCallback)(void);
N
Nvoid CySysTickStart(void);
Nvoid CySysTickInit(void);
Nvoid CySysTickEnable(void);
Nvoid CySysTickStop(void);
Nvoid CySysTickEnableInterrupt(void);
Nvoid CySysTickDisableInterrupt(void);
Nvoid CySysTickSetReload(uint32 value);
Nuint32 CySysTickGetReload(void);
Nuint32 CySysTickGetValue(void);
NcySysTickCallback CySysTickSetCallback(uint32 number, cySysTickCallback function);
NcySysTickCallback CySysTickGetCallback(uint32 number);
N
N#if(CY_SYSTICK_LFCLK_SOURCE)
X#if((1 != 0))
N    void CySysTickSetClockSource(uint32 clockSource);
N    uint32 CySysTickGetClockSource(void);
N#endif /* (CY_SYSTICK_LFCLK_SOURCE) */
N
Nuint32 CySysTickGetCountFlag(void);
Nvoid CySysTickClear(void);
Nextern uint32 CySysTickInitVar;
N/** @} group_api_systick_functions */
N
N
N#if (CY_IP_DMAC_PRESENT)
X#if ((1 == 1))
N    void CySysSetRamAccessArbPriority(uint32 source);
N    void CySysSetFlashAccessArbPriority(uint32 source);
N    void CySysSetDmacAccessArbPriority(uint32 source);
N    void CySysSetPeripheralAccessArbPriority(uint32 interfaceNumber, uint32 source);
N#endif /* (CY_IP_DMAC_PRESENT) */
N
N
N/**
N* \addtogroup group_api_pvb_functions Programmable Voltage Block (PVB) API
N* @{
N*/
N#if (CY_IP_PASS)
X#if ((0 == 1))
S    void CySysPrbSetGlobalVrefSource(uint32 source);
S    void CySysPrbSetBgGain(uint32 gain);
S    void CySysPrbSetGlobalVrefVoltage(uint32 voltageTap);
S    void CySysPrbEnableDeepsleepVddaRef(void);
S    void CySysPrbDisableDeepsleepVddaRef(void);
S    void CySysPrbEnableVddaRef(void);
S    void CySysPrbDisableVddaRef(void);
S    void CySysPrbSetBgBufferTrim(int32 bgTrim);
S    int32 CySysPrbGetBgBufferTrim(void);
N#endif /* (CY_IP_PASS) */
N/** @} group_api_pvb_functions */
N
N
N/***************************************
N* API Constants
N***************************************/
N
N
N/*******************************************************************************
N* Clock API Constants
N*******************************************************************************/
N
N/* CySysClkWriteHfclkDirect() - implementation definitions */
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S    #define CY_SYS_CLK_SELECT_DIRECT_SEL_MASK           (( uint32 ) 0x07u)
S    #define CY_SYS_CLK_SELECT_DIRECT_SEL_PARAM_MASK     (( uint32 ) 0x07u)
S
S    #define CY_SYS_CLK_SELECT_HFCLK_SEL_SHIFT           (( uint32 ) 16u)
S
S    #if (CY_IP_PLL)
S        #define CY_SYS_CLK_SELECT_HFCLK_SEL_MASK        (( uint32 ) 3u << CY_SYS_CLK_SELECT_HFCLK_SEL_SHIFT)
S    #else
S        #define CY_SYS_CLK_SELECT_HFCLK_SEL_MASK        (( uint32 ) 0u )
S    #endif /* (CY_IP_PLL) */
S
N#else
N    #if (CY_IP_PLL && CY_IP_SRSSLT)    
X    #if ((1 == 1) && (!(0 != 0)))    
N        #define CY_SYS_ECO_CLK_SELECT_ECO_PLL_MASK      (( uint32 ) 0x01u )
N        #define CY_SYS_CLK_SELECT_HFCLK_SEL_PLL_MASK    (( uint32 ) 0x04u )
N        #define CY_SYS_CLK_SELECT_HFCLK_PLL_SHIFT       (( uint32 ) 2u) 
N       
N        #define CY_SYS_EXCO_PGM_CLK_ENABLE_MASK         (( uint32 ) 0x80000000u)
N        #define CY_SYS_EXCO_PGM_CLK_CLK_ECO_MASK        (( uint32 ) 0x2u)
N        #define CY_SYS_EXCO_PGM_CLK_SEQ_GENERATOR       (( uint8 ) 0x5u)
N    #endif /* (CY_IP_PLL && CY_IP_SRSSLT) */
N
N    #define CY_SYS_CLK_SELECT_HFCLK_SEL_MASK            (( uint32 ) 0u )  
N    #define CY_SYS_CLK_SELECT_DIRECT_SEL_MASK           (( uint32 ) 0x03u)
N    #define CY_SYS_CLK_SELECT_DIRECT_SEL_PARAM_MASK     (CY_SYS_CLK_SELECT_DIRECT_SEL_MASK)
N#endif  /* (CY_IP_SRSSV2) */
N
N/* CySysClkWriteHfclkDirect() - parameter definitions */
N#define CY_SYS_CLK_HFCLK_IMO                            (0u)
N#define CY_SYS_CLK_HFCLK_EXTCLK                         (1u)
N#if (CY_IP_ECO)
X#if (((0 != 0) || (-1 == 1) || (0 != 0) || ((1 != 0) && (1 != 0))))
N    #define CY_SYS_CLK_HFCLK_ECO                        (2u)
N#endif  /* (CY_IP_ECO) */
N
N#if (CY_IP_PLL)
X#if ((1 == 1))
N    #if (CY_IP_SRSSV2)
X    #if ((0 != 0))
S        #define CY_SYS_CLK_HFCLK_PLL0                   ((uint32) ((uint32) 2u << CY_SYS_CLK_SELECT_HFCLK_SEL_SHIFT))
S        #define CY_SYS_CLK_HFCLK_PLL1                   ((uint32) ((uint32) 1u << CY_SYS_CLK_SELECT_HFCLK_SEL_SHIFT))
N    #else
N        #define CY_SYS_CLK_HFCLK_PLL0                   (6u)
N    #endif /* (CY_IP_SRSSV2) */
N#endif  /* (CY_IP_PLL) */
N
N/* CySysClkWriteSysclkDiv() - parameter definitions */
N#define CY_SYS_CLK_SYSCLK_DIV1                          (0u)
N#define CY_SYS_CLK_SYSCLK_DIV2                          (1u)
N#define CY_SYS_CLK_SYSCLK_DIV4                          (2u)
N#define CY_SYS_CLK_SYSCLK_DIV8                          (3u)
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S    #define CY_SYS_CLK_SYSCLK_DIV16                     (4u)
S    #define CY_SYS_CLK_SYSCLK_DIV32                     (5u)
S    #define CY_SYS_CLK_SYSCLK_DIV64                     (6u)
S    #define CY_SYS_CLK_SYSCLK_DIV128                    (7u)
N#endif  /* (CY_IP_SRSSV2) */
N
N
N/* CySysClkWriteSysclkDiv() - implementation definitions */
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S    #define CY_SYS_CLK_SELECT_SYSCLK_DIV_SHIFT          (19u)
S    #define CY_SYS_CLK_SELECT_SYSCLK_DIV_MASK           (( uint32 )0x07u)
N#else
N    #define CY_SYS_CLK_SELECT_SYSCLK_DIV_SHIFT          (6u)
N    #define CY_SYS_CLK_SELECT_SYSCLK_DIV_MASK           (( uint32 )0x03u)
N#endif  /* (CY_IP_SRSSV2) */
N
N
N/* CySysClkPllSetSource() - implementation definitions */
N#if (CY_IP_PLL)
X#if ((1 == 1))
N    #if(CY_IP_SRSSV2)
X    #if((0 != 0))
S        #define CY_SYS_CLK_SELECT_PLL_SHIFT(x)          (3u + (3u * (x)))
S        #define CY_SYS_CLK_SELECT_PLL_MASK(x)           ((uint32) ((uint32) 0x07u << CY_SYS_CLK_SELECT_PLL_SHIFT((x))))
N    #else
N        #define CY_SYS_ECO_CLK_SELECT_PLL0_SHIFT        (1u)
N        #define CY_SYS_ECO_CLK_SELECT_PLL0_MASK         ((uint32) ((uint32) 0x01u << CY_SYS_ECO_CLK_SELECT_PLL0_SHIFT))
N    #endif  /* (CY_IP_SRSSV2) */
N#endif /* (CY_IP_PLL) */
N
N/* CySysClkPllSetSource() - parameter definitions */
N#if (CY_IP_PLL)
X#if ((1 == 1))
N    #if(CY_IP_SRSSV2)
X    #if((0 != 0))
S        #define CY_SYS_PLL_SOURCE_IMO                   (0u)
S        #define CY_SYS_PLL_SOURCE_EXTCLK                (1u)
S        #define CY_SYS_PLL_SOURCE_ECO                   (2u)
S        #define CY_SYS_PLL_SOURCE_DSI0                  (4u)
S        #define CY_SYS_PLL_SOURCE_DSI1                  (5u)
S        #define CY_SYS_PLL_SOURCE_DSI2                  (6u)
S        #define CY_SYS_PLL_SOURCE_DSI3                  (7u)
N    #else
N        #define CY_SYS_PLL_SOURCE_ECO                   (0u)
N        #define CY_SYS_PLL_SOURCE_IMO                   (1u)
N    #endif  /* (CY_IP_SRSSV2) */
N#endif /* (CY_IP_PLL) */
N
N/* CySysClkPllSetBypassMode() - parameter definitions */
N#if(CY_IP_SRSSV2 || CY_IP_SRSSLT)
X#if((0 != 0) || (!(0 != 0)))
N    #if (CY_IP_PLL)
X    #if ((1 == 1))
N        #define CY_SYS_PLL_BYPASS_AUTO         (0u)
N        #define CY_SYS_PLL_BYPASS_PLL_REF      (2u)
N        #define CY_SYS_PLL_BYPASS_PLL_OUT      (3u)
N    #endif /* (CY_IP_PLL) */
N#endif  /* (CY_IP_SRSSV2 || CY_IP_SRSSLT)) */
N
N/* CySysClkPllSetOutputDivider()/CySysClkPllSetFrequency() - parameters */
N#if(CY_IP_SRSSV2 || CY_IP_SRSSLT)
X#if((0 != 0) || (!(0 != 0)))
N    #if (CY_IP_PLL)
X    #if ((1 == 1))
N        #define CY_SYS_PLL_OUTPUT_DIVPASS               (0u)
N        #define CY_SYS_PLL_OUTPUT_DIV2                  (1u)
N        #define CY_SYS_PLL_OUTPUT_DIV4                  (2u)
N        #define CY_SYS_PLL_OUTPUT_DIV8                  (3u)
N    #endif /* (CY_IP_PLL) */
N#endif  /* (CY_IP_SRSSV2 || CY_IP_SRSSLT) */
N
N/* CySysPumpClock() */
N#define CY_SYS_CLK_PUMP_DISABLE                         ((uint32) 0u)
N#define CY_SYS_CLK_PUMP_ENABLE                          ((uint32) 1u)
N
N#if (CY_IP_PLL)
X#if ((1 == 1))
N
N    /* Set of the PLL registers */
N    typedef struct
N    {
N        uint32 config;
N        uint32 status;
N        uint32 test;
N    } cy_sys_clk_pll_regs_struct;
N
N    /* Array of the PLL registers */
N    typedef struct
N    {
N        cy_sys_clk_pll_regs_struct pll[2u];
N    } cy_sys_clk_pll_struct;
N
N
N    /* CySysClkPllSetPQ() - implementation definitions */
N    #define CY_SYS_CLK_PLL_CONFIG_FEEDBACK_DIV_SHIFT     (0u)
N    #define CY_SYS_CLK_PLL_CONFIG_REFERENCE_DIV_SHIFT    (8u)
N    #define CY_SYS_CLK_PLL_CONFIG_OUTPUT_DIV_SHIFT       (14u)
N    #define CY_SYS_CLK_PLL_CONFIG_ICP_SEL_SHIFT          (16u)
N    #define CY_SYS_CLK_PLL_CONFIG_BYPASS_SEL_SHIFT       (20u)
N
N    #define CY_SYS_CLK_PLL_CONFIG_FEEDBACK_DIV_MASK     ((uint32) ((uint32) 0xFFu << CY_SYS_CLK_PLL_CONFIG_FEEDBACK_DIV_SHIFT))
N    #define CY_SYS_CLK_PLL_CONFIG_REFERENCE_DIV_MASK    ((uint32) ((uint32) 0x3Fu << CY_SYS_CLK_PLL_CONFIG_REFERENCE_DIV_SHIFT))
N    #define CY_SYS_CLK_PLL_CONFIG_OUTPUT_DIV_MASK       ((uint32) ((uint32) 0x03u << CY_SYS_CLK_PLL_CONFIG_OUTPUT_DIV_SHIFT))
N    #define CY_SYS_CLK_PLL_CONFIG_ICP_SEL_MASK          ((uint32) ((uint32) 0x07u << CY_SYS_CLK_PLL_CONFIG_ICP_SEL_SHIFT))
N    #define CY_SYS_CLK_PLL_CONFIG_BYPASS_SEL_MASK       ((uint32) ((uint32) 0x03u << CY_SYS_CLK_PLL_CONFIG_BYPASS_SEL_SHIFT))
N
N    #define CY_SYS_CLK_PLL_CONFIG_BYPASS_SEL_PLL_REF    ((uint32) ((uint32) 2u << CY_SYS_CLK_PLL_CONFIG_BYPASS_SEL_SHIFT))
N
N    #define CY_SYS_CLK_PLL_CONFIG_FEEDBACK_DIV_MIN      (4u)
N    #define CY_SYS_CLK_PLL_CONFIG_FEEDBACK_DIV_MAX      (259u)
N    #define CY_SYS_CLK_PLL_CONFIG_ICP_SEL_MIN           (2u)
N    #define CY_SYS_CLK_PLL_CONFIG_ICP_SEL_MAX           (3u)
N    #define CY_SYS_CLK_PLL_CONFIG_REFERENCE_DIV_MIN     (1u)
N    #define CY_SYS_CLK_PLL_CONFIG_REFERENCE_DIV_MAX     (64u)
N
N    /* CySysClkPllGetUnlockStatus() - implementation definitions */
N    #define CY_SYS_CLK_PLL_TEST_UNLOCK_OCCURRED_SHIFT   (4u)
N    #define CY_SYS_CLK_PLL_TEST_UNLOCK_OCCURRED_MASK    (( uint32 )(( uint32 )0x01u << CY_SYS_CLK_PLL_TEST_UNLOCK_OCCURRED_SHIFT))
N
N    /* CySysClkPllSetFrequency() - implementation definitions */
N    #define CY_SYS_CLK_PLL_QMINIP                       (1u)
N    #define CY_SYS_CLK_PLL_FPFDMAX                      (3000u)
N
N    #define CY_SYS_CLK_PLL_QMAXIP                       (64u)
N    #define CY_SYS_CLK_PLL_FPFDMIN                      (1000u)
N
N    #define CY_SYS_CLK_PLL_INVALID                      (0u)
N    #define CY_SYS_CLK_PLL_CURRENT_DEFAULT              (2u)
N
N    #define CY_SYS_CLK_PLL_INPUT_FREQ_MIN               (1000u)
N    #define CY_SYS_CLK_PLL_INPUT_FREQ_MAX               (49152u)
N
N    #define CY_SYS_CLK_PLL_OUTPUT_FREQ_MIN              (22500u)
N    #define CY_SYS_CLK_PLL_OUTPUT_FREQ_MAX              (49152u)
N
N    /* CySysClkPllStart() / CySysClkPllStop() - implementation definitions */
N    #define CY_SYS_CLK_PLL_STATUS_LOCKED                (1u)
N    #define CY_SYS_CLK_PLL_MIN_STARTUP_US               (5u)
N    #define CY_SYS_CLK_PLL_MAX_STARTUP_US               (255u)
N
N    #define CY_SYS_CLK_PLL_CONFIG_ENABLE                ((uint32) ((uint32) 1u << 31u))
N    #define CY_SYS_CLK_PLL_CONFIG_ISOLATE               ((uint32) ((uint32) 1u << 30u))
N
N#endif /* (CY_IP_PLL) */
N
N/* CySysClkWriteImoFreq() - implementation definitions */
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S    #define CY_SYS_CLK_IMO_MAX_FREQ_MHZ                 (48u)
S    #define CY_SYS_CLK_IMO_MIN_FREQ_MHZ                 (3u)
S
S    #define CY_SYS_CLK_IMO_TEMP_FREQ_MHZ                (24u)
S    #define CY_SYS_CLK_IMO_TEMP_FREQ_TRIM2              (0x19u)     /* Corresponds to 24 MHz */
S
S    #define CY_SYS_CLK_IMO_BOUNDARY_FREQ_MHZ            (43u)
S    #define CY_SYS_CLK_IMO_BOUNDARY_FREQ_TRIM2          (0x30u)     /* Corresponds to 43 MHz */
S
S    #define CY_SYS_CLK_IMO_FREQ_TIMEOUT_CYCLES          (5u)
S    #define CY_SYS_CLK_IMO_TRIM_TIMEOUT_US              (5u)
S    #define CY_SYS_CLK_IMO_FREQ_TABLE_SIZE              (46u)
S    #define CY_SYS_CLK_IMO_FREQ_TABLE_OFFSET            (3u)
S    #define CY_SYS_CLK_IMO_FREQ_BITS_MASK               (( uint32 )0x3Fu)
S    #define CY_SYS_CLK_IMO_FREQ_CLEAR                   (( uint32 )(CY_SYS_CLK_IMO_FREQ_BITS_MASK << 8u))
S    #define CY_SYS_CLK_IMO_TRIM4_GAIN_MASK				(( uint32 )0x1Fu)
S	#define CY_SYS_CLK_IMO_TRIM4_WCO_GAIN               (( uint32 ) 12u)
S    #define CY_SYS_CLK_IMO_TRIM4_USB_GAIN               (( uint32 ) 8u)
S
S    #if(CY_IP_IMO_TRIMMABLE_BY_USB)
S        #define CY_SYS_CLK_USBDEVv2_CR1_ENABLE_LOCK     (( uint32 )0x02u)
S        #define CY_SFLASH_S1_TESTPGM_REV_MASK           (( uint32 )0x3Fu)
S        #define CY_SFLASH_S1_TESTPGM_OLD_REV            (( uint32 )4u)
S    #endif /* (CY_IP_IMO_TRIMMABLE_BY_USB) */
S
N#else
N    #define CY_SYS_CLK_IMO_MIN_FREQ_MHZ                 (24u)
N    #define CY_SYS_CLK_IMO_MAX_FREQ_MHZ                 (48u)
N    #define CY_SYS_CLK_IMO_STEP_SIZE_MASK               (0x03u)
N    #define CY_SYS_CLK_IMO_TRIM1_OFFSET_MASK            (( uint32 )(0xFFu))
N    #define CY_SYS_CLK_IMO_TRIM2_FSOFFSET_MASK          (( uint32 )(0x07u))
N    #define CY_SYS_CLK_IMO_TRIM3_VALUES_MASK            (( uint32 )(0x7Fu))
N    #define CY_SYS_CLK_IMO_SELECT_FREQ_MASK             (( uint32 )(0x07u))
N    #define CY_SYS_CLK_IMO_SELECT_FREQ_SHIFT            (( uint32 )(0x02u))
N    #define CY_SYS_CLK_IMO_SELECT_24MHZ                 (( uint32 )(0x00u))
N
N    #define CY_SYS_CLK_IMO_TRIM_DELAY_US                (( uint32 )(50u))
N    #define CY_SYS_CLK_IMO_TRIM_DELAY_CYCLES            (( uint32 )(50u))    
N#endif  /* (CY_IP_SRSSV2) */
N
N/* CySysClkImoEnableUsbLock(void) -  - implementation definitions */
N#if(CY_IP_IMO_TRIMMABLE_BY_USB)
X#if((0 != 0))
S    #define CY_SYS_CLK_USBDEVv2_CR1_ENABLE_LOCK         (( uint32 )0x02u)
N#endif /* (CY_IP_IMO_TRIMMABLE_BY_USB) */
N
N#if (CY_IP_IMO_TRIMMABLE_BY_WCO && CY_IP_IMO_TRIMMABLE_BY_USB)
X#if ((0 == 0) && (0 != 0))
S    #define CY_SYS_CLK_OSCINTF_CTL_PORT_SEL_MASK        (( uint32 )0x01u)
S    #define CY_SYS_CLK_OSCINTF_CTL_PORT_SEL_USB         (( uint32 )0x00u)
S    #define CY_SYS_CLK_OSCINTF_CTL_PORT_SEL_WCO         (( uint32 )0x01u)
N#endif /* (CY_IP_IMO_TRIMMABLE_BY_WCO && CY_IP_IMO_TRIMMABLE_BY_USB) */
N
N
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S        /* Conversion between CySysClkWriteImoFreq() parameter and register's value */
S        extern const uint8 cyImoFreqMhz2Reg[CY_SYS_CLK_IMO_FREQ_TABLE_SIZE];
N#endif /* (CY_IP_SRSSV2) */
N
N
N/* CySysClkImoStart()/CySysClkImoStop() - implementation definitions */
N#define CY_SYS_CLK_IMO_CONFIG_ENABLE                    (( uint32 )(( uint32 )0x01u << 31u))
N
N
N#if(CY_IP_SRSSLT)
X#if((!(0 != 0)))
N    /* CySysClkWriteHfclkDiv() - parameter definitions */
N    #define CY_SYS_CLK_HFCLK_DIV_NODIV                  (0u)
N    #define CY_SYS_CLK_HFCLK_DIV_2                      (1u)
N    #define CY_SYS_CLK_HFCLK_DIV_4                      (2u)
N    #define CY_SYS_CLK_HFCLK_DIV_8                      (3u)
N
N    /* CySysClkWriteHfclkDiv() - implementation definitions */
N    #define CY_SYS_CLK_SELECT_HFCLK_DIV_SHIFT           (2u)
N    #define CY_SYS_CLK_SELECT_HFCLK_DIV_MASK            (( uint32 )0x03u)
N#endif  /* (CY_IP_SRSSLT) */
N
N
N/* Operating source for Pump clock */
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S    #define CY_SYS_CLK_IMO_CONFIG_PUMP_SEL_SHIFT        (25u)
S    #define CY_SYS_CLK_IMO_CONFIG_PUMP_SEL_MASK         ((uint32) 0x07u)
S    #define CY_SYS_CLK_IMO_CONFIG_PUMP_SEL_IMO          (1u)
S
S	#define CY_SYS_CLK_IMO_CONFIG_PUMP_OSC              (( uint32 )(( uint32 )0x01u << 22u))
N#else /* CY_IP_SRSSLT */
N    #define CY_SYS_CLK_SELECT_PUMP_SEL_SHIFT            (4u)
N    #define CY_SYS_CLK_SELECT_PUMP_SEL_MASK             ((uint32) 0x03u)
N    #define CY_SYS_CLK_SELECT_PUMP_SEL_IMO              (1u)
N#endif  /* (CY_IP_SRSSLT) */
N
N
N#if (CY_IP_ECO_BLESS)
X#if ((0 != 0))
S    /* Radio configuration register */
S    #define CY_SYS_XTAL_BLESS_RF_CONFIG_RF_ENABLE       (( uint32 )0x01u)
S
S    /* RFCTRL mode transition control */
S    #define CY_SYS_XTAL_BLERD_DBUS_XTAL_ENABLE          (( uint32 )(( uint32 )0x01u << 15u))
S
S    /* XO is oscillating status */
S    #define CY_SYS_XTAL_BLERD_FSM_XO_AMP_DETECT         (( uint32 )0x01u)
S
S    /* BB bump configuration 2 */
S    #define CY_SYS_XTAL_BLERD_BB_XO_CAPTRIM_X1_MASK     (( uint32 )(( uint32 )0x7Fu <<  8u))
S    #define CY_SYS_XTAL_BLERD_BB_XO_CAPTRIM_X2_MASK     (( uint32 )(( uint32 )0x7Fu <<  0u))
S    #define CY_SYS_XTAL_BLERD_BB_XO_CAPTRIM_X1_ADD_CAP  (( uint32 )(( uint32 )0x01u << 15u))
S    #define CY_SYS_XTAL_BLERD_BB_XO_CAPTRIM_X2_ADD_CAP  (( uint32 )(( uint32 )0x01u <<  7u))
S
S    /* BB bump configuration 1 */
S    #define CY_SYS_XTAL_BLERD_BB_XO_TRIM                ((uint32) 0x2002u)
S
S
S    /**
S    * \addtogroup group_api_eco
S    * @{
S    */
S     #define CY_SYS_CLK_ECO_DIV1    ((uint32) 0x00)     /**< CySysClkWriteEcoDiv(): HFCLK = ECO / 1 */
S     #define CY_SYS_CLK_ECO_DIV2    ((uint32) 0x01)     /**< CySysClkWriteEcoDiv(): HFCLK = ECO / 2 */
S     #define CY_SYS_CLK_ECO_DIV4    ((uint32) 0x02)     /**< CySysClkWriteEcoDiv(): HFCLK = ECO / 4 */
S     #define CY_SYS_CLK_ECO_DIV8    ((uint32) 0x03)     /**< CySysClkWriteEcoDiv(): HFCLK = ECO / 8 */
S    /** @} group_api_eco */
S
S    /* CySysClkWriteEcoDiv() - implementation definitions */
S    #define CY_SYS_CLK_XTAL_CLK_DIV_MASK                ((uint32) 0x03)
N#endif  /* (CY_IP_ECO_BLESS) */
N
N#if (CY_IP_ECO_BLESSV3)
X#if ((0 != 0))
S     #define CY_SYS_CLK_ECO_DIV1    ((uint32) 0x00)     /**< CySysClkWriteEcoDiv(): HFCLK = ECO / 1 */
S     #define CY_SYS_CLK_ECO_DIV2    ((uint32) 0x01)     /**< CySysClkWriteEcoDiv(): HFCLK = ECO / 2 */
S     #define CY_SYS_CLK_ECO_DIV4    ((uint32) 0x02)     /**< CySysClkWriteEcoDiv(): HFCLK = ECO / 4 */
S     #define CY_SYS_CLK_ECO_DIV8    ((uint32) 0x03)     /**< CySysClkWriteEcoDiv(): HFCLK = ECO / 8 */
S    /** @} group_api_eco */
S
S    #define CY_SYS_BLESS_HVLDO_STARTUP_DELAY                ((uint32) 2u)
S    #define CY_SYS_BLESS_ISOLATE_DEASSERT_DELAY             ((uint32) 1u)
S    #define CY_SYS_BLESS_ACT_TO_SWITCH_DELAY                ((uint32) 1u)
S    #define CY_SYS_BLESS_HVLDO_DISABLE_DELAY                ((uint32) 1u)
S
S    #define CY_SYS_BLESS_OSC_STARTUP_DELAY_LF               ((uint32) 80u)
S    #define CY_SYS_BLESS_DSM_OFFSET_TO_WAKEUP_INST_LF       ((uint32) 4u)
S    #define CY_SYS_BLESS_ACT_STARTUP_DELAY                  ((uint32) 1u)
S    #define CY_SYS_BLESS_DIG_LDO_STARTUP_DELAY              ((uint32) 1u)
S
S    #define CY_SYS_BLESS_XTAL_DISABLE_DELAY                 ((uint32) 1u)
S    #define CY_SYS_BLESS_DIG_LDO_DISABLE_DELAY              ((uint32) 1u)
S
S    #define CY_SYS_BLESS_MT_CFG_ACT_LDO                     ((uint32) 1u)
S    #define CY_SYS_BLESS_MT_CFG_ENABLE_BLERD                ((uint32) 1u)
S    #define CY_SYS_BLESS_MT_CFG_DPSLP_ECO_ON                ((uint32) 1u)
S    
S    #define CY_SYS_BLESS_MT_STATUS_BLERD_IDLE               ((uint32) 4u)
S    #define CY_SYS_BLESS_MT_STATUS_SWITCH_EN                ((uint32) 5u)
S    #define CY_SYS_BLESS_MT_STATUS_ACTIVE                   ((uint32) 6u)
S    #define CY_SYS_BLESS_MT_STATUS_ISOLATE                  ((uint32) 7u)
S    
S    #define CY_SYS_BLESS_BLERD_ACTIVE_INTR_MASK             ((uint32) 0x20u)
S    #define CY_SYS_BLESS_BLERD_ACTIVE_INTR_STAT             ((uint32) 0x8u)
S
S    #define CY_SYS_BLESS_MT_STATUS_CURR_STATE_MASK          ((uint32) 0x1Eu)
S    
S    #define CY_SYS_RCB_CTRL_ENABLED                         ((uint32) 1u)
S    #define CY_SYS_RCB_CTRL_DIV_ENABLED                     ((uint32) 1u)
S    #define CY_SYS_RCB_CTRL_DIV                             ((uint32) 2u)
S    #define CY_SYS_RCB_CTRL_LEAD                            ((uint32) 3u)
S    #define CY_SYS_RCB_CTRL_LAG                             ((uint32) 3u)
S    
S    #define CY_SYS_RCB_INTR_RCB_DONE                        ((uint32) 1u)
S    #define CY_SYS_RCB_INTR_RCB_RX_FIFO_NOT_EMPTY           ((uint32) ((uint32)0x1u << 17u))
S    #define CY_SYS_RCB_INTR_CLEAR                           ((uint32) 0xFFFFFFFFu)
S    #define CY_SYS_RCB_RBUS_RD_CMD                          ((uint32) ((uint32)0x1u << 31u))
S    #define CY_SYS_RCB_RBUS_DIG_CLK_SET                     ((uint32) 0x1e030400u)
S    #define CY_SYS_RCB_RBUS_FREQ_NRST_SET                   ((uint32) 0x1e021800u)
S    #define CY_SYS_RCB_RBUS_FREQ_XTAL_DIV_SET               ((uint32) 0x1e090040u)
S    #define CY_SYS_RCB_RBUS_FREQ_XTAL_NODIV_SET             ((uint32) 0x1e090000u)
S    #define CY_SYS_RCB_RBUS_RF_DCXO_CFG_SET                 ((uint32) 0x1e080000u)
S    #define CY_SYS_RCB_RBUS_IB_VAL                          ((uint32) ((uint32)0x1u << 9u))
S    #define CY_SYS_RCB_RBUS_IB_MASK                         ((uint32) ((uint32)0x3u << 9u))
S    #define CY_SYS_RCB_RBUS_TRIM_VAL                        ((uint32) (CYDEV_RCB_RBUS_RF_DCXO_CAP_TRIM << 1u))
S    #define CY_SYS_RCB_RBUS_TRIM_MASK                       ((uint32) ((uint32)0xFFu << 1u))
S    #define CY_SYS_RCB_RBUS_VAL_MASK                        ((uint32) 0xFFFFu)
S
S    #define CY_SYS_RCBLL_CPU_ACCESS                         ((uint32) 0u)
S    #define CY_SYS_RCBLL_BLELL_ACCESS                       ((uint32) 1u)
S
S    #define CY_SYS_BLELL_CMD_ENTER_DSM                      ((uint32) 0x50u)
S    
S    #define CY_SYS_BLESS_MT_DELAY_CFG_INIT \
S           ((CY_SYS_BLESS_HVLDO_STARTUP_DELAY    <<  CYFLD_BLE_BLESS_HVLDO_STARTUP_DELAY__OFFSET) | \
S            (CY_SYS_BLESS_ISOLATE_DEASSERT_DELAY <<  CYFLD_BLE_BLESS_ISOLATE_DEASSERT_DELAY__OFFSET) | \
S            (CY_SYS_BLESS_ACT_TO_SWITCH_DELAY    <<  CYFLD_BLE_BLESS_ACT_TO_SWITCH_DELAY__OFFSET) | \
S            (CY_SYS_BLESS_HVLDO_DISABLE_DELAY    <<  CYFLD_BLE_BLESS_HVLDO_DISABLE_DELAY__OFFSET))
X    #define CY_SYS_BLESS_MT_DELAY_CFG_INIT            ((CY_SYS_BLESS_HVLDO_STARTUP_DELAY    <<  CYFLD_BLE_BLESS_HVLDO_STARTUP_DELAY__OFFSET) |             (CY_SYS_BLESS_ISOLATE_DEASSERT_DELAY <<  CYFLD_BLE_BLESS_ISOLATE_DEASSERT_DELAY__OFFSET) |             (CY_SYS_BLESS_ACT_TO_SWITCH_DELAY    <<  CYFLD_BLE_BLESS_ACT_TO_SWITCH_DELAY__OFFSET) |             (CY_SYS_BLESS_HVLDO_DISABLE_DELAY    <<  CYFLD_BLE_BLESS_HVLDO_DISABLE_DELAY__OFFSET))
S
S    #define CY_SYS_BLESS_MT_DELAY_CFG2_INIT \
S           ((CY_SYS_BLESS_OSC_STARTUP_DELAY_LF          << CYFLD_BLE_BLESS_OSC_STARTUP_DELAY_LF__OFFSET) | \
S            (CY_SYS_BLESS_DSM_OFFSET_TO_WAKEUP_INST_LF  << CYFLD_BLE_BLESS_DSM_OFFSET_TO_WAKEUP_INSTANT_LF__OFFSET) | \
S            (CY_SYS_BLESS_ACT_STARTUP_DELAY             << CYFLD_BLE_BLESS_ACT_STARTUP_DELAY__OFFSET) | \
S            (CY_SYS_BLESS_DIG_LDO_STARTUP_DELAY         << CYFLD_BLE_BLESS_DIG_LDO_STARTUP_DELAY__OFFSET))
X    #define CY_SYS_BLESS_MT_DELAY_CFG2_INIT            ((CY_SYS_BLESS_OSC_STARTUP_DELAY_LF          << CYFLD_BLE_BLESS_OSC_STARTUP_DELAY_LF__OFFSET) |             (CY_SYS_BLESS_DSM_OFFSET_TO_WAKEUP_INST_LF  << CYFLD_BLE_BLESS_DSM_OFFSET_TO_WAKEUP_INSTANT_LF__OFFSET) |             (CY_SYS_BLESS_ACT_STARTUP_DELAY             << CYFLD_BLE_BLESS_ACT_STARTUP_DELAY__OFFSET) |             (CY_SYS_BLESS_DIG_LDO_STARTUP_DELAY         << CYFLD_BLE_BLESS_DIG_LDO_STARTUP_DELAY__OFFSET))
S    
S    #define CY_SYS_BLESS_MT_DELAY_CFG3_INIT \
S           ((CY_SYS_BLESS_XTAL_DISABLE_DELAY    << CYFLD_BLE_BLESS_XTAL_DISABLE_DELAY__OFFSET) | \
S            (CY_SYS_BLESS_DIG_LDO_DISABLE_DELAY << CYFLD_BLE_BLESS_DIG_LDO_DISABLE_DELAY__OFFSET))
X    #define CY_SYS_BLESS_MT_DELAY_CFG3_INIT            ((CY_SYS_BLESS_XTAL_DISABLE_DELAY    << CYFLD_BLE_BLESS_XTAL_DISABLE_DELAY__OFFSET) |             (CY_SYS_BLESS_DIG_LDO_DISABLE_DELAY << CYFLD_BLE_BLESS_DIG_LDO_DISABLE_DELAY__OFFSET))
S    
S    #define CY_SYS_BLESS_MT_CFG_CLEAR \
S                                                  ~(CY_GET_FIELD_MASK(32, CYFLD_BLE_BLESS_ENABLE_BLERD) | \
S                                                    CY_GET_FIELD_MASK(32, CYFLD_BLE_BLESS_DPSLP_ECO_ON) | \
S                                                    CY_GET_FIELD_MASK(32, CYFLD_BLE_BLESS_ACT_LDO_NOT_BUCK))
X    #define CY_SYS_BLESS_MT_CFG_CLEAR                                                   ~(CY_GET_FIELD_MASK(32, CYFLD_BLE_BLESS_ENABLE_BLERD) |                                                     CY_GET_FIELD_MASK(32, CYFLD_BLE_BLESS_DPSLP_ECO_ON) |                                                     CY_GET_FIELD_MASK(32, CYFLD_BLE_BLESS_ACT_LDO_NOT_BUCK))
S    
S    #define CY_SYS_BLESS_MT_CFG_INIT \
S           ((CY_SYS_BLESS_MT_CFG_ENABLE_BLERD           <<  CYFLD_BLE_BLESS_ENABLE_BLERD__OFFSET) | \
S            (CY_SYS_BLESS_MT_CFG_DPSLP_ECO_ON           <<  CYFLD_BLE_BLESS_DPSLP_ECO_ON__OFFSET) | \
S            (CY_SYS_BLESS_MT_CFG_ACT_LDO                <<  CYFLD_BLE_BLESS_ACT_LDO_NOT_BUCK__OFFSET))
X    #define CY_SYS_BLESS_MT_CFG_INIT            ((CY_SYS_BLESS_MT_CFG_ENABLE_BLERD           <<  CYFLD_BLE_BLESS_ENABLE_BLERD__OFFSET) |             (CY_SYS_BLESS_MT_CFG_DPSLP_ECO_ON           <<  CYFLD_BLE_BLESS_DPSLP_ECO_ON__OFFSET) |             (CY_SYS_BLESS_MT_CFG_ACT_LDO                <<  CYFLD_BLE_BLESS_ACT_LDO_NOT_BUCK__OFFSET))
S    
S    #define CY_SYS_RCB_CTRL_CLEAR \
S                                                  ~(CY_GET_FIELD_MASK(32, CYFLD_BLE_RCB_ENABLED) | \
S                                                    CY_GET_FIELD_MASK(32, CYFLD_BLE_RCB_DIV_ENABLED) | \
S                                                    CY_GET_FIELD_MASK(32, CYFLD_BLE_RCB_DIV) | \
S                                                    CY_GET_FIELD_MASK(32, CYFLD_BLE_RCB_LEAD) | \
S                                                    CY_GET_FIELD_MASK(32, CYFLD_BLE_RCB_LAG))
X    #define CY_SYS_RCB_CTRL_CLEAR                                                   ~(CY_GET_FIELD_MASK(32, CYFLD_BLE_RCB_ENABLED) |                                                     CY_GET_FIELD_MASK(32, CYFLD_BLE_RCB_DIV_ENABLED) |                                                     CY_GET_FIELD_MASK(32, CYFLD_BLE_RCB_DIV) |                                                     CY_GET_FIELD_MASK(32, CYFLD_BLE_RCB_LEAD) |                                                     CY_GET_FIELD_MASK(32, CYFLD_BLE_RCB_LAG))
S    
S    #define CY_SYS_RCB_CTRL_INIT \
S           ((CY_SYS_RCB_CTRL_ENABLED            <<  CYFLD_BLE_RCB_ENABLED__OFFSET) | \
S            (CY_SYS_RCB_CTRL_DIV_ENABLED        <<  CYFLD_BLE_RCB_DIV_ENABLED__OFFSET) | \
S            (CY_SYS_RCB_CTRL_DIV                <<  CYFLD_BLE_RCB_DIV__OFFSET) | \
S            (CY_SYS_RCB_CTRL_LEAD               <<  CYFLD_BLE_RCB_LEAD__OFFSET) | \
S            (CY_SYS_RCB_CTRL_LAG                <<  CYFLD_BLE_RCB_LAG__OFFSET))
X    #define CY_SYS_RCB_CTRL_INIT            ((CY_SYS_RCB_CTRL_ENABLED            <<  CYFLD_BLE_RCB_ENABLED__OFFSET) |             (CY_SYS_RCB_CTRL_DIV_ENABLED        <<  CYFLD_BLE_RCB_DIV_ENABLED__OFFSET) |             (CY_SYS_RCB_CTRL_DIV                <<  CYFLD_BLE_RCB_DIV__OFFSET) |             (CY_SYS_RCB_CTRL_LEAD               <<  CYFLD_BLE_RCB_LEAD__OFFSET) |             (CY_SYS_RCB_CTRL_LAG                <<  CYFLD_BLE_RCB_LAG__OFFSET))
S
S    /* CySysClkWriteEcoDiv() - implementation definitions */
S    #define CY_SYS_CLK_XTAL_CLK_DIV_MASK                    ((uint32) 0x03)
S    
S    #define CY_SYS_BLE_CLK_ECO_FREQ_32MHZ                   (32)
S
N#endif  /* (CY_IP_ECO_BLESSV3) */
N
N
N/* CySysClkImoEnableWcoLock() / CySysClkImoDisableWcoLock() constants */
N#if (CY_IP_IMO_TRIMMABLE_BY_WCO)
X#if ((0 == 0))
N    /* Fimo = DPLL_MULT  * Fwco */
N
N    #define CY_SYS_CLK_WCO_CONFIG_DPLL_ENABLE               (( uint32 )(( uint32 )0x01u << 30u))
N
N    /* Rounding integer division: DPLL_MULT = (Fimo_in_khz + Fwco_in_khz / 2) / Fwco_in_khz */
N    #define CY_SYS_CLK_WCO_DPLL_MULT_VALUE(frequencyMhz)    ((uint32) (((((frequencyMhz) * 1000000u) + 16384u) / 32768u) - 1u))
N    #define CY_SYS_CLK_WCO_DPLL_MULT_MASK                   ((uint32) 0x7FFu)
N
N    #define CY_SYS_CLK_WCO_CONFIG_DPLL_LF_IGAIN_SHIFT       (16u)
N    #define CY_SYS_CLK_WCO_CONFIG_DPLL_LF_PGAIN_SHIFT       (19u)
N    #define CY_SYS_CLK_WCO_CONFIG_DPLL_LF_LIMIT_SHIFT       (22u)
N
N    #define CY_SYS_CLK_WCO_CONFIG_DPLL_LF_IGAIN_MASK        (( uint32 )(( uint32 )0x07u << CY_SYS_CLK_WCO_CONFIG_DPLL_LF_IGAIN_SHIFT))
N    #define CY_SYS_CLK_WCO_CONFIG_DPLL_LF_PGAIN_MASK        (( uint32 )(( uint32 )0x07u << CY_SYS_CLK_WCO_CONFIG_DPLL_LF_PGAIN_SHIFT))
N    #define CY_SYS_CLK_WCO_CONFIG_DPLL_LF_LIMIT_MASK        (( uint32 )(( uint32 )0xFFu << CY_SYS_CLK_WCO_CONFIG_DPLL_LF_LIMIT_SHIFT))
N
N    #define CY_SYS_CLK_WCO_CONFIG_DPLL_LF_IGAIN             (( uint32 )(( uint32 ) 4u << CY_SYS_CLK_WCO_CONFIG_DPLL_LF_IGAIN_SHIFT))
N    #define CY_SYS_CLK_WCO_CONFIG_DPLL_LF_PGAIN             (( uint32 )(( uint32 ) 2u << CY_SYS_CLK_WCO_CONFIG_DPLL_LF_PGAIN_SHIFT))
N
N    #define CY_SYS_CLK_WCO_CONFIG_DPLL_LF_LIMIT_MAX         ((uint32) 0xFFu)
N    #define CY_SYS_CLK_WCO_IMO_TIMEOUT_MS                   ((uint32) 20u)
N
N    #define CY_SYS_CLK_IMO_FREQ_WCO_DPLL_SAFE_POINT         (26u)
N    #define CY_SYS_CLK_IMO_FREQ_WCO_DPLL_TABLE_SIZE         (23u)
N    #define CY_SYS_CLK_IMO_FREQ_WCO_DPLL_TABLE_OFFSET       (26u)
N
N#endif /* (CY_IP_IMO_TRIMMABLE_BY_WCO) */
N
N
N/*******************************************************************************
N* System API Constants
N*******************************************************************************/
N
N/* CySysGetResetReason() */
N#define CY_SYS_RESET_WDT_SHIFT          (0u)
N#define CY_SYS_RESET_PROTFAULT_SHIFT    (3u)
N#define CY_SYS_RESET_SW_SHIFT           (4u)
N
N#define CY_SYS_RESET_WDT                ((uint32)1u << CY_SYS_RESET_WDT_SHIFT      )
N#define CY_SYS_RESET_PROTFAULT          ((uint32)1u << CY_SYS_RESET_PROTFAULT_SHIFT)
N#define CY_SYS_RESET_SW                 ((uint32)1u << CY_SYS_RESET_SW_SHIFT       )
N
N
N/* CySoftwareReset() - implementation definitions */
N
N/* Vector Key */
N#define CY_SYS_AIRCR_VECTKEY_SHIFT      (16u)
N#define CY_SYS_AIRCR_VECTKEY            ((uint32)((uint32)0x05FAu << CY_SYS_AIRCR_VECTKEY_SHIFT))
N#define CY_SYS_AIRCR_VECTKEY_MASK       ((uint32)((uint32)0xFFFFu << CY_SYS_AIRCR_VECTKEY_SHIFT))
N
N/* System Reset Request */
N#define CY_SYS_AIRCR_SYSRESETREQ_SHIFT  (2u)
N#define CY_SYS_AIRCR_SYSRESETREQ        ((uint32)((uint32)1u << CY_SYS_AIRCR_SYSRESETREQ_SHIFT))
N
N
N#if defined(__ARMCC_VERSION)
X#if 1L
N
N    #define CyGlobalIntEnable           do                      \
N                                        {                       \
N                                            __enable_irq();     \
N                                        } while ( 0 )
X    #define CyGlobalIntEnable           do                                                              {                                                                   __enable_irq();                                             } while ( 0 )
N
N    #define CyGlobalIntDisable          do                      \
N                                        {                       \
N                                            __disable_irq();    \
N                                        } while ( 0 )
X    #define CyGlobalIntDisable          do                                                              {                                                                   __disable_irq();                                            } while ( 0 )
N
N#elif defined(__GNUC__) || defined (__ICCARM__)
S
S    #define CyGlobalIntEnable           do                      \
S                                        {                       \
S                                            __asm("CPSIE   i"); \
S                                        } while ( 0 )
X    #define CyGlobalIntEnable           do                                                              {                                                                   __asm("CPSIE   i");                                         } while ( 0 )
S
S    #define CyGlobalIntDisable          do                      \
S                                        {                       \
S                                            __asm("CPSID   i"); \
S                                        } while ( 0 )
X    #define CyGlobalIntDisable          do                                                              {                                                                   __asm("CPSID   i");                                         } while ( 0 )
S
S#else
S    #error No compiler toolchain defined
S    #define CyGlobalIntEnable
S    #define CyGlobalIntDisable
N#endif  /* (__ARMCC_VERSION) */
N
N/* System tick timer */
N#define CY_SYS_SYST_CSR_ENABLE               ((uint32) (0x01u))
N#define CY_SYS_SYST_CSR_ENABLE_INT           ((uint32) (0x02u))
N#define CY_SYS_SYST_CSR_CLK_SOURCE_SHIFT     (0x02u)
N#define CY_SYS_SYST_CSR_COUNTFLAG_SHIFT      (16u)
N#define CY_SYS_SYST_CSR_CLK_SRC_SYSCLK       ((uint32) (1u))
N#define CY_SYS_SYST_CSR_CLK_SRC_LFCLK        (0u)
N#define CY_SYS_SYST_RVR_CNT_MASK             (0x00FFFFFFu)
N#define CY_SYS_SYST_CVR_CNT_MASK             (0x00FFFFFFu)
N#define CY_SYS_SYST_NUM_OF_CALLBACKS         (5u)
N
N
N/*******************************************************************************
N* Macro Name: CyAssert
N********************************************************************************
N* Summary:
N*  Macro that evaluates the expression and, if it is false (evaluates to 0),
N*  the processor is halted.
N*
N*  This macro is evaluated unless NDEBUG is defined.
N*  If NDEBUG is defined, then no code is generated for this macro.
N*  NDEBUG is defined by default for a Release build setting and not defined for
N*  a Debug build setting.
N*
N* Parameters:
N*  expr: Logical expression.  Asserts if false.
N*
N* Return:
N*  None
N*
N*******************************************************************************/
N#if !defined(NDEBUG)
X#if !1L
S    #define CYASSERT(x)                 do                              \
S                                        {                               \
S                                            if(0u == (uint32)(x))               \
S                                            {                           \
S                                                CyHalt((uint8) 0u);     \
S                                            }                           \
S                                        } while ( 0u )
X    #define CYASSERT(x)                 do                                                                      {                                                                           if(0u == (uint32)(x))                                                           {                                                                           CyHalt((uint8) 0u);                                                 }                                                                   } while ( 0u )
N#else
N    #define CYASSERT(x)
N#endif  /* !defined(NDEBUG) */
N
N
N/*******************************************************************************
N* Interrupt API Constants
N*******************************************************************************/
N#define CY_NUM_INTERRUPTS                   (CY_IP_INT_NR)
N
N#define CY_MIN_PRIORITY                     (3u)
N
N#define CY_INT_IRQ_BASE                     (16u)
N#define CY_INT_CLEAR_DISABLE_ALL            (0xFFFFFFFFu)
N#define CY_INT_ENABLE_RANGE_MASK            (0x1Fu)
N
N/* Register n contains priorities for interrupts N=4n .. 4n+3 */
N#define CY_INT_PRIORITY_SHIFT(number)       (( uint32 )6u + (8u * (( uint32 )(number) % 4u)))
N
N/* Mask to get valid range of system priority 0-3 */
N#define CY_INT_PRIORITY_MASK                (( uint32 ) 0x03u)
N
N/* CyIntSetSysVector()/CyIntGetSysVector() - parameter definitions */
N#define CY_INT_NMI_IRQN                      ( 2u)      /* Non Maskable Interrupt      */
N#define CY_INT_HARD_FAULT_IRQN               ( 3u)      /* Hard Fault Interrupt        */
N#define CY_INT_SVCALL_IRQN                   (11u)      /* SV Call Interrupt           */
N#define CY_INT_PEND_SV_IRQN                  (14u)      /* Pend SV Interrupt           */
N#define CY_INT_SYSTICK_IRQN                  (15u)      /* System Tick Interrupt       */
N
N
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S
S
S    /*******************************************************************************
S    * Low Voltage Detection API Constants
S    *******************************************************************************/
S
S    /* CySysLvdEnable() - parameter definitions */
S    #define CY_LVD_THRESHOLD_1_75_V             (( uint32 )  0u)
S    #define CY_LVD_THRESHOLD_1_80_V             (( uint32 )  1u)
S    #define CY_LVD_THRESHOLD_1_90_V             (( uint32 )  2u)
S    #define CY_LVD_THRESHOLD_2_00_V             (( uint32 )  3u)
S    #define CY_LVD_THRESHOLD_2_10_V             (( uint32 )  4u)
S    #define CY_LVD_THRESHOLD_2_20_V             (( uint32 )  5u)
S    #define CY_LVD_THRESHOLD_2_30_V             (( uint32 )  6u)
S    #define CY_LVD_THRESHOLD_2_40_V             (( uint32 )  7u)
S    #define CY_LVD_THRESHOLD_2_50_V             (( uint32 )  8u)
S    #define CY_LVD_THRESHOLD_2_60_V             (( uint32 )  9u)
S    #define CY_LVD_THRESHOLD_2_70_V             (( uint32 ) 10u)
S    #define CY_LVD_THRESHOLD_2_80_V             (( uint32 ) 11u)
S    #define CY_LVD_THRESHOLD_2_90_V             (( uint32 ) 12u)
S    #define CY_LVD_THRESHOLD_3_00_V             (( uint32 ) 13u)
S    #define CY_LVD_THRESHOLD_3_20_V             (( uint32 ) 14u)
S    #define CY_LVD_THRESHOLD_4_50_V             (( uint32 ) 15u)
S
S    /* CySysLvdEnable()  - implementation definitions */
S    #define CY_LVD_PWR_VMON_CONFIG_LVD_EN           (( uint32 ) 0x01u)
S    #define CY_LVD_PWR_VMON_CONFIG_LVD_SEL_SHIFT    (1u)
S    #define CY_LVD_PWR_VMON_CONFIG_LVD_SEL_MASK     (( uint32 ) (0x0F << CY_LVD_PWR_VMON_CONFIG_LVD_SEL_SHIFT))
S    #define CY_LVD_PROPAGATE_INT_TO_CPU             (( uint32 ) 0x02u)
S    #define CY_LVD_STABILIZE_TIMEOUT_US             (1000u)
S
S    /* CySysLvdGetInterruptSource()/ CySysLvdClearInterrupt()  - parameter definitions  */
S    #define CY_SYS_LVD_INT                          (( uint32 ) 0x02u)
N#endif  /* (CY_IP_SRSSV2) */
N
N/* CyDelay()/CyDelayFreq()  - implementation definitions */
N#define CY_DELAY_MS_OVERFLOW                    (0x8000u)
N#define CY_DELAY_1M_THRESHOLD                   (1000000u)
N#define CY_DELAY_1M_MINUS_1_THRESHOLD           (999999u)
N#define CY_DELAY_1K_THRESHOLD                   (1000u)
N#define CY_DELAY_1K_MINUS_1_THRESHOLD           (999u)
N
N
N/*******************************************************************************
N* ECO
N*******************************************************************************/
N#if (CY_IP_ECO)
X#if (((0 != 0) || (-1 == 1) || (0 != 0) || ((1 != 0) && (1 != 0))))
N    #if (CY_IP_ECO_SRSSV2 || CY_IP_ECO_SRSSLT)
X    #if ((-1 == 1) || ((1 != 0) && (1 != 0)))
N
N        /* CySysClkEcoStart() - implementation definitions */
N        #define CY_SYS_CLK_ECO_CONFIG_CLK_EN_SHIFT          (0u)
N        #define CY_SYS_CLK_ECO_CONFIG_CLK_EN                ((uint32) ((uint32) 1u << CY_SYS_CLK_ECO_CONFIG_CLK_EN_SHIFT))
N        #define CY_SYS_CLK_ECO_CONFIG_CLK_EN_TIMEOUT_US     (10u)
N
N        #define CY_SYS_CLK_ECO_CONFIG_ENABLE_SHIFT          (31u)
N        #define CY_SYS_CLK_ECO_CONFIG_ENABLE                ((uint32) ((uint32) 1u << CY_SYS_CLK_ECO_CONFIG_ENABLE_SHIFT))
N
N        #define CY_SYS_CLK_ECO_STATUS_WATCHDOG_ERROR_SHIFT  (0u)
N        #define CY_SYS_CLK_ECO_STATUS_WATCHDOG_ERROR        ((uint32) ((uint32) 1u << CY_SYS_CLK_ECO_STATUS_WATCHDOG_ERROR_SHIFT))
N
N        #define CY_SYS_CLK_ECO_CONFIG_AGC_EN_SHIFT          (1u)
N        #define CY_SYS_CLK_ECO_CONFIG_AGC_EN                ((uint32) ((uint32) 1u << CY_SYS_CLK_ECO_CONFIG_AGC_EN_SHIFT))
N
N
N        /**
N        * \addtogroup group_api_eco
N        * @{
N        */
N        #define CY_SYS_CLK_ECO_WDTRIM0  (0u)    /**< CySysClkWriteEcoDiv(): HFCLK = ECO / 1 */
N        #define CY_SYS_CLK_ECO_WDTRIM1  (1u)
N        #define CY_SYS_CLK_ECO_WDTRIM2  (2u)
N        #define CY_SYS_CLK_ECO_WDTRIM3  (3u)
N
N        #define CY_SYS_CLK_ECO_ATRIM0   (0u)
N        #define CY_SYS_CLK_ECO_ATRIM1   (1u)
N        #define CY_SYS_CLK_ECO_ATRIM2   (2u)
N        #define CY_SYS_CLK_ECO_ATRIM3   (3u)
N        #define CY_SYS_CLK_ECO_ATRIM4   (4u)
N        #define CY_SYS_CLK_ECO_ATRIM5   (5u)
N        #define CY_SYS_CLK_ECO_ATRIM6   (6u)
N        #define CY_SYS_CLK_ECO_ATRIM7   (7u)
N
N        #define CY_SYS_CLK_ECO_FTRIM0   (0u)
N        #define CY_SYS_CLK_ECO_FTRIM1   (1u)
N        #define CY_SYS_CLK_ECO_FTRIM2   (2u)
N        #define CY_SYS_CLK_ECO_FTRIM3   (3u)
N
N        #define CY_SYS_CLK_ECO_RTRIM0   (0u)
N        #define CY_SYS_CLK_ECO_RTRIM1   (1u)
N        #define CY_SYS_CLK_ECO_RTRIM2   (2u)
N        #define CY_SYS_CLK_ECO_RTRIM3   (3u)
N
N        #define CY_SYS_CLK_ECO_GTRIM0   (0u)
N        #define CY_SYS_CLK_ECO_GTRIM1   (1u)
N        #define CY_SYS_CLK_ECO_GTRIM2   (2u)
N        #define CY_SYS_CLK_ECO_GTRIM3   (3u)
N        /** @} group_api_eco */
N
N        
N        /* CySysClkConfigureEcoTrim() - implementation definitions */
N        #define CY_SYS_CLK_ECO_TRIM0_WDTRIM_SHIFT       (0u)
N        #define CY_SYS_CLK_ECO_TRIM0_WDTRIM_MASK        ((uint32) ((uint32) 3u << CY_SYS_CLK_ECO_TRIM0_WDTRIM_SHIFT))
N
N        #define CY_SYS_CLK_ECO_TRIM0_ATRIM_SHIFT        (2u)
N        #define CY_SYS_CLK_ECO_TRIM0_ATRIM_MASK         ((uint32) ((uint32) 7u << CY_SYS_CLK_ECO_TRIM0_ATRIM_SHIFT))
N
N        #define CY_SYS_CLK_ECO_TRIM1_FTRIM_SHIFT        (0u)
N        #define CY_SYS_CLK_ECO_TRIM1_FTRIM_MASK         ((uint32) ((uint32) 3u << CY_SYS_CLK_ECO_TRIM1_FTRIM_SHIFT))
N
N        #define CY_SYS_CLK_ECO_TRIM1_RTRIM_SHIFT        (2u)
N        #define CY_SYS_CLK_ECO_TRIM1_RTRIM_MASK         ((uint32) ((uint32) 3u << CY_SYS_CLK_ECO_TRIM1_RTRIM_SHIFT))
N
N        #define CY_SYS_CLK_ECO_TRIM1_GTRIM_SHIFT        (4u)
N        #define CY_SYS_CLK_ECO_TRIM1_GTRIM_MASK         ((uint32) ((uint32) 3u << CY_SYS_CLK_ECO_TRIM1_GTRIM_SHIFT))
N
N
N        /* CySysClkConfigureEcoDrive() - implementation definitions */
N        #define CY_SYS_CLK_ECO_FREQ_KHZ_MIN     (4000u)
N        #define CY_SYS_CLK_ECO_FREQ_KHZ_MAX     (33333u)
N
N        #define CY_SYS_CLK_ECO_MAX_AMPL_MIN_mV  (500u)
N        #define CY_SYS_CLK_ECO_TRIM_BOUNDARY    (1200u)
N
N        /* Constant coefficient: 5u * 4u * CY_M_PI * CY_M_PI * 4 / 10 */
N        #define CY_SYS_CLK_ECO_GMMIN_COEFFICIENT    (79u)
N
N        #define CY_SYS_CLK_ECO_FREQ_FOR_FTRIM0  (30000u)
N        #define CY_SYS_CLK_ECO_FREQ_FOR_FTRIM1  (24000u)
N        #define CY_SYS_CLK_ECO_FREQ_FOR_FTRIM2  (17000u)
N
N        #define CY_SYS_CLK_ECO_AMPL_FOR_ATRIM0  (600u)
N        #define CY_SYS_CLK_ECO_AMPL_FOR_ATRIM1  (700u)
N        #define CY_SYS_CLK_ECO_AMPL_FOR_ATRIM2  (800u)
N        #define CY_SYS_CLK_ECO_AMPL_FOR_ATRIM3  (900u)
N        #define CY_SYS_CLK_ECO_AMPL_FOR_ATRIM4  (1025u)
N        #define CY_SYS_CLK_ECO_AMPL_FOR_ATRIM5  (1150u)
N        #define CY_SYS_CLK_ECO_AMPL_FOR_ATRIM6  (1275u)
N
N    #endif  /* (CY_IP_ECO_SRSSV2 || CY_IP_ECO_SRSSLT) */
N#endif /* (CY_IP_ECO) */
N
N
N/*******************************************************************************
N* Access Arbitration API Constants
N*******************************************************************************/
N#if (CY_IP_DMAC_PRESENT)
X#if ((1 == 1))
N    #define CY_SYS_CPUSS_RAM_CTL_ARB_SHIFT          (17u)
N    #define CY_SYS_CPUSS_RAM_CTL_ARB_MASK           ((uint32) ((uint32) 3u << CY_SYS_CPUSS_RAM_CTL_ARB_SHIFT))
N
N    #define CY_SYS_CPUSS_FLASH_CTL_ARB_SHIFT        (17u)
N    #define CY_SYS_CPUSS_FLASH_CTL_ARB_MASK         ((uint32) ((uint32) 3u << CY_SYS_CPUSS_FLASH_CTL_ARB_SHIFT))
N
N    #define CY_SYS_CPUSS_DMAC_CTL_ARB_SHIFT         (17u)
N    #define CY_SYS_CPUSS_DMAC_CTL_ARB_MASK          ((uint32) ((uint32) 3u << CY_SYS_CPUSS_DMAC_CTL_ARB_SHIFT))
N
N    #define CY_SYS_CPUSS_SL_CTL_ARB_SHIFT           (17u)
N    #define CY_SYS_CPUSS_SL_CTL_ARB_MASK            ((uint32) ((uint32) 3u << CY_SYS_CPUSS_SL_CTL_ARB_SHIFT))
N
N#endif /* (CY_IP_DMAC_PRESENT) */
N
N
N#if (CY_IP_DMAC_PRESENT)
X#if ((1 == 1))
N    #define CY_SYS_RAM_ACCESS_ARB_PRIORITY_CPU              (0u)
N    #define CY_SYS_RAM_ACCESS_ARB_PRIORITY_DMA              (1u)
N    #define CY_SYS_RAM_ACCESS_ARB_PRIORITY_ROUND            (2u)
N    #define CY_SYS_RAM_ACCESS_ARB_PRIORITY_ROUND_STICKY     (3u)
N#endif /* (CY_IP_DMAC_PRESENT) */
N
N
N/*******************************************************************************
N* Programmable Voltage Reference API
N*******************************************************************************/
N#if (CY_IP_PASS)
X#if ((0 == 1))
S
S    #define CYFLD_PASS_VREF_ENABLE__OFFSET     (CYFLD_PASS_VREF0_ENABLE__OFFSET )
S    #define CYFLD_PASS_VREF_ENABLE__SIZE       (CYFLD_PASS_VREF0_ENABLE__SIZE   )
S    #define CYFLD_PASS_VREF_SUP_SEL__OFFSET    (CYFLD_PASS_VREF0_SUP_SEL__OFFSET)
S    #define CYFLD_PASS_VREF_SUP_SEL__SIZE      (CYFLD_PASS_VREF0_SUP_SEL__SIZE  )
S    #define CYFLD_PASS_VREF_SEL__OFFSET        (CYFLD_PASS_VREF0_SEL__OFFSET    )
S    #define CYFLD_PASS_VREF_SEL__SIZE          (CYFLD_PASS_VREF0_SEL__SIZE      )
S
S    /* CySysSetGlobalVrefSource() */
S    #define CY_SYS_VREF_SOURCE_BG           (0u)
S    #define CY_SYS_VREF_SOURCE_VDDA         (1u)
S
S    /* CySysSetGlobalVrefBgGain() */
S    #define CY_SYS_VREF_BG_GAINx1           (1u)
S    #define CY_SYS_VREF_BG_GAINx2           (2u)
S
S    #ifdef CyDesignWideVoltageReference_PRB_REF
S        #define CYREG_PASS_PRB_REF          (CyDesignWideVoltageReference_PRB_REF)
S    #endif
S
S    #define  CY_SYS_VREF_BG_BUFFER_TRIM_SIGN_BIT    (0x20u)
S
N#endif /* (CY_IP_PASS) */
N
N
N/***************************************
N* Registers
N***************************************/
N
N
N/*******************************************************************************
N* Clocks API Registers
N*******************************************************************************/
N#define CY_SYS_CLK_IMO_TRIM1_REG            (*(reg32 *) CYREG_CLK_IMO_TRIM1)
N#define CY_SYS_CLK_IMO_TRIM1_PTR            ( (reg32 *) CYREG_CLK_IMO_TRIM1)
N
N#define CY_SYS_CLK_IMO_TRIM2_REG            (*(reg32 *) CYREG_CLK_IMO_TRIM2)
N#define CY_SYS_CLK_IMO_TRIM2_PTR            ( (reg32 *) CYREG_CLK_IMO_TRIM2)
N
N#define CY_SYS_CLK_IMO_TRIM3_REG            (*(reg32 *) CYREG_CLK_IMO_TRIM3)
N#define CY_SYS_CLK_IMO_TRIM3_PTR            ( (reg32 *) CYREG_CLK_IMO_TRIM3)
N
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S    #define CY_SYS_CLK_IMO_TRIM4_REG            (*(reg32 *) CYREG_CLK_IMO_TRIM4)
S    #define CY_SYS_CLK_IMO_TRIM4_PTR            ( (reg32 *) CYREG_CLK_IMO_TRIM4)
N#endif /* (CY_IP_SRSSV2) */
N
N#define CY_SYS_CLK_IMO_CONFIG_REG           (*(reg32 *) CYREG_CLK_IMO_CONFIG)
N#define CY_SYS_CLK_IMO_CONFIG_PTR           ( (reg32 *) CYREG_CLK_IMO_CONFIG)
N
N
N#define CY_SYS_CLK_SELECT_REG               (*(reg32 *) CYREG_CLK_SELECT)
N#define CY_SYS_CLK_SELECT_PTR               ( (reg32 *) CYREG_CLK_SELECT)
N
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S
S    #if(CY_IP_HOBTO_DEVICE)
S        #define CY_SFLASH_IMO_TRIM_REG(number)      ( ((reg8 *) CYREG_SFLASH_IMO_TRIM0)[number])
S        #define CY_SFLASH_IMO_TRIM_PTR(number)      (&((reg8 *) CYREG_SFLASH_IMO_TRIM0)[number])
S    #else
S        #define CY_SFLASH_IMO_TRIM_REG(number)      ( ((reg8 *) CYREG_SFLASH_IMO_TRIM00)[number])
S        #define CY_SFLASH_IMO_TRIM_PTR(number)      (&((reg8 *) CYREG_SFLASH_IMO_TRIM00)[number])
S    #endif /* (CY_IP_HOBTO_DEVICE) */
S
S    #define CY_SFLASH_USBMODE_IMO_GAIN_TRIM_REG     (*(reg8 *) CYREG_SFLASH_USBMODE_IMO_GAIN_TRIM)
S    #define CY_SFLASH_USBMODE_IMO_GAIN_TRIM_PTR     ( (reg8 *) CYREG_SFLASH_USBMODE_IMO_GAIN_TRIM)
S    
S    #define CY_SFLASH_USBMODE_IMO_TEMPCO_REG        (*(reg8 *) CYREG_SFLASH_USBMODE_IMO_TEMPCO)
S    #define CY_SFLASH_USBMODE_IMO_TEMPCO_PTR        ( (reg8 *) CYREG_SFLASH_USBMODE_IMO_TEMPCO)
S    
S    #define CY_SFLASH_CU_IMO_TRIM_USBMODE_24_REG    (*(reg8 *) CYREG_SFLASH_CU_IMO_TRIM_USBMODE_24)
S    #define CY_SFLASH_CU_IMO_TRIM_USBMODE_24_PTR    ( (reg8 *) CYREG_SFLASH_CU_IMO_TRIM_USBMODE_24)
S
S    #define CY_SFLASH_CU_IMO_TRIM_USBMODE_48_REG    (*(reg8 *) CYREG_SFLASH_CU_IMO_TRIM_USBMODE_48)
S    #define CY_SFLASH_CU_IMO_TRIM_USBMODE_48_PTR    ( (reg8 *) CYREG_SFLASH_CU_IMO_TRIM_USBMODE_48)
S    
S    #define CY_SFLASH_S1_TESTPGM_REV_REG        (*(reg8 *) CYSFLASH_S1_testpgm_rev)
S    #define CY_SFLASH_S1_TESTPGM_REV_PTR        ( (reg8 *) CYSFLASH_S1_testpgm_rev)
S
S    #define CY_SFLASH_IMO_MAXF0_REG             (*(reg8 *) CYREG_SFLASH_IMO_MAXF0)
S    #define CY_SFLASH_IMO_MAXF0_PTR             ( (reg8 *) CYREG_SFLASH_IMO_MAXF0)
S
S    #define CY_SFLASH_IMO_ABS0_REG              (*(reg8 *) CYREG_SFLASH_IMO_ABS0)
S    #define CY_SFLASH_IMO_ABS0_PTR              ( (reg8 *) CYREG_SFLASH_IMO_ABS0)
S
S    #define CY_SFLASH_IMO_TMPCO0_REG            (*(reg8 *) CYREG_SFLASH_IMO_TMPCO0)
S    #define CY_SFLASH_IMO_TMPCO0_PTR            ( (reg8 *) CYREG_SFLASH_IMO_TMPCO0)
S
S    #define CY_SFLASH_IMO_MAXF1_REG             (*(reg8 *) CYREG_SFLASH_IMO_MAXF1)
S    #define CY_SFLASH_IMO_MAXF1_PTR             ( (reg8 *) CYREG_SFLASH_IMO_MAXF1)
S
S    #define CY_SFLASH_IMO_ABS1_REG              (*(reg8 *) CYREG_SFLASH_IMO_ABS1)
S    #define CY_SFLASH_IMO_ABS1_PTR              ( (reg8 *) CYREG_SFLASH_IMO_ABS1)
S
S    #define CY_SFLASH_IMO_TMPCO1_REG            (*(reg8 *) CYREG_SFLASH_IMO_TMPCO1)
S    #define CY_SFLASH_IMO_TMPCO1_PTR            ( (reg8 *) CYREG_SFLASH_IMO_TMPCO1)
S
S    #define CY_SFLASH_IMO_MAXF2_REG             (*(reg8 *) CYREG_SFLASH_IMO_MAXF2)
S    #define CY_SFLASH_IMO_MAXF2_PTR             ( (reg8 *) CYREG_SFLASH_IMO_MAXF2)
S
S    #define CY_SFLASH_IMO_ABS2_REG              (*(reg8 *) CYREG_SFLASH_IMO_ABS2)
S    #define CY_SFLASH_IMO_ABS2_PTR              ( (reg8 *) CYREG_SFLASH_IMO_ABS2)
S
S    #define CY_SFLASH_IMO_TMPCO2_REG            (*(reg8 *) CYREG_SFLASH_IMO_TMPCO2)
S    #define CY_SFLASH_IMO_TMPCO2_PTR            ( (reg8 *) CYREG_SFLASH_IMO_TMPCO2)
S
S    #define CY_SFLASH_IMO_MAXF3_REG             (*(reg8 *) CYREG_SFLASH_IMO_MAXF3)
S    #define CY_SFLASH_IMO_MAXF3_PTR             ( (reg8 *) CYREG_SFLASH_IMO_MAXF3)
S
S    #define CY_SFLASH_IMO_ABS3_REG              (*(reg8 *) CYREG_SFLASH_IMO_ABS3)
S    #define CY_SFLASH_IMO_ABS3_PTR              ( (reg8 *) CYREG_SFLASH_IMO_ABS3)
S
S    #define CY_SFLASH_IMO_TMPCO3_REG            (*(reg8 *) CYREG_SFLASH_IMO_TMPCO3)
S    #define CY_SFLASH_IMO_TMPCO3_PTR            ( (reg8 *) CYREG_SFLASH_IMO_TMPCO3)
S
S    #define CY_SFLASH_IMO_ABS4_REG              (*(reg8 *) CYREG_SFLASH_IMO_ABS4)
S    #define CY_SFLASH_IMO_ABS4_PTR              ( (reg8 *) CYREG_SFLASH_IMO_ABS4)
S
S    #define CY_SFLASH_IMO_TMPCO4_REG            (*(reg8 *) CYREG_SFLASH_IMO_TMPCO4)
S    #define CY_SFLASH_IMO_TMPCO4_PTR            ( (reg8 *) CYREG_SFLASH_IMO_TMPCO4)
S
S    #define CY_PWR_BG_TRIM4_REG                 (*(reg32 *) CYREG_PWR_BG_TRIM4)
S    #define CY_PWR_BG_TRIM4_PTR                 ( (reg32 *) CYREG_PWR_BG_TRIM4)
S
S    #define CY_PWR_BG_TRIM5_REG                 (*(reg32 *) CYREG_PWR_BG_TRIM5)
S    #define CY_PWR_BG_TRIM5_PTR                 ( (reg32 *) CYREG_PWR_BG_TRIM5)
S
S    #if (CY_IP_IMO_TRIMMABLE_BY_USB)
S
S        #define CY_SFLASH_IMO_TRIM_USBMODE_24_REG   (*(reg8 *) CYREG_SFLASH_IMO_TRIM_USBMODE_24)
S        #define CY_SFLASH_IMO_TRIM_USBMODE_24_PTR   ( (reg8 *) CYREG_SFLASH_IMO_TRIM_USBMODE_24)
S
S        #define CY_SFLASH_IMO_TRIM_USBMODE_48_REG   (*(reg8 *) CYREG_SFLASH_IMO_TRIM_USBMODE_48)
S        #define CY_SFLASH_IMO_TRIM_USBMODE_48_PTR   ( (reg8 *) CYREG_SFLASH_IMO_TRIM_USBMODE_48)
S
S    #endif  /* (CY_IP_IMO_TRIMMABLE_BY_USB) */
S
N#else
N
N    #define CY_SYS_CLK_IMO_SELECT_REG           (*(reg32 *) CYREG_CLK_IMO_SELECT)
N    #define CY_SYS_CLK_IMO_SELECT_PTR           ( (reg32 *) CYREG_CLK_IMO_SELECT)
N
N    #define CY_SFLASH_IMO_TCTRIM_REG(number)    ( ((reg8 *) CYREG_SFLASH_IMO_TCTRIM_LT0)[number])
N    #define CY_SFLASH_IMO_TCTRIM_PTR(number)    (&((reg8 *) CYREG_SFLASH_IMO_TCTRIM_LT0)[number])
N
N    #define CY_SFLASH_IMO_TRIM_REG(number)      ( ((reg8 *) CYREG_SFLASH_IMO_TRIM_LT0)[number])
N    #define CY_SFLASH_IMO_TRIM_PTR(number)      (&((reg8 *) CYREG_SFLASH_IMO_TRIM_LT0)[number])
N
N    #if (CY_IP_IMO_TRIMMABLE_BY_USB && CY_IP_SRSSLT)
X    #if ((0 != 0) && (!(0 != 0)))
S
S        #define CY_SFLASH_IMO_TRIM_USBMODE_24_REG   (*(reg8 *) CYREG_SFLASH_IMO_TRIM_USBMODE_24)
S        #define CY_SFLASH_IMO_TRIM_USBMODE_24_PTR   ( (reg8 *) CYREG_SFLASH_IMO_TRIM_USBMODE_24)
S
S        #define CY_SFLASH_IMO_TRIM_USBMODE_48_REG   (*(reg8 *) CYREG_SFLASH_IMO_TRIM_USBMODE_48)
S        #define CY_SFLASH_IMO_TRIM_USBMODE_48_PTR   ( (reg8 *) CYREG_SFLASH_IMO_TRIM_USBMODE_48)
S        
N    #endif  /* (CY_IP_IMO_TRIMMABLE_BY_USB && CY_IP_SRSSLT) */
N
N#endif  /* (CY_IP_SRSSV2) */
N
N#if(CY_IP_IMO_TRIMMABLE_BY_USB)
X#if((0 != 0))
S    /* USB control 0 Register */
S    #define CY_SYS_CLK_USBDEVv2_CR1_REG           (*(reg32 *) CYREG_USBDEVv2_CR1)
S    #define CY_SYS_CLK_USBDEVv2_CR1_PTR           ( (reg32 *) CYREG_USBDEVv2_CR1)
N#endif /* (CY_IP_IMO_TRIMMABLE_BY_USB) */
N
N
N/*******************************************************************************
N* ECO
N*******************************************************************************/
N#if (CY_IP_ECO)
X#if (((0 != 0) || (-1 == 1) || (0 != 0) || ((1 != 0) && (1 != 0))))
N    #if (CY_IP_ECO_BLESS)
X    #if ((0 != 0))
S
S        /* Radio configuration register */
S        #define CY_SYS_XTAL_BLESS_RF_CONFIG_REG         (*(reg32 *) CYREG_BLE_BLESS_RF_CONFIG)
S        #define CY_SYS_XTAL_BLESS_RF_CONFIG_PTR         ( (reg32 *) CYREG_BLE_BLESS_RF_CONFIG)
S
S        /* RFCTRL mode transition control */
S        #define CY_SYS_XTAL_BLERD_DBUS_REG              (*(reg32 *) CYREG_BLE_BLERD_DBUS)
S        #define CY_SYS_XTAL_BLERD_DBUS_PTR              ( (reg32 *) CYREG_BLE_BLERD_DBUS)
S
S        /* RFCTRL state information */
S        #define CY_SYS_XTAL_BLERD_FSM_REG              (*(reg32 *) CYREG_BLE_BLERD_FSM)
S        #define CY_SYS_XTAL_BLERD_FSM_PTR              ( (reg32 *) CYREG_BLE_BLERD_FSM)
S
S        /* BB bump configuration 1 */
S        #define CY_SYS_XTAL_BLERD_BB_XO_REG             (*(reg32 *) CYREG_BLE_BLERD_BB_XO)
S        #define CY_SYS_XTAL_BLERD_BB_XO_PTR             ( (reg32 *) CYREG_BLE_BLERD_BB_XO)
S
S        /* BB bump configuration 2 */
S        #define CY_SYS_XTAL_BLERD_BB_XO_CAPTRIM_REG     (*(reg32 *) CYREG_BLE_BLERD_BB_XO_CAPTRIM)
S        #define CY_SYS_XTAL_BLERD_BB_XO_CAPTRIM_PTR     ( (reg32 *) CYREG_BLE_BLERD_BB_XO_CAPTRIM)
S
S        /* Crystal clock divider configuration register */
S        #define CY_SYS_CLK_XTAL_CLK_DIV_CONFIG_REG      (*(reg32 *) CYREG_BLE_BLESS_XTAL_CLK_DIV_CONFIG)
S        #define CY_SYS_CLK_XTAL_CLK_DIV_CONFIG_PTR      ( (reg32 *) CYREG_BLE_BLESS_XTAL_CLK_DIV_CONFIG)
S
S    #elif (CY_IP_ECO_BLESSV3)
X    #elif ((0 != 0))
S        /* Crystal clock divider configuration register */
S        #define CY_SYS_CLK_XTAL_CLK_DIV_CONFIG_REG      (*(reg32 *) CYREG_BLE_BLESS_XTAL_CLK_DIV_CONFIG)
S        #define CY_SYS_CLK_XTAL_CLK_DIV_CONFIG_PTR      ( (reg32 *) CYREG_BLE_BLESS_XTAL_CLK_DIV_CONFIG)
S        
S        /* RCB registers */
S        #define CY_SYS_RCB_CTRL_REG                     (*(reg32 *) CYREG_BLE_RCB_CTRL)
S        #define CY_SYS_RCB_CTRL_PTR                     ( (reg32 *) CYREG_BLE_RCB_CTRL)
S        #define CY_SYS_RCB_TX_FIFO_WR_REG               (*(reg32 *) CYREG_BLE_RCB_TX_FIFO_WR)
S        #define CY_SYS_RCB_TX_FIFO_WR_PTR               ( (reg32 *) CYREG_BLE_RCB_TX_FIFO_WR)
S        #define CY_SYS_RCB_RX_FIFO_RD_REG               (*(reg32 *) CYREG_BLE_RCB_RX_FIFO_RD)
S        #define CY_SYS_RCB_RX_FIFO_RD_PTR               ( (reg32 *) CYREG_BLE_RCB_RX_FIFO_RD)
S        #define CY_SYS_RCB_INTR_REG                     (*(reg32 *) CYREG_BLE_RCB_INTR)
S        #define CY_SYS_RCB_INTR_PTR                     ( (reg32 *) CYREG_BLE_RCB_INTR)
S        #define CY_SYS_RCB_INTR_MASK_REG                (*(reg32 *) CYREG_BLE_RCB_INTR_MASK)
S        #define CY_SYS_RCB_INTR_MASK_PTR                ( (reg32 *) CYREG_BLE_RCB_INTR_MASK)
S        
S                                                            
S        /* BLESS registers */
S        #define CY_SYS_BLESS_MT_CFG_REG                 (*(reg32 *) CYREG_BLE_BLESS_MT_CFG)
S        #define CY_SYS_BLESS_MT_CFG_PTR                 ( (reg32 *) CYREG_BLE_BLESS_MT_CFG)
S        #define CY_SYS_BLESS_MT_STATUS_REG              (*(reg32 *) CYREG_BLE_BLESS_MT_STATUS)
S        #define CY_SYS_BLESS_MT_STATUS_PTR              ( (reg32 *) CYREG_BLE_BLESS_MT_STATUS)
S        #define CY_SYS_BLESS_INTR_STAT_REG              (*(reg32 *) CYREG_BLE_BLESS_INTR_STAT)
S        #define CY_SYS_BLESS_INTR_STAT_PTR              ( (reg32 *) CYREG_BLE_BLESS_INTR_STAT)
S        #define CY_SYS_BLESS_INTR_MASK_REG              (*(reg32 *) CYREG_BLE_BLESS_INTR_MASK)
S        #define CY_SYS_BLESS_INTR_MASK_PTR              ( (reg32 *) CYREG_BLE_BLESS_INTR_MASK)
S        #define CY_SYS_BLESS_MT_DELAY_CFG_REG           (*(reg32 *) CYREG_BLE_BLESS_MT_DELAY_CFG)
S        #define CY_SYS_BLESS_MT_DELAY_CFG_PTR           ( (reg32 *) CYREG_BLE_BLESS_MT_DELAY_CFG)
S        #define CY_SYS_BLESS_MT_DELAY_CFG2_REG          (*(reg32 *) CYREG_BLE_BLESS_MT_DELAY_CFG2)
S        #define CY_SYS_BLESS_MT_DELAY_CFG2_PTR          ( (reg32 *) CYREG_BLE_BLESS_MT_DELAY_CFG2)
S        #define CY_SYS_BLESS_MT_DELAY_CFG3_REG          (*(reg32 *) CYREG_BLE_BLESS_MT_DELAY_CFG3)
S        #define CY_SYS_BLESS_MT_DELAY_CFG3_PTR          ( (reg32 *) CYREG_BLE_BLESS_MT_DELAY_CFG3)
S        
S        /* BLELL registers */
S        #define CY_SYS_BLELL_COMMAND_REG                (*(reg32 *) CYREG_BLE_BLELL_COMMAND_REGISTER)
S        #define CY_SYS_BLELL_COMMAND_PTR                ( (reg32 *) CYREG_BLE_BLELL_COMMAND_REGISTER)        
S
N    #elif (CY_IP_ECO_SRSSLT)
X    #elif (((1 != 0) && (1 != 0)))
N
N        /* ECO Clock Select Register */
N        #define CY_SYS_ECO_CLK_SELECT_REG       (*(reg32 *) CYREG_EXCO_CLK_SELECT)
N        #define CY_SYS_ECO_CLK_SELECT_PTR       ( (reg32 *) CYREG_EXCO_CLK_SELECT)
N        
N        /* ECO Configuration Register */
N        #define CY_SYS_CLK_ECO_CONFIG_REG       (*(reg32 *) CYREG_EXCO_ECO_CONFIG)
N        #define CY_SYS_CLK_ECO_CONFIG_PTR       ( (reg32 *) CYREG_EXCO_ECO_CONFIG)
N
N        /* ECO Status Register */
N        #define CY_SYS_CLK_ECO_STATUS_REG       (*(reg32 *) CYREG_EXCO_ECO_STATUS)
N        #define CY_SYS_CLK_ECO_STATUS_PTR       ( (reg32 *) CYREG_EXCO_ECO_STATUS)
N
N        /* PLL Configuration Register */
N        #define CY_SYS_CLK_PLL0_CONFIG_REG      (*(reg32 *) CYREG_EXCO_PLL_CONFIG)
N        #define CY_SYS_CLK_PLL0_CONFIG_PTR      ( (reg32 *) CYREG_EXCO_PLL_CONFIG)
N        
N        /* PLL Status Register */
N        #define CY_SYS_CLK_PLL_STATUS_REG       (*(reg32 *) CYREG_EXCO_PLL_STATUS)
N        #define CY_SYS_CLK_PLL_STATUS_PTR       ( (reg32 *) CYREG_EXCO_PLL_STATUS)
N
N        #define CY_SYS_CLK_PLL_BASE             (*(volatile cy_sys_clk_pll_struct *) CYREG_EXCO_PLL_CONFIG)        
N        
N        /* ECO Trim0 Register */
N        #define CY_SYS_CLK_ECO_TRIM0_REG        (*(reg32 *) CYREG_EXCO_ECO_TRIM0)
N        #define CY_SYS_CLK_ECO_TRIM0_PTR        ( (reg32 *) CYREG_EXCO_ECO_TRIM0)
N
N        /* ECO Trim1 Register */
N        #define CY_SYS_CLK_ECO_TRIM1_REG        (*(reg32 *) CYREG_EXCO_ECO_TRIM1)
N        #define CY_SYS_CLK_ECO_TRIM1_PTR        ( (reg32 *) CYREG_EXCO_ECO_TRIM1)
N        
N        /* PLL Trim Register */
N        #define CY_SYS_CLK_PLL_TRIM_REG         (*(reg32 *) CYREG_EXCO_PLL_TRIM)
N        #define CY_SYS_CLK_PLL_TRIM_PTR         ( (reg32 *) CYREG_EXCO_PLL_TRIM)
N        
N        #define CY_SYS_EXCO_PGM_CLK_REG         (*(reg32 *) CYREG_EXCO_EXCO_PGM_CLK) 
N        #define CY_SYS_EXCO_PGM_CLK_PTR         ( (reg32 *) CYREG_EXCO_EXCO_PGM_CLK)
N        
N    #else
S        /* ECO Configuration Register */
S        #define CY_SYS_CLK_ECO_CONFIG_REG        (*(reg32 *) CYREG_CLK_ECO_CONFIG)
S        #define CY_SYS_CLK_ECO_CONFIG_PTR        ( (reg32 *) CYREG_CLK_ECO_CONFIG)
S
S        /* ECO Status Register */
S        #define CY_SYS_CLK_ECO_STATUS_REG        (*(reg32 *) CYREG_CLK_ECO_STATUS)
S        #define CY_SYS_CLK_ECO_STATUS_PTR        ( (reg32 *) CYREG_CLK_ECO_STATUS)
S
S        /* ECO Trim0 Register */
S        #define CY_SYS_CLK_ECO_TRIM0_REG         (*(reg32 *) CYREG_CLK_ECO_TRIM0)
S        #define CY_SYS_CLK_ECO_TRIM0_PTR         ( (reg32 *) CYREG_CLK_ECO_TRIM0)
S
S        /* ECO Trim1 Register */
S        #define CY_SYS_CLK_ECO_TRIM1_REG         (*(reg32 *) CYREG_CLK_ECO_TRIM1)
S        #define CY_SYS_CLK_ECO_TRIM1_PTR         ( (reg32 *) CYREG_CLK_ECO_TRIM1)
N    #endif  /* (CY_IP_ECO_BLESS) */
N#endif /* (CY_IP_ECO) */
N
N
N/* CySysClkImoEnableWcoLock() / CySysClkImoDisableWcoLock() registers */
N#if (CY_IP_IMO_TRIMMABLE_BY_WCO)
X#if ((0 == 0))
N    /* WCO DPLL Register */
N    #define CY_SYS_CLK_WCO_DPLL_REG                 (*(reg32 *) CYREG_WCO_DPLL)
N    #define CY_SYS_CLK_WCO_DPLL_PTR                 ( (reg32 *) CYREG_WCO_DPLL)
N#endif /* (CY_IP_IMO_TRIMMABLE_BY_WCO) */
N
N
N#if (CY_IP_IMO_TRIMMABLE_BY_WCO && CY_IP_IMO_TRIMMABLE_BY_USB)
X#if ((0 == 0) && (0 != 0))
S    /* Oscillator Interface Control */
S    #define CY_SYS_CLK_OSCINTF_CTL_REG              (*(reg32 *) CYREG_CLK_OSCINTF_CTL)
S    #define CY_SYS_CLK_OSCINTF_CTL_PTR              ( (reg32 *) CYREG_CLK_OSCINTF_CTL)
N#endif /* (CY_IP_IMO_TRIMMABLE_BY_WCO && CY_IP_IMO_TRIMMABLE_BY_USB) */
N
N
N/*******************************************************************************
N* PLL
N*******************************************************************************/
N#if (CY_IP_SRSSV2 && CY_IP_PLL)
X#if ((0 != 0) && (1 == 1))
S
S    /* PLL #0 Configuration Register */
S    #define CY_SYS_CLK_PLL0_CONFIG_REG      (*(reg32 *) CYREG_CLK_PLL0_CONFIG)
S    #define CY_SYS_CLK_PLL0_CONFIG_PTR      ( (reg32 *) CYREG_CLK_PLL0_CONFIG)
S
S    /* PLL #0 Status Register */
S    #define CY_SYS_CLK_PLL0_STATUS_REG      (*(reg32 *) CYREG_CLK_PLL0_STATUS)
S    #define CY_SYS_CLK_PLL0_STATUS_PTR      ( (reg32 *) CYREG_CLK_PLL0_STATUS)
S
S
S    /* PLL #1 Configuration Register */
S    #define CY_SYS_CLK_PLL1_CONFIG_REG      (*(reg32 *) CYREG_CLK_PLL1_CONFIG)
S    #define CY_SYS_CLK_PLL1_CONFIG_PTR      ( (reg32 *) CYREG_CLK_PLL1_CONFIG)
S
S    /* PLL #1 Status Register */
S    #define CY_SYS_CLK_PLL1_STATUS_REG      (*(reg32 *) CYREG_CLK_PLL1_STATUS)
S    #define CY_SYS_CLK_PLL1_STATUS_PTR      ( (reg32 *) CYREG_CLK_PLL1_STATUS)
S
S    #define CY_SYS_CLK_PLL_BASE     (*(volatile cy_sys_clk_pll_struct *) CYREG_CLK_PLL0_CONFIG)
S
N#endif /* (CY_IP_SRSSV2 && CY_IP_PLL) */
N
N
N/*******************************************************************************
N* System API Registers
N*******************************************************************************/
N#if (CY_IP_CPUSS_CM0)
X#if ((0 == 1))
S    #define CY_SYS_AIRCR_REG                (*(reg32 *) CYREG_CM0_AIRCR)
S    #define CY_SYS_AIRCR_PTR                ( (reg32 *) CYREG_CM0_AIRCR)
N#else /* CY_IP_CPUSS_CM0PLUS */
N    #define CY_SYS_AIRCR_REG                (*(reg32 *) CYREG_CM0P_AIRCR)
N    #define CY_SYS_AIRCR_PTR                ( (reg32 *) CYREG_CM0P_AIRCR)
N#endif /* (CY_IP_CPUSS_CM0) */
N
N/* Reset Cause Observation Register */
N#define CY_SYS_RES_CAUSE_REG                (*(reg32 *) CYREG_RES_CAUSE)
N#define CY_SYS_RES_CAUSE_PTR                ( (reg32 *) CYREG_RES_CAUSE)
N
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S
S    /*******************************************************************************
S    * Low Voltage Detection
S    *******************************************************************************/
S
S    /* Voltage Monitoring Trim and Configuration */
S    #define CY_LVD_PWR_VMON_CONFIG_REG          (*(reg32 *) CYREG_PWR_VMON_CONFIG)
S    #define CY_LVD_PWR_VMON_CONFIG_PTR          ( (reg32 *) CYREG_PWR_VMON_CONFIG)
S
S    /* Power System Interrupt Mask Register */
S    #define CY_LVD_PWR_INTR_MASK_REG            (*(reg32 *) CYREG_PWR_INTR_MASK)
S    #define CY_LVD_PWR_INTR_MASK_PTR            ( (reg32 *) CYREG_PWR_INTR_MASK)
S
S    /* Power System Interrupt Register */
S    #define CY_LVD_PWR_INTR_REG                 (*(reg32 *) CYREG_PWR_INTR)
S    #define CY_LVD_PWR_INTR_PTR                 ( (reg32 *) CYREG_PWR_INTR)
S
N#endif  /* (CY_IP_SRSSV2) */
N
N
N/*******************************************************************************
N* Interrupt API Registers
N*******************************************************************************/
N#define CY_INT_VECT_TABLE                   ( (cyisraddress **) CYDEV_SRAM_BASE)
N
N#if (CY_IP_CPUSS_CM0)
X#if ((0 == 1))
S    #define CY_INT_PRIORITY_REG(number)         ( ((reg32 *) CYREG_CM0_IPR0)[(number)/4u])
S    #define CY_INT_PRIORITY_PTR(number)         (&((reg32 *) CYREG_CM0_IPR0)[(number)/4u])
S
S    #define CY_INT_ENABLE_REG                   (*(reg32 *) CYREG_CM0_ISER)
S    #define CY_INT_ENABLE_PTR                   ( (reg32 *) CYREG_CM0_ISER)
S
S    #define CY_INT_CLEAR_REG                    (*(reg32 *) CYREG_CM0_ICER)
S    #define CY_INT_CLEAR_PTR                    ( (reg32 *) CYREG_CM0_ICER)
S
S    #define CY_INT_SET_PEND_REG                 (*(reg32 *) CYREG_CM0_ISPR)
S    #define CY_INT_SET_PEND_PTR                 ( (reg32 *) CYREG_CM0_ISPR)
S
S    #define CY_INT_CLR_PEND_REG                 (*(reg32 *) CYREG_CM0_ICPR)
S    #define CY_INT_CLR_PEND_PTR                 ( (reg32 *) CYREG_CM0_ICPR)
N#else /* CY_IP_CPUSS_CM0PLUS */
N    #define CY_INT_PRIORITY_REG(number)         ( ((reg32 *) CYREG_CM0P_IPR0)[(number)/4u])
N    #define CY_INT_PRIORITY_PTR(number)         (&((reg32 *) CYREG_CM0P_IPR0)[(number)/4u])
N
N    #define CY_INT_ENABLE_REG                   (*(reg32 *) CYREG_CM0P_ISER)
N    #define CY_INT_ENABLE_PTR                   ( (reg32 *) CYREG_CM0P_ISER)
N
N    #define CY_INT_CLEAR_REG                    (*(reg32 *) CYREG_CM0P_ICER)
N    #define CY_INT_CLEAR_PTR                    ( (reg32 *) CYREG_CM0P_ICER)
N
N    #define CY_INT_SET_PEND_REG                 (*(reg32 *) CYREG_CM0P_ISPR)
N    #define CY_INT_SET_PEND_PTR                 ( (reg32 *) CYREG_CM0P_ISPR)
N
N    #define CY_INT_CLR_PEND_REG                 (*(reg32 *) CYREG_CM0P_ICPR)
N    #define CY_INT_CLR_PEND_PTR                 ( (reg32 *) CYREG_CM0P_ICPR)
N#endif /* (CY_IP_CPUSS_CM0) */
N
N/*******************************************************************************
N* System tick API Registers
N*******************************************************************************/
N#if (CY_IP_CPUSS_CM0)
X#if ((0 == 1))
S    #define CY_SYS_SYST_CSR_REG                 (*(reg32 *) CYREG_CM0_SYST_CSR)
S    #define CY_SYS_SYST_CSR_PTR                 ( (reg32 *) CYREG_CM0_SYST_CSR)
S
S    #define CY_SYS_SYST_RVR_REG                 (*(reg32 *) CYREG_CM0_SYST_RVR)
S    #define CY_SYS_SYST_RVR_PTR                 ( (reg32 *) CYREG_CM0_SYST_RVR)
S
S    #define CY_SYS_SYST_CVR_REG                 (*(reg32 *) CYREG_CM0_SYST_CVR)
S    #define CY_SYS_SYST_CVR_PTR                 ( (reg32 *) CYREG_CM0_SYST_CVR)
S
S    #define CY_SYS_SYST_CALIB_REG               (*(reg32 *) CYREG_CM0_SYST_CALIB)
S    #define CY_SYS_SYST_CALIB_PTR               ( (reg32 *) CYREG_CM0_SYST_CALIB)
N#else /* CY_IP_CPUSS_CM0PLUS */
N    #define CY_SYS_SYST_CSR_REG                 (*(reg32 *) CYREG_CM0P_SYST_CSR)
N    #define CY_SYS_SYST_CSR_PTR                 ( (reg32 *) CYREG_CM0P_SYST_CSR)
N
N    #define CY_SYS_SYST_RVR_REG                 (*(reg32 *) CYREG_CM0P_SYST_RVR)
N    #define CY_SYS_SYST_RVR_PTR                 ( (reg32 *) CYREG_CM0P_SYST_RVR)
N
N    #define CY_SYS_SYST_CVR_REG                 (*(reg32 *) CYREG_CM0P_SYST_CVR)
N    #define CY_SYS_SYST_CVR_PTR                 ( (reg32 *) CYREG_CM0P_SYST_CVR)
N
N    #define CY_SYS_SYST_CALIB_REG               (*(reg32 *) CYREG_CM0P_SYST_CALIB)
N    #define CY_SYS_SYST_CALIB_PTR               ( (reg32 *) CYREG_CM0P_SYST_CALIB)
N#endif /* (CY_IP_CPUSS_CM0) */
N
N
N/*******************************************************************************
N* Access Arbitration API Registers
N*******************************************************************************/
N#if (CY_IP_DMAC_PRESENT)
X#if ((1 == 1))
N    /* RAM control register */
N    #define CY_SYS_CPUSS_RAM_CTL_REG            (*(reg32 *) CYREG_CPUSS_RAM_CTL)
N    #define CY_SYS_CPUSS_RAM_CTL_PTR            ( (reg32 *) CYREG_CPUSS_RAM_CTL)
N
N    /* FLASH control register */
N    #define CY_SYS_CPUSS_FLASH_CTL_REG          (*(reg32 *) CYREG_CPUSS_FLASH_CTL)
N    #define CY_SYS_CPUSS_FLASH_CTL_PTR          ( (reg32 *) CYREG_CPUSS_FLASH_CTL)
N
N    /* DMAC control register */
N    #define CY_SYS_CPUSS_DMAC_CTL_REG            (*(reg32 *) CYREG_CPUSS_DMAC_CTL)
N    #define CY_SYS_CPUSS_DMAC_CTL_PTR            ( (reg32 *) CYREG_CPUSS_DMAC_CTL)
N
N    #if (CY_IP_SL_NR >= 1)
X    #if ((3) >= 1)
N        /* Slave control register # 0 */
N        #if (CY_IP_SL_NR == 1)
X        #if ((3) == 1)
S            #define CY_SYS_CPUSS_SL_CTL0_REG            (*(reg32 *) CYREG_CPUSS_SL_CTL)
S            #define CY_SYS_CPUSS_SL_CTL0_PTR            ( (reg32 *) CYREG_CPUSS_SL_CTL)
N        #else
N            #define CY_SYS_CPUSS_SL_CTL0_REG            (*(reg32 *) CYREG_CPUSS_SL_CTL0)
N            #define CY_SYS_CPUSS_SL_CTL0_PTR            ( (reg32 *) CYREG_CPUSS_SL_CTL0)
N        #endif /* (CY_IP_SL_NR == 1) */
N    #endif /* (CY_IP_SL_NR > 0) */
N
N    #if (CY_IP_SL_NR >= 2)
X    #if ((3) >= 2)
N        /* Slave control register # 1 */
N        #define CY_SYS_CPUSS_SL_CTL1_REG            (*(reg32 *) CYREG_CPUSS_SL_CTL1)
N        #define CY_SYS_CPUSS_SL_CTL1_PTR            ( (reg32 *) CYREG_CPUSS_SL_CTL1)
N    #endif /* (CY_IP_SL_NR >= 1) */
N
N    #if (CY_IP_SL_NR >= 3)
X    #if ((3) >= 3)
N        /* Slave control register # 2 */
N        #define CY_SYS_CPUSS_SL_CTL2_REG            (*(reg32 *) CYREG_CPUSS_SL_CTL2)
N        #define CY_SYS_CPUSS_SL_CTL2_PTR            ( (reg32 *) CYREG_CPUSS_SL_CTL2)
N    #endif /* (CY_IP_SL_NR >= 2) */
N
N#endif /* (CY_IP_DMAC_PRESENT) */
N
N
N/*******************************************************************************
N* The following code is OBSOLETE and must not be used.
N*
N* If the obsoleted macro definitions are intended for use in the application,
N* use the following scheme, redefine your own versions of these definitions:
N*    #ifdef <OBSOLETED_DEFINE>
N*        #undef  <OBSOLETED_DEFINE>
N*        #define <OBSOLETED_DEFINE>      (<New Value>)
N*    #endif
N*
N* Note: Redefine obsoleted macro definitions with caution. They might still be
N*       used in the application and their modification might lead to unexpected
N*       consequences.
N*******************************************************************************/
N#define CYINT_IRQ_BASE                     (CY_INT_IRQ_BASE)
N#define CY_SYS_CLK_IMO_TRIM4_GAIN          (CY_SYS_CLK_IMO_TRIM4_USB_GAIN)
N
N/* SFLASH0 block has been renamed to SFLASH */
N#if (CY_PSOC4_4100 || CY_PSOC4_4200 || CY_PSOC4_4000U)
X#if ((16u == 18u) || (16u == 18u) || (16u == 5u))
S    #if !defined(CYREG_SFLASH_IMO_TRIM21)
S        #define CYREG_SFLASH_IMO_TRIM21         (CYREG_SFLASH0_IMO_TRIM21)
S    #endif  /* !defined(CYREG_SFLASH_IMO_TRIM21) */
N#endif /* (CY_PSOC4_4100 || CY_PSOC4_4200 || CY_PSOC4_4000U) */
N
N#if (CY_IP_CPUSS_CM0)
X#if ((0 == 1))
S
S    #define CY_SYS_CM0_AIRCR_REG                (CY_SYS_AIRCR_REG)
S    #define CY_SYS_CM0_AIRCR_PTR                (CY_SYS_AIRCR_PTR)
S
S    #define CY_SYS_CM0_AIRCR_VECTKEY_SHIFT      (CY_SYS_AIRCR_VECTKEY_SHIFT    )
S    #define CY_SYS_CM0_AIRCR_VECTKEY            (CY_SYS_AIRCR_VECTKEY          )
S    #define CY_SYS_CM0_AIRCR_VECTKEY_MASK       (CY_SYS_AIRCR_VECTKEY_MASK     )
S    #define CY_SYS_CM0_AIRCR_SYSRESETREQ_SHIFT  (CY_SYS_AIRCR_SYSRESETREQ_SHIFT)
S    #define CY_SYS_CM0_AIRCR_SYSRESETREQ        (CY_SYS_AIRCR_SYSRESETREQ      )
S
N#endif /* (CY_IP_CPUSS_CM0) */
N
N#endif  /* CY_BOOT_CYLIB_H */
N
N
N/* [] END OF FILE */
L 25 "Generated_Source\PSoC4\UART_1_BLE.h" 2
N
N/* SCB IP block v0 is available in PSoC 4100/PSoC 4200 */
N#define UART_1_BLE_CY_SCBIP_V0    (CYIPBLOCK_m0s8scb_VERSION == 0u)
N/* SCB IP block v1 is available in PSoC 4000 */
N#define UART_1_BLE_CY_SCBIP_V1    (CYIPBLOCK_m0s8scb_VERSION == 1u)
N/* SCB IP block v2 is available in all other devices */
N#define UART_1_BLE_CY_SCBIP_V2    (CYIPBLOCK_m0s8scb_VERSION >= 2u)
N
N/** Component version major.minor */
N#define UART_1_BLE_COMP_VERSION_MAJOR    (4)
N#define UART_1_BLE_COMP_VERSION_MINOR    (0)
N    
N#define UART_1_BLE_SCB_MODE           (4u)
N
N/* SCB modes enum */
N#define UART_1_BLE_SCB_MODE_I2C       (0x01u)
N#define UART_1_BLE_SCB_MODE_SPI       (0x02u)
N#define UART_1_BLE_SCB_MODE_UART      (0x04u)
N#define UART_1_BLE_SCB_MODE_EZI2C     (0x08u)
N#define UART_1_BLE_SCB_MODE_UNCONFIG  (0xFFu)
N
N/* Condition compilation depends on operation mode: Unconfigured implies apply to all modes */
N#define UART_1_BLE_SCB_MODE_I2C_CONST_CFG       (UART_1_BLE_SCB_MODE_I2C       == UART_1_BLE_SCB_MODE)
N#define UART_1_BLE_SCB_MODE_SPI_CONST_CFG       (UART_1_BLE_SCB_MODE_SPI       == UART_1_BLE_SCB_MODE)
N#define UART_1_BLE_SCB_MODE_UART_CONST_CFG      (UART_1_BLE_SCB_MODE_UART      == UART_1_BLE_SCB_MODE)
N#define UART_1_BLE_SCB_MODE_EZI2C_CONST_CFG     (UART_1_BLE_SCB_MODE_EZI2C     == UART_1_BLE_SCB_MODE)
N#define UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG  (UART_1_BLE_SCB_MODE_UNCONFIG  == UART_1_BLE_SCB_MODE)
N
N/* Condition compilation for includes */
N#define UART_1_BLE_SCB_MODE_I2C_INC      (0u !=(UART_1_BLE_SCB_MODE_I2C   & UART_1_BLE_SCB_MODE))
N#define UART_1_BLE_SCB_MODE_EZI2C_INC    (0u !=(UART_1_BLE_SCB_MODE_EZI2C & UART_1_BLE_SCB_MODE))
N#if (!UART_1_BLE_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_1_BLE_SCB_MODE_SPI_INC  (0u !=(UART_1_BLE_SCB_MODE_SPI   & UART_1_BLE_SCB_MODE))
N    #define UART_1_BLE_SCB_MODE_UART_INC (0u !=(UART_1_BLE_SCB_MODE_UART  & UART_1_BLE_SCB_MODE))
N#else
S    #define UART_1_BLE_SCB_MODE_SPI_INC  (0u)
S    #define UART_1_BLE_SCB_MODE_UART_INC (0u)
N#endif /* (!UART_1_BLE_CY_SCBIP_V1) */
N
N/* Interrupts remove options */
N#define UART_1_BLE_REMOVE_SCB_IRQ             (0u)
N#define UART_1_BLE_SCB_IRQ_INTERNAL           (0u == UART_1_BLE_REMOVE_SCB_IRQ)
N
N#define UART_1_BLE_REMOVE_UART_RX_WAKEUP_IRQ  (1u)
N#define UART_1_BLE_UART_RX_WAKEUP_IRQ         (0u == UART_1_BLE_REMOVE_UART_RX_WAKEUP_IRQ)
N
N/* SCB interrupt enum */
N#define UART_1_BLE_SCB_INTR_MODE_NONE     (0u)
N#define UART_1_BLE_SCB_INTR_MODE_INTERNAL (1u)
N#define UART_1_BLE_SCB_INTR_MODE_EXTERNAL (2u)
N
N/* Internal clock remove option */
N#define UART_1_BLE_REMOVE_SCB_CLK     (0u)
N#define UART_1_BLE_SCB_CLK_INTERNAL   (0u == UART_1_BLE_REMOVE_SCB_CLK)
N
N
N/***************************************
N*       Includes
N****************************************/
N
N#include "UART_1_BLE_PINS.h"
L 1 "Generated_Source\PSoC4\UART_1_BLE_PINS.h" 1
N/***************************************************************************//**
N* \file UART_1_BLE_PINS.h
N* \version 4.0
N*
N* \brief
N*  This file provides constants and parameter values for the pin components
N*  buried into SCB Component.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_PINS_UART_1_BLE_H)
X#if !0L
N#define CY_SCB_PINS_UART_1_BLE_H
N
N#include "cydevice_trm.h"
N#include "cyfitter.h"
N#include "cytypes.h"
N
N
N/***************************************
N*   Conditional Compilation Parameters
N****************************************/
N
N/* Unconfigured pins */
N#define UART_1_BLE_REMOVE_RX_WAKE_SCL_MOSI_PIN  (1u)
N#define UART_1_BLE_REMOVE_RX_SCL_MOSI_PIN      (1u)
N#define UART_1_BLE_REMOVE_TX_SDA_MISO_PIN      (1u)
N#define UART_1_BLE_REMOVE_CTS_SCLK_PIN      (1u)
N#define UART_1_BLE_REMOVE_RTS_SS0_PIN      (1u)
N#define UART_1_BLE_REMOVE_SS1_PIN                 (1u)
N#define UART_1_BLE_REMOVE_SS2_PIN                 (1u)
N#define UART_1_BLE_REMOVE_SS3_PIN                 (1u)
N
N/* Mode defined pins */
N#define UART_1_BLE_REMOVE_I2C_PINS                (1u)
N#define UART_1_BLE_REMOVE_SPI_MASTER_PINS         (1u)
N#define UART_1_BLE_REMOVE_SPI_MASTER_SCLK_PIN     (1u)
N#define UART_1_BLE_REMOVE_SPI_MASTER_MOSI_PIN     (1u)
N#define UART_1_BLE_REMOVE_SPI_MASTER_MISO_PIN     (1u)
N#define UART_1_BLE_REMOVE_SPI_MASTER_SS0_PIN      (1u)
N#define UART_1_BLE_REMOVE_SPI_MASTER_SS1_PIN      (1u)
N#define UART_1_BLE_REMOVE_SPI_MASTER_SS2_PIN      (1u)
N#define UART_1_BLE_REMOVE_SPI_MASTER_SS3_PIN      (1u)
N#define UART_1_BLE_REMOVE_SPI_SLAVE_PINS          (1u)
N#define UART_1_BLE_REMOVE_SPI_SLAVE_MOSI_PIN      (1u)
N#define UART_1_BLE_REMOVE_SPI_SLAVE_MISO_PIN      (1u)
N#define UART_1_BLE_REMOVE_UART_TX_PIN             (0u)
N#define UART_1_BLE_REMOVE_UART_RX_TX_PIN          (1u)
N#define UART_1_BLE_REMOVE_UART_RX_PIN             (0u)
N#define UART_1_BLE_REMOVE_UART_RX_WAKE_PIN        (1u)
N#define UART_1_BLE_REMOVE_UART_RTS_PIN            (1u)
N#define UART_1_BLE_REMOVE_UART_CTS_PIN            (1u)
N
N/* Unconfigured pins */
N#define UART_1_BLE_RX_WAKE_SCL_MOSI_PIN (0u == UART_1_BLE_REMOVE_RX_WAKE_SCL_MOSI_PIN)
N#define UART_1_BLE_RX_SCL_MOSI_PIN     (0u == UART_1_BLE_REMOVE_RX_SCL_MOSI_PIN)
N#define UART_1_BLE_TX_SDA_MISO_PIN     (0u == UART_1_BLE_REMOVE_TX_SDA_MISO_PIN)
N#define UART_1_BLE_CTS_SCLK_PIN     (0u == UART_1_BLE_REMOVE_CTS_SCLK_PIN)
N#define UART_1_BLE_RTS_SS0_PIN     (0u == UART_1_BLE_REMOVE_RTS_SS0_PIN)
N#define UART_1_BLE_SS1_PIN                (0u == UART_1_BLE_REMOVE_SS1_PIN)
N#define UART_1_BLE_SS2_PIN                (0u == UART_1_BLE_REMOVE_SS2_PIN)
N#define UART_1_BLE_SS3_PIN                (0u == UART_1_BLE_REMOVE_SS3_PIN)
N
N/* Mode defined pins */
N#define UART_1_BLE_I2C_PINS               (0u == UART_1_BLE_REMOVE_I2C_PINS)
N#define UART_1_BLE_SPI_MASTER_PINS        (0u == UART_1_BLE_REMOVE_SPI_MASTER_PINS)
N#define UART_1_BLE_SPI_MASTER_SCLK_PIN    (0u == UART_1_BLE_REMOVE_SPI_MASTER_SCLK_PIN)
N#define UART_1_BLE_SPI_MASTER_MOSI_PIN    (0u == UART_1_BLE_REMOVE_SPI_MASTER_MOSI_PIN)
N#define UART_1_BLE_SPI_MASTER_MISO_PIN    (0u == UART_1_BLE_REMOVE_SPI_MASTER_MISO_PIN)
N#define UART_1_BLE_SPI_MASTER_SS0_PIN     (0u == UART_1_BLE_REMOVE_SPI_MASTER_SS0_PIN)
N#define UART_1_BLE_SPI_MASTER_SS1_PIN     (0u == UART_1_BLE_REMOVE_SPI_MASTER_SS1_PIN)
N#define UART_1_BLE_SPI_MASTER_SS2_PIN     (0u == UART_1_BLE_REMOVE_SPI_MASTER_SS2_PIN)
N#define UART_1_BLE_SPI_MASTER_SS3_PIN     (0u == UART_1_BLE_REMOVE_SPI_MASTER_SS3_PIN)
N#define UART_1_BLE_SPI_SLAVE_PINS         (0u == UART_1_BLE_REMOVE_SPI_SLAVE_PINS)
N#define UART_1_BLE_SPI_SLAVE_MOSI_PIN     (0u == UART_1_BLE_REMOVE_SPI_SLAVE_MOSI_PIN)
N#define UART_1_BLE_SPI_SLAVE_MISO_PIN     (0u == UART_1_BLE_REMOVE_SPI_SLAVE_MISO_PIN)
N#define UART_1_BLE_UART_TX_PIN            (0u == UART_1_BLE_REMOVE_UART_TX_PIN)
N#define UART_1_BLE_UART_RX_TX_PIN         (0u == UART_1_BLE_REMOVE_UART_RX_TX_PIN)
N#define UART_1_BLE_UART_RX_PIN            (0u == UART_1_BLE_REMOVE_UART_RX_PIN)
N#define UART_1_BLE_UART_RX_WAKE_PIN       (0u == UART_1_BLE_REMOVE_UART_RX_WAKE_PIN)
N#define UART_1_BLE_UART_RTS_PIN           (0u == UART_1_BLE_REMOVE_UART_RTS_PIN)
N#define UART_1_BLE_UART_CTS_PIN           (0u == UART_1_BLE_REMOVE_UART_CTS_PIN)
N
N
N/***************************************
N*             Includes
N****************************************/
N
N#if (UART_1_BLE_RX_WAKE_SCL_MOSI_PIN)
X#if ((0u == (1u)))
S    #include "UART_1_BLE_uart_rx_wake_i2c_scl_spi_mosi.h"
N#endif /* (UART_1_BLE_RX_SCL_MOSI) */
N
N#if (UART_1_BLE_RX_SCL_MOSI_PIN)
X#if ((0u == (1u)))
S    #include "UART_1_BLE_uart_rx_i2c_scl_spi_mosi.h"
N#endif /* (UART_1_BLE_RX_SCL_MOSI) */
N
N#if (UART_1_BLE_TX_SDA_MISO_PIN)
X#if ((0u == (1u)))
S    #include "UART_1_BLE_uart_tx_i2c_sda_spi_miso.h"
N#endif /* (UART_1_BLE_TX_SDA_MISO) */
N
N#if (UART_1_BLE_CTS_SCLK_PIN)
X#if ((0u == (1u)))
S    #include "UART_1_BLE_uart_cts_spi_sclk.h"
N#endif /* (UART_1_BLE_CTS_SCLK) */
N
N#if (UART_1_BLE_RTS_SS0_PIN)
X#if ((0u == (1u)))
S    #include "UART_1_BLE_uart_rts_spi_ss0.h"
N#endif /* (UART_1_BLE_RTS_SS0_PIN) */
N
N#if (UART_1_BLE_SS1_PIN)
X#if ((0u == (1u)))
S    #include "UART_1_BLE_spi_ss1.h"
N#endif /* (UART_1_BLE_SS1_PIN) */
N
N#if (UART_1_BLE_SS2_PIN)
X#if ((0u == (1u)))
S    #include "UART_1_BLE_spi_ss2.h"
N#endif /* (UART_1_BLE_SS2_PIN) */
N
N#if (UART_1_BLE_SS3_PIN)
X#if ((0u == (1u)))
S    #include "UART_1_BLE_spi_ss3.h"
N#endif /* (UART_1_BLE_SS3_PIN) */
N
N#if (UART_1_BLE_I2C_PINS)
X#if ((0u == (1u)))
S    #include "UART_1_BLE_scl.h"
S    #include "UART_1_BLE_sda.h"
N#endif /* (UART_1_BLE_I2C_PINS) */
N
N#if (UART_1_BLE_SPI_MASTER_PINS)
X#if ((0u == (1u)))
S#if (UART_1_BLE_SPI_MASTER_SCLK_PIN)
S    #include "UART_1_BLE_sclk_m.h"
S#endif /* (UART_1_BLE_SPI_MASTER_SCLK_PIN) */
S
S#if (UART_1_BLE_SPI_MASTER_MOSI_PIN)
S    #include "UART_1_BLE_mosi_m.h"
S#endif /* (UART_1_BLE_SPI_MASTER_MOSI_PIN) */
S
S#if (UART_1_BLE_SPI_MASTER_MISO_PIN)
S    #include "UART_1_BLE_miso_m.h"
S#endif /*(UART_1_BLE_SPI_MASTER_MISO_PIN) */
N#endif /* (UART_1_BLE_SPI_MASTER_PINS) */
N
N#if (UART_1_BLE_SPI_SLAVE_PINS)
X#if ((0u == (1u)))
S    #include "UART_1_BLE_sclk_s.h"
S    #include "UART_1_BLE_ss_s.h"
S
S#if (UART_1_BLE_SPI_SLAVE_MOSI_PIN)
S    #include "UART_1_BLE_mosi_s.h"
S#endif /* (UART_1_BLE_SPI_SLAVE_MOSI_PIN) */
S
S#if (UART_1_BLE_SPI_SLAVE_MISO_PIN)
S    #include "UART_1_BLE_miso_s.h"
S#endif /*(UART_1_BLE_SPI_SLAVE_MISO_PIN) */
N#endif /* (UART_1_BLE_SPI_SLAVE_PINS) */
N
N#if (UART_1_BLE_SPI_MASTER_SS0_PIN)
X#if ((0u == (1u)))
S    #include "UART_1_BLE_ss0_m.h"
N#endif /* (UART_1_BLE_SPI_MASTER_SS0_PIN) */
N
N#if (UART_1_BLE_SPI_MASTER_SS1_PIN)
X#if ((0u == (1u)))
S    #include "UART_1_BLE_ss1_m.h"
N#endif /* (UART_1_BLE_SPI_MASTER_SS1_PIN) */
N
N#if (UART_1_BLE_SPI_MASTER_SS2_PIN)
X#if ((0u == (1u)))
S    #include "UART_1_BLE_ss2_m.h"
N#endif /* (UART_1_BLE_SPI_MASTER_SS2_PIN) */
N
N#if (UART_1_BLE_SPI_MASTER_SS3_PIN)
X#if ((0u == (1u)))
S    #include "UART_1_BLE_ss3_m.h"
N#endif /* (UART_1_BLE_SPI_MASTER_SS3_PIN) */
N
N#if (UART_1_BLE_UART_TX_PIN)
X#if ((0u == (0u)))
N    #include "UART_1_BLE_tx.h"
L 1 "Generated_Source\PSoC4\UART_1_BLE_tx.h" 1
N/*******************************************************************************
N* File Name: UART_1_BLE_tx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_1_BLE_tx_H) /* Pins UART_1_BLE_tx_H */
X#if !0L  
N#define CY_PINS_UART_1_BLE_tx_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "UART_1_BLE_tx_aliases.h"
L 1 "Generated_Source\PSoC4\UART_1_BLE_tx_aliases.h" 1
N/*******************************************************************************
N* File Name: UART_1_BLE_tx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_1_BLE_tx_ALIASES_H) /* Pins UART_1_BLE_tx_ALIASES_H */
X#if !0L  
N#define CY_PINS_UART_1_BLE_tx_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
L 1 "Generated_Source\PSoC4\cypins.h" 1
N/*******************************************************************************
N* \file cypins.h
N* \version 5.70
N*
N* \brief This file contains the function prototypes and constants used for
N* port/pin in access and control.
N*
N* \note Documentation of the API's in this file is located in the System
N* Reference Guide provided with PSoC Creator.
N*
N********************************************************************************
N* \copyright
N* Copyright 2008-2018, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_BOOT_CYPINS_H)
X#if !0L
N#define CY_BOOT_CYPINS_H
N
N#include "cytypes.h"
N
N/**
N* \addtogroup group_pins Pins
N* \brief For PSoC 4, there are status registers, data output registers, and port
Nconfiguration registers only, so the macro takes two arguments: port register
Nand pin number. Each port has these registers addresses defined:
NCYREG_PRTx_DR
NCYREG_PRTx_PS
NCYREG_PRTx_PC
N
NThe x is the port number, and the second argument is the pin number.
N
N* @{
N*/
N
N/** @} group_pins */
N
N
N/**************************************
N*       Register Constants
N**************************************/
N
N
N#define CY_SYS_PINS_PC_DATAOUT                 ((uint32) 0x01u)
N#define CY_SYS_PINS_PC_DRIVE_MODE_BITS         ((uint32) 0x03u)
N#define CY_SYS_PINS_PC_DRIVE_MODE_MASK         ((uint32) 0x07u)
N
N
N/**************************************
N*        API Parameter Constants
N**************************************/
N
N/*  SetPinDriveMode */
N#define CY_SYS_PINS_DM_ALG_HIZ                ((uint32) 0x00u)
N#define CY_SYS_PINS_DM_DIG_HIZ                ((uint32) 0x01u)
N#define CY_SYS_PINS_DM_RES_UP                 ((uint32) 0x02u)
N#define CY_SYS_PINS_DM_RES_DWN                ((uint32) 0x03u)
N#define CY_SYS_PINS_DM_OD_LO                  ((uint32) 0x04u)
N#define CY_SYS_PINS_DM_OD_HI                  ((uint32) 0x05u)
N#define CY_SYS_PINS_DM_STRONG                 ((uint32) 0x06u)
N#define CY_SYS_PINS_DM_RES_UPDWN              ((uint32) 0x07u)
N
N
N/**************************************
N*        Compatibility Macros
N**************************************/
N
N#if(CY_IP_HOBTO_DEVICE)
X#if((!(0 == 1)))
N    #define CYREG_PRT0_DR                     (CYREG_GPIO_PRT0_DR)
N    #define CYREG_PRT0_PS                     (CYREG_GPIO_PRT0_PS)
N    #define CYREG_PRT0_PC                     (CYREG_GPIO_PRT0_PC)
N
N    #define CYREG_PRT1_DR                     (CYREG_GPIO_PRT1_DR)
N    #define CYREG_PRT1_PS                     (CYREG_GPIO_PRT1_PS)
N    #define CYREG_PRT1_PC                     (CYREG_GPIO_PRT1_PC)
N
N    #define CYREG_PRT2_DR                     (CYREG_GPIO_PRT2_DR)
N    #define CYREG_PRT2_PS                     (CYREG_GPIO_PRT2_PS)
N    #define CYREG_PRT2_PC                     (CYREG_GPIO_PRT2_PC)
N
N    #define CYREG_PRT3_DR                     (CYREG_GPIO_PRT3_DR)
N    #define CYREG_PRT3_PS                     (CYREG_GPIO_PRT3_PS)
N    #define CYREG_PRT3_PC                     (CYREG_GPIO_PRT3_PC)
N
N    #define CYREG_PRT4_DR                     (CYREG_GPIO_PRT4_DR)
N    #define CYREG_PRT4_PS                     (CYREG_GPIO_PRT4_PS)
N    #define CYREG_PRT4_PC                     (CYREG_GPIO_PRT4_PC)
N
N    #define CYREG_PRT5_DR                     (CYREG_GPIO_PRT5_DR)
N    #define CYREG_PRT5_PS                     (CYREG_GPIO_PRT5_PS)
N    #define CYREG_PRT5_PC                     (CYREG_GPIO_PRT5_PC)
N
N    #define CYREG_PRT6_DR                     (CYREG_GPIO_PRT6_DR)
N    #define CYREG_PRT6_PS                     (CYREG_GPIO_PRT6_PS)
N    #define CYREG_PRT6_PC                     (CYREG_GPIO_PRT6_PC)
N
N    #define CYREG_PRT7_DR                     (CYREG_GPIO_PRT7_DR)
N    #define CYREG_PRT7_PS                     (CYREG_GPIO_PRT7_PS)
N    #define CYREG_PRT7_PC                     (CYREG_GPIO_PRT7_PC)
N
N    #define CYREG_PRT8_DR                     (CYREG_GPIO_PRT8_DR)
N    #define CYREG_PRT8_PS                     (CYREG_GPIO_PRT8_PS)
N    #define CYREG_PRT8_PC                     (CYREG_GPIO_PRT8_PC)
N
N    #define CYREG_PRT9_DR                     (CYREG_GPIO_PRT9_DR)
N    #define CYREG_PRT9_PS                     (CYREG_GPIO_PRT9_PS)
N    #define CYREG_PRT9_PC                     (CYREG_GPIO_PRT9_PC)
N
N    #define CYREG_PRT10_DR                    (CYREG_GPIO_PRT10_DR)
N    #define CYREG_PRT10_PS                    (CYREG_GPIO_PRT10_PS)
N    #define CYREG_PRT10_PC                    (CYREG_GPIO_PRT10_PC)
N
N    #define CYREG_PRT11_DR                    (CYREG_GPIO_PRT11_DR)
N    #define CYREG_PRT11_PS                    (CYREG_GPIO_PRT11_PS)
N    #define CYREG_PRT11_PC                    (CYREG_GPIO_PRT11_PC)
N
N    #define CYREG_PRT12_DR                    (CYREG_GPIO_PRT12_DR)
N    #define CYREG_PRT12_PS                    (CYREG_GPIO_PRT12_PS)
N    #define CYREG_PRT12_PC                    (CYREG_GPIO_PRT12_PC)
N
N    #define CYREG_PRT13_DR                    (CYREG_GPIO_PRT13_DR)
N    #define CYREG_PRT13_PS                    (CYREG_GPIO_PRT13_PS)
N    #define CYREG_PRT13_PC                    (CYREG_GPIO_PRT13_PC)
N
N    #define CYREG_PRT14_DR                    (CYREG_GPIO_PRT14_DR)
N    #define CYREG_PRT14_PS                    (CYREG_GPIO_PRT14_PS)
N    #define CYREG_PRT14_PC                    (CYREG_GPIO_PRT14_PC)
N
N    #define CYREG_PRT15_DR                    (CYREG_GPIO_PRT15_DR)
N    #define CYREG_PRT15_PS                    (CYREG_GPIO_PRT15_PS)
N    #define CYREG_PRT15_PC                    (CYREG_GPIO_PRT15_PC)
N
N#else
S
S    #define CYREG_GPIO_PRT0_DR                (CYREG_PRT0_DR)
S    #define CYREG_GPIO_PRT0_PS                (CYREG_PRT0_PS)
S    #define CYREG_GPIO_PRT0_PC                (CYREG_PRT0_PC)
S
S    #define CYREG_GPIO_PRT1_DR                (CYREG_PRT1_DR)
S    #define CYREG_GPIO_PRT1_PS                (CYREG_PRT1_PS)
S    #define CYREG_GPIO_PRT1_PC                (CYREG_PRT1_PC)
S
S    #define CYREG_GPIO_PRT2_DR                (CYREG_PRT2_DR)
S    #define CYREG_GPIO_PRT2_PS                (CYREG_PRT2_PS)
S    #define CYREG_GPIO_PRT2_PC                (CYREG_PRT2_PC)
S
S    #define CYREG_GPIO_PRT3_DR                (CYREG_PRT3_DR)
S    #define CYREG_GPIO_PRT3_PS                (CYREG_PRT3_PS)
S    #define CYREG_GPIO_PRT3_PC                (CYREG_PRT3_PC)
S
S    #define CYREG_GPIO_PRT4_DR                (CYREG_PRT4_DR)
S    #define CYREG_GPIO_PRT4_PS                (CYREG_PRT4_PS)
S    #define CYREG_GPIO_PRT4_PC                (CYREG_PRT4_PC)
N#endif /* (CY_IP_HOBTO_DEVICE) */
N
N
N/**************************************
N*       Pin API Macros
N**************************************/
N
N/**
N* \defgroup group_pins Pins
N* @{
N*/
N
N/*******************************************************************************
N* Macro Name: CY_SYS_PINS_READ_PIN
N****************************************************************************//**
N*
N* Reads the current value on the pin (pin state, PS).
N*
N* \param portPS Address of the port pin status register (uint32). Definitions
N* for each port are provided in the cydevice_trm.h file  in the form:
N* CYREG_GPIO_PRTx_PS, where x is a port number. The actual number depends on the
N* selected device.
N*
N* \param pin The pin number 0 - 7. The actual number depends on the selected
N* device.
N*
N* \return Zero - logic low, non-zero - logic high.
N*
N*******************************************************************************/
N#define CY_SYS_PINS_READ_PIN(portPS, pin) \
N            (( *(reg32 *)(portPS) >> (pin)) & CY_SYS_PINS_PC_DATAOUT)
X#define CY_SYS_PINS_READ_PIN(portPS, pin)             (( *(reg32 *)(portPS) >> (pin)) & CY_SYS_PINS_PC_DATAOUT)
N
N
N/*******************************************************************************
N* Macro Name: CY_SYS_PINS_SET_PIN
N****************************************************************************//**
N*
N* Set the output value for the pin (data register, DR) to a logic high.
N* Note that this only has an effect for pins configured as software pins that
N* are not driven by hardware.
N*
N* The macro operation is not atomic. It is not guaranteed that shared register
N* will remain uncorrupted during simultaneous read-modify-write operations
N* performed by two threads (main and interrupt threads). To guarantee data
N* integrity in such cases, the macro should be invoked while the specific
N* interrupt is disabled or within critical section (all interrupts are
N* disabled).
N*
N* \param portDR Address of the port output pin data register (uint32).
N* Definitions for each port are provided in the cydevice_trm.h file  in the
N* form: CYREG_GPIO_PRTx_PS, where x is a port number. The actual number depends
N* on the selected device.
N*
N* \param pin The pin number 0 - 7. The actual number depends on the selected
N* device.
N*
N*******************************************************************************/
N#define CY_SYS_PINS_SET_PIN(portDR, pin)     \
N            ( *(reg32 *)(portDR) |= (CY_SYS_PINS_PC_DATAOUT << (pin)) )
X#define CY_SYS_PINS_SET_PIN(portDR, pin)                 ( *(reg32 *)(portDR) |= (CY_SYS_PINS_PC_DATAOUT << (pin)) )
N
N
N/*******************************************************************************
N* Macro Name: CY_SYS_PINS_CLEAR_PIN
N****************************************************************************//**
N*
N* This macro sets the state of the specified pin to zero.
N*
N* The macro operation is not atomic. It is not guaranteed that shared register
N* will remain uncorrupted during simultaneous read-modify-write operations
N* performed by two threads (main and interrupt threads). To guarantee data
N* integrity in such cases, the macro should be invoked while the specific
N* interrupt is disabled or within critical section (all interrupts are
N* disabled).
N*
N* \param portDR Address of the port output pin data register (uint32).
N* Definitions for each port are provided in the cydevice_trm.h file in the
N* form: CYREG_GPIO_PRTx_PS, where x is a port number. The actual number
N* depends on the selected device.
N*
N* \param pin The pin number 0 - 7. The actual number depends on the selected device.
N*
N*******************************************************************************/
N#define CY_SYS_PINS_CLEAR_PIN(portDR, pin)   \
N            ( *(reg32 *)(portDR) &= ~(CY_SYS_PINS_PC_DATAOUT << (pin)) )
X#define CY_SYS_PINS_CLEAR_PIN(portDR, pin)               ( *(reg32 *)(portDR) &= ~(CY_SYS_PINS_PC_DATAOUT << (pin)) )
N
N
N/*******************************************************************************
N* Macro Name: CY_SYS_PINS_SET_DRIVE_MODE
N****************************************************************************//**
N*
N* Sets the drive mode for the pin (DM).
N*
N* The macro operation is not atomic. It is not guaranteed that shared register
N* will remain uncorrupted during simultaneous read-modify-write operations
N* performed by two threads (main and interrupt threads). To guarantee data
N* integrity in such cases, the macro should be invoked while the specific
N* interrupt is disabled or within critical section (all interrupts are
N* disabled).
N*
N* \param portPC: Address of the port configuration register (uint32).
N* Definitions for each port are provided in the cydevice_trm.h file  in the
N* form: CYREG_GPIO_PRTx_PS, where x is a port number. The actual number
N* depends on the selected device.
N*
N* \param pin The pin number 0 - 7. The actual number depends on the selected device.
N*
N* \param mode Desired drive mode.
N*
N*        Define                        Source
N*   CY_SYS_PINS_DM_ALG_HIZ        Analog HiZ
N*   CY_SYS_PINS_DM_DIG_HIZ        Digital HiZ
N*   CY_SYS_PINS_DM_RES_UP         Resistive pull up
N*   CY_SYS_PINS_DM_RES_DWN        Resistive pull down
N*   CY_SYS_PINS_DM_OD_LO          Open drain - drive low
N*   CY_SYS_PINS_DM_OD_HI          Open drain - drive high
N*   CY_SYS_PINS_DM_STRONG         Strong CMOS Output
N*   CY_SYS_PINS_DM_RES_UPDWN      Resistive pull up/down
N*
N*******************************************************************************/
N#define CY_SYS_PINS_SET_DRIVE_MODE(portPC, pin, mode)    \
N            ( *(reg32 *)(portPC) = (*(reg32 *)(portPC) & \
N            ~(CY_SYS_PINS_PC_DRIVE_MODE_MASK << ((pin) * CY_SYS_PINS_PC_DRIVE_MODE_BITS))) | \
N            ((mode) << ((pin) * CY_SYS_PINS_PC_DRIVE_MODE_BITS)))
X#define CY_SYS_PINS_SET_DRIVE_MODE(portPC, pin, mode)                ( *(reg32 *)(portPC) = (*(reg32 *)(portPC) &             ~(CY_SYS_PINS_PC_DRIVE_MODE_MASK << ((pin) * CY_SYS_PINS_PC_DRIVE_MODE_BITS))) |             ((mode) << ((pin) * CY_SYS_PINS_PC_DRIVE_MODE_BITS)))
N
N
N/*******************************************************************************
N* Macro Name: CY_SYS_PINS_READ_DRIVE_MODE
N****************************************************************************//**
N*
N* Reads the drive mode for the pin (DM).
N*
N* \param portPC Address of the port configuration register (uint32). Definitions
N* for each port are provided in the cydevice_trm.h file in the form:
N* CYREG_GPIO_PRTx_PS, where x is a port number. The actual number depends on the
N* selected device.
N*
N* \param pin The pin number 0 - 7. The actual number depends on the selected
N* device.
N*
N* \return mode Current drive mode for the pin:
N* - CY_SYS_PINS_DM_ALG_HIZ        Analog HiZ
N* - CY_SYS_PINS_DM_DIG_HIZ        Digital HiZ
N* - CY_SYS_PINS_DM_RES_UP         Resistive pull up
N* - CY_SYS_PINS_DM_RES_DWN        Resistive pull down
N* - CY_SYS_PINS_DM_OD_LO          Open drain - drive low
N* - CY_SYS_PINS_DM_OD_HI          Open drain - drive high
N* - CY_SYS_PINS_DM_STRONG         Strong CMOS Output
N* - CY_SYS_PINS_DM_RES_UPDWN      Resistive pull up/down
N*
N*******************************************************************************/
N#define CY_SYS_PINS_READ_DRIVE_MODE(portPC, pin)     \
N        (( *(reg32 *)(portPC) & \
N        (CY_SYS_PINS_PC_DRIVE_MODE_MASK << ((pin) * CY_SYS_PINS_PC_DRIVE_MODE_BITS)) ) >> \
N        (pin) * CY_SYS_PINS_PC_DRIVE_MODE_BITS)
X#define CY_SYS_PINS_READ_DRIVE_MODE(portPC, pin)             (( *(reg32 *)(portPC) &         (CY_SYS_PINS_PC_DRIVE_MODE_MASK << ((pin) * CY_SYS_PINS_PC_DRIVE_MODE_BITS)) ) >>         (pin) * CY_SYS_PINS_PC_DRIVE_MODE_BITS)
N
N/** @} group_pins */
N
N/* Defines function macros for mapping PSoC 4 per-pin functions to PSoC 3/5LP style functions  */
N#define CyPins_ReadPin(name)                (CY_SYS_PINS_READ_PIN       (name ## _PS, name ## _SHIFT))
N#define CyPins_SetPin(name)                 (CY_SYS_PINS_SET_PIN        (name ## _DR, name ## _SHIFT))
N#define CyPins_ClearPin(name)               (CY_SYS_PINS_CLEAR_PIN      (name ## _DR, name ## _SHIFT))
N#define CyPins_SetPinDriveMode(name, mode)  (CY_SYS_PINS_SET_DRIVE_MODE (name ## _PC, name ## _SHIFT, mode))
N#define CyPins_ReadPinDriveMode(name)       (CY_SYS_PINS_READ_DRIVE_MODE(name ## _PC, name ## _SHIFT))
N
N
N#endif /* (CY_BOOT_CYPINS_H) */
N
N
N/* [] END OF FILE */
L 24 "Generated_Source\PSoC4\UART_1_BLE_tx_aliases.h" 2
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define UART_1_BLE_tx_0			(UART_1_BLE_tx__0__PC)
N#define UART_1_BLE_tx_0_PS		(UART_1_BLE_tx__0__PS)
N#define UART_1_BLE_tx_0_PC		(UART_1_BLE_tx__0__PC)
N#define UART_1_BLE_tx_0_DR		(UART_1_BLE_tx__0__DR)
N#define UART_1_BLE_tx_0_SHIFT	(UART_1_BLE_tx__0__SHIFT)
N#define UART_1_BLE_tx_0_INTR	((uint16)((uint16)0x0003u << (UART_1_BLE_tx__0__SHIFT*2u)))
N
N#define UART_1_BLE_tx_INTR_ALL	 ((uint16)(UART_1_BLE_tx_0_INTR))
N
N
N#endif /* End Pins UART_1_BLE_tx_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\UART_1_BLE_tx.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} UART_1_BLE_tx_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   UART_1_BLE_tx_Read(void);
Nvoid    UART_1_BLE_tx_Write(uint8 value);
Nuint8   UART_1_BLE_tx_ReadDataReg(void);
N#if defined(UART_1_BLE_tx__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    UART_1_BLE_tx_SetDriveMode(uint8 mode);
N#endif
Nvoid    UART_1_BLE_tx_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   UART_1_BLE_tx_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid UART_1_BLE_tx_Sleep(void); 
Nvoid UART_1_BLE_tx_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(UART_1_BLE_tx__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define UART_1_BLE_tx_DRIVE_MODE_BITS        (3)
N    #define UART_1_BLE_tx_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - UART_1_BLE_tx_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the UART_1_BLE_tx_SetDriveMode() function.
N         *  @{
N         */
N        #define UART_1_BLE_tx_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define UART_1_BLE_tx_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define UART_1_BLE_tx_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define UART_1_BLE_tx_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define UART_1_BLE_tx_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define UART_1_BLE_tx_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define UART_1_BLE_tx_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define UART_1_BLE_tx_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define UART_1_BLE_tx_MASK               UART_1_BLE_tx__MASK
N#define UART_1_BLE_tx_SHIFT              UART_1_BLE_tx__SHIFT
N#define UART_1_BLE_tx_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in UART_1_BLE_tx_SetInterruptMode() function.
N     *  @{
N     */
N        #define UART_1_BLE_tx_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define UART_1_BLE_tx_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define UART_1_BLE_tx_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define UART_1_BLE_tx_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(UART_1_BLE_tx__SIO)
X#if 0L
S    #define UART_1_BLE_tx_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(UART_1_BLE_tx__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define UART_1_BLE_tx_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define UART_1_BLE_tx_USBIO_DISABLE              ((uint32)(~UART_1_BLE_tx_USBIO_ENABLE))
S    #define UART_1_BLE_tx_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define UART_1_BLE_tx_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define UART_1_BLE_tx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_1_BLE_tx_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << UART_1_BLE_tx_USBIO_SUSPEND_DEL_SHIFT)))
X    #define UART_1_BLE_tx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_1_BLE_tx_USBIO_SUSPEND_SHIFT)                                                         | (1u << UART_1_BLE_tx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_1_BLE_tx_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << UART_1_BLE_tx_USBIO_SUSPEND_SHIFT)))
S    #define UART_1_BLE_tx_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << UART_1_BLE_tx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_1_BLE_tx_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(UART_1_BLE_tx__PC)
X#if 1L
N    /* Port Configuration */
N    #define UART_1_BLE_tx_PC                 (* (reg32 *) UART_1_BLE_tx__PC)
N#endif
N/* Pin State */
N#define UART_1_BLE_tx_PS                     (* (reg32 *) UART_1_BLE_tx__PS)
N/* Data Register */
N#define UART_1_BLE_tx_DR                     (* (reg32 *) UART_1_BLE_tx__DR)
N/* Input Buffer Disable Override */
N#define UART_1_BLE_tx_INP_DIS                (* (reg32 *) UART_1_BLE_tx__PC2)
N
N/* Interrupt configuration Registers */
N#define UART_1_BLE_tx_INTCFG                 (* (reg32 *) UART_1_BLE_tx__INTCFG)
N#define UART_1_BLE_tx_INTSTAT                (* (reg32 *) UART_1_BLE_tx__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define UART_1_BLE_tx_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(UART_1_BLE_tx__SIO)
X#if 0L
S    #define UART_1_BLE_tx_SIO_REG            (* (reg32 *) UART_1_BLE_tx__SIO)
N#endif /* (UART_1_BLE_tx__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(UART_1_BLE_tx__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define UART_1_BLE_tx_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define UART_1_BLE_tx_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define UART_1_BLE_tx_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define UART_1_BLE_tx_DRIVE_MODE_SHIFT       (0x00u)
N#define UART_1_BLE_tx_DRIVE_MODE_MASK        (0x07u << UART_1_BLE_tx_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins UART_1_BLE_tx_H */
N
N
N/* [] END OF FILE */
L 178 "Generated_Source\PSoC4\UART_1_BLE_PINS.h" 2
N#endif /* (UART_1_BLE_UART_TX_PIN) */
N
N#if (UART_1_BLE_UART_RX_TX_PIN)
X#if ((0u == (1u)))
S    #include "UART_1_BLE_rx_tx.h"
N#endif /* (UART_1_BLE_UART_RX_TX_PIN) */
N
N#if (UART_1_BLE_UART_RX_PIN)
X#if ((0u == (0u)))
N    #include "UART_1_BLE_rx.h"
L 1 "Generated_Source\PSoC4\UART_1_BLE_rx.h" 1
N/*******************************************************************************
N* File Name: UART_1_BLE_rx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_1_BLE_rx_H) /* Pins UART_1_BLE_rx_H */
X#if !0L  
N#define CY_PINS_UART_1_BLE_rx_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "UART_1_BLE_rx_aliases.h"
L 1 "Generated_Source\PSoC4\UART_1_BLE_rx_aliases.h" 1
N/*******************************************************************************
N* File Name: UART_1_BLE_rx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_1_BLE_rx_ALIASES_H) /* Pins UART_1_BLE_rx_ALIASES_H */
X#if !0L  
N#define CY_PINS_UART_1_BLE_rx_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define UART_1_BLE_rx_0			(UART_1_BLE_rx__0__PC)
N#define UART_1_BLE_rx_0_PS		(UART_1_BLE_rx__0__PS)
N#define UART_1_BLE_rx_0_PC		(UART_1_BLE_rx__0__PC)
N#define UART_1_BLE_rx_0_DR		(UART_1_BLE_rx__0__DR)
N#define UART_1_BLE_rx_0_SHIFT	(UART_1_BLE_rx__0__SHIFT)
N#define UART_1_BLE_rx_0_INTR	((uint16)((uint16)0x0003u << (UART_1_BLE_rx__0__SHIFT*2u)))
N
N#define UART_1_BLE_rx_INTR_ALL	 ((uint16)(UART_1_BLE_rx_0_INTR))
N
N
N#endif /* End Pins UART_1_BLE_rx_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\UART_1_BLE_rx.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} UART_1_BLE_rx_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   UART_1_BLE_rx_Read(void);
Nvoid    UART_1_BLE_rx_Write(uint8 value);
Nuint8   UART_1_BLE_rx_ReadDataReg(void);
N#if defined(UART_1_BLE_rx__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    UART_1_BLE_rx_SetDriveMode(uint8 mode);
N#endif
Nvoid    UART_1_BLE_rx_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   UART_1_BLE_rx_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid UART_1_BLE_rx_Sleep(void); 
Nvoid UART_1_BLE_rx_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(UART_1_BLE_rx__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define UART_1_BLE_rx_DRIVE_MODE_BITS        (3)
N    #define UART_1_BLE_rx_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - UART_1_BLE_rx_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the UART_1_BLE_rx_SetDriveMode() function.
N         *  @{
N         */
N        #define UART_1_BLE_rx_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define UART_1_BLE_rx_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define UART_1_BLE_rx_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define UART_1_BLE_rx_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define UART_1_BLE_rx_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define UART_1_BLE_rx_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define UART_1_BLE_rx_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define UART_1_BLE_rx_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define UART_1_BLE_rx_MASK               UART_1_BLE_rx__MASK
N#define UART_1_BLE_rx_SHIFT              UART_1_BLE_rx__SHIFT
N#define UART_1_BLE_rx_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in UART_1_BLE_rx_SetInterruptMode() function.
N     *  @{
N     */
N        #define UART_1_BLE_rx_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define UART_1_BLE_rx_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define UART_1_BLE_rx_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define UART_1_BLE_rx_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(UART_1_BLE_rx__SIO)
X#if 0L
S    #define UART_1_BLE_rx_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(UART_1_BLE_rx__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define UART_1_BLE_rx_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define UART_1_BLE_rx_USBIO_DISABLE              ((uint32)(~UART_1_BLE_rx_USBIO_ENABLE))
S    #define UART_1_BLE_rx_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define UART_1_BLE_rx_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define UART_1_BLE_rx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_1_BLE_rx_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << UART_1_BLE_rx_USBIO_SUSPEND_DEL_SHIFT)))
X    #define UART_1_BLE_rx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_1_BLE_rx_USBIO_SUSPEND_SHIFT)                                                         | (1u << UART_1_BLE_rx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_1_BLE_rx_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << UART_1_BLE_rx_USBIO_SUSPEND_SHIFT)))
S    #define UART_1_BLE_rx_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << UART_1_BLE_rx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_1_BLE_rx_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(UART_1_BLE_rx__PC)
X#if 1L
N    /* Port Configuration */
N    #define UART_1_BLE_rx_PC                 (* (reg32 *) UART_1_BLE_rx__PC)
N#endif
N/* Pin State */
N#define UART_1_BLE_rx_PS                     (* (reg32 *) UART_1_BLE_rx__PS)
N/* Data Register */
N#define UART_1_BLE_rx_DR                     (* (reg32 *) UART_1_BLE_rx__DR)
N/* Input Buffer Disable Override */
N#define UART_1_BLE_rx_INP_DIS                (* (reg32 *) UART_1_BLE_rx__PC2)
N
N/* Interrupt configuration Registers */
N#define UART_1_BLE_rx_INTCFG                 (* (reg32 *) UART_1_BLE_rx__INTCFG)
N#define UART_1_BLE_rx_INTSTAT                (* (reg32 *) UART_1_BLE_rx__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define UART_1_BLE_rx_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(UART_1_BLE_rx__SIO)
X#if 0L
S    #define UART_1_BLE_rx_SIO_REG            (* (reg32 *) UART_1_BLE_rx__SIO)
N#endif /* (UART_1_BLE_rx__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(UART_1_BLE_rx__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define UART_1_BLE_rx_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define UART_1_BLE_rx_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define UART_1_BLE_rx_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define UART_1_BLE_rx_DRIVE_MODE_SHIFT       (0x00u)
N#define UART_1_BLE_rx_DRIVE_MODE_MASK        (0x07u << UART_1_BLE_rx_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins UART_1_BLE_rx_H */
N
N
N/* [] END OF FILE */
L 186 "Generated_Source\PSoC4\UART_1_BLE_PINS.h" 2
N#endif /* (UART_1_BLE_UART_RX_PIN) */
N
N#if (UART_1_BLE_UART_RX_WAKE_PIN)
X#if ((0u == (1u)))
S    #include "UART_1_BLE_rx_wake.h"
N#endif /* (UART_1_BLE_UART_RX_WAKE_PIN) */
N
N#if (UART_1_BLE_UART_RTS_PIN)
X#if ((0u == (1u)))
S    #include "UART_1_BLE_rts.h"
N#endif /* (UART_1_BLE_UART_RTS_PIN) */
N
N#if (UART_1_BLE_UART_CTS_PIN)
X#if ((0u == (1u)))
S    #include "UART_1_BLE_cts.h"
N#endif /* (UART_1_BLE_UART_CTS_PIN) */
N
N
N/***************************************
N*              Registers
N***************************************/
N
N#if (UART_1_BLE_RX_SCL_MOSI_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_RX_SCL_MOSI_HSIOM_REG   (*(reg32 *) UART_1_BLE_uart_rx_i2c_scl_spi_mosi__0__HSIOM)
S    #define UART_1_BLE_RX_SCL_MOSI_HSIOM_PTR   ( (reg32 *) UART_1_BLE_uart_rx_i2c_scl_spi_mosi__0__HSIOM)
S    
S    #define UART_1_BLE_RX_SCL_MOSI_HSIOM_MASK      (UART_1_BLE_uart_rx_i2c_scl_spi_mosi__0__HSIOM_MASK)
S    #define UART_1_BLE_RX_SCL_MOSI_HSIOM_POS       (UART_1_BLE_uart_rx_i2c_scl_spi_mosi__0__HSIOM_SHIFT)
S    #define UART_1_BLE_RX_SCL_MOSI_HSIOM_SEL_GPIO  (UART_1_BLE_uart_rx_i2c_scl_spi_mosi__0__HSIOM_GPIO)
S    #define UART_1_BLE_RX_SCL_MOSI_HSIOM_SEL_I2C   (UART_1_BLE_uart_rx_i2c_scl_spi_mosi__0__HSIOM_I2C)
S    #define UART_1_BLE_RX_SCL_MOSI_HSIOM_SEL_SPI   (UART_1_BLE_uart_rx_i2c_scl_spi_mosi__0__HSIOM_SPI)
S    #define UART_1_BLE_RX_SCL_MOSI_HSIOM_SEL_UART  (UART_1_BLE_uart_rx_i2c_scl_spi_mosi__0__HSIOM_UART)
S    
S#elif (UART_1_BLE_RX_WAKE_SCL_MOSI_PIN)
X#elif ((0u == (1u)))
S    #define UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_REG   (*(reg32 *) UART_1_BLE_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM)
S    #define UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_PTR   ( (reg32 *) UART_1_BLE_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM)
S    
S    #define UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_MASK      (UART_1_BLE_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_MASK)
S    #define UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_POS       (UART_1_BLE_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_SHIFT)
S    #define UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_SEL_GPIO  (UART_1_BLE_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_GPIO)
S    #define UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_SEL_I2C   (UART_1_BLE_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_I2C)
S    #define UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_SEL_SPI   (UART_1_BLE_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_SPI)
S    #define UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_SEL_UART  (UART_1_BLE_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_UART)    
S   
S    #define UART_1_BLE_RX_WAKE_SCL_MOSI_INTCFG_REG (*(reg32 *) UART_1_BLE_uart_rx_wake_i2c_scl_spi_mosi__0__INTCFG)
S    #define UART_1_BLE_RX_WAKE_SCL_MOSI_INTCFG_PTR ( (reg32 *) UART_1_BLE_uart_rx_wake_i2c_scl_spi_mosi__0__INTCFG)
S    #define UART_1_BLE_RX_WAKE_SCL_MOSI_INTCFG_TYPE_POS  (UART_1_BLE_uart_rx_wake_i2c_scl_spi_mosi__SHIFT)
S    #define UART_1_BLE_RX_WAKE_SCL_MOSI_INTCFG_TYPE_MASK ((uint32) UART_1_BLE_INTCFG_TYPE_MASK << \
S                                                                           UART_1_BLE_RX_WAKE_SCL_MOSI_INTCFG_TYPE_POS)
X    #define UART_1_BLE_RX_WAKE_SCL_MOSI_INTCFG_TYPE_MASK ((uint32) UART_1_BLE_INTCFG_TYPE_MASK <<                                                                            UART_1_BLE_RX_WAKE_SCL_MOSI_INTCFG_TYPE_POS)
N#else
N    /* None of pins UART_1_BLE_RX_SCL_MOSI_PIN or UART_1_BLE_RX_WAKE_SCL_MOSI_PIN present.*/
N#endif /* (UART_1_BLE_RX_SCL_MOSI_PIN) */
N
N#if (UART_1_BLE_TX_SDA_MISO_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_TX_SDA_MISO_HSIOM_REG   (*(reg32 *) UART_1_BLE_uart_tx_i2c_sda_spi_miso__0__HSIOM)
S    #define UART_1_BLE_TX_SDA_MISO_HSIOM_PTR   ( (reg32 *) UART_1_BLE_uart_tx_i2c_sda_spi_miso__0__HSIOM)
S    
S    #define UART_1_BLE_TX_SDA_MISO_HSIOM_MASK      (UART_1_BLE_uart_tx_i2c_sda_spi_miso__0__HSIOM_MASK)
S    #define UART_1_BLE_TX_SDA_MISO_HSIOM_POS       (UART_1_BLE_uart_tx_i2c_sda_spi_miso__0__HSIOM_SHIFT)
S    #define UART_1_BLE_TX_SDA_MISO_HSIOM_SEL_GPIO  (UART_1_BLE_uart_tx_i2c_sda_spi_miso__0__HSIOM_GPIO)
S    #define UART_1_BLE_TX_SDA_MISO_HSIOM_SEL_I2C   (UART_1_BLE_uart_tx_i2c_sda_spi_miso__0__HSIOM_I2C)
S    #define UART_1_BLE_TX_SDA_MISO_HSIOM_SEL_SPI   (UART_1_BLE_uart_tx_i2c_sda_spi_miso__0__HSIOM_SPI)
S    #define UART_1_BLE_TX_SDA_MISO_HSIOM_SEL_UART  (UART_1_BLE_uart_tx_i2c_sda_spi_miso__0__HSIOM_UART)
N#endif /* (UART_1_BLE_TX_SDA_MISO_PIN) */
N
N#if (UART_1_BLE_CTS_SCLK_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_CTS_SCLK_HSIOM_REG   (*(reg32 *) UART_1_BLE_uart_cts_spi_sclk__0__HSIOM)
S    #define UART_1_BLE_CTS_SCLK_HSIOM_PTR   ( (reg32 *) UART_1_BLE_uart_cts_spi_sclk__0__HSIOM)
S    
S    #define UART_1_BLE_CTS_SCLK_HSIOM_MASK      (UART_1_BLE_uart_cts_spi_sclk__0__HSIOM_MASK)
S    #define UART_1_BLE_CTS_SCLK_HSIOM_POS       (UART_1_BLE_uart_cts_spi_sclk__0__HSIOM_SHIFT)
S    #define UART_1_BLE_CTS_SCLK_HSIOM_SEL_GPIO  (UART_1_BLE_uart_cts_spi_sclk__0__HSIOM_GPIO)
S    #define UART_1_BLE_CTS_SCLK_HSIOM_SEL_I2C   (UART_1_BLE_uart_cts_spi_sclk__0__HSIOM_I2C)
S    #define UART_1_BLE_CTS_SCLK_HSIOM_SEL_SPI   (UART_1_BLE_uart_cts_spi_sclk__0__HSIOM_SPI)
S    #define UART_1_BLE_CTS_SCLK_HSIOM_SEL_UART  (UART_1_BLE_uart_cts_spi_sclk__0__HSIOM_UART)
N#endif /* (UART_1_BLE_CTS_SCLK_PIN) */
N
N#if (UART_1_BLE_RTS_SS0_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_RTS_SS0_HSIOM_REG   (*(reg32 *) UART_1_BLE_uart_rts_spi_ss0__0__HSIOM)
S    #define UART_1_BLE_RTS_SS0_HSIOM_PTR   ( (reg32 *) UART_1_BLE_uart_rts_spi_ss0__0__HSIOM)
S    
S    #define UART_1_BLE_RTS_SS0_HSIOM_MASK      (UART_1_BLE_uart_rts_spi_ss0__0__HSIOM_MASK)
S    #define UART_1_BLE_RTS_SS0_HSIOM_POS       (UART_1_BLE_uart_rts_spi_ss0__0__HSIOM_SHIFT)
S    #define UART_1_BLE_RTS_SS0_HSIOM_SEL_GPIO  (UART_1_BLE_uart_rts_spi_ss0__0__HSIOM_GPIO)
S    #define UART_1_BLE_RTS_SS0_HSIOM_SEL_I2C   (UART_1_BLE_uart_rts_spi_ss0__0__HSIOM_I2C)
S    #define UART_1_BLE_RTS_SS0_HSIOM_SEL_SPI   (UART_1_BLE_uart_rts_spi_ss0__0__HSIOM_SPI)
S#if !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1)
S    #define UART_1_BLE_RTS_SS0_HSIOM_SEL_UART  (UART_1_BLE_uart_rts_spi_ss0__0__HSIOM_UART)
S#endif /* !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1) */
N#endif /* (UART_1_BLE_RTS_SS0_PIN) */
N
N#if (UART_1_BLE_SS1_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_SS1_HSIOM_REG  (*(reg32 *) UART_1_BLE_spi_ss1__0__HSIOM)
S    #define UART_1_BLE_SS1_HSIOM_PTR  ( (reg32 *) UART_1_BLE_spi_ss1__0__HSIOM)
S    
S    #define UART_1_BLE_SS1_HSIOM_MASK     (UART_1_BLE_spi_ss1__0__HSIOM_MASK)
S    #define UART_1_BLE_SS1_HSIOM_POS      (UART_1_BLE_spi_ss1__0__HSIOM_SHIFT)
S    #define UART_1_BLE_SS1_HSIOM_SEL_GPIO (UART_1_BLE_spi_ss1__0__HSIOM_GPIO)
S    #define UART_1_BLE_SS1_HSIOM_SEL_I2C  (UART_1_BLE_spi_ss1__0__HSIOM_I2C)
S    #define UART_1_BLE_SS1_HSIOM_SEL_SPI  (UART_1_BLE_spi_ss1__0__HSIOM_SPI)
N#endif /* (UART_1_BLE_SS1_PIN) */
N
N#if (UART_1_BLE_SS2_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_SS2_HSIOM_REG     (*(reg32 *) UART_1_BLE_spi_ss2__0__HSIOM)
S    #define UART_1_BLE_SS2_HSIOM_PTR     ( (reg32 *) UART_1_BLE_spi_ss2__0__HSIOM)
S    
S    #define UART_1_BLE_SS2_HSIOM_MASK     (UART_1_BLE_spi_ss2__0__HSIOM_MASK)
S    #define UART_1_BLE_SS2_HSIOM_POS      (UART_1_BLE_spi_ss2__0__HSIOM_SHIFT)
S    #define UART_1_BLE_SS2_HSIOM_SEL_GPIO (UART_1_BLE_spi_ss2__0__HSIOM_GPIO)
S    #define UART_1_BLE_SS2_HSIOM_SEL_I2C  (UART_1_BLE_spi_ss2__0__HSIOM_I2C)
S    #define UART_1_BLE_SS2_HSIOM_SEL_SPI  (UART_1_BLE_spi_ss2__0__HSIOM_SPI)
N#endif /* (UART_1_BLE_SS2_PIN) */
N
N#if (UART_1_BLE_SS3_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_SS3_HSIOM_REG     (*(reg32 *) UART_1_BLE_spi_ss3__0__HSIOM)
S    #define UART_1_BLE_SS3_HSIOM_PTR     ( (reg32 *) UART_1_BLE_spi_ss3__0__HSIOM)
S    
S    #define UART_1_BLE_SS3_HSIOM_MASK     (UART_1_BLE_spi_ss3__0__HSIOM_MASK)
S    #define UART_1_BLE_SS3_HSIOM_POS      (UART_1_BLE_spi_ss3__0__HSIOM_SHIFT)
S    #define UART_1_BLE_SS3_HSIOM_SEL_GPIO (UART_1_BLE_spi_ss3__0__HSIOM_GPIO)
S    #define UART_1_BLE_SS3_HSIOM_SEL_I2C  (UART_1_BLE_spi_ss3__0__HSIOM_I2C)
S    #define UART_1_BLE_SS3_HSIOM_SEL_SPI  (UART_1_BLE_spi_ss3__0__HSIOM_SPI)
N#endif /* (UART_1_BLE_SS3_PIN) */
N
N#if (UART_1_BLE_I2C_PINS)
X#if ((0u == (1u)))
S    #define UART_1_BLE_SCL_HSIOM_REG  (*(reg32 *) UART_1_BLE_scl__0__HSIOM)
S    #define UART_1_BLE_SCL_HSIOM_PTR  ( (reg32 *) UART_1_BLE_scl__0__HSIOM)
S    
S    #define UART_1_BLE_SCL_HSIOM_MASK     (UART_1_BLE_scl__0__HSIOM_MASK)
S    #define UART_1_BLE_SCL_HSIOM_POS      (UART_1_BLE_scl__0__HSIOM_SHIFT)
S    #define UART_1_BLE_SCL_HSIOM_SEL_GPIO (UART_1_BLE_sda__0__HSIOM_GPIO)
S    #define UART_1_BLE_SCL_HSIOM_SEL_I2C  (UART_1_BLE_sda__0__HSIOM_I2C)
S    
S    #define UART_1_BLE_SDA_HSIOM_REG  (*(reg32 *) UART_1_BLE_sda__0__HSIOM)
S    #define UART_1_BLE_SDA_HSIOM_PTR  ( (reg32 *) UART_1_BLE_sda__0__HSIOM)
S    
S    #define UART_1_BLE_SDA_HSIOM_MASK     (UART_1_BLE_sda__0__HSIOM_MASK)
S    #define UART_1_BLE_SDA_HSIOM_POS      (UART_1_BLE_sda__0__HSIOM_SHIFT)
S    #define UART_1_BLE_SDA_HSIOM_SEL_GPIO (UART_1_BLE_sda__0__HSIOM_GPIO)
S    #define UART_1_BLE_SDA_HSIOM_SEL_I2C  (UART_1_BLE_sda__0__HSIOM_I2C)
N#endif /* (UART_1_BLE_I2C_PINS) */
N
N#if (UART_1_BLE_SPI_SLAVE_PINS)
X#if ((0u == (1u)))
S    #define UART_1_BLE_SCLK_S_HSIOM_REG   (*(reg32 *) UART_1_BLE_sclk_s__0__HSIOM)
S    #define UART_1_BLE_SCLK_S_HSIOM_PTR   ( (reg32 *) UART_1_BLE_sclk_s__0__HSIOM)
S    
S    #define UART_1_BLE_SCLK_S_HSIOM_MASK      (UART_1_BLE_sclk_s__0__HSIOM_MASK)
S    #define UART_1_BLE_SCLK_S_HSIOM_POS       (UART_1_BLE_sclk_s__0__HSIOM_SHIFT)
S    #define UART_1_BLE_SCLK_S_HSIOM_SEL_GPIO  (UART_1_BLE_sclk_s__0__HSIOM_GPIO)
S    #define UART_1_BLE_SCLK_S_HSIOM_SEL_SPI   (UART_1_BLE_sclk_s__0__HSIOM_SPI)
S    
S    #define UART_1_BLE_SS0_S_HSIOM_REG    (*(reg32 *) UART_1_BLE_ss0_s__0__HSIOM)
S    #define UART_1_BLE_SS0_S_HSIOM_PTR    ( (reg32 *) UART_1_BLE_ss0_s__0__HSIOM)
S    
S    #define UART_1_BLE_SS0_S_HSIOM_MASK       (UART_1_BLE_ss0_s__0__HSIOM_MASK)
S    #define UART_1_BLE_SS0_S_HSIOM_POS        (UART_1_BLE_ss0_s__0__HSIOM_SHIFT)
S    #define UART_1_BLE_SS0_S_HSIOM_SEL_GPIO   (UART_1_BLE_ss0_s__0__HSIOM_GPIO)  
S    #define UART_1_BLE_SS0_S_HSIOM_SEL_SPI    (UART_1_BLE_ss0_s__0__HSIOM_SPI)
N#endif /* (UART_1_BLE_SPI_SLAVE_PINS) */
N
N#if (UART_1_BLE_SPI_SLAVE_MOSI_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_MOSI_S_HSIOM_REG   (*(reg32 *) UART_1_BLE_mosi_s__0__HSIOM)
S    #define UART_1_BLE_MOSI_S_HSIOM_PTR   ( (reg32 *) UART_1_BLE_mosi_s__0__HSIOM)
S    
S    #define UART_1_BLE_MOSI_S_HSIOM_MASK      (UART_1_BLE_mosi_s__0__HSIOM_MASK)
S    #define UART_1_BLE_MOSI_S_HSIOM_POS       (UART_1_BLE_mosi_s__0__HSIOM_SHIFT)
S    #define UART_1_BLE_MOSI_S_HSIOM_SEL_GPIO  (UART_1_BLE_mosi_s__0__HSIOM_GPIO)
S    #define UART_1_BLE_MOSI_S_HSIOM_SEL_SPI   (UART_1_BLE_mosi_s__0__HSIOM_SPI)
N#endif /* (UART_1_BLE_SPI_SLAVE_MOSI_PIN) */
N
N#if (UART_1_BLE_SPI_SLAVE_MISO_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_MISO_S_HSIOM_REG   (*(reg32 *) UART_1_BLE_miso_s__0__HSIOM)
S    #define UART_1_BLE_MISO_S_HSIOM_PTR   ( (reg32 *) UART_1_BLE_miso_s__0__HSIOM)
S    
S    #define UART_1_BLE_MISO_S_HSIOM_MASK      (UART_1_BLE_miso_s__0__HSIOM_MASK)
S    #define UART_1_BLE_MISO_S_HSIOM_POS       (UART_1_BLE_miso_s__0__HSIOM_SHIFT)
S    #define UART_1_BLE_MISO_S_HSIOM_SEL_GPIO  (UART_1_BLE_miso_s__0__HSIOM_GPIO)
S    #define UART_1_BLE_MISO_S_HSIOM_SEL_SPI   (UART_1_BLE_miso_s__0__HSIOM_SPI)
N#endif /* (UART_1_BLE_SPI_SLAVE_MISO_PIN) */
N
N#if (UART_1_BLE_SPI_MASTER_MISO_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_MISO_M_HSIOM_REG   (*(reg32 *) UART_1_BLE_miso_m__0__HSIOM)
S    #define UART_1_BLE_MISO_M_HSIOM_PTR   ( (reg32 *) UART_1_BLE_miso_m__0__HSIOM)
S    
S    #define UART_1_BLE_MISO_M_HSIOM_MASK      (UART_1_BLE_miso_m__0__HSIOM_MASK)
S    #define UART_1_BLE_MISO_M_HSIOM_POS       (UART_1_BLE_miso_m__0__HSIOM_SHIFT)
S    #define UART_1_BLE_MISO_M_HSIOM_SEL_GPIO  (UART_1_BLE_miso_m__0__HSIOM_GPIO)
S    #define UART_1_BLE_MISO_M_HSIOM_SEL_SPI   (UART_1_BLE_miso_m__0__HSIOM_SPI)
N#endif /* (UART_1_BLE_SPI_MASTER_MISO_PIN) */
N
N#if (UART_1_BLE_SPI_MASTER_MOSI_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_MOSI_M_HSIOM_REG   (*(reg32 *) UART_1_BLE_mosi_m__0__HSIOM)
S    #define UART_1_BLE_MOSI_M_HSIOM_PTR   ( (reg32 *) UART_1_BLE_mosi_m__0__HSIOM)
S    
S    #define UART_1_BLE_MOSI_M_HSIOM_MASK      (UART_1_BLE_mosi_m__0__HSIOM_MASK)
S    #define UART_1_BLE_MOSI_M_HSIOM_POS       (UART_1_BLE_mosi_m__0__HSIOM_SHIFT)
S    #define UART_1_BLE_MOSI_M_HSIOM_SEL_GPIO  (UART_1_BLE_mosi_m__0__HSIOM_GPIO)
S    #define UART_1_BLE_MOSI_M_HSIOM_SEL_SPI   (UART_1_BLE_mosi_m__0__HSIOM_SPI)
N#endif /* (UART_1_BLE_SPI_MASTER_MOSI_PIN) */
N
N#if (UART_1_BLE_SPI_MASTER_SCLK_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_SCLK_M_HSIOM_REG   (*(reg32 *) UART_1_BLE_sclk_m__0__HSIOM)
S    #define UART_1_BLE_SCLK_M_HSIOM_PTR   ( (reg32 *) UART_1_BLE_sclk_m__0__HSIOM)
S    
S    #define UART_1_BLE_SCLK_M_HSIOM_MASK      (UART_1_BLE_sclk_m__0__HSIOM_MASK)
S    #define UART_1_BLE_SCLK_M_HSIOM_POS       (UART_1_BLE_sclk_m__0__HSIOM_SHIFT)
S    #define UART_1_BLE_SCLK_M_HSIOM_SEL_GPIO  (UART_1_BLE_sclk_m__0__HSIOM_GPIO)
S    #define UART_1_BLE_SCLK_M_HSIOM_SEL_SPI   (UART_1_BLE_sclk_m__0__HSIOM_SPI)
N#endif /* (UART_1_BLE_SPI_MASTER_SCLK_PIN) */
N
N#if (UART_1_BLE_SPI_MASTER_SS0_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_SS0_M_HSIOM_REG    (*(reg32 *) UART_1_BLE_ss0_m__0__HSIOM)
S    #define UART_1_BLE_SS0_M_HSIOM_PTR    ( (reg32 *) UART_1_BLE_ss0_m__0__HSIOM)
S    
S    #define UART_1_BLE_SS0_M_HSIOM_MASK       (UART_1_BLE_ss0_m__0__HSIOM_MASK)
S    #define UART_1_BLE_SS0_M_HSIOM_POS        (UART_1_BLE_ss0_m__0__HSIOM_SHIFT)
S    #define UART_1_BLE_SS0_M_HSIOM_SEL_GPIO   (UART_1_BLE_ss0_m__0__HSIOM_GPIO)
S    #define UART_1_BLE_SS0_M_HSIOM_SEL_SPI    (UART_1_BLE_ss0_m__0__HSIOM_SPI)
N#endif /* (UART_1_BLE_SPI_MASTER_SS0_PIN) */
N
N#if (UART_1_BLE_SPI_MASTER_SS1_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_SS1_M_HSIOM_REG    (*(reg32 *) UART_1_BLE_ss1_m__0__HSIOM)
S    #define UART_1_BLE_SS1_M_HSIOM_PTR    ( (reg32 *) UART_1_BLE_ss1_m__0__HSIOM)
S    
S    #define UART_1_BLE_SS1_M_HSIOM_MASK       (UART_1_BLE_ss1_m__0__HSIOM_MASK)
S    #define UART_1_BLE_SS1_M_HSIOM_POS        (UART_1_BLE_ss1_m__0__HSIOM_SHIFT)
S    #define UART_1_BLE_SS1_M_HSIOM_SEL_GPIO   (UART_1_BLE_ss1_m__0__HSIOM_GPIO)
S    #define UART_1_BLE_SS1_M_HSIOM_SEL_SPI    (UART_1_BLE_ss1_m__0__HSIOM_SPI)
N#endif /* (UART_1_BLE_SPI_MASTER_SS1_PIN) */
N
N#if (UART_1_BLE_SPI_MASTER_SS2_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_SS2_M_HSIOM_REG    (*(reg32 *) UART_1_BLE_ss2_m__0__HSIOM)
S    #define UART_1_BLE_SS2_M_HSIOM_PTR    ( (reg32 *) UART_1_BLE_ss2_m__0__HSIOM)
S    
S    #define UART_1_BLE_SS2_M_HSIOM_MASK       (UART_1_BLE_ss2_m__0__HSIOM_MASK)
S    #define UART_1_BLE_SS2_M_HSIOM_POS        (UART_1_BLE_ss2_m__0__HSIOM_SHIFT)
S    #define UART_1_BLE_SS2_M_HSIOM_SEL_GPIO   (UART_1_BLE_ss2_m__0__HSIOM_GPIO)
S    #define UART_1_BLE_SS2_M_HSIOM_SEL_SPI    (UART_1_BLE_ss2_m__0__HSIOM_SPI)
N#endif /* (UART_1_BLE_SPI_MASTER_SS2_PIN) */
N
N#if (UART_1_BLE_SPI_MASTER_SS3_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_SS3_M_HSIOM_REG    (*(reg32 *) UART_1_BLE_ss3_m__0__HSIOM)
S    #define UART_1_BLE_SS3_M_HSIOM_PTR    ( (reg32 *) UART_1_BLE_ss3_m__0__HSIOM)
S    
S    #define UART_1_BLE_SS3_M_HSIOM_MASK      (UART_1_BLE_ss3_m__0__HSIOM_MASK)
S    #define UART_1_BLE_SS3_M_HSIOM_POS       (UART_1_BLE_ss3_m__0__HSIOM_SHIFT)
S    #define UART_1_BLE_SS3_M_HSIOM_SEL_GPIO  (UART_1_BLE_ss3_m__0__HSIOM_GPIO)
S    #define UART_1_BLE_SS3_M_HSIOM_SEL_SPI   (UART_1_BLE_ss3_m__0__HSIOM_SPI)
N#endif /* (UART_1_BLE_SPI_MASTER_SS3_PIN) */
N
N#if (UART_1_BLE_UART_RX_PIN)
X#if ((0u == (0u)))
N    #define UART_1_BLE_RX_HSIOM_REG   (*(reg32 *) UART_1_BLE_rx__0__HSIOM)
N    #define UART_1_BLE_RX_HSIOM_PTR   ( (reg32 *) UART_1_BLE_rx__0__HSIOM)
N    
N    #define UART_1_BLE_RX_HSIOM_MASK      (UART_1_BLE_rx__0__HSIOM_MASK)
N    #define UART_1_BLE_RX_HSIOM_POS       (UART_1_BLE_rx__0__HSIOM_SHIFT)
N    #define UART_1_BLE_RX_HSIOM_SEL_GPIO  (UART_1_BLE_rx__0__HSIOM_GPIO)
N    #define UART_1_BLE_RX_HSIOM_SEL_UART  (UART_1_BLE_rx__0__HSIOM_UART)
N#endif /* (UART_1_BLE_UART_RX_PIN) */
N
N#if (UART_1_BLE_UART_RX_WAKE_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_RX_WAKE_HSIOM_REG   (*(reg32 *) UART_1_BLE_rx_wake__0__HSIOM)
S    #define UART_1_BLE_RX_WAKE_HSIOM_PTR   ( (reg32 *) UART_1_BLE_rx_wake__0__HSIOM)
S    
S    #define UART_1_BLE_RX_WAKE_HSIOM_MASK      (UART_1_BLE_rx_wake__0__HSIOM_MASK)
S    #define UART_1_BLE_RX_WAKE_HSIOM_POS       (UART_1_BLE_rx_wake__0__HSIOM_SHIFT)
S    #define UART_1_BLE_RX_WAKE_HSIOM_SEL_GPIO  (UART_1_BLE_rx_wake__0__HSIOM_GPIO)
S    #define UART_1_BLE_RX_WAKE_HSIOM_SEL_UART  (UART_1_BLE_rx_wake__0__HSIOM_UART)
N#endif /* (UART_1_BLE_UART_WAKE_RX_PIN) */
N
N#if (UART_1_BLE_UART_CTS_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_CTS_HSIOM_REG   (*(reg32 *) UART_1_BLE_cts__0__HSIOM)
S    #define UART_1_BLE_CTS_HSIOM_PTR   ( (reg32 *) UART_1_BLE_cts__0__HSIOM)
S    
S    #define UART_1_BLE_CTS_HSIOM_MASK      (UART_1_BLE_cts__0__HSIOM_MASK)
S    #define UART_1_BLE_CTS_HSIOM_POS       (UART_1_BLE_cts__0__HSIOM_SHIFT)
S    #define UART_1_BLE_CTS_HSIOM_SEL_GPIO  (UART_1_BLE_cts__0__HSIOM_GPIO)
S    #define UART_1_BLE_CTS_HSIOM_SEL_UART  (UART_1_BLE_cts__0__HSIOM_UART)
N#endif /* (UART_1_BLE_UART_CTS_PIN) */
N
N#if (UART_1_BLE_UART_TX_PIN)
X#if ((0u == (0u)))
N    #define UART_1_BLE_TX_HSIOM_REG   (*(reg32 *) UART_1_BLE_tx__0__HSIOM)
N    #define UART_1_BLE_TX_HSIOM_PTR   ( (reg32 *) UART_1_BLE_tx__0__HSIOM)
N    
N    #define UART_1_BLE_TX_HSIOM_MASK      (UART_1_BLE_tx__0__HSIOM_MASK)
N    #define UART_1_BLE_TX_HSIOM_POS       (UART_1_BLE_tx__0__HSIOM_SHIFT)
N    #define UART_1_BLE_TX_HSIOM_SEL_GPIO  (UART_1_BLE_tx__0__HSIOM_GPIO)
N    #define UART_1_BLE_TX_HSIOM_SEL_UART  (UART_1_BLE_tx__0__HSIOM_UART)
N#endif /* (UART_1_BLE_UART_TX_PIN) */
N
N#if (UART_1_BLE_UART_RX_TX_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_RX_TX_HSIOM_REG   (*(reg32 *) UART_1_BLE_rx_tx__0__HSIOM)
S    #define UART_1_BLE_RX_TX_HSIOM_PTR   ( (reg32 *) UART_1_BLE_rx_tx__0__HSIOM)
S    
S    #define UART_1_BLE_RX_TX_HSIOM_MASK      (UART_1_BLE_rx_tx__0__HSIOM_MASK)
S    #define UART_1_BLE_RX_TX_HSIOM_POS       (UART_1_BLE_rx_tx__0__HSIOM_SHIFT)
S    #define UART_1_BLE_RX_TX_HSIOM_SEL_GPIO  (UART_1_BLE_rx_tx__0__HSIOM_GPIO)
S    #define UART_1_BLE_RX_TX_HSIOM_SEL_UART  (UART_1_BLE_rx_tx__0__HSIOM_UART)
N#endif /* (UART_1_BLE_UART_RX_TX_PIN) */
N
N#if (UART_1_BLE_UART_RTS_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_RTS_HSIOM_REG      (*(reg32 *) UART_1_BLE_rts__0__HSIOM)
S    #define UART_1_BLE_RTS_HSIOM_PTR      ( (reg32 *) UART_1_BLE_rts__0__HSIOM)
S    
S    #define UART_1_BLE_RTS_HSIOM_MASK     (UART_1_BLE_rts__0__HSIOM_MASK)
S    #define UART_1_BLE_RTS_HSIOM_POS      (UART_1_BLE_rts__0__HSIOM_SHIFT)    
S    #define UART_1_BLE_RTS_HSIOM_SEL_GPIO (UART_1_BLE_rts__0__HSIOM_GPIO)
S    #define UART_1_BLE_RTS_HSIOM_SEL_UART (UART_1_BLE_rts__0__HSIOM_UART)    
N#endif /* (UART_1_BLE_UART_RTS_PIN) */
N
N
N/***************************************
N*        Registers Constants
N***************************************/
N
N/* HSIOM switch values. */ 
N#define UART_1_BLE_HSIOM_DEF_SEL      (0x00u)
N#define UART_1_BLE_HSIOM_GPIO_SEL     (0x00u)
N/* The HSIOM values provided below are valid only for UART_1_BLE_CY_SCBIP_V0 
N* and UART_1_BLE_CY_SCBIP_V1. It is not recommended to use them for 
N* UART_1_BLE_CY_SCBIP_V2. Use pin name specific HSIOM constants provided 
N* above instead for any SCB IP block version.
N*/
N#define UART_1_BLE_HSIOM_UART_SEL     (0x09u)
N#define UART_1_BLE_HSIOM_I2C_SEL      (0x0Eu)
N#define UART_1_BLE_HSIOM_SPI_SEL      (0x0Fu)
N
N/* Pins settings index. */
N#define UART_1_BLE_RX_WAKE_SCL_MOSI_PIN_INDEX   (0u)
N#define UART_1_BLE_RX_SCL_MOSI_PIN_INDEX       (0u)
N#define UART_1_BLE_TX_SDA_MISO_PIN_INDEX       (1u)
N#define UART_1_BLE_CTS_SCLK_PIN_INDEX       (2u)
N#define UART_1_BLE_RTS_SS0_PIN_INDEX       (3u)
N#define UART_1_BLE_SS1_PIN_INDEX                  (4u)
N#define UART_1_BLE_SS2_PIN_INDEX                  (5u)
N#define UART_1_BLE_SS3_PIN_INDEX                  (6u)
N
N/* Pins settings mask. */
N#define UART_1_BLE_RX_WAKE_SCL_MOSI_PIN_MASK ((uint32) 0x01u << UART_1_BLE_RX_WAKE_SCL_MOSI_PIN_INDEX)
N#define UART_1_BLE_RX_SCL_MOSI_PIN_MASK     ((uint32) 0x01u << UART_1_BLE_RX_SCL_MOSI_PIN_INDEX)
N#define UART_1_BLE_TX_SDA_MISO_PIN_MASK     ((uint32) 0x01u << UART_1_BLE_TX_SDA_MISO_PIN_INDEX)
N#define UART_1_BLE_CTS_SCLK_PIN_MASK     ((uint32) 0x01u << UART_1_BLE_CTS_SCLK_PIN_INDEX)
N#define UART_1_BLE_RTS_SS0_PIN_MASK     ((uint32) 0x01u << UART_1_BLE_RTS_SS0_PIN_INDEX)
N#define UART_1_BLE_SS1_PIN_MASK                ((uint32) 0x01u << UART_1_BLE_SS1_PIN_INDEX)
N#define UART_1_BLE_SS2_PIN_MASK                ((uint32) 0x01u << UART_1_BLE_SS2_PIN_INDEX)
N#define UART_1_BLE_SS3_PIN_MASK                ((uint32) 0x01u << UART_1_BLE_SS3_PIN_INDEX)
N
N/* Pin interrupt constants. */
N#define UART_1_BLE_INTCFG_TYPE_MASK           (0x03u)
N#define UART_1_BLE_INTCFG_TYPE_FALLING_EDGE   (0x02u)
N
N/* Pin Drive Mode constants. */
N#define UART_1_BLE_PIN_DM_ALG_HIZ  (0u)
N#define UART_1_BLE_PIN_DM_DIG_HIZ  (1u)
N#define UART_1_BLE_PIN_DM_OD_LO    (4u)
N#define UART_1_BLE_PIN_DM_STRONG   (6u)
N
N
N/***************************************
N*          Macro Definitions
N***************************************/
N
N/* Return drive mode of the pin */
N#define UART_1_BLE_DM_MASK    (0x7u)
N#define UART_1_BLE_DM_SIZE    (3u)
N#define UART_1_BLE_GET_P4_PIN_DM(reg, pos) \
N    ( ((reg) & (uint32) ((uint32) UART_1_BLE_DM_MASK << (UART_1_BLE_DM_SIZE * (pos)))) >> \
N                                                              (UART_1_BLE_DM_SIZE * (pos)) )
X#define UART_1_BLE_GET_P4_PIN_DM(reg, pos)     ( ((reg) & (uint32) ((uint32) UART_1_BLE_DM_MASK << (UART_1_BLE_DM_SIZE * (pos)))) >>                                                               (UART_1_BLE_DM_SIZE * (pos)) )
N
N#if (UART_1_BLE_TX_SDA_MISO_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_CHECK_TX_SDA_MISO_PIN_USED \
S                (UART_1_BLE_PIN_DM_ALG_HIZ != \
S                    UART_1_BLE_GET_P4_PIN_DM(UART_1_BLE_uart_tx_i2c_sda_spi_miso_PC, \
S                                                   UART_1_BLE_uart_tx_i2c_sda_spi_miso_SHIFT))
X    #define UART_1_BLE_CHECK_TX_SDA_MISO_PIN_USED                 (UART_1_BLE_PIN_DM_ALG_HIZ !=                     UART_1_BLE_GET_P4_PIN_DM(UART_1_BLE_uart_tx_i2c_sda_spi_miso_PC,                                                    UART_1_BLE_uart_tx_i2c_sda_spi_miso_SHIFT))
N#endif /* (UART_1_BLE_TX_SDA_MISO_PIN) */
N
N#if (UART_1_BLE_RTS_SS0_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_CHECK_RTS_SS0_PIN_USED \
S                (UART_1_BLE_PIN_DM_ALG_HIZ != \
S                    UART_1_BLE_GET_P4_PIN_DM(UART_1_BLE_uart_rts_spi_ss0_PC, \
S                                                   UART_1_BLE_uart_rts_spi_ss0_SHIFT))
X    #define UART_1_BLE_CHECK_RTS_SS0_PIN_USED                 (UART_1_BLE_PIN_DM_ALG_HIZ !=                     UART_1_BLE_GET_P4_PIN_DM(UART_1_BLE_uart_rts_spi_ss0_PC,                                                    UART_1_BLE_uart_rts_spi_ss0_SHIFT))
N#endif /* (UART_1_BLE_RTS_SS0_PIN) */
N
N/* Set bits-mask in register */
N#define UART_1_BLE_SET_REGISTER_BITS(reg, mask, pos, mode) \
N                    do                                           \
N                    {                                            \
N                        (reg) = (((reg) & ((uint32) ~(uint32) (mask))) | ((uint32) ((uint32) (mode) << (pos)))); \
N                    }while(0)
X#define UART_1_BLE_SET_REGISTER_BITS(reg, mask, pos, mode)                     do                                                               {                                                                    (reg) = (((reg) & ((uint32) ~(uint32) (mask))) | ((uint32) ((uint32) (mode) << (pos))));                     }while(0)
N
N/* Set bit in the register */
N#define UART_1_BLE_SET_REGISTER_BIT(reg, mask, val) \
N                    ((val) ? ((reg) |= (mask)) : ((reg) &= ((uint32) ~((uint32) (mask)))))
X#define UART_1_BLE_SET_REGISTER_BIT(reg, mask, val)                     ((val) ? ((reg) |= (mask)) : ((reg) &= ((uint32) ~((uint32) (mask)))))
N
N#define UART_1_BLE_SET_HSIOM_SEL(reg, mask, pos, sel) UART_1_BLE_SET_REGISTER_BITS(reg, mask, pos, sel)
N#define UART_1_BLE_SET_INCFG_TYPE(reg, mask, pos, intType) \
N                                                        UART_1_BLE_SET_REGISTER_BITS(reg, mask, pos, intType)
X#define UART_1_BLE_SET_INCFG_TYPE(reg, mask, pos, intType)                                                         UART_1_BLE_SET_REGISTER_BITS(reg, mask, pos, intType)
N#define UART_1_BLE_SET_INP_DIS(reg, mask, val) UART_1_BLE_SET_REGISTER_BIT(reg, mask, val)
N
N/* UART_1_BLE_SET_I2C_SCL_DR(val) - Sets I2C SCL DR register.
N*  UART_1_BLE_SET_I2C_SCL_HSIOM_SEL(sel) - Sets I2C SCL HSIOM settings.
N*/
N/* SCB I2C: scl signal */
N#if (UART_1_BLE_CY_SCBIP_V0)
X#if ((2 == 0u))
S#if (UART_1_BLE_I2C_PINS)
S    #define UART_1_BLE_SET_I2C_SCL_DR(val) UART_1_BLE_scl_Write(val)
S
S    #define UART_1_BLE_SET_I2C_SCL_HSIOM_SEL(sel) \
S                          UART_1_BLE_SET_HSIOM_SEL(UART_1_BLE_SCL_HSIOM_REG,  \
S                                                         UART_1_BLE_SCL_HSIOM_MASK, \
S                                                         UART_1_BLE_SCL_HSIOM_POS,  \
S                                                         (sel))
X    #define UART_1_BLE_SET_I2C_SCL_HSIOM_SEL(sel)                           UART_1_BLE_SET_HSIOM_SEL(UART_1_BLE_SCL_HSIOM_REG,                                                           UART_1_BLE_SCL_HSIOM_MASK,                                                          UART_1_BLE_SCL_HSIOM_POS,                                                           (sel))
S    #define UART_1_BLE_WAIT_SCL_SET_HIGH  (0u == UART_1_BLE_scl_Read())
S
S/* Unconfigured SCB: scl signal */
S#elif (UART_1_BLE_RX_WAKE_SCL_MOSI_PIN)
S    #define UART_1_BLE_SET_I2C_SCL_DR(val) \
S                            UART_1_BLE_uart_rx_wake_i2c_scl_spi_mosi_Write(val)
X    #define UART_1_BLE_SET_I2C_SCL_DR(val)                             UART_1_BLE_uart_rx_wake_i2c_scl_spi_mosi_Write(val)
S
S    #define UART_1_BLE_SET_I2C_SCL_HSIOM_SEL(sel) \
S                    UART_1_BLE_SET_HSIOM_SEL(UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_REG,  \
S                                                   UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_MASK, \
S                                                   UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_POS,  \
S                                                   (sel))
X    #define UART_1_BLE_SET_I2C_SCL_HSIOM_SEL(sel)                     UART_1_BLE_SET_HSIOM_SEL(UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_REG,                                                     UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_MASK,                                                    UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_POS,                                                     (sel))
S
S    #define UART_1_BLE_WAIT_SCL_SET_HIGH  (0u == UART_1_BLE_uart_rx_wake_i2c_scl_spi_mosi_Read())
S
S#elif (UART_1_BLE_RX_SCL_MOSI_PIN)
S    #define UART_1_BLE_SET_I2C_SCL_DR(val) \
S                            UART_1_BLE_uart_rx_i2c_scl_spi_mosi_Write(val)
X    #define UART_1_BLE_SET_I2C_SCL_DR(val)                             UART_1_BLE_uart_rx_i2c_scl_spi_mosi_Write(val)
S
S
S    #define UART_1_BLE_SET_I2C_SCL_HSIOM_SEL(sel) \
S                            UART_1_BLE_SET_HSIOM_SEL(UART_1_BLE_RX_SCL_MOSI_HSIOM_REG,  \
S                                                           UART_1_BLE_RX_SCL_MOSI_HSIOM_MASK, \
S                                                           UART_1_BLE_RX_SCL_MOSI_HSIOM_POS,  \
S                                                           (sel))
X    #define UART_1_BLE_SET_I2C_SCL_HSIOM_SEL(sel)                             UART_1_BLE_SET_HSIOM_SEL(UART_1_BLE_RX_SCL_MOSI_HSIOM_REG,                                                             UART_1_BLE_RX_SCL_MOSI_HSIOM_MASK,                                                            UART_1_BLE_RX_SCL_MOSI_HSIOM_POS,                                                             (sel))
S
S    #define UART_1_BLE_WAIT_SCL_SET_HIGH  (0u == UART_1_BLE_uart_rx_i2c_scl_spi_mosi_Read())
S
S#else
S    #define UART_1_BLE_SET_I2C_SCL_DR(val)        do{ /* Does nothing */ }while(0)
S    #define UART_1_BLE_SET_I2C_SCL_HSIOM_SEL(sel) do{ /* Does nothing */ }while(0)
S
S    #define UART_1_BLE_WAIT_SCL_SET_HIGH  (0u)
S#endif /* (UART_1_BLE_I2C_PINS) */
S
S/* SCB I2C: sda signal */
S#if (UART_1_BLE_I2C_PINS)
S    #define UART_1_BLE_WAIT_SDA_SET_HIGH  (0u == UART_1_BLE_sda_Read())
S/* Unconfigured SCB: sda signal */
S#elif (UART_1_BLE_TX_SDA_MISO_PIN)
S    #define UART_1_BLE_WAIT_SDA_SET_HIGH  (0u == UART_1_BLE_uart_tx_i2c_sda_spi_miso_Read())
S#else
S    #define UART_1_BLE_WAIT_SDA_SET_HIGH  (0u)
S#endif /* (UART_1_BLE_MOSI_SCL_RX_PIN) */
N#endif /* (UART_1_BLE_CY_SCBIP_V0) */
N
N/* Clear UART wakeup source */
N#if (UART_1_BLE_RX_SCL_MOSI_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_CLEAR_UART_RX_WAKE_INTR        do{ /* Does nothing */ }while(0)
S    
S#elif (UART_1_BLE_RX_WAKE_SCL_MOSI_PIN)
X#elif ((0u == (1u)))
S    #define UART_1_BLE_CLEAR_UART_RX_WAKE_INTR \
S            do{                                      \
S                (void) UART_1_BLE_uart_rx_wake_i2c_scl_spi_mosi_ClearInterrupt(); \
S            }while(0)
X    #define UART_1_BLE_CLEAR_UART_RX_WAKE_INTR             do{                                                      (void) UART_1_BLE_uart_rx_wake_i2c_scl_spi_mosi_ClearInterrupt();             }while(0)
S
S#elif(UART_1_BLE_UART_RX_WAKE_PIN)
X#elif((0u == (1u)))
S    #define UART_1_BLE_CLEAR_UART_RX_WAKE_INTR \
S            do{                                      \
S                (void) UART_1_BLE_rx_wake_ClearInterrupt(); \
S            }while(0)
X    #define UART_1_BLE_CLEAR_UART_RX_WAKE_INTR             do{                                                      (void) UART_1_BLE_rx_wake_ClearInterrupt();             }while(0)
N#else
N#endif /* (UART_1_BLE_RX_SCL_MOSI_PIN) */
N
N
N/***************************************
N* The following code is DEPRECATED and
N* must not be used.
N***************************************/
N
N/* Unconfigured pins */
N#define UART_1_BLE_REMOVE_MOSI_SCL_RX_WAKE_PIN    UART_1_BLE_REMOVE_RX_WAKE_SCL_MOSI_PIN
N#define UART_1_BLE_REMOVE_MOSI_SCL_RX_PIN         UART_1_BLE_REMOVE_RX_SCL_MOSI_PIN
N#define UART_1_BLE_REMOVE_MISO_SDA_TX_PIN         UART_1_BLE_REMOVE_TX_SDA_MISO_PIN
N#ifndef UART_1_BLE_REMOVE_SCLK_PIN
N#define UART_1_BLE_REMOVE_SCLK_PIN                UART_1_BLE_REMOVE_CTS_SCLK_PIN
N#endif /* UART_1_BLE_REMOVE_SCLK_PIN */
N#ifndef UART_1_BLE_REMOVE_SS0_PIN
N#define UART_1_BLE_REMOVE_SS0_PIN                 UART_1_BLE_REMOVE_RTS_SS0_PIN
N#endif /* UART_1_BLE_REMOVE_SS0_PIN */
N
N/* Unconfigured pins */
N#define UART_1_BLE_MOSI_SCL_RX_WAKE_PIN   UART_1_BLE_RX_WAKE_SCL_MOSI_PIN
N#define UART_1_BLE_MOSI_SCL_RX_PIN        UART_1_BLE_RX_SCL_MOSI_PIN
N#define UART_1_BLE_MISO_SDA_TX_PIN        UART_1_BLE_TX_SDA_MISO_PIN
N#ifndef UART_1_BLE_SCLK_PIN
N#define UART_1_BLE_SCLK_PIN               UART_1_BLE_CTS_SCLK_PIN
N#endif /* UART_1_BLE_SCLK_PIN */
N#ifndef UART_1_BLE_SS0_PIN
N#define UART_1_BLE_SS0_PIN                UART_1_BLE_RTS_SS0_PIN
N#endif /* UART_1_BLE_SS0_PIN */
N
N#if (UART_1_BLE_MOSI_SCL_RX_WAKE_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_MOSI_SCL_RX_WAKE_HSIOM_REG     UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define UART_1_BLE_MOSI_SCL_RX_WAKE_HSIOM_PTR     UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define UART_1_BLE_MOSI_SCL_RX_WAKE_HSIOM_MASK    UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define UART_1_BLE_MOSI_SCL_RX_WAKE_HSIOM_POS     UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_REG
S
S    #define UART_1_BLE_MOSI_SCL_RX_WAKE_INTCFG_REG    UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define UART_1_BLE_MOSI_SCL_RX_WAKE_INTCFG_PTR    UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_REG
S
S    #define UART_1_BLE_MOSI_SCL_RX_WAKE_INTCFG_TYPE_POS   UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define UART_1_BLE_MOSI_SCL_RX_WAKE_INTCFG_TYPE_MASK  UART_1_BLE_RX_WAKE_SCL_MOSI_HSIOM_REG
N#endif /* (UART_1_BLE_RX_WAKE_SCL_MOSI_PIN) */
N
N#if (UART_1_BLE_MOSI_SCL_RX_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_MOSI_SCL_RX_HSIOM_REG      UART_1_BLE_RX_SCL_MOSI_HSIOM_REG
S    #define UART_1_BLE_MOSI_SCL_RX_HSIOM_PTR      UART_1_BLE_RX_SCL_MOSI_HSIOM_PTR
S    #define UART_1_BLE_MOSI_SCL_RX_HSIOM_MASK     UART_1_BLE_RX_SCL_MOSI_HSIOM_MASK
S    #define UART_1_BLE_MOSI_SCL_RX_HSIOM_POS      UART_1_BLE_RX_SCL_MOSI_HSIOM_POS
N#endif /* (UART_1_BLE_MOSI_SCL_RX_PIN) */
N
N#if (UART_1_BLE_MISO_SDA_TX_PIN)
X#if ((0u == (1u)))
S    #define UART_1_BLE_MISO_SDA_TX_HSIOM_REG      UART_1_BLE_TX_SDA_MISO_HSIOM_REG
S    #define UART_1_BLE_MISO_SDA_TX_HSIOM_PTR      UART_1_BLE_TX_SDA_MISO_HSIOM_REG
S    #define UART_1_BLE_MISO_SDA_TX_HSIOM_MASK     UART_1_BLE_TX_SDA_MISO_HSIOM_REG
S    #define UART_1_BLE_MISO_SDA_TX_HSIOM_POS      UART_1_BLE_TX_SDA_MISO_HSIOM_REG
N#endif /* (UART_1_BLE_MISO_SDA_TX_PIN_PIN) */
N
N#if (UART_1_BLE_SCLK_PIN)
X#if ((0u == (1u)))
S    #ifndef UART_1_BLE_SCLK_HSIOM_REG
S    #define UART_1_BLE_SCLK_HSIOM_REG     UART_1_BLE_CTS_SCLK_HSIOM_REG
S    #define UART_1_BLE_SCLK_HSIOM_PTR     UART_1_BLE_CTS_SCLK_HSIOM_PTR
S    #define UART_1_BLE_SCLK_HSIOM_MASK    UART_1_BLE_CTS_SCLK_HSIOM_MASK
S    #define UART_1_BLE_SCLK_HSIOM_POS     UART_1_BLE_CTS_SCLK_HSIOM_POS
S    #endif /* UART_1_BLE_SCLK_HSIOM_REG */
N#endif /* (UART_1_BLE_SCLK_PIN) */
N
N#if (UART_1_BLE_SS0_PIN)
X#if ((0u == (1u)))
S    #ifndef UART_1_BLE_SS0_HSIOM_REG
S    #define UART_1_BLE_SS0_HSIOM_REG      UART_1_BLE_RTS_SS0_HSIOM_REG
S    #define UART_1_BLE_SS0_HSIOM_PTR      UART_1_BLE_RTS_SS0_HSIOM_PTR
S    #define UART_1_BLE_SS0_HSIOM_MASK     UART_1_BLE_RTS_SS0_HSIOM_MASK
S    #define UART_1_BLE_SS0_HSIOM_POS      UART_1_BLE_RTS_SS0_HSIOM_POS
S    #endif /* UART_1_BLE_SS0_HSIOM_REG */
N#endif /* (UART_1_BLE_SS0_PIN) */
N
N#define UART_1_BLE_MOSI_SCL_RX_WAKE_PIN_INDEX UART_1_BLE_RX_WAKE_SCL_MOSI_PIN_INDEX
N#define UART_1_BLE_MOSI_SCL_RX_PIN_INDEX      UART_1_BLE_RX_SCL_MOSI_PIN_INDEX
N#define UART_1_BLE_MISO_SDA_TX_PIN_INDEX      UART_1_BLE_TX_SDA_MISO_PIN_INDEX
N#ifndef UART_1_BLE_SCLK_PIN_INDEX
N#define UART_1_BLE_SCLK_PIN_INDEX             UART_1_BLE_CTS_SCLK_PIN_INDEX
N#endif /* UART_1_BLE_SCLK_PIN_INDEX */
N#ifndef UART_1_BLE_SS0_PIN_INDEX
N#define UART_1_BLE_SS0_PIN_INDEX              UART_1_BLE_RTS_SS0_PIN_INDEX
N#endif /* UART_1_BLE_SS0_PIN_INDEX */
N
N#define UART_1_BLE_MOSI_SCL_RX_WAKE_PIN_MASK UART_1_BLE_RX_WAKE_SCL_MOSI_PIN_MASK
N#define UART_1_BLE_MOSI_SCL_RX_PIN_MASK      UART_1_BLE_RX_SCL_MOSI_PIN_MASK
N#define UART_1_BLE_MISO_SDA_TX_PIN_MASK      UART_1_BLE_TX_SDA_MISO_PIN_MASK
N#ifndef UART_1_BLE_SCLK_PIN_MASK
N#define UART_1_BLE_SCLK_PIN_MASK             UART_1_BLE_CTS_SCLK_PIN_MASK
N#endif /* UART_1_BLE_SCLK_PIN_MASK */
N#ifndef UART_1_BLE_SS0_PIN_MASK
N#define UART_1_BLE_SS0_PIN_MASK              UART_1_BLE_RTS_SS0_PIN_MASK
N#endif /* UART_1_BLE_SS0_PIN_MASK */
N
N#endif /* (CY_SCB_PINS_UART_1_BLE_H) */
N
N
N/* [] END OF FILE */
L 86 "Generated_Source\PSoC4\UART_1_BLE.h" 2
N
N#if (UART_1_BLE_SCB_CLK_INTERNAL)
X#if ((0u == (0u)))
N    #include "UART_1_BLE_SCBCLK.h"
L 1 "Generated_Source\PSoC4\UART_1_BLE_SCBCLK.h" 1
N/*******************************************************************************
N* File Name: UART_1_BLE_SCBCLK.h
N* Version 2.20
N*
N*  Description:
N*   Provides the function and constant definitions for the clock component.
N*
N*  Note:
N*
N********************************************************************************
N* Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_CLOCK_UART_1_BLE_SCBCLK_H)
X#if !0L
N#define CY_CLOCK_UART_1_BLE_SCBCLK_H
N
N#include <cytypes.h>
N#include <cyfitter.h>
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N#if defined CYREG_PERI_DIV_CMD
X#if 1L
N
Nvoid UART_1_BLE_SCBCLK_StartEx(uint32 alignClkDiv);
N#define UART_1_BLE_SCBCLK_Start() \
N    UART_1_BLE_SCBCLK_StartEx(UART_1_BLE_SCBCLK__PA_DIV_ID)
X#define UART_1_BLE_SCBCLK_Start()     UART_1_BLE_SCBCLK_StartEx(UART_1_BLE_SCBCLK__PA_DIV_ID)
N
N#else
S
Svoid UART_1_BLE_SCBCLK_Start(void);
S
N#endif/* CYREG_PERI_DIV_CMD */
N
Nvoid UART_1_BLE_SCBCLK_Stop(void);
N
Nvoid UART_1_BLE_SCBCLK_SetFractionalDividerRegister(uint16 clkDivider, uint8 clkFractional);
N
Nuint16 UART_1_BLE_SCBCLK_GetDividerRegister(void);
Nuint8  UART_1_BLE_SCBCLK_GetFractionalDividerRegister(void);
N
N#define UART_1_BLE_SCBCLK_Enable()                         UART_1_BLE_SCBCLK_Start()
N#define UART_1_BLE_SCBCLK_Disable()                        UART_1_BLE_SCBCLK_Stop()
N#define UART_1_BLE_SCBCLK_SetDividerRegister(clkDivider, reset)  \
N    UART_1_BLE_SCBCLK_SetFractionalDividerRegister((clkDivider), 0u)
X#define UART_1_BLE_SCBCLK_SetDividerRegister(clkDivider, reset)      UART_1_BLE_SCBCLK_SetFractionalDividerRegister((clkDivider), 0u)
N#define UART_1_BLE_SCBCLK_SetDivider(clkDivider)           UART_1_BLE_SCBCLK_SetDividerRegister((clkDivider), 1u)
N#define UART_1_BLE_SCBCLK_SetDividerValue(clkDivider)      UART_1_BLE_SCBCLK_SetDividerRegister((clkDivider) - 1u, 1u)
N
N
N/***************************************
N*             Registers
N***************************************/
N#if defined CYREG_PERI_DIV_CMD
X#if 1L
N
N#define UART_1_BLE_SCBCLK_DIV_ID     UART_1_BLE_SCBCLK__DIV_ID
N
N#define UART_1_BLE_SCBCLK_CMD_REG    (*(reg32 *)CYREG_PERI_DIV_CMD)
N#define UART_1_BLE_SCBCLK_CTRL_REG   (*(reg32 *)UART_1_BLE_SCBCLK__CTRL_REGISTER)
N#define UART_1_BLE_SCBCLK_DIV_REG    (*(reg32 *)UART_1_BLE_SCBCLK__DIV_REGISTER)
N
N#define UART_1_BLE_SCBCLK_CMD_DIV_SHIFT          (0u)
N#define UART_1_BLE_SCBCLK_CMD_PA_DIV_SHIFT       (8u)
N#define UART_1_BLE_SCBCLK_CMD_DISABLE_SHIFT      (30u)
N#define UART_1_BLE_SCBCLK_CMD_ENABLE_SHIFT       (31u)
N
N#define UART_1_BLE_SCBCLK_CMD_DISABLE_MASK       ((uint32)((uint32)1u << UART_1_BLE_SCBCLK_CMD_DISABLE_SHIFT))
N#define UART_1_BLE_SCBCLK_CMD_ENABLE_MASK        ((uint32)((uint32)1u << UART_1_BLE_SCBCLK_CMD_ENABLE_SHIFT))
N
N#define UART_1_BLE_SCBCLK_DIV_FRAC_MASK  (0x000000F8u)
N#define UART_1_BLE_SCBCLK_DIV_FRAC_SHIFT (3u)
N#define UART_1_BLE_SCBCLK_DIV_INT_MASK   (0xFFFFFF00u)
N#define UART_1_BLE_SCBCLK_DIV_INT_SHIFT  (8u)
N
N#else 
S
S#define UART_1_BLE_SCBCLK_DIV_REG        (*(reg32 *)UART_1_BLE_SCBCLK__REGISTER)
S#define UART_1_BLE_SCBCLK_ENABLE_REG     UART_1_BLE_SCBCLK_DIV_REG
S#define UART_1_BLE_SCBCLK_DIV_FRAC_MASK  UART_1_BLE_SCBCLK__FRAC_MASK
S#define UART_1_BLE_SCBCLK_DIV_FRAC_SHIFT (16u)
S#define UART_1_BLE_SCBCLK_DIV_INT_MASK   UART_1_BLE_SCBCLK__DIVIDER_MASK
S#define UART_1_BLE_SCBCLK_DIV_INT_SHIFT  (0u)
S
N#endif/* CYREG_PERI_DIV_CMD */
N
N#endif /* !defined(CY_CLOCK_UART_1_BLE_SCBCLK_H) */
N
N/* [] END OF FILE */
L 89 "Generated_Source\PSoC4\UART_1_BLE.h" 2
N#endif /* (UART_1_BLE_SCB_CLK_INTERNAL) */
N
N
N/***************************************
N*       Type Definitions
N***************************************/
N
Ntypedef struct
N{
N    uint8 enableState;
N} UART_1_BLE_BACKUP_STRUCT;
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
N/**
N* \addtogroup group_general
N* @{
N*/
N
N/* Start and Stop APIs */
Nvoid UART_1_BLE_Init(void);
Nvoid UART_1_BLE_Enable(void);
Nvoid UART_1_BLE_Start(void);
Nvoid UART_1_BLE_Stop(void);
N
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
N/* Sleep and Wakeup APis */
Nvoid UART_1_BLE_Sleep(void);
Nvoid UART_1_BLE_Wakeup(void);
N/** @} power */ 
N
N/**
N* \addtogroup group_interrupt
N* @{
N*/
N#if (UART_1_BLE_SCB_IRQ_INTERNAL)
X#if ((0u == (0u)))
N    /* Custom interrupt handler */
N    void UART_1_BLE_SetCustomInterruptHandler(void (*func)(void));
N#endif /* (UART_1_BLE_SCB_IRQ_INTERNAL) */
N/** @} interrupt */
N
N/* Interface to internal interrupt component */
N#if (UART_1_BLE_SCB_IRQ_INTERNAL)
X#if ((0u == (0u)))
N    /**
N    * \addtogroup group_interrupt
N    * @{
N    */    
N    /*******************************************************************************
N    * Function Name: UART_1_BLE_EnableInt
N    ****************************************************************************//**
N    *
N    *  When using an Internal interrupt, this enables the interrupt in the NVIC. 
N    *  When using an external interrupt the API for the interrupt component must 
N    *  be used to enable the interrupt.
N    *
N    *******************************************************************************/
N    #define UART_1_BLE_EnableInt()    CyIntEnable(UART_1_BLE_ISR_NUMBER)
N    
N    
N    /*******************************************************************************
N    * Function Name: UART_1_BLE_DisableInt
N    ****************************************************************************//**
N    *
N    *  When using an Internal interrupt, this disables the interrupt in the NVIC. 
N    *  When using an external interrupt the API for the interrupt component must 
N    *  be used to disable the interrupt.
N    *
N    *******************************************************************************/    
N    #define UART_1_BLE_DisableInt()   CyIntDisable(UART_1_BLE_ISR_NUMBER)
N    /** @} interrupt */
N
N    /*******************************************************************************
N    * Function Name: UART_1_BLE_ClearPendingInt
N    ****************************************************************************//**
N    *
N    *  This function clears the interrupt pending status in the NVIC. 
N    *
N    *******************************************************************************/
N    #define UART_1_BLE_ClearPendingInt()  CyIntClearPending(UART_1_BLE_ISR_NUMBER)
N#endif /* (UART_1_BLE_SCB_IRQ_INTERNAL) */
N
N#if (UART_1_BLE_UART_RX_WAKEUP_IRQ)
X#if ((0u == (1u)))
S    /*******************************************************************************
S    * Function Name: UART_1_BLE_RxWakeEnableInt
S    ****************************************************************************//**
S    *
S    *  This function enables the interrupt (RX_WAKE) pending status in the NVIC. 
S    *
S    *******************************************************************************/    
S    #define UART_1_BLE_RxWakeEnableInt()  CyIntEnable(UART_1_BLE_RX_WAKE_ISR_NUMBER)
S    
S
S    /*******************************************************************************
S    * Function Name: UART_1_BLE_RxWakeDisableInt
S    ****************************************************************************//**
S    *
S    *  This function disables the interrupt (RX_WAKE) pending status in the NVIC.  
S    *
S    *******************************************************************************/
S    #define UART_1_BLE_RxWakeDisableInt() CyIntDisable(UART_1_BLE_RX_WAKE_ISR_NUMBER)
S    
S    
S    /*******************************************************************************
S    * Function Name: UART_1_BLE_RxWakeClearPendingInt
S    ****************************************************************************//**
S    *
S    *  This function clears the interrupt (RX_WAKE) pending status in the NVIC. 
S    *
S    *******************************************************************************/    
S    #define UART_1_BLE_RxWakeClearPendingInt()  CyIntClearPending(UART_1_BLE_RX_WAKE_ISR_NUMBER)
N#endif /* (UART_1_BLE_UART_RX_WAKEUP_IRQ) */
N
N/**
N* \addtogroup group_interrupt
N* @{
N*/
N/* Get interrupt cause */
N/*******************************************************************************
N* Function Name: UART_1_BLE_GetInterruptCause
N****************************************************************************//**
N*
N*  Returns a mask of bits showing the source of the current triggered interrupt. 
N*  This is useful for modes of operation where an interrupt can be generated by 
N*  conditions in multiple interrupt source registers.
N*
N*  \return
N*   Mask with the OR of the following conditions that have been triggered.
N*    - UART_1_BLE_INTR_CAUSE_MASTER - Interrupt from Master
N*    - UART_1_BLE_INTR_CAUSE_SLAVE - Interrupt from Slave
N*    - UART_1_BLE_INTR_CAUSE_TX - Interrupt from TX
N*    - UART_1_BLE_INTR_CAUSE_RX - Interrupt from RX
N*
N*******************************************************************************/
N#define UART_1_BLE_GetInterruptCause()    (UART_1_BLE_INTR_CAUSE_REG)
N
N
N/* APIs to service INTR_RX register */
N/*******************************************************************************
N* Function Name: UART_1_BLE_GetRxInterruptSource
N****************************************************************************//**
N*
N*  Returns RX interrupt request register. This register contains current status 
N*  of RX interrupt sources.
N*
N*  \return
N*   Current status of RX interrupt sources.
N*   Each constant is a bit field value. The value returned may have multiple 
N*   bits set to indicate the current status.
N*   - UART_1_BLE_INTR_RX_FIFO_LEVEL - The number of data elements in the 
N      RX FIFO is greater than the value of RX FIFO level.
N*   - UART_1_BLE_INTR_RX_NOT_EMPTY - Receiver FIFO is not empty.
N*   - UART_1_BLE_INTR_RX_FULL - Receiver FIFO is full.
N*   - UART_1_BLE_INTR_RX_OVERFLOW - Attempt to write to a full 
N*     receiver FIFO.
N*   - UART_1_BLE_INTR_RX_UNDERFLOW - Attempt to read from an empty 
N*     receiver FIFO.
N*   - UART_1_BLE_INTR_RX_FRAME_ERROR - UART framing error detected.
N*   - UART_1_BLE_INTR_RX_PARITY_ERROR - UART parity error detected.
N*
N*******************************************************************************/
N#define UART_1_BLE_GetRxInterruptSource() (UART_1_BLE_INTR_RX_REG)
N
N
N/*******************************************************************************
N* Function Name: UART_1_BLE_SetRxInterruptMode
N****************************************************************************//**
N*
N*  Writes RX interrupt mask register. This register configures which bits from 
N*  RX interrupt request register will trigger an interrupt event.
N*
N*  \param interruptMask: RX interrupt sources to be enabled (refer to 
N*   UART_1_BLE_GetRxInterruptSource() function for bit fields values).
N*
N*******************************************************************************/
N#define UART_1_BLE_SetRxInterruptMode(interruptMask)     UART_1_BLE_WRITE_INTR_RX_MASK(interruptMask)
N
N
N/*******************************************************************************
N* Function Name: UART_1_BLE_GetRxInterruptMode
N****************************************************************************//**
N*
N*  Returns RX interrupt mask register This register specifies which bits from 
N*  RX interrupt request register will trigger an interrupt event.
N*
N*  \return 
N*   RX interrupt sources to be enabled (refer to 
N*   UART_1_BLE_GetRxInterruptSource() function for bit fields values).
N*
N*******************************************************************************/
N#define UART_1_BLE_GetRxInterruptMode()   (UART_1_BLE_INTR_RX_MASK_REG)
N
N
N/*******************************************************************************
N* Function Name: UART_1_BLE_GetRxInterruptSourceMasked
N****************************************************************************//**
N*
N*  Returns RX interrupt masked request register. This register contains logical
N*  AND of corresponding bits from RX interrupt request and mask registers.
N*  This function is intended to be used in the interrupt service routine to 
N*  identify which of enabled RX interrupt sources cause interrupt event.
N*
N*  \return 
N*   Current status of enabled RX interrupt sources (refer to 
N*   UART_1_BLE_GetRxInterruptSource() function for bit fields values).
N*
N*******************************************************************************/
N#define UART_1_BLE_GetRxInterruptSourceMasked()   (UART_1_BLE_INTR_RX_MASKED_REG)
N
N
N/*******************************************************************************
N* Function Name: UART_1_BLE_ClearRxInterruptSource
N****************************************************************************//**
N*
N*  Clears RX interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: RX interrupt sources to be cleared (refer to 
N*   UART_1_BLE_GetRxInterruptSource() function for bit fields values).
N*
N*  \sideeffects 
N*   The side effects are listed in the table below for each 
N*   affected interrupt source. Refer to section RX FIFO interrupt sources for 
N*   detailed description.
N*   - UART_1_BLE_INTR_RX_FIFO_LEVEL Interrupt source is not cleared when 
N*     the receiver FIFO has more entries than level.
N*   - UART_1_BLE_INTR_RX_NOT_EMPTY Interrupt source is not cleared when
N*     receiver FIFO is not empty.
N*   - UART_1_BLE_INTR_RX_FULL Interrupt source is not cleared when 
N*      receiver FIFO is full.
N*
N*******************************************************************************/
N#define UART_1_BLE_ClearRxInterruptSource(interruptMask)  UART_1_BLE_CLEAR_INTR_RX(interruptMask)
N
N
N/*******************************************************************************
N* Function Name: UART_1_BLE_SetRxInterrupt
N****************************************************************************//**
N*
N*  Sets RX interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: RX interrupt sources to set in the RX interrupt request 
N*   register (refer to UART_1_BLE_GetRxInterruptSource() function for bit 
N*   fields values).
N*
N*******************************************************************************/
N#define UART_1_BLE_SetRxInterrupt(interruptMask)  UART_1_BLE_SET_INTR_RX(interruptMask)
N
Nvoid UART_1_BLE_SetRxFifoLevel(uint32 level);
N
N
N/* APIs to service INTR_TX register */
N/*******************************************************************************
N* Function Name: UART_1_BLE_GetTxInterruptSource
N****************************************************************************//**
N*
N*  Returns TX interrupt request register. This register contains current status 
N*  of TX interrupt sources.
N* 
N*  \return 
N*   Current status of TX interrupt sources.
N*   Each constant is a bit field value. The value returned may have multiple 
N*   bits set to indicate the current status.
N*   - UART_1_BLE_INTR_TX_FIFO_LEVEL - The number of data elements in the 
N*     TX FIFO is less than the value of TX FIFO level.
N*   - UART_1_BLE_INTR_TX_NOT_FULL - Transmitter FIFO is not full.
N*   - UART_1_BLE_INTR_TX_EMPTY - Transmitter FIFO is empty.
N*   - UART_1_BLE_INTR_TX_OVERFLOW - Attempt to write to a full 
N*     transmitter FIFO.
N*   - UART_1_BLE_INTR_TX_UNDERFLOW - Attempt to read from an empty 
N*     transmitter FIFO.
N*   - UART_1_BLE_INTR_TX_UART_NACK - UART received a NACK in SmartCard 
N*   mode.
N*   - UART_1_BLE_INTR_TX_UART_DONE - UART transfer is complete. 
N*     All data elements from the TX FIFO are sent.
N*   - UART_1_BLE_INTR_TX_UART_ARB_LOST - Value on the TX line of the UART
N*     does not match the value on the RX line.
N*
N*******************************************************************************/
N#define UART_1_BLE_GetTxInterruptSource() (UART_1_BLE_INTR_TX_REG)
N
N
N/*******************************************************************************
N* Function Name: UART_1_BLE_SetTxInterruptMode
N****************************************************************************//**
N*
N*  Writes TX interrupt mask register. This register configures which bits from 
N*  TX interrupt request register will trigger an interrupt event.
N*
N*  \param interruptMask: TX interrupt sources to be enabled (refer to 
N*   UART_1_BLE_GetTxInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define UART_1_BLE_SetTxInterruptMode(interruptMask)  UART_1_BLE_WRITE_INTR_TX_MASK(interruptMask)
N
N
N/*******************************************************************************
N* Function Name: UART_1_BLE_GetTxInterruptMode
N****************************************************************************//**
N*
N*  Returns TX interrupt mask register This register specifies which bits from 
N*  TX interrupt request register will trigger an interrupt event.
N*
N*  \return 
N*   Enabled TX interrupt sources (refer to 
N*   UART_1_BLE_GetTxInterruptSource() function for bit field values).
N*   
N*******************************************************************************/
N#define UART_1_BLE_GetTxInterruptMode()   (UART_1_BLE_INTR_TX_MASK_REG)
N
N
N/*******************************************************************************
N* Function Name: UART_1_BLE_GetTxInterruptSourceMasked
N****************************************************************************//**
N*
N*  Returns TX interrupt masked request register. This register contains logical
N*  AND of corresponding bits from TX interrupt request and mask registers.
N*  This function is intended to be used in the interrupt service routine to identify 
N*  which of enabled TX interrupt sources cause interrupt event.
N*
N*  \return 
N*   Current status of enabled TX interrupt sources (refer to 
N*   UART_1_BLE_GetTxInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define UART_1_BLE_GetTxInterruptSourceMasked()   (UART_1_BLE_INTR_TX_MASKED_REG)
N
N
N/*******************************************************************************
N* Function Name: UART_1_BLE_ClearTxInterruptSource
N****************************************************************************//**
N*
N*  Clears TX interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: TX interrupt sources to be cleared (refer to 
N*   UART_1_BLE_GetTxInterruptSource() function for bit field values).
N*
N*  \sideeffects 
N*   The side effects are listed in the table below for each affected interrupt 
N*   source. Refer to section TX FIFO interrupt sources for detailed description.
N*   - UART_1_BLE_INTR_TX_FIFO_LEVEL - Interrupt source is not cleared when 
N*     transmitter FIFO has less entries than level.
N*   - UART_1_BLE_INTR_TX_NOT_FULL - Interrupt source is not cleared when
N*     transmitter FIFO has empty entries.
N*   - UART_1_BLE_INTR_TX_EMPTY - Interrupt source is not cleared when 
N*     transmitter FIFO is empty.
N*   - UART_1_BLE_INTR_TX_UNDERFLOW - Interrupt source is not cleared when 
N*     transmitter FIFO is empty and I2C mode with clock stretching is selected. 
N*     Put data into the transmitter FIFO before clearing it. This behavior only 
N*     applicable for PSoC 4100/PSoC 4200 devices.
N*
N*******************************************************************************/
N#define UART_1_BLE_ClearTxInterruptSource(interruptMask)  UART_1_BLE_CLEAR_INTR_TX(interruptMask)
N
N
N/*******************************************************************************
N* Function Name: UART_1_BLE_SetTxInterrupt
N****************************************************************************//**
N*
N*  Sets RX interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: RX interrupt sources to set in the RX interrupt request 
N*   register (refer to UART_1_BLE_GetRxInterruptSource() function for bit 
N*   fields values).
N*
N*******************************************************************************/
N#define UART_1_BLE_SetTxInterrupt(interruptMask)  UART_1_BLE_SET_INTR_TX(interruptMask)
N
Nvoid UART_1_BLE_SetTxFifoLevel(uint32 level);
N
N
N/* APIs to service INTR_MASTER register */
N/*******************************************************************************
N* Function Name: UART_1_BLE_GetMasterInterruptSource
N****************************************************************************//**
N*
N*  Returns Master interrupt request register. This register contains current 
N*  status of Master interrupt sources.
N*
N*  \return 
N*   Current status of Master interrupt sources. 
N*   Each constant is a bit field value. The value returned may have multiple 
N*   bits set to indicate the current status.
N*   - UART_1_BLE_INTR_MASTER_SPI_DONE - SPI master transfer is complete.
N*     Refer to Interrupt sources section for detailed description.
N*   - UART_1_BLE_INTR_MASTER_I2C_ARB_LOST - I2C master lost arbitration.
N*   - UART_1_BLE_INTR_MASTER_I2C_NACK - I2C master received negative 
N*    acknowledgement (NAK).
N*   - UART_1_BLE_INTR_MASTER_I2C_ACK - I2C master received acknowledgement.
N*   - UART_1_BLE_INTR_MASTER_I2C_STOP - I2C master generated STOP.
N*   - UART_1_BLE_INTR_MASTER_I2C_BUS_ERROR - I2C master bus error 
N*     (detection of unexpected START or STOP condition).
N*
N*******************************************************************************/
N#define UART_1_BLE_GetMasterInterruptSource() (UART_1_BLE_INTR_MASTER_REG)
N
N/*******************************************************************************
N* Function Name: UART_1_BLE_SetMasterInterruptMode
N****************************************************************************//**
N*
N*  Writes Master interrupt mask register. This register configures which bits 
N*  from Master interrupt request register will trigger an interrupt event.
N*
N*  \param interruptMask: Master interrupt sources to be enabled (refer to 
N*   UART_1_BLE_GetMasterInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define UART_1_BLE_SetMasterInterruptMode(interruptMask)  UART_1_BLE_WRITE_INTR_MASTER_MASK(interruptMask)
N
N/*******************************************************************************
N* Function Name: UART_1_BLE_GetMasterInterruptMode
N****************************************************************************//**
N*
N*  Returns Master interrupt mask register This register specifies which bits 
N*  from Master interrupt request register will trigger an interrupt event.
N*
N*  \return 
N*   Enabled Master interrupt sources (refer to 
N*   UART_1_BLE_GetMasterInterruptSource() function for return values).
N*
N*******************************************************************************/
N#define UART_1_BLE_GetMasterInterruptMode()   (UART_1_BLE_INTR_MASTER_MASK_REG)
N
N/*******************************************************************************
N* Function Name: UART_1_BLE_GetMasterInterruptSourceMasked
N****************************************************************************//**
N*
N*  Returns Master interrupt masked request register. This register contains 
N*  logical AND of corresponding bits from Master interrupt request and mask 
N*  registers.
N*  This function is intended to be used in the interrupt service routine to 
N*  identify which of enabled Master interrupt sources cause interrupt event.
N*
N*  \return 
N*   Current status of enabled Master interrupt sources (refer to 
N*   UART_1_BLE_GetMasterInterruptSource() function for return values).
N*
N*******************************************************************************/
N#define UART_1_BLE_GetMasterInterruptSourceMasked()   (UART_1_BLE_INTR_MASTER_MASKED_REG)
N
N/*******************************************************************************
N* Function Name: UART_1_BLE_ClearMasterInterruptSource
N****************************************************************************//**
N*
N*  Clears Master interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: Master interrupt sources to be cleared (refer to 
N*   UART_1_BLE_GetMasterInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define UART_1_BLE_ClearMasterInterruptSource(interruptMask)  UART_1_BLE_CLEAR_INTR_MASTER(interruptMask)
N
N/*******************************************************************************
N* Function Name: UART_1_BLE_SetMasterInterrupt
N****************************************************************************//**
N*
N*  Sets Master interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: Master interrupt sources to set in the Master interrupt
N*   request register (refer to UART_1_BLE_GetMasterInterruptSource() 
N*   function for bit field values).
N*
N*******************************************************************************/
N#define UART_1_BLE_SetMasterInterrupt(interruptMask)  UART_1_BLE_SET_INTR_MASTER(interruptMask)
N
N
N/* APIs to service INTR_SLAVE register */
N/*******************************************************************************
N* Function Name: UART_1_BLE_GetSlaveInterruptSource
N****************************************************************************//**
N*
N*  Returns Slave interrupt request register. This register contains current 
N*  status of Slave interrupt sources.
N*
N*  \return 
N*   Current status of Slave interrupt sources.
N*   Each constant is a bit field value. The value returned may have multiple 
N*   bits set to indicate the current status.
N*   - UART_1_BLE_INTR_SLAVE_I2C_ARB_LOST - I2C slave lost arbitration: 
N*     the value driven on the SDA line is not the same as the value observed 
N*     on the SDA line.
N*   - UART_1_BLE_INTR_SLAVE_I2C_NACK - I2C slave received negative 
N*     acknowledgement (NAK).
N*   - UART_1_BLE_INTR_SLAVE_I2C_ACK - I2C slave received 
N*     acknowledgement (ACK).
N*   - UART_1_BLE_INTR_SLAVE_I2C_WRITE_STOP - Stop or Repeated Start 
N*     event for write transfer intended for this slave (address matching 
N*     is performed).
N*   - UART_1_BLE_INTR_SLAVE_I2C_STOP - Stop or Repeated Start event 
N*     for (read or write) transfer intended for this slave (address matching 
N*     is performed).
N*   - UART_1_BLE_INTR_SLAVE_I2C_START - I2C slave received Start 
N*     condition.
N*   - UART_1_BLE_INTR_SLAVE_I2C_ADDR_MATCH - I2C slave received matching 
N*     address.
N*   - UART_1_BLE_INTR_SLAVE_I2C_GENERAL - I2C Slave received general 
N*     call address.
N*   - UART_1_BLE_INTR_SLAVE_I2C_BUS_ERROR - I2C slave bus error (detection 
N*      of unexpected Start or Stop condition).
N*   - UART_1_BLE_INTR_SLAVE_SPI_BUS_ERROR - SPI slave select line is 
N*      deselected at an expected time while the SPI transfer.
N*
N*******************************************************************************/
N#define UART_1_BLE_GetSlaveInterruptSource()  (UART_1_BLE_INTR_SLAVE_REG)
N
N/*******************************************************************************
N* Function Name: UART_1_BLE_SetSlaveInterruptMode
N****************************************************************************//**
N*
N*  Writes Slave interrupt mask register. 
N*  This register configures which bits from Slave interrupt request register 
N*  will trigger an interrupt event.
N*
N*  \param interruptMask: Slave interrupt sources to be enabled (refer to 
N*   UART_1_BLE_GetSlaveInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define UART_1_BLE_SetSlaveInterruptMode(interruptMask)   UART_1_BLE_WRITE_INTR_SLAVE_MASK(interruptMask)
N
N/*******************************************************************************
N* Function Name: UART_1_BLE_GetSlaveInterruptMode
N****************************************************************************//**
N*
N*  Returns Slave interrupt mask register.
N*  This register specifies which bits from Slave interrupt request register 
N*  will trigger an interrupt event.
N*
N*  \return 
N*   Enabled Slave interrupt sources(refer to 
N*   UART_1_BLE_GetSlaveInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define UART_1_BLE_GetSlaveInterruptMode()    (UART_1_BLE_INTR_SLAVE_MASK_REG)
N
N/*******************************************************************************
N* Function Name: UART_1_BLE_GetSlaveInterruptSourceMasked
N****************************************************************************//**
N*
N*  Returns Slave interrupt masked request register. This register contains 
N*  logical AND of corresponding bits from Slave interrupt request and mask 
N*  registers.
N*  This function is intended to be used in the interrupt service routine to 
N*  identify which of enabled Slave interrupt sources cause interrupt event.
N*
N*  \return 
N*   Current status of enabled Slave interrupt sources (refer to 
N*   UART_1_BLE_GetSlaveInterruptSource() function for return values).
N*
N*******************************************************************************/
N#define UART_1_BLE_GetSlaveInterruptSourceMasked()    (UART_1_BLE_INTR_SLAVE_MASKED_REG)
N
N/*******************************************************************************
N* Function Name: UART_1_BLE_ClearSlaveInterruptSource
N****************************************************************************//**
N*
N*  Clears Slave interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: Slave interrupt sources to be cleared (refer to 
N*   UART_1_BLE_GetSlaveInterruptSource() function for return values).
N*
N*******************************************************************************/
N#define UART_1_BLE_ClearSlaveInterruptSource(interruptMask)   UART_1_BLE_CLEAR_INTR_SLAVE(interruptMask)
N
N/*******************************************************************************
N* Function Name: UART_1_BLE_SetSlaveInterrupt
N****************************************************************************//**
N*
N*  Sets Slave interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: Slave interrupt sources to set in the Slave interrupt 
N*   request register (refer to UART_1_BLE_GetSlaveInterruptSource() 
N*   function for return values).
N*
N*******************************************************************************/
N#define UART_1_BLE_SetSlaveInterrupt(interruptMask)   UART_1_BLE_SET_INTR_SLAVE(interruptMask)
N
N/** @} interrupt */ 
N
N
N/***************************************
N*     Vars with External Linkage
N***************************************/
N
N/**
N* \addtogroup group_globals
N* @{
N*/
N
N/** UART_1_BLE_initVar indicates whether the UART_1_BLE 
N*  component has been initialized. The variable is initialized to 0 
N*  and set to 1 the first time SCB_Start() is called. This allows 
N*  the component to restart without reinitialization after the first 
N*  call to the UART_1_BLE_Start() routine.
N*
N*  If re-initialization of the component is required, then the 
N*  UART_1_BLE_Init() function can be called before the 
N*  UART_1_BLE_Start() or UART_1_BLE_Enable() function.
N*/
Nextern uint8 UART_1_BLE_initVar;
N/** @} globals */
N
N/***************************************
N*              Registers
N***************************************/
N
N#define UART_1_BLE_CTRL_REG               (*(reg32 *) UART_1_BLE_SCB__CTRL)
N#define UART_1_BLE_CTRL_PTR               ( (reg32 *) UART_1_BLE_SCB__CTRL)
N
N#define UART_1_BLE_STATUS_REG             (*(reg32 *) UART_1_BLE_SCB__STATUS)
N#define UART_1_BLE_STATUS_PTR             ( (reg32 *) UART_1_BLE_SCB__STATUS)
N
N#if (!UART_1_BLE_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_1_BLE_SPI_CTRL_REG           (*(reg32 *) UART_1_BLE_SCB__SPI_CTRL)
N    #define UART_1_BLE_SPI_CTRL_PTR           ( (reg32 *) UART_1_BLE_SCB__SPI_CTRL)
N
N    #define UART_1_BLE_SPI_STATUS_REG         (*(reg32 *) UART_1_BLE_SCB__SPI_STATUS)
N    #define UART_1_BLE_SPI_STATUS_PTR         ( (reg32 *) UART_1_BLE_SCB__SPI_STATUS)
N
N    #define UART_1_BLE_UART_CTRL_REG          (*(reg32 *) UART_1_BLE_SCB__UART_CTRL)
N    #define UART_1_BLE_UART_CTRL_PTR          ( (reg32 *) UART_1_BLE_SCB__UART_CTRL)
N
N    #define UART_1_BLE_UART_TX_CTRL_REG       (*(reg32 *) UART_1_BLE_SCB__UART_TX_CTRL)
N    #define UART_1_BLE_UART_TX_CTRL_PTR       ( (reg32 *) UART_1_BLE_SCB__UART_TX_CTRL)
N
N    #define UART_1_BLE_UART_RX_CTRL_REG       (*(reg32 *) UART_1_BLE_SCB__UART_RX_CTRL)
N    #define UART_1_BLE_UART_RX_CTRL_PTR       ( (reg32 *) UART_1_BLE_SCB__UART_RX_CTRL)
N
N    #define UART_1_BLE_UART_RX_STATUS_REG     (*(reg32 *) UART_1_BLE_SCB__UART_RX_STATUS)
N    #define UART_1_BLE_UART_RX_STATUS_PTR     ( (reg32 *) UART_1_BLE_SCB__UART_RX_STATUS)
N#endif /* (!UART_1_BLE_CY_SCBIP_V1) */
N
N#if !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define UART_1_BLE_UART_FLOW_CTRL_REG     (*(reg32 *) UART_1_BLE_SCB__UART_FLOW_CTRL)
N    #define UART_1_BLE_UART_FLOW_CTRL_PTR     ( (reg32 *) UART_1_BLE_SCB__UART_FLOW_CTRL)
N#endif /* !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1) */
N
N#define UART_1_BLE_I2C_CTRL_REG           (*(reg32 *) UART_1_BLE_SCB__I2C_CTRL)
N#define UART_1_BLE_I2C_CTRL_PTR           ( (reg32 *) UART_1_BLE_SCB__I2C_CTRL)
N
N#define UART_1_BLE_I2C_STATUS_REG         (*(reg32 *) UART_1_BLE_SCB__I2C_STATUS)
N#define UART_1_BLE_I2C_STATUS_PTR         ( (reg32 *) UART_1_BLE_SCB__I2C_STATUS)
N
N#define UART_1_BLE_I2C_MASTER_CMD_REG     (*(reg32 *) UART_1_BLE_SCB__I2C_M_CMD)
N#define UART_1_BLE_I2C_MASTER_CMD_PTR     ( (reg32 *) UART_1_BLE_SCB__I2C_M_CMD)
N
N#define UART_1_BLE_I2C_SLAVE_CMD_REG      (*(reg32 *) UART_1_BLE_SCB__I2C_S_CMD)
N#define UART_1_BLE_I2C_SLAVE_CMD_PTR      ( (reg32 *) UART_1_BLE_SCB__I2C_S_CMD)
N
N#define UART_1_BLE_I2C_CFG_REG            (*(reg32 *) UART_1_BLE_SCB__I2C_CFG)
N#define UART_1_BLE_I2C_CFG_PTR            ( (reg32 *) UART_1_BLE_SCB__I2C_CFG)
N
N#define UART_1_BLE_TX_CTRL_REG            (*(reg32 *) UART_1_BLE_SCB__TX_CTRL)
N#define UART_1_BLE_TX_CTRL_PTR            ( (reg32 *) UART_1_BLE_SCB__TX_CTRL)
N
N#define UART_1_BLE_TX_FIFO_CTRL_REG       (*(reg32 *) UART_1_BLE_SCB__TX_FIFO_CTRL)
N#define UART_1_BLE_TX_FIFO_CTRL_PTR       ( (reg32 *) UART_1_BLE_SCB__TX_FIFO_CTRL)
N
N#define UART_1_BLE_TX_FIFO_STATUS_REG     (*(reg32 *) UART_1_BLE_SCB__TX_FIFO_STATUS)
N#define UART_1_BLE_TX_FIFO_STATUS_PTR     ( (reg32 *) UART_1_BLE_SCB__TX_FIFO_STATUS)
N
N#define UART_1_BLE_TX_FIFO_WR_REG         (*(reg32 *) UART_1_BLE_SCB__TX_FIFO_WR)
N#define UART_1_BLE_TX_FIFO_WR_PTR         ( (reg32 *) UART_1_BLE_SCB__TX_FIFO_WR)
N
N#define UART_1_BLE_RX_CTRL_REG            (*(reg32 *) UART_1_BLE_SCB__RX_CTRL)
N#define UART_1_BLE_RX_CTRL_PTR            ( (reg32 *) UART_1_BLE_SCB__RX_CTRL)
N
N#define UART_1_BLE_RX_FIFO_CTRL_REG       (*(reg32 *) UART_1_BLE_SCB__RX_FIFO_CTRL)
N#define UART_1_BLE_RX_FIFO_CTRL_PTR       ( (reg32 *) UART_1_BLE_SCB__RX_FIFO_CTRL)
N
N#define UART_1_BLE_RX_FIFO_STATUS_REG     (*(reg32 *) UART_1_BLE_SCB__RX_FIFO_STATUS)
N#define UART_1_BLE_RX_FIFO_STATUS_PTR     ( (reg32 *) UART_1_BLE_SCB__RX_FIFO_STATUS)
N
N#define UART_1_BLE_RX_MATCH_REG           (*(reg32 *) UART_1_BLE_SCB__RX_MATCH)
N#define UART_1_BLE_RX_MATCH_PTR           ( (reg32 *) UART_1_BLE_SCB__RX_MATCH)
N
N#define UART_1_BLE_RX_FIFO_RD_REG         (*(reg32 *) UART_1_BLE_SCB__RX_FIFO_RD)
N#define UART_1_BLE_RX_FIFO_RD_PTR         ( (reg32 *) UART_1_BLE_SCB__RX_FIFO_RD)
N
N#define UART_1_BLE_RX_FIFO_RD_SILENT_REG  (*(reg32 *) UART_1_BLE_SCB__RX_FIFO_RD_SILENT)
N#define UART_1_BLE_RX_FIFO_RD_SILENT_PTR  ( (reg32 *) UART_1_BLE_SCB__RX_FIFO_RD_SILENT)
N
N#ifdef UART_1_BLE_SCB__EZ_DATA0
N    #define UART_1_BLE_EZBUF_DATA0_REG    (*(reg32 *) UART_1_BLE_SCB__EZ_DATA0)
N    #define UART_1_BLE_EZBUF_DATA0_PTR    ( (reg32 *) UART_1_BLE_SCB__EZ_DATA0)
N#else
S    #define UART_1_BLE_EZBUF_DATA0_REG    (*(reg32 *) UART_1_BLE_SCB__EZ_DATA00)
S    #define UART_1_BLE_EZBUF_DATA0_PTR    ( (reg32 *) UART_1_BLE_SCB__EZ_DATA00)
N#endif /* UART_1_BLE_SCB__EZ_DATA00 */
N
N#define UART_1_BLE_INTR_CAUSE_REG         (*(reg32 *) UART_1_BLE_SCB__INTR_CAUSE)
N#define UART_1_BLE_INTR_CAUSE_PTR         ( (reg32 *) UART_1_BLE_SCB__INTR_CAUSE)
N
N#define UART_1_BLE_INTR_I2C_EC_REG        (*(reg32 *) UART_1_BLE_SCB__INTR_I2C_EC)
N#define UART_1_BLE_INTR_I2C_EC_PTR        ( (reg32 *) UART_1_BLE_SCB__INTR_I2C_EC)
N
N#define UART_1_BLE_INTR_I2C_EC_MASK_REG   (*(reg32 *) UART_1_BLE_SCB__INTR_I2C_EC_MASK)
N#define UART_1_BLE_INTR_I2C_EC_MASK_PTR   ( (reg32 *) UART_1_BLE_SCB__INTR_I2C_EC_MASK)
N
N#define UART_1_BLE_INTR_I2C_EC_MASKED_REG (*(reg32 *) UART_1_BLE_SCB__INTR_I2C_EC_MASKED)
N#define UART_1_BLE_INTR_I2C_EC_MASKED_PTR ( (reg32 *) UART_1_BLE_SCB__INTR_I2C_EC_MASKED)
N
N#if (!UART_1_BLE_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_1_BLE_INTR_SPI_EC_REG        (*(reg32 *) UART_1_BLE_SCB__INTR_SPI_EC)
N    #define UART_1_BLE_INTR_SPI_EC_PTR        ( (reg32 *) UART_1_BLE_SCB__INTR_SPI_EC)
N
N    #define UART_1_BLE_INTR_SPI_EC_MASK_REG   (*(reg32 *) UART_1_BLE_SCB__INTR_SPI_EC_MASK)
N    #define UART_1_BLE_INTR_SPI_EC_MASK_PTR   ( (reg32 *) UART_1_BLE_SCB__INTR_SPI_EC_MASK)
N
N    #define UART_1_BLE_INTR_SPI_EC_MASKED_REG (*(reg32 *) UART_1_BLE_SCB__INTR_SPI_EC_MASKED)
N    #define UART_1_BLE_INTR_SPI_EC_MASKED_PTR ( (reg32 *) UART_1_BLE_SCB__INTR_SPI_EC_MASKED)
N#endif /* (!UART_1_BLE_CY_SCBIP_V1) */
N
N#define UART_1_BLE_INTR_MASTER_REG        (*(reg32 *) UART_1_BLE_SCB__INTR_M)
N#define UART_1_BLE_INTR_MASTER_PTR        ( (reg32 *) UART_1_BLE_SCB__INTR_M)
N
N#define UART_1_BLE_INTR_MASTER_SET_REG    (*(reg32 *) UART_1_BLE_SCB__INTR_M_SET)
N#define UART_1_BLE_INTR_MASTER_SET_PTR    ( (reg32 *) UART_1_BLE_SCB__INTR_M_SET)
N
N#define UART_1_BLE_INTR_MASTER_MASK_REG   (*(reg32 *) UART_1_BLE_SCB__INTR_M_MASK)
N#define UART_1_BLE_INTR_MASTER_MASK_PTR   ( (reg32 *) UART_1_BLE_SCB__INTR_M_MASK)
N
N#define UART_1_BLE_INTR_MASTER_MASKED_REG (*(reg32 *) UART_1_BLE_SCB__INTR_M_MASKED)
N#define UART_1_BLE_INTR_MASTER_MASKED_PTR ( (reg32 *) UART_1_BLE_SCB__INTR_M_MASKED)
N
N#define UART_1_BLE_INTR_SLAVE_REG         (*(reg32 *) UART_1_BLE_SCB__INTR_S)
N#define UART_1_BLE_INTR_SLAVE_PTR         ( (reg32 *) UART_1_BLE_SCB__INTR_S)
N
N#define UART_1_BLE_INTR_SLAVE_SET_REG     (*(reg32 *) UART_1_BLE_SCB__INTR_S_SET)
N#define UART_1_BLE_INTR_SLAVE_SET_PTR     ( (reg32 *) UART_1_BLE_SCB__INTR_S_SET)
N
N#define UART_1_BLE_INTR_SLAVE_MASK_REG    (*(reg32 *) UART_1_BLE_SCB__INTR_S_MASK)
N#define UART_1_BLE_INTR_SLAVE_MASK_PTR    ( (reg32 *) UART_1_BLE_SCB__INTR_S_MASK)
N
N#define UART_1_BLE_INTR_SLAVE_MASKED_REG  (*(reg32 *) UART_1_BLE_SCB__INTR_S_MASKED)
N#define UART_1_BLE_INTR_SLAVE_MASKED_PTR  ( (reg32 *) UART_1_BLE_SCB__INTR_S_MASKED)
N
N#define UART_1_BLE_INTR_TX_REG            (*(reg32 *) UART_1_BLE_SCB__INTR_TX)
N#define UART_1_BLE_INTR_TX_PTR            ( (reg32 *) UART_1_BLE_SCB__INTR_TX)
N
N#define UART_1_BLE_INTR_TX_SET_REG        (*(reg32 *) UART_1_BLE_SCB__INTR_TX_SET)
N#define UART_1_BLE_INTR_TX_SET_PTR        ( (reg32 *) UART_1_BLE_SCB__INTR_TX_SET)
N
N#define UART_1_BLE_INTR_TX_MASK_REG       (*(reg32 *) UART_1_BLE_SCB__INTR_TX_MASK)
N#define UART_1_BLE_INTR_TX_MASK_PTR       ( (reg32 *) UART_1_BLE_SCB__INTR_TX_MASK)
N
N#define UART_1_BLE_INTR_TX_MASKED_REG     (*(reg32 *) UART_1_BLE_SCB__INTR_TX_MASKED)
N#define UART_1_BLE_INTR_TX_MASKED_PTR     ( (reg32 *) UART_1_BLE_SCB__INTR_TX_MASKED)
N
N#define UART_1_BLE_INTR_RX_REG            (*(reg32 *) UART_1_BLE_SCB__INTR_RX)
N#define UART_1_BLE_INTR_RX_PTR            ( (reg32 *) UART_1_BLE_SCB__INTR_RX)
N
N#define UART_1_BLE_INTR_RX_SET_REG        (*(reg32 *) UART_1_BLE_SCB__INTR_RX_SET)
N#define UART_1_BLE_INTR_RX_SET_PTR        ( (reg32 *) UART_1_BLE_SCB__INTR_RX_SET)
N
N#define UART_1_BLE_INTR_RX_MASK_REG       (*(reg32 *) UART_1_BLE_SCB__INTR_RX_MASK)
N#define UART_1_BLE_INTR_RX_MASK_PTR       ( (reg32 *) UART_1_BLE_SCB__INTR_RX_MASK)
N
N#define UART_1_BLE_INTR_RX_MASKED_REG     (*(reg32 *) UART_1_BLE_SCB__INTR_RX_MASKED)
N#define UART_1_BLE_INTR_RX_MASKED_PTR     ( (reg32 *) UART_1_BLE_SCB__INTR_RX_MASKED)
N
N/* Defines get from SCB IP parameters. */
N#define UART_1_BLE_FIFO_SIZE      (8u)  /* TX or RX FIFO size. */
N#define UART_1_BLE_EZ_DATA_NR     (32u)  /* Number of words in EZ memory. */ 
N#define UART_1_BLE_ONE_BYTE_WIDTH (8u)            /* Number of bits in one byte. */
N#define UART_1_BLE_FF_DATA_NR_LOG2_MASK       (0x0Fu)      /* Number of bits to represent a FIFO address. */
N#define UART_1_BLE_FF_DATA_NR_LOG2_PLUS1_MASK (0x1Fu) /* Number of bits to represent #bytes in FIFO. */
N
N
N/***************************************
N*        Registers Constants
N***************************************/
N
N#if (UART_1_BLE_SCB_IRQ_INTERNAL)
X#if ((0u == (0u)))
N    #define UART_1_BLE_ISR_NUMBER     ((uint8) UART_1_BLE_SCB_IRQ__INTC_NUMBER)
N    #define UART_1_BLE_ISR_PRIORITY   ((uint8) UART_1_BLE_SCB_IRQ__INTC_PRIOR_NUM)
N#endif /* (UART_1_BLE_SCB_IRQ_INTERNAL) */
N
N#if (UART_1_BLE_UART_RX_WAKEUP_IRQ)
X#if ((0u == (1u)))
S    #define UART_1_BLE_RX_WAKE_ISR_NUMBER     ((uint8) UART_1_BLE_RX_WAKEUP_IRQ__INTC_NUMBER)
S    #define UART_1_BLE_RX_WAKE_ISR_PRIORITY   ((uint8) UART_1_BLE_RX_WAKEUP_IRQ__INTC_PRIOR_NUM)
N#endif /* (UART_1_BLE_UART_RX_WAKEUP_IRQ) */
N
N/* UART_1_BLE_CTRL_REG */
N#define UART_1_BLE_CTRL_OVS_POS           (0u)  /* [3:0]   Oversampling factor                 */
N#define UART_1_BLE_CTRL_EC_AM_MODE_POS    (8u)  /* [8]     Externally clocked address match    */
N#define UART_1_BLE_CTRL_EC_OP_MODE_POS    (9u)  /* [9]     Externally clocked operation mode   */
N#define UART_1_BLE_CTRL_EZBUF_MODE_POS    (10u) /* [10]    EZ buffer is enabled                */
N#if !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define UART_1_BLE_CTRL_BYTE_MODE_POS (11u) /* [11]    Determines the number of bits per FIFO data element */
N#endif /* !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1) */
N#define UART_1_BLE_CTRL_ADDR_ACCEPT_POS   (16u) /* [16]    Put matched address in RX FIFO       */
N#define UART_1_BLE_CTRL_BLOCK_POS         (17u) /* [17]    Ext and Int logic to resolve collide */
N#define UART_1_BLE_CTRL_MODE_POS          (24u) /* [25:24] Operation mode                       */
N#define UART_1_BLE_CTRL_ENABLED_POS       (31u) /* [31]    Enable SCB block                     */
N#define UART_1_BLE_CTRL_OVS_MASK          ((uint32) 0x0Fu)
N#define UART_1_BLE_CTRL_EC_AM_MODE        ((uint32) 0x01u << UART_1_BLE_CTRL_EC_AM_MODE_POS)
N#define UART_1_BLE_CTRL_EC_OP_MODE        ((uint32) 0x01u << UART_1_BLE_CTRL_EC_OP_MODE_POS)
N#define UART_1_BLE_CTRL_EZBUF_MODE        ((uint32) 0x01u << UART_1_BLE_CTRL_EZBUF_MODE_POS)
N#if !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define UART_1_BLE_CTRL_BYTE_MODE ((uint32) 0x01u << UART_1_BLE_CTRL_BYTE_MODE_POS)
N#endif /* !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1) */
N#define UART_1_BLE_CTRL_ADDR_ACCEPT       ((uint32) 0x01u << UART_1_BLE_CTRL_ADDR_ACCEPT_POS)
N#define UART_1_BLE_CTRL_BLOCK             ((uint32) 0x01u << UART_1_BLE_CTRL_BLOCK_POS)
N#define UART_1_BLE_CTRL_MODE_MASK         ((uint32) 0x03u << UART_1_BLE_CTRL_MODE_POS)
N#define UART_1_BLE_CTRL_MODE_I2C          ((uint32) 0x00u)
N#define UART_1_BLE_CTRL_MODE_SPI          ((uint32) 0x01u << UART_1_BLE_CTRL_MODE_POS)
N#define UART_1_BLE_CTRL_MODE_UART         ((uint32) 0x02u << UART_1_BLE_CTRL_MODE_POS)
N#define UART_1_BLE_CTRL_ENABLED           ((uint32) 0x01u << UART_1_BLE_CTRL_ENABLED_POS)
N
N/* UART_1_BLE_STATUS_REG */
N#define UART_1_BLE_STATUS_EC_BUSY_POS     (0u)  /* [0] Bus busy. Externally clocked logic access to EZ memory */
N#define UART_1_BLE_STATUS_EC_BUSY         ((uint32) 0x0Fu)
N
N/* UART_1_BLE_SPI_CTRL_REG  */
N#define UART_1_BLE_SPI_CTRL_CONTINUOUS_POS        (0u)  /* [0]     Continuous or Separated SPI data transfers */
N#define UART_1_BLE_SPI_CTRL_SELECT_PRECEDE_POS    (1u)  /* [1]     Precedes or coincides start of data frame  */
N#define UART_1_BLE_SPI_CTRL_CPHA_POS              (2u)  /* [2]     SCLK phase                                 */
N#define UART_1_BLE_SPI_CTRL_CPOL_POS              (3u)  /* [3]     SCLK polarity                              */
N#define UART_1_BLE_SPI_CTRL_LATE_MISO_SAMPLE_POS  (4u)  /* [4]     Late MISO sample enabled                   */
N#if !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define UART_1_BLE_SPI_CTRL_SCLK_CONTINUOUS_POS   (5u)  /* [5]     Enable continuous SCLK generation */
N    #define UART_1_BLE_SPI_CTRL_SSEL0_POLARITY_POS    (8u)  /* [8]     SS0 polarity                      */
N    #define UART_1_BLE_SPI_CTRL_SSEL1_POLARITY_POS    (9u)  /* [9]     SS1 polarity                      */
N    #define UART_1_BLE_SPI_CTRL_SSEL2_POLARITY_POS    (10u) /* [10]    SS2 polarity                      */
N    #define UART_1_BLE_SPI_CTRL_SSEL3_POLARITY_POS    (11u) /* [11]    SS3 polarity                      */
N#endif /* !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1) */
N#define UART_1_BLE_SPI_CTRL_LOOPBACK_POS          (16u) /* [16]    Local loop-back control enabled            */
N#define UART_1_BLE_SPI_CTRL_MODE_POS              (24u) /* [25:24] Submode of SPI operation                   */
N#define UART_1_BLE_SPI_CTRL_SLAVE_SELECT_POS      (26u) /* [27:26] Selects SPI SS signal                      */
N#define UART_1_BLE_SPI_CTRL_MASTER_MODE_POS       (31u) /* [31]    Master mode enabled                        */
N#define UART_1_BLE_SPI_CTRL_CONTINUOUS            ((uint32) 0x01u)
N#define UART_1_BLE_SPI_CTRL_SELECT_PRECEDE        ((uint32) 0x01u << UART_1_BLE_SPI_CTRL_SELECT_PRECEDE_POS)
N#define UART_1_BLE_SPI_CTRL_SCLK_MODE_MASK        ((uint32) 0x03u << UART_1_BLE_SPI_CTRL_CPHA_POS)
N#define UART_1_BLE_SPI_CTRL_CPHA                  ((uint32) 0x01u << UART_1_BLE_SPI_CTRL_CPHA_POS)
N#define UART_1_BLE_SPI_CTRL_CPOL                  ((uint32) 0x01u << UART_1_BLE_SPI_CTRL_CPOL_POS)
N#define UART_1_BLE_SPI_CTRL_LATE_MISO_SAMPLE      ((uint32) 0x01u << \
N                                                                    UART_1_BLE_SPI_CTRL_LATE_MISO_SAMPLE_POS)
X#define UART_1_BLE_SPI_CTRL_LATE_MISO_SAMPLE      ((uint32) 0x01u <<                                                                     UART_1_BLE_SPI_CTRL_LATE_MISO_SAMPLE_POS)
N#if !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define UART_1_BLE_SPI_CTRL_SCLK_CONTINUOUS  ((uint32) 0x01u << UART_1_BLE_SPI_CTRL_SCLK_CONTINUOUS_POS)
N    #define UART_1_BLE_SPI_CTRL_SSEL0_POLARITY   ((uint32) 0x01u << UART_1_BLE_SPI_CTRL_SSEL0_POLARITY_POS)
N    #define UART_1_BLE_SPI_CTRL_SSEL1_POLARITY   ((uint32) 0x01u << UART_1_BLE_SPI_CTRL_SSEL1_POLARITY_POS)
N    #define UART_1_BLE_SPI_CTRL_SSEL2_POLARITY   ((uint32) 0x01u << UART_1_BLE_SPI_CTRL_SSEL2_POLARITY_POS)
N    #define UART_1_BLE_SPI_CTRL_SSEL3_POLARITY   ((uint32) 0x01u << UART_1_BLE_SPI_CTRL_SSEL3_POLARITY_POS)
N    #define UART_1_BLE_SPI_CTRL_SSEL_POLARITY_MASK ((uint32)0x0Fu << UART_1_BLE_SPI_CTRL_SSEL0_POLARITY_POS)
N#endif /* !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1) */
N
N#define UART_1_BLE_SPI_CTRL_LOOPBACK              ((uint32) 0x01u << UART_1_BLE_SPI_CTRL_LOOPBACK_POS)
N#define UART_1_BLE_SPI_CTRL_MODE_MASK             ((uint32) 0x03u << UART_1_BLE_SPI_CTRL_MODE_POS)
N#define UART_1_BLE_SPI_CTRL_MODE_MOTOROLA         ((uint32) 0x00u)
N#define UART_1_BLE_SPI_CTRL_MODE_TI               ((uint32) 0x01u << UART_1_BLE_CTRL_MODE_POS)
N#define UART_1_BLE_SPI_CTRL_MODE_NS               ((uint32) 0x02u << UART_1_BLE_CTRL_MODE_POS)
N#define UART_1_BLE_SPI_CTRL_SLAVE_SELECT_MASK     ((uint32) 0x03u << UART_1_BLE_SPI_CTRL_SLAVE_SELECT_POS)
N#define UART_1_BLE_SPI_CTRL_SLAVE_SELECT0         ((uint32) 0x00u)
N#define UART_1_BLE_SPI_CTRL_SLAVE_SELECT1         ((uint32) 0x01u << UART_1_BLE_SPI_CTRL_SLAVE_SELECT_POS)
N#define UART_1_BLE_SPI_CTRL_SLAVE_SELECT2         ((uint32) 0x02u << UART_1_BLE_SPI_CTRL_SLAVE_SELECT_POS)
N#define UART_1_BLE_SPI_CTRL_SLAVE_SELECT3         ((uint32) 0x03u << UART_1_BLE_SPI_CTRL_SLAVE_SELECT_POS)
N#define UART_1_BLE_SPI_CTRL_MASTER                ((uint32) 0x01u << UART_1_BLE_SPI_CTRL_MASTER_MODE_POS)
N#define UART_1_BLE_SPI_CTRL_SLAVE                 ((uint32) 0x00u)
N
N/* UART_1_BLE_SPI_STATUS_REG  */
N#define UART_1_BLE_SPI_STATUS_BUS_BUSY_POS    (0u)  /* [0]    Bus busy - slave selected */
N#define UART_1_BLE_SPI_STATUS_EZBUF_ADDR_POS  (8u)  /* [15:8] EzAddress                 */
N#define UART_1_BLE_SPI_STATUS_BUS_BUSY        ((uint32) 0x01u)
N#define UART_1_BLE_SPI_STATUS_EZBUF_ADDR_MASK ((uint32) 0xFFu << UART_1_BLE_I2C_STATUS_EZBUF_ADDR_POS)
N
N/* UART_1_BLE_UART_CTRL */
N#define UART_1_BLE_UART_CTRL_LOOPBACK_POS         (16u) /* [16] Loop-back    */
N#define UART_1_BLE_UART_CTRL_MODE_POS             (24u) /* [24] UART subMode */
N#define UART_1_BLE_UART_CTRL_LOOPBACK             ((uint32) 0x01u << UART_1_BLE_UART_CTRL_LOOPBACK_POS)
N#define UART_1_BLE_UART_CTRL_MODE_UART_STD        ((uint32) 0x00u)
N#define UART_1_BLE_UART_CTRL_MODE_UART_SMARTCARD  ((uint32) 0x01u << UART_1_BLE_UART_CTRL_MODE_POS)
N#define UART_1_BLE_UART_CTRL_MODE_UART_IRDA       ((uint32) 0x02u << UART_1_BLE_UART_CTRL_MODE_POS)
N#define UART_1_BLE_UART_CTRL_MODE_MASK            ((uint32) 0x03u << UART_1_BLE_UART_CTRL_MODE_POS)
N
N/* UART_1_BLE_UART_TX_CTRL */
N#define UART_1_BLE_UART_TX_CTRL_STOP_BITS_POS         (0u)  /* [2:0] Stop bits: (Stop bits + 1) * 0.5 period */
N#define UART_1_BLE_UART_TX_CTRL_PARITY_POS            (4u)  /* [4]   Parity bit                              */
N#define UART_1_BLE_UART_TX_CTRL_PARITY_ENABLED_POS    (5u)  /* [5]   Parity enable                           */
N#define UART_1_BLE_UART_TX_CTRL_RETRY_ON_NACK_POS     (8u)  /* [8]   Smart Card: re-send frame on NACK       */
N#define UART_1_BLE_UART_TX_CTRL_ONE_STOP_BIT          ((uint32) 0x01u)
N#define UART_1_BLE_UART_TX_CTRL_ONE_HALF_STOP_BITS    ((uint32) 0x02u)
N#define UART_1_BLE_UART_TX_CTRL_TWO_STOP_BITS         ((uint32) 0x03u)
N#define UART_1_BLE_UART_TX_CTRL_STOP_BITS_MASK        ((uint32) 0x07u)
N#define UART_1_BLE_UART_TX_CTRL_PARITY                ((uint32) 0x01u << \
N                                                                    UART_1_BLE_UART_TX_CTRL_PARITY_POS)
X#define UART_1_BLE_UART_TX_CTRL_PARITY                ((uint32) 0x01u <<                                                                     UART_1_BLE_UART_TX_CTRL_PARITY_POS)
N#define UART_1_BLE_UART_TX_CTRL_PARITY_ENABLED        ((uint32) 0x01u << \
N                                                                    UART_1_BLE_UART_TX_CTRL_PARITY_ENABLED_POS)
X#define UART_1_BLE_UART_TX_CTRL_PARITY_ENABLED        ((uint32) 0x01u <<                                                                     UART_1_BLE_UART_TX_CTRL_PARITY_ENABLED_POS)
N#define UART_1_BLE_UART_TX_CTRL_RETRY_ON_NACK         ((uint32) 0x01u << \
N                                                                    UART_1_BLE_UART_TX_CTRL_RETRY_ON_NACK_POS)
X#define UART_1_BLE_UART_TX_CTRL_RETRY_ON_NACK         ((uint32) 0x01u <<                                                                     UART_1_BLE_UART_TX_CTRL_RETRY_ON_NACK_POS)
N
N/* UART_1_BLE_UART_RX_CTRL */
N#define UART_1_BLE_UART_RX_CTRL_STOP_BITS_POS             (0u)  /* [2:0] Stop bits: (Stop bits + 1) * 0.5 period*/
N#define UART_1_BLE_UART_RX_CTRL_PARITY_POS                (4u)  /* [4]   Parity bit                             */
N#define UART_1_BLE_UART_RX_CTRL_PARITY_ENABLED_POS        (5u)  /* [5]   Parity enable                          */
N#define UART_1_BLE_UART_RX_CTRL_POLARITY_POS              (6u)  /* [6]   IrDA: inverts polarity of RX signal    */
N#define UART_1_BLE_UART_RX_CTRL_DROP_ON_PARITY_ERR_POS    (8u)  /* [8]   Drop and lost RX FIFO on parity error  */
N#define UART_1_BLE_UART_RX_CTRL_DROP_ON_FRAME_ERR_POS     (9u)  /* [9]   Drop and lost RX FIFO on frame error   */
N#define UART_1_BLE_UART_RX_CTRL_MP_MODE_POS               (10u) /* [10]  Multi-processor mode                   */
N#define UART_1_BLE_UART_RX_CTRL_LIN_MODE_POS              (12u) /* [12]  Lin mode: applicable for UART Standard */
N#define UART_1_BLE_UART_RX_CTRL_SKIP_START_POS            (13u) /* [13]  Skip start not: only for UART Standard */
N#define UART_1_BLE_UART_RX_CTRL_BREAK_WIDTH_POS           (16u) /* [19:16]  Break width: (Break width + 1)      */
N#define UART_1_BLE_UART_TX_CTRL_ONE_STOP_BIT              ((uint32) 0x01u)
N#define UART_1_BLE_UART_TX_CTRL_ONE_HALF_STOP_BITS        ((uint32) 0x02u)
N#define UART_1_BLE_UART_TX_CTRL_TWO_STOP_BITS             ((uint32) 0x03u)
N#define UART_1_BLE_UART_RX_CTRL_STOP_BITS_MASK            ((uint32) 0x07u)
N#define UART_1_BLE_UART_RX_CTRL_PARITY                    ((uint32) 0x01u << \
N                                                                    UART_1_BLE_UART_RX_CTRL_PARITY_POS)
X#define UART_1_BLE_UART_RX_CTRL_PARITY                    ((uint32) 0x01u <<                                                                     UART_1_BLE_UART_RX_CTRL_PARITY_POS)
N#define UART_1_BLE_UART_RX_CTRL_PARITY_ENABLED            ((uint32) 0x01u << \
N                                                                    UART_1_BLE_UART_RX_CTRL_PARITY_ENABLED_POS)
X#define UART_1_BLE_UART_RX_CTRL_PARITY_ENABLED            ((uint32) 0x01u <<                                                                     UART_1_BLE_UART_RX_CTRL_PARITY_ENABLED_POS)
N#define UART_1_BLE_UART_RX_CTRL_POLARITY                  ((uint32) 0x01u << \
N                                                                    UART_1_BLE_UART_RX_CTRL_POLARITY_POS)
X#define UART_1_BLE_UART_RX_CTRL_POLARITY                  ((uint32) 0x01u <<                                                                     UART_1_BLE_UART_RX_CTRL_POLARITY_POS)
N#define UART_1_BLE_UART_RX_CTRL_DROP_ON_PARITY_ERR        ((uint32) 0x01u << \
N                                                                   UART_1_BLE_UART_RX_CTRL_DROP_ON_PARITY_ERR_POS)
X#define UART_1_BLE_UART_RX_CTRL_DROP_ON_PARITY_ERR        ((uint32) 0x01u <<                                                                    UART_1_BLE_UART_RX_CTRL_DROP_ON_PARITY_ERR_POS)
N#define UART_1_BLE_UART_RX_CTRL_DROP_ON_FRAME_ERR         ((uint32) 0x01u << \
N                                                                    UART_1_BLE_UART_RX_CTRL_DROP_ON_FRAME_ERR_POS)
X#define UART_1_BLE_UART_RX_CTRL_DROP_ON_FRAME_ERR         ((uint32) 0x01u <<                                                                     UART_1_BLE_UART_RX_CTRL_DROP_ON_FRAME_ERR_POS)
N#define UART_1_BLE_UART_RX_CTRL_MP_MODE                   ((uint32) 0x01u << \
N                                                                    UART_1_BLE_UART_RX_CTRL_MP_MODE_POS)
X#define UART_1_BLE_UART_RX_CTRL_MP_MODE                   ((uint32) 0x01u <<                                                                     UART_1_BLE_UART_RX_CTRL_MP_MODE_POS)
N#define UART_1_BLE_UART_RX_CTRL_LIN_MODE                  ((uint32) 0x01u << \
N                                                                    UART_1_BLE_UART_RX_CTRL_LIN_MODE_POS)
X#define UART_1_BLE_UART_RX_CTRL_LIN_MODE                  ((uint32) 0x01u <<                                                                     UART_1_BLE_UART_RX_CTRL_LIN_MODE_POS)
N#define UART_1_BLE_UART_RX_CTRL_SKIP_START                ((uint32) 0x01u << \
N                                                                    UART_1_BLE_UART_RX_CTRL_SKIP_START_POS)
X#define UART_1_BLE_UART_RX_CTRL_SKIP_START                ((uint32) 0x01u <<                                                                     UART_1_BLE_UART_RX_CTRL_SKIP_START_POS)
N#define UART_1_BLE_UART_RX_CTRL_BREAK_WIDTH_MASK          ((uint32) 0x0Fu << \
N                                                                    UART_1_BLE_UART_RX_CTRL_BREAK_WIDTH_POS)
X#define UART_1_BLE_UART_RX_CTRL_BREAK_WIDTH_MASK          ((uint32) 0x0Fu <<                                                                     UART_1_BLE_UART_RX_CTRL_BREAK_WIDTH_POS)
N/* UART_1_BLE_UART_RX_STATUS_REG */
N#define UART_1_BLE_UART_RX_STATUS_BR_COUNTER_POS     (0u)  /* [11:0] Baud Rate counter */
N#define UART_1_BLE_UART_RX_STATUS_BR_COUNTER_MASK    ((uint32) 0xFFFu)
N
N#if !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    /* UART_1_BLE_UART_FLOW_CTRL_REG */
N    #define UART_1_BLE_UART_FLOW_CTRL_TRIGGER_LEVEL_POS    (0u)  /* [7:0] RTS RX FIFO trigger level         */
N    #define UART_1_BLE_UART_FLOW_CTRL_RTS_POLARITY_POS     (16u) /* [16]  Polarity of the RTS output signal */
N    #define UART_1_BLE_UART_FLOW_CTRL_CTS_POLARITY_POS     (24u) /* [24]  Polarity of the CTS input signal  */
N    #define UART_1_BLE_UART_FLOW_CTRL_CTS_ENABLED_POS      (25u) /* [25]  Enable CTS signal                 */
N    #define UART_1_BLE_UART_FLOW_CTRL_TRIGGER_LEVEL_MASK   ((uint32) UART_1_BLE_FF_DATA_NR_LOG2_MASK)
N    #define UART_1_BLE_UART_FLOW_CTRL_RTS_POLARITY         ((uint32) 0x01u << \
N                                                                       UART_1_BLE_UART_FLOW_CTRL_RTS_POLARITY_POS)
X    #define UART_1_BLE_UART_FLOW_CTRL_RTS_POLARITY         ((uint32) 0x01u <<                                                                        UART_1_BLE_UART_FLOW_CTRL_RTS_POLARITY_POS)
N    #define UART_1_BLE_UART_FLOW_CTRL_CTS_POLARITY         ((uint32) 0x01u << \
N                                                                       UART_1_BLE_UART_FLOW_CTRL_CTS_POLARITY_POS)
X    #define UART_1_BLE_UART_FLOW_CTRL_CTS_POLARITY         ((uint32) 0x01u <<                                                                        UART_1_BLE_UART_FLOW_CTRL_CTS_POLARITY_POS)
N    #define UART_1_BLE_UART_FLOW_CTRL_CTS_ENABLE           ((uint32) 0x01u << \
N                                                                       UART_1_BLE_UART_FLOW_CTRL_CTS_ENABLED_POS)
X    #define UART_1_BLE_UART_FLOW_CTRL_CTS_ENABLE           ((uint32) 0x01u <<                                                                        UART_1_BLE_UART_FLOW_CTRL_CTS_ENABLED_POS)
N#endif /* !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1) */
N
N/* UART_1_BLE_I2C_CTRL */
N#define UART_1_BLE_I2C_CTRL_HIGH_PHASE_OVS_POS           (0u)   /* [3:0] Oversampling factor high: master only */
N#define UART_1_BLE_I2C_CTRL_LOW_PHASE_OVS_POS            (4u)   /* [7:4] Oversampling factor low:  master only */
N#define UART_1_BLE_I2C_CTRL_M_READY_DATA_ACK_POS         (8u)   /* [8]   Master ACKs data while RX FIFO != FULL*/
N#define UART_1_BLE_I2C_CTRL_M_NOT_READY_DATA_NACK_POS    (9u)   /* [9]   Master NACKs data if RX FIFO ==  FULL */
N#define UART_1_BLE_I2C_CTRL_S_GENERAL_IGNORE_POS         (11u)  /* [11]  Slave ignores General call            */
N#define UART_1_BLE_I2C_CTRL_S_READY_ADDR_ACK_POS         (12u)  /* [12]  Slave ACKs Address if RX FIFO != FULL */
N#define UART_1_BLE_I2C_CTRL_S_READY_DATA_ACK_POS         (13u)  /* [13]  Slave ACKs data while RX FIFO == FULL */
N#define UART_1_BLE_I2C_CTRL_S_NOT_READY_ADDR_NACK_POS    (14u)  /* [14]  Slave NACKs address if RX FIFO == FULL*/
N#define UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK_POS    (15u)  /* [15]  Slave NACKs data if RX FIFO is  FULL  */
N#define UART_1_BLE_I2C_CTRL_LOOPBACK_POS                 (16u)  /* [16]  Loop-back                             */
N#define UART_1_BLE_I2C_CTRL_SLAVE_MODE_POS               (30u)  /* [30]  Slave mode enabled                    */
N#define UART_1_BLE_I2C_CTRL_MASTER_MODE_POS              (31u)  /* [31]  Master mode enabled                   */
N#define UART_1_BLE_I2C_CTRL_HIGH_PHASE_OVS_MASK  ((uint32) 0x0Fu)
N#define UART_1_BLE_I2C_CTRL_LOW_PHASE_OVS_MASK   ((uint32) 0x0Fu << \
N                                                                UART_1_BLE_I2C_CTRL_LOW_PHASE_OVS_POS)
X#define UART_1_BLE_I2C_CTRL_LOW_PHASE_OVS_MASK   ((uint32) 0x0Fu <<                                                                 UART_1_BLE_I2C_CTRL_LOW_PHASE_OVS_POS)
N#define UART_1_BLE_I2C_CTRL_M_READY_DATA_ACK      ((uint32) 0x01u << \
N                                                                UART_1_BLE_I2C_CTRL_M_READY_DATA_ACK_POS)
X#define UART_1_BLE_I2C_CTRL_M_READY_DATA_ACK      ((uint32) 0x01u <<                                                                 UART_1_BLE_I2C_CTRL_M_READY_DATA_ACK_POS)
N#define UART_1_BLE_I2C_CTRL_M_NOT_READY_DATA_NACK ((uint32) 0x01u << \
N                                                                UART_1_BLE_I2C_CTRL_M_NOT_READY_DATA_NACK_POS)
X#define UART_1_BLE_I2C_CTRL_M_NOT_READY_DATA_NACK ((uint32) 0x01u <<                                                                 UART_1_BLE_I2C_CTRL_M_NOT_READY_DATA_NACK_POS)
N#define UART_1_BLE_I2C_CTRL_S_GENERAL_IGNORE      ((uint32) 0x01u << \
N                                                                UART_1_BLE_I2C_CTRL_S_GENERAL_IGNORE_POS)
X#define UART_1_BLE_I2C_CTRL_S_GENERAL_IGNORE      ((uint32) 0x01u <<                                                                 UART_1_BLE_I2C_CTRL_S_GENERAL_IGNORE_POS)
N#define UART_1_BLE_I2C_CTRL_S_READY_ADDR_ACK      ((uint32) 0x01u << \
N                                                                UART_1_BLE_I2C_CTRL_S_READY_ADDR_ACK_POS)
X#define UART_1_BLE_I2C_CTRL_S_READY_ADDR_ACK      ((uint32) 0x01u <<                                                                 UART_1_BLE_I2C_CTRL_S_READY_ADDR_ACK_POS)
N#define UART_1_BLE_I2C_CTRL_S_READY_DATA_ACK      ((uint32) 0x01u << \
N                                                                UART_1_BLE_I2C_CTRL_S_READY_DATA_ACK_POS)
X#define UART_1_BLE_I2C_CTRL_S_READY_DATA_ACK      ((uint32) 0x01u <<                                                                 UART_1_BLE_I2C_CTRL_S_READY_DATA_ACK_POS)
N#define UART_1_BLE_I2C_CTRL_S_NOT_READY_ADDR_NACK ((uint32) 0x01u << \
N                                                                UART_1_BLE_I2C_CTRL_S_NOT_READY_ADDR_NACK_POS)
X#define UART_1_BLE_I2C_CTRL_S_NOT_READY_ADDR_NACK ((uint32) 0x01u <<                                                                 UART_1_BLE_I2C_CTRL_S_NOT_READY_ADDR_NACK_POS)
N#define UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK ((uint32) 0x01u << \
N                                                                UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK_POS)
X#define UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK ((uint32) 0x01u <<                                                                 UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK_POS)
N#define UART_1_BLE_I2C_CTRL_LOOPBACK              ((uint32) 0x01u << \
N                                                                UART_1_BLE_I2C_CTRL_LOOPBACK_POS)
X#define UART_1_BLE_I2C_CTRL_LOOPBACK              ((uint32) 0x01u <<                                                                 UART_1_BLE_I2C_CTRL_LOOPBACK_POS)
N#define UART_1_BLE_I2C_CTRL_SLAVE_MODE            ((uint32) 0x01u << \
N                                                                UART_1_BLE_I2C_CTRL_SLAVE_MODE_POS)
X#define UART_1_BLE_I2C_CTRL_SLAVE_MODE            ((uint32) 0x01u <<                                                                 UART_1_BLE_I2C_CTRL_SLAVE_MODE_POS)
N#define UART_1_BLE_I2C_CTRL_MASTER_MODE           ((uint32) 0x01u << \
N                                                                UART_1_BLE_I2C_CTRL_MASTER_MODE_POS)
X#define UART_1_BLE_I2C_CTRL_MASTER_MODE           ((uint32) 0x01u <<                                                                 UART_1_BLE_I2C_CTRL_MASTER_MODE_POS)
N#define UART_1_BLE_I2C_CTRL_SLAVE_MASTER_MODE_MASK    ((uint32) 0x03u << \
N                                                                UART_1_BLE_I2C_CTRL_SLAVE_MODE_POS)
X#define UART_1_BLE_I2C_CTRL_SLAVE_MASTER_MODE_MASK    ((uint32) 0x03u <<                                                                 UART_1_BLE_I2C_CTRL_SLAVE_MODE_POS)
N
N/* UART_1_BLE_I2C_STATUS_REG  */
N#define UART_1_BLE_I2C_STATUS_BUS_BUSY_POS    (0u)  /* [0]    Bus busy: internally clocked */
N#define UART_1_BLE_I2C_STATUS_S_READ_POS      (4u)  /* [4]    Slave is read by master      */
N#define UART_1_BLE_I2C_STATUS_M_READ_POS      (5u)  /* [5]    Master reads Slave           */
N#define UART_1_BLE_I2C_STATUS_EZBUF_ADDR_POS  (8u)  /* [15:8] EZAddress                    */
N#define UART_1_BLE_I2C_STATUS_BUS_BUSY        ((uint32) 0x01u)
N#define UART_1_BLE_I2C_STATUS_S_READ          ((uint32) 0x01u << UART_1_BLE_I2C_STATUS_S_READ_POS)
N#define UART_1_BLE_I2C_STATUS_M_READ          ((uint32) 0x01u << UART_1_BLE_I2C_STATUS_M_READ_POS)
N#define UART_1_BLE_I2C_STATUS_EZBUF_ADDR_MASK ((uint32) 0xFFu << UART_1_BLE_I2C_STATUS_EZBUF_ADDR_POS)
N
N/* UART_1_BLE_I2C_MASTER_CMD_REG */
N#define UART_1_BLE_I2C_MASTER_CMD_M_START_POS             (0u)  /* [0] Master generate Start                */
N#define UART_1_BLE_I2C_MASTER_CMD_M_START_ON_IDLE_POS     (1u)  /* [1] Master generate Start if bus is free */
N#define UART_1_BLE_I2C_MASTER_CMD_M_ACK_POS               (2u)  /* [2] Master generate ACK                  */
N#define UART_1_BLE_I2C_MASTER_CMD_M_NACK_POS              (3u)  /* [3] Master generate NACK                 */
N#define UART_1_BLE_I2C_MASTER_CMD_M_STOP_POS              (4u)  /* [4] Master generate Stop                 */
N#define UART_1_BLE_I2C_MASTER_CMD_M_START         ((uint32) 0x01u)
N#define UART_1_BLE_I2C_MASTER_CMD_M_START_ON_IDLE ((uint32) 0x01u << \
N                                                                   UART_1_BLE_I2C_MASTER_CMD_M_START_ON_IDLE_POS)
X#define UART_1_BLE_I2C_MASTER_CMD_M_START_ON_IDLE ((uint32) 0x01u <<                                                                    UART_1_BLE_I2C_MASTER_CMD_M_START_ON_IDLE_POS)
N#define UART_1_BLE_I2C_MASTER_CMD_M_ACK           ((uint32) 0x01u << \
N                                                                   UART_1_BLE_I2C_MASTER_CMD_M_ACK_POS)
X#define UART_1_BLE_I2C_MASTER_CMD_M_ACK           ((uint32) 0x01u <<                                                                    UART_1_BLE_I2C_MASTER_CMD_M_ACK_POS)
N#define UART_1_BLE_I2C_MASTER_CMD_M_NACK          ((uint32) 0x01u << \
N                                                                    UART_1_BLE_I2C_MASTER_CMD_M_NACK_POS)
X#define UART_1_BLE_I2C_MASTER_CMD_M_NACK          ((uint32) 0x01u <<                                                                     UART_1_BLE_I2C_MASTER_CMD_M_NACK_POS)
N#define UART_1_BLE_I2C_MASTER_CMD_M_STOP          ((uint32) 0x01u << \
N                                                                    UART_1_BLE_I2C_MASTER_CMD_M_STOP_POS)
X#define UART_1_BLE_I2C_MASTER_CMD_M_STOP          ((uint32) 0x01u <<                                                                     UART_1_BLE_I2C_MASTER_CMD_M_STOP_POS)
N
N/* UART_1_BLE_I2C_SLAVE_CMD_REG  */
N#define UART_1_BLE_I2C_SLAVE_CMD_S_ACK_POS    (0u)  /* [0] Slave generate ACK  */
N#define UART_1_BLE_I2C_SLAVE_CMD_S_NACK_POS   (1u)  /* [1] Slave generate NACK */
N#define UART_1_BLE_I2C_SLAVE_CMD_S_ACK        ((uint32) 0x01u)
N#define UART_1_BLE_I2C_SLAVE_CMD_S_NACK       ((uint32) 0x01u << UART_1_BLE_I2C_SLAVE_CMD_S_NACK_POS)
N
N#define UART_1_BLE_I2C_SLAVE_CMD_S_ACK_POS    (0u)  /* [0] Slave generate ACK  */
N#define UART_1_BLE_I2C_SLAVE_CMD_S_NACK_POS   (1u)  /* [1] Slave generate NACK */
N#define UART_1_BLE_I2C_SLAVE_CMD_S_ACK        ((uint32) 0x01u)
N#define UART_1_BLE_I2C_SLAVE_CMD_S_NACK       ((uint32) 0x01u << UART_1_BLE_I2C_SLAVE_CMD_S_NACK_POS)
N
N/* UART_1_BLE_I2C_CFG_REG */
N#if (UART_1_BLE_CY_SCBIP_V0)
X#if ((2 == 0u))
S#define UART_1_BLE_I2C_CFG_SDA_FILT_HYS_POS           (0u)  /* [1:0]   Trim bits for the I2C SDA filter         */
S#define UART_1_BLE_I2C_CFG_SDA_FILT_TRIM_POS          (2u)  /* [3:2]   Trim bits for the I2C SDA filter         */
S#define UART_1_BLE_I2C_CFG_SCL_FILT_HYS_POS           (4u)  /* [5:4]   Trim bits for the I2C SCL filter         */
S#define UART_1_BLE_I2C_CFG_SCL_FILT_TRIM_POS          (6u)  /* [7:6]   Trim bits for the I2C SCL filter         */
S#define UART_1_BLE_I2C_CFG_SDA_FILT_OUT_HYS_POS       (8u)  /* [9:8]   Trim bits for I2C SDA filter output path */
S#define UART_1_BLE_I2C_CFG_SDA_FILT_OUT_TRIM_POS      (10u) /* [11:10] Trim bits for I2C SDA filter output path */
S#define UART_1_BLE_I2C_CFG_SDA_FILT_HS_POS            (16u) /* [16]    '0': 50 ns filter, '1': 10 ns filter     */
S#define UART_1_BLE_I2C_CFG_SDA_FILT_ENABLED_POS       (17u) /* [17]    I2C SDA filter enabled                   */
S#define UART_1_BLE_I2C_CFG_SCL_FILT_HS_POS            (24u) /* [24]    '0': 50 ns filter, '1': 10 ns filter     */
S#define UART_1_BLE_I2C_CFG_SCL_FILT_ENABLED_POS       (25u) /* [25]    I2C SCL filter enabled                   */
S#define UART_1_BLE_I2C_CFG_SDA_FILT_OUT_HS_POS        (26u) /* [26]    '0': 50 ns filter, '1': 10 ns filter     */
S#define UART_1_BLE_I2C_CFG_SDA_FILT_OUT_ENABLED_POS   (27u) /* [27]    I2C SDA output delay filter enabled      */
S#define UART_1_BLE_I2C_CFG_SDA_FILT_HYS_MASK          ((uint32) 0x03u)
S#define UART_1_BLE_I2C_CFG_SDA_FILT_TRIM_MASK         ((uint32) 0x03u << \
S                                                                UART_1_BLE_I2C_CFG_SDA_FILT_TRIM_POS)
X#define UART_1_BLE_I2C_CFG_SDA_FILT_TRIM_MASK         ((uint32) 0x03u <<                                                                 UART_1_BLE_I2C_CFG_SDA_FILT_TRIM_POS)
S#define UART_1_BLE_I2C_CFG_SCL_FILT_HYS_MASK          ((uint32) 0x03u << \
S                                                                UART_1_BLE_I2C_CFG_SCL_FILT_HYS_POS)
X#define UART_1_BLE_I2C_CFG_SCL_FILT_HYS_MASK          ((uint32) 0x03u <<                                                                 UART_1_BLE_I2C_CFG_SCL_FILT_HYS_POS)
S#define UART_1_BLE_I2C_CFG_SCL_FILT_TRIM_MASK         ((uint32) 0x03u << \
S                                                                UART_1_BLE_I2C_CFG_SCL_FILT_TRIM_POS)
X#define UART_1_BLE_I2C_CFG_SCL_FILT_TRIM_MASK         ((uint32) 0x03u <<                                                                 UART_1_BLE_I2C_CFG_SCL_FILT_TRIM_POS)
S#define UART_1_BLE_I2C_CFG_SDA_FILT_OUT_HYS_MASK      ((uint32) 0x03u << \
S                                                                UART_1_BLE_I2C_CFG_SDA_FILT_OUT_HYS_POS)
X#define UART_1_BLE_I2C_CFG_SDA_FILT_OUT_HYS_MASK      ((uint32) 0x03u <<                                                                 UART_1_BLE_I2C_CFG_SDA_FILT_OUT_HYS_POS)
S#define UART_1_BLE_I2C_CFG_SDA_FILT_OUT_TRIM_MASK     ((uint32) 0x03u << \
S                                                                UART_1_BLE_I2C_CFG_SDA_FILT_OUT_TRIM_POS)
X#define UART_1_BLE_I2C_CFG_SDA_FILT_OUT_TRIM_MASK     ((uint32) 0x03u <<                                                                 UART_1_BLE_I2C_CFG_SDA_FILT_OUT_TRIM_POS)
S#define UART_1_BLE_I2C_CFG_SDA_FILT_HS                ((uint32) 0x01u << \
S                                                                UART_1_BLE_I2C_CFG_SDA_FILT_HS_POS)
X#define UART_1_BLE_I2C_CFG_SDA_FILT_HS                ((uint32) 0x01u <<                                                                 UART_1_BLE_I2C_CFG_SDA_FILT_HS_POS)
S#define UART_1_BLE_I2C_CFG_SDA_FILT_ENABLED           ((uint32) 0x01u << \
S                                                                UART_1_BLE_I2C_CFG_SDA_FILT_ENABLED_POS)
X#define UART_1_BLE_I2C_CFG_SDA_FILT_ENABLED           ((uint32) 0x01u <<                                                                 UART_1_BLE_I2C_CFG_SDA_FILT_ENABLED_POS)
S#define UART_1_BLE_I2C_CFG_SCL_FILT_HS                ((uint32) 0x01u << \
S                                                                UART_1_BLE_I2C_CFG_SCL_FILT_HS_POS)
X#define UART_1_BLE_I2C_CFG_SCL_FILT_HS                ((uint32) 0x01u <<                                                                 UART_1_BLE_I2C_CFG_SCL_FILT_HS_POS)
S#define UART_1_BLE_I2C_CFG_SCL_FILT_ENABLED           ((uint32) 0x01u << \
S                                                                UART_1_BLE_I2C_CFG_SCL_FILT_ENABLED_POS)
X#define UART_1_BLE_I2C_CFG_SCL_FILT_ENABLED           ((uint32) 0x01u <<                                                                 UART_1_BLE_I2C_CFG_SCL_FILT_ENABLED_POS)
S#define UART_1_BLE_I2C_CFG_SDA_FILT_OUT_HS            ((uint32) 0x01u << \
S                                                                UART_1_BLE_I2C_CFG_SDA_FILT_OUT_HS_POS)
X#define UART_1_BLE_I2C_CFG_SDA_FILT_OUT_HS            ((uint32) 0x01u <<                                                                 UART_1_BLE_I2C_CFG_SDA_FILT_OUT_HS_POS)
S#define UART_1_BLE_I2C_CFG_SDA_FILT_OUT_ENABLED       ((uint32) 0x01u << \
S                                                                UART_1_BLE_I2C_CFG_SDA_FILT_OUT_ENABLED_POS)
X#define UART_1_BLE_I2C_CFG_SDA_FILT_OUT_ENABLED       ((uint32) 0x01u <<                                                                 UART_1_BLE_I2C_CFG_SDA_FILT_OUT_ENABLED_POS)
N#else
N#define UART_1_BLE_I2C_CFG_SDA_IN_FILT_TRIM_POS   (0u)  /* [1:0] Trim bits for "i2c_sda_in" 50 ns filter */
N#define UART_1_BLE_I2C_CFG_SDA_IN_FILT_SEL_POS    (4u)  /* [4]   "i2c_sda_in" filter delay: 0 ns and 50 ns */
N#define UART_1_BLE_I2C_CFG_SCL_IN_FILT_TRIM_POS   (8u)  /* [9:8] Trim bits for "i2c_scl_in" 50 ns filter */
N#define UART_1_BLE_I2C_CFG_SCL_IN_FILT_SEL_POS    (12u) /* [12]  "i2c_scl_in" filter delay: 0 ns and 50 ns */
N#define UART_1_BLE_I2C_CFG_SDA_OUT_FILT0_TRIM_POS (16u) /* [17:16] Trim bits for "i2c_sda_out" 50 ns filter 0 */
N#define UART_1_BLE_I2C_CFG_SDA_OUT_FILT1_TRIM_POS (18u) /* [19:18] Trim bits for "i2c_sda_out" 50 ns filter 1 */
N#define UART_1_BLE_I2C_CFG_SDA_OUT_FILT2_TRIM_POS (20u) /* [21:20] Trim bits for "i2c_sda_out" 50 ns filter 2 */
N#define UART_1_BLE_I2C_CFG_SDA_OUT_FILT_SEL_POS   (28u) /* [29:28] Cumulative "i2c_sda_out" filter delay: */
N
N#define UART_1_BLE_I2C_CFG_SDA_IN_FILT_TRIM_MASK  ((uint32) 0x03u)
N#define UART_1_BLE_I2C_CFG_SDA_IN_FILT_SEL        ((uint32) 0x01u << UART_1_BLE_I2C_CFG_SDA_IN_FILT_SEL_POS)
N#define UART_1_BLE_I2C_CFG_SCL_IN_FILT_TRIM_MASK  ((uint32) 0x03u << \
N                                                            UART_1_BLE_I2C_CFG_SCL_IN_FILT_TRIM_POS)
X#define UART_1_BLE_I2C_CFG_SCL_IN_FILT_TRIM_MASK  ((uint32) 0x03u <<                                                             UART_1_BLE_I2C_CFG_SCL_IN_FILT_TRIM_POS)
N#define UART_1_BLE_I2C_CFG_SCL_IN_FILT_SEL        ((uint32) 0x01u << UART_1_BLE_I2C_CFG_SCL_IN_FILT_SEL_POS)
N#define UART_1_BLE_I2C_CFG_SDA_OUT_FILT0_TRIM_MASK ((uint32) 0x03u << \
N                                                            UART_1_BLE_I2C_CFG_SDA_OUT_FILT0_TRIM_POS)
X#define UART_1_BLE_I2C_CFG_SDA_OUT_FILT0_TRIM_MASK ((uint32) 0x03u <<                                                             UART_1_BLE_I2C_CFG_SDA_OUT_FILT0_TRIM_POS)
N#define UART_1_BLE_I2C_CFG_SDA_OUT_FILT1_TRIM_MASK ((uint32) 0x03u << \
N                                                            UART_1_BLE_I2C_CFG_SDA_OUT_FILT1_TRIM_POS)
X#define UART_1_BLE_I2C_CFG_SDA_OUT_FILT1_TRIM_MASK ((uint32) 0x03u <<                                                             UART_1_BLE_I2C_CFG_SDA_OUT_FILT1_TRIM_POS)
N#define UART_1_BLE_I2C_CFG_SDA_OUT_FILT2_TRIM_MASK ((uint32) 0x03u << \
N                                                            UART_1_BLE_I2C_CFG_SDA_OUT_FILT2_TRIM_POS)
X#define UART_1_BLE_I2C_CFG_SDA_OUT_FILT2_TRIM_MASK ((uint32) 0x03u <<                                                             UART_1_BLE_I2C_CFG_SDA_OUT_FILT2_TRIM_POS)
N#define UART_1_BLE_I2C_CFG_SDA_OUT_FILT_SEL_MASK   ((uint32) 0x03u << \
N                                                            UART_1_BLE_I2C_CFG_SDA_OUT_FILT_SEL_POS)
X#define UART_1_BLE_I2C_CFG_SDA_OUT_FILT_SEL_MASK   ((uint32) 0x03u <<                                                             UART_1_BLE_I2C_CFG_SDA_OUT_FILT_SEL_POS)
N#endif /* (UART_1_BLE_CY_SCBIP_V0) */
N
N
N/* UART_1_BLE_TX_CTRL_REG */
N#define UART_1_BLE_TX_CTRL_DATA_WIDTH_POS     (0u)  /* [3:0] Data frame width: (Data width - 1) */
N#define UART_1_BLE_TX_CTRL_MSB_FIRST_POS      (8u)  /* [8]   MSB first shifter-out             */
N#define UART_1_BLE_TX_CTRL_ENABLED_POS        (31u) /* [31]  Transmitter enabled               */
N#define UART_1_BLE_TX_CTRL_DATA_WIDTH_MASK    ((uint32) 0x0Fu)
N#define UART_1_BLE_TX_CTRL_MSB_FIRST          ((uint32) 0x01u << UART_1_BLE_TX_CTRL_MSB_FIRST_POS)
N#define UART_1_BLE_TX_CTRL_LSB_FIRST          ((uint32) 0x00u)
N#define UART_1_BLE_TX_CTRL_ENABLED            ((uint32) 0x01u << UART_1_BLE_TX_CTRL_ENABLED_POS)
N
N/* UART_1_BLE_TX_CTRL_FIFO_REG */
N#define UART_1_BLE_TX_FIFO_CTRL_TRIGGER_LEVEL_POS     (0u)  /* [2:0] Trigger level                              */
N#define UART_1_BLE_TX_FIFO_CTRL_CLEAR_POS             (16u) /* [16]  Clear TX FIFO: cleared after set           */
N#define UART_1_BLE_TX_FIFO_CTRL_FREEZE_POS            (17u) /* [17]  Freeze TX FIFO: HW do not inc read pointer */
N#define UART_1_BLE_TX_FIFO_CTRL_TRIGGER_LEVEL_MASK    ((uint32) UART_1_BLE_FF_DATA_NR_LOG2_MASK)
N#define UART_1_BLE_TX_FIFO_CTRL_CLEAR                 ((uint32) 0x01u << UART_1_BLE_TX_FIFO_CTRL_CLEAR_POS)
N#define UART_1_BLE_TX_FIFO_CTRL_FREEZE                ((uint32) 0x01u << UART_1_BLE_TX_FIFO_CTRL_FREEZE_POS)
N
N/* UART_1_BLE_TX_FIFO_STATUS_REG */
N#define UART_1_BLE_TX_FIFO_STATUS_USED_POS    (0u)  /* [3:0]   Amount of entries in TX FIFO */
N#define UART_1_BLE_TX_FIFO_SR_VALID_POS       (15u) /* [15]    Shifter status of TX FIFO    */
N#define UART_1_BLE_TX_FIFO_STATUS_RD_PTR_POS  (16u) /* [18:16] TX FIFO read pointer         */
N#define UART_1_BLE_TX_FIFO_STATUS_WR_PTR_POS  (24u) /* [26:24] TX FIFO write pointer        */
N#define UART_1_BLE_TX_FIFO_STATUS_USED_MASK   ((uint32) UART_1_BLE_FF_DATA_NR_LOG2_PLUS1_MASK)
N#define UART_1_BLE_TX_FIFO_SR_VALID           ((uint32) 0x01u << UART_1_BLE_TX_FIFO_SR_VALID_POS)
N#define UART_1_BLE_TX_FIFO_STATUS_RD_PTR_MASK ((uint32) UART_1_BLE_FF_DATA_NR_LOG2_MASK << \
N                                                                    UART_1_BLE_TX_FIFO_STATUS_RD_PTR_POS)
X#define UART_1_BLE_TX_FIFO_STATUS_RD_PTR_MASK ((uint32) UART_1_BLE_FF_DATA_NR_LOG2_MASK <<                                                                     UART_1_BLE_TX_FIFO_STATUS_RD_PTR_POS)
N#define UART_1_BLE_TX_FIFO_STATUS_WR_PTR_MASK ((uint32) UART_1_BLE_FF_DATA_NR_LOG2_MASK << \
N                                                                    UART_1_BLE_TX_FIFO_STATUS_WR_PTR_POS)
X#define UART_1_BLE_TX_FIFO_STATUS_WR_PTR_MASK ((uint32) UART_1_BLE_FF_DATA_NR_LOG2_MASK <<                                                                     UART_1_BLE_TX_FIFO_STATUS_WR_PTR_POS)
N
N/* UART_1_BLE_TX_FIFO_WR_REG */
N#define UART_1_BLE_TX_FIFO_WR_POS    (0u)  /* [15:0] Data written into TX FIFO */
N#define UART_1_BLE_TX_FIFO_WR_MASK   ((uint32) 0xFFu)
N
N/* UART_1_BLE_RX_CTRL_REG */
N#define UART_1_BLE_RX_CTRL_DATA_WIDTH_POS     (0u)  /* [3:0] Data frame width: (Data width - 1) */
N#define UART_1_BLE_RX_CTRL_MSB_FIRST_POS      (8u)  /* [8]   MSB first shifter-out             */
N#define UART_1_BLE_RX_CTRL_MEDIAN_POS         (9u)  /* [9]   Median filter                     */
N#define UART_1_BLE_RX_CTRL_ENABLED_POS        (31u) /* [31]  Receiver enabled                  */
N#define UART_1_BLE_RX_CTRL_DATA_WIDTH_MASK    ((uint32) 0x0Fu)
N#define UART_1_BLE_RX_CTRL_MSB_FIRST          ((uint32) 0x01u << UART_1_BLE_RX_CTRL_MSB_FIRST_POS)
N#define UART_1_BLE_RX_CTRL_LSB_FIRST          ((uint32) 0x00u)
N#define UART_1_BLE_RX_CTRL_MEDIAN             ((uint32) 0x01u << UART_1_BLE_RX_CTRL_MEDIAN_POS)
N#define UART_1_BLE_RX_CTRL_ENABLED            ((uint32) 0x01u << UART_1_BLE_RX_CTRL_ENABLED_POS)
N
N
N/* UART_1_BLE_RX_FIFO_CTRL_REG */
N#define UART_1_BLE_RX_FIFO_CTRL_TRIGGER_LEVEL_POS     (0u)   /* [2:0] Trigger level                            */
N#define UART_1_BLE_RX_FIFO_CTRL_CLEAR_POS             (16u)  /* [16]  Clear RX FIFO: clear after set           */
N#define UART_1_BLE_RX_FIFO_CTRL_FREEZE_POS            (17u)  /* [17]  Freeze RX FIFO: HW writes has not effect */
N#define UART_1_BLE_RX_FIFO_CTRL_TRIGGER_LEVEL_MASK    ((uint32) UART_1_BLE_FF_DATA_NR_LOG2_MASK)
N#define UART_1_BLE_RX_FIFO_CTRL_CLEAR                 ((uint32) 0x01u << UART_1_BLE_RX_FIFO_CTRL_CLEAR_POS)
N#define UART_1_BLE_RX_FIFO_CTRL_FREEZE                ((uint32) 0x01u << UART_1_BLE_RX_FIFO_CTRL_FREEZE_POS)
N
N/* UART_1_BLE_RX_FIFO_STATUS_REG */
N#define UART_1_BLE_RX_FIFO_STATUS_USED_POS    (0u)   /* [3:0]   Amount of entries in RX FIFO */
N#define UART_1_BLE_RX_FIFO_SR_VALID_POS       (15u)  /* [15]    Shifter status of RX FIFO    */
N#define UART_1_BLE_RX_FIFO_STATUS_RD_PTR_POS  (16u)  /* [18:16] RX FIFO read pointer         */
N#define UART_1_BLE_RX_FIFO_STATUS_WR_PTR_POS  (24u)  /* [26:24] RX FIFO write pointer        */
N#define UART_1_BLE_RX_FIFO_STATUS_USED_MASK   ((uint32) UART_1_BLE_FF_DATA_NR_LOG2_PLUS1_MASK)
N#define UART_1_BLE_RX_FIFO_SR_VALID           ((uint32) 0x01u << UART_1_BLE_RX_FIFO_SR_VALID_POS)
N#define UART_1_BLE_RX_FIFO_STATUS_RD_PTR_MASK ((uint32) UART_1_BLE_FF_DATA_NR_LOG2_MASK << \
N                                                                    UART_1_BLE_RX_FIFO_STATUS_RD_PTR_POS)
X#define UART_1_BLE_RX_FIFO_STATUS_RD_PTR_MASK ((uint32) UART_1_BLE_FF_DATA_NR_LOG2_MASK <<                                                                     UART_1_BLE_RX_FIFO_STATUS_RD_PTR_POS)
N#define UART_1_BLE_RX_FIFO_STATUS_WR_PTR_MASK ((uint32) UART_1_BLE_FF_DATA_NR_LOG2_MASK << \
N                                                                    UART_1_BLE_RX_FIFO_STATUS_WR_PTR_POS)
X#define UART_1_BLE_RX_FIFO_STATUS_WR_PTR_MASK ((uint32) UART_1_BLE_FF_DATA_NR_LOG2_MASK <<                                                                     UART_1_BLE_RX_FIFO_STATUS_WR_PTR_POS)
N
N/* UART_1_BLE_RX_MATCH_REG */
N#define UART_1_BLE_RX_MATCH_ADDR_POS     (0u)  /* [7:0]   Slave address                        */
N#define UART_1_BLE_RX_MATCH_MASK_POS     (16u) /* [23:16] Slave address mask: 0 - doesn't care */
N#define UART_1_BLE_RX_MATCH_ADDR_MASK    ((uint32) 0xFFu)
N#define UART_1_BLE_RX_MATCH_MASK_MASK    ((uint32) 0xFFu << UART_1_BLE_RX_MATCH_MASK_POS)
N
N/* UART_1_BLE_RX_FIFO_WR_REG */
N#define UART_1_BLE_RX_FIFO_RD_POS    (0u)  /* [15:0] Data read from RX FIFO */
N#define UART_1_BLE_RX_FIFO_RD_MASK   ((uint32) 0xFFu)
N
N/* UART_1_BLE_RX_FIFO_RD_SILENT_REG */
N#define UART_1_BLE_RX_FIFO_RD_SILENT_POS     (0u)  /* [15:0] Data read from RX FIFO: not remove data from FIFO */
N#define UART_1_BLE_RX_FIFO_RD_SILENT_MASK    ((uint32) 0xFFu)
N
N/* UART_1_BLE_RX_FIFO_RD_SILENT_REG */
N#define UART_1_BLE_RX_FIFO_RD_SILENT_POS     (0u)  /* [15:0] Data read from RX FIFO: not remove data from FIFO */
N#define UART_1_BLE_RX_FIFO_RD_SILENT_MASK    ((uint32) 0xFFu)
N
N/* UART_1_BLE_EZBUF_DATA_REG */
N#define UART_1_BLE_EZBUF_DATA_POS   (0u)  /* [7:0] Data from EZ Memory */
N#define UART_1_BLE_EZBUF_DATA_MASK  ((uint32) 0xFFu)
N
N/*  UART_1_BLE_INTR_CAUSE_REG */
N#define UART_1_BLE_INTR_CAUSE_MASTER_POS  (0u)  /* [0] Master interrupt active                 */
N#define UART_1_BLE_INTR_CAUSE_SLAVE_POS   (1u)  /* [1] Slave interrupt active                  */
N#define UART_1_BLE_INTR_CAUSE_TX_POS      (2u)  /* [2] Transmitter interrupt active            */
N#define UART_1_BLE_INTR_CAUSE_RX_POS      (3u)  /* [3] Receiver interrupt active               */
N#define UART_1_BLE_INTR_CAUSE_I2C_EC_POS  (4u)  /* [4] Externally clock I2C interrupt active   */
N#define UART_1_BLE_INTR_CAUSE_SPI_EC_POS  (5u)  /* [5] Externally clocked SPI interrupt active */
N#define UART_1_BLE_INTR_CAUSE_MASTER      ((uint32) 0x01u)
N#define UART_1_BLE_INTR_CAUSE_SLAVE       ((uint32) 0x01u << UART_1_BLE_INTR_CAUSE_SLAVE_POS)
N#define UART_1_BLE_INTR_CAUSE_TX          ((uint32) 0x01u << UART_1_BLE_INTR_CAUSE_TX_POS)
N#define UART_1_BLE_INTR_CAUSE_RX          ((uint32) 0x01u << UART_1_BLE_INTR_CAUSE_RX_POS)
N#define UART_1_BLE_INTR_CAUSE_I2C_EC      ((uint32) 0x01u << UART_1_BLE_INTR_CAUSE_I2C_EC_POS)
N#define UART_1_BLE_INTR_CAUSE_SPI_EC      ((uint32) 0x01u << UART_1_BLE_INTR_CAUSE_SPI_EC_POS)
N
N/* UART_1_BLE_INTR_SPI_EC_REG, UART_1_BLE_INTR_SPI_EC_MASK_REG, UART_1_BLE_INTR_SPI_EC_MASKED_REG */
N#define UART_1_BLE_INTR_SPI_EC_WAKE_UP_POS          (0u)  /* [0] Address match: triggers wakeup of chip */
N#define UART_1_BLE_INTR_SPI_EC_EZBUF_STOP_POS       (1u)  /* [1] Externally clocked Stop detected       */
N#define UART_1_BLE_INTR_SPI_EC_EZBUF_WRITE_STOP_POS (2u)  /* [2] Externally clocked Write Stop detected */
N#define UART_1_BLE_INTR_SPI_EC_WAKE_UP              ((uint32) 0x01u)
N#define UART_1_BLE_INTR_SPI_EC_EZBUF_STOP           ((uint32) 0x01u << \
N                                                                    UART_1_BLE_INTR_SPI_EC_EZBUF_STOP_POS)
X#define UART_1_BLE_INTR_SPI_EC_EZBUF_STOP           ((uint32) 0x01u <<                                                                     UART_1_BLE_INTR_SPI_EC_EZBUF_STOP_POS)
N#define UART_1_BLE_INTR_SPI_EC_EZBUF_WRITE_STOP     ((uint32) 0x01u << \
N                                                                    UART_1_BLE_INTR_SPI_EC_EZBUF_WRITE_STOP_POS)
X#define UART_1_BLE_INTR_SPI_EC_EZBUF_WRITE_STOP     ((uint32) 0x01u <<                                                                     UART_1_BLE_INTR_SPI_EC_EZBUF_WRITE_STOP_POS)
N
N/* UART_1_BLE_INTR_I2C_EC, UART_1_BLE_INTR_I2C_EC_MASK, UART_1_BLE_INTR_I2C_EC_MASKED */
N#define UART_1_BLE_INTR_I2C_EC_WAKE_UP_POS          (0u)  /* [0] Address match: triggers wakeup of chip */
N#define UART_1_BLE_INTR_I2C_EC_EZBUF_STOP_POS       (1u)  /* [1] Externally clocked Stop detected       */
N#define UART_1_BLE_INTR_I2C_EC_EZBUF_WRITE_STOP_POS (2u)  /* [2] Externally clocked Write Stop detected */
N#define UART_1_BLE_INTR_I2C_EC_WAKE_UP              ((uint32) 0x01u)
N#define UART_1_BLE_INTR_I2C_EC_EZBUF_STOP           ((uint32) 0x01u << \
N                                                                    UART_1_BLE_INTR_I2C_EC_EZBUF_STOP_POS)
X#define UART_1_BLE_INTR_I2C_EC_EZBUF_STOP           ((uint32) 0x01u <<                                                                     UART_1_BLE_INTR_I2C_EC_EZBUF_STOP_POS)
N#define UART_1_BLE_INTR_I2C_EC_EZBUF_WRITE_STOP     ((uint32) 0x01u << \
N                                                                    UART_1_BLE_INTR_I2C_EC_EZBUF_WRITE_STOP_POS)
X#define UART_1_BLE_INTR_I2C_EC_EZBUF_WRITE_STOP     ((uint32) 0x01u <<                                                                     UART_1_BLE_INTR_I2C_EC_EZBUF_WRITE_STOP_POS)
N
N/* UART_1_BLE_INTR_MASTER, UART_1_BLE_INTR_MASTER_SET,
N   UART_1_BLE_INTR_MASTER_MASK, UART_1_BLE_INTR_MASTER_MASKED */
N#define UART_1_BLE_INTR_MASTER_I2C_ARB_LOST_POS   (0u)  /* [0] Master lost arbitration                          */
N#define UART_1_BLE_INTR_MASTER_I2C_NACK_POS       (1u)  /* [1] Master receives NACK: address or write to slave  */
N#define UART_1_BLE_INTR_MASTER_I2C_ACK_POS        (2u)  /* [2] Master receives NACK: address or write to slave  */
N#define UART_1_BLE_INTR_MASTER_I2C_STOP_POS       (4u)  /* [4] Master detects the Stop: only self generated Stop*/
N#define UART_1_BLE_INTR_MASTER_I2C_BUS_ERROR_POS  (8u)  /* [8] Master detects bus error: misplaced Start or Stop*/
N#define UART_1_BLE_INTR_MASTER_SPI_DONE_POS       (9u)  /* [9] Master complete transfer: Only for SPI           */
N#define UART_1_BLE_INTR_MASTER_I2C_ARB_LOST       ((uint32) 0x01u)
N#define UART_1_BLE_INTR_MASTER_I2C_NACK           ((uint32) 0x01u << UART_1_BLE_INTR_MASTER_I2C_NACK_POS)
N#define UART_1_BLE_INTR_MASTER_I2C_ACK            ((uint32) 0x01u << UART_1_BLE_INTR_MASTER_I2C_ACK_POS)
N#define UART_1_BLE_INTR_MASTER_I2C_STOP           ((uint32) 0x01u << UART_1_BLE_INTR_MASTER_I2C_STOP_POS)
N#define UART_1_BLE_INTR_MASTER_I2C_BUS_ERROR      ((uint32) 0x01u << \
N                                                                    UART_1_BLE_INTR_MASTER_I2C_BUS_ERROR_POS)
X#define UART_1_BLE_INTR_MASTER_I2C_BUS_ERROR      ((uint32) 0x01u <<                                                                     UART_1_BLE_INTR_MASTER_I2C_BUS_ERROR_POS)
N#define UART_1_BLE_INTR_MASTER_SPI_DONE           ((uint32) 0x01u << UART_1_BLE_INTR_MASTER_SPI_DONE_POS)
N
N/*
N* UART_1_BLE_INTR_SLAVE, UART_1_BLE_INTR_SLAVE_SET,
N* UART_1_BLE_INTR_SLAVE_MASK, UART_1_BLE_INTR_SLAVE_MASKED
N*/
N#define UART_1_BLE_INTR_SLAVE_I2C_ARB_LOST_POS         (0u)  /* [0]  Slave lost arbitration                   */
N#define UART_1_BLE_INTR_SLAVE_I2C_NACK_POS             (1u)  /* [1]  Slave receives NACK: master reads data   */
N#define UART_1_BLE_INTR_SLAVE_I2C_ACK_POS              (2u)  /* [2]  Slave receives ACK: master reads data    */
N#define UART_1_BLE_INTR_SLAVE_I2C_WRITE_STOP_POS       (3u)  /* [3]  Slave detects end of write transaction   */
N#define UART_1_BLE_INTR_SLAVE_I2C_STOP_POS             (4u)  /* [4]  Slave detects end of transaction intended */
N#define UART_1_BLE_INTR_SLAVE_I2C_START_POS            (5u)  /* [5]  Slave detects Start                      */
N#define UART_1_BLE_INTR_SLAVE_I2C_ADDR_MATCH_POS       (6u)  /* [6]  Slave address matches                    */
N#define UART_1_BLE_INTR_SLAVE_I2C_GENERAL_POS          (7u)  /* [7]  General call received                    */
N#define UART_1_BLE_INTR_SLAVE_I2C_BUS_ERROR_POS        (8u)  /* [8]  Slave detects bus error                  */
N#define UART_1_BLE_INTR_SLAVE_SPI_EZBUF_WRITE_STOP_POS (9u)  /* [9]  Slave write complete: Only for SPI       */
N#define UART_1_BLE_INTR_SLAVE_SPI_EZBUF_STOP_POS       (10u) /* [10] Slave end of transaction: Only for SPI   */
N#define UART_1_BLE_INTR_SLAVE_SPI_BUS_ERROR_POS        (11u) /* [11] Slave detects bus error: Only for SPI    */
N#define UART_1_BLE_INTR_SLAVE_I2C_ARB_LOST             ((uint32) 0x01u)
N#define UART_1_BLE_INTR_SLAVE_I2C_NACK                 ((uint32) 0x01u << \
N                                                                    UART_1_BLE_INTR_SLAVE_I2C_NACK_POS)
X#define UART_1_BLE_INTR_SLAVE_I2C_NACK                 ((uint32) 0x01u <<                                                                     UART_1_BLE_INTR_SLAVE_I2C_NACK_POS)
N#define UART_1_BLE_INTR_SLAVE_I2C_ACK                  ((uint32) 0x01u << \
N                                                                    UART_1_BLE_INTR_SLAVE_I2C_ACK_POS)
X#define UART_1_BLE_INTR_SLAVE_I2C_ACK                  ((uint32) 0x01u <<                                                                     UART_1_BLE_INTR_SLAVE_I2C_ACK_POS)
N#define UART_1_BLE_INTR_SLAVE_I2C_WRITE_STOP           ((uint32) 0x01u << \
N                                                                    UART_1_BLE_INTR_SLAVE_I2C_WRITE_STOP_POS)
X#define UART_1_BLE_INTR_SLAVE_I2C_WRITE_STOP           ((uint32) 0x01u <<                                                                     UART_1_BLE_INTR_SLAVE_I2C_WRITE_STOP_POS)
N#define UART_1_BLE_INTR_SLAVE_I2C_STOP                 ((uint32) 0x01u << \
N                                                                    UART_1_BLE_INTR_SLAVE_I2C_STOP_POS)
X#define UART_1_BLE_INTR_SLAVE_I2C_STOP                 ((uint32) 0x01u <<                                                                     UART_1_BLE_INTR_SLAVE_I2C_STOP_POS)
N#define UART_1_BLE_INTR_SLAVE_I2C_START                ((uint32) 0x01u << \
N                                                                    UART_1_BLE_INTR_SLAVE_I2C_START_POS)
X#define UART_1_BLE_INTR_SLAVE_I2C_START                ((uint32) 0x01u <<                                                                     UART_1_BLE_INTR_SLAVE_I2C_START_POS)
N#define UART_1_BLE_INTR_SLAVE_I2C_ADDR_MATCH           ((uint32) 0x01u << \
N                                                                    UART_1_BLE_INTR_SLAVE_I2C_ADDR_MATCH_POS)
X#define UART_1_BLE_INTR_SLAVE_I2C_ADDR_MATCH           ((uint32) 0x01u <<                                                                     UART_1_BLE_INTR_SLAVE_I2C_ADDR_MATCH_POS)
N#define UART_1_BLE_INTR_SLAVE_I2C_GENERAL              ((uint32) 0x01u << \
N                                                                    UART_1_BLE_INTR_SLAVE_I2C_GENERAL_POS)
X#define UART_1_BLE_INTR_SLAVE_I2C_GENERAL              ((uint32) 0x01u <<                                                                     UART_1_BLE_INTR_SLAVE_I2C_GENERAL_POS)
N#define UART_1_BLE_INTR_SLAVE_I2C_BUS_ERROR            ((uint32) 0x01u << \
N                                                                    UART_1_BLE_INTR_SLAVE_I2C_BUS_ERROR_POS)
X#define UART_1_BLE_INTR_SLAVE_I2C_BUS_ERROR            ((uint32) 0x01u <<                                                                     UART_1_BLE_INTR_SLAVE_I2C_BUS_ERROR_POS)
N#define UART_1_BLE_INTR_SLAVE_SPI_EZBUF_WRITE_STOP     ((uint32) 0x01u << \
N                                                                   UART_1_BLE_INTR_SLAVE_SPI_EZBUF_WRITE_STOP_POS)
X#define UART_1_BLE_INTR_SLAVE_SPI_EZBUF_WRITE_STOP     ((uint32) 0x01u <<                                                                    UART_1_BLE_INTR_SLAVE_SPI_EZBUF_WRITE_STOP_POS)
N#define UART_1_BLE_INTR_SLAVE_SPI_EZBUF_STOP           ((uint32) 0x01u << \
N                                                                    UART_1_BLE_INTR_SLAVE_SPI_EZBUF_STOP_POS)
X#define UART_1_BLE_INTR_SLAVE_SPI_EZBUF_STOP           ((uint32) 0x01u <<                                                                     UART_1_BLE_INTR_SLAVE_SPI_EZBUF_STOP_POS)
N#define UART_1_BLE_INTR_SLAVE_SPI_BUS_ERROR           ((uint32) 0x01u << \
N                                                                    UART_1_BLE_INTR_SLAVE_SPI_BUS_ERROR_POS)
X#define UART_1_BLE_INTR_SLAVE_SPI_BUS_ERROR           ((uint32) 0x01u <<                                                                     UART_1_BLE_INTR_SLAVE_SPI_BUS_ERROR_POS)
N
N/*
N* UART_1_BLE_INTR_TX, UART_1_BLE_INTR_TX_SET,
N* UART_1_BLE_INTR_TX_MASK, UART_1_BLE_INTR_TX_MASKED
N*/
N#define UART_1_BLE_INTR_TX_TRIGGER_POS        (0u)  /* [0]  Trigger on TX FIFO entires                       */
N#define UART_1_BLE_INTR_TX_NOT_FULL_POS       (1u)  /* [1]  TX FIFO is not full                              */
N#define UART_1_BLE_INTR_TX_EMPTY_POS          (4u)  /* [4]  TX FIFO is empty                                 */
N#define UART_1_BLE_INTR_TX_OVERFLOW_POS       (5u)  /* [5]  Attempt to write to a full TX FIFO               */
N#define UART_1_BLE_INTR_TX_UNDERFLOW_POS      (6u)  /* [6]  Attempt to read from an empty TX FIFO            */
N#define UART_1_BLE_INTR_TX_BLOCKED_POS        (7u)  /* [7]  No access to the EZ memory                       */
N#define UART_1_BLE_INTR_TX_UART_NACK_POS      (8u)  /* [8]  UART transmitter received a NACK: SmartCard mode */
N#define UART_1_BLE_INTR_TX_UART_DONE_POS      (9u)  /* [9]  UART transmitter done even                       */
N#define UART_1_BLE_INTR_TX_UART_ARB_LOST_POS  (10u) /* [10] UART lost arbitration: LIN or SmartCard          */
N#define UART_1_BLE_INTR_TX_TRIGGER            ((uint32) 0x01u)
N#define UART_1_BLE_INTR_TX_FIFO_LEVEL         (UART_1_BLE_INTR_TX_TRIGGER)
N#define UART_1_BLE_INTR_TX_NOT_FULL           ((uint32) 0x01u << UART_1_BLE_INTR_TX_NOT_FULL_POS)
N#define UART_1_BLE_INTR_TX_EMPTY              ((uint32) 0x01u << UART_1_BLE_INTR_TX_EMPTY_POS)
N#define UART_1_BLE_INTR_TX_OVERFLOW           ((uint32) 0x01u << UART_1_BLE_INTR_TX_OVERFLOW_POS)
N#define UART_1_BLE_INTR_TX_UNDERFLOW          ((uint32) 0x01u << UART_1_BLE_INTR_TX_UNDERFLOW_POS)
N#define UART_1_BLE_INTR_TX_BLOCKED            ((uint32) 0x01u << UART_1_BLE_INTR_TX_BLOCKED_POS)
N#define UART_1_BLE_INTR_TX_UART_NACK          ((uint32) 0x01u << UART_1_BLE_INTR_TX_UART_NACK_POS)
N#define UART_1_BLE_INTR_TX_UART_DONE          ((uint32) 0x01u << UART_1_BLE_INTR_TX_UART_DONE_POS)
N#define UART_1_BLE_INTR_TX_UART_ARB_LOST      ((uint32) 0x01u << UART_1_BLE_INTR_TX_UART_ARB_LOST_POS)
N
N/*
N* UART_1_BLE_INTR_RX, UART_1_BLE_INTR_RX_SET,
N* UART_1_BLE_INTR_RX_MASK, UART_1_BLE_INTR_RX_MASKED
N*/
N#define UART_1_BLE_INTR_RX_TRIGGER_POS        (0u)   /* [0]  Trigger on RX FIFO entires            */
N#define UART_1_BLE_INTR_RX_NOT_EMPTY_POS      (2u)   /* [2]  RX FIFO is not empty                  */
N#define UART_1_BLE_INTR_RX_FULL_POS           (3u)   /* [3]  RX FIFO is full                       */
N#define UART_1_BLE_INTR_RX_OVERFLOW_POS       (5u)   /* [5]  Attempt to write to a full RX FIFO    */
N#define UART_1_BLE_INTR_RX_UNDERFLOW_POS      (6u)   /* [6]  Attempt to read from an empty RX FIFO */
N#define UART_1_BLE_INTR_RX_BLOCKED_POS        (7u)   /* [7]  No access to the EZ memory            */
N#define UART_1_BLE_INTR_RX_FRAME_ERROR_POS    (8u)   /* [8]  Frame error in received data frame    */
N#define UART_1_BLE_INTR_RX_PARITY_ERROR_POS   (9u)   /* [9]  Parity error in received data frame   */
N#define UART_1_BLE_INTR_RX_BAUD_DETECT_POS    (10u)  /* [10] LIN baud rate detection is completed   */
N#define UART_1_BLE_INTR_RX_BREAK_DETECT_POS   (11u)  /* [11] Break detection is successful         */
N#define UART_1_BLE_INTR_RX_TRIGGER            ((uint32) 0x01u)
N#define UART_1_BLE_INTR_RX_FIFO_LEVEL         (UART_1_BLE_INTR_RX_TRIGGER)
N#define UART_1_BLE_INTR_RX_NOT_EMPTY          ((uint32) 0x01u << UART_1_BLE_INTR_RX_NOT_EMPTY_POS)
N#define UART_1_BLE_INTR_RX_FULL               ((uint32) 0x01u << UART_1_BLE_INTR_RX_FULL_POS)
N#define UART_1_BLE_INTR_RX_OVERFLOW           ((uint32) 0x01u << UART_1_BLE_INTR_RX_OVERFLOW_POS)
N#define UART_1_BLE_INTR_RX_UNDERFLOW          ((uint32) 0x01u << UART_1_BLE_INTR_RX_UNDERFLOW_POS)
N#define UART_1_BLE_INTR_RX_BLOCKED            ((uint32) 0x01u << UART_1_BLE_INTR_RX_BLOCKED_POS)
N#define UART_1_BLE_INTR_RX_FRAME_ERROR        ((uint32) 0x01u << UART_1_BLE_INTR_RX_FRAME_ERROR_POS)
N#define UART_1_BLE_INTR_RX_PARITY_ERROR       ((uint32) 0x01u << UART_1_BLE_INTR_RX_PARITY_ERROR_POS)
N#define UART_1_BLE_INTR_RX_BAUD_DETECT        ((uint32) 0x01u << UART_1_BLE_INTR_RX_BAUD_DETECT_POS)
N#define UART_1_BLE_INTR_RX_BREAK_DETECT       ((uint32) 0x01u << UART_1_BLE_INTR_RX_BREAK_DETECT_POS)
N
N/* Define all interrupt sources */
N#define UART_1_BLE_INTR_I2C_EC_ALL    (UART_1_BLE_INTR_I2C_EC_WAKE_UP    | \
N                                             UART_1_BLE_INTR_I2C_EC_EZBUF_STOP | \
N                                             UART_1_BLE_INTR_I2C_EC_EZBUF_WRITE_STOP)
X#define UART_1_BLE_INTR_I2C_EC_ALL    (UART_1_BLE_INTR_I2C_EC_WAKE_UP    |                                              UART_1_BLE_INTR_I2C_EC_EZBUF_STOP |                                              UART_1_BLE_INTR_I2C_EC_EZBUF_WRITE_STOP)
N
N#define UART_1_BLE_INTR_SPI_EC_ALL    (UART_1_BLE_INTR_SPI_EC_WAKE_UP    | \
N                                             UART_1_BLE_INTR_SPI_EC_EZBUF_STOP | \
N                                             UART_1_BLE_INTR_SPI_EC_EZBUF_WRITE_STOP)
X#define UART_1_BLE_INTR_SPI_EC_ALL    (UART_1_BLE_INTR_SPI_EC_WAKE_UP    |                                              UART_1_BLE_INTR_SPI_EC_EZBUF_STOP |                                              UART_1_BLE_INTR_SPI_EC_EZBUF_WRITE_STOP)
N
N#define UART_1_BLE_INTR_MASTER_ALL    (UART_1_BLE_INTR_MASTER_I2C_ARB_LOST  | \
N                                             UART_1_BLE_INTR_MASTER_I2C_NACK      | \
N                                             UART_1_BLE_INTR_MASTER_I2C_ACK       | \
N                                             UART_1_BLE_INTR_MASTER_I2C_STOP      | \
N                                             UART_1_BLE_INTR_MASTER_I2C_BUS_ERROR | \
N                                             UART_1_BLE_INTR_MASTER_SPI_DONE)
X#define UART_1_BLE_INTR_MASTER_ALL    (UART_1_BLE_INTR_MASTER_I2C_ARB_LOST  |                                              UART_1_BLE_INTR_MASTER_I2C_NACK      |                                              UART_1_BLE_INTR_MASTER_I2C_ACK       |                                              UART_1_BLE_INTR_MASTER_I2C_STOP      |                                              UART_1_BLE_INTR_MASTER_I2C_BUS_ERROR |                                              UART_1_BLE_INTR_MASTER_SPI_DONE)
N
N#define UART_1_BLE_INTR_SLAVE_ALL     (UART_1_BLE_INTR_SLAVE_I2C_ARB_LOST      | \
N                                             UART_1_BLE_INTR_SLAVE_I2C_NACK          | \
N                                             UART_1_BLE_INTR_SLAVE_I2C_ACK           | \
N                                             UART_1_BLE_INTR_SLAVE_I2C_WRITE_STOP    | \
N                                             UART_1_BLE_INTR_SLAVE_I2C_STOP          | \
N                                             UART_1_BLE_INTR_SLAVE_I2C_START         | \
N                                             UART_1_BLE_INTR_SLAVE_I2C_ADDR_MATCH    | \
N                                             UART_1_BLE_INTR_SLAVE_I2C_GENERAL       | \
N                                             UART_1_BLE_INTR_SLAVE_I2C_BUS_ERROR     | \
N                                             UART_1_BLE_INTR_SLAVE_SPI_EZBUF_WRITE_STOP | \
N                                             UART_1_BLE_INTR_SLAVE_SPI_EZBUF_STOP       | \
N                                             UART_1_BLE_INTR_SLAVE_SPI_BUS_ERROR)
X#define UART_1_BLE_INTR_SLAVE_ALL     (UART_1_BLE_INTR_SLAVE_I2C_ARB_LOST      |                                              UART_1_BLE_INTR_SLAVE_I2C_NACK          |                                              UART_1_BLE_INTR_SLAVE_I2C_ACK           |                                              UART_1_BLE_INTR_SLAVE_I2C_WRITE_STOP    |                                              UART_1_BLE_INTR_SLAVE_I2C_STOP          |                                              UART_1_BLE_INTR_SLAVE_I2C_START         |                                              UART_1_BLE_INTR_SLAVE_I2C_ADDR_MATCH    |                                              UART_1_BLE_INTR_SLAVE_I2C_GENERAL       |                                              UART_1_BLE_INTR_SLAVE_I2C_BUS_ERROR     |                                              UART_1_BLE_INTR_SLAVE_SPI_EZBUF_WRITE_STOP |                                              UART_1_BLE_INTR_SLAVE_SPI_EZBUF_STOP       |                                              UART_1_BLE_INTR_SLAVE_SPI_BUS_ERROR)
N
N#define UART_1_BLE_INTR_TX_ALL        (UART_1_BLE_INTR_TX_TRIGGER   | \
N                                             UART_1_BLE_INTR_TX_NOT_FULL  | \
N                                             UART_1_BLE_INTR_TX_EMPTY     | \
N                                             UART_1_BLE_INTR_TX_OVERFLOW  | \
N                                             UART_1_BLE_INTR_TX_UNDERFLOW | \
N                                             UART_1_BLE_INTR_TX_BLOCKED   | \
N                                             UART_1_BLE_INTR_TX_UART_NACK | \
N                                             UART_1_BLE_INTR_TX_UART_DONE | \
N                                             UART_1_BLE_INTR_TX_UART_ARB_LOST)
X#define UART_1_BLE_INTR_TX_ALL        (UART_1_BLE_INTR_TX_TRIGGER   |                                              UART_1_BLE_INTR_TX_NOT_FULL  |                                              UART_1_BLE_INTR_TX_EMPTY     |                                              UART_1_BLE_INTR_TX_OVERFLOW  |                                              UART_1_BLE_INTR_TX_UNDERFLOW |                                              UART_1_BLE_INTR_TX_BLOCKED   |                                              UART_1_BLE_INTR_TX_UART_NACK |                                              UART_1_BLE_INTR_TX_UART_DONE |                                              UART_1_BLE_INTR_TX_UART_ARB_LOST)
N
N#define UART_1_BLE_INTR_RX_ALL        (UART_1_BLE_INTR_RX_TRIGGER      | \
N                                             UART_1_BLE_INTR_RX_NOT_EMPTY    | \
N                                             UART_1_BLE_INTR_RX_FULL         | \
N                                             UART_1_BLE_INTR_RX_OVERFLOW     | \
N                                             UART_1_BLE_INTR_RX_UNDERFLOW    | \
N                                             UART_1_BLE_INTR_RX_BLOCKED      | \
N                                             UART_1_BLE_INTR_RX_FRAME_ERROR  | \
N                                             UART_1_BLE_INTR_RX_PARITY_ERROR | \
N                                             UART_1_BLE_INTR_RX_BAUD_DETECT  | \
N                                             UART_1_BLE_INTR_RX_BREAK_DETECT)
X#define UART_1_BLE_INTR_RX_ALL        (UART_1_BLE_INTR_RX_TRIGGER      |                                              UART_1_BLE_INTR_RX_NOT_EMPTY    |                                              UART_1_BLE_INTR_RX_FULL         |                                              UART_1_BLE_INTR_RX_OVERFLOW     |                                              UART_1_BLE_INTR_RX_UNDERFLOW    |                                              UART_1_BLE_INTR_RX_BLOCKED      |                                              UART_1_BLE_INTR_RX_FRAME_ERROR  |                                              UART_1_BLE_INTR_RX_PARITY_ERROR |                                              UART_1_BLE_INTR_RX_BAUD_DETECT  |                                              UART_1_BLE_INTR_RX_BREAK_DETECT)
N
N/* I2C and EZI2C slave address defines */
N#define UART_1_BLE_I2C_SLAVE_ADDR_POS    (0x01u)    /* 7-bit address shift */
N#define UART_1_BLE_I2C_SLAVE_ADDR_MASK   (0xFEu)    /* 8-bit address mask */
N
N/* OVS constants for IrDA Low Power operation */
N#define UART_1_BLE_CTRL_OVS_IRDA_LP_OVS16     (0x00u)
N#define UART_1_BLE_CTRL_OVS_IRDA_LP_OVS32     (0x01u)
N#define UART_1_BLE_CTRL_OVS_IRDA_LP_OVS48     (0x02u)
N#define UART_1_BLE_CTRL_OVS_IRDA_LP_OVS96     (0x03u)
N#define UART_1_BLE_CTRL_OVS_IRDA_LP_OVS192    (0x04u)
N#define UART_1_BLE_CTRL_OVS_IRDA_LP_OVS768    (0x05u)
N#define UART_1_BLE_CTRL_OVS_IRDA_LP_OVS1536   (0x06u)
N
N/* OVS constant for IrDA */
N#define UART_1_BLE_CTRL_OVS_IRDA_OVS16        (UART_1_BLE_UART_IRDA_LP_OVS16)
N
N
N/***************************************
N*    Common Macro Definitions
N***************************************/
N
N/* Re-enables the SCB IP. A clear enable bit has a different effect
N* on the scb IP depending on the version:
N*  CY_SCBIP_V0: resets state, status, TX and RX FIFOs.
N*  CY_SCBIP_V1 or later: resets state, status, TX and RX FIFOs and interrupt sources.
N* Clear I2C command registers are because they are not impacted by re-enable.
N*/
N#define UART_1_BLE_SCB_SW_RESET   UART_1_BLE_I2CFwBlockReset()
N
N/* TX FIFO macro */
N#define UART_1_BLE_CLEAR_TX_FIFO \
N                            do{        \
N                                UART_1_BLE_TX_FIFO_CTRL_REG |= ((uint32)  UART_1_BLE_TX_FIFO_CTRL_CLEAR); \
N                                UART_1_BLE_TX_FIFO_CTRL_REG &= ((uint32) ~UART_1_BLE_TX_FIFO_CTRL_CLEAR); \
N                            }while(0)
X#define UART_1_BLE_CLEAR_TX_FIFO                             do{                                        UART_1_BLE_TX_FIFO_CTRL_REG |= ((uint32)  UART_1_BLE_TX_FIFO_CTRL_CLEAR);                                 UART_1_BLE_TX_FIFO_CTRL_REG &= ((uint32) ~UART_1_BLE_TX_FIFO_CTRL_CLEAR);                             }while(0)
N
N#define UART_1_BLE_GET_TX_FIFO_ENTRIES    (UART_1_BLE_TX_FIFO_STATUS_REG & \
N                                                 UART_1_BLE_TX_FIFO_STATUS_USED_MASK)
X#define UART_1_BLE_GET_TX_FIFO_ENTRIES    (UART_1_BLE_TX_FIFO_STATUS_REG &                                                  UART_1_BLE_TX_FIFO_STATUS_USED_MASK)
N
N#define UART_1_BLE_GET_TX_FIFO_SR_VALID   ((0u != (UART_1_BLE_TX_FIFO_STATUS_REG & \
N                                                         UART_1_BLE_TX_FIFO_SR_VALID)) ? (1u) : (0u))
X#define UART_1_BLE_GET_TX_FIFO_SR_VALID   ((0u != (UART_1_BLE_TX_FIFO_STATUS_REG &                                                          UART_1_BLE_TX_FIFO_SR_VALID)) ? (1u) : (0u))
N
N/* RX FIFO macro */
N#define UART_1_BLE_CLEAR_RX_FIFO \
N                            do{        \
N                                UART_1_BLE_RX_FIFO_CTRL_REG |= ((uint32)  UART_1_BLE_RX_FIFO_CTRL_CLEAR); \
N                                UART_1_BLE_RX_FIFO_CTRL_REG &= ((uint32) ~UART_1_BLE_RX_FIFO_CTRL_CLEAR); \
N                            }while(0)
X#define UART_1_BLE_CLEAR_RX_FIFO                             do{                                        UART_1_BLE_RX_FIFO_CTRL_REG |= ((uint32)  UART_1_BLE_RX_FIFO_CTRL_CLEAR);                                 UART_1_BLE_RX_FIFO_CTRL_REG &= ((uint32) ~UART_1_BLE_RX_FIFO_CTRL_CLEAR);                             }while(0)
N
N#define UART_1_BLE_GET_RX_FIFO_ENTRIES    (UART_1_BLE_RX_FIFO_STATUS_REG & \
N                                                    UART_1_BLE_RX_FIFO_STATUS_USED_MASK)
X#define UART_1_BLE_GET_RX_FIFO_ENTRIES    (UART_1_BLE_RX_FIFO_STATUS_REG &                                                     UART_1_BLE_RX_FIFO_STATUS_USED_MASK)
N
N#define UART_1_BLE_GET_RX_FIFO_SR_VALID   ((0u != (UART_1_BLE_RX_FIFO_STATUS_REG & \
N                                                         UART_1_BLE_RX_FIFO_SR_VALID)) ? (1u) : (0u))
X#define UART_1_BLE_GET_RX_FIFO_SR_VALID   ((0u != (UART_1_BLE_RX_FIFO_STATUS_REG &                                                          UART_1_BLE_RX_FIFO_SR_VALID)) ? (1u) : (0u))
N
N/* Write interrupt source: set sourceMask bits in UART_1_BLE_INTR_X_MASK_REG */
N#define UART_1_BLE_WRITE_INTR_I2C_EC_MASK(sourceMask) \
N                                                do{         \
N                                                    UART_1_BLE_INTR_I2C_EC_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_BLE_WRITE_INTR_I2C_EC_MASK(sourceMask)                                                 do{                                                             UART_1_BLE_INTR_I2C_EC_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#if (!UART_1_BLE_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_1_BLE_WRITE_INTR_SPI_EC_MASK(sourceMask) \
N                                                do{         \
N                                                    UART_1_BLE_INTR_SPI_EC_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X    #define UART_1_BLE_WRITE_INTR_SPI_EC_MASK(sourceMask)                                                 do{                                                             UART_1_BLE_INTR_SPI_EC_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N#endif /* (!UART_1_BLE_CY_SCBIP_V1) */
N
N#define UART_1_BLE_WRITE_INTR_MASTER_MASK(sourceMask) \
N                                                do{         \
N                                                    UART_1_BLE_INTR_MASTER_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_BLE_WRITE_INTR_MASTER_MASK(sourceMask)                                                 do{                                                             UART_1_BLE_INTR_MASTER_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_BLE_WRITE_INTR_SLAVE_MASK(sourceMask)  \
N                                                do{         \
N                                                    UART_1_BLE_INTR_SLAVE_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_BLE_WRITE_INTR_SLAVE_MASK(sourceMask)                                                  do{                                                             UART_1_BLE_INTR_SLAVE_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_BLE_WRITE_INTR_TX_MASK(sourceMask)     \
N                                                do{         \
N                                                    UART_1_BLE_INTR_TX_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_BLE_WRITE_INTR_TX_MASK(sourceMask)                                                     do{                                                             UART_1_BLE_INTR_TX_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_BLE_WRITE_INTR_RX_MASK(sourceMask)     \
N                                                do{         \
N                                                    UART_1_BLE_INTR_RX_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_BLE_WRITE_INTR_RX_MASK(sourceMask)                                                     do{                                                             UART_1_BLE_INTR_RX_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N/* Enable interrupt source: set sourceMask bits in UART_1_BLE_INTR_X_MASK_REG */
N#define UART_1_BLE_ENABLE_INTR_I2C_EC(sourceMask) \
N                                                do{     \
N                                                    UART_1_BLE_INTR_I2C_EC_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_BLE_ENABLE_INTR_I2C_EC(sourceMask)                                                 do{                                                         UART_1_BLE_INTR_I2C_EC_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N#if (!UART_1_BLE_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_1_BLE_ENABLE_INTR_SPI_EC(sourceMask) \
N                                                do{     \
N                                                    UART_1_BLE_INTR_SPI_EC_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X    #define UART_1_BLE_ENABLE_INTR_SPI_EC(sourceMask)                                                 do{                                                         UART_1_BLE_INTR_SPI_EC_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N#endif /* (!UART_1_BLE_CY_SCBIP_V1) */
N
N#define UART_1_BLE_ENABLE_INTR_MASTER(sourceMask) \
N                                                do{     \
N                                                    UART_1_BLE_INTR_MASTER_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_BLE_ENABLE_INTR_MASTER(sourceMask)                                                 do{                                                         UART_1_BLE_INTR_MASTER_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_BLE_ENABLE_INTR_SLAVE(sourceMask)  \
N                                                do{     \
N                                                    UART_1_BLE_INTR_SLAVE_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_BLE_ENABLE_INTR_SLAVE(sourceMask)                                                  do{                                                         UART_1_BLE_INTR_SLAVE_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_BLE_ENABLE_INTR_TX(sourceMask)     \
N                                                do{     \
N                                                    UART_1_BLE_INTR_TX_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_BLE_ENABLE_INTR_TX(sourceMask)                                                     do{                                                         UART_1_BLE_INTR_TX_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_BLE_ENABLE_INTR_RX(sourceMask)     \
N                                                do{     \
N                                                    UART_1_BLE_INTR_RX_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_BLE_ENABLE_INTR_RX(sourceMask)                                                     do{                                                         UART_1_BLE_INTR_RX_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N/* Disable interrupt source: clear sourceMask bits in UART_1_BLE_INTR_X_MASK_REG */
N#define UART_1_BLE_DISABLE_INTR_I2C_EC(sourceMask) \
N                                do{                      \
N                                    UART_1_BLE_INTR_I2C_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define UART_1_BLE_DISABLE_INTR_I2C_EC(sourceMask)                                 do{                                                          UART_1_BLE_INTR_I2C_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N#if (!UART_1_BLE_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_1_BLE_DISABLE_INTR_SPI_EC(sourceMask) \
N                                do{                      \
N                                    UART_1_BLE_INTR_SPI_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                 }while(0)
X    #define UART_1_BLE_DISABLE_INTR_SPI_EC(sourceMask)                                 do{                                                          UART_1_BLE_INTR_SPI_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                  }while(0)
N#endif /* (!UART_1_BLE_CY_SCBIP_V1) */
N
N#define UART_1_BLE_DISABLE_INTR_MASTER(sourceMask) \
N                                do{                      \
N                                UART_1_BLE_INTR_MASTER_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define UART_1_BLE_DISABLE_INTR_MASTER(sourceMask)                                 do{                                                      UART_1_BLE_INTR_MASTER_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N#define UART_1_BLE_DISABLE_INTR_SLAVE(sourceMask) \
N                                do{                     \
N                                    UART_1_BLE_INTR_SLAVE_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define UART_1_BLE_DISABLE_INTR_SLAVE(sourceMask)                                 do{                                                         UART_1_BLE_INTR_SLAVE_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N#define UART_1_BLE_DISABLE_INTR_TX(sourceMask)    \
N                                do{                     \
N                                    UART_1_BLE_INTR_TX_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                 }while(0)
X#define UART_1_BLE_DISABLE_INTR_TX(sourceMask)                                    do{                                                         UART_1_BLE_INTR_TX_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                  }while(0)
N
N#define UART_1_BLE_DISABLE_INTR_RX(sourceMask)    \
N                                do{                     \
N                                    UART_1_BLE_INTR_RX_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define UART_1_BLE_DISABLE_INTR_RX(sourceMask)                                    do{                                                         UART_1_BLE_INTR_RX_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N/* Set interrupt sources: write sourceMask bits in UART_1_BLE_INTR_X_SET_REG */
N#define UART_1_BLE_SET_INTR_MASTER(sourceMask)    \
N                                                do{     \
N                                                    UART_1_BLE_INTR_MASTER_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_BLE_SET_INTR_MASTER(sourceMask)                                                    do{                                                         UART_1_BLE_INTR_MASTER_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_BLE_SET_INTR_SLAVE(sourceMask) \
N                                                do{ \
N                                                    UART_1_BLE_INTR_SLAVE_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_BLE_SET_INTR_SLAVE(sourceMask)                                                 do{                                                     UART_1_BLE_INTR_SLAVE_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_BLE_SET_INTR_TX(sourceMask)    \
N                                                do{ \
N                                                    UART_1_BLE_INTR_TX_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_BLE_SET_INTR_TX(sourceMask)                                                    do{                                                     UART_1_BLE_INTR_TX_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_BLE_SET_INTR_RX(sourceMask)    \
N                                                do{ \
N                                                    UART_1_BLE_INTR_RX_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_BLE_SET_INTR_RX(sourceMask)                                                    do{                                                     UART_1_BLE_INTR_RX_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N/* Clear interrupt sources: write sourceMask bits in UART_1_BLE_INTR_X_REG */
N#define UART_1_BLE_CLEAR_INTR_I2C_EC(sourceMask)  \
N                                                do{     \
N                                                    UART_1_BLE_INTR_I2C_EC_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_BLE_CLEAR_INTR_I2C_EC(sourceMask)                                                  do{                                                         UART_1_BLE_INTR_I2C_EC_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#if (!UART_1_BLE_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_1_BLE_CLEAR_INTR_SPI_EC(sourceMask)  \
N                                                do{     \
N                                                    UART_1_BLE_INTR_SPI_EC_REG = (uint32) (sourceMask); \
N                                                }while(0)
X    #define UART_1_BLE_CLEAR_INTR_SPI_EC(sourceMask)                                                  do{                                                         UART_1_BLE_INTR_SPI_EC_REG = (uint32) (sourceMask);                                                 }while(0)
N#endif /* (!UART_1_BLE_CY_SCBIP_V1) */
N
N#define UART_1_BLE_CLEAR_INTR_MASTER(sourceMask)  \
N                                                do{     \
N                                                    UART_1_BLE_INTR_MASTER_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_BLE_CLEAR_INTR_MASTER(sourceMask)                                                  do{                                                         UART_1_BLE_INTR_MASTER_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_BLE_CLEAR_INTR_SLAVE(sourceMask)   \
N                                                do{     \
N                                                    UART_1_BLE_INTR_SLAVE_REG  = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_BLE_CLEAR_INTR_SLAVE(sourceMask)                                                   do{                                                         UART_1_BLE_INTR_SLAVE_REG  = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_BLE_CLEAR_INTR_TX(sourceMask)      \
N                                                do{     \
N                                                    UART_1_BLE_INTR_TX_REG     = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_BLE_CLEAR_INTR_TX(sourceMask)                                                      do{                                                         UART_1_BLE_INTR_TX_REG     = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_BLE_CLEAR_INTR_RX(sourceMask)      \
N                                                do{     \
N                                                    UART_1_BLE_INTR_RX_REG     = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_BLE_CLEAR_INTR_RX(sourceMask)                                                      do{                                                         UART_1_BLE_INTR_RX_REG     = (uint32) (sourceMask);                                                 }while(0)
N
N/* Return true if sourceMask is set in UART_1_BLE_INTR_CAUSE_REG */
N#define UART_1_BLE_CHECK_CAUSE_INTR(sourceMask)    (0u != (UART_1_BLE_INTR_CAUSE_REG & (sourceMask)))
N
N/* Return true if sourceMask is set in INTR_X_MASKED_REG */
N#define UART_1_BLE_CHECK_INTR_I2C_EC(sourceMask)  (0u != (UART_1_BLE_INTR_I2C_EC_REG & (sourceMask)))
N#if (!UART_1_BLE_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_1_BLE_CHECK_INTR_SPI_EC(sourceMask)  (0u != (UART_1_BLE_INTR_SPI_EC_REG & (sourceMask)))
N#endif /* (!UART_1_BLE_CY_SCBIP_V1) */
N#define UART_1_BLE_CHECK_INTR_MASTER(sourceMask)  (0u != (UART_1_BLE_INTR_MASTER_REG & (sourceMask)))
N#define UART_1_BLE_CHECK_INTR_SLAVE(sourceMask)   (0u != (UART_1_BLE_INTR_SLAVE_REG  & (sourceMask)))
N#define UART_1_BLE_CHECK_INTR_TX(sourceMask)      (0u != (UART_1_BLE_INTR_TX_REG     & (sourceMask)))
N#define UART_1_BLE_CHECK_INTR_RX(sourceMask)      (0u != (UART_1_BLE_INTR_RX_REG     & (sourceMask)))
N
N/* Return true if sourceMask is set in UART_1_BLE_INTR_X_MASKED_REG */
N#define UART_1_BLE_CHECK_INTR_I2C_EC_MASKED(sourceMask)   (0u != (UART_1_BLE_INTR_I2C_EC_MASKED_REG & \
N                                                                       (sourceMask)))
X#define UART_1_BLE_CHECK_INTR_I2C_EC_MASKED(sourceMask)   (0u != (UART_1_BLE_INTR_I2C_EC_MASKED_REG &                                                                        (sourceMask)))
N#if (!UART_1_BLE_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_1_BLE_CHECK_INTR_SPI_EC_MASKED(sourceMask)   (0u != (UART_1_BLE_INTR_SPI_EC_MASKED_REG & \
N                                                                       (sourceMask)))
X    #define UART_1_BLE_CHECK_INTR_SPI_EC_MASKED(sourceMask)   (0u != (UART_1_BLE_INTR_SPI_EC_MASKED_REG &                                                                        (sourceMask)))
N#endif /* (!UART_1_BLE_CY_SCBIP_V1) */
N#define UART_1_BLE_CHECK_INTR_MASTER_MASKED(sourceMask)   (0u != (UART_1_BLE_INTR_MASTER_MASKED_REG & \
N                                                                       (sourceMask)))
X#define UART_1_BLE_CHECK_INTR_MASTER_MASKED(sourceMask)   (0u != (UART_1_BLE_INTR_MASTER_MASKED_REG &                                                                        (sourceMask)))
N#define UART_1_BLE_CHECK_INTR_SLAVE_MASKED(sourceMask)    (0u != (UART_1_BLE_INTR_SLAVE_MASKED_REG  & \
N                                                                       (sourceMask)))
X#define UART_1_BLE_CHECK_INTR_SLAVE_MASKED(sourceMask)    (0u != (UART_1_BLE_INTR_SLAVE_MASKED_REG  &                                                                        (sourceMask)))
N#define UART_1_BLE_CHECK_INTR_TX_MASKED(sourceMask)       (0u != (UART_1_BLE_INTR_TX_MASKED_REG     & \
N                                                                       (sourceMask)))
X#define UART_1_BLE_CHECK_INTR_TX_MASKED(sourceMask)       (0u != (UART_1_BLE_INTR_TX_MASKED_REG     &                                                                        (sourceMask)))
N#define UART_1_BLE_CHECK_INTR_RX_MASKED(sourceMask)       (0u != (UART_1_BLE_INTR_RX_MASKED_REG     & \
N                                                                       (sourceMask)))
X#define UART_1_BLE_CHECK_INTR_RX_MASKED(sourceMask)       (0u != (UART_1_BLE_INTR_RX_MASKED_REG     &                                                                        (sourceMask)))
N
N/* Return true if sourceMask is set in UART_1_BLE_CTRL_REG: generally is used to check enable bit */
N#define UART_1_BLE_GET_CTRL_ENABLED    (0u != (UART_1_BLE_CTRL_REG & UART_1_BLE_CTRL_ENABLED))
N
N#define UART_1_BLE_CHECK_SLAVE_AUTO_ADDR_NACK     (0u != (UART_1_BLE_I2C_CTRL_REG & \
N                                                                UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK))
X#define UART_1_BLE_CHECK_SLAVE_AUTO_ADDR_NACK     (0u != (UART_1_BLE_I2C_CTRL_REG &                                                                 UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK))
N
N
N/***************************************
N*      I2C Macro Definitions
N***************************************/
N
N/* Enable auto ACK/NACK */
N#define UART_1_BLE_ENABLE_SLAVE_AUTO_ADDR_NACK \
N                            do{                      \
N                                UART_1_BLE_I2C_CTRL_REG |= UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_1_BLE_ENABLE_SLAVE_AUTO_ADDR_NACK                             do{                                                      UART_1_BLE_I2C_CTRL_REG |= UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define UART_1_BLE_ENABLE_SLAVE_AUTO_DATA_ACK \
N                            do{                     \
N                                UART_1_BLE_I2C_CTRL_REG |= UART_1_BLE_I2C_CTRL_S_READY_DATA_ACK; \
N                            }while(0)
X#define UART_1_BLE_ENABLE_SLAVE_AUTO_DATA_ACK                             do{                                                     UART_1_BLE_I2C_CTRL_REG |= UART_1_BLE_I2C_CTRL_S_READY_DATA_ACK;                             }while(0)
N
N#define UART_1_BLE_ENABLE_SLAVE_AUTO_DATA_NACK \
N                            do{                      \
N                                UART_1_BLE_I2C_CTRL_REG |= UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_1_BLE_ENABLE_SLAVE_AUTO_DATA_NACK                             do{                                                      UART_1_BLE_I2C_CTRL_REG |= UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define UART_1_BLE_ENABLE_MASTER_AUTO_DATA_ACK \
N                            do{                      \
N                                UART_1_BLE_I2C_CTRL_REG |= UART_1_BLE_I2C_CTRL_M_READY_DATA_ACK; \
N                            }while(0)
X#define UART_1_BLE_ENABLE_MASTER_AUTO_DATA_ACK                             do{                                                      UART_1_BLE_I2C_CTRL_REG |= UART_1_BLE_I2C_CTRL_M_READY_DATA_ACK;                             }while(0)
N
N#define UART_1_BLE_ENABLE_MASTER_AUTO_DATA_NACK \
N                            do{                       \
N                                UART_1_BLE_I2C_CTRL_REG |= UART_1_BLE_I2C_CTRL_M_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_1_BLE_ENABLE_MASTER_AUTO_DATA_NACK                             do{                                                       UART_1_BLE_I2C_CTRL_REG |= UART_1_BLE_I2C_CTRL_M_NOT_READY_DATA_NACK;                             }while(0)
N
N/* Disable auto ACK/NACK */
N#define UART_1_BLE_DISABLE_SLAVE_AUTO_ADDR_NACK \
N                            do{                       \
N                                UART_1_BLE_I2C_CTRL_REG &= ~UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_1_BLE_DISABLE_SLAVE_AUTO_ADDR_NACK                             do{                                                       UART_1_BLE_I2C_CTRL_REG &= ~UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define UART_1_BLE_DISABLE_SLAVE_AUTO_DATA_ACK \
N                            do{                      \
N                                UART_1_BLE_I2C_CTRL_REG &= ~UART_1_BLE_I2C_CTRL_S_READY_DATA_ACK; \
N                            }while(0)
X#define UART_1_BLE_DISABLE_SLAVE_AUTO_DATA_ACK                             do{                                                      UART_1_BLE_I2C_CTRL_REG &= ~UART_1_BLE_I2C_CTRL_S_READY_DATA_ACK;                             }while(0)
N
N#define UART_1_BLE_DISABLE_SLAVE_AUTO_DATA_NACK \
N                            do{                       \
N                                UART_1_BLE_I2C_CTRL_REG &= ~UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_1_BLE_DISABLE_SLAVE_AUTO_DATA_NACK                             do{                                                       UART_1_BLE_I2C_CTRL_REG &= ~UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define UART_1_BLE_DISABLE_MASTER_AUTO_DATA_ACK \
N                            do{                       \
N                                UART_1_BLE_I2C_CTRL_REG &= ~UART_1_BLE_I2C_CTRL_M_READY_DATA_ACK; \
N                            }while(0)
X#define UART_1_BLE_DISABLE_MASTER_AUTO_DATA_ACK                             do{                                                       UART_1_BLE_I2C_CTRL_REG &= ~UART_1_BLE_I2C_CTRL_M_READY_DATA_ACK;                             }while(0)
N
N#define UART_1_BLE_DISABLE_MASTER_AUTO_DATA_NACK \
N                            do{                        \
N                                UART_1_BLE_I2C_CTRL_REG &= ~UART_1_BLE_I2C_CTRL_M_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_1_BLE_DISABLE_MASTER_AUTO_DATA_NACK                             do{                                                        UART_1_BLE_I2C_CTRL_REG &= ~UART_1_BLE_I2C_CTRL_M_NOT_READY_DATA_NACK;                             }while(0)
N
N/* Enable Slave autoACK/NACK Data */
N#define UART_1_BLE_ENABLE_SLAVE_AUTO_DATA \
N                            do{                 \
N                                UART_1_BLE_I2C_CTRL_REG |= (UART_1_BLE_I2C_CTRL_S_READY_DATA_ACK |      \
N                                                                  UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK); \
N                            }while(0)
X#define UART_1_BLE_ENABLE_SLAVE_AUTO_DATA                             do{                                                 UART_1_BLE_I2C_CTRL_REG |= (UART_1_BLE_I2C_CTRL_S_READY_DATA_ACK |                                                                        UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK);                             }while(0)
N
N/* Disable Slave autoACK/NACK Data */
N#define UART_1_BLE_DISABLE_SLAVE_AUTO_DATA \
N                            do{                  \
N                                UART_1_BLE_I2C_CTRL_REG &= ((uint32) \
N                                                                  ~(UART_1_BLE_I2C_CTRL_S_READY_DATA_ACK |       \
N                                                                    UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK)); \
N                            }while(0)
X#define UART_1_BLE_DISABLE_SLAVE_AUTO_DATA                             do{                                                  UART_1_BLE_I2C_CTRL_REG &= ((uint32)                                                                   ~(UART_1_BLE_I2C_CTRL_S_READY_DATA_ACK |                                                                           UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK));                             }while(0)
N
N/* Disable Master autoACK/NACK Data */
N#define UART_1_BLE_DISABLE_MASTER_AUTO_DATA \
N                            do{                   \
N                                UART_1_BLE_I2C_CTRL_REG &= ((uint32) \
N                                                                  ~(UART_1_BLE_I2C_CTRL_M_READY_DATA_ACK |       \
N                                                                    UART_1_BLE_I2C_CTRL_M_NOT_READY_DATA_NACK)); \
N                            }while(0)
X#define UART_1_BLE_DISABLE_MASTER_AUTO_DATA                             do{                                                   UART_1_BLE_I2C_CTRL_REG &= ((uint32)                                                                   ~(UART_1_BLE_I2C_CTRL_M_READY_DATA_ACK |                                                                           UART_1_BLE_I2C_CTRL_M_NOT_READY_DATA_NACK));                             }while(0)
N/* Disables auto data ACK/NACK bits */
N#define UART_1_BLE_DISABLE_AUTO_DATA \
N                do{                        \
N                    UART_1_BLE_I2C_CTRL_REG &= ((uint32) ~(UART_1_BLE_I2C_CTRL_M_READY_DATA_ACK      |  \
N                                                                 UART_1_BLE_I2C_CTRL_M_NOT_READY_DATA_NACK |  \
N                                                                 UART_1_BLE_I2C_CTRL_S_READY_DATA_ACK      |  \
N                                                                 UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK)); \
N                }while(0)
X#define UART_1_BLE_DISABLE_AUTO_DATA                 do{                                            UART_1_BLE_I2C_CTRL_REG &= ((uint32) ~(UART_1_BLE_I2C_CTRL_M_READY_DATA_ACK      |                                                                   UART_1_BLE_I2C_CTRL_M_NOT_READY_DATA_NACK |                                                                   UART_1_BLE_I2C_CTRL_S_READY_DATA_ACK      |                                                                   UART_1_BLE_I2C_CTRL_S_NOT_READY_DATA_NACK));                 }while(0)
N
N/* Master commands */
N#define UART_1_BLE_I2C_MASTER_GENERATE_START \
N                            do{                    \
N                                UART_1_BLE_I2C_MASTER_CMD_REG = UART_1_BLE_I2C_MASTER_CMD_M_START_ON_IDLE; \
N                            }while(0)
X#define UART_1_BLE_I2C_MASTER_GENERATE_START                             do{                                                    UART_1_BLE_I2C_MASTER_CMD_REG = UART_1_BLE_I2C_MASTER_CMD_M_START_ON_IDLE;                             }while(0)
N
N#define UART_1_BLE_I2C_MASTER_CLEAR_START \
N                            do{                 \
N                                UART_1_BLE_I2C_MASTER_CMD_REG =  ((uint32) 0u); \
N                            }while(0)
X#define UART_1_BLE_I2C_MASTER_CLEAR_START                             do{                                                 UART_1_BLE_I2C_MASTER_CMD_REG =  ((uint32) 0u);                             }while(0)
N
N#define UART_1_BLE_I2C_MASTER_GENERATE_RESTART UART_1_BLE_I2CReStartGeneration()
N
N#define UART_1_BLE_I2C_MASTER_GENERATE_STOP \
N                            do{                   \
N                                UART_1_BLE_I2C_MASTER_CMD_REG =                                            \
N                                    (UART_1_BLE_I2C_MASTER_CMD_M_STOP |                                    \
N                                        (UART_1_BLE_CHECK_I2C_STATUS(UART_1_BLE_I2C_STATUS_M_READ) ? \
N                                            (UART_1_BLE_I2C_MASTER_CMD_M_NACK) : (0u)));                   \
N                            }while(0)
X#define UART_1_BLE_I2C_MASTER_GENERATE_STOP                             do{                                                   UART_1_BLE_I2C_MASTER_CMD_REG =                                                                                (UART_1_BLE_I2C_MASTER_CMD_M_STOP |                                                                            (UART_1_BLE_CHECK_I2C_STATUS(UART_1_BLE_I2C_STATUS_M_READ) ?                                             (UART_1_BLE_I2C_MASTER_CMD_M_NACK) : (0u)));                                               }while(0)
N
N#define UART_1_BLE_I2C_MASTER_GENERATE_ACK \
N                            do{                  \
N                                UART_1_BLE_I2C_MASTER_CMD_REG = UART_1_BLE_I2C_MASTER_CMD_M_ACK; \
N                            }while(0)
X#define UART_1_BLE_I2C_MASTER_GENERATE_ACK                             do{                                                  UART_1_BLE_I2C_MASTER_CMD_REG = UART_1_BLE_I2C_MASTER_CMD_M_ACK;                             }while(0)
N
N#define UART_1_BLE_I2C_MASTER_GENERATE_NACK \
N                            do{                   \
N                                UART_1_BLE_I2C_MASTER_CMD_REG = UART_1_BLE_I2C_MASTER_CMD_M_NACK; \
N                            }while(0)
X#define UART_1_BLE_I2C_MASTER_GENERATE_NACK                             do{                                                   UART_1_BLE_I2C_MASTER_CMD_REG = UART_1_BLE_I2C_MASTER_CMD_M_NACK;                             }while(0)
N
N/* Slave commands */
N#define UART_1_BLE_I2C_SLAVE_GENERATE_ACK \
N                            do{                 \
N                                UART_1_BLE_I2C_SLAVE_CMD_REG = UART_1_BLE_I2C_SLAVE_CMD_S_ACK; \
N                            }while(0)
X#define UART_1_BLE_I2C_SLAVE_GENERATE_ACK                             do{                                                 UART_1_BLE_I2C_SLAVE_CMD_REG = UART_1_BLE_I2C_SLAVE_CMD_S_ACK;                             }while(0)
N
N#if (UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1)
X#if ((2 == 0u) || (2 == 1u))
S    /* Slave NACK generation for EC_AM logic on address phase. Ticket ID #183902 */
S    void UART_1_BLE_I2CSlaveNackGeneration(void);
S    #define UART_1_BLE_I2C_SLAVE_GENERATE_NACK UART_1_BLE_I2CSlaveNackGeneration()
S
N#else
N    #define UART_1_BLE_I2C_SLAVE_GENERATE_NACK \
N                            do{                      \
N                                UART_1_BLE_I2C_SLAVE_CMD_REG = UART_1_BLE_I2C_SLAVE_CMD_S_NACK; \
N                            }while(0)
X    #define UART_1_BLE_I2C_SLAVE_GENERATE_NACK                             do{                                                      UART_1_BLE_I2C_SLAVE_CMD_REG = UART_1_BLE_I2C_SLAVE_CMD_S_NACK;                             }while(0)
N#endif /* (UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1) */
N
N#define UART_1_BLE_I2C_SLAVE_CLEAR_NACK \
N                            do{               \
N                                UART_1_BLE_I2C_SLAVE_CMD_REG = 0u; \
N                            }while(0)
X#define UART_1_BLE_I2C_SLAVE_CLEAR_NACK                             do{                                               UART_1_BLE_I2C_SLAVE_CMD_REG = 0u;                             }while(0)
N
N/* Return 8-bit address. The input address should be 7-bits */
N#define UART_1_BLE_GET_I2C_8BIT_ADDRESS(addr) (((uint32) ((uint32) (addr) << \
N                                                                    UART_1_BLE_I2C_SLAVE_ADDR_POS)) & \
N                                                                        UART_1_BLE_I2C_SLAVE_ADDR_MASK)
X#define UART_1_BLE_GET_I2C_8BIT_ADDRESS(addr) (((uint32) ((uint32) (addr) <<                                                                     UART_1_BLE_I2C_SLAVE_ADDR_POS)) &                                                                         UART_1_BLE_I2C_SLAVE_ADDR_MASK)
N
N#define UART_1_BLE_GET_I2C_7BIT_ADDRESS(addr) ((uint32) (addr) >> UART_1_BLE_I2C_SLAVE_ADDR_POS)
N
N/* Adjust SDA filter Trim settings */
N#define UART_1_BLE_DEFAULT_I2C_CFG_SDA_FILT_TRIM  (0x02u)
N#define UART_1_BLE_EC_AM_I2C_CFG_SDA_FILT_TRIM    (0x03u)
N
N#if (UART_1_BLE_CY_SCBIP_V0)
X#if ((2 == 0u))
S    #define UART_1_BLE_SET_I2C_CFG_SDA_FILT_TRIM(sdaTrim) \
S        do{                                                 \
S            UART_1_BLE_I2C_CFG_REG =                  \
S                            ((UART_1_BLE_I2C_CFG_REG & (uint32) ~UART_1_BLE_I2C_CFG_SDA_FILT_TRIM_MASK) | \
S                             ((uint32) ((uint32) (sdaTrim) <<UART_1_BLE_I2C_CFG_SDA_FILT_TRIM_POS)));           \
S        }while(0)
X    #define UART_1_BLE_SET_I2C_CFG_SDA_FILT_TRIM(sdaTrim)         do{                                                             UART_1_BLE_I2C_CFG_REG =                                              ((UART_1_BLE_I2C_CFG_REG & (uint32) ~UART_1_BLE_I2C_CFG_SDA_FILT_TRIM_MASK) |                              ((uint32) ((uint32) (sdaTrim) <<UART_1_BLE_I2C_CFG_SDA_FILT_TRIM_POS)));                   }while(0)
N#endif /* (UART_1_BLE_CY_SCBIP_V0) */
N
N/* Enable/Disable analog and digital filter */
N#define UART_1_BLE_DIGITAL_FILTER_DISABLE    (0u)
N#define UART_1_BLE_DIGITAL_FILTER_ENABLE     (1u)
N#define UART_1_BLE_I2C_DATA_RATE_FS_MODE_MAX (400u)
N#if (UART_1_BLE_CY_SCBIP_V0)
X#if ((2 == 0u))
S    /* UART_1_BLE_I2C_CFG_SDA_FILT_OUT_ENABLED is disabled by default */
S    #define UART_1_BLE_I2C_CFG_FILT_MASK  (UART_1_BLE_I2C_CFG_SDA_FILT_ENABLED | \
S                                                 UART_1_BLE_I2C_CFG_SCL_FILT_ENABLED)
X    #define UART_1_BLE_I2C_CFG_FILT_MASK  (UART_1_BLE_I2C_CFG_SDA_FILT_ENABLED |                                                  UART_1_BLE_I2C_CFG_SCL_FILT_ENABLED)
N#else
N    /* UART_1_BLE_I2C_CFG_SDA_OUT_FILT_SEL_MASK is disabled by default */
N    #define UART_1_BLE_I2C_CFG_FILT_MASK  (UART_1_BLE_I2C_CFG_SDA_IN_FILT_SEL | \
N                                                 UART_1_BLE_I2C_CFG_SCL_IN_FILT_SEL)
X    #define UART_1_BLE_I2C_CFG_FILT_MASK  (UART_1_BLE_I2C_CFG_SDA_IN_FILT_SEL |                                                  UART_1_BLE_I2C_CFG_SCL_IN_FILT_SEL)
N#endif /* (UART_1_BLE_CY_SCBIP_V0) */
N
N#define UART_1_BLE_I2C_CFG_ANALOG_FITER_DISABLE \
N        do{                                           \
N            UART_1_BLE_I2C_CFG_REG &= (uint32) ~UART_1_BLE_I2C_CFG_FILT_MASK; \
N        }while(0)
X#define UART_1_BLE_I2C_CFG_ANALOG_FITER_DISABLE         do{                                                       UART_1_BLE_I2C_CFG_REG &= (uint32) ~UART_1_BLE_I2C_CFG_FILT_MASK;         }while(0)
N
N#define UART_1_BLE_I2C_CFG_ANALOG_FITER_ENABLE \
N        do{                                          \
N            UART_1_BLE_I2C_CFG_REG |= (uint32)  UART_1_BLE_I2C_CFG_FILT_MASK; \
N        }while(0)
X#define UART_1_BLE_I2C_CFG_ANALOG_FITER_ENABLE         do{                                                      UART_1_BLE_I2C_CFG_REG |= (uint32)  UART_1_BLE_I2C_CFG_FILT_MASK;         }while(0)
N
N/* Return slave select number from SPI_CTRL register */
N#define UART_1_BLE_GET_SPI_CTRL_SS(activeSelect) (((uint32) ((uint32) (activeSelect) << \
N                                                                    UART_1_BLE_SPI_CTRL_SLAVE_SELECT_POS)) & \
N                                                                        UART_1_BLE_SPI_CTRL_SLAVE_SELECT_MASK)
X#define UART_1_BLE_GET_SPI_CTRL_SS(activeSelect) (((uint32) ((uint32) (activeSelect) <<                                                                     UART_1_BLE_SPI_CTRL_SLAVE_SELECT_POS)) &                                                                         UART_1_BLE_SPI_CTRL_SLAVE_SELECT_MASK)
N
N/* Return true if bit is set in UART_1_BLE_I2C_STATUS_REG */
N#define UART_1_BLE_CHECK_I2C_STATUS(sourceMask)   (0u != (UART_1_BLE_I2C_STATUS_REG & (sourceMask)))
N
N/* Return true if bit is set in UART_1_BLE_SPI_STATUS_REG */
N#define UART_1_BLE_CHECK_SPI_STATUS(sourceMask)   (0u != (UART_1_BLE_SPI_STATUS_REG & (sourceMask)))
N
N/* Return FIFO size depends on UART_1_BLE_CTRL_BYTE_MODE bit */
N#define UART_1_BLE_GET_FIFO_SIZE(condition) ((0u != (condition)) ? \
N                                                    (2u * UART_1_BLE_FIFO_SIZE) : (UART_1_BLE_FIFO_SIZE))
X#define UART_1_BLE_GET_FIFO_SIZE(condition) ((0u != (condition)) ?                                                     (2u * UART_1_BLE_FIFO_SIZE) : (UART_1_BLE_FIFO_SIZE))
N
N
N/***************************************
N*       Get Macros Definitions
N***************************************/
N
N/* UART_1_BLE_CTRL */
N#define UART_1_BLE_GET_CTRL_OVS(oversample)       (((uint32) (oversample) - 1u) & UART_1_BLE_CTRL_OVS_MASK)
N
N#define UART_1_BLE_GET_CTRL_EC_OP_MODE(opMode)        ((0u != (opMode)) ? \
N                                                                (UART_1_BLE_CTRL_EC_OP_MODE)  : (0u))
X#define UART_1_BLE_GET_CTRL_EC_OP_MODE(opMode)        ((0u != (opMode)) ?                                                                 (UART_1_BLE_CTRL_EC_OP_MODE)  : (0u))
N
N#define UART_1_BLE_GET_CTRL_EC_AM_MODE(amMode)        ((0u != (amMode)) ? \
N                                                                (UART_1_BLE_CTRL_EC_AM_MODE)  : (0u))
X#define UART_1_BLE_GET_CTRL_EC_AM_MODE(amMode)        ((0u != (amMode)) ?                                                                 (UART_1_BLE_CTRL_EC_AM_MODE)  : (0u))
N
N#define UART_1_BLE_GET_CTRL_BLOCK(block)              ((0u != (block))  ? \
N                                                                (UART_1_BLE_CTRL_BLOCK)       : (0u))
X#define UART_1_BLE_GET_CTRL_BLOCK(block)              ((0u != (block))  ?                                                                 (UART_1_BLE_CTRL_BLOCK)       : (0u))
N
N#define UART_1_BLE_GET_CTRL_ADDR_ACCEPT(acceptAddr)   ((0u != (acceptAddr)) ? \
N                                                                (UART_1_BLE_CTRL_ADDR_ACCEPT) : (0u))
X#define UART_1_BLE_GET_CTRL_ADDR_ACCEPT(acceptAddr)   ((0u != (acceptAddr)) ?                                                                 (UART_1_BLE_CTRL_ADDR_ACCEPT) : (0u))
N
N#if (UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1)
X#if ((2 == 0u) || (2 == 1u))
S    #define UART_1_BLE_GET_CTRL_BYTE_MODE(mode)   (0u)
N#else
N    #define UART_1_BLE_GET_CTRL_BYTE_MODE(mode)   ((0u != (mode)) ? \
N                                                            (UART_1_BLE_CTRL_BYTE_MODE) : (0u))
X    #define UART_1_BLE_GET_CTRL_BYTE_MODE(mode)   ((0u != (mode)) ?                                                             (UART_1_BLE_CTRL_BYTE_MODE) : (0u))
N#endif /* (UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1) */
N
N/* UART_1_BLE_I2C_CTRL */
N#define UART_1_BLE_GET_I2C_CTRL_HIGH_PHASE_OVS(oversampleHigh) (((uint32) (oversampleHigh) - 1u) & \
N                                                                        UART_1_BLE_I2C_CTRL_HIGH_PHASE_OVS_MASK)
X#define UART_1_BLE_GET_I2C_CTRL_HIGH_PHASE_OVS(oversampleHigh) (((uint32) (oversampleHigh) - 1u) &                                                                         UART_1_BLE_I2C_CTRL_HIGH_PHASE_OVS_MASK)
N
N#define UART_1_BLE_GET_I2C_CTRL_LOW_PHASE_OVS(oversampleLow)  ((((uint32) (oversampleLow) - 1u) << \
N                                                                    UART_1_BLE_I2C_CTRL_LOW_PHASE_OVS_POS) &  \
N                                                                    UART_1_BLE_I2C_CTRL_LOW_PHASE_OVS_MASK)
X#define UART_1_BLE_GET_I2C_CTRL_LOW_PHASE_OVS(oversampleLow)  ((((uint32) (oversampleLow) - 1u) <<                                                                     UART_1_BLE_I2C_CTRL_LOW_PHASE_OVS_POS) &                                                                      UART_1_BLE_I2C_CTRL_LOW_PHASE_OVS_MASK)
N
N#define UART_1_BLE_GET_I2C_CTRL_S_NOT_READY_ADDR_NACK(wakeNack) ((0u != (wakeNack)) ? \
N                                                            (UART_1_BLE_I2C_CTRL_S_NOT_READY_ADDR_NACK) : (0u))
X#define UART_1_BLE_GET_I2C_CTRL_S_NOT_READY_ADDR_NACK(wakeNack) ((0u != (wakeNack)) ?                                                             (UART_1_BLE_I2C_CTRL_S_NOT_READY_ADDR_NACK) : (0u))
N
N#define UART_1_BLE_GET_I2C_CTRL_S_GENERAL_IGNORE(genCall) ((0u != (genCall)) ? \
N                                                                    (UART_1_BLE_I2C_CTRL_S_GENERAL_IGNORE) : (0u))
X#define UART_1_BLE_GET_I2C_CTRL_S_GENERAL_IGNORE(genCall) ((0u != (genCall)) ?                                                                     (UART_1_BLE_I2C_CTRL_S_GENERAL_IGNORE) : (0u))
N
N#define UART_1_BLE_GET_I2C_CTRL_SL_MSTR_MODE(mode)    ((uint32)(mode) << UART_1_BLE_I2C_CTRL_SLAVE_MODE_POS)
N
N/* UART_1_BLE_SPI_CTRL */
N#define UART_1_BLE_GET_SPI_CTRL_CONTINUOUS(separate)  ((0u != (separate)) ? \
N                                                                (UART_1_BLE_SPI_CTRL_CONTINUOUS) : (0u))
X#define UART_1_BLE_GET_SPI_CTRL_CONTINUOUS(separate)  ((0u != (separate)) ?                                                                 (UART_1_BLE_SPI_CTRL_CONTINUOUS) : (0u))
N
N#define UART_1_BLE_GET_SPI_CTRL_SELECT_PRECEDE(mode)  ((0u != (mode)) ? \
N                                                                      (UART_1_BLE_SPI_CTRL_SELECT_PRECEDE) : (0u))
X#define UART_1_BLE_GET_SPI_CTRL_SELECT_PRECEDE(mode)  ((0u != (mode)) ?                                                                       (UART_1_BLE_SPI_CTRL_SELECT_PRECEDE) : (0u))
N
N#define UART_1_BLE_GET_SPI_CTRL_SCLK_MODE(mode)       (((uint32) (mode) << \
N                                                                        UART_1_BLE_SPI_CTRL_CPHA_POS) & \
N                                                                        UART_1_BLE_SPI_CTRL_SCLK_MODE_MASK)
X#define UART_1_BLE_GET_SPI_CTRL_SCLK_MODE(mode)       (((uint32) (mode) <<                                                                         UART_1_BLE_SPI_CTRL_CPHA_POS) &                                                                         UART_1_BLE_SPI_CTRL_SCLK_MODE_MASK)
N
N#define UART_1_BLE_GET_SPI_CTRL_LATE_MISO_SAMPLE(lateMiso) ((0u != (lateMiso)) ? \
N                                                                    (UART_1_BLE_SPI_CTRL_LATE_MISO_SAMPLE) : (0u))
X#define UART_1_BLE_GET_SPI_CTRL_LATE_MISO_SAMPLE(lateMiso) ((0u != (lateMiso)) ?                                                                     (UART_1_BLE_SPI_CTRL_LATE_MISO_SAMPLE) : (0u))
N
N#if (UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1)
X#if ((2 == 0u) || (2 == 1u))
S    #define UART_1_BLE_GET_SPI_CTRL_SCLK_CONTINUOUS(sclkType) (0u)
S    #define UART_1_BLE_GET_SPI_CTRL_SSEL_POLARITY(polarity)   (0u)
N#else
N    #define UART_1_BLE_GET_SPI_CTRL_SCLK_CONTINUOUS(sclkType) ((0u != (sclkType)) ? \
N                                                                    (UART_1_BLE_SPI_CTRL_SCLK_CONTINUOUS) : (0u))
X    #define UART_1_BLE_GET_SPI_CTRL_SCLK_CONTINUOUS(sclkType) ((0u != (sclkType)) ?                                                                     (UART_1_BLE_SPI_CTRL_SCLK_CONTINUOUS) : (0u))
N
N    #define UART_1_BLE_GET_SPI_CTRL_SSEL_POLARITY(polarity)   (((uint32) (polarity) << \
N                                                                     UART_1_BLE_SPI_CTRL_SSEL0_POLARITY_POS) & \
N                                                                     UART_1_BLE_SPI_CTRL_SSEL_POLARITY_MASK)
X    #define UART_1_BLE_GET_SPI_CTRL_SSEL_POLARITY(polarity)   (((uint32) (polarity) <<                                                                      UART_1_BLE_SPI_CTRL_SSEL0_POLARITY_POS) &                                                                      UART_1_BLE_SPI_CTRL_SSEL_POLARITY_MASK)
N#endif /* ((UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1) */
N
N#define UART_1_BLE_GET_SPI_CTRL_SUB_MODE(mode)        (((uint32) (mode) << UART_1_BLE_SPI_CTRL_MODE_POS) & \
N                                                                                 UART_1_BLE_SPI_CTRL_MODE_MASK)
X#define UART_1_BLE_GET_SPI_CTRL_SUB_MODE(mode)        (((uint32) (mode) << UART_1_BLE_SPI_CTRL_MODE_POS) &                                                                                  UART_1_BLE_SPI_CTRL_MODE_MASK)
N
N#define UART_1_BLE_GET_SPI_CTRL_SLAVE_SELECT(select)  (((uint32) (select) << \
N                                                                      UART_1_BLE_SPI_CTRL_SLAVE_SELECT_POS) & \
N                                                                      UART_1_BLE_SPI_CTRL_SLAVE_SELECT_MASK)
X#define UART_1_BLE_GET_SPI_CTRL_SLAVE_SELECT(select)  (((uint32) (select) <<                                                                       UART_1_BLE_SPI_CTRL_SLAVE_SELECT_POS) &                                                                       UART_1_BLE_SPI_CTRL_SLAVE_SELECT_MASK)
N
N#define UART_1_BLE_GET_SPI_CTRL_MASTER_MODE(mode)     ((0u != (mode)) ? \
N                                                                (UART_1_BLE_SPI_CTRL_MASTER) : (0u))
X#define UART_1_BLE_GET_SPI_CTRL_MASTER_MODE(mode)     ((0u != (mode)) ?                                                                 (UART_1_BLE_SPI_CTRL_MASTER) : (0u))
N
N/* UART_1_BLE_UART_CTRL */
N#define UART_1_BLE_GET_UART_CTRL_MODE(mode)           (((uint32) (mode) << \
N                                                                            UART_1_BLE_UART_CTRL_MODE_POS) & \
N                                                                            UART_1_BLE_UART_CTRL_MODE_MASK)
X#define UART_1_BLE_GET_UART_CTRL_MODE(mode)           (((uint32) (mode) <<                                                                             UART_1_BLE_UART_CTRL_MODE_POS) &                                                                             UART_1_BLE_UART_CTRL_MODE_MASK)
N
N/* UART_1_BLE_UART_RX_CTRL */
N#define UART_1_BLE_GET_UART_RX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) & \
N                                                                        UART_1_BLE_UART_RX_CTRL_STOP_BITS_MASK)
X#define UART_1_BLE_GET_UART_RX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) &                                                                         UART_1_BLE_UART_RX_CTRL_STOP_BITS_MASK)
N
N#define UART_1_BLE_GET_UART_RX_CTRL_PARITY(parity)    ((0u != (parity)) ? \
N                                                                    (UART_1_BLE_UART_RX_CTRL_PARITY) : (0u))
X#define UART_1_BLE_GET_UART_RX_CTRL_PARITY(parity)    ((0u != (parity)) ?                                                                     (UART_1_BLE_UART_RX_CTRL_PARITY) : (0u))
N
N#define UART_1_BLE_GET_UART_RX_CTRL_POLARITY(polarity)    ((0u != (polarity)) ? \
N                                                                    (UART_1_BLE_UART_RX_CTRL_POLARITY) : (0u))
X#define UART_1_BLE_GET_UART_RX_CTRL_POLARITY(polarity)    ((0u != (polarity)) ?                                                                     (UART_1_BLE_UART_RX_CTRL_POLARITY) : (0u))
N
N#define UART_1_BLE_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(dropErr) ((0u != (dropErr)) ? \
N                                                        (UART_1_BLE_UART_RX_CTRL_DROP_ON_PARITY_ERR) : (0u))
X#define UART_1_BLE_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(dropErr) ((0u != (dropErr)) ?                                                         (UART_1_BLE_UART_RX_CTRL_DROP_ON_PARITY_ERR) : (0u))
N
N#define UART_1_BLE_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(dropErr) ((0u != (dropErr)) ? \
N                                                        (UART_1_BLE_UART_RX_CTRL_DROP_ON_FRAME_ERR) : (0u))
X#define UART_1_BLE_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(dropErr) ((0u != (dropErr)) ?                                                         (UART_1_BLE_UART_RX_CTRL_DROP_ON_FRAME_ERR) : (0u))
N
N#define UART_1_BLE_GET_UART_RX_CTRL_MP_MODE(mpMode)   ((0u != (mpMode)) ? \
N                                                        (UART_1_BLE_UART_RX_CTRL_MP_MODE) : (0u))
X#define UART_1_BLE_GET_UART_RX_CTRL_MP_MODE(mpMode)   ((0u != (mpMode)) ?                                                         (UART_1_BLE_UART_RX_CTRL_MP_MODE) : (0u))
N
N#define UART_1_BLE_GET_UART_RX_CTRL_BREAK_WIDTH(width)    (((uint32) ((uint32) (width) - 1u) << \
N                                                                    UART_1_BLE_UART_RX_CTRL_BREAK_WIDTH_POS) & \
N                                                                    UART_1_BLE_UART_RX_CTRL_BREAK_WIDTH_MASK)
X#define UART_1_BLE_GET_UART_RX_CTRL_BREAK_WIDTH(width)    (((uint32) ((uint32) (width) - 1u) <<                                                                     UART_1_BLE_UART_RX_CTRL_BREAK_WIDTH_POS) &                                                                     UART_1_BLE_UART_RX_CTRL_BREAK_WIDTH_MASK)
N
N/* UART_1_BLE_UART_TX_CTRL */
N#define UART_1_BLE_GET_UART_TX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) & \
N                                                                UART_1_BLE_UART_RX_CTRL_STOP_BITS_MASK)
X#define UART_1_BLE_GET_UART_TX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) &                                                                 UART_1_BLE_UART_RX_CTRL_STOP_BITS_MASK)
N
N#define UART_1_BLE_GET_UART_TX_CTRL_PARITY(parity)    ((0u != (parity)) ? \
N                                                               (UART_1_BLE_UART_TX_CTRL_PARITY) : (0u))
X#define UART_1_BLE_GET_UART_TX_CTRL_PARITY(parity)    ((0u != (parity)) ?                                                                (UART_1_BLE_UART_TX_CTRL_PARITY) : (0u))
N
N#define UART_1_BLE_GET_UART_TX_CTRL_RETRY_NACK(nack)  ((0u != (nack)) ? \
N                                                               (UART_1_BLE_UART_TX_CTRL_RETRY_ON_NACK) : (0u))
X#define UART_1_BLE_GET_UART_TX_CTRL_RETRY_NACK(nack)  ((0u != (nack)) ?                                                                (UART_1_BLE_UART_TX_CTRL_RETRY_ON_NACK) : (0u))
N
N/* UART_1_BLE_UART_FLOW_CTRL */
N#if !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define UART_1_BLE_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(level)   ( (uint32) (level) & \
N                                                                 UART_1_BLE_UART_FLOW_CTRL_TRIGGER_LEVEL_MASK)
X    #define UART_1_BLE_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(level)   ( (uint32) (level) &                                                                  UART_1_BLE_UART_FLOW_CTRL_TRIGGER_LEVEL_MASK)
N
N    #define UART_1_BLE_GET_UART_FLOW_CTRL_RTS_POLARITY(polarity) ((0u != (polarity)) ? \
N                                                                (UART_1_BLE_UART_FLOW_CTRL_RTS_POLARITY) : (0u))
X    #define UART_1_BLE_GET_UART_FLOW_CTRL_RTS_POLARITY(polarity) ((0u != (polarity)) ?                                                                 (UART_1_BLE_UART_FLOW_CTRL_RTS_POLARITY) : (0u))
N
N    #define UART_1_BLE_GET_UART_FLOW_CTRL_CTS_POLARITY(polarity) ((0u != (polarity)) ? \
N                                                                (UART_1_BLE_UART_FLOW_CTRL_CTS_POLARITY) : (0u))
X    #define UART_1_BLE_GET_UART_FLOW_CTRL_CTS_POLARITY(polarity) ((0u != (polarity)) ?                                                                 (UART_1_BLE_UART_FLOW_CTRL_CTS_POLARITY) : (0u))
N
N    #define UART_1_BLE_GET_UART_FLOW_CTRL_CTS_ENABLE(ctsEn)      ((0u != (ctsEn)) ? \
N                                                                (UART_1_BLE_UART_FLOW_CTRL_CTS_ENABLE) : (0u))
X    #define UART_1_BLE_GET_UART_FLOW_CTRL_CTS_ENABLE(ctsEn)      ((0u != (ctsEn)) ?                                                                 (UART_1_BLE_UART_FLOW_CTRL_CTS_ENABLE) : (0u))
N#endif /* !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1) */
N
N/* UART_1_BLE_RX_CTRL */
N#define UART_1_BLE_GET_RX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) & \
N                                                                UART_1_BLE_RX_CTRL_DATA_WIDTH_MASK)
X#define UART_1_BLE_GET_RX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) &                                                                 UART_1_BLE_RX_CTRL_DATA_WIDTH_MASK)
N
N#define UART_1_BLE_GET_RX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ? \
N                                                                (UART_1_BLE_RX_CTRL_MSB_FIRST) : (0u))
X#define UART_1_BLE_GET_RX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ?                                                                 (UART_1_BLE_RX_CTRL_MSB_FIRST) : (0u))
N
N#define UART_1_BLE_GET_RX_CTRL_MEDIAN(filterEn)       ((0u != (filterEn)) ? \
N                                                                (UART_1_BLE_RX_CTRL_MEDIAN) : (0u))
X#define UART_1_BLE_GET_RX_CTRL_MEDIAN(filterEn)       ((0u != (filterEn)) ?                                                                 (UART_1_BLE_RX_CTRL_MEDIAN) : (0u))
N
N/* UART_1_BLE_RX_MATCH */
N#define UART_1_BLE_GET_RX_MATCH_ADDR(addr)    ((uint32) (addr) & UART_1_BLE_RX_MATCH_ADDR_MASK)
N#define UART_1_BLE_GET_RX_MATCH_MASK(mask)    (((uint32) (mask) << \
N                                                            UART_1_BLE_RX_MATCH_MASK_POS) & \
N                                                            UART_1_BLE_RX_MATCH_MASK_MASK)
X#define UART_1_BLE_GET_RX_MATCH_MASK(mask)    (((uint32) (mask) <<                                                             UART_1_BLE_RX_MATCH_MASK_POS) &                                                             UART_1_BLE_RX_MATCH_MASK_MASK)
N
N/* UART_1_BLE_RX_FIFO_CTRL */
N#define UART_1_BLE_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) & \
N                                                                    UART_1_BLE_RX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
X#define UART_1_BLE_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) &                                                                     UART_1_BLE_RX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
N
N/* UART_1_BLE_TX_CTRL */
N#define UART_1_BLE_GET_TX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) & \
N                                                                UART_1_BLE_TX_CTRL_DATA_WIDTH_MASK)
X#define UART_1_BLE_GET_TX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) &                                                                 UART_1_BLE_TX_CTRL_DATA_WIDTH_MASK)
N
N#define UART_1_BLE_GET_TX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ? \
N                                                                (UART_1_BLE_TX_CTRL_MSB_FIRST) : (0u))
X#define UART_1_BLE_GET_TX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ?                                                                 (UART_1_BLE_TX_CTRL_MSB_FIRST) : (0u))
N
N/* UART_1_BLE_TX_FIFO_CTRL */
N#define UART_1_BLE_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) & \
N                                                                    UART_1_BLE_TX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
X#define UART_1_BLE_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) &                                                                     UART_1_BLE_TX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
N
N/* UART_1_BLE_INTR_SLAVE_I2C_GENERAL */
N#define UART_1_BLE_GET_INTR_SLAVE_I2C_GENERAL(genCall)  ((0u != (genCall)) ? \
N                                                                (UART_1_BLE_INTR_SLAVE_I2C_GENERAL) : (0u))
X#define UART_1_BLE_GET_INTR_SLAVE_I2C_GENERAL(genCall)  ((0u != (genCall)) ?                                                                 (UART_1_BLE_INTR_SLAVE_I2C_GENERAL) : (0u))
N
N/* Return true if master mode is enabled UART_1_BLE_SPI_CTRL_REG */
N#define UART_1_BLE_CHECK_SPI_MASTER   (0u != (UART_1_BLE_SPI_CTRL_REG & UART_1_BLE_SPI_CTRL_MASTER))
N
N/* Return inactive state of SPI SCLK line depends on CPOL */
N#define UART_1_BLE_GET_SPI_SCLK_INACTIVE \
N            ((0u == (UART_1_BLE_SPI_CTRL_REG & UART_1_BLE_SPI_CTRL_CPOL)) ? (0u) : (1u))
X#define UART_1_BLE_GET_SPI_SCLK_INACTIVE             ((0u == (UART_1_BLE_SPI_CTRL_REG & UART_1_BLE_SPI_CTRL_CPOL)) ? (0u) : (1u))
N
N/* Get output pin inactive state */
N#if (UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1)
X#if ((2 == 0u) || (2 == 1u))
S#define UART_1_BLE_GET_SPI_SS0_INACTIVE       (1u)
S#define UART_1_BLE_GET_SPI_SS1_INACTIVE       (1u)
S#define UART_1_BLE_GET_SPI_SS2_INACTIVE       (1u)
S#define UART_1_BLE_GET_SPI_SS3_INACTIVE       (1u)
S#define UART_1_BLE_GET_UART_RTS_INACTIVE      (1u)
S
N#else
N#define UART_1_BLE_GET_SPI_SS0_INACTIVE  \
N        ((0u != (UART_1_BLE_SPI_CTRL_REG & UART_1_BLE_SPI_CTRL_SSEL0_POLARITY)) ? (0u) : (1u))
X#define UART_1_BLE_GET_SPI_SS0_INACTIVE          ((0u != (UART_1_BLE_SPI_CTRL_REG & UART_1_BLE_SPI_CTRL_SSEL0_POLARITY)) ? (0u) : (1u))
N
N#define UART_1_BLE_GET_SPI_SS1_INACTIVE  \
N        ((0u != (UART_1_BLE_SPI_CTRL_REG & UART_1_BLE_SPI_CTRL_SSEL1_POLARITY)) ? (0u) : (1u))
X#define UART_1_BLE_GET_SPI_SS1_INACTIVE          ((0u != (UART_1_BLE_SPI_CTRL_REG & UART_1_BLE_SPI_CTRL_SSEL1_POLARITY)) ? (0u) : (1u))
N
N#define UART_1_BLE_GET_SPI_SS2_INACTIVE  \
N        ((0u != (UART_1_BLE_SPI_CTRL_REG & UART_1_BLE_SPI_CTRL_SSEL2_POLARITY)) ? (0u) : (1u))
X#define UART_1_BLE_GET_SPI_SS2_INACTIVE          ((0u != (UART_1_BLE_SPI_CTRL_REG & UART_1_BLE_SPI_CTRL_SSEL2_POLARITY)) ? (0u) : (1u))
N
N#define UART_1_BLE_GET_SPI_SS3_INACTIVE  \
N        ((0u != (UART_1_BLE_SPI_CTRL_REG & UART_1_BLE_SPI_CTRL_SSEL3_POLARITY)) ? (0u) : (1u))
X#define UART_1_BLE_GET_SPI_SS3_INACTIVE          ((0u != (UART_1_BLE_SPI_CTRL_REG & UART_1_BLE_SPI_CTRL_SSEL3_POLARITY)) ? (0u) : (1u))
N
N#define UART_1_BLE_GET_UART_RTS_INACTIVE \
N        ((0u == (UART_1_BLE_UART_FLOW_CTRL_REG & UART_1_BLE_UART_FLOW_CTRL_RTS_POLARITY)) ? (0u) : (1u))
X#define UART_1_BLE_GET_UART_RTS_INACTIVE         ((0u == (UART_1_BLE_UART_FLOW_CTRL_REG & UART_1_BLE_UART_FLOW_CTRL_RTS_POLARITY)) ? (0u) : (1u))
N
N#endif /*(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1) */
N
N/* Clear register constants for configuration and interrupt mask */
N#define UART_1_BLE_CLEAR_REG          ((uint32) (0u))
N#define UART_1_BLE_NO_INTR_SOURCES    ((uint32) (0u))
N#define UART_1_BLE_DUMMY_PARAM        ((uint32) (0u))
N#define UART_1_BLE_SUBMODE_SPI_SLAVE  ((uint32) (0u))
N
N/* Return in case of I2C read error */
N#define UART_1_BLE_I2C_INVALID_BYTE   ((uint32) 0xFFFFFFFFu)
N#define UART_1_BLE_CHECK_VALID_BYTE   ((uint32) 0x80000000u)
N
N
N/***************************************
N* The following code is DEPRECATED and
N* must not be used.
N***************************************/
N
N#define UART_1_BLE_CHECK_INTR_EC_I2C(sourceMask)  UART_1_BLE_CHECK_INTR_I2C_EC(sourceMask)
N#if (!UART_1_BLE_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_1_BLE_CHECK_INTR_EC_SPI(sourceMask)  UART_1_BLE_CHECK_INTR_SPI_EC(sourceMask)
N#endif /* (!UART_1_BLE_CY_SCBIP_V1) */
N
N#define UART_1_BLE_CY_SCBIP_V1_I2C_ONLY   (UART_1_BLE_CY_SCBIP_V1)
N#define UART_1_BLE_EZBUFFER_SIZE          (UART_1_BLE_EZ_DATA_NR)
N
N#define UART_1_BLE_EZBUF_DATA00_REG   UART_1_BLE_EZBUF_DATA0_REG
N#define UART_1_BLE_EZBUF_DATA00_PTR   UART_1_BLE_EZBUF_DATA0_PTR
N
N#endif /* (CY_SCB_UART_1_BLE_H) */
N
N
N/* [] END OF FILE */
L 22 "Generated_Source\PSoC4\project.h" 2
N#include "UART_1_BLE_SPI_UART.h"
L 1 "Generated_Source\PSoC4\UART_1_BLE_SPI_UART.h" 1
N/***************************************************************************//**
N* \file UART_1_BLE_SPI_UART.h
N* \version 4.0
N*
N* \brief
N*  This file provides constants and parameter values for the SCB Component in
N*  SPI and UART modes.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_SPI_UART_UART_1_BLE_H)
X#if !0L
N#define CY_SCB_SPI_UART_UART_1_BLE_H
N
N#include "UART_1_BLE.h"
N
N
N/***************************************
N*   SPI Initial Parameter Constants
N****************************************/
N
N#define UART_1_BLE_SPI_MODE                   (0u)
N#define UART_1_BLE_SPI_SUB_MODE               (0u)
N#define UART_1_BLE_SPI_CLOCK_MODE             (0u)
N#define UART_1_BLE_SPI_OVS_FACTOR             (16u)
N#define UART_1_BLE_SPI_MEDIAN_FILTER_ENABLE   (0u)
N#define UART_1_BLE_SPI_LATE_MISO_SAMPLE_ENABLE (0u)
N#define UART_1_BLE_SPI_RX_DATA_BITS_NUM       (8u)
N#define UART_1_BLE_SPI_TX_DATA_BITS_NUM       (8u)
N#define UART_1_BLE_SPI_WAKE_ENABLE            (0u)
N#define UART_1_BLE_SPI_BITS_ORDER             (1u)
N#define UART_1_BLE_SPI_TRANSFER_SEPARATION    (1u)
N#define UART_1_BLE_SPI_NUMBER_OF_SS_LINES     (1u)
N#define UART_1_BLE_SPI_RX_BUFFER_SIZE         (8u)
N#define UART_1_BLE_SPI_TX_BUFFER_SIZE         (8u)
N
N#define UART_1_BLE_SPI_INTERRUPT_MODE         (0u)
N
N#define UART_1_BLE_SPI_INTR_RX_MASK           (0x0u)
N#define UART_1_BLE_SPI_INTR_TX_MASK           (0x0u)
N
N#define UART_1_BLE_SPI_RX_TRIGGER_LEVEL       (7u)
N#define UART_1_BLE_SPI_TX_TRIGGER_LEVEL       (0u)
N
N#define UART_1_BLE_SPI_BYTE_MODE_ENABLE       (0u)
N#define UART_1_BLE_SPI_FREE_RUN_SCLK_ENABLE   (0u)
N#define UART_1_BLE_SPI_SS0_POLARITY           (0u)
N#define UART_1_BLE_SPI_SS1_POLARITY           (0u)
N#define UART_1_BLE_SPI_SS2_POLARITY           (0u)
N#define UART_1_BLE_SPI_SS3_POLARITY           (0u)
N
N
N/***************************************
N*   UART Initial Parameter Constants
N****************************************/
N
N#define UART_1_BLE_UART_SUB_MODE              (0u)
N#define UART_1_BLE_UART_DIRECTION             (3u)
N#define UART_1_BLE_UART_DATA_BITS_NUM         (8u)
N#define UART_1_BLE_UART_PARITY_TYPE           (2u)
N#define UART_1_BLE_UART_STOP_BITS_NUM         (2u)
N#define UART_1_BLE_UART_OVS_FACTOR            (12u)
N#define UART_1_BLE_UART_IRDA_LOW_POWER        (0u)
N#define UART_1_BLE_UART_MEDIAN_FILTER_ENABLE  (0u)
N#define UART_1_BLE_UART_RETRY_ON_NACK         (0u)
N#define UART_1_BLE_UART_IRDA_POLARITY         (0u)
N#define UART_1_BLE_UART_DROP_ON_FRAME_ERR     (0u)
N#define UART_1_BLE_UART_DROP_ON_PARITY_ERR    (0u)
N#define UART_1_BLE_UART_WAKE_ENABLE           (0u)
N#define UART_1_BLE_UART_RX_BUFFER_SIZE        (8u)
N#define UART_1_BLE_UART_TX_BUFFER_SIZE        (8u)
N#define UART_1_BLE_UART_MP_MODE_ENABLE        (0u)
N#define UART_1_BLE_UART_MP_ACCEPT_ADDRESS     (0u)
N#define UART_1_BLE_UART_MP_RX_ADDRESS         (0x2u)
N#define UART_1_BLE_UART_MP_RX_ADDRESS_MASK    (0xFFu)
N
N#define UART_1_BLE_UART_INTERRUPT_MODE        (1u)
N
N#define UART_1_BLE_UART_INTR_RX_MASK          (0x4u)
N#define UART_1_BLE_UART_INTR_TX_MASK          (0x0u)
N
N#define UART_1_BLE_UART_RX_TRIGGER_LEVEL      (7u)
N#define UART_1_BLE_UART_TX_TRIGGER_LEVEL      (0u)
N
N#define UART_1_BLE_UART_BYTE_MODE_ENABLE      (0u)
N#define UART_1_BLE_UART_CTS_ENABLE            (0u)
N#define UART_1_BLE_UART_CTS_POLARITY          (0u)
N#define UART_1_BLE_UART_RTS_ENABLE            (0u)
N#define UART_1_BLE_UART_RTS_POLARITY          (0u)
N#define UART_1_BLE_UART_RTS_FIFO_LEVEL        (4u)
N
N#define UART_1_BLE_UART_RX_BREAK_WIDTH        (11u)
N
N/* SPI mode enum */
N#define UART_1_BLE_SPI_SLAVE  (0u)
N#define UART_1_BLE_SPI_MASTER (1u)
N
N/* UART direction enum */
N#define UART_1_BLE_UART_RX    (1u)
N#define UART_1_BLE_UART_TX    (2u)
N#define UART_1_BLE_UART_TX_RX (3u)
N
N
N/***************************************
N*   Conditional Compilation Parameters
N****************************************/
N
N#if(UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S
S    /* Mode */
S    #define UART_1_BLE_SPI_SLAVE_CONST        (1u)
S    #define UART_1_BLE_SPI_MASTER_CONST       (1u)
S
S    /* Direction */
S    #define UART_1_BLE_RX_DIRECTION           (1u)
S    #define UART_1_BLE_TX_DIRECTION           (1u)
S    #define UART_1_BLE_UART_RX_DIRECTION      (1u)
S    #define UART_1_BLE_UART_TX_DIRECTION      (1u)
S
S    /* Only external RX and TX buffer for Uncofigured mode */
S    #define UART_1_BLE_INTERNAL_RX_SW_BUFFER   (0u)
S    #define UART_1_BLE_INTERNAL_TX_SW_BUFFER   (0u)
S
S    /* Get RX and TX buffer size */
S    #define UART_1_BLE_INTERNAL_RX_BUFFER_SIZE    (UART_1_BLE_rxBufferSize + 1u)
S    #define UART_1_BLE_RX_BUFFER_SIZE             (UART_1_BLE_rxBufferSize)
S    #define UART_1_BLE_TX_BUFFER_SIZE             (UART_1_BLE_txBufferSize)
S
S    /* Return true if buffer is provided */
S    #define UART_1_BLE_CHECK_RX_SW_BUFFER (NULL != UART_1_BLE_rxBuffer)
S    #define UART_1_BLE_CHECK_TX_SW_BUFFER (NULL != UART_1_BLE_txBuffer)
S
S    /* Always provide global variables to support RX and TX buffers */
S    #define UART_1_BLE_INTERNAL_RX_SW_BUFFER_CONST    (1u)
S    #define UART_1_BLE_INTERNAL_TX_SW_BUFFER_CONST    (1u)
S
S    /* Get wakeup enable option */
S    #define UART_1_BLE_SPI_WAKE_ENABLE_CONST  (1u)
S    #define UART_1_BLE_UART_WAKE_ENABLE_CONST (1u)
S    #define UART_1_BLE_CHECK_SPI_WAKE_ENABLE  ((0u != UART_1_BLE_scbEnableWake) && UART_1_BLE_SCB_MODE_SPI_RUNTM_CFG)
S    #define UART_1_BLE_CHECK_UART_WAKE_ENABLE ((0u != UART_1_BLE_scbEnableWake) && UART_1_BLE_SCB_MODE_UART_RUNTM_CFG)
S
S    /* SPI/UART: TX or RX FIFO size */
S    #if (UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1)
S        #define UART_1_BLE_SPI_UART_FIFO_SIZE             (UART_1_BLE_FIFO_SIZE)
S        #define UART_1_BLE_CHECK_UART_RTS_CONTROL_FLOW    (0u)
S    #else
S        #define UART_1_BLE_SPI_UART_FIFO_SIZE (UART_1_BLE_GET_FIFO_SIZE(UART_1_BLE_CTRL_REG & \
S                                                                                    UART_1_BLE_CTRL_BYTE_MODE))
X        #define UART_1_BLE_SPI_UART_FIFO_SIZE (UART_1_BLE_GET_FIFO_SIZE(UART_1_BLE_CTRL_REG &                                                                                     UART_1_BLE_CTRL_BYTE_MODE))
S
S        #define UART_1_BLE_CHECK_UART_RTS_CONTROL_FLOW \
S                    ((UART_1_BLE_SCB_MODE_UART_RUNTM_CFG) && \
S                     (0u != UART_1_BLE_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(UART_1_BLE_UART_FLOW_CTRL_REG)))
X        #define UART_1_BLE_CHECK_UART_RTS_CONTROL_FLOW                     ((UART_1_BLE_SCB_MODE_UART_RUNTM_CFG) &&                      (0u != UART_1_BLE_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(UART_1_BLE_UART_FLOW_CTRL_REG)))
S    #endif /* (UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1) */
S
N#else
N
N    /* Internal RX and TX buffer: for SPI or UART */
N    #if (UART_1_BLE_SCB_MODE_SPI_CONST_CFG)
X    #if (((0x02u) == (4u)))
S
S        /* SPI Direction */
S        #define UART_1_BLE_SPI_RX_DIRECTION (1u)
S        #define UART_1_BLE_SPI_TX_DIRECTION (1u)
S
S        /* Get FIFO size */
S        #define UART_1_BLE_SPI_UART_FIFO_SIZE UART_1_BLE_GET_FIFO_SIZE(UART_1_BLE_SPI_BYTE_MODE_ENABLE)
S
S        /* SPI internal RX and TX buffers */
S        #define UART_1_BLE_INTERNAL_SPI_RX_SW_BUFFER  (UART_1_BLE_SPI_RX_BUFFER_SIZE > \
S                                                                UART_1_BLE_SPI_UART_FIFO_SIZE)
X        #define UART_1_BLE_INTERNAL_SPI_RX_SW_BUFFER  (UART_1_BLE_SPI_RX_BUFFER_SIZE >                                                                 UART_1_BLE_SPI_UART_FIFO_SIZE)
S        #define UART_1_BLE_INTERNAL_SPI_TX_SW_BUFFER  (UART_1_BLE_SPI_TX_BUFFER_SIZE > \
S                                                                UART_1_BLE_SPI_UART_FIFO_SIZE)
X        #define UART_1_BLE_INTERNAL_SPI_TX_SW_BUFFER  (UART_1_BLE_SPI_TX_BUFFER_SIZE >                                                                 UART_1_BLE_SPI_UART_FIFO_SIZE)
S
S        /* Internal SPI RX and TX buffer */
S        #define UART_1_BLE_INTERNAL_RX_SW_BUFFER  (UART_1_BLE_INTERNAL_SPI_RX_SW_BUFFER)
S        #define UART_1_BLE_INTERNAL_TX_SW_BUFFER  (UART_1_BLE_INTERNAL_SPI_TX_SW_BUFFER)
S
S        /* Internal SPI RX and TX buffer size */
S        #define UART_1_BLE_INTERNAL_RX_BUFFER_SIZE    (UART_1_BLE_SPI_RX_BUFFER_SIZE + 1u)
S        #define UART_1_BLE_RX_BUFFER_SIZE             (UART_1_BLE_SPI_RX_BUFFER_SIZE)
S        #define UART_1_BLE_TX_BUFFER_SIZE             (UART_1_BLE_SPI_TX_BUFFER_SIZE)
S
S        /* Get wakeup enable option */
S        #define UART_1_BLE_SPI_WAKE_ENABLE_CONST  (0u != UART_1_BLE_SPI_WAKE_ENABLE)
S        #define UART_1_BLE_UART_WAKE_ENABLE_CONST (0u)
S
N    #else
N
N        /* UART Direction */
N        #define UART_1_BLE_UART_RX_DIRECTION (0u != (UART_1_BLE_UART_DIRECTION & UART_1_BLE_UART_RX))
N        #define UART_1_BLE_UART_TX_DIRECTION (0u != (UART_1_BLE_UART_DIRECTION & UART_1_BLE_UART_TX))
N
N        /* Get FIFO size */
N        #define UART_1_BLE_SPI_UART_FIFO_SIZE UART_1_BLE_GET_FIFO_SIZE(UART_1_BLE_UART_BYTE_MODE_ENABLE)
N
N        /* UART internal RX and TX buffers */
N        #define UART_1_BLE_INTERNAL_UART_RX_SW_BUFFER  (UART_1_BLE_UART_RX_BUFFER_SIZE > \
N                                                                UART_1_BLE_SPI_UART_FIFO_SIZE)
X        #define UART_1_BLE_INTERNAL_UART_RX_SW_BUFFER  (UART_1_BLE_UART_RX_BUFFER_SIZE >                                                                 UART_1_BLE_SPI_UART_FIFO_SIZE)
N        #define UART_1_BLE_INTERNAL_UART_TX_SW_BUFFER  (UART_1_BLE_UART_TX_BUFFER_SIZE > \
N                                                                    UART_1_BLE_SPI_UART_FIFO_SIZE)
X        #define UART_1_BLE_INTERNAL_UART_TX_SW_BUFFER  (UART_1_BLE_UART_TX_BUFFER_SIZE >                                                                     UART_1_BLE_SPI_UART_FIFO_SIZE)
N
N        /* Internal UART RX and TX buffer */
N        #define UART_1_BLE_INTERNAL_RX_SW_BUFFER  (UART_1_BLE_INTERNAL_UART_RX_SW_BUFFER)
N        #define UART_1_BLE_INTERNAL_TX_SW_BUFFER  (UART_1_BLE_INTERNAL_UART_TX_SW_BUFFER)
N
N        /* Internal UART RX and TX buffer size */
N        #define UART_1_BLE_INTERNAL_RX_BUFFER_SIZE    (UART_1_BLE_UART_RX_BUFFER_SIZE + 1u)
N        #define UART_1_BLE_RX_BUFFER_SIZE             (UART_1_BLE_UART_RX_BUFFER_SIZE)
N        #define UART_1_BLE_TX_BUFFER_SIZE             (UART_1_BLE_UART_TX_BUFFER_SIZE)
N
N        /* Get wakeup enable option */
N        #define UART_1_BLE_SPI_WAKE_ENABLE_CONST  (0u)
N        #define UART_1_BLE_UART_WAKE_ENABLE_CONST (0u != UART_1_BLE_UART_WAKE_ENABLE)
N
N    #endif /* (UART_1_BLE_SCB_MODE_SPI_CONST_CFG) */
N
N    /* Mode */
N    #define UART_1_BLE_SPI_SLAVE_CONST    (UART_1_BLE_SPI_MODE == UART_1_BLE_SPI_SLAVE)
N    #define UART_1_BLE_SPI_MASTER_CONST   (UART_1_BLE_SPI_MODE == UART_1_BLE_SPI_MASTER)
N
N    /* Direction */
N    #define UART_1_BLE_RX_DIRECTION ((UART_1_BLE_SCB_MODE_SPI_CONST_CFG) ? \
N                                            (UART_1_BLE_SPI_RX_DIRECTION) : (UART_1_BLE_UART_RX_DIRECTION))
X    #define UART_1_BLE_RX_DIRECTION ((UART_1_BLE_SCB_MODE_SPI_CONST_CFG) ?                                             (UART_1_BLE_SPI_RX_DIRECTION) : (UART_1_BLE_UART_RX_DIRECTION))
N
N    #define UART_1_BLE_TX_DIRECTION ((UART_1_BLE_SCB_MODE_SPI_CONST_CFG) ? \
N                                            (UART_1_BLE_SPI_TX_DIRECTION) : (UART_1_BLE_UART_TX_DIRECTION))
X    #define UART_1_BLE_TX_DIRECTION ((UART_1_BLE_SCB_MODE_SPI_CONST_CFG) ?                                             (UART_1_BLE_SPI_TX_DIRECTION) : (UART_1_BLE_UART_TX_DIRECTION))
N
N    /* Internal RX and TX buffer: for SPI or UART. Used in conditional compilation check */
N    #define UART_1_BLE_CHECK_RX_SW_BUFFER (UART_1_BLE_INTERNAL_RX_SW_BUFFER)
N    #define UART_1_BLE_CHECK_TX_SW_BUFFER (UART_1_BLE_INTERNAL_TX_SW_BUFFER)
N
N    /* Provide global variables to support RX and TX buffers */
N    #define UART_1_BLE_INTERNAL_RX_SW_BUFFER_CONST    (UART_1_BLE_INTERNAL_RX_SW_BUFFER)
N    #define UART_1_BLE_INTERNAL_TX_SW_BUFFER_CONST    (UART_1_BLE_INTERNAL_TX_SW_BUFFER)
N
N    /* Wake up enable */
N    #define UART_1_BLE_CHECK_SPI_WAKE_ENABLE  (UART_1_BLE_SPI_WAKE_ENABLE_CONST)
N    #define UART_1_BLE_CHECK_UART_WAKE_ENABLE (UART_1_BLE_UART_WAKE_ENABLE_CONST)
N
N    /* UART flow control: not applicable for CY_SCBIP_V0 || CY_SCBIP_V1 */
N    #define UART_1_BLE_CHECK_UART_RTS_CONTROL_FLOW    (UART_1_BLE_SCB_MODE_UART_CONST_CFG && \
N                                                             UART_1_BLE_UART_RTS_ENABLE)
X    #define UART_1_BLE_CHECK_UART_RTS_CONTROL_FLOW    (UART_1_BLE_SCB_MODE_UART_CONST_CFG &&                                                              UART_1_BLE_UART_RTS_ENABLE)
N
N#endif /* End (UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N
N/***************************************
N*       Type Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N
N/* UART_1_BLE_SPI_INIT_STRUCT */
Ntypedef struct
N{
N    /** Mode of operation for SPI. The following defines are available choices:
N     *  - UART_1_BLE_SPI_SLAVE
N     *  - UART_1_BLE_SPI_MASTE
N    */
N    uint32 mode;
N
N    /** Submode of operation for SPI. The following defines are available
N     *  choices:
N     *  - UART_1_BLE_SPI_MODE_MOTOROLA
N     *  - UART_1_BLE_SPI_MODE_TI_COINCIDES
N     *  - UART_1_BLE_SPI_MODE_TI_PRECEDES
N     *  - UART_1_BLE_SPI_MODE_NATIONAL
N    */
N    uint32 submode;
N
N    /** Determines the sclk relationship for Motorola submode. Ignored
N     *  for other submodes. The following defines are available choices:
N     *  - UART_1_BLE_SPI_SCLK_CPHA0_CPOL0
N     *  - UART_1_BLE_SPI_SCLK_CPHA0_CPOL1
N     *  - UART_1_BLE_SPI_SCLK_CPHA1_CPOL0
N     *  - UART_1_BLE_SPI_SCLK_CPHA1_CPOL1
N    */
N    uint32 sclkMode;
N
N    /** Oversampling factor for the SPI clock. Ignored for Slave mode operation.
N    */
N    uint32 oversample;
N
N    /** Applies median filter on the input lines: 0  not applied, 1  applied.
N    */
N    uint32 enableMedianFilter;
N
N    /** Applies late sampling of MISO line: 0  not applied, 1  applied.
N     *  Ignored for slave mode.
N    */
N    uint32 enableLateSampling;
N
N    /** Enables wakeup from low power mode: 0  disable, 1  enable.
N     *  Ignored for master mode.
N    */
N    uint32 enableWake;
N
N    /** Number of data bits for RX direction.
N     *  Different dataBitsRx and dataBitsTx are only allowed for National
N     *  submode.
N    */
N    uint32 rxDataBits;
N
N    /** Number of data bits for TX direction.
N     *  Different dataBitsRx and dataBitsTx are only allowed for National
N     *  submode.
N    */
N    uint32 txDataBits;
N
N    /** Determines the bit ordering. The following defines are available
N     *  choices:
N     *  - UART_1_BLE_BITS_ORDER_LSB_FIRST
N     *  - UART_1_BLE_BITS_ORDER_MSB_FIRST
N    */
N    uint32 bitOrder;
N
N    /** Determines whether transfers are back to back or have SS disabled
N     *  between words. Ignored for slave mode. The following defines are
N     *  available choices:
N     *  - UART_1_BLE_SPI_TRANSFER_CONTINUOUS
N     *  - UART_1_BLE_SPI_TRANSFER_SEPARATED
N    */
N    uint32 transferSeperation;
N
N    /** Size of the RX buffer in bytes/words (depends on rxDataBits parameter).
N     *  A value equal to the RX FIFO depth implies the usage of buffering in
N     *  hardware. A value greater than the RX FIFO depth results in a software
N     *  buffer.
N     *  The UART_1_BLE_INTR _RX_NOT_EMPTY interrupt has to be enabled to
N     *  transfer data into the software buffer.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words for PSoC 4100 /
N     *    PSoC 4200 devices.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words or 16
N     *    bytes (Byte mode is enabled) for PSoC 4100 BLE / PSoC 4200 BLE /
N     *    PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *    PSoC Analog Coprocessor devices.
N    */
N    uint32 rxBufferSize;
N
N    /** Buffer space provided for a RX software buffer:
N     *  - A NULL pointer must be provided to use hardware buffering.
N     *  - A pointer to an allocated buffer must be provided to use software
N     *    buffering. The buffer size must equal (rxBufferSize + 1) in bytes if
N     *    dataBitsRx is less or equal to 8, otherwise (2 * (rxBufferSize + 1))
N     *    in bytes. The software RX buffer always keeps one element empty.
N     *    For correct operation the allocated RX buffer has to be one element
N     *    greater than maximum packet size expected to be received.
N    */
N    uint8* rxBuffer;
N
N    /** Size of the TX buffer in bytes/words(depends on txDataBits parameter).
N     *  A value equal to the TX FIFO depth implies the usage of buffering in
N     *  hardware. A value greater than the TX FIFO depth results in a software
N     *  buffer.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words for PSoC 4100 /
N     *    PSoC 4200 devices.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words or 16
N     *    bytes (Byte mode is enabled) for PSoC 4100 BLE / PSoC 4200 BLE /
N     *    PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *    PSoC Analog Coprocessor devices.
N    */
N    uint32 txBufferSize;
N
N    /** Buffer space provided for a TX software buffer:
N     *  - A NULL pointer must be provided to use hardware buffering.
N     *  - A pointer to an allocated buffer must be provided to use software
N     *    buffering. The buffer size must equal txBufferSize if dataBitsTx is
N     *    less or equal to 8, otherwise (2* txBufferSize).
N    */
N    uint8* txBuffer;
N
N    /** Enables component interrupt: 0  disable, 1  enable.
N     *  The interrupt has to be enabled if software buffer is used.
N    */
N    uint32 enableInterrupt;
N
N    /** Mask of enabled interrupt sources for the RX direction. This mask is
N     *  written regardless of the setting of the enable Interrupt field.
N     *  Multiple sources are enabled by providing a value that is the OR of
N     *  all of the following sources to enable:
N     *  - UART_1_BLE_INTR_RX_FIFO_LEVEL
N     *  - UART_1_BLE_INTR_RX_NOT_EMPTY
N     *  - UART_1_BLE_INTR_RX_FULL
N     *  - UART_1_BLE_INTR_RX_OVERFLOW
N     *  - UART_1_BLE_INTR_RX_UNDERFLOW
N     *  - UART_1_BLE_INTR_SLAVE_SPI_BUS_ERROR
N    */
N    uint32 rxInterruptMask;
N
N    /** FIFO level for an RX FIFO level interrupt. This value is written
N     *  regardless of whether the RX FIFO level interrupt source is enabled.
N    */
N    uint32 rxTriggerLevel;
N
N    /** Mask of enabled interrupt sources for the TX direction. This mask is
N     *  written regardless of the setting of the enable Interrupt field.
N     *  Multiple sources are enabled by providing a value that is the OR of
N     *  all of the following sources to enable:
N     *  - UART_1_BLE_INTR_TX_FIFO_LEVEL
N     *  - UART_1_BLE_INTR_TX_NOT_FULL
N     *  - UART_1_BLE_INTR_TX_EMPTY
N     *  - UART_1_BLE_INTR_TX_OVERFLOW
N     *  - UART_1_BLE_INTR_TX_UNDERFLOW
N     *  - UART_1_BLE_INTR_MASTER_SPI_DONE
N    */
N    uint32 txInterruptMask;
N
N    /** FIFO level for a TX FIFO level interrupt. This value is written
N     * regardless of whether the TX FIFO level interrupt source is enabled.
N    */
N    uint32 txTriggerLevel;
N
N    /** When enabled the TX and RX FIFO depth is doubled and equal to
N     *  16 bytes: 0  disable, 1  enable. This implies that number of
N     *  TX and RX data bits must be less than or equal to 8.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 enableByteMode;
N
N    /** Enables continuous SCLK generation by the SPI master: 0  disable,
N     *  1  enable.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 enableFreeRunSclk;
N
N    /** Active polarity of slave select lines 0-3. This is bit mask where bit
N     *  UART_1_BLE_SPI_SLAVE_SELECT0 corresponds to slave select 0
N     *  polarity, bit UART_1_BLE_SPI_SLAVE_SELECT1  slave select 1
N     *  polarity and so on. Polarity constants are:
N     *  - UART_1_BLE_SPI_SS_ACTIVE_LOW
N     *  - UART_1_BLE_SPI_SS_ACTIVE_HIGH
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 polaritySs;
N} UART_1_BLE_SPI_INIT_STRUCT;
N
N
N/* UART_1_BLE_UART_INIT_STRUCT */
Ntypedef struct
N{
N    /** Mode of operation for the UART. The following defines are available
N     *  choices:
N     *  - UART_1_BLE_UART_MODE_STD
N     *  - UART_1_BLE_UART_MODE_SMARTCARD
N     *  - UART_1_BLE_UART_MODE_IRDA
N    */
N    uint32 mode;
N
N    /** Direction of operation for the UART. The following defines are available
N     *  choices:
N     *  - UART_1_BLE_UART_TX_RX
N     *  - UART_1_BLE_UART_RX
N     *  - UART_1_BLE_UART_TX
N    */
N    uint32 direction;
N
N    /** Number of data bits.
N    */
N    uint32 dataBits;
N
N    /** Determines the parity. The following defines are available choices:
N     *  - UART_1_BLE_UART_PARITY_EVEN
N     *  - UART_1_BLE_UART_PARITY_ODD
N     *  - UART_1_BLE_UART_PARITY_NONE
N    */
N    uint32 parity;
N
N    /** Determines the number of stop bits. The following defines are available
N     *  choices:
N     *  - UART_1_BLE_UART_STOP_BITS_1
N     *  - UART_1_BLE_UART_STOP_BITS_1_5
N     *  - UART_1_BLE_UART_STOP_BITS_2
N    */
N    uint32 stopBits;
N
N    /** Oversampling factor for the UART.
N     *
N     *  Note The oversampling factor values are changed when enableIrdaLowPower
N     *  is enabled:
N     *  - UART_1_BLE_UART_IRDA_LP_OVS16
N     *  - UART_1_BLE_UART_IRDA_LP_OVS32
N     *  - UART_1_BLE_UART_IRDA_LP_OVS48
N     *  - UART_1_BLE_UART_IRDA_LP_OVS96
N     *  - UART_1_BLE_UART_IRDA_LP_OVS192
N     *  - UART_1_BLE_UART_IRDA_LP_OVS768
N     *  - UART_1_BLE_UART_IRDA_LP_OVS1536
N    */
N    uint32 oversample;
N
N    /** Enables IrDA low power RX mode operation: 0  disable, 1  enable.
N     *  The TX functionality does not work when enabled.
N    */
N    uint32 enableIrdaLowPower;
N
N    /** Applies median filter on the input lines:  0  not applied, 1  applied.
N    */
N    uint32 enableMedianFilter;
N
N    /** Enables retry when NACK response was received: 0  disable, 1  enable.
N     *  Only current content of TX FIFO is re-sent.
N     *  Ignored for modes other than SmartCard.
N    */
N    uint32 enableRetryNack;
N
N    /** Inverts polarity of RX line: 0  non-inverting, 1  inverting.
N     *  Ignored for modes other than IrDA.
N    */
N    uint32 enableInvertedRx;
N
N    /** Drop data from RX FIFO if parity error is detected: 0  disable,
N     *  1  enable.
N    */
N    uint32 dropOnParityErr;
N
N    /** Drop data from RX FIFO if a frame error is detected: 0  disable,
N     *  1  enable.
N    */
N    uint32 dropOnFrameErr;
N
N    /** Enables wakeup from low power mode: 0  disable, 1  enable.
N     *  Ignored for modes other than standard UART. The RX functionality
N     *  has to be enabled.
N    */
N    uint32 enableWake;
N
N    /** Size of the RX buffer in bytes/words (depends on rxDataBits parameter).
N     *  A value equal to the RX FIFO depth implies the usage of buffering in
N     *  hardware. A value greater than the RX FIFO depth results in a software
N     *  buffer.
N     *  The UART_1_BLE_INTR _RX_NOT_EMPTY interrupt has to be enabled to
N     *  transfer data into the software buffer.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words for PSoC 4100 /
N     *    PSoC 4200 devices.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words or 16
N     *    bytes (Byte mode is enabled) for PSoC 4100 BLE / PSoC 4200 BLE /
N     *    PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *    PSoC Analog Coprocessor devices.
N    */
N    uint32 rxBufferSize;
N
N    /** Buffer space provided for a RX software buffer:
N     *  - A NULL pointer must be provided to use hardware buffering.
N     *  - A pointer to an allocated buffer must be provided to use software
N     *    buffering. The buffer size must equal (rxBufferSize + 1) in bytes if
N     *    dataBitsRx is less or equal to 8, otherwise (2 * (rxBufferSize + 1))
N     *    in bytes. The software RX buffer always keeps one element empty.
N     *    For correct operation the allocated RX buffer has to be one element
N     *    greater than maximum packet size expected to be received.
N    */
N    uint8* rxBuffer;
N
N    /** Size of the TX buffer in bytes/words(depends on txDataBits parameter).
N     *  A value equal to the TX FIFO depth implies the usage of buffering in
N     *  hardware. A value greater than the TX FIFO depth results in a software
N     *  buffer.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words for PSoC 4100 /
N     *    PSoC 4200 devices.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words or 16
N     *    bytes (Byte mode is enabled) for PSoC 4100 BLE / PSoC 4200 BLE /
N     *    PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *    PSoC Analog Coprocessor devices.
N    */
N    uint32 txBufferSize;
N
N    /** Buffer space provided for a TX software buffer:
N     *  - A NULL pointer must be provided to use hardware buffering.
N     *  - A pointer to an allocated buffer must be provided to use software
N     *    buffering. The buffer size must equal txBufferSize if dataBitsTx is
N     *    less or equal to 8, otherwise (2* txBufferSize).
N    */
N    uint8* txBuffer;
N
N    /** Enables multiprocessor mode: 0  disable, 1  enable.
N    */
N    uint32 enableMultiproc;
N
N    /** Enables matched address to be accepted: 0  disable, 1  enable.
N    */
N    uint32 multiprocAcceptAddr;
N
N    /** 8 bit address to match in Multiprocessor mode. Ignored for other modes.
N    */
N    uint32 multiprocAddr;
N
N    /** 8 bit mask of address bits that are compared for a Multiprocessor
N     *  address match. Ignored for other modes.
N     *  - Bit value 0  excludes bit from address comparison.
N     *  - Bit value 1  the bit needs to match with the corresponding bit
N     *   of the device address.
N    */
N    uint32 multiprocAddrMask;
N
N    /** Enables component interrupt: 0  disable, 1  enable.
N     *  The interrupt has to be enabled if software buffer is used.
N    */
N    uint32 enableInterrupt;
N
N    /** Mask of interrupt sources to enable in the RX direction. This mask is
N     *  written regardless of the setting of the enableInterrupt field.
N     *  Multiple sources are enabled by providing a value that is the OR of
N     *  all of the following sources to enable:
N     *  - UART_1_BLE_INTR_RX_FIFO_LEVEL
N     *  - UART_1_BLE_INTR_RX_NOT_EMPTY
N     *  - UART_1_BLE_INTR_RX_FULL
N     *  - UART_1_BLE_INTR_RX_OVERFLOW
N     *  - UART_1_BLE_INTR_RX_UNDERFLOW
N     *  - UART_1_BLE_INTR_RX_FRAME_ERROR
N     *  - UART_1_BLE_INTR_RX_PARITY_ERROR
N    */
N    uint32 rxInterruptMask;
N
N    /** FIFO level for an RX FIFO level interrupt. This value is written
N     *  regardless of whether the RX FIFO level interrupt source is enabled.
N    */
N    uint32 rxTriggerLevel;
N
N    /** Mask of interrupt sources to enable in the TX direction. This mask is
N     *  written regardless of the setting of the enableInterrupt field.
N     *  Multiple sources are enabled by providing a value that is the OR of
N     *  all of the following sources to enable:
N     *  - UART_1_BLE_INTR_TX_FIFO_LEVEL
N     *  - UART_1_BLE_INTR_TX_NOT_FULL
N     *  - UART_1_BLE_INTR_TX_EMPTY
N     *  - UART_1_BLE_INTR_TX_OVERFLOW
N     *  - UART_1_BLE_INTR_TX_UNDERFLOW
N     *  - UART_1_BLE_INTR_TX_UART_DONE
N     *  - UART_1_BLE_INTR_TX_UART_NACK
N     *  - UART_1_BLE_INTR_TX_UART_ARB_LOST
N    */
N    uint32 txInterruptMask;
N
N    /** FIFO level for a TX FIFO level interrupt. This value is written
N     *  regardless of whether the TX FIFO level interrupt source is enabled.
N    */
N    uint32 txTriggerLevel;
N
N    /** When enabled the TX and RX FIFO depth is doubled and equal to
N     *  16 bytes: 0  disable, 1  enable. This implies that number of
N     *  Data bits must be less than or equal to 8.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 enableByteMode;
N
N    /** Enables usage of CTS input signal by the UART transmitter : 0  disable,
N     *  1  enable.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 enableCts;
N
N    /** Sets active polarity of CTS input signal:
N     *  - UART_1_BLE_UART_CTS_ACTIVE_LOW
N     *  - UART_1_BLE_UART_CTS_ACTIVE_HIGH
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 ctsPolarity;
N
N    /** RX FIFO level for RTS signal activation. While the RX FIFO has fewer
N     *  entries than the RTS FIFO level value the RTS signal remains active,
N     *  otherwise the RTS signal becomes inactive. By setting this field to 0,
N     *  RTS signal activation is disabled.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 rtsRxFifoLevel;
N
N    /** Sets active polarity of RTS output signal:
N     *  - UART_1_BLE_UART_RTS_ ACTIVE_LOW
N     *  - UART_1_BLE_UART_RTS_ACTIVE_HIGH
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 rtsPolarity;
N
N    /** Configures the width of a break signal in that triggers the break
N     *  detection interrupt source. A Break is a low level on the RX line.
N     *  Valid range is 1-16 UART bits times.
N    */
N    uint8 breakWidth;
N} UART_1_BLE_UART_INIT_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
N/**
N* \addtogroup group_spi
N* @{
N*/
N/* SPI specific functions */
N#if(UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    void UART_1_BLE_SpiInit(const UART_1_BLE_SPI_INIT_STRUCT *config);
N#endif /* (UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N
N#if(UART_1_BLE_SCB_MODE_SPI_INC)
X#if((0u !=((0x02u) & (4u))))
S    /*******************************************************************************
S    * Function Name: UART_1_BLE_SpiIsBusBusy
S    ****************************************************************************//**
S    *
S    *  Returns the current status on the bus. The bus status is determined using
S    *  the slave select signal.
S    *  - Motorola and National Semiconductor sub-modes: The bus is busy after
S    *    the slave select line is activated and lasts until the slave select line
S    *    is deactivated.
S    *  - Texas Instrument sub-modes: The bus is busy at the moment of the initial
S    *    pulse on the slave select line and lasts until the transfer is complete.
S    *    If SPI Master is configured to use "Separated transfers"
S    *    (see Continuous versus Separated Transfer Separation), the bus is busy
S    *    during each element transfer and is free between each element transfer.
S    *    The Master does not activate SS line immediately after data has been
S    *    written into the TX FIFO.
S    *
S    *  \return slaveSelect: Current status on the bus.
S    *   If the returned value is nonzero, the bus is busy.
S    *   If zero is returned, the bus is free. The bus status is determined using
S    *   the slave select signal.
S    *
S    *******************************************************************************/
S    #define UART_1_BLE_SpiIsBusBusy() ((uint32) (0u != (UART_1_BLE_SPI_STATUS_REG & \
S                                                              UART_1_BLE_SPI_STATUS_BUS_BUSY)))
X    #define UART_1_BLE_SpiIsBusBusy() ((uint32) (0u != (UART_1_BLE_SPI_STATUS_REG &                                                               UART_1_BLE_SPI_STATUS_BUS_BUSY)))
S
S    #if (UART_1_BLE_SPI_MASTER_CONST)
S        void UART_1_BLE_SpiSetActiveSlaveSelect(uint32 slaveSelect);
S    #endif /*(UART_1_BLE_SPI_MASTER_CONST) */
S
S    #if !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1)
S        void UART_1_BLE_SpiSetSlaveSelectPolarity(uint32 slaveSelect, uint32 polarity);
S    #endif /* !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1) */
N#endif /* (UART_1_BLE_SCB_MODE_SPI_INC) */
N/** @} spi */
N
N/**
N* \addtogroup group_uart
N* @{
N*/
N/* UART specific functions */
N#if(UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    void UART_1_BLE_UartInit(const UART_1_BLE_UART_INIT_STRUCT *config);
N#endif /* (UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N#if(UART_1_BLE_SCB_MODE_UART_INC)
X#if((0u !=((0x04u) & (4u))))
N    void UART_1_BLE_UartSetRxAddress(uint32 address);
N    void UART_1_BLE_UartSetRxAddressMask(uint32 addressMask);
N
N
N    /* UART RX direction APIs */
N    #if(UART_1_BLE_UART_RX_DIRECTION)
X    #if((0u != ((3u) & (1u))))
N        uint32 UART_1_BLE_UartGetChar(void);
N        uint32 UART_1_BLE_UartGetByte(void);
N
N        #if !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1)
X        #if !((2 == 0u) || (2 == 1u))
N            /* UART APIs for Flow Control */
N            void UART_1_BLE_UartSetRtsPolarity(uint32 polarity);
N            void UART_1_BLE_UartSetRtsFifoLevel(uint32 level);
N        #endif /* !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1) */
N    #endif /* (UART_1_BLE_UART_RX_DIRECTION) */
N
N    /* UART TX direction APIs */
N    #if(UART_1_BLE_UART_TX_DIRECTION)
X    #if((0u != ((3u) & (2u))))
N        /*******************************************************************************
N        * Function Name: UART_1_BLE_UartPutChar
N        ****************************************************************************//**
N        *
N        *  Places a byte of data in the transmit buffer to be sent at the next available
N        *  bus time. This function is blocking and waits until there is a space
N        *  available to put requested data in the transmit buffer.
N        *  For UART Multi Processor mode this function can send 9-bits data as well.
N        *  Use UART_1_BLE_UART_MP_MARK to add a mark to create an address byte.
N        *
N        *  \param txDataByte: the data to be transmitted.
N        *
N        *******************************************************************************/
N        #define UART_1_BLE_UartPutChar(ch)    UART_1_BLE_SpiUartWriteTxData((uint32)(ch))
N
N        void UART_1_BLE_UartPutString(const char8 string[]);
N        void UART_1_BLE_UartPutCRLF(uint32 txDataByte);
N        void UART_1_BLE_UartSendBreakBlocking(uint32 breakWidth);
N
N        #if !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1)
X        #if !((2 == 0u) || (2 == 1u))
N            /* UART APIs for Flow Control */
N            void UART_1_BLE_UartEnableCts(void);
N            void UART_1_BLE_UartDisableCts(void);
N            void UART_1_BLE_UartSetCtsPolarity(uint32 polarity);
N        #endif /* !(UART_1_BLE_CY_SCBIP_V0 || UART_1_BLE_CY_SCBIP_V1) */
N    #endif /* (UART_1_BLE_UART_TX_DIRECTION) */
N#endif /* (UART_1_BLE_SCB_MODE_UART_INC) */
N/** @} uart */
N
N/**
N* \addtogroup group_spi_uart
N* @{
N*/
N#if(UART_1_BLE_RX_DIRECTION)
X#if(((((0x02u) == (4u))) ? (UART_1_BLE_SPI_RX_DIRECTION) : ((0u != ((3u) & (1u))))))
N    uint32 UART_1_BLE_SpiUartReadRxData(void);
N    uint32 UART_1_BLE_SpiUartGetRxBufferSize(void);
N    void   UART_1_BLE_SpiUartClearRxBuffer(void);
N#endif /* (UART_1_BLE_RX_DIRECTION) */
N
N/* Common APIs TX direction */
N#if(UART_1_BLE_TX_DIRECTION)
X#if(((((0x02u) == (4u))) ? (UART_1_BLE_SPI_TX_DIRECTION) : ((0u != ((3u) & (2u))))))
N    void   UART_1_BLE_SpiUartWriteTxData(uint32 txData);
N    void   UART_1_BLE_SpiUartPutArray(const uint8 wrBuf[], uint32 count);
N    uint32 UART_1_BLE_SpiUartGetTxBufferSize(void);
N    void   UART_1_BLE_SpiUartClearTxBuffer(void);
N#endif /* (UART_1_BLE_TX_DIRECTION) */
N/** @} spi_uart */
N
NCY_ISR_PROTO(UART_1_BLE_SPI_UART_ISR);
Xvoid UART_1_BLE_SPI_UART_ISR (void);
N
N#if(UART_1_BLE_UART_RX_WAKEUP_IRQ)
X#if((0u == (1u)))
S    CY_ISR_PROTO(UART_1_BLE_UART_WAKEUP_ISR);
N#endif /* (UART_1_BLE_UART_RX_WAKEUP_IRQ) */
N
N
N/***************************************
N*     Buffer Access Macro Definitions
N***************************************/
N
N#if(UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    /* RX direction */
S    void   UART_1_BLE_PutWordInRxBuffer  (uint32 idx, uint32 rxDataByte);
S    uint32 UART_1_BLE_GetWordFromRxBuffer(uint32 idx);
S
S    /* TX direction */
S    void   UART_1_BLE_PutWordInTxBuffer  (uint32 idx, uint32 txDataByte);
S    uint32 UART_1_BLE_GetWordFromTxBuffer(uint32 idx);
S
N#else
N    /* RX direction */
N    #if(UART_1_BLE_INTERNAL_RX_SW_BUFFER_CONST)
X    #if(((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u)))))))
S        #define UART_1_BLE_PutWordInRxBuffer(idx, rxDataByte) \
S                do{                                                 \
S                    UART_1_BLE_rxBufferInternal[(idx)] = ((uint8) (rxDataByte)); \
S                }while(0)
X        #define UART_1_BLE_PutWordInRxBuffer(idx, rxDataByte)                 do{                                                                     UART_1_BLE_rxBufferInternal[(idx)] = ((uint8) (rxDataByte));                 }while(0)
S
S        #define UART_1_BLE_GetWordFromRxBuffer(idx) UART_1_BLE_rxBufferInternal[(idx)]
S
N    #endif /* (UART_1_BLE_INTERNAL_RX_SW_BUFFER_CONST) */
N
N    /* TX direction */
N    #if(UART_1_BLE_INTERNAL_TX_SW_BUFFER_CONST)
X    #if(((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u)))))))
S        #define UART_1_BLE_PutWordInTxBuffer(idx, txDataByte) \
S                    do{                                             \
S                        UART_1_BLE_txBufferInternal[(idx)] = ((uint8) (txDataByte)); \
S                    }while(0)
X        #define UART_1_BLE_PutWordInTxBuffer(idx, txDataByte)                     do{                                                                     UART_1_BLE_txBufferInternal[(idx)] = ((uint8) (txDataByte));                     }while(0)
S
S        #define UART_1_BLE_GetWordFromTxBuffer(idx) UART_1_BLE_txBufferInternal[(idx)]
S
N    #endif /* (UART_1_BLE_INTERNAL_TX_SW_BUFFER_CONST) */
N
N#endif /* (UART_1_BLE_TX_SW_BUFFER_ENABLE) */
N
N
N/***************************************
N*         SPI API Constants
N***************************************/
N
N/* SPI sub mode enum */
N#define UART_1_BLE_SPI_MODE_MOTOROLA      (0x00u)
N#define UART_1_BLE_SPI_MODE_TI_COINCIDES  (0x01u)
N#define UART_1_BLE_SPI_MODE_TI_PRECEDES   (0x11u)
N#define UART_1_BLE_SPI_MODE_NATIONAL      (0x02u)
N#define UART_1_BLE_SPI_MODE_MASK          (0x03u)
N#define UART_1_BLE_SPI_MODE_TI_PRECEDES_MASK  (0x10u)
N#define UART_1_BLE_SPI_MODE_NS_MICROWIRE  (UART_1_BLE_SPI_MODE_NATIONAL)
N
N/* SPI phase and polarity mode enum */
N#define UART_1_BLE_SPI_SCLK_CPHA0_CPOL0   (0x00u)
N#define UART_1_BLE_SPI_SCLK_CPHA0_CPOL1   (0x02u)
N#define UART_1_BLE_SPI_SCLK_CPHA1_CPOL0   (0x01u)
N#define UART_1_BLE_SPI_SCLK_CPHA1_CPOL1   (0x03u)
N
N/* SPI bits order enum */
N#define UART_1_BLE_BITS_ORDER_LSB_FIRST   (0u)
N#define UART_1_BLE_BITS_ORDER_MSB_FIRST   (1u)
N
N/* SPI transfer separation enum */
N#define UART_1_BLE_SPI_TRANSFER_SEPARATED     (0u)
N#define UART_1_BLE_SPI_TRANSFER_CONTINUOUS    (1u)
N
N/* SPI slave select constants */
N#define UART_1_BLE_SPI_SLAVE_SELECT0    (UART_1_BLE_SCB__SS0_POSISTION)
N#define UART_1_BLE_SPI_SLAVE_SELECT1    (UART_1_BLE_SCB__SS1_POSISTION)
N#define UART_1_BLE_SPI_SLAVE_SELECT2    (UART_1_BLE_SCB__SS2_POSISTION)
N#define UART_1_BLE_SPI_SLAVE_SELECT3    (UART_1_BLE_SCB__SS3_POSISTION)
N
N/* SPI slave select polarity settings */
N#define UART_1_BLE_SPI_SS_ACTIVE_LOW  (0u)
N#define UART_1_BLE_SPI_SS_ACTIVE_HIGH (1u)
N
N#define UART_1_BLE_INTR_SPIM_TX_RESTORE   (UART_1_BLE_INTR_TX_OVERFLOW)
N
N#define UART_1_BLE_INTR_SPIS_TX_RESTORE     (UART_1_BLE_INTR_TX_OVERFLOW | \
N                                                 UART_1_BLE_INTR_TX_UNDERFLOW)
X#define UART_1_BLE_INTR_SPIS_TX_RESTORE     (UART_1_BLE_INTR_TX_OVERFLOW |                                                  UART_1_BLE_INTR_TX_UNDERFLOW)
N
N/***************************************
N*         UART API Constants
N***************************************/
N
N/* UART sub-modes enum */
N#define UART_1_BLE_UART_MODE_STD          (0u)
N#define UART_1_BLE_UART_MODE_SMARTCARD    (1u)
N#define UART_1_BLE_UART_MODE_IRDA         (2u)
N
N/* UART direction enum */
N#define UART_1_BLE_UART_RX    (1u)
N#define UART_1_BLE_UART_TX    (2u)
N#define UART_1_BLE_UART_TX_RX (3u)
N
N/* UART parity enum */
N#define UART_1_BLE_UART_PARITY_EVEN   (0u)
N#define UART_1_BLE_UART_PARITY_ODD    (1u)
N#define UART_1_BLE_UART_PARITY_NONE   (2u)
N
N/* UART stop bits enum */
N#define UART_1_BLE_UART_STOP_BITS_1   (2u)
N#define UART_1_BLE_UART_STOP_BITS_1_5 (3u)
N#define UART_1_BLE_UART_STOP_BITS_2   (4u)
N
N/* UART IrDA low power OVS enum */
N#define UART_1_BLE_UART_IRDA_LP_OVS16     (16u)
N#define UART_1_BLE_UART_IRDA_LP_OVS32     (32u)
N#define UART_1_BLE_UART_IRDA_LP_OVS48     (48u)
N#define UART_1_BLE_UART_IRDA_LP_OVS96     (96u)
N#define UART_1_BLE_UART_IRDA_LP_OVS192    (192u)
N#define UART_1_BLE_UART_IRDA_LP_OVS768    (768u)
N#define UART_1_BLE_UART_IRDA_LP_OVS1536   (1536u)
N
N/* Uart MP: mark (address) and space (data) bit definitions */
N#define UART_1_BLE_UART_MP_MARK       (0x100u)
N#define UART_1_BLE_UART_MP_SPACE      (0x000u)
N
N/* UART CTS/RTS polarity settings */
N#define UART_1_BLE_UART_CTS_ACTIVE_LOW    (0u)
N#define UART_1_BLE_UART_CTS_ACTIVE_HIGH   (1u)
N#define UART_1_BLE_UART_RTS_ACTIVE_LOW    (0u)
N#define UART_1_BLE_UART_RTS_ACTIVE_HIGH   (1u)
N
N/* Sources of RX errors */
N#define UART_1_BLE_INTR_RX_ERR        (UART_1_BLE_INTR_RX_OVERFLOW    | \
N                                             UART_1_BLE_INTR_RX_UNDERFLOW   | \
N                                             UART_1_BLE_INTR_RX_FRAME_ERROR | \
N                                             UART_1_BLE_INTR_RX_PARITY_ERROR)
X#define UART_1_BLE_INTR_RX_ERR        (UART_1_BLE_INTR_RX_OVERFLOW    |                                              UART_1_BLE_INTR_RX_UNDERFLOW   |                                              UART_1_BLE_INTR_RX_FRAME_ERROR |                                              UART_1_BLE_INTR_RX_PARITY_ERROR)
N
N/* Shifted INTR_RX_ERR defines ONLY for UART_1_BLE_UartGetByte() */
N#define UART_1_BLE_UART_RX_OVERFLOW       (UART_1_BLE_INTR_RX_OVERFLOW << 8u)
N#define UART_1_BLE_UART_RX_UNDERFLOW      (UART_1_BLE_INTR_RX_UNDERFLOW << 8u)
N#define UART_1_BLE_UART_RX_FRAME_ERROR    (UART_1_BLE_INTR_RX_FRAME_ERROR << 8u)
N#define UART_1_BLE_UART_RX_PARITY_ERROR   (UART_1_BLE_INTR_RX_PARITY_ERROR << 8u)
N#define UART_1_BLE_UART_RX_ERROR_MASK     (UART_1_BLE_UART_RX_OVERFLOW    | \
N                                                 UART_1_BLE_UART_RX_UNDERFLOW   | \
N                                                 UART_1_BLE_UART_RX_FRAME_ERROR | \
N                                                 UART_1_BLE_UART_RX_PARITY_ERROR)
X#define UART_1_BLE_UART_RX_ERROR_MASK     (UART_1_BLE_UART_RX_OVERFLOW    |                                                  UART_1_BLE_UART_RX_UNDERFLOW   |                                                  UART_1_BLE_UART_RX_FRAME_ERROR |                                                  UART_1_BLE_UART_RX_PARITY_ERROR)
N
N#define UART_1_BLE_INTR_UART_TX_RESTORE   (UART_1_BLE_INTR_TX_OVERFLOW  | \
N                                                 UART_1_BLE_INTR_TX_UART_NACK | \
N                                                 UART_1_BLE_INTR_TX_UART_DONE | \
N                                                 UART_1_BLE_INTR_TX_UART_ARB_LOST)
X#define UART_1_BLE_INTR_UART_TX_RESTORE   (UART_1_BLE_INTR_TX_OVERFLOW  |                                                  UART_1_BLE_INTR_TX_UART_NACK |                                                  UART_1_BLE_INTR_TX_UART_DONE |                                                  UART_1_BLE_INTR_TX_UART_ARB_LOST)
N
N
N/***************************************
N*     Vars with External Linkage
N***************************************/
N
N#if(UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    extern const UART_1_BLE_SPI_INIT_STRUCT  UART_1_BLE_configSpi;
S    extern const UART_1_BLE_UART_INIT_STRUCT UART_1_BLE_configUart;
N#endif /* (UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N#if (UART_1_BLE_UART_WAKE_ENABLE_CONST && UART_1_BLE_UART_RX_WAKEUP_IRQ)
X#if ((0u != (0u)) && (0u == (1u)))
S    extern uint8 UART_1_BLE_skipStart;
N#endif /* (UART_1_BLE_UART_WAKE_ENABLE_CONST && UART_1_BLE_UART_RX_WAKEUP_IRQ) */
N
N
N/***************************************
N*    Specific SPI Macro Definitions
N***************************************/
N
N#define UART_1_BLE_GET_SPI_INTR_SLAVE_MASK(sourceMask)  ((sourceMask) & UART_1_BLE_INTR_SLAVE_SPI_BUS_ERROR)
N#define UART_1_BLE_GET_SPI_INTR_MASTER_MASK(sourceMask) ((sourceMask) & UART_1_BLE_INTR_MASTER_SPI_DONE)
N#define UART_1_BLE_GET_SPI_INTR_RX_MASK(sourceMask) \
N                                             ((sourceMask) & (uint32) ~UART_1_BLE_INTR_SLAVE_SPI_BUS_ERROR)
X#define UART_1_BLE_GET_SPI_INTR_RX_MASK(sourceMask)                                              ((sourceMask) & (uint32) ~UART_1_BLE_INTR_SLAVE_SPI_BUS_ERROR)
N
N#define UART_1_BLE_GET_SPI_INTR_TX_MASK(sourceMask) \
N                                             ((sourceMask) & (uint32) ~UART_1_BLE_INTR_MASTER_SPI_DONE)
X#define UART_1_BLE_GET_SPI_INTR_TX_MASK(sourceMask)                                              ((sourceMask) & (uint32) ~UART_1_BLE_INTR_MASTER_SPI_DONE)
N
N
N/***************************************
N*    Specific UART Macro Definitions
N***************************************/
N
N#define UART_1_BLE_UART_GET_CTRL_OVS_IRDA_LP(oversample) \
N        ((UART_1_BLE_UART_IRDA_LP_OVS16   == (oversample)) ? UART_1_BLE_CTRL_OVS_IRDA_LP_OVS16 : \
N         ((UART_1_BLE_UART_IRDA_LP_OVS32   == (oversample)) ? UART_1_BLE_CTRL_OVS_IRDA_LP_OVS32 : \
N          ((UART_1_BLE_UART_IRDA_LP_OVS48   == (oversample)) ? UART_1_BLE_CTRL_OVS_IRDA_LP_OVS48 : \
N           ((UART_1_BLE_UART_IRDA_LP_OVS96   == (oversample)) ? UART_1_BLE_CTRL_OVS_IRDA_LP_OVS96 : \
N            ((UART_1_BLE_UART_IRDA_LP_OVS192  == (oversample)) ? UART_1_BLE_CTRL_OVS_IRDA_LP_OVS192 : \
N             ((UART_1_BLE_UART_IRDA_LP_OVS768  == (oversample)) ? UART_1_BLE_CTRL_OVS_IRDA_LP_OVS768 : \
N              ((UART_1_BLE_UART_IRDA_LP_OVS1536 == (oversample)) ? UART_1_BLE_CTRL_OVS_IRDA_LP_OVS1536 : \
N                                                                          UART_1_BLE_CTRL_OVS_IRDA_LP_OVS16)))))))
X#define UART_1_BLE_UART_GET_CTRL_OVS_IRDA_LP(oversample)         ((UART_1_BLE_UART_IRDA_LP_OVS16   == (oversample)) ? UART_1_BLE_CTRL_OVS_IRDA_LP_OVS16 :          ((UART_1_BLE_UART_IRDA_LP_OVS32   == (oversample)) ? UART_1_BLE_CTRL_OVS_IRDA_LP_OVS32 :           ((UART_1_BLE_UART_IRDA_LP_OVS48   == (oversample)) ? UART_1_BLE_CTRL_OVS_IRDA_LP_OVS48 :            ((UART_1_BLE_UART_IRDA_LP_OVS96   == (oversample)) ? UART_1_BLE_CTRL_OVS_IRDA_LP_OVS96 :             ((UART_1_BLE_UART_IRDA_LP_OVS192  == (oversample)) ? UART_1_BLE_CTRL_OVS_IRDA_LP_OVS192 :              ((UART_1_BLE_UART_IRDA_LP_OVS768  == (oversample)) ? UART_1_BLE_CTRL_OVS_IRDA_LP_OVS768 :               ((UART_1_BLE_UART_IRDA_LP_OVS1536 == (oversample)) ? UART_1_BLE_CTRL_OVS_IRDA_LP_OVS1536 :                                                                           UART_1_BLE_CTRL_OVS_IRDA_LP_OVS16)))))))
N
N#define UART_1_BLE_GET_UART_RX_CTRL_ENABLED(direction) ((0u != (UART_1_BLE_UART_RX & (direction))) ? \
N                                                                     (UART_1_BLE_RX_CTRL_ENABLED) : (0u))
X#define UART_1_BLE_GET_UART_RX_CTRL_ENABLED(direction) ((0u != (UART_1_BLE_UART_RX & (direction))) ?                                                                      (UART_1_BLE_RX_CTRL_ENABLED) : (0u))
N
N#define UART_1_BLE_GET_UART_TX_CTRL_ENABLED(direction) ((0u != (UART_1_BLE_UART_TX & (direction))) ? \
N                                                                     (UART_1_BLE_TX_CTRL_ENABLED) : (0u))
X#define UART_1_BLE_GET_UART_TX_CTRL_ENABLED(direction) ((0u != (UART_1_BLE_UART_TX & (direction))) ?                                                                      (UART_1_BLE_TX_CTRL_ENABLED) : (0u))
N
N
N/***************************************
N*        SPI Register Settings
N***************************************/
N
N#define UART_1_BLE_CTRL_SPI      (UART_1_BLE_CTRL_MODE_SPI)
N#define UART_1_BLE_SPI_RX_CTRL   (UART_1_BLE_RX_CTRL_ENABLED)
N#define UART_1_BLE_SPI_TX_CTRL   (UART_1_BLE_TX_CTRL_ENABLED)
N
N
N/***************************************
N*       SPI Init Register Settings
N***************************************/
N
N#define UART_1_BLE_SPI_SS_POLARITY \
N             (((uint32) UART_1_BLE_SPI_SS0_POLARITY << UART_1_BLE_SPI_SLAVE_SELECT0) | \
N              ((uint32) UART_1_BLE_SPI_SS1_POLARITY << UART_1_BLE_SPI_SLAVE_SELECT1) | \
N              ((uint32) UART_1_BLE_SPI_SS2_POLARITY << UART_1_BLE_SPI_SLAVE_SELECT2) | \
N              ((uint32) UART_1_BLE_SPI_SS3_POLARITY << UART_1_BLE_SPI_SLAVE_SELECT3))
X#define UART_1_BLE_SPI_SS_POLARITY              (((uint32) UART_1_BLE_SPI_SS0_POLARITY << UART_1_BLE_SPI_SLAVE_SELECT0) |               ((uint32) UART_1_BLE_SPI_SS1_POLARITY << UART_1_BLE_SPI_SLAVE_SELECT1) |               ((uint32) UART_1_BLE_SPI_SS2_POLARITY << UART_1_BLE_SPI_SLAVE_SELECT2) |               ((uint32) UART_1_BLE_SPI_SS3_POLARITY << UART_1_BLE_SPI_SLAVE_SELECT3))
N
N#if(UART_1_BLE_SCB_MODE_SPI_CONST_CFG)
X#if(((0x02u) == (4u)))
S
S    /* SPI Configuration */
S    #define UART_1_BLE_SPI_DEFAULT_CTRL \
S                    (UART_1_BLE_GET_CTRL_OVS(UART_1_BLE_SPI_OVS_FACTOR) | \
S                     UART_1_BLE_GET_CTRL_BYTE_MODE (UART_1_BLE_SPI_BYTE_MODE_ENABLE) | \
S                     UART_1_BLE_GET_CTRL_EC_AM_MODE(UART_1_BLE_SPI_WAKE_ENABLE)      | \
S                     UART_1_BLE_CTRL_SPI)
X    #define UART_1_BLE_SPI_DEFAULT_CTRL                     (UART_1_BLE_GET_CTRL_OVS(UART_1_BLE_SPI_OVS_FACTOR) |                      UART_1_BLE_GET_CTRL_BYTE_MODE (UART_1_BLE_SPI_BYTE_MODE_ENABLE) |                      UART_1_BLE_GET_CTRL_EC_AM_MODE(UART_1_BLE_SPI_WAKE_ENABLE)      |                      UART_1_BLE_CTRL_SPI)
S
S    #define UART_1_BLE_SPI_DEFAULT_SPI_CTRL \
S                    (UART_1_BLE_GET_SPI_CTRL_CONTINUOUS    (UART_1_BLE_SPI_TRANSFER_SEPARATION)       | \
S                     UART_1_BLE_GET_SPI_CTRL_SELECT_PRECEDE(UART_1_BLE_SPI_SUB_MODE &                   \
S                                                                  UART_1_BLE_SPI_MODE_TI_PRECEDES_MASK)     | \
S                     UART_1_BLE_GET_SPI_CTRL_SCLK_MODE     (UART_1_BLE_SPI_CLOCK_MODE)                | \
S                     UART_1_BLE_GET_SPI_CTRL_LATE_MISO_SAMPLE(UART_1_BLE_SPI_LATE_MISO_SAMPLE_ENABLE) | \
S                     UART_1_BLE_GET_SPI_CTRL_SCLK_CONTINUOUS(UART_1_BLE_SPI_FREE_RUN_SCLK_ENABLE)     | \
S                     UART_1_BLE_GET_SPI_CTRL_SSEL_POLARITY (UART_1_BLE_SPI_SS_POLARITY)               | \
S                     UART_1_BLE_GET_SPI_CTRL_SUB_MODE      (UART_1_BLE_SPI_SUB_MODE)                  | \
S                     UART_1_BLE_GET_SPI_CTRL_MASTER_MODE   (UART_1_BLE_SPI_MODE))
X    #define UART_1_BLE_SPI_DEFAULT_SPI_CTRL                     (UART_1_BLE_GET_SPI_CTRL_CONTINUOUS    (UART_1_BLE_SPI_TRANSFER_SEPARATION)       |                      UART_1_BLE_GET_SPI_CTRL_SELECT_PRECEDE(UART_1_BLE_SPI_SUB_MODE &                                                                                     UART_1_BLE_SPI_MODE_TI_PRECEDES_MASK)     |                      UART_1_BLE_GET_SPI_CTRL_SCLK_MODE     (UART_1_BLE_SPI_CLOCK_MODE)                |                      UART_1_BLE_GET_SPI_CTRL_LATE_MISO_SAMPLE(UART_1_BLE_SPI_LATE_MISO_SAMPLE_ENABLE) |                      UART_1_BLE_GET_SPI_CTRL_SCLK_CONTINUOUS(UART_1_BLE_SPI_FREE_RUN_SCLK_ENABLE)     |                      UART_1_BLE_GET_SPI_CTRL_SSEL_POLARITY (UART_1_BLE_SPI_SS_POLARITY)               |                      UART_1_BLE_GET_SPI_CTRL_SUB_MODE      (UART_1_BLE_SPI_SUB_MODE)                  |                      UART_1_BLE_GET_SPI_CTRL_MASTER_MODE   (UART_1_BLE_SPI_MODE))
S
S    /* RX direction */
S    #define UART_1_BLE_SPI_DEFAULT_RX_CTRL \
S                    (UART_1_BLE_GET_RX_CTRL_DATA_WIDTH(UART_1_BLE_SPI_RX_DATA_BITS_NUM)     | \
S                     UART_1_BLE_GET_RX_CTRL_BIT_ORDER (UART_1_BLE_SPI_BITS_ORDER)           | \
S                     UART_1_BLE_GET_RX_CTRL_MEDIAN    (UART_1_BLE_SPI_MEDIAN_FILTER_ENABLE) | \
S                     UART_1_BLE_SPI_RX_CTRL)
X    #define UART_1_BLE_SPI_DEFAULT_RX_CTRL                     (UART_1_BLE_GET_RX_CTRL_DATA_WIDTH(UART_1_BLE_SPI_RX_DATA_BITS_NUM)     |                      UART_1_BLE_GET_RX_CTRL_BIT_ORDER (UART_1_BLE_SPI_BITS_ORDER)           |                      UART_1_BLE_GET_RX_CTRL_MEDIAN    (UART_1_BLE_SPI_MEDIAN_FILTER_ENABLE) |                      UART_1_BLE_SPI_RX_CTRL)
S
S    #define UART_1_BLE_SPI_DEFAULT_RX_FIFO_CTRL \
S                    UART_1_BLE_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(UART_1_BLE_SPI_RX_TRIGGER_LEVEL)
X    #define UART_1_BLE_SPI_DEFAULT_RX_FIFO_CTRL                     UART_1_BLE_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(UART_1_BLE_SPI_RX_TRIGGER_LEVEL)
S
S    /* TX direction */
S    #define UART_1_BLE_SPI_DEFAULT_TX_CTRL \
S                    (UART_1_BLE_GET_TX_CTRL_DATA_WIDTH(UART_1_BLE_SPI_TX_DATA_BITS_NUM) | \
S                     UART_1_BLE_GET_TX_CTRL_BIT_ORDER (UART_1_BLE_SPI_BITS_ORDER)       | \
S                     UART_1_BLE_SPI_TX_CTRL)
X    #define UART_1_BLE_SPI_DEFAULT_TX_CTRL                     (UART_1_BLE_GET_TX_CTRL_DATA_WIDTH(UART_1_BLE_SPI_TX_DATA_BITS_NUM) |                      UART_1_BLE_GET_TX_CTRL_BIT_ORDER (UART_1_BLE_SPI_BITS_ORDER)       |                      UART_1_BLE_SPI_TX_CTRL)
S
S    #define UART_1_BLE_SPI_DEFAULT_TX_FIFO_CTRL \
S                    UART_1_BLE_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(UART_1_BLE_SPI_TX_TRIGGER_LEVEL)
X    #define UART_1_BLE_SPI_DEFAULT_TX_FIFO_CTRL                     UART_1_BLE_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(UART_1_BLE_SPI_TX_TRIGGER_LEVEL)
S
S    /* Interrupt sources */
S    #define UART_1_BLE_SPI_DEFAULT_INTR_SPI_EC_MASK   (UART_1_BLE_NO_INTR_SOURCES)
S
S    #define UART_1_BLE_SPI_DEFAULT_INTR_I2C_EC_MASK   (UART_1_BLE_NO_INTR_SOURCES)
S    #define UART_1_BLE_SPI_DEFAULT_INTR_SLAVE_MASK \
S                    (UART_1_BLE_SPI_INTR_RX_MASK & UART_1_BLE_INTR_SLAVE_SPI_BUS_ERROR)
X    #define UART_1_BLE_SPI_DEFAULT_INTR_SLAVE_MASK                     (UART_1_BLE_SPI_INTR_RX_MASK & UART_1_BLE_INTR_SLAVE_SPI_BUS_ERROR)
S
S    #define UART_1_BLE_SPI_DEFAULT_INTR_MASTER_MASK \
S                    (UART_1_BLE_SPI_INTR_TX_MASK & UART_1_BLE_INTR_MASTER_SPI_DONE)
X    #define UART_1_BLE_SPI_DEFAULT_INTR_MASTER_MASK                     (UART_1_BLE_SPI_INTR_TX_MASK & UART_1_BLE_INTR_MASTER_SPI_DONE)
S
S    #define UART_1_BLE_SPI_DEFAULT_INTR_RX_MASK \
S                    (UART_1_BLE_SPI_INTR_RX_MASK & (uint32) ~UART_1_BLE_INTR_SLAVE_SPI_BUS_ERROR)
X    #define UART_1_BLE_SPI_DEFAULT_INTR_RX_MASK                     (UART_1_BLE_SPI_INTR_RX_MASK & (uint32) ~UART_1_BLE_INTR_SLAVE_SPI_BUS_ERROR)
S
S    #define UART_1_BLE_SPI_DEFAULT_INTR_TX_MASK \
S                    (UART_1_BLE_SPI_INTR_TX_MASK & (uint32) ~UART_1_BLE_INTR_MASTER_SPI_DONE)
X    #define UART_1_BLE_SPI_DEFAULT_INTR_TX_MASK                     (UART_1_BLE_SPI_INTR_TX_MASK & (uint32) ~UART_1_BLE_INTR_MASTER_SPI_DONE)
S
N#endif /* (UART_1_BLE_SCB_MODE_SPI_CONST_CFG) */
N
N
N/***************************************
N*        UART Register Settings
N***************************************/
N
N#define UART_1_BLE_CTRL_UART      (UART_1_BLE_CTRL_MODE_UART)
N#define UART_1_BLE_UART_RX_CTRL   (UART_1_BLE_RX_CTRL_LSB_FIRST) /* LSB for UART goes first */
N#define UART_1_BLE_UART_TX_CTRL   (UART_1_BLE_TX_CTRL_LSB_FIRST) /* LSB for UART goes first */
N
N
N/***************************************
N*      UART Init Register Settings
N***************************************/
N
N#if(UART_1_BLE_SCB_MODE_UART_CONST_CFG)
X#if(((0x04u) == (4u)))
N
N    /* UART configuration */
N    #if(UART_1_BLE_UART_MODE_IRDA == UART_1_BLE_UART_SUB_MODE)
X    #if((2u) == (0u))
S
S        #define UART_1_BLE_DEFAULT_CTRL_OVS   ((0u != UART_1_BLE_UART_IRDA_LOW_POWER) ?              \
S                                (UART_1_BLE_UART_GET_CTRL_OVS_IRDA_LP(UART_1_BLE_UART_OVS_FACTOR)) : \
S                                (UART_1_BLE_CTRL_OVS_IRDA_OVS16))
X        #define UART_1_BLE_DEFAULT_CTRL_OVS   ((0u != UART_1_BLE_UART_IRDA_LOW_POWER) ?                                              (UART_1_BLE_UART_GET_CTRL_OVS_IRDA_LP(UART_1_BLE_UART_OVS_FACTOR)) :                                 (UART_1_BLE_CTRL_OVS_IRDA_OVS16))
S
N    #else
N
N        #define UART_1_BLE_DEFAULT_CTRL_OVS   UART_1_BLE_GET_CTRL_OVS(UART_1_BLE_UART_OVS_FACTOR)
N
N    #endif /* (UART_1_BLE_UART_MODE_IRDA == UART_1_BLE_UART_SUB_MODE) */
N
N    #define UART_1_BLE_UART_DEFAULT_CTRL \
N                                (UART_1_BLE_GET_CTRL_BYTE_MODE  (UART_1_BLE_UART_BYTE_MODE_ENABLE)  | \
N                                 UART_1_BLE_GET_CTRL_ADDR_ACCEPT(UART_1_BLE_UART_MP_ACCEPT_ADDRESS) | \
N                                 UART_1_BLE_DEFAULT_CTRL_OVS                                              | \
N                                 UART_1_BLE_CTRL_UART)
X    #define UART_1_BLE_UART_DEFAULT_CTRL                                 (UART_1_BLE_GET_CTRL_BYTE_MODE  (UART_1_BLE_UART_BYTE_MODE_ENABLE)  |                                  UART_1_BLE_GET_CTRL_ADDR_ACCEPT(UART_1_BLE_UART_MP_ACCEPT_ADDRESS) |                                  UART_1_BLE_DEFAULT_CTRL_OVS                                              |                                  UART_1_BLE_CTRL_UART)
N
N    #define UART_1_BLE_UART_DEFAULT_UART_CTRL \
N                                    (UART_1_BLE_GET_UART_CTRL_MODE(UART_1_BLE_UART_SUB_MODE))
X    #define UART_1_BLE_UART_DEFAULT_UART_CTRL                                     (UART_1_BLE_GET_UART_CTRL_MODE(UART_1_BLE_UART_SUB_MODE))
N
N    /* RX direction */
N    #define UART_1_BLE_UART_DEFAULT_RX_CTRL_PARITY \
N                                ((UART_1_BLE_UART_PARITY_NONE != UART_1_BLE_UART_PARITY_TYPE) ?      \
N                                  (UART_1_BLE_GET_UART_RX_CTRL_PARITY(UART_1_BLE_UART_PARITY_TYPE) | \
N                                   UART_1_BLE_UART_RX_CTRL_PARITY_ENABLED) : (0u))
X    #define UART_1_BLE_UART_DEFAULT_RX_CTRL_PARITY                                 ((UART_1_BLE_UART_PARITY_NONE != UART_1_BLE_UART_PARITY_TYPE) ?                                        (UART_1_BLE_GET_UART_RX_CTRL_PARITY(UART_1_BLE_UART_PARITY_TYPE) |                                    UART_1_BLE_UART_RX_CTRL_PARITY_ENABLED) : (0u))
N
N    #define UART_1_BLE_UART_DEFAULT_UART_RX_CTRL \
N                    (UART_1_BLE_GET_UART_RX_CTRL_MODE(UART_1_BLE_UART_STOP_BITS_NUM)                    | \
N                     UART_1_BLE_GET_UART_RX_CTRL_POLARITY(UART_1_BLE_UART_IRDA_POLARITY)                | \
N                     UART_1_BLE_GET_UART_RX_CTRL_MP_MODE(UART_1_BLE_UART_MP_MODE_ENABLE)                | \
N                     UART_1_BLE_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(UART_1_BLE_UART_DROP_ON_PARITY_ERR) | \
N                     UART_1_BLE_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(UART_1_BLE_UART_DROP_ON_FRAME_ERR)   | \
N                     UART_1_BLE_GET_UART_RX_CTRL_BREAK_WIDTH(UART_1_BLE_UART_RX_BREAK_WIDTH)            | \
N                     UART_1_BLE_UART_DEFAULT_RX_CTRL_PARITY)
X    #define UART_1_BLE_UART_DEFAULT_UART_RX_CTRL                     (UART_1_BLE_GET_UART_RX_CTRL_MODE(UART_1_BLE_UART_STOP_BITS_NUM)                    |                      UART_1_BLE_GET_UART_RX_CTRL_POLARITY(UART_1_BLE_UART_IRDA_POLARITY)                |                      UART_1_BLE_GET_UART_RX_CTRL_MP_MODE(UART_1_BLE_UART_MP_MODE_ENABLE)                |                      UART_1_BLE_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(UART_1_BLE_UART_DROP_ON_PARITY_ERR) |                      UART_1_BLE_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(UART_1_BLE_UART_DROP_ON_FRAME_ERR)   |                      UART_1_BLE_GET_UART_RX_CTRL_BREAK_WIDTH(UART_1_BLE_UART_RX_BREAK_WIDTH)            |                      UART_1_BLE_UART_DEFAULT_RX_CTRL_PARITY)
N
N
N    #define UART_1_BLE_UART_DEFAULT_RX_CTRL \
N                                (UART_1_BLE_GET_RX_CTRL_DATA_WIDTH(UART_1_BLE_UART_DATA_BITS_NUM)        | \
N                                 UART_1_BLE_GET_RX_CTRL_MEDIAN    (UART_1_BLE_UART_MEDIAN_FILTER_ENABLE) | \
N                                 UART_1_BLE_GET_UART_RX_CTRL_ENABLED(UART_1_BLE_UART_DIRECTION))
X    #define UART_1_BLE_UART_DEFAULT_RX_CTRL                                 (UART_1_BLE_GET_RX_CTRL_DATA_WIDTH(UART_1_BLE_UART_DATA_BITS_NUM)        |                                  UART_1_BLE_GET_RX_CTRL_MEDIAN    (UART_1_BLE_UART_MEDIAN_FILTER_ENABLE) |                                  UART_1_BLE_GET_UART_RX_CTRL_ENABLED(UART_1_BLE_UART_DIRECTION))
N
N    #define UART_1_BLE_UART_DEFAULT_RX_FIFO_CTRL \
N                                UART_1_BLE_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(UART_1_BLE_UART_RX_TRIGGER_LEVEL)
X    #define UART_1_BLE_UART_DEFAULT_RX_FIFO_CTRL                                 UART_1_BLE_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(UART_1_BLE_UART_RX_TRIGGER_LEVEL)
N
N    #define UART_1_BLE_UART_DEFAULT_RX_MATCH_REG  ((0u != UART_1_BLE_UART_MP_MODE_ENABLE) ?          \
N                                (UART_1_BLE_GET_RX_MATCH_ADDR(UART_1_BLE_UART_MP_RX_ADDRESS) | \
N                                 UART_1_BLE_GET_RX_MATCH_MASK(UART_1_BLE_UART_MP_RX_ADDRESS_MASK)) : (0u))
X    #define UART_1_BLE_UART_DEFAULT_RX_MATCH_REG  ((0u != UART_1_BLE_UART_MP_MODE_ENABLE) ?                                          (UART_1_BLE_GET_RX_MATCH_ADDR(UART_1_BLE_UART_MP_RX_ADDRESS) |                                  UART_1_BLE_GET_RX_MATCH_MASK(UART_1_BLE_UART_MP_RX_ADDRESS_MASK)) : (0u))
N
N    /* TX direction */
N    #define UART_1_BLE_UART_DEFAULT_TX_CTRL_PARITY (UART_1_BLE_UART_DEFAULT_RX_CTRL_PARITY)
N
N    #define UART_1_BLE_UART_DEFAULT_UART_TX_CTRL \
N                                (UART_1_BLE_GET_UART_TX_CTRL_MODE(UART_1_BLE_UART_STOP_BITS_NUM)       | \
N                                 UART_1_BLE_GET_UART_TX_CTRL_RETRY_NACK(UART_1_BLE_UART_RETRY_ON_NACK) | \
N                                 UART_1_BLE_UART_DEFAULT_TX_CTRL_PARITY)
X    #define UART_1_BLE_UART_DEFAULT_UART_TX_CTRL                                 (UART_1_BLE_GET_UART_TX_CTRL_MODE(UART_1_BLE_UART_STOP_BITS_NUM)       |                                  UART_1_BLE_GET_UART_TX_CTRL_RETRY_NACK(UART_1_BLE_UART_RETRY_ON_NACK) |                                  UART_1_BLE_UART_DEFAULT_TX_CTRL_PARITY)
N
N    #define UART_1_BLE_UART_DEFAULT_TX_CTRL \
N                                (UART_1_BLE_GET_TX_CTRL_DATA_WIDTH(UART_1_BLE_UART_DATA_BITS_NUM) | \
N                                 UART_1_BLE_GET_UART_TX_CTRL_ENABLED(UART_1_BLE_UART_DIRECTION))
X    #define UART_1_BLE_UART_DEFAULT_TX_CTRL                                 (UART_1_BLE_GET_TX_CTRL_DATA_WIDTH(UART_1_BLE_UART_DATA_BITS_NUM) |                                  UART_1_BLE_GET_UART_TX_CTRL_ENABLED(UART_1_BLE_UART_DIRECTION))
N
N    #define UART_1_BLE_UART_DEFAULT_TX_FIFO_CTRL \
N                                UART_1_BLE_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(UART_1_BLE_UART_TX_TRIGGER_LEVEL)
X    #define UART_1_BLE_UART_DEFAULT_TX_FIFO_CTRL                                 UART_1_BLE_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(UART_1_BLE_UART_TX_TRIGGER_LEVEL)
N
N    #define UART_1_BLE_UART_DEFAULT_FLOW_CTRL \
N                        (UART_1_BLE_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(UART_1_BLE_UART_RTS_FIFO_LEVEL) | \
N                         UART_1_BLE_GET_UART_FLOW_CTRL_RTS_POLARITY (UART_1_BLE_UART_RTS_POLARITY)   | \
N                         UART_1_BLE_GET_UART_FLOW_CTRL_CTS_POLARITY (UART_1_BLE_UART_CTS_POLARITY)   | \
N                         UART_1_BLE_GET_UART_FLOW_CTRL_CTS_ENABLE   (UART_1_BLE_UART_CTS_ENABLE))
X    #define UART_1_BLE_UART_DEFAULT_FLOW_CTRL                         (UART_1_BLE_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(UART_1_BLE_UART_RTS_FIFO_LEVEL) |                          UART_1_BLE_GET_UART_FLOW_CTRL_RTS_POLARITY (UART_1_BLE_UART_RTS_POLARITY)   |                          UART_1_BLE_GET_UART_FLOW_CTRL_CTS_POLARITY (UART_1_BLE_UART_CTS_POLARITY)   |                          UART_1_BLE_GET_UART_FLOW_CTRL_CTS_ENABLE   (UART_1_BLE_UART_CTS_ENABLE))
N
N    /* Interrupt sources */
N    #define UART_1_BLE_UART_DEFAULT_INTR_I2C_EC_MASK  (UART_1_BLE_NO_INTR_SOURCES)
N    #define UART_1_BLE_UART_DEFAULT_INTR_SPI_EC_MASK  (UART_1_BLE_NO_INTR_SOURCES)
N    #define UART_1_BLE_UART_DEFAULT_INTR_SLAVE_MASK   (UART_1_BLE_NO_INTR_SOURCES)
N    #define UART_1_BLE_UART_DEFAULT_INTR_MASTER_MASK  (UART_1_BLE_NO_INTR_SOURCES)
N    #define UART_1_BLE_UART_DEFAULT_INTR_RX_MASK      (UART_1_BLE_UART_INTR_RX_MASK)
N    #define UART_1_BLE_UART_DEFAULT_INTR_TX_MASK      (UART_1_BLE_UART_INTR_TX_MASK)
N
N#endif /* (UART_1_BLE_SCB_MODE_UART_CONST_CFG) */
N
N
N/***************************************
N* The following code is DEPRECATED and
N* must not be used.
N***************************************/
N
N#define UART_1_BLE_SPIM_ACTIVE_SS0    (UART_1_BLE_SPI_SLAVE_SELECT0)
N#define UART_1_BLE_SPIM_ACTIVE_SS1    (UART_1_BLE_SPI_SLAVE_SELECT1)
N#define UART_1_BLE_SPIM_ACTIVE_SS2    (UART_1_BLE_SPI_SLAVE_SELECT2)
N#define UART_1_BLE_SPIM_ACTIVE_SS3    (UART_1_BLE_SPI_SLAVE_SELECT3)
N
N#endif /* CY_SCB_SPI_UART_UART_1_BLE_H */
N
N
N/* [] END OF FILE */
L 23 "Generated_Source\PSoC4\project.h" 2
N#include "UART_1_BLE_PINS.h"
N#include "UART_1_BLE_SPI_UART_PVT.h"
L 1 "Generated_Source\PSoC4\UART_1_BLE_SPI_UART_PVT.h" 1
N/***************************************************************************//**
N* \file UART_1_BLE_SPI_UART_PVT.h
N* \version 4.0
N*
N* \brief
N*  This private file provides constants and parameter values for the
N*  SCB Component in SPI and UART modes.
N*  Please do not use this file or its content in your project.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation. All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_SPI_UART_PVT_UART_1_BLE_H)
X#if !0L
N#define CY_SCB_SPI_UART_PVT_UART_1_BLE_H
N
N#include "UART_1_BLE_SPI_UART.h"
N
N
N/***************************************
N*     Internal Global Vars
N***************************************/
N
N#if (UART_1_BLE_INTERNAL_RX_SW_BUFFER_CONST)
X#if (((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u)))))))
S    extern volatile uint32  UART_1_BLE_rxBufferHead;
S    extern volatile uint32  UART_1_BLE_rxBufferTail;
S    
S    /**
S    * \addtogroup group_globals
S    * @{
S    */
S    
S    /** Sets when internal software receive buffer overflow
S     *  was occurred.
S    */  
S    extern volatile uint8   UART_1_BLE_rxBufferOverflow;
S    /** @} globals */
N#endif /* (UART_1_BLE_INTERNAL_RX_SW_BUFFER_CONST) */
N
N#if (UART_1_BLE_INTERNAL_TX_SW_BUFFER_CONST)
X#if (((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u)))))))
S    extern volatile uint32  UART_1_BLE_txBufferHead;
S    extern volatile uint32  UART_1_BLE_txBufferTail;
N#endif /* (UART_1_BLE_INTERNAL_TX_SW_BUFFER_CONST) */
N
N#if (UART_1_BLE_INTERNAL_RX_SW_BUFFER)
X#if ((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u))))))
S    extern volatile uint8 UART_1_BLE_rxBufferInternal[UART_1_BLE_INTERNAL_RX_BUFFER_SIZE];
N#endif /* (UART_1_BLE_INTERNAL_RX_SW_BUFFER) */
N
N#if (UART_1_BLE_INTERNAL_TX_SW_BUFFER)
X#if ((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u))))))
S    extern volatile uint8 UART_1_BLE_txBufferInternal[UART_1_BLE_TX_BUFFER_SIZE];
N#endif /* (UART_1_BLE_INTERNAL_TX_SW_BUFFER) */
N
N
N/***************************************
N*     Private Function Prototypes
N***************************************/
N
Nvoid UART_1_BLE_SpiPostEnable(void);
Nvoid UART_1_BLE_SpiStop(void);
N
N#if (UART_1_BLE_SCB_MODE_SPI_CONST_CFG)
X#if (((0x02u) == (4u)))
S    void UART_1_BLE_SpiInit(void);
N#endif /* (UART_1_BLE_SCB_MODE_SPI_CONST_CFG) */
N
N#if (UART_1_BLE_SPI_WAKE_ENABLE_CONST)
X#if ((0u))
S    void UART_1_BLE_SpiSaveConfig(void);
S    void UART_1_BLE_SpiRestoreConfig(void);
N#endif /* (UART_1_BLE_SPI_WAKE_ENABLE_CONST) */
N
Nvoid UART_1_BLE_UartPostEnable(void);
Nvoid UART_1_BLE_UartStop(void);
N
N#if (UART_1_BLE_SCB_MODE_UART_CONST_CFG)
X#if (((0x04u) == (4u)))
N    void UART_1_BLE_UartInit(void);
N#endif /* (UART_1_BLE_SCB_MODE_UART_CONST_CFG) */
N
N#if (UART_1_BLE_UART_WAKE_ENABLE_CONST)
X#if ((0u != (0u)))
S    void UART_1_BLE_UartSaveConfig(void);
S    void UART_1_BLE_UartRestoreConfig(void);
N#endif /* (UART_1_BLE_UART_WAKE_ENABLE_CONST) */
N
N
N/***************************************
N*         UART API Constants
N***************************************/
N
N/* UART RX and TX position to be used in UART_1_BLE_SetPins() */
N#define UART_1_BLE_UART_RX_PIN_ENABLE    (UART_1_BLE_UART_RX)
N#define UART_1_BLE_UART_TX_PIN_ENABLE    (UART_1_BLE_UART_TX)
N
N/* UART RTS and CTS position to be used in  UART_1_BLE_SetPins() */
N#define UART_1_BLE_UART_RTS_PIN_ENABLE    (0x10u)
N#define UART_1_BLE_UART_CTS_PIN_ENABLE    (0x20u)
N
N
N/***************************************
N* The following code is DEPRECATED and
N* must not be used.
N***************************************/
N
N/* Interrupt processing */
N#define UART_1_BLE_SpiUartEnableIntRx(intSourceMask)  UART_1_BLE_SetRxInterruptMode(intSourceMask)
N#define UART_1_BLE_SpiUartEnableIntTx(intSourceMask)  UART_1_BLE_SetTxInterruptMode(intSourceMask)
Nuint32  UART_1_BLE_SpiUartDisableIntRx(void);
Nuint32  UART_1_BLE_SpiUartDisableIntTx(void);
N
N
N#endif /* (CY_SCB_SPI_UART_PVT_UART_1_BLE_H) */
N
N
N/* [] END OF FILE */
L 25 "Generated_Source\PSoC4\project.h" 2
N#include "UART_1_BLE_PVT.h"
L 1 "Generated_Source\PSoC4\UART_1_BLE_PVT.h" 1
N/***************************************************************************//**
N* \file .h
N* \version 4.0
N*
N* \brief
N*  This private file provides constants and parameter values for the
N*  SCB Component.
N*  Please do not use this file or its content in your project.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation. All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_PVT_UART_1_BLE_H)
X#if !0L
N#define CY_SCB_PVT_UART_1_BLE_H
N
N#include "UART_1_BLE.h"
N
N
N/***************************************
N*     Private Function Prototypes
N***************************************/
N
N/* APIs to service INTR_I2C_EC register */
N#define UART_1_BLE_SetI2CExtClkInterruptMode(interruptMask) UART_1_BLE_WRITE_INTR_I2C_EC_MASK(interruptMask)
N#define UART_1_BLE_ClearI2CExtClkInterruptSource(interruptMask) UART_1_BLE_CLEAR_INTR_I2C_EC(interruptMask)
N#define UART_1_BLE_GetI2CExtClkInterruptSource()                (UART_1_BLE_INTR_I2C_EC_REG)
N#define UART_1_BLE_GetI2CExtClkInterruptMode()                  (UART_1_BLE_INTR_I2C_EC_MASK_REG)
N#define UART_1_BLE_GetI2CExtClkInterruptSourceMasked()          (UART_1_BLE_INTR_I2C_EC_MASKED_REG)
N
N#if (!UART_1_BLE_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    /* APIs to service INTR_SPI_EC register */
N    #define UART_1_BLE_SetSpiExtClkInterruptMode(interruptMask) \
N                                                                UART_1_BLE_WRITE_INTR_SPI_EC_MASK(interruptMask)
X    #define UART_1_BLE_SetSpiExtClkInterruptMode(interruptMask)                                                                 UART_1_BLE_WRITE_INTR_SPI_EC_MASK(interruptMask)
N    #define UART_1_BLE_ClearSpiExtClkInterruptSource(interruptMask) \
N                                                                UART_1_BLE_CLEAR_INTR_SPI_EC(interruptMask)
X    #define UART_1_BLE_ClearSpiExtClkInterruptSource(interruptMask)                                                                 UART_1_BLE_CLEAR_INTR_SPI_EC(interruptMask)
N    #define UART_1_BLE_GetExtSpiClkInterruptSource()                 (UART_1_BLE_INTR_SPI_EC_REG)
N    #define UART_1_BLE_GetExtSpiClkInterruptMode()                   (UART_1_BLE_INTR_SPI_EC_MASK_REG)
N    #define UART_1_BLE_GetExtSpiClkInterruptSourceMasked()           (UART_1_BLE_INTR_SPI_EC_MASKED_REG)
N#endif /* (!UART_1_BLE_CY_SCBIP_V1) */
N
N#if(UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    extern void UART_1_BLE_SetPins(uint32 mode, uint32 subMode, uint32 uartEnableMask);
N#endif /* (UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N
N/***************************************
N*     Vars with External Linkage
N***************************************/
N
N#if (UART_1_BLE_SCB_IRQ_INTERNAL)
X#if ((0u == (0u)))
N#if !defined (CY_REMOVE_UART_1_BLE_CUSTOM_INTR_HANDLER)
X#if !0L
N    extern cyisraddress UART_1_BLE_customIntrHandler;
N#endif /* !defined (CY_REMOVE_UART_1_BLE_CUSTOM_INTR_HANDLER) */
N#endif /* (UART_1_BLE_SCB_IRQ_INTERNAL) */
N
Nextern UART_1_BLE_BACKUP_STRUCT UART_1_BLE_backup;
N
N#if(UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    /* Common configuration variables */
S    extern uint8 UART_1_BLE_scbMode;
S    extern uint8 UART_1_BLE_scbEnableWake;
S    extern uint8 UART_1_BLE_scbEnableIntr;
S
S    /* I2C configuration variables */
S    extern uint8 UART_1_BLE_mode;
S    extern uint8 UART_1_BLE_acceptAddr;
S
S    /* SPI/UART configuration variables */
S    extern volatile uint8 * UART_1_BLE_rxBuffer;
S    extern uint8   UART_1_BLE_rxDataBits;
S    extern uint32  UART_1_BLE_rxBufferSize;
S
S    extern volatile uint8 * UART_1_BLE_txBuffer;
S    extern uint8   UART_1_BLE_txDataBits;
S    extern uint32  UART_1_BLE_txBufferSize;
S
S    /* EZI2C configuration variables */
S    extern uint8 UART_1_BLE_numberOfAddr;
S    extern uint8 UART_1_BLE_subAddrSize;
N#endif /* (UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N#if (! (UART_1_BLE_SCB_MODE_I2C_CONST_CFG || \
N        UART_1_BLE_SCB_MODE_EZI2C_CONST_CFG))
X#if (! (((0x01u) == (4u)) ||         ((0x08u) == (4u))))
N    extern uint16 UART_1_BLE_IntrTxMask;
N#endif /* (! (UART_1_BLE_SCB_MODE_I2C_CONST_CFG || \
N              UART_1_BLE_SCB_MODE_EZI2C_CONST_CFG)) */
X#endif  
N
N
N/***************************************
N*        Conditional Macro
N****************************************/
N
N#if(UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    /* Defines run time operation mode */
S    #define UART_1_BLE_SCB_MODE_I2C_RUNTM_CFG     (UART_1_BLE_SCB_MODE_I2C      == UART_1_BLE_scbMode)
S    #define UART_1_BLE_SCB_MODE_SPI_RUNTM_CFG     (UART_1_BLE_SCB_MODE_SPI      == UART_1_BLE_scbMode)
S    #define UART_1_BLE_SCB_MODE_UART_RUNTM_CFG    (UART_1_BLE_SCB_MODE_UART     == UART_1_BLE_scbMode)
S    #define UART_1_BLE_SCB_MODE_EZI2C_RUNTM_CFG   (UART_1_BLE_SCB_MODE_EZI2C    == UART_1_BLE_scbMode)
S    #define UART_1_BLE_SCB_MODE_UNCONFIG_RUNTM_CFG \
S                                                        (UART_1_BLE_SCB_MODE_UNCONFIG == UART_1_BLE_scbMode)
X    #define UART_1_BLE_SCB_MODE_UNCONFIG_RUNTM_CFG                                                         (UART_1_BLE_SCB_MODE_UNCONFIG == UART_1_BLE_scbMode)
S
S    /* Defines wakeup enable */
S    #define UART_1_BLE_SCB_WAKE_ENABLE_CHECK       (0u != UART_1_BLE_scbEnableWake)
N#endif /* (UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N/* Defines maximum number of SCB pins */
N#if (!UART_1_BLE_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_1_BLE_SCB_PINS_NUMBER    (7u)
N#else
S    #define UART_1_BLE_SCB_PINS_NUMBER    (2u)
N#endif /* (!UART_1_BLE_CY_SCBIP_V1) */
N
N#endif /* (CY_SCB_PVT_UART_1_BLE_H) */
N
N
N/* [] END OF FILE */
L 26 "Generated_Source\PSoC4\project.h" 2
N#include "UART_1_BLE_BOOT.h"
L 1 "Generated_Source\PSoC4\UART_1_BLE_BOOT.h" 1
N/***************************************************************************//**
N* \file UART_1_BLE_BOOT.h
N* \version 4.0
N*
N* \brief
N*  This file provides constants and parameter values of the bootloader
N*  communication APIs for the SCB Component.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2014-2017, Cypress Semiconductor Corporation. All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_BOOT_UART_1_BLE_H)
X#if !0L
N#define CY_SCB_BOOT_UART_1_BLE_H
N
N#include "UART_1_BLE_PVT.h"
N
N#if (UART_1_BLE_SCB_MODE_I2C_INC)
X#if ((0u !=((0x01u) & (4u))))
S    #include "UART_1_BLE_I2C.h"
N#endif /* (UART_1_BLE_SCB_MODE_I2C_INC) */
N
N#if (UART_1_BLE_SCB_MODE_EZI2C_INC)
X#if ((0u !=((0x08u) & (4u))))
S    #include "UART_1_BLE_EZI2C.h"
N#endif /* (UART_1_BLE_SCB_MODE_EZI2C_INC) */
N
N#if (UART_1_BLE_SCB_MODE_SPI_INC || UART_1_BLE_SCB_MODE_UART_INC)
X#if ((0u !=((0x02u) & (4u))) || (0u !=((0x04u) & (4u))))
N    #include "UART_1_BLE_SPI_UART.h"
N#endif /* (UART_1_BLE_SCB_MODE_SPI_INC || UART_1_BLE_SCB_MODE_UART_INC) */
N
N
N/***************************************
N*  Conditional Compilation Parameters
N****************************************/
N
N/* Bootloader communication interface enable */
N#define UART_1_BLE_BTLDR_COMM_ENABLED ((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_1_BLE) || \
N                                             (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface))
X#define UART_1_BLE_BTLDR_COMM_ENABLED ((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_1_BLE) ||                                              (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface))
N
N/* Enable I2C bootloader communication */
N#if (UART_1_BLE_SCB_MODE_I2C_INC)
X#if ((0u !=((0x01u) & (4u))))
S    #define UART_1_BLE_I2C_BTLDR_COMM_ENABLED     (UART_1_BLE_BTLDR_COMM_ENABLED && \
S                                                            (UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG || \
S                                                             UART_1_BLE_I2C_SLAVE_CONST))
X    #define UART_1_BLE_I2C_BTLDR_COMM_ENABLED     (UART_1_BLE_BTLDR_COMM_ENABLED &&                                                             (UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG ||                                                              UART_1_BLE_I2C_SLAVE_CONST))
N#else
N     #define UART_1_BLE_I2C_BTLDR_COMM_ENABLED    (0u)
N#endif /* (UART_1_BLE_SCB_MODE_I2C_INC) */
N
N/* EZI2C does not support bootloader communication. Provide empty APIs */
N#if (UART_1_BLE_SCB_MODE_EZI2C_INC)
X#if ((0u !=((0x08u) & (4u))))
S    #define UART_1_BLE_EZI2C_BTLDR_COMM_ENABLED   (UART_1_BLE_BTLDR_COMM_ENABLED && \
S                                                         UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG)
X    #define UART_1_BLE_EZI2C_BTLDR_COMM_ENABLED   (UART_1_BLE_BTLDR_COMM_ENABLED &&                                                          UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG)
N#else
N    #define UART_1_BLE_EZI2C_BTLDR_COMM_ENABLED   (0u)
N#endif /* (UART_1_BLE_EZI2C_BTLDR_COMM_ENABLED) */
N
N/* Enable SPI bootloader communication */
N#if (UART_1_BLE_SCB_MODE_SPI_INC)
X#if ((0u !=((0x02u) & (4u))))
S    #define UART_1_BLE_SPI_BTLDR_COMM_ENABLED     (UART_1_BLE_BTLDR_COMM_ENABLED && \
S                                                            (UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG || \
S                                                             UART_1_BLE_SPI_SLAVE_CONST))
X    #define UART_1_BLE_SPI_BTLDR_COMM_ENABLED     (UART_1_BLE_BTLDR_COMM_ENABLED &&                                                             (UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG ||                                                              UART_1_BLE_SPI_SLAVE_CONST))
N#else
N        #define UART_1_BLE_SPI_BTLDR_COMM_ENABLED (0u)
N#endif /* (UART_1_BLE_SPI_BTLDR_COMM_ENABLED) */
N
N/* Enable UART bootloader communication */
N#if (UART_1_BLE_SCB_MODE_UART_INC)
X#if ((0u !=((0x04u) & (4u))))
N       #define UART_1_BLE_UART_BTLDR_COMM_ENABLED    (UART_1_BLE_BTLDR_COMM_ENABLED && \
N                                                            (UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG || \
N                                                             (UART_1_BLE_UART_RX_DIRECTION && \
N                                                              UART_1_BLE_UART_TX_DIRECTION)))
X       #define UART_1_BLE_UART_BTLDR_COMM_ENABLED    (UART_1_BLE_BTLDR_COMM_ENABLED &&                                                             (UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG ||                                                              (UART_1_BLE_UART_RX_DIRECTION &&                                                               UART_1_BLE_UART_TX_DIRECTION)))
N#else
S     #define UART_1_BLE_UART_BTLDR_COMM_ENABLED   (0u)
N#endif /* (UART_1_BLE_UART_BTLDR_COMM_ENABLED) */
N
N/* Enable bootloader communication */
N#define UART_1_BLE_BTLDR_COMM_MODE_ENABLED    (UART_1_BLE_I2C_BTLDR_COMM_ENABLED   || \
N                                                     UART_1_BLE_SPI_BTLDR_COMM_ENABLED   || \
N                                                     UART_1_BLE_EZI2C_BTLDR_COMM_ENABLED || \
N                                                     UART_1_BLE_UART_BTLDR_COMM_ENABLED)
X#define UART_1_BLE_BTLDR_COMM_MODE_ENABLED    (UART_1_BLE_I2C_BTLDR_COMM_ENABLED   ||                                                      UART_1_BLE_SPI_BTLDR_COMM_ENABLED   ||                                                      UART_1_BLE_EZI2C_BTLDR_COMM_ENABLED ||                                                      UART_1_BLE_UART_BTLDR_COMM_ENABLED)
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_1_BLE_I2C_BTLDR_COMM_ENABLED)
X#if 0L && ((0u))
S    /* I2C Bootloader physical layer functions */
S    void UART_1_BLE_I2CCyBtldrCommStart(void);
S    void UART_1_BLE_I2CCyBtldrCommStop (void);
S    void UART_1_BLE_I2CCyBtldrCommReset(void);
S    cystatus UART_1_BLE_I2CCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus UART_1_BLE_I2CCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    /* Map I2C specific bootloader communication APIs to SCB specific APIs */
S    #if (UART_1_BLE_SCB_MODE_I2C_CONST_CFG)
S        #define UART_1_BLE_CyBtldrCommStart   UART_1_BLE_I2CCyBtldrCommStart
S        #define UART_1_BLE_CyBtldrCommStop    UART_1_BLE_I2CCyBtldrCommStop
S        #define UART_1_BLE_CyBtldrCommReset   UART_1_BLE_I2CCyBtldrCommReset
S        #define UART_1_BLE_CyBtldrCommRead    UART_1_BLE_I2CCyBtldrCommRead
S        #define UART_1_BLE_CyBtldrCommWrite   UART_1_BLE_I2CCyBtldrCommWrite
S    #endif /* (UART_1_BLE_SCB_MODE_I2C_CONST_CFG) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_1_BLE_I2C_BTLDR_COMM_ENABLED) */
N
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_1_BLE_EZI2C_BTLDR_COMM_ENABLED)
X#if 0L && ((0u))
S    /* Bootloader physical layer functions */
S    void UART_1_BLE_EzI2CCyBtldrCommStart(void);
S    void UART_1_BLE_EzI2CCyBtldrCommStop (void);
S    void UART_1_BLE_EzI2CCyBtldrCommReset(void);
S    cystatus UART_1_BLE_EzI2CCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus UART_1_BLE_EzI2CCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    /* Map EZI2C specific bootloader communication APIs to SCB specific APIs */
S    #if (UART_1_BLE_SCB_MODE_EZI2C_CONST_CFG)
S        #define UART_1_BLE_CyBtldrCommStart   UART_1_BLE_EzI2CCyBtldrCommStart
S        #define UART_1_BLE_CyBtldrCommStop    UART_1_BLE_EzI2CCyBtldrCommStop
S        #define UART_1_BLE_CyBtldrCommReset   UART_1_BLE_EzI2CCyBtldrCommReset
S        #define UART_1_BLE_CyBtldrCommRead    UART_1_BLE_EzI2CCyBtldrCommRead
S        #define UART_1_BLE_CyBtldrCommWrite   UART_1_BLE_EzI2CCyBtldrCommWrite
S    #endif /* (UART_1_BLE_SCB_MODE_EZI2C_CONST_CFG) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_1_BLE_EZI2C_BTLDR_COMM_ENABLED) */
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_1_BLE_SPI_BTLDR_COMM_ENABLED)
X#if 0L && ((0u))
S    /* SPI Bootloader physical layer functions */
S    void UART_1_BLE_SpiCyBtldrCommStart(void);
S    void UART_1_BLE_SpiCyBtldrCommStop (void);
S    void UART_1_BLE_SpiCyBtldrCommReset(void);
S    cystatus UART_1_BLE_SpiCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus UART_1_BLE_SpiCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    /* Map SPI specific bootloader communication APIs to SCB specific APIs */
S    #if (UART_1_BLE_SCB_MODE_SPI_CONST_CFG)
S        #define UART_1_BLE_CyBtldrCommStart   UART_1_BLE_SpiCyBtldrCommStart
S        #define UART_1_BLE_CyBtldrCommStop    UART_1_BLE_SpiCyBtldrCommStop
S        #define UART_1_BLE_CyBtldrCommReset   UART_1_BLE_SpiCyBtldrCommReset
S        #define UART_1_BLE_CyBtldrCommRead    UART_1_BLE_SpiCyBtldrCommRead
S        #define UART_1_BLE_CyBtldrCommWrite   UART_1_BLE_SpiCyBtldrCommWrite
S    #endif /* (UART_1_BLE_SCB_MODE_SPI_CONST_CFG) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_1_BLE_SPI_BTLDR_COMM_ENABLED) */
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_1_BLE_UART_BTLDR_COMM_ENABLED)
X#if 0L && ((((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_1_BLE) || (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface)) && (((0xFFu) == (4u)) || ((0u != ((3u) & (1u))) && (0u != ((3u) & (2u)))))))
S    /* UART Bootloader physical layer functions */
S    void UART_1_BLE_UartCyBtldrCommStart(void);
S    void UART_1_BLE_UartCyBtldrCommStop (void);
S    void UART_1_BLE_UartCyBtldrCommReset(void);
S    cystatus UART_1_BLE_UartCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus UART_1_BLE_UartCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    /* Map UART specific bootloader communication APIs to SCB specific APIs */
S    #if (UART_1_BLE_SCB_MODE_UART_CONST_CFG)
S        #define UART_1_BLE_CyBtldrCommStart   UART_1_BLE_UartCyBtldrCommStart
S        #define UART_1_BLE_CyBtldrCommStop    UART_1_BLE_UartCyBtldrCommStop
S        #define UART_1_BLE_CyBtldrCommReset   UART_1_BLE_UartCyBtldrCommReset
S        #define UART_1_BLE_CyBtldrCommRead    UART_1_BLE_UartCyBtldrCommRead
S        #define UART_1_BLE_CyBtldrCommWrite   UART_1_BLE_UartCyBtldrCommWrite
S    #endif /* (UART_1_BLE_SCB_MODE_UART_CONST_CFG) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_1_BLE_UART_BTLDR_COMM_ENABLED) */
N
N/**
N* \addtogroup group_bootloader
N* @{
N*/
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_1_BLE_BTLDR_COMM_ENABLED)
X#if 0L && (((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_1_BLE) || (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface)))
S    #if (UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG)
S        /* Bootloader physical layer functions */
S        void UART_1_BLE_CyBtldrCommStart(void);
S        void UART_1_BLE_CyBtldrCommStop (void);
S        void UART_1_BLE_CyBtldrCommReset(void);
S        cystatus UART_1_BLE_CyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S        cystatus UART_1_BLE_CyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    #endif /* (UART_1_BLE_SCB_MODE_UNCONFIG_CONST_CFG) */
S
S    /* Map SCB specific bootloader communication APIs to common APIs */
S    #if (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_1_BLE)
S        #define CyBtldrCommStart    UART_1_BLE_CyBtldrCommStart
S        #define CyBtldrCommStop     UART_1_BLE_CyBtldrCommStop
S        #define CyBtldrCommReset    UART_1_BLE_CyBtldrCommReset
S        #define CyBtldrCommWrite    UART_1_BLE_CyBtldrCommWrite
S        #define CyBtldrCommRead     UART_1_BLE_CyBtldrCommRead
S    #endif /* (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_1_BLE) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_1_BLE_BTLDR_COMM_ENABLED) */
N
N/** @} group_bootloader */
N
N/***************************************
N*           API Constants
N***************************************/
N
N/* Timeout unit in milliseconds */
N#define UART_1_BLE_WAIT_1_MS  (1u)
N
N/* Return number of bytes to copy into bootloader buffer */
N#define UART_1_BLE_BYTES_TO_COPY(actBufSize, bufSize) \
N                            ( ((uint32)(actBufSize) < (uint32)(bufSize)) ? \
N                                ((uint32) (actBufSize)) : ((uint32) (bufSize)) )
X#define UART_1_BLE_BYTES_TO_COPY(actBufSize, bufSize)                             ( ((uint32)(actBufSize) < (uint32)(bufSize)) ?                                 ((uint32) (actBufSize)) : ((uint32) (bufSize)) )
N
N/* Size of Read/Write buffers for I2C bootloader  */
N#define UART_1_BLE_I2C_BTLDR_SIZEOF_READ_BUFFER   (64u)
N#define UART_1_BLE_I2C_BTLDR_SIZEOF_WRITE_BUFFER  (64u)
N
N/* Byte to byte time interval: calculated basing on current component
N* data rate configuration, can be defined in project if required.
N*/
N#ifndef UART_1_BLE_SPI_BYTE_TO_BYTE
N    #define UART_1_BLE_SPI_BYTE_TO_BYTE   (160u)
N#endif
N
N/* Byte to byte time interval: calculated basing on current component
N* baud rate configuration, can be defined in the project if required.
N*/
N#ifndef UART_1_BLE_UART_BYTE_TO_BYTE
N    #define UART_1_BLE_UART_BYTE_TO_BYTE  (2086u)
N#endif /* UART_1_BLE_UART_BYTE_TO_BYTE */
N
N#endif /* (CY_SCB_BOOT_UART_1_BLE_H) */
N
N
N/* [] END OF FILE */
L 27 "Generated_Source\PSoC4\project.h" 2
N#include "UART_0_FPC.h"
L 1 "Generated_Source\PSoC4\UART_0_FPC.h" 1
N/***************************************************************************//**
N* \file UART_0_FPC.h
N* \version 4.0
N*
N* \brief
N*  This file provides constants and parameter values for the SCB Component.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_UART_0_FPC_H)
X#if !0L
N#define CY_SCB_UART_0_FPC_H
N
N#include <cydevice_trm.h>
N#include <cyfitter.h>
N#include <cytypes.h>
N#include <CyLib.h>
N
N/* SCB IP block v0 is available in PSoC 4100/PSoC 4200 */
N#define UART_0_FPC_CY_SCBIP_V0    (CYIPBLOCK_m0s8scb_VERSION == 0u)
N/* SCB IP block v1 is available in PSoC 4000 */
N#define UART_0_FPC_CY_SCBIP_V1    (CYIPBLOCK_m0s8scb_VERSION == 1u)
N/* SCB IP block v2 is available in all other devices */
N#define UART_0_FPC_CY_SCBIP_V2    (CYIPBLOCK_m0s8scb_VERSION >= 2u)
N
N/** Component version major.minor */
N#define UART_0_FPC_COMP_VERSION_MAJOR    (4)
N#define UART_0_FPC_COMP_VERSION_MINOR    (0)
N    
N#define UART_0_FPC_SCB_MODE           (4u)
N
N/* SCB modes enum */
N#define UART_0_FPC_SCB_MODE_I2C       (0x01u)
N#define UART_0_FPC_SCB_MODE_SPI       (0x02u)
N#define UART_0_FPC_SCB_MODE_UART      (0x04u)
N#define UART_0_FPC_SCB_MODE_EZI2C     (0x08u)
N#define UART_0_FPC_SCB_MODE_UNCONFIG  (0xFFu)
N
N/* Condition compilation depends on operation mode: Unconfigured implies apply to all modes */
N#define UART_0_FPC_SCB_MODE_I2C_CONST_CFG       (UART_0_FPC_SCB_MODE_I2C       == UART_0_FPC_SCB_MODE)
N#define UART_0_FPC_SCB_MODE_SPI_CONST_CFG       (UART_0_FPC_SCB_MODE_SPI       == UART_0_FPC_SCB_MODE)
N#define UART_0_FPC_SCB_MODE_UART_CONST_CFG      (UART_0_FPC_SCB_MODE_UART      == UART_0_FPC_SCB_MODE)
N#define UART_0_FPC_SCB_MODE_EZI2C_CONST_CFG     (UART_0_FPC_SCB_MODE_EZI2C     == UART_0_FPC_SCB_MODE)
N#define UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG  (UART_0_FPC_SCB_MODE_UNCONFIG  == UART_0_FPC_SCB_MODE)
N
N/* Condition compilation for includes */
N#define UART_0_FPC_SCB_MODE_I2C_INC      (0u !=(UART_0_FPC_SCB_MODE_I2C   & UART_0_FPC_SCB_MODE))
N#define UART_0_FPC_SCB_MODE_EZI2C_INC    (0u !=(UART_0_FPC_SCB_MODE_EZI2C & UART_0_FPC_SCB_MODE))
N#if (!UART_0_FPC_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_0_FPC_SCB_MODE_SPI_INC  (0u !=(UART_0_FPC_SCB_MODE_SPI   & UART_0_FPC_SCB_MODE))
N    #define UART_0_FPC_SCB_MODE_UART_INC (0u !=(UART_0_FPC_SCB_MODE_UART  & UART_0_FPC_SCB_MODE))
N#else
S    #define UART_0_FPC_SCB_MODE_SPI_INC  (0u)
S    #define UART_0_FPC_SCB_MODE_UART_INC (0u)
N#endif /* (!UART_0_FPC_CY_SCBIP_V1) */
N
N/* Interrupts remove options */
N#define UART_0_FPC_REMOVE_SCB_IRQ             (0u)
N#define UART_0_FPC_SCB_IRQ_INTERNAL           (0u == UART_0_FPC_REMOVE_SCB_IRQ)
N
N#define UART_0_FPC_REMOVE_UART_RX_WAKEUP_IRQ  (1u)
N#define UART_0_FPC_UART_RX_WAKEUP_IRQ         (0u == UART_0_FPC_REMOVE_UART_RX_WAKEUP_IRQ)
N
N/* SCB interrupt enum */
N#define UART_0_FPC_SCB_INTR_MODE_NONE     (0u)
N#define UART_0_FPC_SCB_INTR_MODE_INTERNAL (1u)
N#define UART_0_FPC_SCB_INTR_MODE_EXTERNAL (2u)
N
N/* Internal clock remove option */
N#define UART_0_FPC_REMOVE_SCB_CLK     (0u)
N#define UART_0_FPC_SCB_CLK_INTERNAL   (0u == UART_0_FPC_REMOVE_SCB_CLK)
N
N
N/***************************************
N*       Includes
N****************************************/
N
N#include "UART_0_FPC_PINS.h"
L 1 "Generated_Source\PSoC4\UART_0_FPC_PINS.h" 1
N/***************************************************************************//**
N* \file UART_0_FPC_PINS.h
N* \version 4.0
N*
N* \brief
N*  This file provides constants and parameter values for the pin components
N*  buried into SCB Component.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_PINS_UART_0_FPC_H)
X#if !0L
N#define CY_SCB_PINS_UART_0_FPC_H
N
N#include "cydevice_trm.h"
N#include "cyfitter.h"
N#include "cytypes.h"
N
N
N/***************************************
N*   Conditional Compilation Parameters
N****************************************/
N
N/* Unconfigured pins */
N#define UART_0_FPC_REMOVE_RX_WAKE_SCL_MOSI_PIN  (1u)
N#define UART_0_FPC_REMOVE_RX_SCL_MOSI_PIN      (1u)
N#define UART_0_FPC_REMOVE_TX_SDA_MISO_PIN      (1u)
N#define UART_0_FPC_REMOVE_CTS_SCLK_PIN      (1u)
N#define UART_0_FPC_REMOVE_RTS_SS0_PIN      (1u)
N#define UART_0_FPC_REMOVE_SS1_PIN                 (1u)
N#define UART_0_FPC_REMOVE_SS2_PIN                 (1u)
N#define UART_0_FPC_REMOVE_SS3_PIN                 (1u)
N
N/* Mode defined pins */
N#define UART_0_FPC_REMOVE_I2C_PINS                (1u)
N#define UART_0_FPC_REMOVE_SPI_MASTER_PINS         (1u)
N#define UART_0_FPC_REMOVE_SPI_MASTER_SCLK_PIN     (1u)
N#define UART_0_FPC_REMOVE_SPI_MASTER_MOSI_PIN     (1u)
N#define UART_0_FPC_REMOVE_SPI_MASTER_MISO_PIN     (1u)
N#define UART_0_FPC_REMOVE_SPI_MASTER_SS0_PIN      (1u)
N#define UART_0_FPC_REMOVE_SPI_MASTER_SS1_PIN      (1u)
N#define UART_0_FPC_REMOVE_SPI_MASTER_SS2_PIN      (1u)
N#define UART_0_FPC_REMOVE_SPI_MASTER_SS3_PIN      (1u)
N#define UART_0_FPC_REMOVE_SPI_SLAVE_PINS          (1u)
N#define UART_0_FPC_REMOVE_SPI_SLAVE_MOSI_PIN      (1u)
N#define UART_0_FPC_REMOVE_SPI_SLAVE_MISO_PIN      (1u)
N#define UART_0_FPC_REMOVE_UART_TX_PIN             (0u)
N#define UART_0_FPC_REMOVE_UART_RX_TX_PIN          (1u)
N#define UART_0_FPC_REMOVE_UART_RX_PIN             (0u)
N#define UART_0_FPC_REMOVE_UART_RX_WAKE_PIN        (1u)
N#define UART_0_FPC_REMOVE_UART_RTS_PIN            (1u)
N#define UART_0_FPC_REMOVE_UART_CTS_PIN            (1u)
N
N/* Unconfigured pins */
N#define UART_0_FPC_RX_WAKE_SCL_MOSI_PIN (0u == UART_0_FPC_REMOVE_RX_WAKE_SCL_MOSI_PIN)
N#define UART_0_FPC_RX_SCL_MOSI_PIN     (0u == UART_0_FPC_REMOVE_RX_SCL_MOSI_PIN)
N#define UART_0_FPC_TX_SDA_MISO_PIN     (0u == UART_0_FPC_REMOVE_TX_SDA_MISO_PIN)
N#define UART_0_FPC_CTS_SCLK_PIN     (0u == UART_0_FPC_REMOVE_CTS_SCLK_PIN)
N#define UART_0_FPC_RTS_SS0_PIN     (0u == UART_0_FPC_REMOVE_RTS_SS0_PIN)
N#define UART_0_FPC_SS1_PIN                (0u == UART_0_FPC_REMOVE_SS1_PIN)
N#define UART_0_FPC_SS2_PIN                (0u == UART_0_FPC_REMOVE_SS2_PIN)
N#define UART_0_FPC_SS3_PIN                (0u == UART_0_FPC_REMOVE_SS3_PIN)
N
N/* Mode defined pins */
N#define UART_0_FPC_I2C_PINS               (0u == UART_0_FPC_REMOVE_I2C_PINS)
N#define UART_0_FPC_SPI_MASTER_PINS        (0u == UART_0_FPC_REMOVE_SPI_MASTER_PINS)
N#define UART_0_FPC_SPI_MASTER_SCLK_PIN    (0u == UART_0_FPC_REMOVE_SPI_MASTER_SCLK_PIN)
N#define UART_0_FPC_SPI_MASTER_MOSI_PIN    (0u == UART_0_FPC_REMOVE_SPI_MASTER_MOSI_PIN)
N#define UART_0_FPC_SPI_MASTER_MISO_PIN    (0u == UART_0_FPC_REMOVE_SPI_MASTER_MISO_PIN)
N#define UART_0_FPC_SPI_MASTER_SS0_PIN     (0u == UART_0_FPC_REMOVE_SPI_MASTER_SS0_PIN)
N#define UART_0_FPC_SPI_MASTER_SS1_PIN     (0u == UART_0_FPC_REMOVE_SPI_MASTER_SS1_PIN)
N#define UART_0_FPC_SPI_MASTER_SS2_PIN     (0u == UART_0_FPC_REMOVE_SPI_MASTER_SS2_PIN)
N#define UART_0_FPC_SPI_MASTER_SS3_PIN     (0u == UART_0_FPC_REMOVE_SPI_MASTER_SS3_PIN)
N#define UART_0_FPC_SPI_SLAVE_PINS         (0u == UART_0_FPC_REMOVE_SPI_SLAVE_PINS)
N#define UART_0_FPC_SPI_SLAVE_MOSI_PIN     (0u == UART_0_FPC_REMOVE_SPI_SLAVE_MOSI_PIN)
N#define UART_0_FPC_SPI_SLAVE_MISO_PIN     (0u == UART_0_FPC_REMOVE_SPI_SLAVE_MISO_PIN)
N#define UART_0_FPC_UART_TX_PIN            (0u == UART_0_FPC_REMOVE_UART_TX_PIN)
N#define UART_0_FPC_UART_RX_TX_PIN         (0u == UART_0_FPC_REMOVE_UART_RX_TX_PIN)
N#define UART_0_FPC_UART_RX_PIN            (0u == UART_0_FPC_REMOVE_UART_RX_PIN)
N#define UART_0_FPC_UART_RX_WAKE_PIN       (0u == UART_0_FPC_REMOVE_UART_RX_WAKE_PIN)
N#define UART_0_FPC_UART_RTS_PIN           (0u == UART_0_FPC_REMOVE_UART_RTS_PIN)
N#define UART_0_FPC_UART_CTS_PIN           (0u == UART_0_FPC_REMOVE_UART_CTS_PIN)
N
N
N/***************************************
N*             Includes
N****************************************/
N
N#if (UART_0_FPC_RX_WAKE_SCL_MOSI_PIN)
X#if ((0u == (1u)))
S    #include "UART_0_FPC_uart_rx_wake_i2c_scl_spi_mosi.h"
N#endif /* (UART_0_FPC_RX_SCL_MOSI) */
N
N#if (UART_0_FPC_RX_SCL_MOSI_PIN)
X#if ((0u == (1u)))
S    #include "UART_0_FPC_uart_rx_i2c_scl_spi_mosi.h"
N#endif /* (UART_0_FPC_RX_SCL_MOSI) */
N
N#if (UART_0_FPC_TX_SDA_MISO_PIN)
X#if ((0u == (1u)))
S    #include "UART_0_FPC_uart_tx_i2c_sda_spi_miso.h"
N#endif /* (UART_0_FPC_TX_SDA_MISO) */
N
N#if (UART_0_FPC_CTS_SCLK_PIN)
X#if ((0u == (1u)))
S    #include "UART_0_FPC_uart_cts_spi_sclk.h"
N#endif /* (UART_0_FPC_CTS_SCLK) */
N
N#if (UART_0_FPC_RTS_SS0_PIN)
X#if ((0u == (1u)))
S    #include "UART_0_FPC_uart_rts_spi_ss0.h"
N#endif /* (UART_0_FPC_RTS_SS0_PIN) */
N
N#if (UART_0_FPC_SS1_PIN)
X#if ((0u == (1u)))
S    #include "UART_0_FPC_spi_ss1.h"
N#endif /* (UART_0_FPC_SS1_PIN) */
N
N#if (UART_0_FPC_SS2_PIN)
X#if ((0u == (1u)))
S    #include "UART_0_FPC_spi_ss2.h"
N#endif /* (UART_0_FPC_SS2_PIN) */
N
N#if (UART_0_FPC_SS3_PIN)
X#if ((0u == (1u)))
S    #include "UART_0_FPC_spi_ss3.h"
N#endif /* (UART_0_FPC_SS3_PIN) */
N
N#if (UART_0_FPC_I2C_PINS)
X#if ((0u == (1u)))
S    #include "UART_0_FPC_scl.h"
S    #include "UART_0_FPC_sda.h"
N#endif /* (UART_0_FPC_I2C_PINS) */
N
N#if (UART_0_FPC_SPI_MASTER_PINS)
X#if ((0u == (1u)))
S#if (UART_0_FPC_SPI_MASTER_SCLK_PIN)
S    #include "UART_0_FPC_sclk_m.h"
S#endif /* (UART_0_FPC_SPI_MASTER_SCLK_PIN) */
S
S#if (UART_0_FPC_SPI_MASTER_MOSI_PIN)
S    #include "UART_0_FPC_mosi_m.h"
S#endif /* (UART_0_FPC_SPI_MASTER_MOSI_PIN) */
S
S#if (UART_0_FPC_SPI_MASTER_MISO_PIN)
S    #include "UART_0_FPC_miso_m.h"
S#endif /*(UART_0_FPC_SPI_MASTER_MISO_PIN) */
N#endif /* (UART_0_FPC_SPI_MASTER_PINS) */
N
N#if (UART_0_FPC_SPI_SLAVE_PINS)
X#if ((0u == (1u)))
S    #include "UART_0_FPC_sclk_s.h"
S    #include "UART_0_FPC_ss_s.h"
S
S#if (UART_0_FPC_SPI_SLAVE_MOSI_PIN)
S    #include "UART_0_FPC_mosi_s.h"
S#endif /* (UART_0_FPC_SPI_SLAVE_MOSI_PIN) */
S
S#if (UART_0_FPC_SPI_SLAVE_MISO_PIN)
S    #include "UART_0_FPC_miso_s.h"
S#endif /*(UART_0_FPC_SPI_SLAVE_MISO_PIN) */
N#endif /* (UART_0_FPC_SPI_SLAVE_PINS) */
N
N#if (UART_0_FPC_SPI_MASTER_SS0_PIN)
X#if ((0u == (1u)))
S    #include "UART_0_FPC_ss0_m.h"
N#endif /* (UART_0_FPC_SPI_MASTER_SS0_PIN) */
N
N#if (UART_0_FPC_SPI_MASTER_SS1_PIN)
X#if ((0u == (1u)))
S    #include "UART_0_FPC_ss1_m.h"
N#endif /* (UART_0_FPC_SPI_MASTER_SS1_PIN) */
N
N#if (UART_0_FPC_SPI_MASTER_SS2_PIN)
X#if ((0u == (1u)))
S    #include "UART_0_FPC_ss2_m.h"
N#endif /* (UART_0_FPC_SPI_MASTER_SS2_PIN) */
N
N#if (UART_0_FPC_SPI_MASTER_SS3_PIN)
X#if ((0u == (1u)))
S    #include "UART_0_FPC_ss3_m.h"
N#endif /* (UART_0_FPC_SPI_MASTER_SS3_PIN) */
N
N#if (UART_0_FPC_UART_TX_PIN)
X#if ((0u == (0u)))
N    #include "UART_0_FPC_tx.h"
L 1 "Generated_Source\PSoC4\UART_0_FPC_tx.h" 1
N/*******************************************************************************
N* File Name: UART_0_FPC_tx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_0_FPC_tx_H) /* Pins UART_0_FPC_tx_H */
X#if !0L  
N#define CY_PINS_UART_0_FPC_tx_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "UART_0_FPC_tx_aliases.h"
L 1 "Generated_Source\PSoC4\UART_0_FPC_tx_aliases.h" 1
N/*******************************************************************************
N* File Name: UART_0_FPC_tx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_0_FPC_tx_ALIASES_H) /* Pins UART_0_FPC_tx_ALIASES_H */
X#if !0L  
N#define CY_PINS_UART_0_FPC_tx_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define UART_0_FPC_tx_0			(UART_0_FPC_tx__0__PC)
N#define UART_0_FPC_tx_0_PS		(UART_0_FPC_tx__0__PS)
N#define UART_0_FPC_tx_0_PC		(UART_0_FPC_tx__0__PC)
N#define UART_0_FPC_tx_0_DR		(UART_0_FPC_tx__0__DR)
N#define UART_0_FPC_tx_0_SHIFT	(UART_0_FPC_tx__0__SHIFT)
N#define UART_0_FPC_tx_0_INTR	((uint16)((uint16)0x0003u << (UART_0_FPC_tx__0__SHIFT*2u)))
N
N#define UART_0_FPC_tx_INTR_ALL	 ((uint16)(UART_0_FPC_tx_0_INTR))
N
N
N#endif /* End Pins UART_0_FPC_tx_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\UART_0_FPC_tx.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} UART_0_FPC_tx_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   UART_0_FPC_tx_Read(void);
Nvoid    UART_0_FPC_tx_Write(uint8 value);
Nuint8   UART_0_FPC_tx_ReadDataReg(void);
N#if defined(UART_0_FPC_tx__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    UART_0_FPC_tx_SetDriveMode(uint8 mode);
N#endif
Nvoid    UART_0_FPC_tx_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   UART_0_FPC_tx_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid UART_0_FPC_tx_Sleep(void); 
Nvoid UART_0_FPC_tx_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(UART_0_FPC_tx__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define UART_0_FPC_tx_DRIVE_MODE_BITS        (3)
N    #define UART_0_FPC_tx_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - UART_0_FPC_tx_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the UART_0_FPC_tx_SetDriveMode() function.
N         *  @{
N         */
N        #define UART_0_FPC_tx_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define UART_0_FPC_tx_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define UART_0_FPC_tx_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define UART_0_FPC_tx_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define UART_0_FPC_tx_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define UART_0_FPC_tx_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define UART_0_FPC_tx_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define UART_0_FPC_tx_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define UART_0_FPC_tx_MASK               UART_0_FPC_tx__MASK
N#define UART_0_FPC_tx_SHIFT              UART_0_FPC_tx__SHIFT
N#define UART_0_FPC_tx_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in UART_0_FPC_tx_SetInterruptMode() function.
N     *  @{
N     */
N        #define UART_0_FPC_tx_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define UART_0_FPC_tx_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define UART_0_FPC_tx_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define UART_0_FPC_tx_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(UART_0_FPC_tx__SIO)
X#if 0L
S    #define UART_0_FPC_tx_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(UART_0_FPC_tx__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define UART_0_FPC_tx_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define UART_0_FPC_tx_USBIO_DISABLE              ((uint32)(~UART_0_FPC_tx_USBIO_ENABLE))
S    #define UART_0_FPC_tx_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define UART_0_FPC_tx_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define UART_0_FPC_tx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_0_FPC_tx_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << UART_0_FPC_tx_USBIO_SUSPEND_DEL_SHIFT)))
X    #define UART_0_FPC_tx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_0_FPC_tx_USBIO_SUSPEND_SHIFT)                                                         | (1u << UART_0_FPC_tx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_0_FPC_tx_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << UART_0_FPC_tx_USBIO_SUSPEND_SHIFT)))
S    #define UART_0_FPC_tx_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << UART_0_FPC_tx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_0_FPC_tx_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(UART_0_FPC_tx__PC)
X#if 1L
N    /* Port Configuration */
N    #define UART_0_FPC_tx_PC                 (* (reg32 *) UART_0_FPC_tx__PC)
N#endif
N/* Pin State */
N#define UART_0_FPC_tx_PS                     (* (reg32 *) UART_0_FPC_tx__PS)
N/* Data Register */
N#define UART_0_FPC_tx_DR                     (* (reg32 *) UART_0_FPC_tx__DR)
N/* Input Buffer Disable Override */
N#define UART_0_FPC_tx_INP_DIS                (* (reg32 *) UART_0_FPC_tx__PC2)
N
N/* Interrupt configuration Registers */
N#define UART_0_FPC_tx_INTCFG                 (* (reg32 *) UART_0_FPC_tx__INTCFG)
N#define UART_0_FPC_tx_INTSTAT                (* (reg32 *) UART_0_FPC_tx__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define UART_0_FPC_tx_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(UART_0_FPC_tx__SIO)
X#if 0L
S    #define UART_0_FPC_tx_SIO_REG            (* (reg32 *) UART_0_FPC_tx__SIO)
N#endif /* (UART_0_FPC_tx__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(UART_0_FPC_tx__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define UART_0_FPC_tx_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define UART_0_FPC_tx_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define UART_0_FPC_tx_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define UART_0_FPC_tx_DRIVE_MODE_SHIFT       (0x00u)
N#define UART_0_FPC_tx_DRIVE_MODE_MASK        (0x07u << UART_0_FPC_tx_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins UART_0_FPC_tx_H */
N
N
N/* [] END OF FILE */
L 178 "Generated_Source\PSoC4\UART_0_FPC_PINS.h" 2
N#endif /* (UART_0_FPC_UART_TX_PIN) */
N
N#if (UART_0_FPC_UART_RX_TX_PIN)
X#if ((0u == (1u)))
S    #include "UART_0_FPC_rx_tx.h"
N#endif /* (UART_0_FPC_UART_RX_TX_PIN) */
N
N#if (UART_0_FPC_UART_RX_PIN)
X#if ((0u == (0u)))
N    #include "UART_0_FPC_rx.h"
L 1 "Generated_Source\PSoC4\UART_0_FPC_rx.h" 1
N/*******************************************************************************
N* File Name: UART_0_FPC_rx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_0_FPC_rx_H) /* Pins UART_0_FPC_rx_H */
X#if !0L  
N#define CY_PINS_UART_0_FPC_rx_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "UART_0_FPC_rx_aliases.h"
L 1 "Generated_Source\PSoC4\UART_0_FPC_rx_aliases.h" 1
N/*******************************************************************************
N* File Name: UART_0_FPC_rx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_0_FPC_rx_ALIASES_H) /* Pins UART_0_FPC_rx_ALIASES_H */
X#if !0L  
N#define CY_PINS_UART_0_FPC_rx_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define UART_0_FPC_rx_0			(UART_0_FPC_rx__0__PC)
N#define UART_0_FPC_rx_0_PS		(UART_0_FPC_rx__0__PS)
N#define UART_0_FPC_rx_0_PC		(UART_0_FPC_rx__0__PC)
N#define UART_0_FPC_rx_0_DR		(UART_0_FPC_rx__0__DR)
N#define UART_0_FPC_rx_0_SHIFT	(UART_0_FPC_rx__0__SHIFT)
N#define UART_0_FPC_rx_0_INTR	((uint16)((uint16)0x0003u << (UART_0_FPC_rx__0__SHIFT*2u)))
N
N#define UART_0_FPC_rx_INTR_ALL	 ((uint16)(UART_0_FPC_rx_0_INTR))
N
N
N#endif /* End Pins UART_0_FPC_rx_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\UART_0_FPC_rx.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} UART_0_FPC_rx_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   UART_0_FPC_rx_Read(void);
Nvoid    UART_0_FPC_rx_Write(uint8 value);
Nuint8   UART_0_FPC_rx_ReadDataReg(void);
N#if defined(UART_0_FPC_rx__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    UART_0_FPC_rx_SetDriveMode(uint8 mode);
N#endif
Nvoid    UART_0_FPC_rx_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   UART_0_FPC_rx_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid UART_0_FPC_rx_Sleep(void); 
Nvoid UART_0_FPC_rx_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(UART_0_FPC_rx__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define UART_0_FPC_rx_DRIVE_MODE_BITS        (3)
N    #define UART_0_FPC_rx_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - UART_0_FPC_rx_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the UART_0_FPC_rx_SetDriveMode() function.
N         *  @{
N         */
N        #define UART_0_FPC_rx_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define UART_0_FPC_rx_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define UART_0_FPC_rx_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define UART_0_FPC_rx_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define UART_0_FPC_rx_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define UART_0_FPC_rx_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define UART_0_FPC_rx_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define UART_0_FPC_rx_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define UART_0_FPC_rx_MASK               UART_0_FPC_rx__MASK
N#define UART_0_FPC_rx_SHIFT              UART_0_FPC_rx__SHIFT
N#define UART_0_FPC_rx_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in UART_0_FPC_rx_SetInterruptMode() function.
N     *  @{
N     */
N        #define UART_0_FPC_rx_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define UART_0_FPC_rx_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define UART_0_FPC_rx_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define UART_0_FPC_rx_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(UART_0_FPC_rx__SIO)
X#if 0L
S    #define UART_0_FPC_rx_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(UART_0_FPC_rx__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define UART_0_FPC_rx_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define UART_0_FPC_rx_USBIO_DISABLE              ((uint32)(~UART_0_FPC_rx_USBIO_ENABLE))
S    #define UART_0_FPC_rx_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define UART_0_FPC_rx_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define UART_0_FPC_rx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_0_FPC_rx_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << UART_0_FPC_rx_USBIO_SUSPEND_DEL_SHIFT)))
X    #define UART_0_FPC_rx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_0_FPC_rx_USBIO_SUSPEND_SHIFT)                                                         | (1u << UART_0_FPC_rx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_0_FPC_rx_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << UART_0_FPC_rx_USBIO_SUSPEND_SHIFT)))
S    #define UART_0_FPC_rx_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << UART_0_FPC_rx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_0_FPC_rx_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(UART_0_FPC_rx__PC)
X#if 1L
N    /* Port Configuration */
N    #define UART_0_FPC_rx_PC                 (* (reg32 *) UART_0_FPC_rx__PC)
N#endif
N/* Pin State */
N#define UART_0_FPC_rx_PS                     (* (reg32 *) UART_0_FPC_rx__PS)
N/* Data Register */
N#define UART_0_FPC_rx_DR                     (* (reg32 *) UART_0_FPC_rx__DR)
N/* Input Buffer Disable Override */
N#define UART_0_FPC_rx_INP_DIS                (* (reg32 *) UART_0_FPC_rx__PC2)
N
N/* Interrupt configuration Registers */
N#define UART_0_FPC_rx_INTCFG                 (* (reg32 *) UART_0_FPC_rx__INTCFG)
N#define UART_0_FPC_rx_INTSTAT                (* (reg32 *) UART_0_FPC_rx__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define UART_0_FPC_rx_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(UART_0_FPC_rx__SIO)
X#if 0L
S    #define UART_0_FPC_rx_SIO_REG            (* (reg32 *) UART_0_FPC_rx__SIO)
N#endif /* (UART_0_FPC_rx__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(UART_0_FPC_rx__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define UART_0_FPC_rx_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define UART_0_FPC_rx_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define UART_0_FPC_rx_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define UART_0_FPC_rx_DRIVE_MODE_SHIFT       (0x00u)
N#define UART_0_FPC_rx_DRIVE_MODE_MASK        (0x07u << UART_0_FPC_rx_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins UART_0_FPC_rx_H */
N
N
N/* [] END OF FILE */
L 186 "Generated_Source\PSoC4\UART_0_FPC_PINS.h" 2
N#endif /* (UART_0_FPC_UART_RX_PIN) */
N
N#if (UART_0_FPC_UART_RX_WAKE_PIN)
X#if ((0u == (1u)))
S    #include "UART_0_FPC_rx_wake.h"
N#endif /* (UART_0_FPC_UART_RX_WAKE_PIN) */
N
N#if (UART_0_FPC_UART_RTS_PIN)
X#if ((0u == (1u)))
S    #include "UART_0_FPC_rts.h"
N#endif /* (UART_0_FPC_UART_RTS_PIN) */
N
N#if (UART_0_FPC_UART_CTS_PIN)
X#if ((0u == (1u)))
S    #include "UART_0_FPC_cts.h"
N#endif /* (UART_0_FPC_UART_CTS_PIN) */
N
N
N/***************************************
N*              Registers
N***************************************/
N
N#if (UART_0_FPC_RX_SCL_MOSI_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_RX_SCL_MOSI_HSIOM_REG   (*(reg32 *) UART_0_FPC_uart_rx_i2c_scl_spi_mosi__0__HSIOM)
S    #define UART_0_FPC_RX_SCL_MOSI_HSIOM_PTR   ( (reg32 *) UART_0_FPC_uart_rx_i2c_scl_spi_mosi__0__HSIOM)
S    
S    #define UART_0_FPC_RX_SCL_MOSI_HSIOM_MASK      (UART_0_FPC_uart_rx_i2c_scl_spi_mosi__0__HSIOM_MASK)
S    #define UART_0_FPC_RX_SCL_MOSI_HSIOM_POS       (UART_0_FPC_uart_rx_i2c_scl_spi_mosi__0__HSIOM_SHIFT)
S    #define UART_0_FPC_RX_SCL_MOSI_HSIOM_SEL_GPIO  (UART_0_FPC_uart_rx_i2c_scl_spi_mosi__0__HSIOM_GPIO)
S    #define UART_0_FPC_RX_SCL_MOSI_HSIOM_SEL_I2C   (UART_0_FPC_uart_rx_i2c_scl_spi_mosi__0__HSIOM_I2C)
S    #define UART_0_FPC_RX_SCL_MOSI_HSIOM_SEL_SPI   (UART_0_FPC_uart_rx_i2c_scl_spi_mosi__0__HSIOM_SPI)
S    #define UART_0_FPC_RX_SCL_MOSI_HSIOM_SEL_UART  (UART_0_FPC_uart_rx_i2c_scl_spi_mosi__0__HSIOM_UART)
S    
S#elif (UART_0_FPC_RX_WAKE_SCL_MOSI_PIN)
X#elif ((0u == (1u)))
S    #define UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_REG   (*(reg32 *) UART_0_FPC_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM)
S    #define UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_PTR   ( (reg32 *) UART_0_FPC_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM)
S    
S    #define UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_MASK      (UART_0_FPC_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_MASK)
S    #define UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_POS       (UART_0_FPC_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_SHIFT)
S    #define UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_SEL_GPIO  (UART_0_FPC_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_GPIO)
S    #define UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_SEL_I2C   (UART_0_FPC_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_I2C)
S    #define UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_SEL_SPI   (UART_0_FPC_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_SPI)
S    #define UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_SEL_UART  (UART_0_FPC_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_UART)    
S   
S    #define UART_0_FPC_RX_WAKE_SCL_MOSI_INTCFG_REG (*(reg32 *) UART_0_FPC_uart_rx_wake_i2c_scl_spi_mosi__0__INTCFG)
S    #define UART_0_FPC_RX_WAKE_SCL_MOSI_INTCFG_PTR ( (reg32 *) UART_0_FPC_uart_rx_wake_i2c_scl_spi_mosi__0__INTCFG)
S    #define UART_0_FPC_RX_WAKE_SCL_MOSI_INTCFG_TYPE_POS  (UART_0_FPC_uart_rx_wake_i2c_scl_spi_mosi__SHIFT)
S    #define UART_0_FPC_RX_WAKE_SCL_MOSI_INTCFG_TYPE_MASK ((uint32) UART_0_FPC_INTCFG_TYPE_MASK << \
S                                                                           UART_0_FPC_RX_WAKE_SCL_MOSI_INTCFG_TYPE_POS)
X    #define UART_0_FPC_RX_WAKE_SCL_MOSI_INTCFG_TYPE_MASK ((uint32) UART_0_FPC_INTCFG_TYPE_MASK <<                                                                            UART_0_FPC_RX_WAKE_SCL_MOSI_INTCFG_TYPE_POS)
N#else
N    /* None of pins UART_0_FPC_RX_SCL_MOSI_PIN or UART_0_FPC_RX_WAKE_SCL_MOSI_PIN present.*/
N#endif /* (UART_0_FPC_RX_SCL_MOSI_PIN) */
N
N#if (UART_0_FPC_TX_SDA_MISO_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_TX_SDA_MISO_HSIOM_REG   (*(reg32 *) UART_0_FPC_uart_tx_i2c_sda_spi_miso__0__HSIOM)
S    #define UART_0_FPC_TX_SDA_MISO_HSIOM_PTR   ( (reg32 *) UART_0_FPC_uart_tx_i2c_sda_spi_miso__0__HSIOM)
S    
S    #define UART_0_FPC_TX_SDA_MISO_HSIOM_MASK      (UART_0_FPC_uart_tx_i2c_sda_spi_miso__0__HSIOM_MASK)
S    #define UART_0_FPC_TX_SDA_MISO_HSIOM_POS       (UART_0_FPC_uart_tx_i2c_sda_spi_miso__0__HSIOM_SHIFT)
S    #define UART_0_FPC_TX_SDA_MISO_HSIOM_SEL_GPIO  (UART_0_FPC_uart_tx_i2c_sda_spi_miso__0__HSIOM_GPIO)
S    #define UART_0_FPC_TX_SDA_MISO_HSIOM_SEL_I2C   (UART_0_FPC_uart_tx_i2c_sda_spi_miso__0__HSIOM_I2C)
S    #define UART_0_FPC_TX_SDA_MISO_HSIOM_SEL_SPI   (UART_0_FPC_uart_tx_i2c_sda_spi_miso__0__HSIOM_SPI)
S    #define UART_0_FPC_TX_SDA_MISO_HSIOM_SEL_UART  (UART_0_FPC_uart_tx_i2c_sda_spi_miso__0__HSIOM_UART)
N#endif /* (UART_0_FPC_TX_SDA_MISO_PIN) */
N
N#if (UART_0_FPC_CTS_SCLK_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_CTS_SCLK_HSIOM_REG   (*(reg32 *) UART_0_FPC_uart_cts_spi_sclk__0__HSIOM)
S    #define UART_0_FPC_CTS_SCLK_HSIOM_PTR   ( (reg32 *) UART_0_FPC_uart_cts_spi_sclk__0__HSIOM)
S    
S    #define UART_0_FPC_CTS_SCLK_HSIOM_MASK      (UART_0_FPC_uart_cts_spi_sclk__0__HSIOM_MASK)
S    #define UART_0_FPC_CTS_SCLK_HSIOM_POS       (UART_0_FPC_uart_cts_spi_sclk__0__HSIOM_SHIFT)
S    #define UART_0_FPC_CTS_SCLK_HSIOM_SEL_GPIO  (UART_0_FPC_uart_cts_spi_sclk__0__HSIOM_GPIO)
S    #define UART_0_FPC_CTS_SCLK_HSIOM_SEL_I2C   (UART_0_FPC_uart_cts_spi_sclk__0__HSIOM_I2C)
S    #define UART_0_FPC_CTS_SCLK_HSIOM_SEL_SPI   (UART_0_FPC_uart_cts_spi_sclk__0__HSIOM_SPI)
S    #define UART_0_FPC_CTS_SCLK_HSIOM_SEL_UART  (UART_0_FPC_uart_cts_spi_sclk__0__HSIOM_UART)
N#endif /* (UART_0_FPC_CTS_SCLK_PIN) */
N
N#if (UART_0_FPC_RTS_SS0_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_RTS_SS0_HSIOM_REG   (*(reg32 *) UART_0_FPC_uart_rts_spi_ss0__0__HSIOM)
S    #define UART_0_FPC_RTS_SS0_HSIOM_PTR   ( (reg32 *) UART_0_FPC_uart_rts_spi_ss0__0__HSIOM)
S    
S    #define UART_0_FPC_RTS_SS0_HSIOM_MASK      (UART_0_FPC_uart_rts_spi_ss0__0__HSIOM_MASK)
S    #define UART_0_FPC_RTS_SS0_HSIOM_POS       (UART_0_FPC_uart_rts_spi_ss0__0__HSIOM_SHIFT)
S    #define UART_0_FPC_RTS_SS0_HSIOM_SEL_GPIO  (UART_0_FPC_uart_rts_spi_ss0__0__HSIOM_GPIO)
S    #define UART_0_FPC_RTS_SS0_HSIOM_SEL_I2C   (UART_0_FPC_uart_rts_spi_ss0__0__HSIOM_I2C)
S    #define UART_0_FPC_RTS_SS0_HSIOM_SEL_SPI   (UART_0_FPC_uart_rts_spi_ss0__0__HSIOM_SPI)
S#if !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1)
S    #define UART_0_FPC_RTS_SS0_HSIOM_SEL_UART  (UART_0_FPC_uart_rts_spi_ss0__0__HSIOM_UART)
S#endif /* !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1) */
N#endif /* (UART_0_FPC_RTS_SS0_PIN) */
N
N#if (UART_0_FPC_SS1_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_SS1_HSIOM_REG  (*(reg32 *) UART_0_FPC_spi_ss1__0__HSIOM)
S    #define UART_0_FPC_SS1_HSIOM_PTR  ( (reg32 *) UART_0_FPC_spi_ss1__0__HSIOM)
S    
S    #define UART_0_FPC_SS1_HSIOM_MASK     (UART_0_FPC_spi_ss1__0__HSIOM_MASK)
S    #define UART_0_FPC_SS1_HSIOM_POS      (UART_0_FPC_spi_ss1__0__HSIOM_SHIFT)
S    #define UART_0_FPC_SS1_HSIOM_SEL_GPIO (UART_0_FPC_spi_ss1__0__HSIOM_GPIO)
S    #define UART_0_FPC_SS1_HSIOM_SEL_I2C  (UART_0_FPC_spi_ss1__0__HSIOM_I2C)
S    #define UART_0_FPC_SS1_HSIOM_SEL_SPI  (UART_0_FPC_spi_ss1__0__HSIOM_SPI)
N#endif /* (UART_0_FPC_SS1_PIN) */
N
N#if (UART_0_FPC_SS2_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_SS2_HSIOM_REG     (*(reg32 *) UART_0_FPC_spi_ss2__0__HSIOM)
S    #define UART_0_FPC_SS2_HSIOM_PTR     ( (reg32 *) UART_0_FPC_spi_ss2__0__HSIOM)
S    
S    #define UART_0_FPC_SS2_HSIOM_MASK     (UART_0_FPC_spi_ss2__0__HSIOM_MASK)
S    #define UART_0_FPC_SS2_HSIOM_POS      (UART_0_FPC_spi_ss2__0__HSIOM_SHIFT)
S    #define UART_0_FPC_SS2_HSIOM_SEL_GPIO (UART_0_FPC_spi_ss2__0__HSIOM_GPIO)
S    #define UART_0_FPC_SS2_HSIOM_SEL_I2C  (UART_0_FPC_spi_ss2__0__HSIOM_I2C)
S    #define UART_0_FPC_SS2_HSIOM_SEL_SPI  (UART_0_FPC_spi_ss2__0__HSIOM_SPI)
N#endif /* (UART_0_FPC_SS2_PIN) */
N
N#if (UART_0_FPC_SS3_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_SS3_HSIOM_REG     (*(reg32 *) UART_0_FPC_spi_ss3__0__HSIOM)
S    #define UART_0_FPC_SS3_HSIOM_PTR     ( (reg32 *) UART_0_FPC_spi_ss3__0__HSIOM)
S    
S    #define UART_0_FPC_SS3_HSIOM_MASK     (UART_0_FPC_spi_ss3__0__HSIOM_MASK)
S    #define UART_0_FPC_SS3_HSIOM_POS      (UART_0_FPC_spi_ss3__0__HSIOM_SHIFT)
S    #define UART_0_FPC_SS3_HSIOM_SEL_GPIO (UART_0_FPC_spi_ss3__0__HSIOM_GPIO)
S    #define UART_0_FPC_SS3_HSIOM_SEL_I2C  (UART_0_FPC_spi_ss3__0__HSIOM_I2C)
S    #define UART_0_FPC_SS3_HSIOM_SEL_SPI  (UART_0_FPC_spi_ss3__0__HSIOM_SPI)
N#endif /* (UART_0_FPC_SS3_PIN) */
N
N#if (UART_0_FPC_I2C_PINS)
X#if ((0u == (1u)))
S    #define UART_0_FPC_SCL_HSIOM_REG  (*(reg32 *) UART_0_FPC_scl__0__HSIOM)
S    #define UART_0_FPC_SCL_HSIOM_PTR  ( (reg32 *) UART_0_FPC_scl__0__HSIOM)
S    
S    #define UART_0_FPC_SCL_HSIOM_MASK     (UART_0_FPC_scl__0__HSIOM_MASK)
S    #define UART_0_FPC_SCL_HSIOM_POS      (UART_0_FPC_scl__0__HSIOM_SHIFT)
S    #define UART_0_FPC_SCL_HSIOM_SEL_GPIO (UART_0_FPC_sda__0__HSIOM_GPIO)
S    #define UART_0_FPC_SCL_HSIOM_SEL_I2C  (UART_0_FPC_sda__0__HSIOM_I2C)
S    
S    #define UART_0_FPC_SDA_HSIOM_REG  (*(reg32 *) UART_0_FPC_sda__0__HSIOM)
S    #define UART_0_FPC_SDA_HSIOM_PTR  ( (reg32 *) UART_0_FPC_sda__0__HSIOM)
S    
S    #define UART_0_FPC_SDA_HSIOM_MASK     (UART_0_FPC_sda__0__HSIOM_MASK)
S    #define UART_0_FPC_SDA_HSIOM_POS      (UART_0_FPC_sda__0__HSIOM_SHIFT)
S    #define UART_0_FPC_SDA_HSIOM_SEL_GPIO (UART_0_FPC_sda__0__HSIOM_GPIO)
S    #define UART_0_FPC_SDA_HSIOM_SEL_I2C  (UART_0_FPC_sda__0__HSIOM_I2C)
N#endif /* (UART_0_FPC_I2C_PINS) */
N
N#if (UART_0_FPC_SPI_SLAVE_PINS)
X#if ((0u == (1u)))
S    #define UART_0_FPC_SCLK_S_HSIOM_REG   (*(reg32 *) UART_0_FPC_sclk_s__0__HSIOM)
S    #define UART_0_FPC_SCLK_S_HSIOM_PTR   ( (reg32 *) UART_0_FPC_sclk_s__0__HSIOM)
S    
S    #define UART_0_FPC_SCLK_S_HSIOM_MASK      (UART_0_FPC_sclk_s__0__HSIOM_MASK)
S    #define UART_0_FPC_SCLK_S_HSIOM_POS       (UART_0_FPC_sclk_s__0__HSIOM_SHIFT)
S    #define UART_0_FPC_SCLK_S_HSIOM_SEL_GPIO  (UART_0_FPC_sclk_s__0__HSIOM_GPIO)
S    #define UART_0_FPC_SCLK_S_HSIOM_SEL_SPI   (UART_0_FPC_sclk_s__0__HSIOM_SPI)
S    
S    #define UART_0_FPC_SS0_S_HSIOM_REG    (*(reg32 *) UART_0_FPC_ss0_s__0__HSIOM)
S    #define UART_0_FPC_SS0_S_HSIOM_PTR    ( (reg32 *) UART_0_FPC_ss0_s__0__HSIOM)
S    
S    #define UART_0_FPC_SS0_S_HSIOM_MASK       (UART_0_FPC_ss0_s__0__HSIOM_MASK)
S    #define UART_0_FPC_SS0_S_HSIOM_POS        (UART_0_FPC_ss0_s__0__HSIOM_SHIFT)
S    #define UART_0_FPC_SS0_S_HSIOM_SEL_GPIO   (UART_0_FPC_ss0_s__0__HSIOM_GPIO)  
S    #define UART_0_FPC_SS0_S_HSIOM_SEL_SPI    (UART_0_FPC_ss0_s__0__HSIOM_SPI)
N#endif /* (UART_0_FPC_SPI_SLAVE_PINS) */
N
N#if (UART_0_FPC_SPI_SLAVE_MOSI_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_MOSI_S_HSIOM_REG   (*(reg32 *) UART_0_FPC_mosi_s__0__HSIOM)
S    #define UART_0_FPC_MOSI_S_HSIOM_PTR   ( (reg32 *) UART_0_FPC_mosi_s__0__HSIOM)
S    
S    #define UART_0_FPC_MOSI_S_HSIOM_MASK      (UART_0_FPC_mosi_s__0__HSIOM_MASK)
S    #define UART_0_FPC_MOSI_S_HSIOM_POS       (UART_0_FPC_mosi_s__0__HSIOM_SHIFT)
S    #define UART_0_FPC_MOSI_S_HSIOM_SEL_GPIO  (UART_0_FPC_mosi_s__0__HSIOM_GPIO)
S    #define UART_0_FPC_MOSI_S_HSIOM_SEL_SPI   (UART_0_FPC_mosi_s__0__HSIOM_SPI)
N#endif /* (UART_0_FPC_SPI_SLAVE_MOSI_PIN) */
N
N#if (UART_0_FPC_SPI_SLAVE_MISO_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_MISO_S_HSIOM_REG   (*(reg32 *) UART_0_FPC_miso_s__0__HSIOM)
S    #define UART_0_FPC_MISO_S_HSIOM_PTR   ( (reg32 *) UART_0_FPC_miso_s__0__HSIOM)
S    
S    #define UART_0_FPC_MISO_S_HSIOM_MASK      (UART_0_FPC_miso_s__0__HSIOM_MASK)
S    #define UART_0_FPC_MISO_S_HSIOM_POS       (UART_0_FPC_miso_s__0__HSIOM_SHIFT)
S    #define UART_0_FPC_MISO_S_HSIOM_SEL_GPIO  (UART_0_FPC_miso_s__0__HSIOM_GPIO)
S    #define UART_0_FPC_MISO_S_HSIOM_SEL_SPI   (UART_0_FPC_miso_s__0__HSIOM_SPI)
N#endif /* (UART_0_FPC_SPI_SLAVE_MISO_PIN) */
N
N#if (UART_0_FPC_SPI_MASTER_MISO_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_MISO_M_HSIOM_REG   (*(reg32 *) UART_0_FPC_miso_m__0__HSIOM)
S    #define UART_0_FPC_MISO_M_HSIOM_PTR   ( (reg32 *) UART_0_FPC_miso_m__0__HSIOM)
S    
S    #define UART_0_FPC_MISO_M_HSIOM_MASK      (UART_0_FPC_miso_m__0__HSIOM_MASK)
S    #define UART_0_FPC_MISO_M_HSIOM_POS       (UART_0_FPC_miso_m__0__HSIOM_SHIFT)
S    #define UART_0_FPC_MISO_M_HSIOM_SEL_GPIO  (UART_0_FPC_miso_m__0__HSIOM_GPIO)
S    #define UART_0_FPC_MISO_M_HSIOM_SEL_SPI   (UART_0_FPC_miso_m__0__HSIOM_SPI)
N#endif /* (UART_0_FPC_SPI_MASTER_MISO_PIN) */
N
N#if (UART_0_FPC_SPI_MASTER_MOSI_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_MOSI_M_HSIOM_REG   (*(reg32 *) UART_0_FPC_mosi_m__0__HSIOM)
S    #define UART_0_FPC_MOSI_M_HSIOM_PTR   ( (reg32 *) UART_0_FPC_mosi_m__0__HSIOM)
S    
S    #define UART_0_FPC_MOSI_M_HSIOM_MASK      (UART_0_FPC_mosi_m__0__HSIOM_MASK)
S    #define UART_0_FPC_MOSI_M_HSIOM_POS       (UART_0_FPC_mosi_m__0__HSIOM_SHIFT)
S    #define UART_0_FPC_MOSI_M_HSIOM_SEL_GPIO  (UART_0_FPC_mosi_m__0__HSIOM_GPIO)
S    #define UART_0_FPC_MOSI_M_HSIOM_SEL_SPI   (UART_0_FPC_mosi_m__0__HSIOM_SPI)
N#endif /* (UART_0_FPC_SPI_MASTER_MOSI_PIN) */
N
N#if (UART_0_FPC_SPI_MASTER_SCLK_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_SCLK_M_HSIOM_REG   (*(reg32 *) UART_0_FPC_sclk_m__0__HSIOM)
S    #define UART_0_FPC_SCLK_M_HSIOM_PTR   ( (reg32 *) UART_0_FPC_sclk_m__0__HSIOM)
S    
S    #define UART_0_FPC_SCLK_M_HSIOM_MASK      (UART_0_FPC_sclk_m__0__HSIOM_MASK)
S    #define UART_0_FPC_SCLK_M_HSIOM_POS       (UART_0_FPC_sclk_m__0__HSIOM_SHIFT)
S    #define UART_0_FPC_SCLK_M_HSIOM_SEL_GPIO  (UART_0_FPC_sclk_m__0__HSIOM_GPIO)
S    #define UART_0_FPC_SCLK_M_HSIOM_SEL_SPI   (UART_0_FPC_sclk_m__0__HSIOM_SPI)
N#endif /* (UART_0_FPC_SPI_MASTER_SCLK_PIN) */
N
N#if (UART_0_FPC_SPI_MASTER_SS0_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_SS0_M_HSIOM_REG    (*(reg32 *) UART_0_FPC_ss0_m__0__HSIOM)
S    #define UART_0_FPC_SS0_M_HSIOM_PTR    ( (reg32 *) UART_0_FPC_ss0_m__0__HSIOM)
S    
S    #define UART_0_FPC_SS0_M_HSIOM_MASK       (UART_0_FPC_ss0_m__0__HSIOM_MASK)
S    #define UART_0_FPC_SS0_M_HSIOM_POS        (UART_0_FPC_ss0_m__0__HSIOM_SHIFT)
S    #define UART_0_FPC_SS0_M_HSIOM_SEL_GPIO   (UART_0_FPC_ss0_m__0__HSIOM_GPIO)
S    #define UART_0_FPC_SS0_M_HSIOM_SEL_SPI    (UART_0_FPC_ss0_m__0__HSIOM_SPI)
N#endif /* (UART_0_FPC_SPI_MASTER_SS0_PIN) */
N
N#if (UART_0_FPC_SPI_MASTER_SS1_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_SS1_M_HSIOM_REG    (*(reg32 *) UART_0_FPC_ss1_m__0__HSIOM)
S    #define UART_0_FPC_SS1_M_HSIOM_PTR    ( (reg32 *) UART_0_FPC_ss1_m__0__HSIOM)
S    
S    #define UART_0_FPC_SS1_M_HSIOM_MASK       (UART_0_FPC_ss1_m__0__HSIOM_MASK)
S    #define UART_0_FPC_SS1_M_HSIOM_POS        (UART_0_FPC_ss1_m__0__HSIOM_SHIFT)
S    #define UART_0_FPC_SS1_M_HSIOM_SEL_GPIO   (UART_0_FPC_ss1_m__0__HSIOM_GPIO)
S    #define UART_0_FPC_SS1_M_HSIOM_SEL_SPI    (UART_0_FPC_ss1_m__0__HSIOM_SPI)
N#endif /* (UART_0_FPC_SPI_MASTER_SS1_PIN) */
N
N#if (UART_0_FPC_SPI_MASTER_SS2_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_SS2_M_HSIOM_REG    (*(reg32 *) UART_0_FPC_ss2_m__0__HSIOM)
S    #define UART_0_FPC_SS2_M_HSIOM_PTR    ( (reg32 *) UART_0_FPC_ss2_m__0__HSIOM)
S    
S    #define UART_0_FPC_SS2_M_HSIOM_MASK       (UART_0_FPC_ss2_m__0__HSIOM_MASK)
S    #define UART_0_FPC_SS2_M_HSIOM_POS        (UART_0_FPC_ss2_m__0__HSIOM_SHIFT)
S    #define UART_0_FPC_SS2_M_HSIOM_SEL_GPIO   (UART_0_FPC_ss2_m__0__HSIOM_GPIO)
S    #define UART_0_FPC_SS2_M_HSIOM_SEL_SPI    (UART_0_FPC_ss2_m__0__HSIOM_SPI)
N#endif /* (UART_0_FPC_SPI_MASTER_SS2_PIN) */
N
N#if (UART_0_FPC_SPI_MASTER_SS3_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_SS3_M_HSIOM_REG    (*(reg32 *) UART_0_FPC_ss3_m__0__HSIOM)
S    #define UART_0_FPC_SS3_M_HSIOM_PTR    ( (reg32 *) UART_0_FPC_ss3_m__0__HSIOM)
S    
S    #define UART_0_FPC_SS3_M_HSIOM_MASK      (UART_0_FPC_ss3_m__0__HSIOM_MASK)
S    #define UART_0_FPC_SS3_M_HSIOM_POS       (UART_0_FPC_ss3_m__0__HSIOM_SHIFT)
S    #define UART_0_FPC_SS3_M_HSIOM_SEL_GPIO  (UART_0_FPC_ss3_m__0__HSIOM_GPIO)
S    #define UART_0_FPC_SS3_M_HSIOM_SEL_SPI   (UART_0_FPC_ss3_m__0__HSIOM_SPI)
N#endif /* (UART_0_FPC_SPI_MASTER_SS3_PIN) */
N
N#if (UART_0_FPC_UART_RX_PIN)
X#if ((0u == (0u)))
N    #define UART_0_FPC_RX_HSIOM_REG   (*(reg32 *) UART_0_FPC_rx__0__HSIOM)
N    #define UART_0_FPC_RX_HSIOM_PTR   ( (reg32 *) UART_0_FPC_rx__0__HSIOM)
N    
N    #define UART_0_FPC_RX_HSIOM_MASK      (UART_0_FPC_rx__0__HSIOM_MASK)
N    #define UART_0_FPC_RX_HSIOM_POS       (UART_0_FPC_rx__0__HSIOM_SHIFT)
N    #define UART_0_FPC_RX_HSIOM_SEL_GPIO  (UART_0_FPC_rx__0__HSIOM_GPIO)
N    #define UART_0_FPC_RX_HSIOM_SEL_UART  (UART_0_FPC_rx__0__HSIOM_UART)
N#endif /* (UART_0_FPC_UART_RX_PIN) */
N
N#if (UART_0_FPC_UART_RX_WAKE_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_RX_WAKE_HSIOM_REG   (*(reg32 *) UART_0_FPC_rx_wake__0__HSIOM)
S    #define UART_0_FPC_RX_WAKE_HSIOM_PTR   ( (reg32 *) UART_0_FPC_rx_wake__0__HSIOM)
S    
S    #define UART_0_FPC_RX_WAKE_HSIOM_MASK      (UART_0_FPC_rx_wake__0__HSIOM_MASK)
S    #define UART_0_FPC_RX_WAKE_HSIOM_POS       (UART_0_FPC_rx_wake__0__HSIOM_SHIFT)
S    #define UART_0_FPC_RX_WAKE_HSIOM_SEL_GPIO  (UART_0_FPC_rx_wake__0__HSIOM_GPIO)
S    #define UART_0_FPC_RX_WAKE_HSIOM_SEL_UART  (UART_0_FPC_rx_wake__0__HSIOM_UART)
N#endif /* (UART_0_FPC_UART_WAKE_RX_PIN) */
N
N#if (UART_0_FPC_UART_CTS_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_CTS_HSIOM_REG   (*(reg32 *) UART_0_FPC_cts__0__HSIOM)
S    #define UART_0_FPC_CTS_HSIOM_PTR   ( (reg32 *) UART_0_FPC_cts__0__HSIOM)
S    
S    #define UART_0_FPC_CTS_HSIOM_MASK      (UART_0_FPC_cts__0__HSIOM_MASK)
S    #define UART_0_FPC_CTS_HSIOM_POS       (UART_0_FPC_cts__0__HSIOM_SHIFT)
S    #define UART_0_FPC_CTS_HSIOM_SEL_GPIO  (UART_0_FPC_cts__0__HSIOM_GPIO)
S    #define UART_0_FPC_CTS_HSIOM_SEL_UART  (UART_0_FPC_cts__0__HSIOM_UART)
N#endif /* (UART_0_FPC_UART_CTS_PIN) */
N
N#if (UART_0_FPC_UART_TX_PIN)
X#if ((0u == (0u)))
N    #define UART_0_FPC_TX_HSIOM_REG   (*(reg32 *) UART_0_FPC_tx__0__HSIOM)
N    #define UART_0_FPC_TX_HSIOM_PTR   ( (reg32 *) UART_0_FPC_tx__0__HSIOM)
N    
N    #define UART_0_FPC_TX_HSIOM_MASK      (UART_0_FPC_tx__0__HSIOM_MASK)
N    #define UART_0_FPC_TX_HSIOM_POS       (UART_0_FPC_tx__0__HSIOM_SHIFT)
N    #define UART_0_FPC_TX_HSIOM_SEL_GPIO  (UART_0_FPC_tx__0__HSIOM_GPIO)
N    #define UART_0_FPC_TX_HSIOM_SEL_UART  (UART_0_FPC_tx__0__HSIOM_UART)
N#endif /* (UART_0_FPC_UART_TX_PIN) */
N
N#if (UART_0_FPC_UART_RX_TX_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_RX_TX_HSIOM_REG   (*(reg32 *) UART_0_FPC_rx_tx__0__HSIOM)
S    #define UART_0_FPC_RX_TX_HSIOM_PTR   ( (reg32 *) UART_0_FPC_rx_tx__0__HSIOM)
S    
S    #define UART_0_FPC_RX_TX_HSIOM_MASK      (UART_0_FPC_rx_tx__0__HSIOM_MASK)
S    #define UART_0_FPC_RX_TX_HSIOM_POS       (UART_0_FPC_rx_tx__0__HSIOM_SHIFT)
S    #define UART_0_FPC_RX_TX_HSIOM_SEL_GPIO  (UART_0_FPC_rx_tx__0__HSIOM_GPIO)
S    #define UART_0_FPC_RX_TX_HSIOM_SEL_UART  (UART_0_FPC_rx_tx__0__HSIOM_UART)
N#endif /* (UART_0_FPC_UART_RX_TX_PIN) */
N
N#if (UART_0_FPC_UART_RTS_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_RTS_HSIOM_REG      (*(reg32 *) UART_0_FPC_rts__0__HSIOM)
S    #define UART_0_FPC_RTS_HSIOM_PTR      ( (reg32 *) UART_0_FPC_rts__0__HSIOM)
S    
S    #define UART_0_FPC_RTS_HSIOM_MASK     (UART_0_FPC_rts__0__HSIOM_MASK)
S    #define UART_0_FPC_RTS_HSIOM_POS      (UART_0_FPC_rts__0__HSIOM_SHIFT)    
S    #define UART_0_FPC_RTS_HSIOM_SEL_GPIO (UART_0_FPC_rts__0__HSIOM_GPIO)
S    #define UART_0_FPC_RTS_HSIOM_SEL_UART (UART_0_FPC_rts__0__HSIOM_UART)    
N#endif /* (UART_0_FPC_UART_RTS_PIN) */
N
N
N/***************************************
N*        Registers Constants
N***************************************/
N
N/* HSIOM switch values. */ 
N#define UART_0_FPC_HSIOM_DEF_SEL      (0x00u)
N#define UART_0_FPC_HSIOM_GPIO_SEL     (0x00u)
N/* The HSIOM values provided below are valid only for UART_0_FPC_CY_SCBIP_V0 
N* and UART_0_FPC_CY_SCBIP_V1. It is not recommended to use them for 
N* UART_0_FPC_CY_SCBIP_V2. Use pin name specific HSIOM constants provided 
N* above instead for any SCB IP block version.
N*/
N#define UART_0_FPC_HSIOM_UART_SEL     (0x09u)
N#define UART_0_FPC_HSIOM_I2C_SEL      (0x0Eu)
N#define UART_0_FPC_HSIOM_SPI_SEL      (0x0Fu)
N
N/* Pins settings index. */
N#define UART_0_FPC_RX_WAKE_SCL_MOSI_PIN_INDEX   (0u)
N#define UART_0_FPC_RX_SCL_MOSI_PIN_INDEX       (0u)
N#define UART_0_FPC_TX_SDA_MISO_PIN_INDEX       (1u)
N#define UART_0_FPC_CTS_SCLK_PIN_INDEX       (2u)
N#define UART_0_FPC_RTS_SS0_PIN_INDEX       (3u)
N#define UART_0_FPC_SS1_PIN_INDEX                  (4u)
N#define UART_0_FPC_SS2_PIN_INDEX                  (5u)
N#define UART_0_FPC_SS3_PIN_INDEX                  (6u)
N
N/* Pins settings mask. */
N#define UART_0_FPC_RX_WAKE_SCL_MOSI_PIN_MASK ((uint32) 0x01u << UART_0_FPC_RX_WAKE_SCL_MOSI_PIN_INDEX)
N#define UART_0_FPC_RX_SCL_MOSI_PIN_MASK     ((uint32) 0x01u << UART_0_FPC_RX_SCL_MOSI_PIN_INDEX)
N#define UART_0_FPC_TX_SDA_MISO_PIN_MASK     ((uint32) 0x01u << UART_0_FPC_TX_SDA_MISO_PIN_INDEX)
N#define UART_0_FPC_CTS_SCLK_PIN_MASK     ((uint32) 0x01u << UART_0_FPC_CTS_SCLK_PIN_INDEX)
N#define UART_0_FPC_RTS_SS0_PIN_MASK     ((uint32) 0x01u << UART_0_FPC_RTS_SS0_PIN_INDEX)
N#define UART_0_FPC_SS1_PIN_MASK                ((uint32) 0x01u << UART_0_FPC_SS1_PIN_INDEX)
N#define UART_0_FPC_SS2_PIN_MASK                ((uint32) 0x01u << UART_0_FPC_SS2_PIN_INDEX)
N#define UART_0_FPC_SS3_PIN_MASK                ((uint32) 0x01u << UART_0_FPC_SS3_PIN_INDEX)
N
N/* Pin interrupt constants. */
N#define UART_0_FPC_INTCFG_TYPE_MASK           (0x03u)
N#define UART_0_FPC_INTCFG_TYPE_FALLING_EDGE   (0x02u)
N
N/* Pin Drive Mode constants. */
N#define UART_0_FPC_PIN_DM_ALG_HIZ  (0u)
N#define UART_0_FPC_PIN_DM_DIG_HIZ  (1u)
N#define UART_0_FPC_PIN_DM_OD_LO    (4u)
N#define UART_0_FPC_PIN_DM_STRONG   (6u)
N
N
N/***************************************
N*          Macro Definitions
N***************************************/
N
N/* Return drive mode of the pin */
N#define UART_0_FPC_DM_MASK    (0x7u)
N#define UART_0_FPC_DM_SIZE    (3u)
N#define UART_0_FPC_GET_P4_PIN_DM(reg, pos) \
N    ( ((reg) & (uint32) ((uint32) UART_0_FPC_DM_MASK << (UART_0_FPC_DM_SIZE * (pos)))) >> \
N                                                              (UART_0_FPC_DM_SIZE * (pos)) )
X#define UART_0_FPC_GET_P4_PIN_DM(reg, pos)     ( ((reg) & (uint32) ((uint32) UART_0_FPC_DM_MASK << (UART_0_FPC_DM_SIZE * (pos)))) >>                                                               (UART_0_FPC_DM_SIZE * (pos)) )
N
N#if (UART_0_FPC_TX_SDA_MISO_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_CHECK_TX_SDA_MISO_PIN_USED \
S                (UART_0_FPC_PIN_DM_ALG_HIZ != \
S                    UART_0_FPC_GET_P4_PIN_DM(UART_0_FPC_uart_tx_i2c_sda_spi_miso_PC, \
S                                                   UART_0_FPC_uart_tx_i2c_sda_spi_miso_SHIFT))
X    #define UART_0_FPC_CHECK_TX_SDA_MISO_PIN_USED                 (UART_0_FPC_PIN_DM_ALG_HIZ !=                     UART_0_FPC_GET_P4_PIN_DM(UART_0_FPC_uart_tx_i2c_sda_spi_miso_PC,                                                    UART_0_FPC_uart_tx_i2c_sda_spi_miso_SHIFT))
N#endif /* (UART_0_FPC_TX_SDA_MISO_PIN) */
N
N#if (UART_0_FPC_RTS_SS0_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_CHECK_RTS_SS0_PIN_USED \
S                (UART_0_FPC_PIN_DM_ALG_HIZ != \
S                    UART_0_FPC_GET_P4_PIN_DM(UART_0_FPC_uart_rts_spi_ss0_PC, \
S                                                   UART_0_FPC_uart_rts_spi_ss0_SHIFT))
X    #define UART_0_FPC_CHECK_RTS_SS0_PIN_USED                 (UART_0_FPC_PIN_DM_ALG_HIZ !=                     UART_0_FPC_GET_P4_PIN_DM(UART_0_FPC_uart_rts_spi_ss0_PC,                                                    UART_0_FPC_uart_rts_spi_ss0_SHIFT))
N#endif /* (UART_0_FPC_RTS_SS0_PIN) */
N
N/* Set bits-mask in register */
N#define UART_0_FPC_SET_REGISTER_BITS(reg, mask, pos, mode) \
N                    do                                           \
N                    {                                            \
N                        (reg) = (((reg) & ((uint32) ~(uint32) (mask))) | ((uint32) ((uint32) (mode) << (pos)))); \
N                    }while(0)
X#define UART_0_FPC_SET_REGISTER_BITS(reg, mask, pos, mode)                     do                                                               {                                                                    (reg) = (((reg) & ((uint32) ~(uint32) (mask))) | ((uint32) ((uint32) (mode) << (pos))));                     }while(0)
N
N/* Set bit in the register */
N#define UART_0_FPC_SET_REGISTER_BIT(reg, mask, val) \
N                    ((val) ? ((reg) |= (mask)) : ((reg) &= ((uint32) ~((uint32) (mask)))))
X#define UART_0_FPC_SET_REGISTER_BIT(reg, mask, val)                     ((val) ? ((reg) |= (mask)) : ((reg) &= ((uint32) ~((uint32) (mask)))))
N
N#define UART_0_FPC_SET_HSIOM_SEL(reg, mask, pos, sel) UART_0_FPC_SET_REGISTER_BITS(reg, mask, pos, sel)
N#define UART_0_FPC_SET_INCFG_TYPE(reg, mask, pos, intType) \
N                                                        UART_0_FPC_SET_REGISTER_BITS(reg, mask, pos, intType)
X#define UART_0_FPC_SET_INCFG_TYPE(reg, mask, pos, intType)                                                         UART_0_FPC_SET_REGISTER_BITS(reg, mask, pos, intType)
N#define UART_0_FPC_SET_INP_DIS(reg, mask, val) UART_0_FPC_SET_REGISTER_BIT(reg, mask, val)
N
N/* UART_0_FPC_SET_I2C_SCL_DR(val) - Sets I2C SCL DR register.
N*  UART_0_FPC_SET_I2C_SCL_HSIOM_SEL(sel) - Sets I2C SCL HSIOM settings.
N*/
N/* SCB I2C: scl signal */
N#if (UART_0_FPC_CY_SCBIP_V0)
X#if ((2 == 0u))
S#if (UART_0_FPC_I2C_PINS)
S    #define UART_0_FPC_SET_I2C_SCL_DR(val) UART_0_FPC_scl_Write(val)
S
S    #define UART_0_FPC_SET_I2C_SCL_HSIOM_SEL(sel) \
S                          UART_0_FPC_SET_HSIOM_SEL(UART_0_FPC_SCL_HSIOM_REG,  \
S                                                         UART_0_FPC_SCL_HSIOM_MASK, \
S                                                         UART_0_FPC_SCL_HSIOM_POS,  \
S                                                         (sel))
X    #define UART_0_FPC_SET_I2C_SCL_HSIOM_SEL(sel)                           UART_0_FPC_SET_HSIOM_SEL(UART_0_FPC_SCL_HSIOM_REG,                                                           UART_0_FPC_SCL_HSIOM_MASK,                                                          UART_0_FPC_SCL_HSIOM_POS,                                                           (sel))
S    #define UART_0_FPC_WAIT_SCL_SET_HIGH  (0u == UART_0_FPC_scl_Read())
S
S/* Unconfigured SCB: scl signal */
S#elif (UART_0_FPC_RX_WAKE_SCL_MOSI_PIN)
S    #define UART_0_FPC_SET_I2C_SCL_DR(val) \
S                            UART_0_FPC_uart_rx_wake_i2c_scl_spi_mosi_Write(val)
X    #define UART_0_FPC_SET_I2C_SCL_DR(val)                             UART_0_FPC_uart_rx_wake_i2c_scl_spi_mosi_Write(val)
S
S    #define UART_0_FPC_SET_I2C_SCL_HSIOM_SEL(sel) \
S                    UART_0_FPC_SET_HSIOM_SEL(UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_REG,  \
S                                                   UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_MASK, \
S                                                   UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_POS,  \
S                                                   (sel))
X    #define UART_0_FPC_SET_I2C_SCL_HSIOM_SEL(sel)                     UART_0_FPC_SET_HSIOM_SEL(UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_REG,                                                     UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_MASK,                                                    UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_POS,                                                     (sel))
S
S    #define UART_0_FPC_WAIT_SCL_SET_HIGH  (0u == UART_0_FPC_uart_rx_wake_i2c_scl_spi_mosi_Read())
S
S#elif (UART_0_FPC_RX_SCL_MOSI_PIN)
S    #define UART_0_FPC_SET_I2C_SCL_DR(val) \
S                            UART_0_FPC_uart_rx_i2c_scl_spi_mosi_Write(val)
X    #define UART_0_FPC_SET_I2C_SCL_DR(val)                             UART_0_FPC_uart_rx_i2c_scl_spi_mosi_Write(val)
S
S
S    #define UART_0_FPC_SET_I2C_SCL_HSIOM_SEL(sel) \
S                            UART_0_FPC_SET_HSIOM_SEL(UART_0_FPC_RX_SCL_MOSI_HSIOM_REG,  \
S                                                           UART_0_FPC_RX_SCL_MOSI_HSIOM_MASK, \
S                                                           UART_0_FPC_RX_SCL_MOSI_HSIOM_POS,  \
S                                                           (sel))
X    #define UART_0_FPC_SET_I2C_SCL_HSIOM_SEL(sel)                             UART_0_FPC_SET_HSIOM_SEL(UART_0_FPC_RX_SCL_MOSI_HSIOM_REG,                                                             UART_0_FPC_RX_SCL_MOSI_HSIOM_MASK,                                                            UART_0_FPC_RX_SCL_MOSI_HSIOM_POS,                                                             (sel))
S
S    #define UART_0_FPC_WAIT_SCL_SET_HIGH  (0u == UART_0_FPC_uart_rx_i2c_scl_spi_mosi_Read())
S
S#else
S    #define UART_0_FPC_SET_I2C_SCL_DR(val)        do{ /* Does nothing */ }while(0)
S    #define UART_0_FPC_SET_I2C_SCL_HSIOM_SEL(sel) do{ /* Does nothing */ }while(0)
S
S    #define UART_0_FPC_WAIT_SCL_SET_HIGH  (0u)
S#endif /* (UART_0_FPC_I2C_PINS) */
S
S/* SCB I2C: sda signal */
S#if (UART_0_FPC_I2C_PINS)
S    #define UART_0_FPC_WAIT_SDA_SET_HIGH  (0u == UART_0_FPC_sda_Read())
S/* Unconfigured SCB: sda signal */
S#elif (UART_0_FPC_TX_SDA_MISO_PIN)
S    #define UART_0_FPC_WAIT_SDA_SET_HIGH  (0u == UART_0_FPC_uart_tx_i2c_sda_spi_miso_Read())
S#else
S    #define UART_0_FPC_WAIT_SDA_SET_HIGH  (0u)
S#endif /* (UART_0_FPC_MOSI_SCL_RX_PIN) */
N#endif /* (UART_0_FPC_CY_SCBIP_V0) */
N
N/* Clear UART wakeup source */
N#if (UART_0_FPC_RX_SCL_MOSI_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_CLEAR_UART_RX_WAKE_INTR        do{ /* Does nothing */ }while(0)
S    
S#elif (UART_0_FPC_RX_WAKE_SCL_MOSI_PIN)
X#elif ((0u == (1u)))
S    #define UART_0_FPC_CLEAR_UART_RX_WAKE_INTR \
S            do{                                      \
S                (void) UART_0_FPC_uart_rx_wake_i2c_scl_spi_mosi_ClearInterrupt(); \
S            }while(0)
X    #define UART_0_FPC_CLEAR_UART_RX_WAKE_INTR             do{                                                      (void) UART_0_FPC_uart_rx_wake_i2c_scl_spi_mosi_ClearInterrupt();             }while(0)
S
S#elif(UART_0_FPC_UART_RX_WAKE_PIN)
X#elif((0u == (1u)))
S    #define UART_0_FPC_CLEAR_UART_RX_WAKE_INTR \
S            do{                                      \
S                (void) UART_0_FPC_rx_wake_ClearInterrupt(); \
S            }while(0)
X    #define UART_0_FPC_CLEAR_UART_RX_WAKE_INTR             do{                                                      (void) UART_0_FPC_rx_wake_ClearInterrupt();             }while(0)
N#else
N#endif /* (UART_0_FPC_RX_SCL_MOSI_PIN) */
N
N
N/***************************************
N* The following code is DEPRECATED and
N* must not be used.
N***************************************/
N
N/* Unconfigured pins */
N#define UART_0_FPC_REMOVE_MOSI_SCL_RX_WAKE_PIN    UART_0_FPC_REMOVE_RX_WAKE_SCL_MOSI_PIN
N#define UART_0_FPC_REMOVE_MOSI_SCL_RX_PIN         UART_0_FPC_REMOVE_RX_SCL_MOSI_PIN
N#define UART_0_FPC_REMOVE_MISO_SDA_TX_PIN         UART_0_FPC_REMOVE_TX_SDA_MISO_PIN
N#ifndef UART_0_FPC_REMOVE_SCLK_PIN
N#define UART_0_FPC_REMOVE_SCLK_PIN                UART_0_FPC_REMOVE_CTS_SCLK_PIN
N#endif /* UART_0_FPC_REMOVE_SCLK_PIN */
N#ifndef UART_0_FPC_REMOVE_SS0_PIN
N#define UART_0_FPC_REMOVE_SS0_PIN                 UART_0_FPC_REMOVE_RTS_SS0_PIN
N#endif /* UART_0_FPC_REMOVE_SS0_PIN */
N
N/* Unconfigured pins */
N#define UART_0_FPC_MOSI_SCL_RX_WAKE_PIN   UART_0_FPC_RX_WAKE_SCL_MOSI_PIN
N#define UART_0_FPC_MOSI_SCL_RX_PIN        UART_0_FPC_RX_SCL_MOSI_PIN
N#define UART_0_FPC_MISO_SDA_TX_PIN        UART_0_FPC_TX_SDA_MISO_PIN
N#ifndef UART_0_FPC_SCLK_PIN
N#define UART_0_FPC_SCLK_PIN               UART_0_FPC_CTS_SCLK_PIN
N#endif /* UART_0_FPC_SCLK_PIN */
N#ifndef UART_0_FPC_SS0_PIN
N#define UART_0_FPC_SS0_PIN                UART_0_FPC_RTS_SS0_PIN
N#endif /* UART_0_FPC_SS0_PIN */
N
N#if (UART_0_FPC_MOSI_SCL_RX_WAKE_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_MOSI_SCL_RX_WAKE_HSIOM_REG     UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define UART_0_FPC_MOSI_SCL_RX_WAKE_HSIOM_PTR     UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define UART_0_FPC_MOSI_SCL_RX_WAKE_HSIOM_MASK    UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define UART_0_FPC_MOSI_SCL_RX_WAKE_HSIOM_POS     UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_REG
S
S    #define UART_0_FPC_MOSI_SCL_RX_WAKE_INTCFG_REG    UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define UART_0_FPC_MOSI_SCL_RX_WAKE_INTCFG_PTR    UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_REG
S
S    #define UART_0_FPC_MOSI_SCL_RX_WAKE_INTCFG_TYPE_POS   UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define UART_0_FPC_MOSI_SCL_RX_WAKE_INTCFG_TYPE_MASK  UART_0_FPC_RX_WAKE_SCL_MOSI_HSIOM_REG
N#endif /* (UART_0_FPC_RX_WAKE_SCL_MOSI_PIN) */
N
N#if (UART_0_FPC_MOSI_SCL_RX_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_MOSI_SCL_RX_HSIOM_REG      UART_0_FPC_RX_SCL_MOSI_HSIOM_REG
S    #define UART_0_FPC_MOSI_SCL_RX_HSIOM_PTR      UART_0_FPC_RX_SCL_MOSI_HSIOM_PTR
S    #define UART_0_FPC_MOSI_SCL_RX_HSIOM_MASK     UART_0_FPC_RX_SCL_MOSI_HSIOM_MASK
S    #define UART_0_FPC_MOSI_SCL_RX_HSIOM_POS      UART_0_FPC_RX_SCL_MOSI_HSIOM_POS
N#endif /* (UART_0_FPC_MOSI_SCL_RX_PIN) */
N
N#if (UART_0_FPC_MISO_SDA_TX_PIN)
X#if ((0u == (1u)))
S    #define UART_0_FPC_MISO_SDA_TX_HSIOM_REG      UART_0_FPC_TX_SDA_MISO_HSIOM_REG
S    #define UART_0_FPC_MISO_SDA_TX_HSIOM_PTR      UART_0_FPC_TX_SDA_MISO_HSIOM_REG
S    #define UART_0_FPC_MISO_SDA_TX_HSIOM_MASK     UART_0_FPC_TX_SDA_MISO_HSIOM_REG
S    #define UART_0_FPC_MISO_SDA_TX_HSIOM_POS      UART_0_FPC_TX_SDA_MISO_HSIOM_REG
N#endif /* (UART_0_FPC_MISO_SDA_TX_PIN_PIN) */
N
N#if (UART_0_FPC_SCLK_PIN)
X#if ((0u == (1u)))
S    #ifndef UART_0_FPC_SCLK_HSIOM_REG
S    #define UART_0_FPC_SCLK_HSIOM_REG     UART_0_FPC_CTS_SCLK_HSIOM_REG
S    #define UART_0_FPC_SCLK_HSIOM_PTR     UART_0_FPC_CTS_SCLK_HSIOM_PTR
S    #define UART_0_FPC_SCLK_HSIOM_MASK    UART_0_FPC_CTS_SCLK_HSIOM_MASK
S    #define UART_0_FPC_SCLK_HSIOM_POS     UART_0_FPC_CTS_SCLK_HSIOM_POS
S    #endif /* UART_0_FPC_SCLK_HSIOM_REG */
N#endif /* (UART_0_FPC_SCLK_PIN) */
N
N#if (UART_0_FPC_SS0_PIN)
X#if ((0u == (1u)))
S    #ifndef UART_0_FPC_SS0_HSIOM_REG
S    #define UART_0_FPC_SS0_HSIOM_REG      UART_0_FPC_RTS_SS0_HSIOM_REG
S    #define UART_0_FPC_SS0_HSIOM_PTR      UART_0_FPC_RTS_SS0_HSIOM_PTR
S    #define UART_0_FPC_SS0_HSIOM_MASK     UART_0_FPC_RTS_SS0_HSIOM_MASK
S    #define UART_0_FPC_SS0_HSIOM_POS      UART_0_FPC_RTS_SS0_HSIOM_POS
S    #endif /* UART_0_FPC_SS0_HSIOM_REG */
N#endif /* (UART_0_FPC_SS0_PIN) */
N
N#define UART_0_FPC_MOSI_SCL_RX_WAKE_PIN_INDEX UART_0_FPC_RX_WAKE_SCL_MOSI_PIN_INDEX
N#define UART_0_FPC_MOSI_SCL_RX_PIN_INDEX      UART_0_FPC_RX_SCL_MOSI_PIN_INDEX
N#define UART_0_FPC_MISO_SDA_TX_PIN_INDEX      UART_0_FPC_TX_SDA_MISO_PIN_INDEX
N#ifndef UART_0_FPC_SCLK_PIN_INDEX
N#define UART_0_FPC_SCLK_PIN_INDEX             UART_0_FPC_CTS_SCLK_PIN_INDEX
N#endif /* UART_0_FPC_SCLK_PIN_INDEX */
N#ifndef UART_0_FPC_SS0_PIN_INDEX
N#define UART_0_FPC_SS0_PIN_INDEX              UART_0_FPC_RTS_SS0_PIN_INDEX
N#endif /* UART_0_FPC_SS0_PIN_INDEX */
N
N#define UART_0_FPC_MOSI_SCL_RX_WAKE_PIN_MASK UART_0_FPC_RX_WAKE_SCL_MOSI_PIN_MASK
N#define UART_0_FPC_MOSI_SCL_RX_PIN_MASK      UART_0_FPC_RX_SCL_MOSI_PIN_MASK
N#define UART_0_FPC_MISO_SDA_TX_PIN_MASK      UART_0_FPC_TX_SDA_MISO_PIN_MASK
N#ifndef UART_0_FPC_SCLK_PIN_MASK
N#define UART_0_FPC_SCLK_PIN_MASK             UART_0_FPC_CTS_SCLK_PIN_MASK
N#endif /* UART_0_FPC_SCLK_PIN_MASK */
N#ifndef UART_0_FPC_SS0_PIN_MASK
N#define UART_0_FPC_SS0_PIN_MASK              UART_0_FPC_RTS_SS0_PIN_MASK
N#endif /* UART_0_FPC_SS0_PIN_MASK */
N
N#endif /* (CY_SCB_PINS_UART_0_FPC_H) */
N
N
N/* [] END OF FILE */
L 86 "Generated_Source\PSoC4\UART_0_FPC.h" 2
N
N#if (UART_0_FPC_SCB_CLK_INTERNAL)
X#if ((0u == (0u)))
N    #include "UART_0_FPC_SCBCLK.h"
L 1 "Generated_Source\PSoC4\UART_0_FPC_SCBCLK.h" 1
N/*******************************************************************************
N* File Name: UART_0_FPC_SCBCLK.h
N* Version 2.20
N*
N*  Description:
N*   Provides the function and constant definitions for the clock component.
N*
N*  Note:
N*
N********************************************************************************
N* Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_CLOCK_UART_0_FPC_SCBCLK_H)
X#if !0L
N#define CY_CLOCK_UART_0_FPC_SCBCLK_H
N
N#include <cytypes.h>
N#include <cyfitter.h>
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N#if defined CYREG_PERI_DIV_CMD
X#if 1L
N
Nvoid UART_0_FPC_SCBCLK_StartEx(uint32 alignClkDiv);
N#define UART_0_FPC_SCBCLK_Start() \
N    UART_0_FPC_SCBCLK_StartEx(UART_0_FPC_SCBCLK__PA_DIV_ID)
X#define UART_0_FPC_SCBCLK_Start()     UART_0_FPC_SCBCLK_StartEx(UART_0_FPC_SCBCLK__PA_DIV_ID)
N
N#else
S
Svoid UART_0_FPC_SCBCLK_Start(void);
S
N#endif/* CYREG_PERI_DIV_CMD */
N
Nvoid UART_0_FPC_SCBCLK_Stop(void);
N
Nvoid UART_0_FPC_SCBCLK_SetFractionalDividerRegister(uint16 clkDivider, uint8 clkFractional);
N
Nuint16 UART_0_FPC_SCBCLK_GetDividerRegister(void);
Nuint8  UART_0_FPC_SCBCLK_GetFractionalDividerRegister(void);
N
N#define UART_0_FPC_SCBCLK_Enable()                         UART_0_FPC_SCBCLK_Start()
N#define UART_0_FPC_SCBCLK_Disable()                        UART_0_FPC_SCBCLK_Stop()
N#define UART_0_FPC_SCBCLK_SetDividerRegister(clkDivider, reset)  \
N    UART_0_FPC_SCBCLK_SetFractionalDividerRegister((clkDivider), 0u)
X#define UART_0_FPC_SCBCLK_SetDividerRegister(clkDivider, reset)      UART_0_FPC_SCBCLK_SetFractionalDividerRegister((clkDivider), 0u)
N#define UART_0_FPC_SCBCLK_SetDivider(clkDivider)           UART_0_FPC_SCBCLK_SetDividerRegister((clkDivider), 1u)
N#define UART_0_FPC_SCBCLK_SetDividerValue(clkDivider)      UART_0_FPC_SCBCLK_SetDividerRegister((clkDivider) - 1u, 1u)
N
N
N/***************************************
N*             Registers
N***************************************/
N#if defined CYREG_PERI_DIV_CMD
X#if 1L
N
N#define UART_0_FPC_SCBCLK_DIV_ID     UART_0_FPC_SCBCLK__DIV_ID
N
N#define UART_0_FPC_SCBCLK_CMD_REG    (*(reg32 *)CYREG_PERI_DIV_CMD)
N#define UART_0_FPC_SCBCLK_CTRL_REG   (*(reg32 *)UART_0_FPC_SCBCLK__CTRL_REGISTER)
N#define UART_0_FPC_SCBCLK_DIV_REG    (*(reg32 *)UART_0_FPC_SCBCLK__DIV_REGISTER)
N
N#define UART_0_FPC_SCBCLK_CMD_DIV_SHIFT          (0u)
N#define UART_0_FPC_SCBCLK_CMD_PA_DIV_SHIFT       (8u)
N#define UART_0_FPC_SCBCLK_CMD_DISABLE_SHIFT      (30u)
N#define UART_0_FPC_SCBCLK_CMD_ENABLE_SHIFT       (31u)
N
N#define UART_0_FPC_SCBCLK_CMD_DISABLE_MASK       ((uint32)((uint32)1u << UART_0_FPC_SCBCLK_CMD_DISABLE_SHIFT))
N#define UART_0_FPC_SCBCLK_CMD_ENABLE_MASK        ((uint32)((uint32)1u << UART_0_FPC_SCBCLK_CMD_ENABLE_SHIFT))
N
N#define UART_0_FPC_SCBCLK_DIV_FRAC_MASK  (0x000000F8u)
N#define UART_0_FPC_SCBCLK_DIV_FRAC_SHIFT (3u)
N#define UART_0_FPC_SCBCLK_DIV_INT_MASK   (0xFFFFFF00u)
N#define UART_0_FPC_SCBCLK_DIV_INT_SHIFT  (8u)
N
N#else 
S
S#define UART_0_FPC_SCBCLK_DIV_REG        (*(reg32 *)UART_0_FPC_SCBCLK__REGISTER)
S#define UART_0_FPC_SCBCLK_ENABLE_REG     UART_0_FPC_SCBCLK_DIV_REG
S#define UART_0_FPC_SCBCLK_DIV_FRAC_MASK  UART_0_FPC_SCBCLK__FRAC_MASK
S#define UART_0_FPC_SCBCLK_DIV_FRAC_SHIFT (16u)
S#define UART_0_FPC_SCBCLK_DIV_INT_MASK   UART_0_FPC_SCBCLK__DIVIDER_MASK
S#define UART_0_FPC_SCBCLK_DIV_INT_SHIFT  (0u)
S
N#endif/* CYREG_PERI_DIV_CMD */
N
N#endif /* !defined(CY_CLOCK_UART_0_FPC_SCBCLK_H) */
N
N/* [] END OF FILE */
L 89 "Generated_Source\PSoC4\UART_0_FPC.h" 2
N#endif /* (UART_0_FPC_SCB_CLK_INTERNAL) */
N
N
N/***************************************
N*       Type Definitions
N***************************************/
N
Ntypedef struct
N{
N    uint8 enableState;
N} UART_0_FPC_BACKUP_STRUCT;
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
N/**
N* \addtogroup group_general
N* @{
N*/
N
N/* Start and Stop APIs */
Nvoid UART_0_FPC_Init(void);
Nvoid UART_0_FPC_Enable(void);
Nvoid UART_0_FPC_Start(void);
Nvoid UART_0_FPC_Stop(void);
N
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
N/* Sleep and Wakeup APis */
Nvoid UART_0_FPC_Sleep(void);
Nvoid UART_0_FPC_Wakeup(void);
N/** @} power */ 
N
N/**
N* \addtogroup group_interrupt
N* @{
N*/
N#if (UART_0_FPC_SCB_IRQ_INTERNAL)
X#if ((0u == (0u)))
N    /* Custom interrupt handler */
N    void UART_0_FPC_SetCustomInterruptHandler(void (*func)(void));
N#endif /* (UART_0_FPC_SCB_IRQ_INTERNAL) */
N/** @} interrupt */
N
N/* Interface to internal interrupt component */
N#if (UART_0_FPC_SCB_IRQ_INTERNAL)
X#if ((0u == (0u)))
N    /**
N    * \addtogroup group_interrupt
N    * @{
N    */    
N    /*******************************************************************************
N    * Function Name: UART_0_FPC_EnableInt
N    ****************************************************************************//**
N    *
N    *  When using an Internal interrupt, this enables the interrupt in the NVIC. 
N    *  When using an external interrupt the API for the interrupt component must 
N    *  be used to enable the interrupt.
N    *
N    *******************************************************************************/
N    #define UART_0_FPC_EnableInt()    CyIntEnable(UART_0_FPC_ISR_NUMBER)
N    
N    
N    /*******************************************************************************
N    * Function Name: UART_0_FPC_DisableInt
N    ****************************************************************************//**
N    *
N    *  When using an Internal interrupt, this disables the interrupt in the NVIC. 
N    *  When using an external interrupt the API for the interrupt component must 
N    *  be used to disable the interrupt.
N    *
N    *******************************************************************************/    
N    #define UART_0_FPC_DisableInt()   CyIntDisable(UART_0_FPC_ISR_NUMBER)
N    /** @} interrupt */
N
N    /*******************************************************************************
N    * Function Name: UART_0_FPC_ClearPendingInt
N    ****************************************************************************//**
N    *
N    *  This function clears the interrupt pending status in the NVIC. 
N    *
N    *******************************************************************************/
N    #define UART_0_FPC_ClearPendingInt()  CyIntClearPending(UART_0_FPC_ISR_NUMBER)
N#endif /* (UART_0_FPC_SCB_IRQ_INTERNAL) */
N
N#if (UART_0_FPC_UART_RX_WAKEUP_IRQ)
X#if ((0u == (1u)))
S    /*******************************************************************************
S    * Function Name: UART_0_FPC_RxWakeEnableInt
S    ****************************************************************************//**
S    *
S    *  This function enables the interrupt (RX_WAKE) pending status in the NVIC. 
S    *
S    *******************************************************************************/    
S    #define UART_0_FPC_RxWakeEnableInt()  CyIntEnable(UART_0_FPC_RX_WAKE_ISR_NUMBER)
S    
S
S    /*******************************************************************************
S    * Function Name: UART_0_FPC_RxWakeDisableInt
S    ****************************************************************************//**
S    *
S    *  This function disables the interrupt (RX_WAKE) pending status in the NVIC.  
S    *
S    *******************************************************************************/
S    #define UART_0_FPC_RxWakeDisableInt() CyIntDisable(UART_0_FPC_RX_WAKE_ISR_NUMBER)
S    
S    
S    /*******************************************************************************
S    * Function Name: UART_0_FPC_RxWakeClearPendingInt
S    ****************************************************************************//**
S    *
S    *  This function clears the interrupt (RX_WAKE) pending status in the NVIC. 
S    *
S    *******************************************************************************/    
S    #define UART_0_FPC_RxWakeClearPendingInt()  CyIntClearPending(UART_0_FPC_RX_WAKE_ISR_NUMBER)
N#endif /* (UART_0_FPC_UART_RX_WAKEUP_IRQ) */
N
N/**
N* \addtogroup group_interrupt
N* @{
N*/
N/* Get interrupt cause */
N/*******************************************************************************
N* Function Name: UART_0_FPC_GetInterruptCause
N****************************************************************************//**
N*
N*  Returns a mask of bits showing the source of the current triggered interrupt. 
N*  This is useful for modes of operation where an interrupt can be generated by 
N*  conditions in multiple interrupt source registers.
N*
N*  \return
N*   Mask with the OR of the following conditions that have been triggered.
N*    - UART_0_FPC_INTR_CAUSE_MASTER - Interrupt from Master
N*    - UART_0_FPC_INTR_CAUSE_SLAVE - Interrupt from Slave
N*    - UART_0_FPC_INTR_CAUSE_TX - Interrupt from TX
N*    - UART_0_FPC_INTR_CAUSE_RX - Interrupt from RX
N*
N*******************************************************************************/
N#define UART_0_FPC_GetInterruptCause()    (UART_0_FPC_INTR_CAUSE_REG)
N
N
N/* APIs to service INTR_RX register */
N/*******************************************************************************
N* Function Name: UART_0_FPC_GetRxInterruptSource
N****************************************************************************//**
N*
N*  Returns RX interrupt request register. This register contains current status 
N*  of RX interrupt sources.
N*
N*  \return
N*   Current status of RX interrupt sources.
N*   Each constant is a bit field value. The value returned may have multiple 
N*   bits set to indicate the current status.
N*   - UART_0_FPC_INTR_RX_FIFO_LEVEL - The number of data elements in the 
N      RX FIFO is greater than the value of RX FIFO level.
N*   - UART_0_FPC_INTR_RX_NOT_EMPTY - Receiver FIFO is not empty.
N*   - UART_0_FPC_INTR_RX_FULL - Receiver FIFO is full.
N*   - UART_0_FPC_INTR_RX_OVERFLOW - Attempt to write to a full 
N*     receiver FIFO.
N*   - UART_0_FPC_INTR_RX_UNDERFLOW - Attempt to read from an empty 
N*     receiver FIFO.
N*   - UART_0_FPC_INTR_RX_FRAME_ERROR - UART framing error detected.
N*   - UART_0_FPC_INTR_RX_PARITY_ERROR - UART parity error detected.
N*
N*******************************************************************************/
N#define UART_0_FPC_GetRxInterruptSource() (UART_0_FPC_INTR_RX_REG)
N
N
N/*******************************************************************************
N* Function Name: UART_0_FPC_SetRxInterruptMode
N****************************************************************************//**
N*
N*  Writes RX interrupt mask register. This register configures which bits from 
N*  RX interrupt request register will trigger an interrupt event.
N*
N*  \param interruptMask: RX interrupt sources to be enabled (refer to 
N*   UART_0_FPC_GetRxInterruptSource() function for bit fields values).
N*
N*******************************************************************************/
N#define UART_0_FPC_SetRxInterruptMode(interruptMask)     UART_0_FPC_WRITE_INTR_RX_MASK(interruptMask)
N
N
N/*******************************************************************************
N* Function Name: UART_0_FPC_GetRxInterruptMode
N****************************************************************************//**
N*
N*  Returns RX interrupt mask register This register specifies which bits from 
N*  RX interrupt request register will trigger an interrupt event.
N*
N*  \return 
N*   RX interrupt sources to be enabled (refer to 
N*   UART_0_FPC_GetRxInterruptSource() function for bit fields values).
N*
N*******************************************************************************/
N#define UART_0_FPC_GetRxInterruptMode()   (UART_0_FPC_INTR_RX_MASK_REG)
N
N
N/*******************************************************************************
N* Function Name: UART_0_FPC_GetRxInterruptSourceMasked
N****************************************************************************//**
N*
N*  Returns RX interrupt masked request register. This register contains logical
N*  AND of corresponding bits from RX interrupt request and mask registers.
N*  This function is intended to be used in the interrupt service routine to 
N*  identify which of enabled RX interrupt sources cause interrupt event.
N*
N*  \return 
N*   Current status of enabled RX interrupt sources (refer to 
N*   UART_0_FPC_GetRxInterruptSource() function for bit fields values).
N*
N*******************************************************************************/
N#define UART_0_FPC_GetRxInterruptSourceMasked()   (UART_0_FPC_INTR_RX_MASKED_REG)
N
N
N/*******************************************************************************
N* Function Name: UART_0_FPC_ClearRxInterruptSource
N****************************************************************************//**
N*
N*  Clears RX interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: RX interrupt sources to be cleared (refer to 
N*   UART_0_FPC_GetRxInterruptSource() function for bit fields values).
N*
N*  \sideeffects 
N*   The side effects are listed in the table below for each 
N*   affected interrupt source. Refer to section RX FIFO interrupt sources for 
N*   detailed description.
N*   - UART_0_FPC_INTR_RX_FIFO_LEVEL Interrupt source is not cleared when 
N*     the receiver FIFO has more entries than level.
N*   - UART_0_FPC_INTR_RX_NOT_EMPTY Interrupt source is not cleared when
N*     receiver FIFO is not empty.
N*   - UART_0_FPC_INTR_RX_FULL Interrupt source is not cleared when 
N*      receiver FIFO is full.
N*
N*******************************************************************************/
N#define UART_0_FPC_ClearRxInterruptSource(interruptMask)  UART_0_FPC_CLEAR_INTR_RX(interruptMask)
N
N
N/*******************************************************************************
N* Function Name: UART_0_FPC_SetRxInterrupt
N****************************************************************************//**
N*
N*  Sets RX interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: RX interrupt sources to set in the RX interrupt request 
N*   register (refer to UART_0_FPC_GetRxInterruptSource() function for bit 
N*   fields values).
N*
N*******************************************************************************/
N#define UART_0_FPC_SetRxInterrupt(interruptMask)  UART_0_FPC_SET_INTR_RX(interruptMask)
N
Nvoid UART_0_FPC_SetRxFifoLevel(uint32 level);
N
N
N/* APIs to service INTR_TX register */
N/*******************************************************************************
N* Function Name: UART_0_FPC_GetTxInterruptSource
N****************************************************************************//**
N*
N*  Returns TX interrupt request register. This register contains current status 
N*  of TX interrupt sources.
N* 
N*  \return 
N*   Current status of TX interrupt sources.
N*   Each constant is a bit field value. The value returned may have multiple 
N*   bits set to indicate the current status.
N*   - UART_0_FPC_INTR_TX_FIFO_LEVEL - The number of data elements in the 
N*     TX FIFO is less than the value of TX FIFO level.
N*   - UART_0_FPC_INTR_TX_NOT_FULL - Transmitter FIFO is not full.
N*   - UART_0_FPC_INTR_TX_EMPTY - Transmitter FIFO is empty.
N*   - UART_0_FPC_INTR_TX_OVERFLOW - Attempt to write to a full 
N*     transmitter FIFO.
N*   - UART_0_FPC_INTR_TX_UNDERFLOW - Attempt to read from an empty 
N*     transmitter FIFO.
N*   - UART_0_FPC_INTR_TX_UART_NACK - UART received a NACK in SmartCard 
N*   mode.
N*   - UART_0_FPC_INTR_TX_UART_DONE - UART transfer is complete. 
N*     All data elements from the TX FIFO are sent.
N*   - UART_0_FPC_INTR_TX_UART_ARB_LOST - Value on the TX line of the UART
N*     does not match the value on the RX line.
N*
N*******************************************************************************/
N#define UART_0_FPC_GetTxInterruptSource() (UART_0_FPC_INTR_TX_REG)
N
N
N/*******************************************************************************
N* Function Name: UART_0_FPC_SetTxInterruptMode
N****************************************************************************//**
N*
N*  Writes TX interrupt mask register. This register configures which bits from 
N*  TX interrupt request register will trigger an interrupt event.
N*
N*  \param interruptMask: TX interrupt sources to be enabled (refer to 
N*   UART_0_FPC_GetTxInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define UART_0_FPC_SetTxInterruptMode(interruptMask)  UART_0_FPC_WRITE_INTR_TX_MASK(interruptMask)
N
N
N/*******************************************************************************
N* Function Name: UART_0_FPC_GetTxInterruptMode
N****************************************************************************//**
N*
N*  Returns TX interrupt mask register This register specifies which bits from 
N*  TX interrupt request register will trigger an interrupt event.
N*
N*  \return 
N*   Enabled TX interrupt sources (refer to 
N*   UART_0_FPC_GetTxInterruptSource() function for bit field values).
N*   
N*******************************************************************************/
N#define UART_0_FPC_GetTxInterruptMode()   (UART_0_FPC_INTR_TX_MASK_REG)
N
N
N/*******************************************************************************
N* Function Name: UART_0_FPC_GetTxInterruptSourceMasked
N****************************************************************************//**
N*
N*  Returns TX interrupt masked request register. This register contains logical
N*  AND of corresponding bits from TX interrupt request and mask registers.
N*  This function is intended to be used in the interrupt service routine to identify 
N*  which of enabled TX interrupt sources cause interrupt event.
N*
N*  \return 
N*   Current status of enabled TX interrupt sources (refer to 
N*   UART_0_FPC_GetTxInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define UART_0_FPC_GetTxInterruptSourceMasked()   (UART_0_FPC_INTR_TX_MASKED_REG)
N
N
N/*******************************************************************************
N* Function Name: UART_0_FPC_ClearTxInterruptSource
N****************************************************************************//**
N*
N*  Clears TX interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: TX interrupt sources to be cleared (refer to 
N*   UART_0_FPC_GetTxInterruptSource() function for bit field values).
N*
N*  \sideeffects 
N*   The side effects are listed in the table below for each affected interrupt 
N*   source. Refer to section TX FIFO interrupt sources for detailed description.
N*   - UART_0_FPC_INTR_TX_FIFO_LEVEL - Interrupt source is not cleared when 
N*     transmitter FIFO has less entries than level.
N*   - UART_0_FPC_INTR_TX_NOT_FULL - Interrupt source is not cleared when
N*     transmitter FIFO has empty entries.
N*   - UART_0_FPC_INTR_TX_EMPTY - Interrupt source is not cleared when 
N*     transmitter FIFO is empty.
N*   - UART_0_FPC_INTR_TX_UNDERFLOW - Interrupt source is not cleared when 
N*     transmitter FIFO is empty and I2C mode with clock stretching is selected. 
N*     Put data into the transmitter FIFO before clearing it. This behavior only 
N*     applicable for PSoC 4100/PSoC 4200 devices.
N*
N*******************************************************************************/
N#define UART_0_FPC_ClearTxInterruptSource(interruptMask)  UART_0_FPC_CLEAR_INTR_TX(interruptMask)
N
N
N/*******************************************************************************
N* Function Name: UART_0_FPC_SetTxInterrupt
N****************************************************************************//**
N*
N*  Sets RX interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: RX interrupt sources to set in the RX interrupt request 
N*   register (refer to UART_0_FPC_GetRxInterruptSource() function for bit 
N*   fields values).
N*
N*******************************************************************************/
N#define UART_0_FPC_SetTxInterrupt(interruptMask)  UART_0_FPC_SET_INTR_TX(interruptMask)
N
Nvoid UART_0_FPC_SetTxFifoLevel(uint32 level);
N
N
N/* APIs to service INTR_MASTER register */
N/*******************************************************************************
N* Function Name: UART_0_FPC_GetMasterInterruptSource
N****************************************************************************//**
N*
N*  Returns Master interrupt request register. This register contains current 
N*  status of Master interrupt sources.
N*
N*  \return 
N*   Current status of Master interrupt sources. 
N*   Each constant is a bit field value. The value returned may have multiple 
N*   bits set to indicate the current status.
N*   - UART_0_FPC_INTR_MASTER_SPI_DONE - SPI master transfer is complete.
N*     Refer to Interrupt sources section for detailed description.
N*   - UART_0_FPC_INTR_MASTER_I2C_ARB_LOST - I2C master lost arbitration.
N*   - UART_0_FPC_INTR_MASTER_I2C_NACK - I2C master received negative 
N*    acknowledgement (NAK).
N*   - UART_0_FPC_INTR_MASTER_I2C_ACK - I2C master received acknowledgement.
N*   - UART_0_FPC_INTR_MASTER_I2C_STOP - I2C master generated STOP.
N*   - UART_0_FPC_INTR_MASTER_I2C_BUS_ERROR - I2C master bus error 
N*     (detection of unexpected START or STOP condition).
N*
N*******************************************************************************/
N#define UART_0_FPC_GetMasterInterruptSource() (UART_0_FPC_INTR_MASTER_REG)
N
N/*******************************************************************************
N* Function Name: UART_0_FPC_SetMasterInterruptMode
N****************************************************************************//**
N*
N*  Writes Master interrupt mask register. This register configures which bits 
N*  from Master interrupt request register will trigger an interrupt event.
N*
N*  \param interruptMask: Master interrupt sources to be enabled (refer to 
N*   UART_0_FPC_GetMasterInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define UART_0_FPC_SetMasterInterruptMode(interruptMask)  UART_0_FPC_WRITE_INTR_MASTER_MASK(interruptMask)
N
N/*******************************************************************************
N* Function Name: UART_0_FPC_GetMasterInterruptMode
N****************************************************************************//**
N*
N*  Returns Master interrupt mask register This register specifies which bits 
N*  from Master interrupt request register will trigger an interrupt event.
N*
N*  \return 
N*   Enabled Master interrupt sources (refer to 
N*   UART_0_FPC_GetMasterInterruptSource() function for return values).
N*
N*******************************************************************************/
N#define UART_0_FPC_GetMasterInterruptMode()   (UART_0_FPC_INTR_MASTER_MASK_REG)
N
N/*******************************************************************************
N* Function Name: UART_0_FPC_GetMasterInterruptSourceMasked
N****************************************************************************//**
N*
N*  Returns Master interrupt masked request register. This register contains 
N*  logical AND of corresponding bits from Master interrupt request and mask 
N*  registers.
N*  This function is intended to be used in the interrupt service routine to 
N*  identify which of enabled Master interrupt sources cause interrupt event.
N*
N*  \return 
N*   Current status of enabled Master interrupt sources (refer to 
N*   UART_0_FPC_GetMasterInterruptSource() function for return values).
N*
N*******************************************************************************/
N#define UART_0_FPC_GetMasterInterruptSourceMasked()   (UART_0_FPC_INTR_MASTER_MASKED_REG)
N
N/*******************************************************************************
N* Function Name: UART_0_FPC_ClearMasterInterruptSource
N****************************************************************************//**
N*
N*  Clears Master interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: Master interrupt sources to be cleared (refer to 
N*   UART_0_FPC_GetMasterInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define UART_0_FPC_ClearMasterInterruptSource(interruptMask)  UART_0_FPC_CLEAR_INTR_MASTER(interruptMask)
N
N/*******************************************************************************
N* Function Name: UART_0_FPC_SetMasterInterrupt
N****************************************************************************//**
N*
N*  Sets Master interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: Master interrupt sources to set in the Master interrupt
N*   request register (refer to UART_0_FPC_GetMasterInterruptSource() 
N*   function for bit field values).
N*
N*******************************************************************************/
N#define UART_0_FPC_SetMasterInterrupt(interruptMask)  UART_0_FPC_SET_INTR_MASTER(interruptMask)
N
N
N/* APIs to service INTR_SLAVE register */
N/*******************************************************************************
N* Function Name: UART_0_FPC_GetSlaveInterruptSource
N****************************************************************************//**
N*
N*  Returns Slave interrupt request register. This register contains current 
N*  status of Slave interrupt sources.
N*
N*  \return 
N*   Current status of Slave interrupt sources.
N*   Each constant is a bit field value. The value returned may have multiple 
N*   bits set to indicate the current status.
N*   - UART_0_FPC_INTR_SLAVE_I2C_ARB_LOST - I2C slave lost arbitration: 
N*     the value driven on the SDA line is not the same as the value observed 
N*     on the SDA line.
N*   - UART_0_FPC_INTR_SLAVE_I2C_NACK - I2C slave received negative 
N*     acknowledgement (NAK).
N*   - UART_0_FPC_INTR_SLAVE_I2C_ACK - I2C slave received 
N*     acknowledgement (ACK).
N*   - UART_0_FPC_INTR_SLAVE_I2C_WRITE_STOP - Stop or Repeated Start 
N*     event for write transfer intended for this slave (address matching 
N*     is performed).
N*   - UART_0_FPC_INTR_SLAVE_I2C_STOP - Stop or Repeated Start event 
N*     for (read or write) transfer intended for this slave (address matching 
N*     is performed).
N*   - UART_0_FPC_INTR_SLAVE_I2C_START - I2C slave received Start 
N*     condition.
N*   - UART_0_FPC_INTR_SLAVE_I2C_ADDR_MATCH - I2C slave received matching 
N*     address.
N*   - UART_0_FPC_INTR_SLAVE_I2C_GENERAL - I2C Slave received general 
N*     call address.
N*   - UART_0_FPC_INTR_SLAVE_I2C_BUS_ERROR - I2C slave bus error (detection 
N*      of unexpected Start or Stop condition).
N*   - UART_0_FPC_INTR_SLAVE_SPI_BUS_ERROR - SPI slave select line is 
N*      deselected at an expected time while the SPI transfer.
N*
N*******************************************************************************/
N#define UART_0_FPC_GetSlaveInterruptSource()  (UART_0_FPC_INTR_SLAVE_REG)
N
N/*******************************************************************************
N* Function Name: UART_0_FPC_SetSlaveInterruptMode
N****************************************************************************//**
N*
N*  Writes Slave interrupt mask register. 
N*  This register configures which bits from Slave interrupt request register 
N*  will trigger an interrupt event.
N*
N*  \param interruptMask: Slave interrupt sources to be enabled (refer to 
N*   UART_0_FPC_GetSlaveInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define UART_0_FPC_SetSlaveInterruptMode(interruptMask)   UART_0_FPC_WRITE_INTR_SLAVE_MASK(interruptMask)
N
N/*******************************************************************************
N* Function Name: UART_0_FPC_GetSlaveInterruptMode
N****************************************************************************//**
N*
N*  Returns Slave interrupt mask register.
N*  This register specifies which bits from Slave interrupt request register 
N*  will trigger an interrupt event.
N*
N*  \return 
N*   Enabled Slave interrupt sources(refer to 
N*   UART_0_FPC_GetSlaveInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define UART_0_FPC_GetSlaveInterruptMode()    (UART_0_FPC_INTR_SLAVE_MASK_REG)
N
N/*******************************************************************************
N* Function Name: UART_0_FPC_GetSlaveInterruptSourceMasked
N****************************************************************************//**
N*
N*  Returns Slave interrupt masked request register. This register contains 
N*  logical AND of corresponding bits from Slave interrupt request and mask 
N*  registers.
N*  This function is intended to be used in the interrupt service routine to 
N*  identify which of enabled Slave interrupt sources cause interrupt event.
N*
N*  \return 
N*   Current status of enabled Slave interrupt sources (refer to 
N*   UART_0_FPC_GetSlaveInterruptSource() function for return values).
N*
N*******************************************************************************/
N#define UART_0_FPC_GetSlaveInterruptSourceMasked()    (UART_0_FPC_INTR_SLAVE_MASKED_REG)
N
N/*******************************************************************************
N* Function Name: UART_0_FPC_ClearSlaveInterruptSource
N****************************************************************************//**
N*
N*  Clears Slave interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: Slave interrupt sources to be cleared (refer to 
N*   UART_0_FPC_GetSlaveInterruptSource() function for return values).
N*
N*******************************************************************************/
N#define UART_0_FPC_ClearSlaveInterruptSource(interruptMask)   UART_0_FPC_CLEAR_INTR_SLAVE(interruptMask)
N
N/*******************************************************************************
N* Function Name: UART_0_FPC_SetSlaveInterrupt
N****************************************************************************//**
N*
N*  Sets Slave interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: Slave interrupt sources to set in the Slave interrupt 
N*   request register (refer to UART_0_FPC_GetSlaveInterruptSource() 
N*   function for return values).
N*
N*******************************************************************************/
N#define UART_0_FPC_SetSlaveInterrupt(interruptMask)   UART_0_FPC_SET_INTR_SLAVE(interruptMask)
N
N/** @} interrupt */ 
N
N
N/***************************************
N*     Vars with External Linkage
N***************************************/
N
N/**
N* \addtogroup group_globals
N* @{
N*/
N
N/** UART_0_FPC_initVar indicates whether the UART_0_FPC 
N*  component has been initialized. The variable is initialized to 0 
N*  and set to 1 the first time SCB_Start() is called. This allows 
N*  the component to restart without reinitialization after the first 
N*  call to the UART_0_FPC_Start() routine.
N*
N*  If re-initialization of the component is required, then the 
N*  UART_0_FPC_Init() function can be called before the 
N*  UART_0_FPC_Start() or UART_0_FPC_Enable() function.
N*/
Nextern uint8 UART_0_FPC_initVar;
N/** @} globals */
N
N/***************************************
N*              Registers
N***************************************/
N
N#define UART_0_FPC_CTRL_REG               (*(reg32 *) UART_0_FPC_SCB__CTRL)
N#define UART_0_FPC_CTRL_PTR               ( (reg32 *) UART_0_FPC_SCB__CTRL)
N
N#define UART_0_FPC_STATUS_REG             (*(reg32 *) UART_0_FPC_SCB__STATUS)
N#define UART_0_FPC_STATUS_PTR             ( (reg32 *) UART_0_FPC_SCB__STATUS)
N
N#if (!UART_0_FPC_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_0_FPC_SPI_CTRL_REG           (*(reg32 *) UART_0_FPC_SCB__SPI_CTRL)
N    #define UART_0_FPC_SPI_CTRL_PTR           ( (reg32 *) UART_0_FPC_SCB__SPI_CTRL)
N
N    #define UART_0_FPC_SPI_STATUS_REG         (*(reg32 *) UART_0_FPC_SCB__SPI_STATUS)
N    #define UART_0_FPC_SPI_STATUS_PTR         ( (reg32 *) UART_0_FPC_SCB__SPI_STATUS)
N
N    #define UART_0_FPC_UART_CTRL_REG          (*(reg32 *) UART_0_FPC_SCB__UART_CTRL)
N    #define UART_0_FPC_UART_CTRL_PTR          ( (reg32 *) UART_0_FPC_SCB__UART_CTRL)
N
N    #define UART_0_FPC_UART_TX_CTRL_REG       (*(reg32 *) UART_0_FPC_SCB__UART_TX_CTRL)
N    #define UART_0_FPC_UART_TX_CTRL_PTR       ( (reg32 *) UART_0_FPC_SCB__UART_TX_CTRL)
N
N    #define UART_0_FPC_UART_RX_CTRL_REG       (*(reg32 *) UART_0_FPC_SCB__UART_RX_CTRL)
N    #define UART_0_FPC_UART_RX_CTRL_PTR       ( (reg32 *) UART_0_FPC_SCB__UART_RX_CTRL)
N
N    #define UART_0_FPC_UART_RX_STATUS_REG     (*(reg32 *) UART_0_FPC_SCB__UART_RX_STATUS)
N    #define UART_0_FPC_UART_RX_STATUS_PTR     ( (reg32 *) UART_0_FPC_SCB__UART_RX_STATUS)
N#endif /* (!UART_0_FPC_CY_SCBIP_V1) */
N
N#if !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define UART_0_FPC_UART_FLOW_CTRL_REG     (*(reg32 *) UART_0_FPC_SCB__UART_FLOW_CTRL)
N    #define UART_0_FPC_UART_FLOW_CTRL_PTR     ( (reg32 *) UART_0_FPC_SCB__UART_FLOW_CTRL)
N#endif /* !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1) */
N
N#define UART_0_FPC_I2C_CTRL_REG           (*(reg32 *) UART_0_FPC_SCB__I2C_CTRL)
N#define UART_0_FPC_I2C_CTRL_PTR           ( (reg32 *) UART_0_FPC_SCB__I2C_CTRL)
N
N#define UART_0_FPC_I2C_STATUS_REG         (*(reg32 *) UART_0_FPC_SCB__I2C_STATUS)
N#define UART_0_FPC_I2C_STATUS_PTR         ( (reg32 *) UART_0_FPC_SCB__I2C_STATUS)
N
N#define UART_0_FPC_I2C_MASTER_CMD_REG     (*(reg32 *) UART_0_FPC_SCB__I2C_M_CMD)
N#define UART_0_FPC_I2C_MASTER_CMD_PTR     ( (reg32 *) UART_0_FPC_SCB__I2C_M_CMD)
N
N#define UART_0_FPC_I2C_SLAVE_CMD_REG      (*(reg32 *) UART_0_FPC_SCB__I2C_S_CMD)
N#define UART_0_FPC_I2C_SLAVE_CMD_PTR      ( (reg32 *) UART_0_FPC_SCB__I2C_S_CMD)
N
N#define UART_0_FPC_I2C_CFG_REG            (*(reg32 *) UART_0_FPC_SCB__I2C_CFG)
N#define UART_0_FPC_I2C_CFG_PTR            ( (reg32 *) UART_0_FPC_SCB__I2C_CFG)
N
N#define UART_0_FPC_TX_CTRL_REG            (*(reg32 *) UART_0_FPC_SCB__TX_CTRL)
N#define UART_0_FPC_TX_CTRL_PTR            ( (reg32 *) UART_0_FPC_SCB__TX_CTRL)
N
N#define UART_0_FPC_TX_FIFO_CTRL_REG       (*(reg32 *) UART_0_FPC_SCB__TX_FIFO_CTRL)
N#define UART_0_FPC_TX_FIFO_CTRL_PTR       ( (reg32 *) UART_0_FPC_SCB__TX_FIFO_CTRL)
N
N#define UART_0_FPC_TX_FIFO_STATUS_REG     (*(reg32 *) UART_0_FPC_SCB__TX_FIFO_STATUS)
N#define UART_0_FPC_TX_FIFO_STATUS_PTR     ( (reg32 *) UART_0_FPC_SCB__TX_FIFO_STATUS)
N
N#define UART_0_FPC_TX_FIFO_WR_REG         (*(reg32 *) UART_0_FPC_SCB__TX_FIFO_WR)
N#define UART_0_FPC_TX_FIFO_WR_PTR         ( (reg32 *) UART_0_FPC_SCB__TX_FIFO_WR)
N
N#define UART_0_FPC_RX_CTRL_REG            (*(reg32 *) UART_0_FPC_SCB__RX_CTRL)
N#define UART_0_FPC_RX_CTRL_PTR            ( (reg32 *) UART_0_FPC_SCB__RX_CTRL)
N
N#define UART_0_FPC_RX_FIFO_CTRL_REG       (*(reg32 *) UART_0_FPC_SCB__RX_FIFO_CTRL)
N#define UART_0_FPC_RX_FIFO_CTRL_PTR       ( (reg32 *) UART_0_FPC_SCB__RX_FIFO_CTRL)
N
N#define UART_0_FPC_RX_FIFO_STATUS_REG     (*(reg32 *) UART_0_FPC_SCB__RX_FIFO_STATUS)
N#define UART_0_FPC_RX_FIFO_STATUS_PTR     ( (reg32 *) UART_0_FPC_SCB__RX_FIFO_STATUS)
N
N#define UART_0_FPC_RX_MATCH_REG           (*(reg32 *) UART_0_FPC_SCB__RX_MATCH)
N#define UART_0_FPC_RX_MATCH_PTR           ( (reg32 *) UART_0_FPC_SCB__RX_MATCH)
N
N#define UART_0_FPC_RX_FIFO_RD_REG         (*(reg32 *) UART_0_FPC_SCB__RX_FIFO_RD)
N#define UART_0_FPC_RX_FIFO_RD_PTR         ( (reg32 *) UART_0_FPC_SCB__RX_FIFO_RD)
N
N#define UART_0_FPC_RX_FIFO_RD_SILENT_REG  (*(reg32 *) UART_0_FPC_SCB__RX_FIFO_RD_SILENT)
N#define UART_0_FPC_RX_FIFO_RD_SILENT_PTR  ( (reg32 *) UART_0_FPC_SCB__RX_FIFO_RD_SILENT)
N
N#ifdef UART_0_FPC_SCB__EZ_DATA0
N    #define UART_0_FPC_EZBUF_DATA0_REG    (*(reg32 *) UART_0_FPC_SCB__EZ_DATA0)
N    #define UART_0_FPC_EZBUF_DATA0_PTR    ( (reg32 *) UART_0_FPC_SCB__EZ_DATA0)
N#else
S    #define UART_0_FPC_EZBUF_DATA0_REG    (*(reg32 *) UART_0_FPC_SCB__EZ_DATA00)
S    #define UART_0_FPC_EZBUF_DATA0_PTR    ( (reg32 *) UART_0_FPC_SCB__EZ_DATA00)
N#endif /* UART_0_FPC_SCB__EZ_DATA00 */
N
N#define UART_0_FPC_INTR_CAUSE_REG         (*(reg32 *) UART_0_FPC_SCB__INTR_CAUSE)
N#define UART_0_FPC_INTR_CAUSE_PTR         ( (reg32 *) UART_0_FPC_SCB__INTR_CAUSE)
N
N#define UART_0_FPC_INTR_I2C_EC_REG        (*(reg32 *) UART_0_FPC_SCB__INTR_I2C_EC)
N#define UART_0_FPC_INTR_I2C_EC_PTR        ( (reg32 *) UART_0_FPC_SCB__INTR_I2C_EC)
N
N#define UART_0_FPC_INTR_I2C_EC_MASK_REG   (*(reg32 *) UART_0_FPC_SCB__INTR_I2C_EC_MASK)
N#define UART_0_FPC_INTR_I2C_EC_MASK_PTR   ( (reg32 *) UART_0_FPC_SCB__INTR_I2C_EC_MASK)
N
N#define UART_0_FPC_INTR_I2C_EC_MASKED_REG (*(reg32 *) UART_0_FPC_SCB__INTR_I2C_EC_MASKED)
N#define UART_0_FPC_INTR_I2C_EC_MASKED_PTR ( (reg32 *) UART_0_FPC_SCB__INTR_I2C_EC_MASKED)
N
N#if (!UART_0_FPC_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_0_FPC_INTR_SPI_EC_REG        (*(reg32 *) UART_0_FPC_SCB__INTR_SPI_EC)
N    #define UART_0_FPC_INTR_SPI_EC_PTR        ( (reg32 *) UART_0_FPC_SCB__INTR_SPI_EC)
N
N    #define UART_0_FPC_INTR_SPI_EC_MASK_REG   (*(reg32 *) UART_0_FPC_SCB__INTR_SPI_EC_MASK)
N    #define UART_0_FPC_INTR_SPI_EC_MASK_PTR   ( (reg32 *) UART_0_FPC_SCB__INTR_SPI_EC_MASK)
N
N    #define UART_0_FPC_INTR_SPI_EC_MASKED_REG (*(reg32 *) UART_0_FPC_SCB__INTR_SPI_EC_MASKED)
N    #define UART_0_FPC_INTR_SPI_EC_MASKED_PTR ( (reg32 *) UART_0_FPC_SCB__INTR_SPI_EC_MASKED)
N#endif /* (!UART_0_FPC_CY_SCBIP_V1) */
N
N#define UART_0_FPC_INTR_MASTER_REG        (*(reg32 *) UART_0_FPC_SCB__INTR_M)
N#define UART_0_FPC_INTR_MASTER_PTR        ( (reg32 *) UART_0_FPC_SCB__INTR_M)
N
N#define UART_0_FPC_INTR_MASTER_SET_REG    (*(reg32 *) UART_0_FPC_SCB__INTR_M_SET)
N#define UART_0_FPC_INTR_MASTER_SET_PTR    ( (reg32 *) UART_0_FPC_SCB__INTR_M_SET)
N
N#define UART_0_FPC_INTR_MASTER_MASK_REG   (*(reg32 *) UART_0_FPC_SCB__INTR_M_MASK)
N#define UART_0_FPC_INTR_MASTER_MASK_PTR   ( (reg32 *) UART_0_FPC_SCB__INTR_M_MASK)
N
N#define UART_0_FPC_INTR_MASTER_MASKED_REG (*(reg32 *) UART_0_FPC_SCB__INTR_M_MASKED)
N#define UART_0_FPC_INTR_MASTER_MASKED_PTR ( (reg32 *) UART_0_FPC_SCB__INTR_M_MASKED)
N
N#define UART_0_FPC_INTR_SLAVE_REG         (*(reg32 *) UART_0_FPC_SCB__INTR_S)
N#define UART_0_FPC_INTR_SLAVE_PTR         ( (reg32 *) UART_0_FPC_SCB__INTR_S)
N
N#define UART_0_FPC_INTR_SLAVE_SET_REG     (*(reg32 *) UART_0_FPC_SCB__INTR_S_SET)
N#define UART_0_FPC_INTR_SLAVE_SET_PTR     ( (reg32 *) UART_0_FPC_SCB__INTR_S_SET)
N
N#define UART_0_FPC_INTR_SLAVE_MASK_REG    (*(reg32 *) UART_0_FPC_SCB__INTR_S_MASK)
N#define UART_0_FPC_INTR_SLAVE_MASK_PTR    ( (reg32 *) UART_0_FPC_SCB__INTR_S_MASK)
N
N#define UART_0_FPC_INTR_SLAVE_MASKED_REG  (*(reg32 *) UART_0_FPC_SCB__INTR_S_MASKED)
N#define UART_0_FPC_INTR_SLAVE_MASKED_PTR  ( (reg32 *) UART_0_FPC_SCB__INTR_S_MASKED)
N
N#define UART_0_FPC_INTR_TX_REG            (*(reg32 *) UART_0_FPC_SCB__INTR_TX)
N#define UART_0_FPC_INTR_TX_PTR            ( (reg32 *) UART_0_FPC_SCB__INTR_TX)
N
N#define UART_0_FPC_INTR_TX_SET_REG        (*(reg32 *) UART_0_FPC_SCB__INTR_TX_SET)
N#define UART_0_FPC_INTR_TX_SET_PTR        ( (reg32 *) UART_0_FPC_SCB__INTR_TX_SET)
N
N#define UART_0_FPC_INTR_TX_MASK_REG       (*(reg32 *) UART_0_FPC_SCB__INTR_TX_MASK)
N#define UART_0_FPC_INTR_TX_MASK_PTR       ( (reg32 *) UART_0_FPC_SCB__INTR_TX_MASK)
N
N#define UART_0_FPC_INTR_TX_MASKED_REG     (*(reg32 *) UART_0_FPC_SCB__INTR_TX_MASKED)
N#define UART_0_FPC_INTR_TX_MASKED_PTR     ( (reg32 *) UART_0_FPC_SCB__INTR_TX_MASKED)
N
N#define UART_0_FPC_INTR_RX_REG            (*(reg32 *) UART_0_FPC_SCB__INTR_RX)
N#define UART_0_FPC_INTR_RX_PTR            ( (reg32 *) UART_0_FPC_SCB__INTR_RX)
N
N#define UART_0_FPC_INTR_RX_SET_REG        (*(reg32 *) UART_0_FPC_SCB__INTR_RX_SET)
N#define UART_0_FPC_INTR_RX_SET_PTR        ( (reg32 *) UART_0_FPC_SCB__INTR_RX_SET)
N
N#define UART_0_FPC_INTR_RX_MASK_REG       (*(reg32 *) UART_0_FPC_SCB__INTR_RX_MASK)
N#define UART_0_FPC_INTR_RX_MASK_PTR       ( (reg32 *) UART_0_FPC_SCB__INTR_RX_MASK)
N
N#define UART_0_FPC_INTR_RX_MASKED_REG     (*(reg32 *) UART_0_FPC_SCB__INTR_RX_MASKED)
N#define UART_0_FPC_INTR_RX_MASKED_PTR     ( (reg32 *) UART_0_FPC_SCB__INTR_RX_MASKED)
N
N/* Defines get from SCB IP parameters. */
N#define UART_0_FPC_FIFO_SIZE      (8u)  /* TX or RX FIFO size. */
N#define UART_0_FPC_EZ_DATA_NR     (32u)  /* Number of words in EZ memory. */ 
N#define UART_0_FPC_ONE_BYTE_WIDTH (8u)            /* Number of bits in one byte. */
N#define UART_0_FPC_FF_DATA_NR_LOG2_MASK       (0x0Fu)      /* Number of bits to represent a FIFO address. */
N#define UART_0_FPC_FF_DATA_NR_LOG2_PLUS1_MASK (0x1Fu) /* Number of bits to represent #bytes in FIFO. */
N
N
N/***************************************
N*        Registers Constants
N***************************************/
N
N#if (UART_0_FPC_SCB_IRQ_INTERNAL)
X#if ((0u == (0u)))
N    #define UART_0_FPC_ISR_NUMBER     ((uint8) UART_0_FPC_SCB_IRQ__INTC_NUMBER)
N    #define UART_0_FPC_ISR_PRIORITY   ((uint8) UART_0_FPC_SCB_IRQ__INTC_PRIOR_NUM)
N#endif /* (UART_0_FPC_SCB_IRQ_INTERNAL) */
N
N#if (UART_0_FPC_UART_RX_WAKEUP_IRQ)
X#if ((0u == (1u)))
S    #define UART_0_FPC_RX_WAKE_ISR_NUMBER     ((uint8) UART_0_FPC_RX_WAKEUP_IRQ__INTC_NUMBER)
S    #define UART_0_FPC_RX_WAKE_ISR_PRIORITY   ((uint8) UART_0_FPC_RX_WAKEUP_IRQ__INTC_PRIOR_NUM)
N#endif /* (UART_0_FPC_UART_RX_WAKEUP_IRQ) */
N
N/* UART_0_FPC_CTRL_REG */
N#define UART_0_FPC_CTRL_OVS_POS           (0u)  /* [3:0]   Oversampling factor                 */
N#define UART_0_FPC_CTRL_EC_AM_MODE_POS    (8u)  /* [8]     Externally clocked address match    */
N#define UART_0_FPC_CTRL_EC_OP_MODE_POS    (9u)  /* [9]     Externally clocked operation mode   */
N#define UART_0_FPC_CTRL_EZBUF_MODE_POS    (10u) /* [10]    EZ buffer is enabled                */
N#if !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define UART_0_FPC_CTRL_BYTE_MODE_POS (11u) /* [11]    Determines the number of bits per FIFO data element */
N#endif /* !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1) */
N#define UART_0_FPC_CTRL_ADDR_ACCEPT_POS   (16u) /* [16]    Put matched address in RX FIFO       */
N#define UART_0_FPC_CTRL_BLOCK_POS         (17u) /* [17]    Ext and Int logic to resolve collide */
N#define UART_0_FPC_CTRL_MODE_POS          (24u) /* [25:24] Operation mode                       */
N#define UART_0_FPC_CTRL_ENABLED_POS       (31u) /* [31]    Enable SCB block                     */
N#define UART_0_FPC_CTRL_OVS_MASK          ((uint32) 0x0Fu)
N#define UART_0_FPC_CTRL_EC_AM_MODE        ((uint32) 0x01u << UART_0_FPC_CTRL_EC_AM_MODE_POS)
N#define UART_0_FPC_CTRL_EC_OP_MODE        ((uint32) 0x01u << UART_0_FPC_CTRL_EC_OP_MODE_POS)
N#define UART_0_FPC_CTRL_EZBUF_MODE        ((uint32) 0x01u << UART_0_FPC_CTRL_EZBUF_MODE_POS)
N#if !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define UART_0_FPC_CTRL_BYTE_MODE ((uint32) 0x01u << UART_0_FPC_CTRL_BYTE_MODE_POS)
N#endif /* !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1) */
N#define UART_0_FPC_CTRL_ADDR_ACCEPT       ((uint32) 0x01u << UART_0_FPC_CTRL_ADDR_ACCEPT_POS)
N#define UART_0_FPC_CTRL_BLOCK             ((uint32) 0x01u << UART_0_FPC_CTRL_BLOCK_POS)
N#define UART_0_FPC_CTRL_MODE_MASK         ((uint32) 0x03u << UART_0_FPC_CTRL_MODE_POS)
N#define UART_0_FPC_CTRL_MODE_I2C          ((uint32) 0x00u)
N#define UART_0_FPC_CTRL_MODE_SPI          ((uint32) 0x01u << UART_0_FPC_CTRL_MODE_POS)
N#define UART_0_FPC_CTRL_MODE_UART         ((uint32) 0x02u << UART_0_FPC_CTRL_MODE_POS)
N#define UART_0_FPC_CTRL_ENABLED           ((uint32) 0x01u << UART_0_FPC_CTRL_ENABLED_POS)
N
N/* UART_0_FPC_STATUS_REG */
N#define UART_0_FPC_STATUS_EC_BUSY_POS     (0u)  /* [0] Bus busy. Externally clocked logic access to EZ memory */
N#define UART_0_FPC_STATUS_EC_BUSY         ((uint32) 0x0Fu)
N
N/* UART_0_FPC_SPI_CTRL_REG  */
N#define UART_0_FPC_SPI_CTRL_CONTINUOUS_POS        (0u)  /* [0]     Continuous or Separated SPI data transfers */
N#define UART_0_FPC_SPI_CTRL_SELECT_PRECEDE_POS    (1u)  /* [1]     Precedes or coincides start of data frame  */
N#define UART_0_FPC_SPI_CTRL_CPHA_POS              (2u)  /* [2]     SCLK phase                                 */
N#define UART_0_FPC_SPI_CTRL_CPOL_POS              (3u)  /* [3]     SCLK polarity                              */
N#define UART_0_FPC_SPI_CTRL_LATE_MISO_SAMPLE_POS  (4u)  /* [4]     Late MISO sample enabled                   */
N#if !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define UART_0_FPC_SPI_CTRL_SCLK_CONTINUOUS_POS   (5u)  /* [5]     Enable continuous SCLK generation */
N    #define UART_0_FPC_SPI_CTRL_SSEL0_POLARITY_POS    (8u)  /* [8]     SS0 polarity                      */
N    #define UART_0_FPC_SPI_CTRL_SSEL1_POLARITY_POS    (9u)  /* [9]     SS1 polarity                      */
N    #define UART_0_FPC_SPI_CTRL_SSEL2_POLARITY_POS    (10u) /* [10]    SS2 polarity                      */
N    #define UART_0_FPC_SPI_CTRL_SSEL3_POLARITY_POS    (11u) /* [11]    SS3 polarity                      */
N#endif /* !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1) */
N#define UART_0_FPC_SPI_CTRL_LOOPBACK_POS          (16u) /* [16]    Local loop-back control enabled            */
N#define UART_0_FPC_SPI_CTRL_MODE_POS              (24u) /* [25:24] Submode of SPI operation                   */
N#define UART_0_FPC_SPI_CTRL_SLAVE_SELECT_POS      (26u) /* [27:26] Selects SPI SS signal                      */
N#define UART_0_FPC_SPI_CTRL_MASTER_MODE_POS       (31u) /* [31]    Master mode enabled                        */
N#define UART_0_FPC_SPI_CTRL_CONTINUOUS            ((uint32) 0x01u)
N#define UART_0_FPC_SPI_CTRL_SELECT_PRECEDE        ((uint32) 0x01u << UART_0_FPC_SPI_CTRL_SELECT_PRECEDE_POS)
N#define UART_0_FPC_SPI_CTRL_SCLK_MODE_MASK        ((uint32) 0x03u << UART_0_FPC_SPI_CTRL_CPHA_POS)
N#define UART_0_FPC_SPI_CTRL_CPHA                  ((uint32) 0x01u << UART_0_FPC_SPI_CTRL_CPHA_POS)
N#define UART_0_FPC_SPI_CTRL_CPOL                  ((uint32) 0x01u << UART_0_FPC_SPI_CTRL_CPOL_POS)
N#define UART_0_FPC_SPI_CTRL_LATE_MISO_SAMPLE      ((uint32) 0x01u << \
N                                                                    UART_0_FPC_SPI_CTRL_LATE_MISO_SAMPLE_POS)
X#define UART_0_FPC_SPI_CTRL_LATE_MISO_SAMPLE      ((uint32) 0x01u <<                                                                     UART_0_FPC_SPI_CTRL_LATE_MISO_SAMPLE_POS)
N#if !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define UART_0_FPC_SPI_CTRL_SCLK_CONTINUOUS  ((uint32) 0x01u << UART_0_FPC_SPI_CTRL_SCLK_CONTINUOUS_POS)
N    #define UART_0_FPC_SPI_CTRL_SSEL0_POLARITY   ((uint32) 0x01u << UART_0_FPC_SPI_CTRL_SSEL0_POLARITY_POS)
N    #define UART_0_FPC_SPI_CTRL_SSEL1_POLARITY   ((uint32) 0x01u << UART_0_FPC_SPI_CTRL_SSEL1_POLARITY_POS)
N    #define UART_0_FPC_SPI_CTRL_SSEL2_POLARITY   ((uint32) 0x01u << UART_0_FPC_SPI_CTRL_SSEL2_POLARITY_POS)
N    #define UART_0_FPC_SPI_CTRL_SSEL3_POLARITY   ((uint32) 0x01u << UART_0_FPC_SPI_CTRL_SSEL3_POLARITY_POS)
N    #define UART_0_FPC_SPI_CTRL_SSEL_POLARITY_MASK ((uint32)0x0Fu << UART_0_FPC_SPI_CTRL_SSEL0_POLARITY_POS)
N#endif /* !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1) */
N
N#define UART_0_FPC_SPI_CTRL_LOOPBACK              ((uint32) 0x01u << UART_0_FPC_SPI_CTRL_LOOPBACK_POS)
N#define UART_0_FPC_SPI_CTRL_MODE_MASK             ((uint32) 0x03u << UART_0_FPC_SPI_CTRL_MODE_POS)
N#define UART_0_FPC_SPI_CTRL_MODE_MOTOROLA         ((uint32) 0x00u)
N#define UART_0_FPC_SPI_CTRL_MODE_TI               ((uint32) 0x01u << UART_0_FPC_CTRL_MODE_POS)
N#define UART_0_FPC_SPI_CTRL_MODE_NS               ((uint32) 0x02u << UART_0_FPC_CTRL_MODE_POS)
N#define UART_0_FPC_SPI_CTRL_SLAVE_SELECT_MASK     ((uint32) 0x03u << UART_0_FPC_SPI_CTRL_SLAVE_SELECT_POS)
N#define UART_0_FPC_SPI_CTRL_SLAVE_SELECT0         ((uint32) 0x00u)
N#define UART_0_FPC_SPI_CTRL_SLAVE_SELECT1         ((uint32) 0x01u << UART_0_FPC_SPI_CTRL_SLAVE_SELECT_POS)
N#define UART_0_FPC_SPI_CTRL_SLAVE_SELECT2         ((uint32) 0x02u << UART_0_FPC_SPI_CTRL_SLAVE_SELECT_POS)
N#define UART_0_FPC_SPI_CTRL_SLAVE_SELECT3         ((uint32) 0x03u << UART_0_FPC_SPI_CTRL_SLAVE_SELECT_POS)
N#define UART_0_FPC_SPI_CTRL_MASTER                ((uint32) 0x01u << UART_0_FPC_SPI_CTRL_MASTER_MODE_POS)
N#define UART_0_FPC_SPI_CTRL_SLAVE                 ((uint32) 0x00u)
N
N/* UART_0_FPC_SPI_STATUS_REG  */
N#define UART_0_FPC_SPI_STATUS_BUS_BUSY_POS    (0u)  /* [0]    Bus busy - slave selected */
N#define UART_0_FPC_SPI_STATUS_EZBUF_ADDR_POS  (8u)  /* [15:8] EzAddress                 */
N#define UART_0_FPC_SPI_STATUS_BUS_BUSY        ((uint32) 0x01u)
N#define UART_0_FPC_SPI_STATUS_EZBUF_ADDR_MASK ((uint32) 0xFFu << UART_0_FPC_I2C_STATUS_EZBUF_ADDR_POS)
N
N/* UART_0_FPC_UART_CTRL */
N#define UART_0_FPC_UART_CTRL_LOOPBACK_POS         (16u) /* [16] Loop-back    */
N#define UART_0_FPC_UART_CTRL_MODE_POS             (24u) /* [24] UART subMode */
N#define UART_0_FPC_UART_CTRL_LOOPBACK             ((uint32) 0x01u << UART_0_FPC_UART_CTRL_LOOPBACK_POS)
N#define UART_0_FPC_UART_CTRL_MODE_UART_STD        ((uint32) 0x00u)
N#define UART_0_FPC_UART_CTRL_MODE_UART_SMARTCARD  ((uint32) 0x01u << UART_0_FPC_UART_CTRL_MODE_POS)
N#define UART_0_FPC_UART_CTRL_MODE_UART_IRDA       ((uint32) 0x02u << UART_0_FPC_UART_CTRL_MODE_POS)
N#define UART_0_FPC_UART_CTRL_MODE_MASK            ((uint32) 0x03u << UART_0_FPC_UART_CTRL_MODE_POS)
N
N/* UART_0_FPC_UART_TX_CTRL */
N#define UART_0_FPC_UART_TX_CTRL_STOP_BITS_POS         (0u)  /* [2:0] Stop bits: (Stop bits + 1) * 0.5 period */
N#define UART_0_FPC_UART_TX_CTRL_PARITY_POS            (4u)  /* [4]   Parity bit                              */
N#define UART_0_FPC_UART_TX_CTRL_PARITY_ENABLED_POS    (5u)  /* [5]   Parity enable                           */
N#define UART_0_FPC_UART_TX_CTRL_RETRY_ON_NACK_POS     (8u)  /* [8]   Smart Card: re-send frame on NACK       */
N#define UART_0_FPC_UART_TX_CTRL_ONE_STOP_BIT          ((uint32) 0x01u)
N#define UART_0_FPC_UART_TX_CTRL_ONE_HALF_STOP_BITS    ((uint32) 0x02u)
N#define UART_0_FPC_UART_TX_CTRL_TWO_STOP_BITS         ((uint32) 0x03u)
N#define UART_0_FPC_UART_TX_CTRL_STOP_BITS_MASK        ((uint32) 0x07u)
N#define UART_0_FPC_UART_TX_CTRL_PARITY                ((uint32) 0x01u << \
N                                                                    UART_0_FPC_UART_TX_CTRL_PARITY_POS)
X#define UART_0_FPC_UART_TX_CTRL_PARITY                ((uint32) 0x01u <<                                                                     UART_0_FPC_UART_TX_CTRL_PARITY_POS)
N#define UART_0_FPC_UART_TX_CTRL_PARITY_ENABLED        ((uint32) 0x01u << \
N                                                                    UART_0_FPC_UART_TX_CTRL_PARITY_ENABLED_POS)
X#define UART_0_FPC_UART_TX_CTRL_PARITY_ENABLED        ((uint32) 0x01u <<                                                                     UART_0_FPC_UART_TX_CTRL_PARITY_ENABLED_POS)
N#define UART_0_FPC_UART_TX_CTRL_RETRY_ON_NACK         ((uint32) 0x01u << \
N                                                                    UART_0_FPC_UART_TX_CTRL_RETRY_ON_NACK_POS)
X#define UART_0_FPC_UART_TX_CTRL_RETRY_ON_NACK         ((uint32) 0x01u <<                                                                     UART_0_FPC_UART_TX_CTRL_RETRY_ON_NACK_POS)
N
N/* UART_0_FPC_UART_RX_CTRL */
N#define UART_0_FPC_UART_RX_CTRL_STOP_BITS_POS             (0u)  /* [2:0] Stop bits: (Stop bits + 1) * 0.5 period*/
N#define UART_0_FPC_UART_RX_CTRL_PARITY_POS                (4u)  /* [4]   Parity bit                             */
N#define UART_0_FPC_UART_RX_CTRL_PARITY_ENABLED_POS        (5u)  /* [5]   Parity enable                          */
N#define UART_0_FPC_UART_RX_CTRL_POLARITY_POS              (6u)  /* [6]   IrDA: inverts polarity of RX signal    */
N#define UART_0_FPC_UART_RX_CTRL_DROP_ON_PARITY_ERR_POS    (8u)  /* [8]   Drop and lost RX FIFO on parity error  */
N#define UART_0_FPC_UART_RX_CTRL_DROP_ON_FRAME_ERR_POS     (9u)  /* [9]   Drop and lost RX FIFO on frame error   */
N#define UART_0_FPC_UART_RX_CTRL_MP_MODE_POS               (10u) /* [10]  Multi-processor mode                   */
N#define UART_0_FPC_UART_RX_CTRL_LIN_MODE_POS              (12u) /* [12]  Lin mode: applicable for UART Standard */
N#define UART_0_FPC_UART_RX_CTRL_SKIP_START_POS            (13u) /* [13]  Skip start not: only for UART Standard */
N#define UART_0_FPC_UART_RX_CTRL_BREAK_WIDTH_POS           (16u) /* [19:16]  Break width: (Break width + 1)      */
N#define UART_0_FPC_UART_TX_CTRL_ONE_STOP_BIT              ((uint32) 0x01u)
N#define UART_0_FPC_UART_TX_CTRL_ONE_HALF_STOP_BITS        ((uint32) 0x02u)
N#define UART_0_FPC_UART_TX_CTRL_TWO_STOP_BITS             ((uint32) 0x03u)
N#define UART_0_FPC_UART_RX_CTRL_STOP_BITS_MASK            ((uint32) 0x07u)
N#define UART_0_FPC_UART_RX_CTRL_PARITY                    ((uint32) 0x01u << \
N                                                                    UART_0_FPC_UART_RX_CTRL_PARITY_POS)
X#define UART_0_FPC_UART_RX_CTRL_PARITY                    ((uint32) 0x01u <<                                                                     UART_0_FPC_UART_RX_CTRL_PARITY_POS)
N#define UART_0_FPC_UART_RX_CTRL_PARITY_ENABLED            ((uint32) 0x01u << \
N                                                                    UART_0_FPC_UART_RX_CTRL_PARITY_ENABLED_POS)
X#define UART_0_FPC_UART_RX_CTRL_PARITY_ENABLED            ((uint32) 0x01u <<                                                                     UART_0_FPC_UART_RX_CTRL_PARITY_ENABLED_POS)
N#define UART_0_FPC_UART_RX_CTRL_POLARITY                  ((uint32) 0x01u << \
N                                                                    UART_0_FPC_UART_RX_CTRL_POLARITY_POS)
X#define UART_0_FPC_UART_RX_CTRL_POLARITY                  ((uint32) 0x01u <<                                                                     UART_0_FPC_UART_RX_CTRL_POLARITY_POS)
N#define UART_0_FPC_UART_RX_CTRL_DROP_ON_PARITY_ERR        ((uint32) 0x01u << \
N                                                                   UART_0_FPC_UART_RX_CTRL_DROP_ON_PARITY_ERR_POS)
X#define UART_0_FPC_UART_RX_CTRL_DROP_ON_PARITY_ERR        ((uint32) 0x01u <<                                                                    UART_0_FPC_UART_RX_CTRL_DROP_ON_PARITY_ERR_POS)
N#define UART_0_FPC_UART_RX_CTRL_DROP_ON_FRAME_ERR         ((uint32) 0x01u << \
N                                                                    UART_0_FPC_UART_RX_CTRL_DROP_ON_FRAME_ERR_POS)
X#define UART_0_FPC_UART_RX_CTRL_DROP_ON_FRAME_ERR         ((uint32) 0x01u <<                                                                     UART_0_FPC_UART_RX_CTRL_DROP_ON_FRAME_ERR_POS)
N#define UART_0_FPC_UART_RX_CTRL_MP_MODE                   ((uint32) 0x01u << \
N                                                                    UART_0_FPC_UART_RX_CTRL_MP_MODE_POS)
X#define UART_0_FPC_UART_RX_CTRL_MP_MODE                   ((uint32) 0x01u <<                                                                     UART_0_FPC_UART_RX_CTRL_MP_MODE_POS)
N#define UART_0_FPC_UART_RX_CTRL_LIN_MODE                  ((uint32) 0x01u << \
N                                                                    UART_0_FPC_UART_RX_CTRL_LIN_MODE_POS)
X#define UART_0_FPC_UART_RX_CTRL_LIN_MODE                  ((uint32) 0x01u <<                                                                     UART_0_FPC_UART_RX_CTRL_LIN_MODE_POS)
N#define UART_0_FPC_UART_RX_CTRL_SKIP_START                ((uint32) 0x01u << \
N                                                                    UART_0_FPC_UART_RX_CTRL_SKIP_START_POS)
X#define UART_0_FPC_UART_RX_CTRL_SKIP_START                ((uint32) 0x01u <<                                                                     UART_0_FPC_UART_RX_CTRL_SKIP_START_POS)
N#define UART_0_FPC_UART_RX_CTRL_BREAK_WIDTH_MASK          ((uint32) 0x0Fu << \
N                                                                    UART_0_FPC_UART_RX_CTRL_BREAK_WIDTH_POS)
X#define UART_0_FPC_UART_RX_CTRL_BREAK_WIDTH_MASK          ((uint32) 0x0Fu <<                                                                     UART_0_FPC_UART_RX_CTRL_BREAK_WIDTH_POS)
N/* UART_0_FPC_UART_RX_STATUS_REG */
N#define UART_0_FPC_UART_RX_STATUS_BR_COUNTER_POS     (0u)  /* [11:0] Baud Rate counter */
N#define UART_0_FPC_UART_RX_STATUS_BR_COUNTER_MASK    ((uint32) 0xFFFu)
N
N#if !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    /* UART_0_FPC_UART_FLOW_CTRL_REG */
N    #define UART_0_FPC_UART_FLOW_CTRL_TRIGGER_LEVEL_POS    (0u)  /* [7:0] RTS RX FIFO trigger level         */
N    #define UART_0_FPC_UART_FLOW_CTRL_RTS_POLARITY_POS     (16u) /* [16]  Polarity of the RTS output signal */
N    #define UART_0_FPC_UART_FLOW_CTRL_CTS_POLARITY_POS     (24u) /* [24]  Polarity of the CTS input signal  */
N    #define UART_0_FPC_UART_FLOW_CTRL_CTS_ENABLED_POS      (25u) /* [25]  Enable CTS signal                 */
N    #define UART_0_FPC_UART_FLOW_CTRL_TRIGGER_LEVEL_MASK   ((uint32) UART_0_FPC_FF_DATA_NR_LOG2_MASK)
N    #define UART_0_FPC_UART_FLOW_CTRL_RTS_POLARITY         ((uint32) 0x01u << \
N                                                                       UART_0_FPC_UART_FLOW_CTRL_RTS_POLARITY_POS)
X    #define UART_0_FPC_UART_FLOW_CTRL_RTS_POLARITY         ((uint32) 0x01u <<                                                                        UART_0_FPC_UART_FLOW_CTRL_RTS_POLARITY_POS)
N    #define UART_0_FPC_UART_FLOW_CTRL_CTS_POLARITY         ((uint32) 0x01u << \
N                                                                       UART_0_FPC_UART_FLOW_CTRL_CTS_POLARITY_POS)
X    #define UART_0_FPC_UART_FLOW_CTRL_CTS_POLARITY         ((uint32) 0x01u <<                                                                        UART_0_FPC_UART_FLOW_CTRL_CTS_POLARITY_POS)
N    #define UART_0_FPC_UART_FLOW_CTRL_CTS_ENABLE           ((uint32) 0x01u << \
N                                                                       UART_0_FPC_UART_FLOW_CTRL_CTS_ENABLED_POS)
X    #define UART_0_FPC_UART_FLOW_CTRL_CTS_ENABLE           ((uint32) 0x01u <<                                                                        UART_0_FPC_UART_FLOW_CTRL_CTS_ENABLED_POS)
N#endif /* !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1) */
N
N/* UART_0_FPC_I2C_CTRL */
N#define UART_0_FPC_I2C_CTRL_HIGH_PHASE_OVS_POS           (0u)   /* [3:0] Oversampling factor high: master only */
N#define UART_0_FPC_I2C_CTRL_LOW_PHASE_OVS_POS            (4u)   /* [7:4] Oversampling factor low:  master only */
N#define UART_0_FPC_I2C_CTRL_M_READY_DATA_ACK_POS         (8u)   /* [8]   Master ACKs data while RX FIFO != FULL*/
N#define UART_0_FPC_I2C_CTRL_M_NOT_READY_DATA_NACK_POS    (9u)   /* [9]   Master NACKs data if RX FIFO ==  FULL */
N#define UART_0_FPC_I2C_CTRL_S_GENERAL_IGNORE_POS         (11u)  /* [11]  Slave ignores General call            */
N#define UART_0_FPC_I2C_CTRL_S_READY_ADDR_ACK_POS         (12u)  /* [12]  Slave ACKs Address if RX FIFO != FULL */
N#define UART_0_FPC_I2C_CTRL_S_READY_DATA_ACK_POS         (13u)  /* [13]  Slave ACKs data while RX FIFO == FULL */
N#define UART_0_FPC_I2C_CTRL_S_NOT_READY_ADDR_NACK_POS    (14u)  /* [14]  Slave NACKs address if RX FIFO == FULL*/
N#define UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK_POS    (15u)  /* [15]  Slave NACKs data if RX FIFO is  FULL  */
N#define UART_0_FPC_I2C_CTRL_LOOPBACK_POS                 (16u)  /* [16]  Loop-back                             */
N#define UART_0_FPC_I2C_CTRL_SLAVE_MODE_POS               (30u)  /* [30]  Slave mode enabled                    */
N#define UART_0_FPC_I2C_CTRL_MASTER_MODE_POS              (31u)  /* [31]  Master mode enabled                   */
N#define UART_0_FPC_I2C_CTRL_HIGH_PHASE_OVS_MASK  ((uint32) 0x0Fu)
N#define UART_0_FPC_I2C_CTRL_LOW_PHASE_OVS_MASK   ((uint32) 0x0Fu << \
N                                                                UART_0_FPC_I2C_CTRL_LOW_PHASE_OVS_POS)
X#define UART_0_FPC_I2C_CTRL_LOW_PHASE_OVS_MASK   ((uint32) 0x0Fu <<                                                                 UART_0_FPC_I2C_CTRL_LOW_PHASE_OVS_POS)
N#define UART_0_FPC_I2C_CTRL_M_READY_DATA_ACK      ((uint32) 0x01u << \
N                                                                UART_0_FPC_I2C_CTRL_M_READY_DATA_ACK_POS)
X#define UART_0_FPC_I2C_CTRL_M_READY_DATA_ACK      ((uint32) 0x01u <<                                                                 UART_0_FPC_I2C_CTRL_M_READY_DATA_ACK_POS)
N#define UART_0_FPC_I2C_CTRL_M_NOT_READY_DATA_NACK ((uint32) 0x01u << \
N                                                                UART_0_FPC_I2C_CTRL_M_NOT_READY_DATA_NACK_POS)
X#define UART_0_FPC_I2C_CTRL_M_NOT_READY_DATA_NACK ((uint32) 0x01u <<                                                                 UART_0_FPC_I2C_CTRL_M_NOT_READY_DATA_NACK_POS)
N#define UART_0_FPC_I2C_CTRL_S_GENERAL_IGNORE      ((uint32) 0x01u << \
N                                                                UART_0_FPC_I2C_CTRL_S_GENERAL_IGNORE_POS)
X#define UART_0_FPC_I2C_CTRL_S_GENERAL_IGNORE      ((uint32) 0x01u <<                                                                 UART_0_FPC_I2C_CTRL_S_GENERAL_IGNORE_POS)
N#define UART_0_FPC_I2C_CTRL_S_READY_ADDR_ACK      ((uint32) 0x01u << \
N                                                                UART_0_FPC_I2C_CTRL_S_READY_ADDR_ACK_POS)
X#define UART_0_FPC_I2C_CTRL_S_READY_ADDR_ACK      ((uint32) 0x01u <<                                                                 UART_0_FPC_I2C_CTRL_S_READY_ADDR_ACK_POS)
N#define UART_0_FPC_I2C_CTRL_S_READY_DATA_ACK      ((uint32) 0x01u << \
N                                                                UART_0_FPC_I2C_CTRL_S_READY_DATA_ACK_POS)
X#define UART_0_FPC_I2C_CTRL_S_READY_DATA_ACK      ((uint32) 0x01u <<                                                                 UART_0_FPC_I2C_CTRL_S_READY_DATA_ACK_POS)
N#define UART_0_FPC_I2C_CTRL_S_NOT_READY_ADDR_NACK ((uint32) 0x01u << \
N                                                                UART_0_FPC_I2C_CTRL_S_NOT_READY_ADDR_NACK_POS)
X#define UART_0_FPC_I2C_CTRL_S_NOT_READY_ADDR_NACK ((uint32) 0x01u <<                                                                 UART_0_FPC_I2C_CTRL_S_NOT_READY_ADDR_NACK_POS)
N#define UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK ((uint32) 0x01u << \
N                                                                UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK_POS)
X#define UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK ((uint32) 0x01u <<                                                                 UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK_POS)
N#define UART_0_FPC_I2C_CTRL_LOOPBACK              ((uint32) 0x01u << \
N                                                                UART_0_FPC_I2C_CTRL_LOOPBACK_POS)
X#define UART_0_FPC_I2C_CTRL_LOOPBACK              ((uint32) 0x01u <<                                                                 UART_0_FPC_I2C_CTRL_LOOPBACK_POS)
N#define UART_0_FPC_I2C_CTRL_SLAVE_MODE            ((uint32) 0x01u << \
N                                                                UART_0_FPC_I2C_CTRL_SLAVE_MODE_POS)
X#define UART_0_FPC_I2C_CTRL_SLAVE_MODE            ((uint32) 0x01u <<                                                                 UART_0_FPC_I2C_CTRL_SLAVE_MODE_POS)
N#define UART_0_FPC_I2C_CTRL_MASTER_MODE           ((uint32) 0x01u << \
N                                                                UART_0_FPC_I2C_CTRL_MASTER_MODE_POS)
X#define UART_0_FPC_I2C_CTRL_MASTER_MODE           ((uint32) 0x01u <<                                                                 UART_0_FPC_I2C_CTRL_MASTER_MODE_POS)
N#define UART_0_FPC_I2C_CTRL_SLAVE_MASTER_MODE_MASK    ((uint32) 0x03u << \
N                                                                UART_0_FPC_I2C_CTRL_SLAVE_MODE_POS)
X#define UART_0_FPC_I2C_CTRL_SLAVE_MASTER_MODE_MASK    ((uint32) 0x03u <<                                                                 UART_0_FPC_I2C_CTRL_SLAVE_MODE_POS)
N
N/* UART_0_FPC_I2C_STATUS_REG  */
N#define UART_0_FPC_I2C_STATUS_BUS_BUSY_POS    (0u)  /* [0]    Bus busy: internally clocked */
N#define UART_0_FPC_I2C_STATUS_S_READ_POS      (4u)  /* [4]    Slave is read by master      */
N#define UART_0_FPC_I2C_STATUS_M_READ_POS      (5u)  /* [5]    Master reads Slave           */
N#define UART_0_FPC_I2C_STATUS_EZBUF_ADDR_POS  (8u)  /* [15:8] EZAddress                    */
N#define UART_0_FPC_I2C_STATUS_BUS_BUSY        ((uint32) 0x01u)
N#define UART_0_FPC_I2C_STATUS_S_READ          ((uint32) 0x01u << UART_0_FPC_I2C_STATUS_S_READ_POS)
N#define UART_0_FPC_I2C_STATUS_M_READ          ((uint32) 0x01u << UART_0_FPC_I2C_STATUS_M_READ_POS)
N#define UART_0_FPC_I2C_STATUS_EZBUF_ADDR_MASK ((uint32) 0xFFu << UART_0_FPC_I2C_STATUS_EZBUF_ADDR_POS)
N
N/* UART_0_FPC_I2C_MASTER_CMD_REG */
N#define UART_0_FPC_I2C_MASTER_CMD_M_START_POS             (0u)  /* [0] Master generate Start                */
N#define UART_0_FPC_I2C_MASTER_CMD_M_START_ON_IDLE_POS     (1u)  /* [1] Master generate Start if bus is free */
N#define UART_0_FPC_I2C_MASTER_CMD_M_ACK_POS               (2u)  /* [2] Master generate ACK                  */
N#define UART_0_FPC_I2C_MASTER_CMD_M_NACK_POS              (3u)  /* [3] Master generate NACK                 */
N#define UART_0_FPC_I2C_MASTER_CMD_M_STOP_POS              (4u)  /* [4] Master generate Stop                 */
N#define UART_0_FPC_I2C_MASTER_CMD_M_START         ((uint32) 0x01u)
N#define UART_0_FPC_I2C_MASTER_CMD_M_START_ON_IDLE ((uint32) 0x01u << \
N                                                                   UART_0_FPC_I2C_MASTER_CMD_M_START_ON_IDLE_POS)
X#define UART_0_FPC_I2C_MASTER_CMD_M_START_ON_IDLE ((uint32) 0x01u <<                                                                    UART_0_FPC_I2C_MASTER_CMD_M_START_ON_IDLE_POS)
N#define UART_0_FPC_I2C_MASTER_CMD_M_ACK           ((uint32) 0x01u << \
N                                                                   UART_0_FPC_I2C_MASTER_CMD_M_ACK_POS)
X#define UART_0_FPC_I2C_MASTER_CMD_M_ACK           ((uint32) 0x01u <<                                                                    UART_0_FPC_I2C_MASTER_CMD_M_ACK_POS)
N#define UART_0_FPC_I2C_MASTER_CMD_M_NACK          ((uint32) 0x01u << \
N                                                                    UART_0_FPC_I2C_MASTER_CMD_M_NACK_POS)
X#define UART_0_FPC_I2C_MASTER_CMD_M_NACK          ((uint32) 0x01u <<                                                                     UART_0_FPC_I2C_MASTER_CMD_M_NACK_POS)
N#define UART_0_FPC_I2C_MASTER_CMD_M_STOP          ((uint32) 0x01u << \
N                                                                    UART_0_FPC_I2C_MASTER_CMD_M_STOP_POS)
X#define UART_0_FPC_I2C_MASTER_CMD_M_STOP          ((uint32) 0x01u <<                                                                     UART_0_FPC_I2C_MASTER_CMD_M_STOP_POS)
N
N/* UART_0_FPC_I2C_SLAVE_CMD_REG  */
N#define UART_0_FPC_I2C_SLAVE_CMD_S_ACK_POS    (0u)  /* [0] Slave generate ACK  */
N#define UART_0_FPC_I2C_SLAVE_CMD_S_NACK_POS   (1u)  /* [1] Slave generate NACK */
N#define UART_0_FPC_I2C_SLAVE_CMD_S_ACK        ((uint32) 0x01u)
N#define UART_0_FPC_I2C_SLAVE_CMD_S_NACK       ((uint32) 0x01u << UART_0_FPC_I2C_SLAVE_CMD_S_NACK_POS)
N
N#define UART_0_FPC_I2C_SLAVE_CMD_S_ACK_POS    (0u)  /* [0] Slave generate ACK  */
N#define UART_0_FPC_I2C_SLAVE_CMD_S_NACK_POS   (1u)  /* [1] Slave generate NACK */
N#define UART_0_FPC_I2C_SLAVE_CMD_S_ACK        ((uint32) 0x01u)
N#define UART_0_FPC_I2C_SLAVE_CMD_S_NACK       ((uint32) 0x01u << UART_0_FPC_I2C_SLAVE_CMD_S_NACK_POS)
N
N/* UART_0_FPC_I2C_CFG_REG */
N#if (UART_0_FPC_CY_SCBIP_V0)
X#if ((2 == 0u))
S#define UART_0_FPC_I2C_CFG_SDA_FILT_HYS_POS           (0u)  /* [1:0]   Trim bits for the I2C SDA filter         */
S#define UART_0_FPC_I2C_CFG_SDA_FILT_TRIM_POS          (2u)  /* [3:2]   Trim bits for the I2C SDA filter         */
S#define UART_0_FPC_I2C_CFG_SCL_FILT_HYS_POS           (4u)  /* [5:4]   Trim bits for the I2C SCL filter         */
S#define UART_0_FPC_I2C_CFG_SCL_FILT_TRIM_POS          (6u)  /* [7:6]   Trim bits for the I2C SCL filter         */
S#define UART_0_FPC_I2C_CFG_SDA_FILT_OUT_HYS_POS       (8u)  /* [9:8]   Trim bits for I2C SDA filter output path */
S#define UART_0_FPC_I2C_CFG_SDA_FILT_OUT_TRIM_POS      (10u) /* [11:10] Trim bits for I2C SDA filter output path */
S#define UART_0_FPC_I2C_CFG_SDA_FILT_HS_POS            (16u) /* [16]    '0': 50 ns filter, '1': 10 ns filter     */
S#define UART_0_FPC_I2C_CFG_SDA_FILT_ENABLED_POS       (17u) /* [17]    I2C SDA filter enabled                   */
S#define UART_0_FPC_I2C_CFG_SCL_FILT_HS_POS            (24u) /* [24]    '0': 50 ns filter, '1': 10 ns filter     */
S#define UART_0_FPC_I2C_CFG_SCL_FILT_ENABLED_POS       (25u) /* [25]    I2C SCL filter enabled                   */
S#define UART_0_FPC_I2C_CFG_SDA_FILT_OUT_HS_POS        (26u) /* [26]    '0': 50 ns filter, '1': 10 ns filter     */
S#define UART_0_FPC_I2C_CFG_SDA_FILT_OUT_ENABLED_POS   (27u) /* [27]    I2C SDA output delay filter enabled      */
S#define UART_0_FPC_I2C_CFG_SDA_FILT_HYS_MASK          ((uint32) 0x03u)
S#define UART_0_FPC_I2C_CFG_SDA_FILT_TRIM_MASK         ((uint32) 0x03u << \
S                                                                UART_0_FPC_I2C_CFG_SDA_FILT_TRIM_POS)
X#define UART_0_FPC_I2C_CFG_SDA_FILT_TRIM_MASK         ((uint32) 0x03u <<                                                                 UART_0_FPC_I2C_CFG_SDA_FILT_TRIM_POS)
S#define UART_0_FPC_I2C_CFG_SCL_FILT_HYS_MASK          ((uint32) 0x03u << \
S                                                                UART_0_FPC_I2C_CFG_SCL_FILT_HYS_POS)
X#define UART_0_FPC_I2C_CFG_SCL_FILT_HYS_MASK          ((uint32) 0x03u <<                                                                 UART_0_FPC_I2C_CFG_SCL_FILT_HYS_POS)
S#define UART_0_FPC_I2C_CFG_SCL_FILT_TRIM_MASK         ((uint32) 0x03u << \
S                                                                UART_0_FPC_I2C_CFG_SCL_FILT_TRIM_POS)
X#define UART_0_FPC_I2C_CFG_SCL_FILT_TRIM_MASK         ((uint32) 0x03u <<                                                                 UART_0_FPC_I2C_CFG_SCL_FILT_TRIM_POS)
S#define UART_0_FPC_I2C_CFG_SDA_FILT_OUT_HYS_MASK      ((uint32) 0x03u << \
S                                                                UART_0_FPC_I2C_CFG_SDA_FILT_OUT_HYS_POS)
X#define UART_0_FPC_I2C_CFG_SDA_FILT_OUT_HYS_MASK      ((uint32) 0x03u <<                                                                 UART_0_FPC_I2C_CFG_SDA_FILT_OUT_HYS_POS)
S#define UART_0_FPC_I2C_CFG_SDA_FILT_OUT_TRIM_MASK     ((uint32) 0x03u << \
S                                                                UART_0_FPC_I2C_CFG_SDA_FILT_OUT_TRIM_POS)
X#define UART_0_FPC_I2C_CFG_SDA_FILT_OUT_TRIM_MASK     ((uint32) 0x03u <<                                                                 UART_0_FPC_I2C_CFG_SDA_FILT_OUT_TRIM_POS)
S#define UART_0_FPC_I2C_CFG_SDA_FILT_HS                ((uint32) 0x01u << \
S                                                                UART_0_FPC_I2C_CFG_SDA_FILT_HS_POS)
X#define UART_0_FPC_I2C_CFG_SDA_FILT_HS                ((uint32) 0x01u <<                                                                 UART_0_FPC_I2C_CFG_SDA_FILT_HS_POS)
S#define UART_0_FPC_I2C_CFG_SDA_FILT_ENABLED           ((uint32) 0x01u << \
S                                                                UART_0_FPC_I2C_CFG_SDA_FILT_ENABLED_POS)
X#define UART_0_FPC_I2C_CFG_SDA_FILT_ENABLED           ((uint32) 0x01u <<                                                                 UART_0_FPC_I2C_CFG_SDA_FILT_ENABLED_POS)
S#define UART_0_FPC_I2C_CFG_SCL_FILT_HS                ((uint32) 0x01u << \
S                                                                UART_0_FPC_I2C_CFG_SCL_FILT_HS_POS)
X#define UART_0_FPC_I2C_CFG_SCL_FILT_HS                ((uint32) 0x01u <<                                                                 UART_0_FPC_I2C_CFG_SCL_FILT_HS_POS)
S#define UART_0_FPC_I2C_CFG_SCL_FILT_ENABLED           ((uint32) 0x01u << \
S                                                                UART_0_FPC_I2C_CFG_SCL_FILT_ENABLED_POS)
X#define UART_0_FPC_I2C_CFG_SCL_FILT_ENABLED           ((uint32) 0x01u <<                                                                 UART_0_FPC_I2C_CFG_SCL_FILT_ENABLED_POS)
S#define UART_0_FPC_I2C_CFG_SDA_FILT_OUT_HS            ((uint32) 0x01u << \
S                                                                UART_0_FPC_I2C_CFG_SDA_FILT_OUT_HS_POS)
X#define UART_0_FPC_I2C_CFG_SDA_FILT_OUT_HS            ((uint32) 0x01u <<                                                                 UART_0_FPC_I2C_CFG_SDA_FILT_OUT_HS_POS)
S#define UART_0_FPC_I2C_CFG_SDA_FILT_OUT_ENABLED       ((uint32) 0x01u << \
S                                                                UART_0_FPC_I2C_CFG_SDA_FILT_OUT_ENABLED_POS)
X#define UART_0_FPC_I2C_CFG_SDA_FILT_OUT_ENABLED       ((uint32) 0x01u <<                                                                 UART_0_FPC_I2C_CFG_SDA_FILT_OUT_ENABLED_POS)
N#else
N#define UART_0_FPC_I2C_CFG_SDA_IN_FILT_TRIM_POS   (0u)  /* [1:0] Trim bits for "i2c_sda_in" 50 ns filter */
N#define UART_0_FPC_I2C_CFG_SDA_IN_FILT_SEL_POS    (4u)  /* [4]   "i2c_sda_in" filter delay: 0 ns and 50 ns */
N#define UART_0_FPC_I2C_CFG_SCL_IN_FILT_TRIM_POS   (8u)  /* [9:8] Trim bits for "i2c_scl_in" 50 ns filter */
N#define UART_0_FPC_I2C_CFG_SCL_IN_FILT_SEL_POS    (12u) /* [12]  "i2c_scl_in" filter delay: 0 ns and 50 ns */
N#define UART_0_FPC_I2C_CFG_SDA_OUT_FILT0_TRIM_POS (16u) /* [17:16] Trim bits for "i2c_sda_out" 50 ns filter 0 */
N#define UART_0_FPC_I2C_CFG_SDA_OUT_FILT1_TRIM_POS (18u) /* [19:18] Trim bits for "i2c_sda_out" 50 ns filter 1 */
N#define UART_0_FPC_I2C_CFG_SDA_OUT_FILT2_TRIM_POS (20u) /* [21:20] Trim bits for "i2c_sda_out" 50 ns filter 2 */
N#define UART_0_FPC_I2C_CFG_SDA_OUT_FILT_SEL_POS   (28u) /* [29:28] Cumulative "i2c_sda_out" filter delay: */
N
N#define UART_0_FPC_I2C_CFG_SDA_IN_FILT_TRIM_MASK  ((uint32) 0x03u)
N#define UART_0_FPC_I2C_CFG_SDA_IN_FILT_SEL        ((uint32) 0x01u << UART_0_FPC_I2C_CFG_SDA_IN_FILT_SEL_POS)
N#define UART_0_FPC_I2C_CFG_SCL_IN_FILT_TRIM_MASK  ((uint32) 0x03u << \
N                                                            UART_0_FPC_I2C_CFG_SCL_IN_FILT_TRIM_POS)
X#define UART_0_FPC_I2C_CFG_SCL_IN_FILT_TRIM_MASK  ((uint32) 0x03u <<                                                             UART_0_FPC_I2C_CFG_SCL_IN_FILT_TRIM_POS)
N#define UART_0_FPC_I2C_CFG_SCL_IN_FILT_SEL        ((uint32) 0x01u << UART_0_FPC_I2C_CFG_SCL_IN_FILT_SEL_POS)
N#define UART_0_FPC_I2C_CFG_SDA_OUT_FILT0_TRIM_MASK ((uint32) 0x03u << \
N                                                            UART_0_FPC_I2C_CFG_SDA_OUT_FILT0_TRIM_POS)
X#define UART_0_FPC_I2C_CFG_SDA_OUT_FILT0_TRIM_MASK ((uint32) 0x03u <<                                                             UART_0_FPC_I2C_CFG_SDA_OUT_FILT0_TRIM_POS)
N#define UART_0_FPC_I2C_CFG_SDA_OUT_FILT1_TRIM_MASK ((uint32) 0x03u << \
N                                                            UART_0_FPC_I2C_CFG_SDA_OUT_FILT1_TRIM_POS)
X#define UART_0_FPC_I2C_CFG_SDA_OUT_FILT1_TRIM_MASK ((uint32) 0x03u <<                                                             UART_0_FPC_I2C_CFG_SDA_OUT_FILT1_TRIM_POS)
N#define UART_0_FPC_I2C_CFG_SDA_OUT_FILT2_TRIM_MASK ((uint32) 0x03u << \
N                                                            UART_0_FPC_I2C_CFG_SDA_OUT_FILT2_TRIM_POS)
X#define UART_0_FPC_I2C_CFG_SDA_OUT_FILT2_TRIM_MASK ((uint32) 0x03u <<                                                             UART_0_FPC_I2C_CFG_SDA_OUT_FILT2_TRIM_POS)
N#define UART_0_FPC_I2C_CFG_SDA_OUT_FILT_SEL_MASK   ((uint32) 0x03u << \
N                                                            UART_0_FPC_I2C_CFG_SDA_OUT_FILT_SEL_POS)
X#define UART_0_FPC_I2C_CFG_SDA_OUT_FILT_SEL_MASK   ((uint32) 0x03u <<                                                             UART_0_FPC_I2C_CFG_SDA_OUT_FILT_SEL_POS)
N#endif /* (UART_0_FPC_CY_SCBIP_V0) */
N
N
N/* UART_0_FPC_TX_CTRL_REG */
N#define UART_0_FPC_TX_CTRL_DATA_WIDTH_POS     (0u)  /* [3:0] Data frame width: (Data width - 1) */
N#define UART_0_FPC_TX_CTRL_MSB_FIRST_POS      (8u)  /* [8]   MSB first shifter-out             */
N#define UART_0_FPC_TX_CTRL_ENABLED_POS        (31u) /* [31]  Transmitter enabled               */
N#define UART_0_FPC_TX_CTRL_DATA_WIDTH_MASK    ((uint32) 0x0Fu)
N#define UART_0_FPC_TX_CTRL_MSB_FIRST          ((uint32) 0x01u << UART_0_FPC_TX_CTRL_MSB_FIRST_POS)
N#define UART_0_FPC_TX_CTRL_LSB_FIRST          ((uint32) 0x00u)
N#define UART_0_FPC_TX_CTRL_ENABLED            ((uint32) 0x01u << UART_0_FPC_TX_CTRL_ENABLED_POS)
N
N/* UART_0_FPC_TX_CTRL_FIFO_REG */
N#define UART_0_FPC_TX_FIFO_CTRL_TRIGGER_LEVEL_POS     (0u)  /* [2:0] Trigger level                              */
N#define UART_0_FPC_TX_FIFO_CTRL_CLEAR_POS             (16u) /* [16]  Clear TX FIFO: cleared after set           */
N#define UART_0_FPC_TX_FIFO_CTRL_FREEZE_POS            (17u) /* [17]  Freeze TX FIFO: HW do not inc read pointer */
N#define UART_0_FPC_TX_FIFO_CTRL_TRIGGER_LEVEL_MASK    ((uint32) UART_0_FPC_FF_DATA_NR_LOG2_MASK)
N#define UART_0_FPC_TX_FIFO_CTRL_CLEAR                 ((uint32) 0x01u << UART_0_FPC_TX_FIFO_CTRL_CLEAR_POS)
N#define UART_0_FPC_TX_FIFO_CTRL_FREEZE                ((uint32) 0x01u << UART_0_FPC_TX_FIFO_CTRL_FREEZE_POS)
N
N/* UART_0_FPC_TX_FIFO_STATUS_REG */
N#define UART_0_FPC_TX_FIFO_STATUS_USED_POS    (0u)  /* [3:0]   Amount of entries in TX FIFO */
N#define UART_0_FPC_TX_FIFO_SR_VALID_POS       (15u) /* [15]    Shifter status of TX FIFO    */
N#define UART_0_FPC_TX_FIFO_STATUS_RD_PTR_POS  (16u) /* [18:16] TX FIFO read pointer         */
N#define UART_0_FPC_TX_FIFO_STATUS_WR_PTR_POS  (24u) /* [26:24] TX FIFO write pointer        */
N#define UART_0_FPC_TX_FIFO_STATUS_USED_MASK   ((uint32) UART_0_FPC_FF_DATA_NR_LOG2_PLUS1_MASK)
N#define UART_0_FPC_TX_FIFO_SR_VALID           ((uint32) 0x01u << UART_0_FPC_TX_FIFO_SR_VALID_POS)
N#define UART_0_FPC_TX_FIFO_STATUS_RD_PTR_MASK ((uint32) UART_0_FPC_FF_DATA_NR_LOG2_MASK << \
N                                                                    UART_0_FPC_TX_FIFO_STATUS_RD_PTR_POS)
X#define UART_0_FPC_TX_FIFO_STATUS_RD_PTR_MASK ((uint32) UART_0_FPC_FF_DATA_NR_LOG2_MASK <<                                                                     UART_0_FPC_TX_FIFO_STATUS_RD_PTR_POS)
N#define UART_0_FPC_TX_FIFO_STATUS_WR_PTR_MASK ((uint32) UART_0_FPC_FF_DATA_NR_LOG2_MASK << \
N                                                                    UART_0_FPC_TX_FIFO_STATUS_WR_PTR_POS)
X#define UART_0_FPC_TX_FIFO_STATUS_WR_PTR_MASK ((uint32) UART_0_FPC_FF_DATA_NR_LOG2_MASK <<                                                                     UART_0_FPC_TX_FIFO_STATUS_WR_PTR_POS)
N
N/* UART_0_FPC_TX_FIFO_WR_REG */
N#define UART_0_FPC_TX_FIFO_WR_POS    (0u)  /* [15:0] Data written into TX FIFO */
N#define UART_0_FPC_TX_FIFO_WR_MASK   ((uint32) 0xFFu)
N
N/* UART_0_FPC_RX_CTRL_REG */
N#define UART_0_FPC_RX_CTRL_DATA_WIDTH_POS     (0u)  /* [3:0] Data frame width: (Data width - 1) */
N#define UART_0_FPC_RX_CTRL_MSB_FIRST_POS      (8u)  /* [8]   MSB first shifter-out             */
N#define UART_0_FPC_RX_CTRL_MEDIAN_POS         (9u)  /* [9]   Median filter                     */
N#define UART_0_FPC_RX_CTRL_ENABLED_POS        (31u) /* [31]  Receiver enabled                  */
N#define UART_0_FPC_RX_CTRL_DATA_WIDTH_MASK    ((uint32) 0x0Fu)
N#define UART_0_FPC_RX_CTRL_MSB_FIRST          ((uint32) 0x01u << UART_0_FPC_RX_CTRL_MSB_FIRST_POS)
N#define UART_0_FPC_RX_CTRL_LSB_FIRST          ((uint32) 0x00u)
N#define UART_0_FPC_RX_CTRL_MEDIAN             ((uint32) 0x01u << UART_0_FPC_RX_CTRL_MEDIAN_POS)
N#define UART_0_FPC_RX_CTRL_ENABLED            ((uint32) 0x01u << UART_0_FPC_RX_CTRL_ENABLED_POS)
N
N
N/* UART_0_FPC_RX_FIFO_CTRL_REG */
N#define UART_0_FPC_RX_FIFO_CTRL_TRIGGER_LEVEL_POS     (0u)   /* [2:0] Trigger level                            */
N#define UART_0_FPC_RX_FIFO_CTRL_CLEAR_POS             (16u)  /* [16]  Clear RX FIFO: clear after set           */
N#define UART_0_FPC_RX_FIFO_CTRL_FREEZE_POS            (17u)  /* [17]  Freeze RX FIFO: HW writes has not effect */
N#define UART_0_FPC_RX_FIFO_CTRL_TRIGGER_LEVEL_MASK    ((uint32) UART_0_FPC_FF_DATA_NR_LOG2_MASK)
N#define UART_0_FPC_RX_FIFO_CTRL_CLEAR                 ((uint32) 0x01u << UART_0_FPC_RX_FIFO_CTRL_CLEAR_POS)
N#define UART_0_FPC_RX_FIFO_CTRL_FREEZE                ((uint32) 0x01u << UART_0_FPC_RX_FIFO_CTRL_FREEZE_POS)
N
N/* UART_0_FPC_RX_FIFO_STATUS_REG */
N#define UART_0_FPC_RX_FIFO_STATUS_USED_POS    (0u)   /* [3:0]   Amount of entries in RX FIFO */
N#define UART_0_FPC_RX_FIFO_SR_VALID_POS       (15u)  /* [15]    Shifter status of RX FIFO    */
N#define UART_0_FPC_RX_FIFO_STATUS_RD_PTR_POS  (16u)  /* [18:16] RX FIFO read pointer         */
N#define UART_0_FPC_RX_FIFO_STATUS_WR_PTR_POS  (24u)  /* [26:24] RX FIFO write pointer        */
N#define UART_0_FPC_RX_FIFO_STATUS_USED_MASK   ((uint32) UART_0_FPC_FF_DATA_NR_LOG2_PLUS1_MASK)
N#define UART_0_FPC_RX_FIFO_SR_VALID           ((uint32) 0x01u << UART_0_FPC_RX_FIFO_SR_VALID_POS)
N#define UART_0_FPC_RX_FIFO_STATUS_RD_PTR_MASK ((uint32) UART_0_FPC_FF_DATA_NR_LOG2_MASK << \
N                                                                    UART_0_FPC_RX_FIFO_STATUS_RD_PTR_POS)
X#define UART_0_FPC_RX_FIFO_STATUS_RD_PTR_MASK ((uint32) UART_0_FPC_FF_DATA_NR_LOG2_MASK <<                                                                     UART_0_FPC_RX_FIFO_STATUS_RD_PTR_POS)
N#define UART_0_FPC_RX_FIFO_STATUS_WR_PTR_MASK ((uint32) UART_0_FPC_FF_DATA_NR_LOG2_MASK << \
N                                                                    UART_0_FPC_RX_FIFO_STATUS_WR_PTR_POS)
X#define UART_0_FPC_RX_FIFO_STATUS_WR_PTR_MASK ((uint32) UART_0_FPC_FF_DATA_NR_LOG2_MASK <<                                                                     UART_0_FPC_RX_FIFO_STATUS_WR_PTR_POS)
N
N/* UART_0_FPC_RX_MATCH_REG */
N#define UART_0_FPC_RX_MATCH_ADDR_POS     (0u)  /* [7:0]   Slave address                        */
N#define UART_0_FPC_RX_MATCH_MASK_POS     (16u) /* [23:16] Slave address mask: 0 - doesn't care */
N#define UART_0_FPC_RX_MATCH_ADDR_MASK    ((uint32) 0xFFu)
N#define UART_0_FPC_RX_MATCH_MASK_MASK    ((uint32) 0xFFu << UART_0_FPC_RX_MATCH_MASK_POS)
N
N/* UART_0_FPC_RX_FIFO_WR_REG */
N#define UART_0_FPC_RX_FIFO_RD_POS    (0u)  /* [15:0] Data read from RX FIFO */
N#define UART_0_FPC_RX_FIFO_RD_MASK   ((uint32) 0xFFu)
N
N/* UART_0_FPC_RX_FIFO_RD_SILENT_REG */
N#define UART_0_FPC_RX_FIFO_RD_SILENT_POS     (0u)  /* [15:0] Data read from RX FIFO: not remove data from FIFO */
N#define UART_0_FPC_RX_FIFO_RD_SILENT_MASK    ((uint32) 0xFFu)
N
N/* UART_0_FPC_RX_FIFO_RD_SILENT_REG */
N#define UART_0_FPC_RX_FIFO_RD_SILENT_POS     (0u)  /* [15:0] Data read from RX FIFO: not remove data from FIFO */
N#define UART_0_FPC_RX_FIFO_RD_SILENT_MASK    ((uint32) 0xFFu)
N
N/* UART_0_FPC_EZBUF_DATA_REG */
N#define UART_0_FPC_EZBUF_DATA_POS   (0u)  /* [7:0] Data from EZ Memory */
N#define UART_0_FPC_EZBUF_DATA_MASK  ((uint32) 0xFFu)
N
N/*  UART_0_FPC_INTR_CAUSE_REG */
N#define UART_0_FPC_INTR_CAUSE_MASTER_POS  (0u)  /* [0] Master interrupt active                 */
N#define UART_0_FPC_INTR_CAUSE_SLAVE_POS   (1u)  /* [1] Slave interrupt active                  */
N#define UART_0_FPC_INTR_CAUSE_TX_POS      (2u)  /* [2] Transmitter interrupt active            */
N#define UART_0_FPC_INTR_CAUSE_RX_POS      (3u)  /* [3] Receiver interrupt active               */
N#define UART_0_FPC_INTR_CAUSE_I2C_EC_POS  (4u)  /* [4] Externally clock I2C interrupt active   */
N#define UART_0_FPC_INTR_CAUSE_SPI_EC_POS  (5u)  /* [5] Externally clocked SPI interrupt active */
N#define UART_0_FPC_INTR_CAUSE_MASTER      ((uint32) 0x01u)
N#define UART_0_FPC_INTR_CAUSE_SLAVE       ((uint32) 0x01u << UART_0_FPC_INTR_CAUSE_SLAVE_POS)
N#define UART_0_FPC_INTR_CAUSE_TX          ((uint32) 0x01u << UART_0_FPC_INTR_CAUSE_TX_POS)
N#define UART_0_FPC_INTR_CAUSE_RX          ((uint32) 0x01u << UART_0_FPC_INTR_CAUSE_RX_POS)
N#define UART_0_FPC_INTR_CAUSE_I2C_EC      ((uint32) 0x01u << UART_0_FPC_INTR_CAUSE_I2C_EC_POS)
N#define UART_0_FPC_INTR_CAUSE_SPI_EC      ((uint32) 0x01u << UART_0_FPC_INTR_CAUSE_SPI_EC_POS)
N
N/* UART_0_FPC_INTR_SPI_EC_REG, UART_0_FPC_INTR_SPI_EC_MASK_REG, UART_0_FPC_INTR_SPI_EC_MASKED_REG */
N#define UART_0_FPC_INTR_SPI_EC_WAKE_UP_POS          (0u)  /* [0] Address match: triggers wakeup of chip */
N#define UART_0_FPC_INTR_SPI_EC_EZBUF_STOP_POS       (1u)  /* [1] Externally clocked Stop detected       */
N#define UART_0_FPC_INTR_SPI_EC_EZBUF_WRITE_STOP_POS (2u)  /* [2] Externally clocked Write Stop detected */
N#define UART_0_FPC_INTR_SPI_EC_WAKE_UP              ((uint32) 0x01u)
N#define UART_0_FPC_INTR_SPI_EC_EZBUF_STOP           ((uint32) 0x01u << \
N                                                                    UART_0_FPC_INTR_SPI_EC_EZBUF_STOP_POS)
X#define UART_0_FPC_INTR_SPI_EC_EZBUF_STOP           ((uint32) 0x01u <<                                                                     UART_0_FPC_INTR_SPI_EC_EZBUF_STOP_POS)
N#define UART_0_FPC_INTR_SPI_EC_EZBUF_WRITE_STOP     ((uint32) 0x01u << \
N                                                                    UART_0_FPC_INTR_SPI_EC_EZBUF_WRITE_STOP_POS)
X#define UART_0_FPC_INTR_SPI_EC_EZBUF_WRITE_STOP     ((uint32) 0x01u <<                                                                     UART_0_FPC_INTR_SPI_EC_EZBUF_WRITE_STOP_POS)
N
N/* UART_0_FPC_INTR_I2C_EC, UART_0_FPC_INTR_I2C_EC_MASK, UART_0_FPC_INTR_I2C_EC_MASKED */
N#define UART_0_FPC_INTR_I2C_EC_WAKE_UP_POS          (0u)  /* [0] Address match: triggers wakeup of chip */
N#define UART_0_FPC_INTR_I2C_EC_EZBUF_STOP_POS       (1u)  /* [1] Externally clocked Stop detected       */
N#define UART_0_FPC_INTR_I2C_EC_EZBUF_WRITE_STOP_POS (2u)  /* [2] Externally clocked Write Stop detected */
N#define UART_0_FPC_INTR_I2C_EC_WAKE_UP              ((uint32) 0x01u)
N#define UART_0_FPC_INTR_I2C_EC_EZBUF_STOP           ((uint32) 0x01u << \
N                                                                    UART_0_FPC_INTR_I2C_EC_EZBUF_STOP_POS)
X#define UART_0_FPC_INTR_I2C_EC_EZBUF_STOP           ((uint32) 0x01u <<                                                                     UART_0_FPC_INTR_I2C_EC_EZBUF_STOP_POS)
N#define UART_0_FPC_INTR_I2C_EC_EZBUF_WRITE_STOP     ((uint32) 0x01u << \
N                                                                    UART_0_FPC_INTR_I2C_EC_EZBUF_WRITE_STOP_POS)
X#define UART_0_FPC_INTR_I2C_EC_EZBUF_WRITE_STOP     ((uint32) 0x01u <<                                                                     UART_0_FPC_INTR_I2C_EC_EZBUF_WRITE_STOP_POS)
N
N/* UART_0_FPC_INTR_MASTER, UART_0_FPC_INTR_MASTER_SET,
N   UART_0_FPC_INTR_MASTER_MASK, UART_0_FPC_INTR_MASTER_MASKED */
N#define UART_0_FPC_INTR_MASTER_I2C_ARB_LOST_POS   (0u)  /* [0] Master lost arbitration                          */
N#define UART_0_FPC_INTR_MASTER_I2C_NACK_POS       (1u)  /* [1] Master receives NACK: address or write to slave  */
N#define UART_0_FPC_INTR_MASTER_I2C_ACK_POS        (2u)  /* [2] Master receives NACK: address or write to slave  */
N#define UART_0_FPC_INTR_MASTER_I2C_STOP_POS       (4u)  /* [4] Master detects the Stop: only self generated Stop*/
N#define UART_0_FPC_INTR_MASTER_I2C_BUS_ERROR_POS  (8u)  /* [8] Master detects bus error: misplaced Start or Stop*/
N#define UART_0_FPC_INTR_MASTER_SPI_DONE_POS       (9u)  /* [9] Master complete transfer: Only for SPI           */
N#define UART_0_FPC_INTR_MASTER_I2C_ARB_LOST       ((uint32) 0x01u)
N#define UART_0_FPC_INTR_MASTER_I2C_NACK           ((uint32) 0x01u << UART_0_FPC_INTR_MASTER_I2C_NACK_POS)
N#define UART_0_FPC_INTR_MASTER_I2C_ACK            ((uint32) 0x01u << UART_0_FPC_INTR_MASTER_I2C_ACK_POS)
N#define UART_0_FPC_INTR_MASTER_I2C_STOP           ((uint32) 0x01u << UART_0_FPC_INTR_MASTER_I2C_STOP_POS)
N#define UART_0_FPC_INTR_MASTER_I2C_BUS_ERROR      ((uint32) 0x01u << \
N                                                                    UART_0_FPC_INTR_MASTER_I2C_BUS_ERROR_POS)
X#define UART_0_FPC_INTR_MASTER_I2C_BUS_ERROR      ((uint32) 0x01u <<                                                                     UART_0_FPC_INTR_MASTER_I2C_BUS_ERROR_POS)
N#define UART_0_FPC_INTR_MASTER_SPI_DONE           ((uint32) 0x01u << UART_0_FPC_INTR_MASTER_SPI_DONE_POS)
N
N/*
N* UART_0_FPC_INTR_SLAVE, UART_0_FPC_INTR_SLAVE_SET,
N* UART_0_FPC_INTR_SLAVE_MASK, UART_0_FPC_INTR_SLAVE_MASKED
N*/
N#define UART_0_FPC_INTR_SLAVE_I2C_ARB_LOST_POS         (0u)  /* [0]  Slave lost arbitration                   */
N#define UART_0_FPC_INTR_SLAVE_I2C_NACK_POS             (1u)  /* [1]  Slave receives NACK: master reads data   */
N#define UART_0_FPC_INTR_SLAVE_I2C_ACK_POS              (2u)  /* [2]  Slave receives ACK: master reads data    */
N#define UART_0_FPC_INTR_SLAVE_I2C_WRITE_STOP_POS       (3u)  /* [3]  Slave detects end of write transaction   */
N#define UART_0_FPC_INTR_SLAVE_I2C_STOP_POS             (4u)  /* [4]  Slave detects end of transaction intended */
N#define UART_0_FPC_INTR_SLAVE_I2C_START_POS            (5u)  /* [5]  Slave detects Start                      */
N#define UART_0_FPC_INTR_SLAVE_I2C_ADDR_MATCH_POS       (6u)  /* [6]  Slave address matches                    */
N#define UART_0_FPC_INTR_SLAVE_I2C_GENERAL_POS          (7u)  /* [7]  General call received                    */
N#define UART_0_FPC_INTR_SLAVE_I2C_BUS_ERROR_POS        (8u)  /* [8]  Slave detects bus error                  */
N#define UART_0_FPC_INTR_SLAVE_SPI_EZBUF_WRITE_STOP_POS (9u)  /* [9]  Slave write complete: Only for SPI       */
N#define UART_0_FPC_INTR_SLAVE_SPI_EZBUF_STOP_POS       (10u) /* [10] Slave end of transaction: Only for SPI   */
N#define UART_0_FPC_INTR_SLAVE_SPI_BUS_ERROR_POS        (11u) /* [11] Slave detects bus error: Only for SPI    */
N#define UART_0_FPC_INTR_SLAVE_I2C_ARB_LOST             ((uint32) 0x01u)
N#define UART_0_FPC_INTR_SLAVE_I2C_NACK                 ((uint32) 0x01u << \
N                                                                    UART_0_FPC_INTR_SLAVE_I2C_NACK_POS)
X#define UART_0_FPC_INTR_SLAVE_I2C_NACK                 ((uint32) 0x01u <<                                                                     UART_0_FPC_INTR_SLAVE_I2C_NACK_POS)
N#define UART_0_FPC_INTR_SLAVE_I2C_ACK                  ((uint32) 0x01u << \
N                                                                    UART_0_FPC_INTR_SLAVE_I2C_ACK_POS)
X#define UART_0_FPC_INTR_SLAVE_I2C_ACK                  ((uint32) 0x01u <<                                                                     UART_0_FPC_INTR_SLAVE_I2C_ACK_POS)
N#define UART_0_FPC_INTR_SLAVE_I2C_WRITE_STOP           ((uint32) 0x01u << \
N                                                                    UART_0_FPC_INTR_SLAVE_I2C_WRITE_STOP_POS)
X#define UART_0_FPC_INTR_SLAVE_I2C_WRITE_STOP           ((uint32) 0x01u <<                                                                     UART_0_FPC_INTR_SLAVE_I2C_WRITE_STOP_POS)
N#define UART_0_FPC_INTR_SLAVE_I2C_STOP                 ((uint32) 0x01u << \
N                                                                    UART_0_FPC_INTR_SLAVE_I2C_STOP_POS)
X#define UART_0_FPC_INTR_SLAVE_I2C_STOP                 ((uint32) 0x01u <<                                                                     UART_0_FPC_INTR_SLAVE_I2C_STOP_POS)
N#define UART_0_FPC_INTR_SLAVE_I2C_START                ((uint32) 0x01u << \
N                                                                    UART_0_FPC_INTR_SLAVE_I2C_START_POS)
X#define UART_0_FPC_INTR_SLAVE_I2C_START                ((uint32) 0x01u <<                                                                     UART_0_FPC_INTR_SLAVE_I2C_START_POS)
N#define UART_0_FPC_INTR_SLAVE_I2C_ADDR_MATCH           ((uint32) 0x01u << \
N                                                                    UART_0_FPC_INTR_SLAVE_I2C_ADDR_MATCH_POS)
X#define UART_0_FPC_INTR_SLAVE_I2C_ADDR_MATCH           ((uint32) 0x01u <<                                                                     UART_0_FPC_INTR_SLAVE_I2C_ADDR_MATCH_POS)
N#define UART_0_FPC_INTR_SLAVE_I2C_GENERAL              ((uint32) 0x01u << \
N                                                                    UART_0_FPC_INTR_SLAVE_I2C_GENERAL_POS)
X#define UART_0_FPC_INTR_SLAVE_I2C_GENERAL              ((uint32) 0x01u <<                                                                     UART_0_FPC_INTR_SLAVE_I2C_GENERAL_POS)
N#define UART_0_FPC_INTR_SLAVE_I2C_BUS_ERROR            ((uint32) 0x01u << \
N                                                                    UART_0_FPC_INTR_SLAVE_I2C_BUS_ERROR_POS)
X#define UART_0_FPC_INTR_SLAVE_I2C_BUS_ERROR            ((uint32) 0x01u <<                                                                     UART_0_FPC_INTR_SLAVE_I2C_BUS_ERROR_POS)
N#define UART_0_FPC_INTR_SLAVE_SPI_EZBUF_WRITE_STOP     ((uint32) 0x01u << \
N                                                                   UART_0_FPC_INTR_SLAVE_SPI_EZBUF_WRITE_STOP_POS)
X#define UART_0_FPC_INTR_SLAVE_SPI_EZBUF_WRITE_STOP     ((uint32) 0x01u <<                                                                    UART_0_FPC_INTR_SLAVE_SPI_EZBUF_WRITE_STOP_POS)
N#define UART_0_FPC_INTR_SLAVE_SPI_EZBUF_STOP           ((uint32) 0x01u << \
N                                                                    UART_0_FPC_INTR_SLAVE_SPI_EZBUF_STOP_POS)
X#define UART_0_FPC_INTR_SLAVE_SPI_EZBUF_STOP           ((uint32) 0x01u <<                                                                     UART_0_FPC_INTR_SLAVE_SPI_EZBUF_STOP_POS)
N#define UART_0_FPC_INTR_SLAVE_SPI_BUS_ERROR           ((uint32) 0x01u << \
N                                                                    UART_0_FPC_INTR_SLAVE_SPI_BUS_ERROR_POS)
X#define UART_0_FPC_INTR_SLAVE_SPI_BUS_ERROR           ((uint32) 0x01u <<                                                                     UART_0_FPC_INTR_SLAVE_SPI_BUS_ERROR_POS)
N
N/*
N* UART_0_FPC_INTR_TX, UART_0_FPC_INTR_TX_SET,
N* UART_0_FPC_INTR_TX_MASK, UART_0_FPC_INTR_TX_MASKED
N*/
N#define UART_0_FPC_INTR_TX_TRIGGER_POS        (0u)  /* [0]  Trigger on TX FIFO entires                       */
N#define UART_0_FPC_INTR_TX_NOT_FULL_POS       (1u)  /* [1]  TX FIFO is not full                              */
N#define UART_0_FPC_INTR_TX_EMPTY_POS          (4u)  /* [4]  TX FIFO is empty                                 */
N#define UART_0_FPC_INTR_TX_OVERFLOW_POS       (5u)  /* [5]  Attempt to write to a full TX FIFO               */
N#define UART_0_FPC_INTR_TX_UNDERFLOW_POS      (6u)  /* [6]  Attempt to read from an empty TX FIFO            */
N#define UART_0_FPC_INTR_TX_BLOCKED_POS        (7u)  /* [7]  No access to the EZ memory                       */
N#define UART_0_FPC_INTR_TX_UART_NACK_POS      (8u)  /* [8]  UART transmitter received a NACK: SmartCard mode */
N#define UART_0_FPC_INTR_TX_UART_DONE_POS      (9u)  /* [9]  UART transmitter done even                       */
N#define UART_0_FPC_INTR_TX_UART_ARB_LOST_POS  (10u) /* [10] UART lost arbitration: LIN or SmartCard          */
N#define UART_0_FPC_INTR_TX_TRIGGER            ((uint32) 0x01u)
N#define UART_0_FPC_INTR_TX_FIFO_LEVEL         (UART_0_FPC_INTR_TX_TRIGGER)
N#define UART_0_FPC_INTR_TX_NOT_FULL           ((uint32) 0x01u << UART_0_FPC_INTR_TX_NOT_FULL_POS)
N#define UART_0_FPC_INTR_TX_EMPTY              ((uint32) 0x01u << UART_0_FPC_INTR_TX_EMPTY_POS)
N#define UART_0_FPC_INTR_TX_OVERFLOW           ((uint32) 0x01u << UART_0_FPC_INTR_TX_OVERFLOW_POS)
N#define UART_0_FPC_INTR_TX_UNDERFLOW          ((uint32) 0x01u << UART_0_FPC_INTR_TX_UNDERFLOW_POS)
N#define UART_0_FPC_INTR_TX_BLOCKED            ((uint32) 0x01u << UART_0_FPC_INTR_TX_BLOCKED_POS)
N#define UART_0_FPC_INTR_TX_UART_NACK          ((uint32) 0x01u << UART_0_FPC_INTR_TX_UART_NACK_POS)
N#define UART_0_FPC_INTR_TX_UART_DONE          ((uint32) 0x01u << UART_0_FPC_INTR_TX_UART_DONE_POS)
N#define UART_0_FPC_INTR_TX_UART_ARB_LOST      ((uint32) 0x01u << UART_0_FPC_INTR_TX_UART_ARB_LOST_POS)
N
N/*
N* UART_0_FPC_INTR_RX, UART_0_FPC_INTR_RX_SET,
N* UART_0_FPC_INTR_RX_MASK, UART_0_FPC_INTR_RX_MASKED
N*/
N#define UART_0_FPC_INTR_RX_TRIGGER_POS        (0u)   /* [0]  Trigger on RX FIFO entires            */
N#define UART_0_FPC_INTR_RX_NOT_EMPTY_POS      (2u)   /* [2]  RX FIFO is not empty                  */
N#define UART_0_FPC_INTR_RX_FULL_POS           (3u)   /* [3]  RX FIFO is full                       */
N#define UART_0_FPC_INTR_RX_OVERFLOW_POS       (5u)   /* [5]  Attempt to write to a full RX FIFO    */
N#define UART_0_FPC_INTR_RX_UNDERFLOW_POS      (6u)   /* [6]  Attempt to read from an empty RX FIFO */
N#define UART_0_FPC_INTR_RX_BLOCKED_POS        (7u)   /* [7]  No access to the EZ memory            */
N#define UART_0_FPC_INTR_RX_FRAME_ERROR_POS    (8u)   /* [8]  Frame error in received data frame    */
N#define UART_0_FPC_INTR_RX_PARITY_ERROR_POS   (9u)   /* [9]  Parity error in received data frame   */
N#define UART_0_FPC_INTR_RX_BAUD_DETECT_POS    (10u)  /* [10] LIN baud rate detection is completed   */
N#define UART_0_FPC_INTR_RX_BREAK_DETECT_POS   (11u)  /* [11] Break detection is successful         */
N#define UART_0_FPC_INTR_RX_TRIGGER            ((uint32) 0x01u)
N#define UART_0_FPC_INTR_RX_FIFO_LEVEL         (UART_0_FPC_INTR_RX_TRIGGER)
N#define UART_0_FPC_INTR_RX_NOT_EMPTY          ((uint32) 0x01u << UART_0_FPC_INTR_RX_NOT_EMPTY_POS)
N#define UART_0_FPC_INTR_RX_FULL               ((uint32) 0x01u << UART_0_FPC_INTR_RX_FULL_POS)
N#define UART_0_FPC_INTR_RX_OVERFLOW           ((uint32) 0x01u << UART_0_FPC_INTR_RX_OVERFLOW_POS)
N#define UART_0_FPC_INTR_RX_UNDERFLOW          ((uint32) 0x01u << UART_0_FPC_INTR_RX_UNDERFLOW_POS)
N#define UART_0_FPC_INTR_RX_BLOCKED            ((uint32) 0x01u << UART_0_FPC_INTR_RX_BLOCKED_POS)
N#define UART_0_FPC_INTR_RX_FRAME_ERROR        ((uint32) 0x01u << UART_0_FPC_INTR_RX_FRAME_ERROR_POS)
N#define UART_0_FPC_INTR_RX_PARITY_ERROR       ((uint32) 0x01u << UART_0_FPC_INTR_RX_PARITY_ERROR_POS)
N#define UART_0_FPC_INTR_RX_BAUD_DETECT        ((uint32) 0x01u << UART_0_FPC_INTR_RX_BAUD_DETECT_POS)
N#define UART_0_FPC_INTR_RX_BREAK_DETECT       ((uint32) 0x01u << UART_0_FPC_INTR_RX_BREAK_DETECT_POS)
N
N/* Define all interrupt sources */
N#define UART_0_FPC_INTR_I2C_EC_ALL    (UART_0_FPC_INTR_I2C_EC_WAKE_UP    | \
N                                             UART_0_FPC_INTR_I2C_EC_EZBUF_STOP | \
N                                             UART_0_FPC_INTR_I2C_EC_EZBUF_WRITE_STOP)
X#define UART_0_FPC_INTR_I2C_EC_ALL    (UART_0_FPC_INTR_I2C_EC_WAKE_UP    |                                              UART_0_FPC_INTR_I2C_EC_EZBUF_STOP |                                              UART_0_FPC_INTR_I2C_EC_EZBUF_WRITE_STOP)
N
N#define UART_0_FPC_INTR_SPI_EC_ALL    (UART_0_FPC_INTR_SPI_EC_WAKE_UP    | \
N                                             UART_0_FPC_INTR_SPI_EC_EZBUF_STOP | \
N                                             UART_0_FPC_INTR_SPI_EC_EZBUF_WRITE_STOP)
X#define UART_0_FPC_INTR_SPI_EC_ALL    (UART_0_FPC_INTR_SPI_EC_WAKE_UP    |                                              UART_0_FPC_INTR_SPI_EC_EZBUF_STOP |                                              UART_0_FPC_INTR_SPI_EC_EZBUF_WRITE_STOP)
N
N#define UART_0_FPC_INTR_MASTER_ALL    (UART_0_FPC_INTR_MASTER_I2C_ARB_LOST  | \
N                                             UART_0_FPC_INTR_MASTER_I2C_NACK      | \
N                                             UART_0_FPC_INTR_MASTER_I2C_ACK       | \
N                                             UART_0_FPC_INTR_MASTER_I2C_STOP      | \
N                                             UART_0_FPC_INTR_MASTER_I2C_BUS_ERROR | \
N                                             UART_0_FPC_INTR_MASTER_SPI_DONE)
X#define UART_0_FPC_INTR_MASTER_ALL    (UART_0_FPC_INTR_MASTER_I2C_ARB_LOST  |                                              UART_0_FPC_INTR_MASTER_I2C_NACK      |                                              UART_0_FPC_INTR_MASTER_I2C_ACK       |                                              UART_0_FPC_INTR_MASTER_I2C_STOP      |                                              UART_0_FPC_INTR_MASTER_I2C_BUS_ERROR |                                              UART_0_FPC_INTR_MASTER_SPI_DONE)
N
N#define UART_0_FPC_INTR_SLAVE_ALL     (UART_0_FPC_INTR_SLAVE_I2C_ARB_LOST      | \
N                                             UART_0_FPC_INTR_SLAVE_I2C_NACK          | \
N                                             UART_0_FPC_INTR_SLAVE_I2C_ACK           | \
N                                             UART_0_FPC_INTR_SLAVE_I2C_WRITE_STOP    | \
N                                             UART_0_FPC_INTR_SLAVE_I2C_STOP          | \
N                                             UART_0_FPC_INTR_SLAVE_I2C_START         | \
N                                             UART_0_FPC_INTR_SLAVE_I2C_ADDR_MATCH    | \
N                                             UART_0_FPC_INTR_SLAVE_I2C_GENERAL       | \
N                                             UART_0_FPC_INTR_SLAVE_I2C_BUS_ERROR     | \
N                                             UART_0_FPC_INTR_SLAVE_SPI_EZBUF_WRITE_STOP | \
N                                             UART_0_FPC_INTR_SLAVE_SPI_EZBUF_STOP       | \
N                                             UART_0_FPC_INTR_SLAVE_SPI_BUS_ERROR)
X#define UART_0_FPC_INTR_SLAVE_ALL     (UART_0_FPC_INTR_SLAVE_I2C_ARB_LOST      |                                              UART_0_FPC_INTR_SLAVE_I2C_NACK          |                                              UART_0_FPC_INTR_SLAVE_I2C_ACK           |                                              UART_0_FPC_INTR_SLAVE_I2C_WRITE_STOP    |                                              UART_0_FPC_INTR_SLAVE_I2C_STOP          |                                              UART_0_FPC_INTR_SLAVE_I2C_START         |                                              UART_0_FPC_INTR_SLAVE_I2C_ADDR_MATCH    |                                              UART_0_FPC_INTR_SLAVE_I2C_GENERAL       |                                              UART_0_FPC_INTR_SLAVE_I2C_BUS_ERROR     |                                              UART_0_FPC_INTR_SLAVE_SPI_EZBUF_WRITE_STOP |                                              UART_0_FPC_INTR_SLAVE_SPI_EZBUF_STOP       |                                              UART_0_FPC_INTR_SLAVE_SPI_BUS_ERROR)
N
N#define UART_0_FPC_INTR_TX_ALL        (UART_0_FPC_INTR_TX_TRIGGER   | \
N                                             UART_0_FPC_INTR_TX_NOT_FULL  | \
N                                             UART_0_FPC_INTR_TX_EMPTY     | \
N                                             UART_0_FPC_INTR_TX_OVERFLOW  | \
N                                             UART_0_FPC_INTR_TX_UNDERFLOW | \
N                                             UART_0_FPC_INTR_TX_BLOCKED   | \
N                                             UART_0_FPC_INTR_TX_UART_NACK | \
N                                             UART_0_FPC_INTR_TX_UART_DONE | \
N                                             UART_0_FPC_INTR_TX_UART_ARB_LOST)
X#define UART_0_FPC_INTR_TX_ALL        (UART_0_FPC_INTR_TX_TRIGGER   |                                              UART_0_FPC_INTR_TX_NOT_FULL  |                                              UART_0_FPC_INTR_TX_EMPTY     |                                              UART_0_FPC_INTR_TX_OVERFLOW  |                                              UART_0_FPC_INTR_TX_UNDERFLOW |                                              UART_0_FPC_INTR_TX_BLOCKED   |                                              UART_0_FPC_INTR_TX_UART_NACK |                                              UART_0_FPC_INTR_TX_UART_DONE |                                              UART_0_FPC_INTR_TX_UART_ARB_LOST)
N
N#define UART_0_FPC_INTR_RX_ALL        (UART_0_FPC_INTR_RX_TRIGGER      | \
N                                             UART_0_FPC_INTR_RX_NOT_EMPTY    | \
N                                             UART_0_FPC_INTR_RX_FULL         | \
N                                             UART_0_FPC_INTR_RX_OVERFLOW     | \
N                                             UART_0_FPC_INTR_RX_UNDERFLOW    | \
N                                             UART_0_FPC_INTR_RX_BLOCKED      | \
N                                             UART_0_FPC_INTR_RX_FRAME_ERROR  | \
N                                             UART_0_FPC_INTR_RX_PARITY_ERROR | \
N                                             UART_0_FPC_INTR_RX_BAUD_DETECT  | \
N                                             UART_0_FPC_INTR_RX_BREAK_DETECT)
X#define UART_0_FPC_INTR_RX_ALL        (UART_0_FPC_INTR_RX_TRIGGER      |                                              UART_0_FPC_INTR_RX_NOT_EMPTY    |                                              UART_0_FPC_INTR_RX_FULL         |                                              UART_0_FPC_INTR_RX_OVERFLOW     |                                              UART_0_FPC_INTR_RX_UNDERFLOW    |                                              UART_0_FPC_INTR_RX_BLOCKED      |                                              UART_0_FPC_INTR_RX_FRAME_ERROR  |                                              UART_0_FPC_INTR_RX_PARITY_ERROR |                                              UART_0_FPC_INTR_RX_BAUD_DETECT  |                                              UART_0_FPC_INTR_RX_BREAK_DETECT)
N
N/* I2C and EZI2C slave address defines */
N#define UART_0_FPC_I2C_SLAVE_ADDR_POS    (0x01u)    /* 7-bit address shift */
N#define UART_0_FPC_I2C_SLAVE_ADDR_MASK   (0xFEu)    /* 8-bit address mask */
N
N/* OVS constants for IrDA Low Power operation */
N#define UART_0_FPC_CTRL_OVS_IRDA_LP_OVS16     (0x00u)
N#define UART_0_FPC_CTRL_OVS_IRDA_LP_OVS32     (0x01u)
N#define UART_0_FPC_CTRL_OVS_IRDA_LP_OVS48     (0x02u)
N#define UART_0_FPC_CTRL_OVS_IRDA_LP_OVS96     (0x03u)
N#define UART_0_FPC_CTRL_OVS_IRDA_LP_OVS192    (0x04u)
N#define UART_0_FPC_CTRL_OVS_IRDA_LP_OVS768    (0x05u)
N#define UART_0_FPC_CTRL_OVS_IRDA_LP_OVS1536   (0x06u)
N
N/* OVS constant for IrDA */
N#define UART_0_FPC_CTRL_OVS_IRDA_OVS16        (UART_0_FPC_UART_IRDA_LP_OVS16)
N
N
N/***************************************
N*    Common Macro Definitions
N***************************************/
N
N/* Re-enables the SCB IP. A clear enable bit has a different effect
N* on the scb IP depending on the version:
N*  CY_SCBIP_V0: resets state, status, TX and RX FIFOs.
N*  CY_SCBIP_V1 or later: resets state, status, TX and RX FIFOs and interrupt sources.
N* Clear I2C command registers are because they are not impacted by re-enable.
N*/
N#define UART_0_FPC_SCB_SW_RESET   UART_0_FPC_I2CFwBlockReset()
N
N/* TX FIFO macro */
N#define UART_0_FPC_CLEAR_TX_FIFO \
N                            do{        \
N                                UART_0_FPC_TX_FIFO_CTRL_REG |= ((uint32)  UART_0_FPC_TX_FIFO_CTRL_CLEAR); \
N                                UART_0_FPC_TX_FIFO_CTRL_REG &= ((uint32) ~UART_0_FPC_TX_FIFO_CTRL_CLEAR); \
N                            }while(0)
X#define UART_0_FPC_CLEAR_TX_FIFO                             do{                                        UART_0_FPC_TX_FIFO_CTRL_REG |= ((uint32)  UART_0_FPC_TX_FIFO_CTRL_CLEAR);                                 UART_0_FPC_TX_FIFO_CTRL_REG &= ((uint32) ~UART_0_FPC_TX_FIFO_CTRL_CLEAR);                             }while(0)
N
N#define UART_0_FPC_GET_TX_FIFO_ENTRIES    (UART_0_FPC_TX_FIFO_STATUS_REG & \
N                                                 UART_0_FPC_TX_FIFO_STATUS_USED_MASK)
X#define UART_0_FPC_GET_TX_FIFO_ENTRIES    (UART_0_FPC_TX_FIFO_STATUS_REG &                                                  UART_0_FPC_TX_FIFO_STATUS_USED_MASK)
N
N#define UART_0_FPC_GET_TX_FIFO_SR_VALID   ((0u != (UART_0_FPC_TX_FIFO_STATUS_REG & \
N                                                         UART_0_FPC_TX_FIFO_SR_VALID)) ? (1u) : (0u))
X#define UART_0_FPC_GET_TX_FIFO_SR_VALID   ((0u != (UART_0_FPC_TX_FIFO_STATUS_REG &                                                          UART_0_FPC_TX_FIFO_SR_VALID)) ? (1u) : (0u))
N
N/* RX FIFO macro */
N#define UART_0_FPC_CLEAR_RX_FIFO \
N                            do{        \
N                                UART_0_FPC_RX_FIFO_CTRL_REG |= ((uint32)  UART_0_FPC_RX_FIFO_CTRL_CLEAR); \
N                                UART_0_FPC_RX_FIFO_CTRL_REG &= ((uint32) ~UART_0_FPC_RX_FIFO_CTRL_CLEAR); \
N                            }while(0)
X#define UART_0_FPC_CLEAR_RX_FIFO                             do{                                        UART_0_FPC_RX_FIFO_CTRL_REG |= ((uint32)  UART_0_FPC_RX_FIFO_CTRL_CLEAR);                                 UART_0_FPC_RX_FIFO_CTRL_REG &= ((uint32) ~UART_0_FPC_RX_FIFO_CTRL_CLEAR);                             }while(0)
N
N#define UART_0_FPC_GET_RX_FIFO_ENTRIES    (UART_0_FPC_RX_FIFO_STATUS_REG & \
N                                                    UART_0_FPC_RX_FIFO_STATUS_USED_MASK)
X#define UART_0_FPC_GET_RX_FIFO_ENTRIES    (UART_0_FPC_RX_FIFO_STATUS_REG &                                                     UART_0_FPC_RX_FIFO_STATUS_USED_MASK)
N
N#define UART_0_FPC_GET_RX_FIFO_SR_VALID   ((0u != (UART_0_FPC_RX_FIFO_STATUS_REG & \
N                                                         UART_0_FPC_RX_FIFO_SR_VALID)) ? (1u) : (0u))
X#define UART_0_FPC_GET_RX_FIFO_SR_VALID   ((0u != (UART_0_FPC_RX_FIFO_STATUS_REG &                                                          UART_0_FPC_RX_FIFO_SR_VALID)) ? (1u) : (0u))
N
N/* Write interrupt source: set sourceMask bits in UART_0_FPC_INTR_X_MASK_REG */
N#define UART_0_FPC_WRITE_INTR_I2C_EC_MASK(sourceMask) \
N                                                do{         \
N                                                    UART_0_FPC_INTR_I2C_EC_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_0_FPC_WRITE_INTR_I2C_EC_MASK(sourceMask)                                                 do{                                                             UART_0_FPC_INTR_I2C_EC_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#if (!UART_0_FPC_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_0_FPC_WRITE_INTR_SPI_EC_MASK(sourceMask) \
N                                                do{         \
N                                                    UART_0_FPC_INTR_SPI_EC_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X    #define UART_0_FPC_WRITE_INTR_SPI_EC_MASK(sourceMask)                                                 do{                                                             UART_0_FPC_INTR_SPI_EC_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N#endif /* (!UART_0_FPC_CY_SCBIP_V1) */
N
N#define UART_0_FPC_WRITE_INTR_MASTER_MASK(sourceMask) \
N                                                do{         \
N                                                    UART_0_FPC_INTR_MASTER_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_0_FPC_WRITE_INTR_MASTER_MASK(sourceMask)                                                 do{                                                             UART_0_FPC_INTR_MASTER_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_0_FPC_WRITE_INTR_SLAVE_MASK(sourceMask)  \
N                                                do{         \
N                                                    UART_0_FPC_INTR_SLAVE_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_0_FPC_WRITE_INTR_SLAVE_MASK(sourceMask)                                                  do{                                                             UART_0_FPC_INTR_SLAVE_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_0_FPC_WRITE_INTR_TX_MASK(sourceMask)     \
N                                                do{         \
N                                                    UART_0_FPC_INTR_TX_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_0_FPC_WRITE_INTR_TX_MASK(sourceMask)                                                     do{                                                             UART_0_FPC_INTR_TX_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_0_FPC_WRITE_INTR_RX_MASK(sourceMask)     \
N                                                do{         \
N                                                    UART_0_FPC_INTR_RX_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_0_FPC_WRITE_INTR_RX_MASK(sourceMask)                                                     do{                                                             UART_0_FPC_INTR_RX_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N/* Enable interrupt source: set sourceMask bits in UART_0_FPC_INTR_X_MASK_REG */
N#define UART_0_FPC_ENABLE_INTR_I2C_EC(sourceMask) \
N                                                do{     \
N                                                    UART_0_FPC_INTR_I2C_EC_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_0_FPC_ENABLE_INTR_I2C_EC(sourceMask)                                                 do{                                                         UART_0_FPC_INTR_I2C_EC_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N#if (!UART_0_FPC_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_0_FPC_ENABLE_INTR_SPI_EC(sourceMask) \
N                                                do{     \
N                                                    UART_0_FPC_INTR_SPI_EC_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X    #define UART_0_FPC_ENABLE_INTR_SPI_EC(sourceMask)                                                 do{                                                         UART_0_FPC_INTR_SPI_EC_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N#endif /* (!UART_0_FPC_CY_SCBIP_V1) */
N
N#define UART_0_FPC_ENABLE_INTR_MASTER(sourceMask) \
N                                                do{     \
N                                                    UART_0_FPC_INTR_MASTER_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_0_FPC_ENABLE_INTR_MASTER(sourceMask)                                                 do{                                                         UART_0_FPC_INTR_MASTER_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_0_FPC_ENABLE_INTR_SLAVE(sourceMask)  \
N                                                do{     \
N                                                    UART_0_FPC_INTR_SLAVE_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_0_FPC_ENABLE_INTR_SLAVE(sourceMask)                                                  do{                                                         UART_0_FPC_INTR_SLAVE_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_0_FPC_ENABLE_INTR_TX(sourceMask)     \
N                                                do{     \
N                                                    UART_0_FPC_INTR_TX_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_0_FPC_ENABLE_INTR_TX(sourceMask)                                                     do{                                                         UART_0_FPC_INTR_TX_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_0_FPC_ENABLE_INTR_RX(sourceMask)     \
N                                                do{     \
N                                                    UART_0_FPC_INTR_RX_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_0_FPC_ENABLE_INTR_RX(sourceMask)                                                     do{                                                         UART_0_FPC_INTR_RX_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N/* Disable interrupt source: clear sourceMask bits in UART_0_FPC_INTR_X_MASK_REG */
N#define UART_0_FPC_DISABLE_INTR_I2C_EC(sourceMask) \
N                                do{                      \
N                                    UART_0_FPC_INTR_I2C_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define UART_0_FPC_DISABLE_INTR_I2C_EC(sourceMask)                                 do{                                                          UART_0_FPC_INTR_I2C_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N#if (!UART_0_FPC_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_0_FPC_DISABLE_INTR_SPI_EC(sourceMask) \
N                                do{                      \
N                                    UART_0_FPC_INTR_SPI_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                 }while(0)
X    #define UART_0_FPC_DISABLE_INTR_SPI_EC(sourceMask)                                 do{                                                          UART_0_FPC_INTR_SPI_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                  }while(0)
N#endif /* (!UART_0_FPC_CY_SCBIP_V1) */
N
N#define UART_0_FPC_DISABLE_INTR_MASTER(sourceMask) \
N                                do{                      \
N                                UART_0_FPC_INTR_MASTER_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define UART_0_FPC_DISABLE_INTR_MASTER(sourceMask)                                 do{                                                      UART_0_FPC_INTR_MASTER_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N#define UART_0_FPC_DISABLE_INTR_SLAVE(sourceMask) \
N                                do{                     \
N                                    UART_0_FPC_INTR_SLAVE_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define UART_0_FPC_DISABLE_INTR_SLAVE(sourceMask)                                 do{                                                         UART_0_FPC_INTR_SLAVE_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N#define UART_0_FPC_DISABLE_INTR_TX(sourceMask)    \
N                                do{                     \
N                                    UART_0_FPC_INTR_TX_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                 }while(0)
X#define UART_0_FPC_DISABLE_INTR_TX(sourceMask)                                    do{                                                         UART_0_FPC_INTR_TX_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                  }while(0)
N
N#define UART_0_FPC_DISABLE_INTR_RX(sourceMask)    \
N                                do{                     \
N                                    UART_0_FPC_INTR_RX_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define UART_0_FPC_DISABLE_INTR_RX(sourceMask)                                    do{                                                         UART_0_FPC_INTR_RX_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N/* Set interrupt sources: write sourceMask bits in UART_0_FPC_INTR_X_SET_REG */
N#define UART_0_FPC_SET_INTR_MASTER(sourceMask)    \
N                                                do{     \
N                                                    UART_0_FPC_INTR_MASTER_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_0_FPC_SET_INTR_MASTER(sourceMask)                                                    do{                                                         UART_0_FPC_INTR_MASTER_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_0_FPC_SET_INTR_SLAVE(sourceMask) \
N                                                do{ \
N                                                    UART_0_FPC_INTR_SLAVE_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_0_FPC_SET_INTR_SLAVE(sourceMask)                                                 do{                                                     UART_0_FPC_INTR_SLAVE_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_0_FPC_SET_INTR_TX(sourceMask)    \
N                                                do{ \
N                                                    UART_0_FPC_INTR_TX_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_0_FPC_SET_INTR_TX(sourceMask)                                                    do{                                                     UART_0_FPC_INTR_TX_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_0_FPC_SET_INTR_RX(sourceMask)    \
N                                                do{ \
N                                                    UART_0_FPC_INTR_RX_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_0_FPC_SET_INTR_RX(sourceMask)                                                    do{                                                     UART_0_FPC_INTR_RX_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N/* Clear interrupt sources: write sourceMask bits in UART_0_FPC_INTR_X_REG */
N#define UART_0_FPC_CLEAR_INTR_I2C_EC(sourceMask)  \
N                                                do{     \
N                                                    UART_0_FPC_INTR_I2C_EC_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_0_FPC_CLEAR_INTR_I2C_EC(sourceMask)                                                  do{                                                         UART_0_FPC_INTR_I2C_EC_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#if (!UART_0_FPC_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_0_FPC_CLEAR_INTR_SPI_EC(sourceMask)  \
N                                                do{     \
N                                                    UART_0_FPC_INTR_SPI_EC_REG = (uint32) (sourceMask); \
N                                                }while(0)
X    #define UART_0_FPC_CLEAR_INTR_SPI_EC(sourceMask)                                                  do{                                                         UART_0_FPC_INTR_SPI_EC_REG = (uint32) (sourceMask);                                                 }while(0)
N#endif /* (!UART_0_FPC_CY_SCBIP_V1) */
N
N#define UART_0_FPC_CLEAR_INTR_MASTER(sourceMask)  \
N                                                do{     \
N                                                    UART_0_FPC_INTR_MASTER_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_0_FPC_CLEAR_INTR_MASTER(sourceMask)                                                  do{                                                         UART_0_FPC_INTR_MASTER_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_0_FPC_CLEAR_INTR_SLAVE(sourceMask)   \
N                                                do{     \
N                                                    UART_0_FPC_INTR_SLAVE_REG  = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_0_FPC_CLEAR_INTR_SLAVE(sourceMask)                                                   do{                                                         UART_0_FPC_INTR_SLAVE_REG  = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_0_FPC_CLEAR_INTR_TX(sourceMask)      \
N                                                do{     \
N                                                    UART_0_FPC_INTR_TX_REG     = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_0_FPC_CLEAR_INTR_TX(sourceMask)                                                      do{                                                         UART_0_FPC_INTR_TX_REG     = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_0_FPC_CLEAR_INTR_RX(sourceMask)      \
N                                                do{     \
N                                                    UART_0_FPC_INTR_RX_REG     = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_0_FPC_CLEAR_INTR_RX(sourceMask)                                                      do{                                                         UART_0_FPC_INTR_RX_REG     = (uint32) (sourceMask);                                                 }while(0)
N
N/* Return true if sourceMask is set in UART_0_FPC_INTR_CAUSE_REG */
N#define UART_0_FPC_CHECK_CAUSE_INTR(sourceMask)    (0u != (UART_0_FPC_INTR_CAUSE_REG & (sourceMask)))
N
N/* Return true if sourceMask is set in INTR_X_MASKED_REG */
N#define UART_0_FPC_CHECK_INTR_I2C_EC(sourceMask)  (0u != (UART_0_FPC_INTR_I2C_EC_REG & (sourceMask)))
N#if (!UART_0_FPC_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_0_FPC_CHECK_INTR_SPI_EC(sourceMask)  (0u != (UART_0_FPC_INTR_SPI_EC_REG & (sourceMask)))
N#endif /* (!UART_0_FPC_CY_SCBIP_V1) */
N#define UART_0_FPC_CHECK_INTR_MASTER(sourceMask)  (0u != (UART_0_FPC_INTR_MASTER_REG & (sourceMask)))
N#define UART_0_FPC_CHECK_INTR_SLAVE(sourceMask)   (0u != (UART_0_FPC_INTR_SLAVE_REG  & (sourceMask)))
N#define UART_0_FPC_CHECK_INTR_TX(sourceMask)      (0u != (UART_0_FPC_INTR_TX_REG     & (sourceMask)))
N#define UART_0_FPC_CHECK_INTR_RX(sourceMask)      (0u != (UART_0_FPC_INTR_RX_REG     & (sourceMask)))
N
N/* Return true if sourceMask is set in UART_0_FPC_INTR_X_MASKED_REG */
N#define UART_0_FPC_CHECK_INTR_I2C_EC_MASKED(sourceMask)   (0u != (UART_0_FPC_INTR_I2C_EC_MASKED_REG & \
N                                                                       (sourceMask)))
X#define UART_0_FPC_CHECK_INTR_I2C_EC_MASKED(sourceMask)   (0u != (UART_0_FPC_INTR_I2C_EC_MASKED_REG &                                                                        (sourceMask)))
N#if (!UART_0_FPC_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_0_FPC_CHECK_INTR_SPI_EC_MASKED(sourceMask)   (0u != (UART_0_FPC_INTR_SPI_EC_MASKED_REG & \
N                                                                       (sourceMask)))
X    #define UART_0_FPC_CHECK_INTR_SPI_EC_MASKED(sourceMask)   (0u != (UART_0_FPC_INTR_SPI_EC_MASKED_REG &                                                                        (sourceMask)))
N#endif /* (!UART_0_FPC_CY_SCBIP_V1) */
N#define UART_0_FPC_CHECK_INTR_MASTER_MASKED(sourceMask)   (0u != (UART_0_FPC_INTR_MASTER_MASKED_REG & \
N                                                                       (sourceMask)))
X#define UART_0_FPC_CHECK_INTR_MASTER_MASKED(sourceMask)   (0u != (UART_0_FPC_INTR_MASTER_MASKED_REG &                                                                        (sourceMask)))
N#define UART_0_FPC_CHECK_INTR_SLAVE_MASKED(sourceMask)    (0u != (UART_0_FPC_INTR_SLAVE_MASKED_REG  & \
N                                                                       (sourceMask)))
X#define UART_0_FPC_CHECK_INTR_SLAVE_MASKED(sourceMask)    (0u != (UART_0_FPC_INTR_SLAVE_MASKED_REG  &                                                                        (sourceMask)))
N#define UART_0_FPC_CHECK_INTR_TX_MASKED(sourceMask)       (0u != (UART_0_FPC_INTR_TX_MASKED_REG     & \
N                                                                       (sourceMask)))
X#define UART_0_FPC_CHECK_INTR_TX_MASKED(sourceMask)       (0u != (UART_0_FPC_INTR_TX_MASKED_REG     &                                                                        (sourceMask)))
N#define UART_0_FPC_CHECK_INTR_RX_MASKED(sourceMask)       (0u != (UART_0_FPC_INTR_RX_MASKED_REG     & \
N                                                                       (sourceMask)))
X#define UART_0_FPC_CHECK_INTR_RX_MASKED(sourceMask)       (0u != (UART_0_FPC_INTR_RX_MASKED_REG     &                                                                        (sourceMask)))
N
N/* Return true if sourceMask is set in UART_0_FPC_CTRL_REG: generally is used to check enable bit */
N#define UART_0_FPC_GET_CTRL_ENABLED    (0u != (UART_0_FPC_CTRL_REG & UART_0_FPC_CTRL_ENABLED))
N
N#define UART_0_FPC_CHECK_SLAVE_AUTO_ADDR_NACK     (0u != (UART_0_FPC_I2C_CTRL_REG & \
N                                                                UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK))
X#define UART_0_FPC_CHECK_SLAVE_AUTO_ADDR_NACK     (0u != (UART_0_FPC_I2C_CTRL_REG &                                                                 UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK))
N
N
N/***************************************
N*      I2C Macro Definitions
N***************************************/
N
N/* Enable auto ACK/NACK */
N#define UART_0_FPC_ENABLE_SLAVE_AUTO_ADDR_NACK \
N                            do{                      \
N                                UART_0_FPC_I2C_CTRL_REG |= UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_0_FPC_ENABLE_SLAVE_AUTO_ADDR_NACK                             do{                                                      UART_0_FPC_I2C_CTRL_REG |= UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define UART_0_FPC_ENABLE_SLAVE_AUTO_DATA_ACK \
N                            do{                     \
N                                UART_0_FPC_I2C_CTRL_REG |= UART_0_FPC_I2C_CTRL_S_READY_DATA_ACK; \
N                            }while(0)
X#define UART_0_FPC_ENABLE_SLAVE_AUTO_DATA_ACK                             do{                                                     UART_0_FPC_I2C_CTRL_REG |= UART_0_FPC_I2C_CTRL_S_READY_DATA_ACK;                             }while(0)
N
N#define UART_0_FPC_ENABLE_SLAVE_AUTO_DATA_NACK \
N                            do{                      \
N                                UART_0_FPC_I2C_CTRL_REG |= UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_0_FPC_ENABLE_SLAVE_AUTO_DATA_NACK                             do{                                                      UART_0_FPC_I2C_CTRL_REG |= UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define UART_0_FPC_ENABLE_MASTER_AUTO_DATA_ACK \
N                            do{                      \
N                                UART_0_FPC_I2C_CTRL_REG |= UART_0_FPC_I2C_CTRL_M_READY_DATA_ACK; \
N                            }while(0)
X#define UART_0_FPC_ENABLE_MASTER_AUTO_DATA_ACK                             do{                                                      UART_0_FPC_I2C_CTRL_REG |= UART_0_FPC_I2C_CTRL_M_READY_DATA_ACK;                             }while(0)
N
N#define UART_0_FPC_ENABLE_MASTER_AUTO_DATA_NACK \
N                            do{                       \
N                                UART_0_FPC_I2C_CTRL_REG |= UART_0_FPC_I2C_CTRL_M_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_0_FPC_ENABLE_MASTER_AUTO_DATA_NACK                             do{                                                       UART_0_FPC_I2C_CTRL_REG |= UART_0_FPC_I2C_CTRL_M_NOT_READY_DATA_NACK;                             }while(0)
N
N/* Disable auto ACK/NACK */
N#define UART_0_FPC_DISABLE_SLAVE_AUTO_ADDR_NACK \
N                            do{                       \
N                                UART_0_FPC_I2C_CTRL_REG &= ~UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_0_FPC_DISABLE_SLAVE_AUTO_ADDR_NACK                             do{                                                       UART_0_FPC_I2C_CTRL_REG &= ~UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define UART_0_FPC_DISABLE_SLAVE_AUTO_DATA_ACK \
N                            do{                      \
N                                UART_0_FPC_I2C_CTRL_REG &= ~UART_0_FPC_I2C_CTRL_S_READY_DATA_ACK; \
N                            }while(0)
X#define UART_0_FPC_DISABLE_SLAVE_AUTO_DATA_ACK                             do{                                                      UART_0_FPC_I2C_CTRL_REG &= ~UART_0_FPC_I2C_CTRL_S_READY_DATA_ACK;                             }while(0)
N
N#define UART_0_FPC_DISABLE_SLAVE_AUTO_DATA_NACK \
N                            do{                       \
N                                UART_0_FPC_I2C_CTRL_REG &= ~UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_0_FPC_DISABLE_SLAVE_AUTO_DATA_NACK                             do{                                                       UART_0_FPC_I2C_CTRL_REG &= ~UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define UART_0_FPC_DISABLE_MASTER_AUTO_DATA_ACK \
N                            do{                       \
N                                UART_0_FPC_I2C_CTRL_REG &= ~UART_0_FPC_I2C_CTRL_M_READY_DATA_ACK; \
N                            }while(0)
X#define UART_0_FPC_DISABLE_MASTER_AUTO_DATA_ACK                             do{                                                       UART_0_FPC_I2C_CTRL_REG &= ~UART_0_FPC_I2C_CTRL_M_READY_DATA_ACK;                             }while(0)
N
N#define UART_0_FPC_DISABLE_MASTER_AUTO_DATA_NACK \
N                            do{                        \
N                                UART_0_FPC_I2C_CTRL_REG &= ~UART_0_FPC_I2C_CTRL_M_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_0_FPC_DISABLE_MASTER_AUTO_DATA_NACK                             do{                                                        UART_0_FPC_I2C_CTRL_REG &= ~UART_0_FPC_I2C_CTRL_M_NOT_READY_DATA_NACK;                             }while(0)
N
N/* Enable Slave autoACK/NACK Data */
N#define UART_0_FPC_ENABLE_SLAVE_AUTO_DATA \
N                            do{                 \
N                                UART_0_FPC_I2C_CTRL_REG |= (UART_0_FPC_I2C_CTRL_S_READY_DATA_ACK |      \
N                                                                  UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK); \
N                            }while(0)
X#define UART_0_FPC_ENABLE_SLAVE_AUTO_DATA                             do{                                                 UART_0_FPC_I2C_CTRL_REG |= (UART_0_FPC_I2C_CTRL_S_READY_DATA_ACK |                                                                        UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK);                             }while(0)
N
N/* Disable Slave autoACK/NACK Data */
N#define UART_0_FPC_DISABLE_SLAVE_AUTO_DATA \
N                            do{                  \
N                                UART_0_FPC_I2C_CTRL_REG &= ((uint32) \
N                                                                  ~(UART_0_FPC_I2C_CTRL_S_READY_DATA_ACK |       \
N                                                                    UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK)); \
N                            }while(0)
X#define UART_0_FPC_DISABLE_SLAVE_AUTO_DATA                             do{                                                  UART_0_FPC_I2C_CTRL_REG &= ((uint32)                                                                   ~(UART_0_FPC_I2C_CTRL_S_READY_DATA_ACK |                                                                           UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK));                             }while(0)
N
N/* Disable Master autoACK/NACK Data */
N#define UART_0_FPC_DISABLE_MASTER_AUTO_DATA \
N                            do{                   \
N                                UART_0_FPC_I2C_CTRL_REG &= ((uint32) \
N                                                                  ~(UART_0_FPC_I2C_CTRL_M_READY_DATA_ACK |       \
N                                                                    UART_0_FPC_I2C_CTRL_M_NOT_READY_DATA_NACK)); \
N                            }while(0)
X#define UART_0_FPC_DISABLE_MASTER_AUTO_DATA                             do{                                                   UART_0_FPC_I2C_CTRL_REG &= ((uint32)                                                                   ~(UART_0_FPC_I2C_CTRL_M_READY_DATA_ACK |                                                                           UART_0_FPC_I2C_CTRL_M_NOT_READY_DATA_NACK));                             }while(0)
N/* Disables auto data ACK/NACK bits */
N#define UART_0_FPC_DISABLE_AUTO_DATA \
N                do{                        \
N                    UART_0_FPC_I2C_CTRL_REG &= ((uint32) ~(UART_0_FPC_I2C_CTRL_M_READY_DATA_ACK      |  \
N                                                                 UART_0_FPC_I2C_CTRL_M_NOT_READY_DATA_NACK |  \
N                                                                 UART_0_FPC_I2C_CTRL_S_READY_DATA_ACK      |  \
N                                                                 UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK)); \
N                }while(0)
X#define UART_0_FPC_DISABLE_AUTO_DATA                 do{                                            UART_0_FPC_I2C_CTRL_REG &= ((uint32) ~(UART_0_FPC_I2C_CTRL_M_READY_DATA_ACK      |                                                                   UART_0_FPC_I2C_CTRL_M_NOT_READY_DATA_NACK |                                                                   UART_0_FPC_I2C_CTRL_S_READY_DATA_ACK      |                                                                   UART_0_FPC_I2C_CTRL_S_NOT_READY_DATA_NACK));                 }while(0)
N
N/* Master commands */
N#define UART_0_FPC_I2C_MASTER_GENERATE_START \
N                            do{                    \
N                                UART_0_FPC_I2C_MASTER_CMD_REG = UART_0_FPC_I2C_MASTER_CMD_M_START_ON_IDLE; \
N                            }while(0)
X#define UART_0_FPC_I2C_MASTER_GENERATE_START                             do{                                                    UART_0_FPC_I2C_MASTER_CMD_REG = UART_0_FPC_I2C_MASTER_CMD_M_START_ON_IDLE;                             }while(0)
N
N#define UART_0_FPC_I2C_MASTER_CLEAR_START \
N                            do{                 \
N                                UART_0_FPC_I2C_MASTER_CMD_REG =  ((uint32) 0u); \
N                            }while(0)
X#define UART_0_FPC_I2C_MASTER_CLEAR_START                             do{                                                 UART_0_FPC_I2C_MASTER_CMD_REG =  ((uint32) 0u);                             }while(0)
N
N#define UART_0_FPC_I2C_MASTER_GENERATE_RESTART UART_0_FPC_I2CReStartGeneration()
N
N#define UART_0_FPC_I2C_MASTER_GENERATE_STOP \
N                            do{                   \
N                                UART_0_FPC_I2C_MASTER_CMD_REG =                                            \
N                                    (UART_0_FPC_I2C_MASTER_CMD_M_STOP |                                    \
N                                        (UART_0_FPC_CHECK_I2C_STATUS(UART_0_FPC_I2C_STATUS_M_READ) ? \
N                                            (UART_0_FPC_I2C_MASTER_CMD_M_NACK) : (0u)));                   \
N                            }while(0)
X#define UART_0_FPC_I2C_MASTER_GENERATE_STOP                             do{                                                   UART_0_FPC_I2C_MASTER_CMD_REG =                                                                                (UART_0_FPC_I2C_MASTER_CMD_M_STOP |                                                                            (UART_0_FPC_CHECK_I2C_STATUS(UART_0_FPC_I2C_STATUS_M_READ) ?                                             (UART_0_FPC_I2C_MASTER_CMD_M_NACK) : (0u)));                                               }while(0)
N
N#define UART_0_FPC_I2C_MASTER_GENERATE_ACK \
N                            do{                  \
N                                UART_0_FPC_I2C_MASTER_CMD_REG = UART_0_FPC_I2C_MASTER_CMD_M_ACK; \
N                            }while(0)
X#define UART_0_FPC_I2C_MASTER_GENERATE_ACK                             do{                                                  UART_0_FPC_I2C_MASTER_CMD_REG = UART_0_FPC_I2C_MASTER_CMD_M_ACK;                             }while(0)
N
N#define UART_0_FPC_I2C_MASTER_GENERATE_NACK \
N                            do{                   \
N                                UART_0_FPC_I2C_MASTER_CMD_REG = UART_0_FPC_I2C_MASTER_CMD_M_NACK; \
N                            }while(0)
X#define UART_0_FPC_I2C_MASTER_GENERATE_NACK                             do{                                                   UART_0_FPC_I2C_MASTER_CMD_REG = UART_0_FPC_I2C_MASTER_CMD_M_NACK;                             }while(0)
N
N/* Slave commands */
N#define UART_0_FPC_I2C_SLAVE_GENERATE_ACK \
N                            do{                 \
N                                UART_0_FPC_I2C_SLAVE_CMD_REG = UART_0_FPC_I2C_SLAVE_CMD_S_ACK; \
N                            }while(0)
X#define UART_0_FPC_I2C_SLAVE_GENERATE_ACK                             do{                                                 UART_0_FPC_I2C_SLAVE_CMD_REG = UART_0_FPC_I2C_SLAVE_CMD_S_ACK;                             }while(0)
N
N#if (UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1)
X#if ((2 == 0u) || (2 == 1u))
S    /* Slave NACK generation for EC_AM logic on address phase. Ticket ID #183902 */
S    void UART_0_FPC_I2CSlaveNackGeneration(void);
S    #define UART_0_FPC_I2C_SLAVE_GENERATE_NACK UART_0_FPC_I2CSlaveNackGeneration()
S
N#else
N    #define UART_0_FPC_I2C_SLAVE_GENERATE_NACK \
N                            do{                      \
N                                UART_0_FPC_I2C_SLAVE_CMD_REG = UART_0_FPC_I2C_SLAVE_CMD_S_NACK; \
N                            }while(0)
X    #define UART_0_FPC_I2C_SLAVE_GENERATE_NACK                             do{                                                      UART_0_FPC_I2C_SLAVE_CMD_REG = UART_0_FPC_I2C_SLAVE_CMD_S_NACK;                             }while(0)
N#endif /* (UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1) */
N
N#define UART_0_FPC_I2C_SLAVE_CLEAR_NACK \
N                            do{               \
N                                UART_0_FPC_I2C_SLAVE_CMD_REG = 0u; \
N                            }while(0)
X#define UART_0_FPC_I2C_SLAVE_CLEAR_NACK                             do{                                               UART_0_FPC_I2C_SLAVE_CMD_REG = 0u;                             }while(0)
N
N/* Return 8-bit address. The input address should be 7-bits */
N#define UART_0_FPC_GET_I2C_8BIT_ADDRESS(addr) (((uint32) ((uint32) (addr) << \
N                                                                    UART_0_FPC_I2C_SLAVE_ADDR_POS)) & \
N                                                                        UART_0_FPC_I2C_SLAVE_ADDR_MASK)
X#define UART_0_FPC_GET_I2C_8BIT_ADDRESS(addr) (((uint32) ((uint32) (addr) <<                                                                     UART_0_FPC_I2C_SLAVE_ADDR_POS)) &                                                                         UART_0_FPC_I2C_SLAVE_ADDR_MASK)
N
N#define UART_0_FPC_GET_I2C_7BIT_ADDRESS(addr) ((uint32) (addr) >> UART_0_FPC_I2C_SLAVE_ADDR_POS)
N
N/* Adjust SDA filter Trim settings */
N#define UART_0_FPC_DEFAULT_I2C_CFG_SDA_FILT_TRIM  (0x02u)
N#define UART_0_FPC_EC_AM_I2C_CFG_SDA_FILT_TRIM    (0x03u)
N
N#if (UART_0_FPC_CY_SCBIP_V0)
X#if ((2 == 0u))
S    #define UART_0_FPC_SET_I2C_CFG_SDA_FILT_TRIM(sdaTrim) \
S        do{                                                 \
S            UART_0_FPC_I2C_CFG_REG =                  \
S                            ((UART_0_FPC_I2C_CFG_REG & (uint32) ~UART_0_FPC_I2C_CFG_SDA_FILT_TRIM_MASK) | \
S                             ((uint32) ((uint32) (sdaTrim) <<UART_0_FPC_I2C_CFG_SDA_FILT_TRIM_POS)));           \
S        }while(0)
X    #define UART_0_FPC_SET_I2C_CFG_SDA_FILT_TRIM(sdaTrim)         do{                                                             UART_0_FPC_I2C_CFG_REG =                                              ((UART_0_FPC_I2C_CFG_REG & (uint32) ~UART_0_FPC_I2C_CFG_SDA_FILT_TRIM_MASK) |                              ((uint32) ((uint32) (sdaTrim) <<UART_0_FPC_I2C_CFG_SDA_FILT_TRIM_POS)));                   }while(0)
N#endif /* (UART_0_FPC_CY_SCBIP_V0) */
N
N/* Enable/Disable analog and digital filter */
N#define UART_0_FPC_DIGITAL_FILTER_DISABLE    (0u)
N#define UART_0_FPC_DIGITAL_FILTER_ENABLE     (1u)
N#define UART_0_FPC_I2C_DATA_RATE_FS_MODE_MAX (400u)
N#if (UART_0_FPC_CY_SCBIP_V0)
X#if ((2 == 0u))
S    /* UART_0_FPC_I2C_CFG_SDA_FILT_OUT_ENABLED is disabled by default */
S    #define UART_0_FPC_I2C_CFG_FILT_MASK  (UART_0_FPC_I2C_CFG_SDA_FILT_ENABLED | \
S                                                 UART_0_FPC_I2C_CFG_SCL_FILT_ENABLED)
X    #define UART_0_FPC_I2C_CFG_FILT_MASK  (UART_0_FPC_I2C_CFG_SDA_FILT_ENABLED |                                                  UART_0_FPC_I2C_CFG_SCL_FILT_ENABLED)
N#else
N    /* UART_0_FPC_I2C_CFG_SDA_OUT_FILT_SEL_MASK is disabled by default */
N    #define UART_0_FPC_I2C_CFG_FILT_MASK  (UART_0_FPC_I2C_CFG_SDA_IN_FILT_SEL | \
N                                                 UART_0_FPC_I2C_CFG_SCL_IN_FILT_SEL)
X    #define UART_0_FPC_I2C_CFG_FILT_MASK  (UART_0_FPC_I2C_CFG_SDA_IN_FILT_SEL |                                                  UART_0_FPC_I2C_CFG_SCL_IN_FILT_SEL)
N#endif /* (UART_0_FPC_CY_SCBIP_V0) */
N
N#define UART_0_FPC_I2C_CFG_ANALOG_FITER_DISABLE \
N        do{                                           \
N            UART_0_FPC_I2C_CFG_REG &= (uint32) ~UART_0_FPC_I2C_CFG_FILT_MASK; \
N        }while(0)
X#define UART_0_FPC_I2C_CFG_ANALOG_FITER_DISABLE         do{                                                       UART_0_FPC_I2C_CFG_REG &= (uint32) ~UART_0_FPC_I2C_CFG_FILT_MASK;         }while(0)
N
N#define UART_0_FPC_I2C_CFG_ANALOG_FITER_ENABLE \
N        do{                                          \
N            UART_0_FPC_I2C_CFG_REG |= (uint32)  UART_0_FPC_I2C_CFG_FILT_MASK; \
N        }while(0)
X#define UART_0_FPC_I2C_CFG_ANALOG_FITER_ENABLE         do{                                                      UART_0_FPC_I2C_CFG_REG |= (uint32)  UART_0_FPC_I2C_CFG_FILT_MASK;         }while(0)
N
N/* Return slave select number from SPI_CTRL register */
N#define UART_0_FPC_GET_SPI_CTRL_SS(activeSelect) (((uint32) ((uint32) (activeSelect) << \
N                                                                    UART_0_FPC_SPI_CTRL_SLAVE_SELECT_POS)) & \
N                                                                        UART_0_FPC_SPI_CTRL_SLAVE_SELECT_MASK)
X#define UART_0_FPC_GET_SPI_CTRL_SS(activeSelect) (((uint32) ((uint32) (activeSelect) <<                                                                     UART_0_FPC_SPI_CTRL_SLAVE_SELECT_POS)) &                                                                         UART_0_FPC_SPI_CTRL_SLAVE_SELECT_MASK)
N
N/* Return true if bit is set in UART_0_FPC_I2C_STATUS_REG */
N#define UART_0_FPC_CHECK_I2C_STATUS(sourceMask)   (0u != (UART_0_FPC_I2C_STATUS_REG & (sourceMask)))
N
N/* Return true if bit is set in UART_0_FPC_SPI_STATUS_REG */
N#define UART_0_FPC_CHECK_SPI_STATUS(sourceMask)   (0u != (UART_0_FPC_SPI_STATUS_REG & (sourceMask)))
N
N/* Return FIFO size depends on UART_0_FPC_CTRL_BYTE_MODE bit */
N#define UART_0_FPC_GET_FIFO_SIZE(condition) ((0u != (condition)) ? \
N                                                    (2u * UART_0_FPC_FIFO_SIZE) : (UART_0_FPC_FIFO_SIZE))
X#define UART_0_FPC_GET_FIFO_SIZE(condition) ((0u != (condition)) ?                                                     (2u * UART_0_FPC_FIFO_SIZE) : (UART_0_FPC_FIFO_SIZE))
N
N
N/***************************************
N*       Get Macros Definitions
N***************************************/
N
N/* UART_0_FPC_CTRL */
N#define UART_0_FPC_GET_CTRL_OVS(oversample)       (((uint32) (oversample) - 1u) & UART_0_FPC_CTRL_OVS_MASK)
N
N#define UART_0_FPC_GET_CTRL_EC_OP_MODE(opMode)        ((0u != (opMode)) ? \
N                                                                (UART_0_FPC_CTRL_EC_OP_MODE)  : (0u))
X#define UART_0_FPC_GET_CTRL_EC_OP_MODE(opMode)        ((0u != (opMode)) ?                                                                 (UART_0_FPC_CTRL_EC_OP_MODE)  : (0u))
N
N#define UART_0_FPC_GET_CTRL_EC_AM_MODE(amMode)        ((0u != (amMode)) ? \
N                                                                (UART_0_FPC_CTRL_EC_AM_MODE)  : (0u))
X#define UART_0_FPC_GET_CTRL_EC_AM_MODE(amMode)        ((0u != (amMode)) ?                                                                 (UART_0_FPC_CTRL_EC_AM_MODE)  : (0u))
N
N#define UART_0_FPC_GET_CTRL_BLOCK(block)              ((0u != (block))  ? \
N                                                                (UART_0_FPC_CTRL_BLOCK)       : (0u))
X#define UART_0_FPC_GET_CTRL_BLOCK(block)              ((0u != (block))  ?                                                                 (UART_0_FPC_CTRL_BLOCK)       : (0u))
N
N#define UART_0_FPC_GET_CTRL_ADDR_ACCEPT(acceptAddr)   ((0u != (acceptAddr)) ? \
N                                                                (UART_0_FPC_CTRL_ADDR_ACCEPT) : (0u))
X#define UART_0_FPC_GET_CTRL_ADDR_ACCEPT(acceptAddr)   ((0u != (acceptAddr)) ?                                                                 (UART_0_FPC_CTRL_ADDR_ACCEPT) : (0u))
N
N#if (UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1)
X#if ((2 == 0u) || (2 == 1u))
S    #define UART_0_FPC_GET_CTRL_BYTE_MODE(mode)   (0u)
N#else
N    #define UART_0_FPC_GET_CTRL_BYTE_MODE(mode)   ((0u != (mode)) ? \
N                                                            (UART_0_FPC_CTRL_BYTE_MODE) : (0u))
X    #define UART_0_FPC_GET_CTRL_BYTE_MODE(mode)   ((0u != (mode)) ?                                                             (UART_0_FPC_CTRL_BYTE_MODE) : (0u))
N#endif /* (UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1) */
N
N/* UART_0_FPC_I2C_CTRL */
N#define UART_0_FPC_GET_I2C_CTRL_HIGH_PHASE_OVS(oversampleHigh) (((uint32) (oversampleHigh) - 1u) & \
N                                                                        UART_0_FPC_I2C_CTRL_HIGH_PHASE_OVS_MASK)
X#define UART_0_FPC_GET_I2C_CTRL_HIGH_PHASE_OVS(oversampleHigh) (((uint32) (oversampleHigh) - 1u) &                                                                         UART_0_FPC_I2C_CTRL_HIGH_PHASE_OVS_MASK)
N
N#define UART_0_FPC_GET_I2C_CTRL_LOW_PHASE_OVS(oversampleLow)  ((((uint32) (oversampleLow) - 1u) << \
N                                                                    UART_0_FPC_I2C_CTRL_LOW_PHASE_OVS_POS) &  \
N                                                                    UART_0_FPC_I2C_CTRL_LOW_PHASE_OVS_MASK)
X#define UART_0_FPC_GET_I2C_CTRL_LOW_PHASE_OVS(oversampleLow)  ((((uint32) (oversampleLow) - 1u) <<                                                                     UART_0_FPC_I2C_CTRL_LOW_PHASE_OVS_POS) &                                                                      UART_0_FPC_I2C_CTRL_LOW_PHASE_OVS_MASK)
N
N#define UART_0_FPC_GET_I2C_CTRL_S_NOT_READY_ADDR_NACK(wakeNack) ((0u != (wakeNack)) ? \
N                                                            (UART_0_FPC_I2C_CTRL_S_NOT_READY_ADDR_NACK) : (0u))
X#define UART_0_FPC_GET_I2C_CTRL_S_NOT_READY_ADDR_NACK(wakeNack) ((0u != (wakeNack)) ?                                                             (UART_0_FPC_I2C_CTRL_S_NOT_READY_ADDR_NACK) : (0u))
N
N#define UART_0_FPC_GET_I2C_CTRL_S_GENERAL_IGNORE(genCall) ((0u != (genCall)) ? \
N                                                                    (UART_0_FPC_I2C_CTRL_S_GENERAL_IGNORE) : (0u))
X#define UART_0_FPC_GET_I2C_CTRL_S_GENERAL_IGNORE(genCall) ((0u != (genCall)) ?                                                                     (UART_0_FPC_I2C_CTRL_S_GENERAL_IGNORE) : (0u))
N
N#define UART_0_FPC_GET_I2C_CTRL_SL_MSTR_MODE(mode)    ((uint32)(mode) << UART_0_FPC_I2C_CTRL_SLAVE_MODE_POS)
N
N/* UART_0_FPC_SPI_CTRL */
N#define UART_0_FPC_GET_SPI_CTRL_CONTINUOUS(separate)  ((0u != (separate)) ? \
N                                                                (UART_0_FPC_SPI_CTRL_CONTINUOUS) : (0u))
X#define UART_0_FPC_GET_SPI_CTRL_CONTINUOUS(separate)  ((0u != (separate)) ?                                                                 (UART_0_FPC_SPI_CTRL_CONTINUOUS) : (0u))
N
N#define UART_0_FPC_GET_SPI_CTRL_SELECT_PRECEDE(mode)  ((0u != (mode)) ? \
N                                                                      (UART_0_FPC_SPI_CTRL_SELECT_PRECEDE) : (0u))
X#define UART_0_FPC_GET_SPI_CTRL_SELECT_PRECEDE(mode)  ((0u != (mode)) ?                                                                       (UART_0_FPC_SPI_CTRL_SELECT_PRECEDE) : (0u))
N
N#define UART_0_FPC_GET_SPI_CTRL_SCLK_MODE(mode)       (((uint32) (mode) << \
N                                                                        UART_0_FPC_SPI_CTRL_CPHA_POS) & \
N                                                                        UART_0_FPC_SPI_CTRL_SCLK_MODE_MASK)
X#define UART_0_FPC_GET_SPI_CTRL_SCLK_MODE(mode)       (((uint32) (mode) <<                                                                         UART_0_FPC_SPI_CTRL_CPHA_POS) &                                                                         UART_0_FPC_SPI_CTRL_SCLK_MODE_MASK)
N
N#define UART_0_FPC_GET_SPI_CTRL_LATE_MISO_SAMPLE(lateMiso) ((0u != (lateMiso)) ? \
N                                                                    (UART_0_FPC_SPI_CTRL_LATE_MISO_SAMPLE) : (0u))
X#define UART_0_FPC_GET_SPI_CTRL_LATE_MISO_SAMPLE(lateMiso) ((0u != (lateMiso)) ?                                                                     (UART_0_FPC_SPI_CTRL_LATE_MISO_SAMPLE) : (0u))
N
N#if (UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1)
X#if ((2 == 0u) || (2 == 1u))
S    #define UART_0_FPC_GET_SPI_CTRL_SCLK_CONTINUOUS(sclkType) (0u)
S    #define UART_0_FPC_GET_SPI_CTRL_SSEL_POLARITY(polarity)   (0u)
N#else
N    #define UART_0_FPC_GET_SPI_CTRL_SCLK_CONTINUOUS(sclkType) ((0u != (sclkType)) ? \
N                                                                    (UART_0_FPC_SPI_CTRL_SCLK_CONTINUOUS) : (0u))
X    #define UART_0_FPC_GET_SPI_CTRL_SCLK_CONTINUOUS(sclkType) ((0u != (sclkType)) ?                                                                     (UART_0_FPC_SPI_CTRL_SCLK_CONTINUOUS) : (0u))
N
N    #define UART_0_FPC_GET_SPI_CTRL_SSEL_POLARITY(polarity)   (((uint32) (polarity) << \
N                                                                     UART_0_FPC_SPI_CTRL_SSEL0_POLARITY_POS) & \
N                                                                     UART_0_FPC_SPI_CTRL_SSEL_POLARITY_MASK)
X    #define UART_0_FPC_GET_SPI_CTRL_SSEL_POLARITY(polarity)   (((uint32) (polarity) <<                                                                      UART_0_FPC_SPI_CTRL_SSEL0_POLARITY_POS) &                                                                      UART_0_FPC_SPI_CTRL_SSEL_POLARITY_MASK)
N#endif /* ((UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1) */
N
N#define UART_0_FPC_GET_SPI_CTRL_SUB_MODE(mode)        (((uint32) (mode) << UART_0_FPC_SPI_CTRL_MODE_POS) & \
N                                                                                 UART_0_FPC_SPI_CTRL_MODE_MASK)
X#define UART_0_FPC_GET_SPI_CTRL_SUB_MODE(mode)        (((uint32) (mode) << UART_0_FPC_SPI_CTRL_MODE_POS) &                                                                                  UART_0_FPC_SPI_CTRL_MODE_MASK)
N
N#define UART_0_FPC_GET_SPI_CTRL_SLAVE_SELECT(select)  (((uint32) (select) << \
N                                                                      UART_0_FPC_SPI_CTRL_SLAVE_SELECT_POS) & \
N                                                                      UART_0_FPC_SPI_CTRL_SLAVE_SELECT_MASK)
X#define UART_0_FPC_GET_SPI_CTRL_SLAVE_SELECT(select)  (((uint32) (select) <<                                                                       UART_0_FPC_SPI_CTRL_SLAVE_SELECT_POS) &                                                                       UART_0_FPC_SPI_CTRL_SLAVE_SELECT_MASK)
N
N#define UART_0_FPC_GET_SPI_CTRL_MASTER_MODE(mode)     ((0u != (mode)) ? \
N                                                                (UART_0_FPC_SPI_CTRL_MASTER) : (0u))
X#define UART_0_FPC_GET_SPI_CTRL_MASTER_MODE(mode)     ((0u != (mode)) ?                                                                 (UART_0_FPC_SPI_CTRL_MASTER) : (0u))
N
N/* UART_0_FPC_UART_CTRL */
N#define UART_0_FPC_GET_UART_CTRL_MODE(mode)           (((uint32) (mode) << \
N                                                                            UART_0_FPC_UART_CTRL_MODE_POS) & \
N                                                                            UART_0_FPC_UART_CTRL_MODE_MASK)
X#define UART_0_FPC_GET_UART_CTRL_MODE(mode)           (((uint32) (mode) <<                                                                             UART_0_FPC_UART_CTRL_MODE_POS) &                                                                             UART_0_FPC_UART_CTRL_MODE_MASK)
N
N/* UART_0_FPC_UART_RX_CTRL */
N#define UART_0_FPC_GET_UART_RX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) & \
N                                                                        UART_0_FPC_UART_RX_CTRL_STOP_BITS_MASK)
X#define UART_0_FPC_GET_UART_RX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) &                                                                         UART_0_FPC_UART_RX_CTRL_STOP_BITS_MASK)
N
N#define UART_0_FPC_GET_UART_RX_CTRL_PARITY(parity)    ((0u != (parity)) ? \
N                                                                    (UART_0_FPC_UART_RX_CTRL_PARITY) : (0u))
X#define UART_0_FPC_GET_UART_RX_CTRL_PARITY(parity)    ((0u != (parity)) ?                                                                     (UART_0_FPC_UART_RX_CTRL_PARITY) : (0u))
N
N#define UART_0_FPC_GET_UART_RX_CTRL_POLARITY(polarity)    ((0u != (polarity)) ? \
N                                                                    (UART_0_FPC_UART_RX_CTRL_POLARITY) : (0u))
X#define UART_0_FPC_GET_UART_RX_CTRL_POLARITY(polarity)    ((0u != (polarity)) ?                                                                     (UART_0_FPC_UART_RX_CTRL_POLARITY) : (0u))
N
N#define UART_0_FPC_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(dropErr) ((0u != (dropErr)) ? \
N                                                        (UART_0_FPC_UART_RX_CTRL_DROP_ON_PARITY_ERR) : (0u))
X#define UART_0_FPC_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(dropErr) ((0u != (dropErr)) ?                                                         (UART_0_FPC_UART_RX_CTRL_DROP_ON_PARITY_ERR) : (0u))
N
N#define UART_0_FPC_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(dropErr) ((0u != (dropErr)) ? \
N                                                        (UART_0_FPC_UART_RX_CTRL_DROP_ON_FRAME_ERR) : (0u))
X#define UART_0_FPC_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(dropErr) ((0u != (dropErr)) ?                                                         (UART_0_FPC_UART_RX_CTRL_DROP_ON_FRAME_ERR) : (0u))
N
N#define UART_0_FPC_GET_UART_RX_CTRL_MP_MODE(mpMode)   ((0u != (mpMode)) ? \
N                                                        (UART_0_FPC_UART_RX_CTRL_MP_MODE) : (0u))
X#define UART_0_FPC_GET_UART_RX_CTRL_MP_MODE(mpMode)   ((0u != (mpMode)) ?                                                         (UART_0_FPC_UART_RX_CTRL_MP_MODE) : (0u))
N
N#define UART_0_FPC_GET_UART_RX_CTRL_BREAK_WIDTH(width)    (((uint32) ((uint32) (width) - 1u) << \
N                                                                    UART_0_FPC_UART_RX_CTRL_BREAK_WIDTH_POS) & \
N                                                                    UART_0_FPC_UART_RX_CTRL_BREAK_WIDTH_MASK)
X#define UART_0_FPC_GET_UART_RX_CTRL_BREAK_WIDTH(width)    (((uint32) ((uint32) (width) - 1u) <<                                                                     UART_0_FPC_UART_RX_CTRL_BREAK_WIDTH_POS) &                                                                     UART_0_FPC_UART_RX_CTRL_BREAK_WIDTH_MASK)
N
N/* UART_0_FPC_UART_TX_CTRL */
N#define UART_0_FPC_GET_UART_TX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) & \
N                                                                UART_0_FPC_UART_RX_CTRL_STOP_BITS_MASK)
X#define UART_0_FPC_GET_UART_TX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) &                                                                 UART_0_FPC_UART_RX_CTRL_STOP_BITS_MASK)
N
N#define UART_0_FPC_GET_UART_TX_CTRL_PARITY(parity)    ((0u != (parity)) ? \
N                                                               (UART_0_FPC_UART_TX_CTRL_PARITY) : (0u))
X#define UART_0_FPC_GET_UART_TX_CTRL_PARITY(parity)    ((0u != (parity)) ?                                                                (UART_0_FPC_UART_TX_CTRL_PARITY) : (0u))
N
N#define UART_0_FPC_GET_UART_TX_CTRL_RETRY_NACK(nack)  ((0u != (nack)) ? \
N                                                               (UART_0_FPC_UART_TX_CTRL_RETRY_ON_NACK) : (0u))
X#define UART_0_FPC_GET_UART_TX_CTRL_RETRY_NACK(nack)  ((0u != (nack)) ?                                                                (UART_0_FPC_UART_TX_CTRL_RETRY_ON_NACK) : (0u))
N
N/* UART_0_FPC_UART_FLOW_CTRL */
N#if !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define UART_0_FPC_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(level)   ( (uint32) (level) & \
N                                                                 UART_0_FPC_UART_FLOW_CTRL_TRIGGER_LEVEL_MASK)
X    #define UART_0_FPC_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(level)   ( (uint32) (level) &                                                                  UART_0_FPC_UART_FLOW_CTRL_TRIGGER_LEVEL_MASK)
N
N    #define UART_0_FPC_GET_UART_FLOW_CTRL_RTS_POLARITY(polarity) ((0u != (polarity)) ? \
N                                                                (UART_0_FPC_UART_FLOW_CTRL_RTS_POLARITY) : (0u))
X    #define UART_0_FPC_GET_UART_FLOW_CTRL_RTS_POLARITY(polarity) ((0u != (polarity)) ?                                                                 (UART_0_FPC_UART_FLOW_CTRL_RTS_POLARITY) : (0u))
N
N    #define UART_0_FPC_GET_UART_FLOW_CTRL_CTS_POLARITY(polarity) ((0u != (polarity)) ? \
N                                                                (UART_0_FPC_UART_FLOW_CTRL_CTS_POLARITY) : (0u))
X    #define UART_0_FPC_GET_UART_FLOW_CTRL_CTS_POLARITY(polarity) ((0u != (polarity)) ?                                                                 (UART_0_FPC_UART_FLOW_CTRL_CTS_POLARITY) : (0u))
N
N    #define UART_0_FPC_GET_UART_FLOW_CTRL_CTS_ENABLE(ctsEn)      ((0u != (ctsEn)) ? \
N                                                                (UART_0_FPC_UART_FLOW_CTRL_CTS_ENABLE) : (0u))
X    #define UART_0_FPC_GET_UART_FLOW_CTRL_CTS_ENABLE(ctsEn)      ((0u != (ctsEn)) ?                                                                 (UART_0_FPC_UART_FLOW_CTRL_CTS_ENABLE) : (0u))
N#endif /* !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1) */
N
N/* UART_0_FPC_RX_CTRL */
N#define UART_0_FPC_GET_RX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) & \
N                                                                UART_0_FPC_RX_CTRL_DATA_WIDTH_MASK)
X#define UART_0_FPC_GET_RX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) &                                                                 UART_0_FPC_RX_CTRL_DATA_WIDTH_MASK)
N
N#define UART_0_FPC_GET_RX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ? \
N                                                                (UART_0_FPC_RX_CTRL_MSB_FIRST) : (0u))
X#define UART_0_FPC_GET_RX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ?                                                                 (UART_0_FPC_RX_CTRL_MSB_FIRST) : (0u))
N
N#define UART_0_FPC_GET_RX_CTRL_MEDIAN(filterEn)       ((0u != (filterEn)) ? \
N                                                                (UART_0_FPC_RX_CTRL_MEDIAN) : (0u))
X#define UART_0_FPC_GET_RX_CTRL_MEDIAN(filterEn)       ((0u != (filterEn)) ?                                                                 (UART_0_FPC_RX_CTRL_MEDIAN) : (0u))
N
N/* UART_0_FPC_RX_MATCH */
N#define UART_0_FPC_GET_RX_MATCH_ADDR(addr)    ((uint32) (addr) & UART_0_FPC_RX_MATCH_ADDR_MASK)
N#define UART_0_FPC_GET_RX_MATCH_MASK(mask)    (((uint32) (mask) << \
N                                                            UART_0_FPC_RX_MATCH_MASK_POS) & \
N                                                            UART_0_FPC_RX_MATCH_MASK_MASK)
X#define UART_0_FPC_GET_RX_MATCH_MASK(mask)    (((uint32) (mask) <<                                                             UART_0_FPC_RX_MATCH_MASK_POS) &                                                             UART_0_FPC_RX_MATCH_MASK_MASK)
N
N/* UART_0_FPC_RX_FIFO_CTRL */
N#define UART_0_FPC_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) & \
N                                                                    UART_0_FPC_RX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
X#define UART_0_FPC_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) &                                                                     UART_0_FPC_RX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
N
N/* UART_0_FPC_TX_CTRL */
N#define UART_0_FPC_GET_TX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) & \
N                                                                UART_0_FPC_TX_CTRL_DATA_WIDTH_MASK)
X#define UART_0_FPC_GET_TX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) &                                                                 UART_0_FPC_TX_CTRL_DATA_WIDTH_MASK)
N
N#define UART_0_FPC_GET_TX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ? \
N                                                                (UART_0_FPC_TX_CTRL_MSB_FIRST) : (0u))
X#define UART_0_FPC_GET_TX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ?                                                                 (UART_0_FPC_TX_CTRL_MSB_FIRST) : (0u))
N
N/* UART_0_FPC_TX_FIFO_CTRL */
N#define UART_0_FPC_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) & \
N                                                                    UART_0_FPC_TX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
X#define UART_0_FPC_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) &                                                                     UART_0_FPC_TX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
N
N/* UART_0_FPC_INTR_SLAVE_I2C_GENERAL */
N#define UART_0_FPC_GET_INTR_SLAVE_I2C_GENERAL(genCall)  ((0u != (genCall)) ? \
N                                                                (UART_0_FPC_INTR_SLAVE_I2C_GENERAL) : (0u))
X#define UART_0_FPC_GET_INTR_SLAVE_I2C_GENERAL(genCall)  ((0u != (genCall)) ?                                                                 (UART_0_FPC_INTR_SLAVE_I2C_GENERAL) : (0u))
N
N/* Return true if master mode is enabled UART_0_FPC_SPI_CTRL_REG */
N#define UART_0_FPC_CHECK_SPI_MASTER   (0u != (UART_0_FPC_SPI_CTRL_REG & UART_0_FPC_SPI_CTRL_MASTER))
N
N/* Return inactive state of SPI SCLK line depends on CPOL */
N#define UART_0_FPC_GET_SPI_SCLK_INACTIVE \
N            ((0u == (UART_0_FPC_SPI_CTRL_REG & UART_0_FPC_SPI_CTRL_CPOL)) ? (0u) : (1u))
X#define UART_0_FPC_GET_SPI_SCLK_INACTIVE             ((0u == (UART_0_FPC_SPI_CTRL_REG & UART_0_FPC_SPI_CTRL_CPOL)) ? (0u) : (1u))
N
N/* Get output pin inactive state */
N#if (UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1)
X#if ((2 == 0u) || (2 == 1u))
S#define UART_0_FPC_GET_SPI_SS0_INACTIVE       (1u)
S#define UART_0_FPC_GET_SPI_SS1_INACTIVE       (1u)
S#define UART_0_FPC_GET_SPI_SS2_INACTIVE       (1u)
S#define UART_0_FPC_GET_SPI_SS3_INACTIVE       (1u)
S#define UART_0_FPC_GET_UART_RTS_INACTIVE      (1u)
S
N#else
N#define UART_0_FPC_GET_SPI_SS0_INACTIVE  \
N        ((0u != (UART_0_FPC_SPI_CTRL_REG & UART_0_FPC_SPI_CTRL_SSEL0_POLARITY)) ? (0u) : (1u))
X#define UART_0_FPC_GET_SPI_SS0_INACTIVE          ((0u != (UART_0_FPC_SPI_CTRL_REG & UART_0_FPC_SPI_CTRL_SSEL0_POLARITY)) ? (0u) : (1u))
N
N#define UART_0_FPC_GET_SPI_SS1_INACTIVE  \
N        ((0u != (UART_0_FPC_SPI_CTRL_REG & UART_0_FPC_SPI_CTRL_SSEL1_POLARITY)) ? (0u) : (1u))
X#define UART_0_FPC_GET_SPI_SS1_INACTIVE          ((0u != (UART_0_FPC_SPI_CTRL_REG & UART_0_FPC_SPI_CTRL_SSEL1_POLARITY)) ? (0u) : (1u))
N
N#define UART_0_FPC_GET_SPI_SS2_INACTIVE  \
N        ((0u != (UART_0_FPC_SPI_CTRL_REG & UART_0_FPC_SPI_CTRL_SSEL2_POLARITY)) ? (0u) : (1u))
X#define UART_0_FPC_GET_SPI_SS2_INACTIVE          ((0u != (UART_0_FPC_SPI_CTRL_REG & UART_0_FPC_SPI_CTRL_SSEL2_POLARITY)) ? (0u) : (1u))
N
N#define UART_0_FPC_GET_SPI_SS3_INACTIVE  \
N        ((0u != (UART_0_FPC_SPI_CTRL_REG & UART_0_FPC_SPI_CTRL_SSEL3_POLARITY)) ? (0u) : (1u))
X#define UART_0_FPC_GET_SPI_SS3_INACTIVE          ((0u != (UART_0_FPC_SPI_CTRL_REG & UART_0_FPC_SPI_CTRL_SSEL3_POLARITY)) ? (0u) : (1u))
N
N#define UART_0_FPC_GET_UART_RTS_INACTIVE \
N        ((0u == (UART_0_FPC_UART_FLOW_CTRL_REG & UART_0_FPC_UART_FLOW_CTRL_RTS_POLARITY)) ? (0u) : (1u))
X#define UART_0_FPC_GET_UART_RTS_INACTIVE         ((0u == (UART_0_FPC_UART_FLOW_CTRL_REG & UART_0_FPC_UART_FLOW_CTRL_RTS_POLARITY)) ? (0u) : (1u))
N
N#endif /*(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1) */
N
N/* Clear register constants for configuration and interrupt mask */
N#define UART_0_FPC_CLEAR_REG          ((uint32) (0u))
N#define UART_0_FPC_NO_INTR_SOURCES    ((uint32) (0u))
N#define UART_0_FPC_DUMMY_PARAM        ((uint32) (0u))
N#define UART_0_FPC_SUBMODE_SPI_SLAVE  ((uint32) (0u))
N
N/* Return in case of I2C read error */
N#define UART_0_FPC_I2C_INVALID_BYTE   ((uint32) 0xFFFFFFFFu)
N#define UART_0_FPC_CHECK_VALID_BYTE   ((uint32) 0x80000000u)
N
N
N/***************************************
N* The following code is DEPRECATED and
N* must not be used.
N***************************************/
N
N#define UART_0_FPC_CHECK_INTR_EC_I2C(sourceMask)  UART_0_FPC_CHECK_INTR_I2C_EC(sourceMask)
N#if (!UART_0_FPC_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_0_FPC_CHECK_INTR_EC_SPI(sourceMask)  UART_0_FPC_CHECK_INTR_SPI_EC(sourceMask)
N#endif /* (!UART_0_FPC_CY_SCBIP_V1) */
N
N#define UART_0_FPC_CY_SCBIP_V1_I2C_ONLY   (UART_0_FPC_CY_SCBIP_V1)
N#define UART_0_FPC_EZBUFFER_SIZE          (UART_0_FPC_EZ_DATA_NR)
N
N#define UART_0_FPC_EZBUF_DATA00_REG   UART_0_FPC_EZBUF_DATA0_REG
N#define UART_0_FPC_EZBUF_DATA00_PTR   UART_0_FPC_EZBUF_DATA0_PTR
N
N#endif /* (CY_SCB_UART_0_FPC_H) */
N
N
N/* [] END OF FILE */
L 28 "Generated_Source\PSoC4\project.h" 2
N#include "UART_0_FPC_SPI_UART.h"
L 1 "Generated_Source\PSoC4\UART_0_FPC_SPI_UART.h" 1
N/***************************************************************************//**
N* \file UART_0_FPC_SPI_UART.h
N* \version 4.0
N*
N* \brief
N*  This file provides constants and parameter values for the SCB Component in
N*  SPI and UART modes.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_SPI_UART_UART_0_FPC_H)
X#if !0L
N#define CY_SCB_SPI_UART_UART_0_FPC_H
N
N#include "UART_0_FPC.h"
N
N
N/***************************************
N*   SPI Initial Parameter Constants
N****************************************/
N
N#define UART_0_FPC_SPI_MODE                   (0u)
N#define UART_0_FPC_SPI_SUB_MODE               (0u)
N#define UART_0_FPC_SPI_CLOCK_MODE             (0u)
N#define UART_0_FPC_SPI_OVS_FACTOR             (16u)
N#define UART_0_FPC_SPI_MEDIAN_FILTER_ENABLE   (0u)
N#define UART_0_FPC_SPI_LATE_MISO_SAMPLE_ENABLE (0u)
N#define UART_0_FPC_SPI_RX_DATA_BITS_NUM       (8u)
N#define UART_0_FPC_SPI_TX_DATA_BITS_NUM       (8u)
N#define UART_0_FPC_SPI_WAKE_ENABLE            (0u)
N#define UART_0_FPC_SPI_BITS_ORDER             (1u)
N#define UART_0_FPC_SPI_TRANSFER_SEPARATION    (1u)
N#define UART_0_FPC_SPI_NUMBER_OF_SS_LINES     (1u)
N#define UART_0_FPC_SPI_RX_BUFFER_SIZE         (8u)
N#define UART_0_FPC_SPI_TX_BUFFER_SIZE         (8u)
N
N#define UART_0_FPC_SPI_INTERRUPT_MODE         (0u)
N
N#define UART_0_FPC_SPI_INTR_RX_MASK           (0x0u)
N#define UART_0_FPC_SPI_INTR_TX_MASK           (0x0u)
N
N#define UART_0_FPC_SPI_RX_TRIGGER_LEVEL       (7u)
N#define UART_0_FPC_SPI_TX_TRIGGER_LEVEL       (0u)
N
N#define UART_0_FPC_SPI_BYTE_MODE_ENABLE       (0u)
N#define UART_0_FPC_SPI_FREE_RUN_SCLK_ENABLE   (0u)
N#define UART_0_FPC_SPI_SS0_POLARITY           (0u)
N#define UART_0_FPC_SPI_SS1_POLARITY           (0u)
N#define UART_0_FPC_SPI_SS2_POLARITY           (0u)
N#define UART_0_FPC_SPI_SS3_POLARITY           (0u)
N
N
N/***************************************
N*   UART Initial Parameter Constants
N****************************************/
N
N#define UART_0_FPC_UART_SUB_MODE              (0u)
N#define UART_0_FPC_UART_DIRECTION             (3u)
N#define UART_0_FPC_UART_DATA_BITS_NUM         (8u)
N#define UART_0_FPC_UART_PARITY_TYPE           (2u)
N#define UART_0_FPC_UART_STOP_BITS_NUM         (2u)
N#define UART_0_FPC_UART_OVS_FACTOR            (12u)
N#define UART_0_FPC_UART_IRDA_LOW_POWER        (0u)
N#define UART_0_FPC_UART_MEDIAN_FILTER_ENABLE  (0u)
N#define UART_0_FPC_UART_RETRY_ON_NACK         (0u)
N#define UART_0_FPC_UART_IRDA_POLARITY         (0u)
N#define UART_0_FPC_UART_DROP_ON_FRAME_ERR     (0u)
N#define UART_0_FPC_UART_DROP_ON_PARITY_ERR    (0u)
N#define UART_0_FPC_UART_WAKE_ENABLE           (0u)
N#define UART_0_FPC_UART_RX_BUFFER_SIZE        (8u)
N#define UART_0_FPC_UART_TX_BUFFER_SIZE        (8u)
N#define UART_0_FPC_UART_MP_MODE_ENABLE        (0u)
N#define UART_0_FPC_UART_MP_ACCEPT_ADDRESS     (0u)
N#define UART_0_FPC_UART_MP_RX_ADDRESS         (0x2u)
N#define UART_0_FPC_UART_MP_RX_ADDRESS_MASK    (0xFFu)
N
N#define UART_0_FPC_UART_INTERRUPT_MODE        (1u)
N
N#define UART_0_FPC_UART_INTR_RX_MASK          (0x4u)
N#define UART_0_FPC_UART_INTR_TX_MASK          (0x0u)
N
N#define UART_0_FPC_UART_RX_TRIGGER_LEVEL      (7u)
N#define UART_0_FPC_UART_TX_TRIGGER_LEVEL      (0u)
N
N#define UART_0_FPC_UART_BYTE_MODE_ENABLE      (0u)
N#define UART_0_FPC_UART_CTS_ENABLE            (0u)
N#define UART_0_FPC_UART_CTS_POLARITY          (0u)
N#define UART_0_FPC_UART_RTS_ENABLE            (0u)
N#define UART_0_FPC_UART_RTS_POLARITY          (0u)
N#define UART_0_FPC_UART_RTS_FIFO_LEVEL        (4u)
N
N#define UART_0_FPC_UART_RX_BREAK_WIDTH        (11u)
N
N/* SPI mode enum */
N#define UART_0_FPC_SPI_SLAVE  (0u)
N#define UART_0_FPC_SPI_MASTER (1u)
N
N/* UART direction enum */
N#define UART_0_FPC_UART_RX    (1u)
N#define UART_0_FPC_UART_TX    (2u)
N#define UART_0_FPC_UART_TX_RX (3u)
N
N
N/***************************************
N*   Conditional Compilation Parameters
N****************************************/
N
N#if(UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S
S    /* Mode */
S    #define UART_0_FPC_SPI_SLAVE_CONST        (1u)
S    #define UART_0_FPC_SPI_MASTER_CONST       (1u)
S
S    /* Direction */
S    #define UART_0_FPC_RX_DIRECTION           (1u)
S    #define UART_0_FPC_TX_DIRECTION           (1u)
S    #define UART_0_FPC_UART_RX_DIRECTION      (1u)
S    #define UART_0_FPC_UART_TX_DIRECTION      (1u)
S
S    /* Only external RX and TX buffer for Uncofigured mode */
S    #define UART_0_FPC_INTERNAL_RX_SW_BUFFER   (0u)
S    #define UART_0_FPC_INTERNAL_TX_SW_BUFFER   (0u)
S
S    /* Get RX and TX buffer size */
S    #define UART_0_FPC_INTERNAL_RX_BUFFER_SIZE    (UART_0_FPC_rxBufferSize + 1u)
S    #define UART_0_FPC_RX_BUFFER_SIZE             (UART_0_FPC_rxBufferSize)
S    #define UART_0_FPC_TX_BUFFER_SIZE             (UART_0_FPC_txBufferSize)
S
S    /* Return true if buffer is provided */
S    #define UART_0_FPC_CHECK_RX_SW_BUFFER (NULL != UART_0_FPC_rxBuffer)
S    #define UART_0_FPC_CHECK_TX_SW_BUFFER (NULL != UART_0_FPC_txBuffer)
S
S    /* Always provide global variables to support RX and TX buffers */
S    #define UART_0_FPC_INTERNAL_RX_SW_BUFFER_CONST    (1u)
S    #define UART_0_FPC_INTERNAL_TX_SW_BUFFER_CONST    (1u)
S
S    /* Get wakeup enable option */
S    #define UART_0_FPC_SPI_WAKE_ENABLE_CONST  (1u)
S    #define UART_0_FPC_UART_WAKE_ENABLE_CONST (1u)
S    #define UART_0_FPC_CHECK_SPI_WAKE_ENABLE  ((0u != UART_0_FPC_scbEnableWake) && UART_0_FPC_SCB_MODE_SPI_RUNTM_CFG)
S    #define UART_0_FPC_CHECK_UART_WAKE_ENABLE ((0u != UART_0_FPC_scbEnableWake) && UART_0_FPC_SCB_MODE_UART_RUNTM_CFG)
S
S    /* SPI/UART: TX or RX FIFO size */
S    #if (UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1)
S        #define UART_0_FPC_SPI_UART_FIFO_SIZE             (UART_0_FPC_FIFO_SIZE)
S        #define UART_0_FPC_CHECK_UART_RTS_CONTROL_FLOW    (0u)
S    #else
S        #define UART_0_FPC_SPI_UART_FIFO_SIZE (UART_0_FPC_GET_FIFO_SIZE(UART_0_FPC_CTRL_REG & \
S                                                                                    UART_0_FPC_CTRL_BYTE_MODE))
X        #define UART_0_FPC_SPI_UART_FIFO_SIZE (UART_0_FPC_GET_FIFO_SIZE(UART_0_FPC_CTRL_REG &                                                                                     UART_0_FPC_CTRL_BYTE_MODE))
S
S        #define UART_0_FPC_CHECK_UART_RTS_CONTROL_FLOW \
S                    ((UART_0_FPC_SCB_MODE_UART_RUNTM_CFG) && \
S                     (0u != UART_0_FPC_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(UART_0_FPC_UART_FLOW_CTRL_REG)))
X        #define UART_0_FPC_CHECK_UART_RTS_CONTROL_FLOW                     ((UART_0_FPC_SCB_MODE_UART_RUNTM_CFG) &&                      (0u != UART_0_FPC_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(UART_0_FPC_UART_FLOW_CTRL_REG)))
S    #endif /* (UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1) */
S
N#else
N
N    /* Internal RX and TX buffer: for SPI or UART */
N    #if (UART_0_FPC_SCB_MODE_SPI_CONST_CFG)
X    #if (((0x02u) == (4u)))
S
S        /* SPI Direction */
S        #define UART_0_FPC_SPI_RX_DIRECTION (1u)
S        #define UART_0_FPC_SPI_TX_DIRECTION (1u)
S
S        /* Get FIFO size */
S        #define UART_0_FPC_SPI_UART_FIFO_SIZE UART_0_FPC_GET_FIFO_SIZE(UART_0_FPC_SPI_BYTE_MODE_ENABLE)
S
S        /* SPI internal RX and TX buffers */
S        #define UART_0_FPC_INTERNAL_SPI_RX_SW_BUFFER  (UART_0_FPC_SPI_RX_BUFFER_SIZE > \
S                                                                UART_0_FPC_SPI_UART_FIFO_SIZE)
X        #define UART_0_FPC_INTERNAL_SPI_RX_SW_BUFFER  (UART_0_FPC_SPI_RX_BUFFER_SIZE >                                                                 UART_0_FPC_SPI_UART_FIFO_SIZE)
S        #define UART_0_FPC_INTERNAL_SPI_TX_SW_BUFFER  (UART_0_FPC_SPI_TX_BUFFER_SIZE > \
S                                                                UART_0_FPC_SPI_UART_FIFO_SIZE)
X        #define UART_0_FPC_INTERNAL_SPI_TX_SW_BUFFER  (UART_0_FPC_SPI_TX_BUFFER_SIZE >                                                                 UART_0_FPC_SPI_UART_FIFO_SIZE)
S
S        /* Internal SPI RX and TX buffer */
S        #define UART_0_FPC_INTERNAL_RX_SW_BUFFER  (UART_0_FPC_INTERNAL_SPI_RX_SW_BUFFER)
S        #define UART_0_FPC_INTERNAL_TX_SW_BUFFER  (UART_0_FPC_INTERNAL_SPI_TX_SW_BUFFER)
S
S        /* Internal SPI RX and TX buffer size */
S        #define UART_0_FPC_INTERNAL_RX_BUFFER_SIZE    (UART_0_FPC_SPI_RX_BUFFER_SIZE + 1u)
S        #define UART_0_FPC_RX_BUFFER_SIZE             (UART_0_FPC_SPI_RX_BUFFER_SIZE)
S        #define UART_0_FPC_TX_BUFFER_SIZE             (UART_0_FPC_SPI_TX_BUFFER_SIZE)
S
S        /* Get wakeup enable option */
S        #define UART_0_FPC_SPI_WAKE_ENABLE_CONST  (0u != UART_0_FPC_SPI_WAKE_ENABLE)
S        #define UART_0_FPC_UART_WAKE_ENABLE_CONST (0u)
S
N    #else
N
N        /* UART Direction */
N        #define UART_0_FPC_UART_RX_DIRECTION (0u != (UART_0_FPC_UART_DIRECTION & UART_0_FPC_UART_RX))
N        #define UART_0_FPC_UART_TX_DIRECTION (0u != (UART_0_FPC_UART_DIRECTION & UART_0_FPC_UART_TX))
N
N        /* Get FIFO size */
N        #define UART_0_FPC_SPI_UART_FIFO_SIZE UART_0_FPC_GET_FIFO_SIZE(UART_0_FPC_UART_BYTE_MODE_ENABLE)
N
N        /* UART internal RX and TX buffers */
N        #define UART_0_FPC_INTERNAL_UART_RX_SW_BUFFER  (UART_0_FPC_UART_RX_BUFFER_SIZE > \
N                                                                UART_0_FPC_SPI_UART_FIFO_SIZE)
X        #define UART_0_FPC_INTERNAL_UART_RX_SW_BUFFER  (UART_0_FPC_UART_RX_BUFFER_SIZE >                                                                 UART_0_FPC_SPI_UART_FIFO_SIZE)
N        #define UART_0_FPC_INTERNAL_UART_TX_SW_BUFFER  (UART_0_FPC_UART_TX_BUFFER_SIZE > \
N                                                                    UART_0_FPC_SPI_UART_FIFO_SIZE)
X        #define UART_0_FPC_INTERNAL_UART_TX_SW_BUFFER  (UART_0_FPC_UART_TX_BUFFER_SIZE >                                                                     UART_0_FPC_SPI_UART_FIFO_SIZE)
N
N        /* Internal UART RX and TX buffer */
N        #define UART_0_FPC_INTERNAL_RX_SW_BUFFER  (UART_0_FPC_INTERNAL_UART_RX_SW_BUFFER)
N        #define UART_0_FPC_INTERNAL_TX_SW_BUFFER  (UART_0_FPC_INTERNAL_UART_TX_SW_BUFFER)
N
N        /* Internal UART RX and TX buffer size */
N        #define UART_0_FPC_INTERNAL_RX_BUFFER_SIZE    (UART_0_FPC_UART_RX_BUFFER_SIZE + 1u)
N        #define UART_0_FPC_RX_BUFFER_SIZE             (UART_0_FPC_UART_RX_BUFFER_SIZE)
N        #define UART_0_FPC_TX_BUFFER_SIZE             (UART_0_FPC_UART_TX_BUFFER_SIZE)
N
N        /* Get wakeup enable option */
N        #define UART_0_FPC_SPI_WAKE_ENABLE_CONST  (0u)
N        #define UART_0_FPC_UART_WAKE_ENABLE_CONST (0u != UART_0_FPC_UART_WAKE_ENABLE)
N
N    #endif /* (UART_0_FPC_SCB_MODE_SPI_CONST_CFG) */
N
N    /* Mode */
N    #define UART_0_FPC_SPI_SLAVE_CONST    (UART_0_FPC_SPI_MODE == UART_0_FPC_SPI_SLAVE)
N    #define UART_0_FPC_SPI_MASTER_CONST   (UART_0_FPC_SPI_MODE == UART_0_FPC_SPI_MASTER)
N
N    /* Direction */
N    #define UART_0_FPC_RX_DIRECTION ((UART_0_FPC_SCB_MODE_SPI_CONST_CFG) ? \
N                                            (UART_0_FPC_SPI_RX_DIRECTION) : (UART_0_FPC_UART_RX_DIRECTION))
X    #define UART_0_FPC_RX_DIRECTION ((UART_0_FPC_SCB_MODE_SPI_CONST_CFG) ?                                             (UART_0_FPC_SPI_RX_DIRECTION) : (UART_0_FPC_UART_RX_DIRECTION))
N
N    #define UART_0_FPC_TX_DIRECTION ((UART_0_FPC_SCB_MODE_SPI_CONST_CFG) ? \
N                                            (UART_0_FPC_SPI_TX_DIRECTION) : (UART_0_FPC_UART_TX_DIRECTION))
X    #define UART_0_FPC_TX_DIRECTION ((UART_0_FPC_SCB_MODE_SPI_CONST_CFG) ?                                             (UART_0_FPC_SPI_TX_DIRECTION) : (UART_0_FPC_UART_TX_DIRECTION))
N
N    /* Internal RX and TX buffer: for SPI or UART. Used in conditional compilation check */
N    #define UART_0_FPC_CHECK_RX_SW_BUFFER (UART_0_FPC_INTERNAL_RX_SW_BUFFER)
N    #define UART_0_FPC_CHECK_TX_SW_BUFFER (UART_0_FPC_INTERNAL_TX_SW_BUFFER)
N
N    /* Provide global variables to support RX and TX buffers */
N    #define UART_0_FPC_INTERNAL_RX_SW_BUFFER_CONST    (UART_0_FPC_INTERNAL_RX_SW_BUFFER)
N    #define UART_0_FPC_INTERNAL_TX_SW_BUFFER_CONST    (UART_0_FPC_INTERNAL_TX_SW_BUFFER)
N
N    /* Wake up enable */
N    #define UART_0_FPC_CHECK_SPI_WAKE_ENABLE  (UART_0_FPC_SPI_WAKE_ENABLE_CONST)
N    #define UART_0_FPC_CHECK_UART_WAKE_ENABLE (UART_0_FPC_UART_WAKE_ENABLE_CONST)
N
N    /* UART flow control: not applicable for CY_SCBIP_V0 || CY_SCBIP_V1 */
N    #define UART_0_FPC_CHECK_UART_RTS_CONTROL_FLOW    (UART_0_FPC_SCB_MODE_UART_CONST_CFG && \
N                                                             UART_0_FPC_UART_RTS_ENABLE)
X    #define UART_0_FPC_CHECK_UART_RTS_CONTROL_FLOW    (UART_0_FPC_SCB_MODE_UART_CONST_CFG &&                                                              UART_0_FPC_UART_RTS_ENABLE)
N
N#endif /* End (UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N
N/***************************************
N*       Type Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N
N/* UART_0_FPC_SPI_INIT_STRUCT */
Ntypedef struct
N{
N    /** Mode of operation for SPI. The following defines are available choices:
N     *  - UART_0_FPC_SPI_SLAVE
N     *  - UART_0_FPC_SPI_MASTE
N    */
N    uint32 mode;
N
N    /** Submode of operation for SPI. The following defines are available
N     *  choices:
N     *  - UART_0_FPC_SPI_MODE_MOTOROLA
N     *  - UART_0_FPC_SPI_MODE_TI_COINCIDES
N     *  - UART_0_FPC_SPI_MODE_TI_PRECEDES
N     *  - UART_0_FPC_SPI_MODE_NATIONAL
N    */
N    uint32 submode;
N
N    /** Determines the sclk relationship for Motorola submode. Ignored
N     *  for other submodes. The following defines are available choices:
N     *  - UART_0_FPC_SPI_SCLK_CPHA0_CPOL0
N     *  - UART_0_FPC_SPI_SCLK_CPHA0_CPOL1
N     *  - UART_0_FPC_SPI_SCLK_CPHA1_CPOL0
N     *  - UART_0_FPC_SPI_SCLK_CPHA1_CPOL1
N    */
N    uint32 sclkMode;
N
N    /** Oversampling factor for the SPI clock. Ignored for Slave mode operation.
N    */
N    uint32 oversample;
N
N    /** Applies median filter on the input lines: 0  not applied, 1  applied.
N    */
N    uint32 enableMedianFilter;
N
N    /** Applies late sampling of MISO line: 0  not applied, 1  applied.
N     *  Ignored for slave mode.
N    */
N    uint32 enableLateSampling;
N
N    /** Enables wakeup from low power mode: 0  disable, 1  enable.
N     *  Ignored for master mode.
N    */
N    uint32 enableWake;
N
N    /** Number of data bits for RX direction.
N     *  Different dataBitsRx and dataBitsTx are only allowed for National
N     *  submode.
N    */
N    uint32 rxDataBits;
N
N    /** Number of data bits for TX direction.
N     *  Different dataBitsRx and dataBitsTx are only allowed for National
N     *  submode.
N    */
N    uint32 txDataBits;
N
N    /** Determines the bit ordering. The following defines are available
N     *  choices:
N     *  - UART_0_FPC_BITS_ORDER_LSB_FIRST
N     *  - UART_0_FPC_BITS_ORDER_MSB_FIRST
N    */
N    uint32 bitOrder;
N
N    /** Determines whether transfers are back to back or have SS disabled
N     *  between words. Ignored for slave mode. The following defines are
N     *  available choices:
N     *  - UART_0_FPC_SPI_TRANSFER_CONTINUOUS
N     *  - UART_0_FPC_SPI_TRANSFER_SEPARATED
N    */
N    uint32 transferSeperation;
N
N    /** Size of the RX buffer in bytes/words (depends on rxDataBits parameter).
N     *  A value equal to the RX FIFO depth implies the usage of buffering in
N     *  hardware. A value greater than the RX FIFO depth results in a software
N     *  buffer.
N     *  The UART_0_FPC_INTR _RX_NOT_EMPTY interrupt has to be enabled to
N     *  transfer data into the software buffer.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words for PSoC 4100 /
N     *    PSoC 4200 devices.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words or 16
N     *    bytes (Byte mode is enabled) for PSoC 4100 BLE / PSoC 4200 BLE /
N     *    PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *    PSoC Analog Coprocessor devices.
N    */
N    uint32 rxBufferSize;
N
N    /** Buffer space provided for a RX software buffer:
N     *  - A NULL pointer must be provided to use hardware buffering.
N     *  - A pointer to an allocated buffer must be provided to use software
N     *    buffering. The buffer size must equal (rxBufferSize + 1) in bytes if
N     *    dataBitsRx is less or equal to 8, otherwise (2 * (rxBufferSize + 1))
N     *    in bytes. The software RX buffer always keeps one element empty.
N     *    For correct operation the allocated RX buffer has to be one element
N     *    greater than maximum packet size expected to be received.
N    */
N    uint8* rxBuffer;
N
N    /** Size of the TX buffer in bytes/words(depends on txDataBits parameter).
N     *  A value equal to the TX FIFO depth implies the usage of buffering in
N     *  hardware. A value greater than the TX FIFO depth results in a software
N     *  buffer.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words for PSoC 4100 /
N     *    PSoC 4200 devices.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words or 16
N     *    bytes (Byte mode is enabled) for PSoC 4100 BLE / PSoC 4200 BLE /
N     *    PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *    PSoC Analog Coprocessor devices.
N    */
N    uint32 txBufferSize;
N
N    /** Buffer space provided for a TX software buffer:
N     *  - A NULL pointer must be provided to use hardware buffering.
N     *  - A pointer to an allocated buffer must be provided to use software
N     *    buffering. The buffer size must equal txBufferSize if dataBitsTx is
N     *    less or equal to 8, otherwise (2* txBufferSize).
N    */
N    uint8* txBuffer;
N
N    /** Enables component interrupt: 0  disable, 1  enable.
N     *  The interrupt has to be enabled if software buffer is used.
N    */
N    uint32 enableInterrupt;
N
N    /** Mask of enabled interrupt sources for the RX direction. This mask is
N     *  written regardless of the setting of the enable Interrupt field.
N     *  Multiple sources are enabled by providing a value that is the OR of
N     *  all of the following sources to enable:
N     *  - UART_0_FPC_INTR_RX_FIFO_LEVEL
N     *  - UART_0_FPC_INTR_RX_NOT_EMPTY
N     *  - UART_0_FPC_INTR_RX_FULL
N     *  - UART_0_FPC_INTR_RX_OVERFLOW
N     *  - UART_0_FPC_INTR_RX_UNDERFLOW
N     *  - UART_0_FPC_INTR_SLAVE_SPI_BUS_ERROR
N    */
N    uint32 rxInterruptMask;
N
N    /** FIFO level for an RX FIFO level interrupt. This value is written
N     *  regardless of whether the RX FIFO level interrupt source is enabled.
N    */
N    uint32 rxTriggerLevel;
N
N    /** Mask of enabled interrupt sources for the TX direction. This mask is
N     *  written regardless of the setting of the enable Interrupt field.
N     *  Multiple sources are enabled by providing a value that is the OR of
N     *  all of the following sources to enable:
N     *  - UART_0_FPC_INTR_TX_FIFO_LEVEL
N     *  - UART_0_FPC_INTR_TX_NOT_FULL
N     *  - UART_0_FPC_INTR_TX_EMPTY
N     *  - UART_0_FPC_INTR_TX_OVERFLOW
N     *  - UART_0_FPC_INTR_TX_UNDERFLOW
N     *  - UART_0_FPC_INTR_MASTER_SPI_DONE
N    */
N    uint32 txInterruptMask;
N
N    /** FIFO level for a TX FIFO level interrupt. This value is written
N     * regardless of whether the TX FIFO level interrupt source is enabled.
N    */
N    uint32 txTriggerLevel;
N
N    /** When enabled the TX and RX FIFO depth is doubled and equal to
N     *  16 bytes: 0  disable, 1  enable. This implies that number of
N     *  TX and RX data bits must be less than or equal to 8.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 enableByteMode;
N
N    /** Enables continuous SCLK generation by the SPI master: 0  disable,
N     *  1  enable.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 enableFreeRunSclk;
N
N    /** Active polarity of slave select lines 0-3. This is bit mask where bit
N     *  UART_0_FPC_SPI_SLAVE_SELECT0 corresponds to slave select 0
N     *  polarity, bit UART_0_FPC_SPI_SLAVE_SELECT1  slave select 1
N     *  polarity and so on. Polarity constants are:
N     *  - UART_0_FPC_SPI_SS_ACTIVE_LOW
N     *  - UART_0_FPC_SPI_SS_ACTIVE_HIGH
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 polaritySs;
N} UART_0_FPC_SPI_INIT_STRUCT;
N
N
N/* UART_0_FPC_UART_INIT_STRUCT */
Ntypedef struct
N{
N    /** Mode of operation for the UART. The following defines are available
N     *  choices:
N     *  - UART_0_FPC_UART_MODE_STD
N     *  - UART_0_FPC_UART_MODE_SMARTCARD
N     *  - UART_0_FPC_UART_MODE_IRDA
N    */
N    uint32 mode;
N
N    /** Direction of operation for the UART. The following defines are available
N     *  choices:
N     *  - UART_0_FPC_UART_TX_RX
N     *  - UART_0_FPC_UART_RX
N     *  - UART_0_FPC_UART_TX
N    */
N    uint32 direction;
N
N    /** Number of data bits.
N    */
N    uint32 dataBits;
N
N    /** Determines the parity. The following defines are available choices:
N     *  - UART_0_FPC_UART_PARITY_EVEN
N     *  - UART_0_FPC_UART_PARITY_ODD
N     *  - UART_0_FPC_UART_PARITY_NONE
N    */
N    uint32 parity;
N
N    /** Determines the number of stop bits. The following defines are available
N     *  choices:
N     *  - UART_0_FPC_UART_STOP_BITS_1
N     *  - UART_0_FPC_UART_STOP_BITS_1_5
N     *  - UART_0_FPC_UART_STOP_BITS_2
N    */
N    uint32 stopBits;
N
N    /** Oversampling factor for the UART.
N     *
N     *  Note The oversampling factor values are changed when enableIrdaLowPower
N     *  is enabled:
N     *  - UART_0_FPC_UART_IRDA_LP_OVS16
N     *  - UART_0_FPC_UART_IRDA_LP_OVS32
N     *  - UART_0_FPC_UART_IRDA_LP_OVS48
N     *  - UART_0_FPC_UART_IRDA_LP_OVS96
N     *  - UART_0_FPC_UART_IRDA_LP_OVS192
N     *  - UART_0_FPC_UART_IRDA_LP_OVS768
N     *  - UART_0_FPC_UART_IRDA_LP_OVS1536
N    */
N    uint32 oversample;
N
N    /** Enables IrDA low power RX mode operation: 0  disable, 1  enable.
N     *  The TX functionality does not work when enabled.
N    */
N    uint32 enableIrdaLowPower;
N
N    /** Applies median filter on the input lines:  0  not applied, 1  applied.
N    */
N    uint32 enableMedianFilter;
N
N    /** Enables retry when NACK response was received: 0  disable, 1  enable.
N     *  Only current content of TX FIFO is re-sent.
N     *  Ignored for modes other than SmartCard.
N    */
N    uint32 enableRetryNack;
N
N    /** Inverts polarity of RX line: 0  non-inverting, 1  inverting.
N     *  Ignored for modes other than IrDA.
N    */
N    uint32 enableInvertedRx;
N
N    /** Drop data from RX FIFO if parity error is detected: 0  disable,
N     *  1  enable.
N    */
N    uint32 dropOnParityErr;
N
N    /** Drop data from RX FIFO if a frame error is detected: 0  disable,
N     *  1  enable.
N    */
N    uint32 dropOnFrameErr;
N
N    /** Enables wakeup from low power mode: 0  disable, 1  enable.
N     *  Ignored for modes other than standard UART. The RX functionality
N     *  has to be enabled.
N    */
N    uint32 enableWake;
N
N    /** Size of the RX buffer in bytes/words (depends on rxDataBits parameter).
N     *  A value equal to the RX FIFO depth implies the usage of buffering in
N     *  hardware. A value greater than the RX FIFO depth results in a software
N     *  buffer.
N     *  The UART_0_FPC_INTR _RX_NOT_EMPTY interrupt has to be enabled to
N     *  transfer data into the software buffer.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words for PSoC 4100 /
N     *    PSoC 4200 devices.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words or 16
N     *    bytes (Byte mode is enabled) for PSoC 4100 BLE / PSoC 4200 BLE /
N     *    PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *    PSoC Analog Coprocessor devices.
N    */
N    uint32 rxBufferSize;
N
N    /** Buffer space provided for a RX software buffer:
N     *  - A NULL pointer must be provided to use hardware buffering.
N     *  - A pointer to an allocated buffer must be provided to use software
N     *    buffering. The buffer size must equal (rxBufferSize + 1) in bytes if
N     *    dataBitsRx is less or equal to 8, otherwise (2 * (rxBufferSize + 1))
N     *    in bytes. The software RX buffer always keeps one element empty.
N     *    For correct operation the allocated RX buffer has to be one element
N     *    greater than maximum packet size expected to be received.
N    */
N    uint8* rxBuffer;
N
N    /** Size of the TX buffer in bytes/words(depends on txDataBits parameter).
N     *  A value equal to the TX FIFO depth implies the usage of buffering in
N     *  hardware. A value greater than the TX FIFO depth results in a software
N     *  buffer.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words for PSoC 4100 /
N     *    PSoC 4200 devices.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words or 16
N     *    bytes (Byte mode is enabled) for PSoC 4100 BLE / PSoC 4200 BLE /
N     *    PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *    PSoC Analog Coprocessor devices.
N    */
N    uint32 txBufferSize;
N
N    /** Buffer space provided for a TX software buffer:
N     *  - A NULL pointer must be provided to use hardware buffering.
N     *  - A pointer to an allocated buffer must be provided to use software
N     *    buffering. The buffer size must equal txBufferSize if dataBitsTx is
N     *    less or equal to 8, otherwise (2* txBufferSize).
N    */
N    uint8* txBuffer;
N
N    /** Enables multiprocessor mode: 0  disable, 1  enable.
N    */
N    uint32 enableMultiproc;
N
N    /** Enables matched address to be accepted: 0  disable, 1  enable.
N    */
N    uint32 multiprocAcceptAddr;
N
N    /** 8 bit address to match in Multiprocessor mode. Ignored for other modes.
N    */
N    uint32 multiprocAddr;
N
N    /** 8 bit mask of address bits that are compared for a Multiprocessor
N     *  address match. Ignored for other modes.
N     *  - Bit value 0  excludes bit from address comparison.
N     *  - Bit value 1  the bit needs to match with the corresponding bit
N     *   of the device address.
N    */
N    uint32 multiprocAddrMask;
N
N    /** Enables component interrupt: 0  disable, 1  enable.
N     *  The interrupt has to be enabled if software buffer is used.
N    */
N    uint32 enableInterrupt;
N
N    /** Mask of interrupt sources to enable in the RX direction. This mask is
N     *  written regardless of the setting of the enableInterrupt field.
N     *  Multiple sources are enabled by providing a value that is the OR of
N     *  all of the following sources to enable:
N     *  - UART_0_FPC_INTR_RX_FIFO_LEVEL
N     *  - UART_0_FPC_INTR_RX_NOT_EMPTY
N     *  - UART_0_FPC_INTR_RX_FULL
N     *  - UART_0_FPC_INTR_RX_OVERFLOW
N     *  - UART_0_FPC_INTR_RX_UNDERFLOW
N     *  - UART_0_FPC_INTR_RX_FRAME_ERROR
N     *  - UART_0_FPC_INTR_RX_PARITY_ERROR
N    */
N    uint32 rxInterruptMask;
N
N    /** FIFO level for an RX FIFO level interrupt. This value is written
N     *  regardless of whether the RX FIFO level interrupt source is enabled.
N    */
N    uint32 rxTriggerLevel;
N
N    /** Mask of interrupt sources to enable in the TX direction. This mask is
N     *  written regardless of the setting of the enableInterrupt field.
N     *  Multiple sources are enabled by providing a value that is the OR of
N     *  all of the following sources to enable:
N     *  - UART_0_FPC_INTR_TX_FIFO_LEVEL
N     *  - UART_0_FPC_INTR_TX_NOT_FULL
N     *  - UART_0_FPC_INTR_TX_EMPTY
N     *  - UART_0_FPC_INTR_TX_OVERFLOW
N     *  - UART_0_FPC_INTR_TX_UNDERFLOW
N     *  - UART_0_FPC_INTR_TX_UART_DONE
N     *  - UART_0_FPC_INTR_TX_UART_NACK
N     *  - UART_0_FPC_INTR_TX_UART_ARB_LOST
N    */
N    uint32 txInterruptMask;
N
N    /** FIFO level for a TX FIFO level interrupt. This value is written
N     *  regardless of whether the TX FIFO level interrupt source is enabled.
N    */
N    uint32 txTriggerLevel;
N
N    /** When enabled the TX and RX FIFO depth is doubled and equal to
N     *  16 bytes: 0  disable, 1  enable. This implies that number of
N     *  Data bits must be less than or equal to 8.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 enableByteMode;
N
N    /** Enables usage of CTS input signal by the UART transmitter : 0  disable,
N     *  1  enable.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 enableCts;
N
N    /** Sets active polarity of CTS input signal:
N     *  - UART_0_FPC_UART_CTS_ACTIVE_LOW
N     *  - UART_0_FPC_UART_CTS_ACTIVE_HIGH
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 ctsPolarity;
N
N    /** RX FIFO level for RTS signal activation. While the RX FIFO has fewer
N     *  entries than the RTS FIFO level value the RTS signal remains active,
N     *  otherwise the RTS signal becomes inactive. By setting this field to 0,
N     *  RTS signal activation is disabled.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 rtsRxFifoLevel;
N
N    /** Sets active polarity of RTS output signal:
N     *  - UART_0_FPC_UART_RTS_ ACTIVE_LOW
N     *  - UART_0_FPC_UART_RTS_ACTIVE_HIGH
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 rtsPolarity;
N
N    /** Configures the width of a break signal in that triggers the break
N     *  detection interrupt source. A Break is a low level on the RX line.
N     *  Valid range is 1-16 UART bits times.
N    */
N    uint8 breakWidth;
N} UART_0_FPC_UART_INIT_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
N/**
N* \addtogroup group_spi
N* @{
N*/
N/* SPI specific functions */
N#if(UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    void UART_0_FPC_SpiInit(const UART_0_FPC_SPI_INIT_STRUCT *config);
N#endif /* (UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N
N#if(UART_0_FPC_SCB_MODE_SPI_INC)
X#if((0u !=((0x02u) & (4u))))
S    /*******************************************************************************
S    * Function Name: UART_0_FPC_SpiIsBusBusy
S    ****************************************************************************//**
S    *
S    *  Returns the current status on the bus. The bus status is determined using
S    *  the slave select signal.
S    *  - Motorola and National Semiconductor sub-modes: The bus is busy after
S    *    the slave select line is activated and lasts until the slave select line
S    *    is deactivated.
S    *  - Texas Instrument sub-modes: The bus is busy at the moment of the initial
S    *    pulse on the slave select line and lasts until the transfer is complete.
S    *    If SPI Master is configured to use "Separated transfers"
S    *    (see Continuous versus Separated Transfer Separation), the bus is busy
S    *    during each element transfer and is free between each element transfer.
S    *    The Master does not activate SS line immediately after data has been
S    *    written into the TX FIFO.
S    *
S    *  \return slaveSelect: Current status on the bus.
S    *   If the returned value is nonzero, the bus is busy.
S    *   If zero is returned, the bus is free. The bus status is determined using
S    *   the slave select signal.
S    *
S    *******************************************************************************/
S    #define UART_0_FPC_SpiIsBusBusy() ((uint32) (0u != (UART_0_FPC_SPI_STATUS_REG & \
S                                                              UART_0_FPC_SPI_STATUS_BUS_BUSY)))
X    #define UART_0_FPC_SpiIsBusBusy() ((uint32) (0u != (UART_0_FPC_SPI_STATUS_REG &                                                               UART_0_FPC_SPI_STATUS_BUS_BUSY)))
S
S    #if (UART_0_FPC_SPI_MASTER_CONST)
S        void UART_0_FPC_SpiSetActiveSlaveSelect(uint32 slaveSelect);
S    #endif /*(UART_0_FPC_SPI_MASTER_CONST) */
S
S    #if !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1)
S        void UART_0_FPC_SpiSetSlaveSelectPolarity(uint32 slaveSelect, uint32 polarity);
S    #endif /* !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1) */
N#endif /* (UART_0_FPC_SCB_MODE_SPI_INC) */
N/** @} spi */
N
N/**
N* \addtogroup group_uart
N* @{
N*/
N/* UART specific functions */
N#if(UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    void UART_0_FPC_UartInit(const UART_0_FPC_UART_INIT_STRUCT *config);
N#endif /* (UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N#if(UART_0_FPC_SCB_MODE_UART_INC)
X#if((0u !=((0x04u) & (4u))))
N    void UART_0_FPC_UartSetRxAddress(uint32 address);
N    void UART_0_FPC_UartSetRxAddressMask(uint32 addressMask);
N
N
N    /* UART RX direction APIs */
N    #if(UART_0_FPC_UART_RX_DIRECTION)
X    #if((0u != ((3u) & (1u))))
N        uint32 UART_0_FPC_UartGetChar(void);
N        uint32 UART_0_FPC_UartGetByte(void);
N
N        #if !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1)
X        #if !((2 == 0u) || (2 == 1u))
N            /* UART APIs for Flow Control */
N            void UART_0_FPC_UartSetRtsPolarity(uint32 polarity);
N            void UART_0_FPC_UartSetRtsFifoLevel(uint32 level);
N        #endif /* !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1) */
N    #endif /* (UART_0_FPC_UART_RX_DIRECTION) */
N
N    /* UART TX direction APIs */
N    #if(UART_0_FPC_UART_TX_DIRECTION)
X    #if((0u != ((3u) & (2u))))
N        /*******************************************************************************
N        * Function Name: UART_0_FPC_UartPutChar
N        ****************************************************************************//**
N        *
N        *  Places a byte of data in the transmit buffer to be sent at the next available
N        *  bus time. This function is blocking and waits until there is a space
N        *  available to put requested data in the transmit buffer.
N        *  For UART Multi Processor mode this function can send 9-bits data as well.
N        *  Use UART_0_FPC_UART_MP_MARK to add a mark to create an address byte.
N        *
N        *  \param txDataByte: the data to be transmitted.
N        *
N        *******************************************************************************/
N        #define UART_0_FPC_UartPutChar(ch)    UART_0_FPC_SpiUartWriteTxData((uint32)(ch))
N
N        void UART_0_FPC_UartPutString(const char8 string[]);
N        void UART_0_FPC_UartPutCRLF(uint32 txDataByte);
N        void UART_0_FPC_UartSendBreakBlocking(uint32 breakWidth);
N
N        #if !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1)
X        #if !((2 == 0u) || (2 == 1u))
N            /* UART APIs for Flow Control */
N            void UART_0_FPC_UartEnableCts(void);
N            void UART_0_FPC_UartDisableCts(void);
N            void UART_0_FPC_UartSetCtsPolarity(uint32 polarity);
N        #endif /* !(UART_0_FPC_CY_SCBIP_V0 || UART_0_FPC_CY_SCBIP_V1) */
N    #endif /* (UART_0_FPC_UART_TX_DIRECTION) */
N#endif /* (UART_0_FPC_SCB_MODE_UART_INC) */
N/** @} uart */
N
N/**
N* \addtogroup group_spi_uart
N* @{
N*/
N#if(UART_0_FPC_RX_DIRECTION)
X#if(((((0x02u) == (4u))) ? (UART_0_FPC_SPI_RX_DIRECTION) : ((0u != ((3u) & (1u))))))
N    uint32 UART_0_FPC_SpiUartReadRxData(void);
N    uint32 UART_0_FPC_SpiUartGetRxBufferSize(void);
N    void   UART_0_FPC_SpiUartClearRxBuffer(void);
N#endif /* (UART_0_FPC_RX_DIRECTION) */
N
N/* Common APIs TX direction */
N#if(UART_0_FPC_TX_DIRECTION)
X#if(((((0x02u) == (4u))) ? (UART_0_FPC_SPI_TX_DIRECTION) : ((0u != ((3u) & (2u))))))
N    void   UART_0_FPC_SpiUartWriteTxData(uint32 txData);
N    void   UART_0_FPC_SpiUartPutArray(const uint8 wrBuf[], uint32 count);
N    uint32 UART_0_FPC_SpiUartGetTxBufferSize(void);
N    void   UART_0_FPC_SpiUartClearTxBuffer(void);
N#endif /* (UART_0_FPC_TX_DIRECTION) */
N/** @} spi_uart */
N
NCY_ISR_PROTO(UART_0_FPC_SPI_UART_ISR);
Xvoid UART_0_FPC_SPI_UART_ISR (void);
N
N#if(UART_0_FPC_UART_RX_WAKEUP_IRQ)
X#if((0u == (1u)))
S    CY_ISR_PROTO(UART_0_FPC_UART_WAKEUP_ISR);
N#endif /* (UART_0_FPC_UART_RX_WAKEUP_IRQ) */
N
N
N/***************************************
N*     Buffer Access Macro Definitions
N***************************************/
N
N#if(UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    /* RX direction */
S    void   UART_0_FPC_PutWordInRxBuffer  (uint32 idx, uint32 rxDataByte);
S    uint32 UART_0_FPC_GetWordFromRxBuffer(uint32 idx);
S
S    /* TX direction */
S    void   UART_0_FPC_PutWordInTxBuffer  (uint32 idx, uint32 txDataByte);
S    uint32 UART_0_FPC_GetWordFromTxBuffer(uint32 idx);
S
N#else
N    /* RX direction */
N    #if(UART_0_FPC_INTERNAL_RX_SW_BUFFER_CONST)
X    #if(((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u)))))))
S        #define UART_0_FPC_PutWordInRxBuffer(idx, rxDataByte) \
S                do{                                                 \
S                    UART_0_FPC_rxBufferInternal[(idx)] = ((uint8) (rxDataByte)); \
S                }while(0)
X        #define UART_0_FPC_PutWordInRxBuffer(idx, rxDataByte)                 do{                                                                     UART_0_FPC_rxBufferInternal[(idx)] = ((uint8) (rxDataByte));                 }while(0)
S
S        #define UART_0_FPC_GetWordFromRxBuffer(idx) UART_0_FPC_rxBufferInternal[(idx)]
S
N    #endif /* (UART_0_FPC_INTERNAL_RX_SW_BUFFER_CONST) */
N
N    /* TX direction */
N    #if(UART_0_FPC_INTERNAL_TX_SW_BUFFER_CONST)
X    #if(((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u)))))))
S        #define UART_0_FPC_PutWordInTxBuffer(idx, txDataByte) \
S                    do{                                             \
S                        UART_0_FPC_txBufferInternal[(idx)] = ((uint8) (txDataByte)); \
S                    }while(0)
X        #define UART_0_FPC_PutWordInTxBuffer(idx, txDataByte)                     do{                                                                     UART_0_FPC_txBufferInternal[(idx)] = ((uint8) (txDataByte));                     }while(0)
S
S        #define UART_0_FPC_GetWordFromTxBuffer(idx) UART_0_FPC_txBufferInternal[(idx)]
S
N    #endif /* (UART_0_FPC_INTERNAL_TX_SW_BUFFER_CONST) */
N
N#endif /* (UART_0_FPC_TX_SW_BUFFER_ENABLE) */
N
N
N/***************************************
N*         SPI API Constants
N***************************************/
N
N/* SPI sub mode enum */
N#define UART_0_FPC_SPI_MODE_MOTOROLA      (0x00u)
N#define UART_0_FPC_SPI_MODE_TI_COINCIDES  (0x01u)
N#define UART_0_FPC_SPI_MODE_TI_PRECEDES   (0x11u)
N#define UART_0_FPC_SPI_MODE_NATIONAL      (0x02u)
N#define UART_0_FPC_SPI_MODE_MASK          (0x03u)
N#define UART_0_FPC_SPI_MODE_TI_PRECEDES_MASK  (0x10u)
N#define UART_0_FPC_SPI_MODE_NS_MICROWIRE  (UART_0_FPC_SPI_MODE_NATIONAL)
N
N/* SPI phase and polarity mode enum */
N#define UART_0_FPC_SPI_SCLK_CPHA0_CPOL0   (0x00u)
N#define UART_0_FPC_SPI_SCLK_CPHA0_CPOL1   (0x02u)
N#define UART_0_FPC_SPI_SCLK_CPHA1_CPOL0   (0x01u)
N#define UART_0_FPC_SPI_SCLK_CPHA1_CPOL1   (0x03u)
N
N/* SPI bits order enum */
N#define UART_0_FPC_BITS_ORDER_LSB_FIRST   (0u)
N#define UART_0_FPC_BITS_ORDER_MSB_FIRST   (1u)
N
N/* SPI transfer separation enum */
N#define UART_0_FPC_SPI_TRANSFER_SEPARATED     (0u)
N#define UART_0_FPC_SPI_TRANSFER_CONTINUOUS    (1u)
N
N/* SPI slave select constants */
N#define UART_0_FPC_SPI_SLAVE_SELECT0    (UART_0_FPC_SCB__SS0_POSISTION)
N#define UART_0_FPC_SPI_SLAVE_SELECT1    (UART_0_FPC_SCB__SS1_POSISTION)
N#define UART_0_FPC_SPI_SLAVE_SELECT2    (UART_0_FPC_SCB__SS2_POSISTION)
N#define UART_0_FPC_SPI_SLAVE_SELECT3    (UART_0_FPC_SCB__SS3_POSISTION)
N
N/* SPI slave select polarity settings */
N#define UART_0_FPC_SPI_SS_ACTIVE_LOW  (0u)
N#define UART_0_FPC_SPI_SS_ACTIVE_HIGH (1u)
N
N#define UART_0_FPC_INTR_SPIM_TX_RESTORE   (UART_0_FPC_INTR_TX_OVERFLOW)
N
N#define UART_0_FPC_INTR_SPIS_TX_RESTORE     (UART_0_FPC_INTR_TX_OVERFLOW | \
N                                                 UART_0_FPC_INTR_TX_UNDERFLOW)
X#define UART_0_FPC_INTR_SPIS_TX_RESTORE     (UART_0_FPC_INTR_TX_OVERFLOW |                                                  UART_0_FPC_INTR_TX_UNDERFLOW)
N
N/***************************************
N*         UART API Constants
N***************************************/
N
N/* UART sub-modes enum */
N#define UART_0_FPC_UART_MODE_STD          (0u)
N#define UART_0_FPC_UART_MODE_SMARTCARD    (1u)
N#define UART_0_FPC_UART_MODE_IRDA         (2u)
N
N/* UART direction enum */
N#define UART_0_FPC_UART_RX    (1u)
N#define UART_0_FPC_UART_TX    (2u)
N#define UART_0_FPC_UART_TX_RX (3u)
N
N/* UART parity enum */
N#define UART_0_FPC_UART_PARITY_EVEN   (0u)
N#define UART_0_FPC_UART_PARITY_ODD    (1u)
N#define UART_0_FPC_UART_PARITY_NONE   (2u)
N
N/* UART stop bits enum */
N#define UART_0_FPC_UART_STOP_BITS_1   (2u)
N#define UART_0_FPC_UART_STOP_BITS_1_5 (3u)
N#define UART_0_FPC_UART_STOP_BITS_2   (4u)
N
N/* UART IrDA low power OVS enum */
N#define UART_0_FPC_UART_IRDA_LP_OVS16     (16u)
N#define UART_0_FPC_UART_IRDA_LP_OVS32     (32u)
N#define UART_0_FPC_UART_IRDA_LP_OVS48     (48u)
N#define UART_0_FPC_UART_IRDA_LP_OVS96     (96u)
N#define UART_0_FPC_UART_IRDA_LP_OVS192    (192u)
N#define UART_0_FPC_UART_IRDA_LP_OVS768    (768u)
N#define UART_0_FPC_UART_IRDA_LP_OVS1536   (1536u)
N
N/* Uart MP: mark (address) and space (data) bit definitions */
N#define UART_0_FPC_UART_MP_MARK       (0x100u)
N#define UART_0_FPC_UART_MP_SPACE      (0x000u)
N
N/* UART CTS/RTS polarity settings */
N#define UART_0_FPC_UART_CTS_ACTIVE_LOW    (0u)
N#define UART_0_FPC_UART_CTS_ACTIVE_HIGH   (1u)
N#define UART_0_FPC_UART_RTS_ACTIVE_LOW    (0u)
N#define UART_0_FPC_UART_RTS_ACTIVE_HIGH   (1u)
N
N/* Sources of RX errors */
N#define UART_0_FPC_INTR_RX_ERR        (UART_0_FPC_INTR_RX_OVERFLOW    | \
N                                             UART_0_FPC_INTR_RX_UNDERFLOW   | \
N                                             UART_0_FPC_INTR_RX_FRAME_ERROR | \
N                                             UART_0_FPC_INTR_RX_PARITY_ERROR)
X#define UART_0_FPC_INTR_RX_ERR        (UART_0_FPC_INTR_RX_OVERFLOW    |                                              UART_0_FPC_INTR_RX_UNDERFLOW   |                                              UART_0_FPC_INTR_RX_FRAME_ERROR |                                              UART_0_FPC_INTR_RX_PARITY_ERROR)
N
N/* Shifted INTR_RX_ERR defines ONLY for UART_0_FPC_UartGetByte() */
N#define UART_0_FPC_UART_RX_OVERFLOW       (UART_0_FPC_INTR_RX_OVERFLOW << 8u)
N#define UART_0_FPC_UART_RX_UNDERFLOW      (UART_0_FPC_INTR_RX_UNDERFLOW << 8u)
N#define UART_0_FPC_UART_RX_FRAME_ERROR    (UART_0_FPC_INTR_RX_FRAME_ERROR << 8u)
N#define UART_0_FPC_UART_RX_PARITY_ERROR   (UART_0_FPC_INTR_RX_PARITY_ERROR << 8u)
N#define UART_0_FPC_UART_RX_ERROR_MASK     (UART_0_FPC_UART_RX_OVERFLOW    | \
N                                                 UART_0_FPC_UART_RX_UNDERFLOW   | \
N                                                 UART_0_FPC_UART_RX_FRAME_ERROR | \
N                                                 UART_0_FPC_UART_RX_PARITY_ERROR)
X#define UART_0_FPC_UART_RX_ERROR_MASK     (UART_0_FPC_UART_RX_OVERFLOW    |                                                  UART_0_FPC_UART_RX_UNDERFLOW   |                                                  UART_0_FPC_UART_RX_FRAME_ERROR |                                                  UART_0_FPC_UART_RX_PARITY_ERROR)
N
N#define UART_0_FPC_INTR_UART_TX_RESTORE   (UART_0_FPC_INTR_TX_OVERFLOW  | \
N                                                 UART_0_FPC_INTR_TX_UART_NACK | \
N                                                 UART_0_FPC_INTR_TX_UART_DONE | \
N                                                 UART_0_FPC_INTR_TX_UART_ARB_LOST)
X#define UART_0_FPC_INTR_UART_TX_RESTORE   (UART_0_FPC_INTR_TX_OVERFLOW  |                                                  UART_0_FPC_INTR_TX_UART_NACK |                                                  UART_0_FPC_INTR_TX_UART_DONE |                                                  UART_0_FPC_INTR_TX_UART_ARB_LOST)
N
N
N/***************************************
N*     Vars with External Linkage
N***************************************/
N
N#if(UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    extern const UART_0_FPC_SPI_INIT_STRUCT  UART_0_FPC_configSpi;
S    extern const UART_0_FPC_UART_INIT_STRUCT UART_0_FPC_configUart;
N#endif /* (UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N#if (UART_0_FPC_UART_WAKE_ENABLE_CONST && UART_0_FPC_UART_RX_WAKEUP_IRQ)
X#if ((0u != (0u)) && (0u == (1u)))
S    extern uint8 UART_0_FPC_skipStart;
N#endif /* (UART_0_FPC_UART_WAKE_ENABLE_CONST && UART_0_FPC_UART_RX_WAKEUP_IRQ) */
N
N
N/***************************************
N*    Specific SPI Macro Definitions
N***************************************/
N
N#define UART_0_FPC_GET_SPI_INTR_SLAVE_MASK(sourceMask)  ((sourceMask) & UART_0_FPC_INTR_SLAVE_SPI_BUS_ERROR)
N#define UART_0_FPC_GET_SPI_INTR_MASTER_MASK(sourceMask) ((sourceMask) & UART_0_FPC_INTR_MASTER_SPI_DONE)
N#define UART_0_FPC_GET_SPI_INTR_RX_MASK(sourceMask) \
N                                             ((sourceMask) & (uint32) ~UART_0_FPC_INTR_SLAVE_SPI_BUS_ERROR)
X#define UART_0_FPC_GET_SPI_INTR_RX_MASK(sourceMask)                                              ((sourceMask) & (uint32) ~UART_0_FPC_INTR_SLAVE_SPI_BUS_ERROR)
N
N#define UART_0_FPC_GET_SPI_INTR_TX_MASK(sourceMask) \
N                                             ((sourceMask) & (uint32) ~UART_0_FPC_INTR_MASTER_SPI_DONE)
X#define UART_0_FPC_GET_SPI_INTR_TX_MASK(sourceMask)                                              ((sourceMask) & (uint32) ~UART_0_FPC_INTR_MASTER_SPI_DONE)
N
N
N/***************************************
N*    Specific UART Macro Definitions
N***************************************/
N
N#define UART_0_FPC_UART_GET_CTRL_OVS_IRDA_LP(oversample) \
N        ((UART_0_FPC_UART_IRDA_LP_OVS16   == (oversample)) ? UART_0_FPC_CTRL_OVS_IRDA_LP_OVS16 : \
N         ((UART_0_FPC_UART_IRDA_LP_OVS32   == (oversample)) ? UART_0_FPC_CTRL_OVS_IRDA_LP_OVS32 : \
N          ((UART_0_FPC_UART_IRDA_LP_OVS48   == (oversample)) ? UART_0_FPC_CTRL_OVS_IRDA_LP_OVS48 : \
N           ((UART_0_FPC_UART_IRDA_LP_OVS96   == (oversample)) ? UART_0_FPC_CTRL_OVS_IRDA_LP_OVS96 : \
N            ((UART_0_FPC_UART_IRDA_LP_OVS192  == (oversample)) ? UART_0_FPC_CTRL_OVS_IRDA_LP_OVS192 : \
N             ((UART_0_FPC_UART_IRDA_LP_OVS768  == (oversample)) ? UART_0_FPC_CTRL_OVS_IRDA_LP_OVS768 : \
N              ((UART_0_FPC_UART_IRDA_LP_OVS1536 == (oversample)) ? UART_0_FPC_CTRL_OVS_IRDA_LP_OVS1536 : \
N                                                                          UART_0_FPC_CTRL_OVS_IRDA_LP_OVS16)))))))
X#define UART_0_FPC_UART_GET_CTRL_OVS_IRDA_LP(oversample)         ((UART_0_FPC_UART_IRDA_LP_OVS16   == (oversample)) ? UART_0_FPC_CTRL_OVS_IRDA_LP_OVS16 :          ((UART_0_FPC_UART_IRDA_LP_OVS32   == (oversample)) ? UART_0_FPC_CTRL_OVS_IRDA_LP_OVS32 :           ((UART_0_FPC_UART_IRDA_LP_OVS48   == (oversample)) ? UART_0_FPC_CTRL_OVS_IRDA_LP_OVS48 :            ((UART_0_FPC_UART_IRDA_LP_OVS96   == (oversample)) ? UART_0_FPC_CTRL_OVS_IRDA_LP_OVS96 :             ((UART_0_FPC_UART_IRDA_LP_OVS192  == (oversample)) ? UART_0_FPC_CTRL_OVS_IRDA_LP_OVS192 :              ((UART_0_FPC_UART_IRDA_LP_OVS768  == (oversample)) ? UART_0_FPC_CTRL_OVS_IRDA_LP_OVS768 :               ((UART_0_FPC_UART_IRDA_LP_OVS1536 == (oversample)) ? UART_0_FPC_CTRL_OVS_IRDA_LP_OVS1536 :                                                                           UART_0_FPC_CTRL_OVS_IRDA_LP_OVS16)))))))
N
N#define UART_0_FPC_GET_UART_RX_CTRL_ENABLED(direction) ((0u != (UART_0_FPC_UART_RX & (direction))) ? \
N                                                                     (UART_0_FPC_RX_CTRL_ENABLED) : (0u))
X#define UART_0_FPC_GET_UART_RX_CTRL_ENABLED(direction) ((0u != (UART_0_FPC_UART_RX & (direction))) ?                                                                      (UART_0_FPC_RX_CTRL_ENABLED) : (0u))
N
N#define UART_0_FPC_GET_UART_TX_CTRL_ENABLED(direction) ((0u != (UART_0_FPC_UART_TX & (direction))) ? \
N                                                                     (UART_0_FPC_TX_CTRL_ENABLED) : (0u))
X#define UART_0_FPC_GET_UART_TX_CTRL_ENABLED(direction) ((0u != (UART_0_FPC_UART_TX & (direction))) ?                                                                      (UART_0_FPC_TX_CTRL_ENABLED) : (0u))
N
N
N/***************************************
N*        SPI Register Settings
N***************************************/
N
N#define UART_0_FPC_CTRL_SPI      (UART_0_FPC_CTRL_MODE_SPI)
N#define UART_0_FPC_SPI_RX_CTRL   (UART_0_FPC_RX_CTRL_ENABLED)
N#define UART_0_FPC_SPI_TX_CTRL   (UART_0_FPC_TX_CTRL_ENABLED)
N
N
N/***************************************
N*       SPI Init Register Settings
N***************************************/
N
N#define UART_0_FPC_SPI_SS_POLARITY \
N             (((uint32) UART_0_FPC_SPI_SS0_POLARITY << UART_0_FPC_SPI_SLAVE_SELECT0) | \
N              ((uint32) UART_0_FPC_SPI_SS1_POLARITY << UART_0_FPC_SPI_SLAVE_SELECT1) | \
N              ((uint32) UART_0_FPC_SPI_SS2_POLARITY << UART_0_FPC_SPI_SLAVE_SELECT2) | \
N              ((uint32) UART_0_FPC_SPI_SS3_POLARITY << UART_0_FPC_SPI_SLAVE_SELECT3))
X#define UART_0_FPC_SPI_SS_POLARITY              (((uint32) UART_0_FPC_SPI_SS0_POLARITY << UART_0_FPC_SPI_SLAVE_SELECT0) |               ((uint32) UART_0_FPC_SPI_SS1_POLARITY << UART_0_FPC_SPI_SLAVE_SELECT1) |               ((uint32) UART_0_FPC_SPI_SS2_POLARITY << UART_0_FPC_SPI_SLAVE_SELECT2) |               ((uint32) UART_0_FPC_SPI_SS3_POLARITY << UART_0_FPC_SPI_SLAVE_SELECT3))
N
N#if(UART_0_FPC_SCB_MODE_SPI_CONST_CFG)
X#if(((0x02u) == (4u)))
S
S    /* SPI Configuration */
S    #define UART_0_FPC_SPI_DEFAULT_CTRL \
S                    (UART_0_FPC_GET_CTRL_OVS(UART_0_FPC_SPI_OVS_FACTOR) | \
S                     UART_0_FPC_GET_CTRL_BYTE_MODE (UART_0_FPC_SPI_BYTE_MODE_ENABLE) | \
S                     UART_0_FPC_GET_CTRL_EC_AM_MODE(UART_0_FPC_SPI_WAKE_ENABLE)      | \
S                     UART_0_FPC_CTRL_SPI)
X    #define UART_0_FPC_SPI_DEFAULT_CTRL                     (UART_0_FPC_GET_CTRL_OVS(UART_0_FPC_SPI_OVS_FACTOR) |                      UART_0_FPC_GET_CTRL_BYTE_MODE (UART_0_FPC_SPI_BYTE_MODE_ENABLE) |                      UART_0_FPC_GET_CTRL_EC_AM_MODE(UART_0_FPC_SPI_WAKE_ENABLE)      |                      UART_0_FPC_CTRL_SPI)
S
S    #define UART_0_FPC_SPI_DEFAULT_SPI_CTRL \
S                    (UART_0_FPC_GET_SPI_CTRL_CONTINUOUS    (UART_0_FPC_SPI_TRANSFER_SEPARATION)       | \
S                     UART_0_FPC_GET_SPI_CTRL_SELECT_PRECEDE(UART_0_FPC_SPI_SUB_MODE &                   \
S                                                                  UART_0_FPC_SPI_MODE_TI_PRECEDES_MASK)     | \
S                     UART_0_FPC_GET_SPI_CTRL_SCLK_MODE     (UART_0_FPC_SPI_CLOCK_MODE)                | \
S                     UART_0_FPC_GET_SPI_CTRL_LATE_MISO_SAMPLE(UART_0_FPC_SPI_LATE_MISO_SAMPLE_ENABLE) | \
S                     UART_0_FPC_GET_SPI_CTRL_SCLK_CONTINUOUS(UART_0_FPC_SPI_FREE_RUN_SCLK_ENABLE)     | \
S                     UART_0_FPC_GET_SPI_CTRL_SSEL_POLARITY (UART_0_FPC_SPI_SS_POLARITY)               | \
S                     UART_0_FPC_GET_SPI_CTRL_SUB_MODE      (UART_0_FPC_SPI_SUB_MODE)                  | \
S                     UART_0_FPC_GET_SPI_CTRL_MASTER_MODE   (UART_0_FPC_SPI_MODE))
X    #define UART_0_FPC_SPI_DEFAULT_SPI_CTRL                     (UART_0_FPC_GET_SPI_CTRL_CONTINUOUS    (UART_0_FPC_SPI_TRANSFER_SEPARATION)       |                      UART_0_FPC_GET_SPI_CTRL_SELECT_PRECEDE(UART_0_FPC_SPI_SUB_MODE &                                                                                     UART_0_FPC_SPI_MODE_TI_PRECEDES_MASK)     |                      UART_0_FPC_GET_SPI_CTRL_SCLK_MODE     (UART_0_FPC_SPI_CLOCK_MODE)                |                      UART_0_FPC_GET_SPI_CTRL_LATE_MISO_SAMPLE(UART_0_FPC_SPI_LATE_MISO_SAMPLE_ENABLE) |                      UART_0_FPC_GET_SPI_CTRL_SCLK_CONTINUOUS(UART_0_FPC_SPI_FREE_RUN_SCLK_ENABLE)     |                      UART_0_FPC_GET_SPI_CTRL_SSEL_POLARITY (UART_0_FPC_SPI_SS_POLARITY)               |                      UART_0_FPC_GET_SPI_CTRL_SUB_MODE      (UART_0_FPC_SPI_SUB_MODE)                  |                      UART_0_FPC_GET_SPI_CTRL_MASTER_MODE   (UART_0_FPC_SPI_MODE))
S
S    /* RX direction */
S    #define UART_0_FPC_SPI_DEFAULT_RX_CTRL \
S                    (UART_0_FPC_GET_RX_CTRL_DATA_WIDTH(UART_0_FPC_SPI_RX_DATA_BITS_NUM)     | \
S                     UART_0_FPC_GET_RX_CTRL_BIT_ORDER (UART_0_FPC_SPI_BITS_ORDER)           | \
S                     UART_0_FPC_GET_RX_CTRL_MEDIAN    (UART_0_FPC_SPI_MEDIAN_FILTER_ENABLE) | \
S                     UART_0_FPC_SPI_RX_CTRL)
X    #define UART_0_FPC_SPI_DEFAULT_RX_CTRL                     (UART_0_FPC_GET_RX_CTRL_DATA_WIDTH(UART_0_FPC_SPI_RX_DATA_BITS_NUM)     |                      UART_0_FPC_GET_RX_CTRL_BIT_ORDER (UART_0_FPC_SPI_BITS_ORDER)           |                      UART_0_FPC_GET_RX_CTRL_MEDIAN    (UART_0_FPC_SPI_MEDIAN_FILTER_ENABLE) |                      UART_0_FPC_SPI_RX_CTRL)
S
S    #define UART_0_FPC_SPI_DEFAULT_RX_FIFO_CTRL \
S                    UART_0_FPC_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(UART_0_FPC_SPI_RX_TRIGGER_LEVEL)
X    #define UART_0_FPC_SPI_DEFAULT_RX_FIFO_CTRL                     UART_0_FPC_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(UART_0_FPC_SPI_RX_TRIGGER_LEVEL)
S
S    /* TX direction */
S    #define UART_0_FPC_SPI_DEFAULT_TX_CTRL \
S                    (UART_0_FPC_GET_TX_CTRL_DATA_WIDTH(UART_0_FPC_SPI_TX_DATA_BITS_NUM) | \
S                     UART_0_FPC_GET_TX_CTRL_BIT_ORDER (UART_0_FPC_SPI_BITS_ORDER)       | \
S                     UART_0_FPC_SPI_TX_CTRL)
X    #define UART_0_FPC_SPI_DEFAULT_TX_CTRL                     (UART_0_FPC_GET_TX_CTRL_DATA_WIDTH(UART_0_FPC_SPI_TX_DATA_BITS_NUM) |                      UART_0_FPC_GET_TX_CTRL_BIT_ORDER (UART_0_FPC_SPI_BITS_ORDER)       |                      UART_0_FPC_SPI_TX_CTRL)
S
S    #define UART_0_FPC_SPI_DEFAULT_TX_FIFO_CTRL \
S                    UART_0_FPC_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(UART_0_FPC_SPI_TX_TRIGGER_LEVEL)
X    #define UART_0_FPC_SPI_DEFAULT_TX_FIFO_CTRL                     UART_0_FPC_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(UART_0_FPC_SPI_TX_TRIGGER_LEVEL)
S
S    /* Interrupt sources */
S    #define UART_0_FPC_SPI_DEFAULT_INTR_SPI_EC_MASK   (UART_0_FPC_NO_INTR_SOURCES)
S
S    #define UART_0_FPC_SPI_DEFAULT_INTR_I2C_EC_MASK   (UART_0_FPC_NO_INTR_SOURCES)
S    #define UART_0_FPC_SPI_DEFAULT_INTR_SLAVE_MASK \
S                    (UART_0_FPC_SPI_INTR_RX_MASK & UART_0_FPC_INTR_SLAVE_SPI_BUS_ERROR)
X    #define UART_0_FPC_SPI_DEFAULT_INTR_SLAVE_MASK                     (UART_0_FPC_SPI_INTR_RX_MASK & UART_0_FPC_INTR_SLAVE_SPI_BUS_ERROR)
S
S    #define UART_0_FPC_SPI_DEFAULT_INTR_MASTER_MASK \
S                    (UART_0_FPC_SPI_INTR_TX_MASK & UART_0_FPC_INTR_MASTER_SPI_DONE)
X    #define UART_0_FPC_SPI_DEFAULT_INTR_MASTER_MASK                     (UART_0_FPC_SPI_INTR_TX_MASK & UART_0_FPC_INTR_MASTER_SPI_DONE)
S
S    #define UART_0_FPC_SPI_DEFAULT_INTR_RX_MASK \
S                    (UART_0_FPC_SPI_INTR_RX_MASK & (uint32) ~UART_0_FPC_INTR_SLAVE_SPI_BUS_ERROR)
X    #define UART_0_FPC_SPI_DEFAULT_INTR_RX_MASK                     (UART_0_FPC_SPI_INTR_RX_MASK & (uint32) ~UART_0_FPC_INTR_SLAVE_SPI_BUS_ERROR)
S
S    #define UART_0_FPC_SPI_DEFAULT_INTR_TX_MASK \
S                    (UART_0_FPC_SPI_INTR_TX_MASK & (uint32) ~UART_0_FPC_INTR_MASTER_SPI_DONE)
X    #define UART_0_FPC_SPI_DEFAULT_INTR_TX_MASK                     (UART_0_FPC_SPI_INTR_TX_MASK & (uint32) ~UART_0_FPC_INTR_MASTER_SPI_DONE)
S
N#endif /* (UART_0_FPC_SCB_MODE_SPI_CONST_CFG) */
N
N
N/***************************************
N*        UART Register Settings
N***************************************/
N
N#define UART_0_FPC_CTRL_UART      (UART_0_FPC_CTRL_MODE_UART)
N#define UART_0_FPC_UART_RX_CTRL   (UART_0_FPC_RX_CTRL_LSB_FIRST) /* LSB for UART goes first */
N#define UART_0_FPC_UART_TX_CTRL   (UART_0_FPC_TX_CTRL_LSB_FIRST) /* LSB for UART goes first */
N
N
N/***************************************
N*      UART Init Register Settings
N***************************************/
N
N#if(UART_0_FPC_SCB_MODE_UART_CONST_CFG)
X#if(((0x04u) == (4u)))
N
N    /* UART configuration */
N    #if(UART_0_FPC_UART_MODE_IRDA == UART_0_FPC_UART_SUB_MODE)
X    #if((2u) == (0u))
S
S        #define UART_0_FPC_DEFAULT_CTRL_OVS   ((0u != UART_0_FPC_UART_IRDA_LOW_POWER) ?              \
S                                (UART_0_FPC_UART_GET_CTRL_OVS_IRDA_LP(UART_0_FPC_UART_OVS_FACTOR)) : \
S                                (UART_0_FPC_CTRL_OVS_IRDA_OVS16))
X        #define UART_0_FPC_DEFAULT_CTRL_OVS   ((0u != UART_0_FPC_UART_IRDA_LOW_POWER) ?                                              (UART_0_FPC_UART_GET_CTRL_OVS_IRDA_LP(UART_0_FPC_UART_OVS_FACTOR)) :                                 (UART_0_FPC_CTRL_OVS_IRDA_OVS16))
S
N    #else
N
N        #define UART_0_FPC_DEFAULT_CTRL_OVS   UART_0_FPC_GET_CTRL_OVS(UART_0_FPC_UART_OVS_FACTOR)
N
N    #endif /* (UART_0_FPC_UART_MODE_IRDA == UART_0_FPC_UART_SUB_MODE) */
N
N    #define UART_0_FPC_UART_DEFAULT_CTRL \
N                                (UART_0_FPC_GET_CTRL_BYTE_MODE  (UART_0_FPC_UART_BYTE_MODE_ENABLE)  | \
N                                 UART_0_FPC_GET_CTRL_ADDR_ACCEPT(UART_0_FPC_UART_MP_ACCEPT_ADDRESS) | \
N                                 UART_0_FPC_DEFAULT_CTRL_OVS                                              | \
N                                 UART_0_FPC_CTRL_UART)
X    #define UART_0_FPC_UART_DEFAULT_CTRL                                 (UART_0_FPC_GET_CTRL_BYTE_MODE  (UART_0_FPC_UART_BYTE_MODE_ENABLE)  |                                  UART_0_FPC_GET_CTRL_ADDR_ACCEPT(UART_0_FPC_UART_MP_ACCEPT_ADDRESS) |                                  UART_0_FPC_DEFAULT_CTRL_OVS                                              |                                  UART_0_FPC_CTRL_UART)
N
N    #define UART_0_FPC_UART_DEFAULT_UART_CTRL \
N                                    (UART_0_FPC_GET_UART_CTRL_MODE(UART_0_FPC_UART_SUB_MODE))
X    #define UART_0_FPC_UART_DEFAULT_UART_CTRL                                     (UART_0_FPC_GET_UART_CTRL_MODE(UART_0_FPC_UART_SUB_MODE))
N
N    /* RX direction */
N    #define UART_0_FPC_UART_DEFAULT_RX_CTRL_PARITY \
N                                ((UART_0_FPC_UART_PARITY_NONE != UART_0_FPC_UART_PARITY_TYPE) ?      \
N                                  (UART_0_FPC_GET_UART_RX_CTRL_PARITY(UART_0_FPC_UART_PARITY_TYPE) | \
N                                   UART_0_FPC_UART_RX_CTRL_PARITY_ENABLED) : (0u))
X    #define UART_0_FPC_UART_DEFAULT_RX_CTRL_PARITY                                 ((UART_0_FPC_UART_PARITY_NONE != UART_0_FPC_UART_PARITY_TYPE) ?                                        (UART_0_FPC_GET_UART_RX_CTRL_PARITY(UART_0_FPC_UART_PARITY_TYPE) |                                    UART_0_FPC_UART_RX_CTRL_PARITY_ENABLED) : (0u))
N
N    #define UART_0_FPC_UART_DEFAULT_UART_RX_CTRL \
N                    (UART_0_FPC_GET_UART_RX_CTRL_MODE(UART_0_FPC_UART_STOP_BITS_NUM)                    | \
N                     UART_0_FPC_GET_UART_RX_CTRL_POLARITY(UART_0_FPC_UART_IRDA_POLARITY)                | \
N                     UART_0_FPC_GET_UART_RX_CTRL_MP_MODE(UART_0_FPC_UART_MP_MODE_ENABLE)                | \
N                     UART_0_FPC_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(UART_0_FPC_UART_DROP_ON_PARITY_ERR) | \
N                     UART_0_FPC_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(UART_0_FPC_UART_DROP_ON_FRAME_ERR)   | \
N                     UART_0_FPC_GET_UART_RX_CTRL_BREAK_WIDTH(UART_0_FPC_UART_RX_BREAK_WIDTH)            | \
N                     UART_0_FPC_UART_DEFAULT_RX_CTRL_PARITY)
X    #define UART_0_FPC_UART_DEFAULT_UART_RX_CTRL                     (UART_0_FPC_GET_UART_RX_CTRL_MODE(UART_0_FPC_UART_STOP_BITS_NUM)                    |                      UART_0_FPC_GET_UART_RX_CTRL_POLARITY(UART_0_FPC_UART_IRDA_POLARITY)                |                      UART_0_FPC_GET_UART_RX_CTRL_MP_MODE(UART_0_FPC_UART_MP_MODE_ENABLE)                |                      UART_0_FPC_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(UART_0_FPC_UART_DROP_ON_PARITY_ERR) |                      UART_0_FPC_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(UART_0_FPC_UART_DROP_ON_FRAME_ERR)   |                      UART_0_FPC_GET_UART_RX_CTRL_BREAK_WIDTH(UART_0_FPC_UART_RX_BREAK_WIDTH)            |                      UART_0_FPC_UART_DEFAULT_RX_CTRL_PARITY)
N
N
N    #define UART_0_FPC_UART_DEFAULT_RX_CTRL \
N                                (UART_0_FPC_GET_RX_CTRL_DATA_WIDTH(UART_0_FPC_UART_DATA_BITS_NUM)        | \
N                                 UART_0_FPC_GET_RX_CTRL_MEDIAN    (UART_0_FPC_UART_MEDIAN_FILTER_ENABLE) | \
N                                 UART_0_FPC_GET_UART_RX_CTRL_ENABLED(UART_0_FPC_UART_DIRECTION))
X    #define UART_0_FPC_UART_DEFAULT_RX_CTRL                                 (UART_0_FPC_GET_RX_CTRL_DATA_WIDTH(UART_0_FPC_UART_DATA_BITS_NUM)        |                                  UART_0_FPC_GET_RX_CTRL_MEDIAN    (UART_0_FPC_UART_MEDIAN_FILTER_ENABLE) |                                  UART_0_FPC_GET_UART_RX_CTRL_ENABLED(UART_0_FPC_UART_DIRECTION))
N
N    #define UART_0_FPC_UART_DEFAULT_RX_FIFO_CTRL \
N                                UART_0_FPC_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(UART_0_FPC_UART_RX_TRIGGER_LEVEL)
X    #define UART_0_FPC_UART_DEFAULT_RX_FIFO_CTRL                                 UART_0_FPC_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(UART_0_FPC_UART_RX_TRIGGER_LEVEL)
N
N    #define UART_0_FPC_UART_DEFAULT_RX_MATCH_REG  ((0u != UART_0_FPC_UART_MP_MODE_ENABLE) ?          \
N                                (UART_0_FPC_GET_RX_MATCH_ADDR(UART_0_FPC_UART_MP_RX_ADDRESS) | \
N                                 UART_0_FPC_GET_RX_MATCH_MASK(UART_0_FPC_UART_MP_RX_ADDRESS_MASK)) : (0u))
X    #define UART_0_FPC_UART_DEFAULT_RX_MATCH_REG  ((0u != UART_0_FPC_UART_MP_MODE_ENABLE) ?                                          (UART_0_FPC_GET_RX_MATCH_ADDR(UART_0_FPC_UART_MP_RX_ADDRESS) |                                  UART_0_FPC_GET_RX_MATCH_MASK(UART_0_FPC_UART_MP_RX_ADDRESS_MASK)) : (0u))
N
N    /* TX direction */
N    #define UART_0_FPC_UART_DEFAULT_TX_CTRL_PARITY (UART_0_FPC_UART_DEFAULT_RX_CTRL_PARITY)
N
N    #define UART_0_FPC_UART_DEFAULT_UART_TX_CTRL \
N                                (UART_0_FPC_GET_UART_TX_CTRL_MODE(UART_0_FPC_UART_STOP_BITS_NUM)       | \
N                                 UART_0_FPC_GET_UART_TX_CTRL_RETRY_NACK(UART_0_FPC_UART_RETRY_ON_NACK) | \
N                                 UART_0_FPC_UART_DEFAULT_TX_CTRL_PARITY)
X    #define UART_0_FPC_UART_DEFAULT_UART_TX_CTRL                                 (UART_0_FPC_GET_UART_TX_CTRL_MODE(UART_0_FPC_UART_STOP_BITS_NUM)       |                                  UART_0_FPC_GET_UART_TX_CTRL_RETRY_NACK(UART_0_FPC_UART_RETRY_ON_NACK) |                                  UART_0_FPC_UART_DEFAULT_TX_CTRL_PARITY)
N
N    #define UART_0_FPC_UART_DEFAULT_TX_CTRL \
N                                (UART_0_FPC_GET_TX_CTRL_DATA_WIDTH(UART_0_FPC_UART_DATA_BITS_NUM) | \
N                                 UART_0_FPC_GET_UART_TX_CTRL_ENABLED(UART_0_FPC_UART_DIRECTION))
X    #define UART_0_FPC_UART_DEFAULT_TX_CTRL                                 (UART_0_FPC_GET_TX_CTRL_DATA_WIDTH(UART_0_FPC_UART_DATA_BITS_NUM) |                                  UART_0_FPC_GET_UART_TX_CTRL_ENABLED(UART_0_FPC_UART_DIRECTION))
N
N    #define UART_0_FPC_UART_DEFAULT_TX_FIFO_CTRL \
N                                UART_0_FPC_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(UART_0_FPC_UART_TX_TRIGGER_LEVEL)
X    #define UART_0_FPC_UART_DEFAULT_TX_FIFO_CTRL                                 UART_0_FPC_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(UART_0_FPC_UART_TX_TRIGGER_LEVEL)
N
N    #define UART_0_FPC_UART_DEFAULT_FLOW_CTRL \
N                        (UART_0_FPC_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(UART_0_FPC_UART_RTS_FIFO_LEVEL) | \
N                         UART_0_FPC_GET_UART_FLOW_CTRL_RTS_POLARITY (UART_0_FPC_UART_RTS_POLARITY)   | \
N                         UART_0_FPC_GET_UART_FLOW_CTRL_CTS_POLARITY (UART_0_FPC_UART_CTS_POLARITY)   | \
N                         UART_0_FPC_GET_UART_FLOW_CTRL_CTS_ENABLE   (UART_0_FPC_UART_CTS_ENABLE))
X    #define UART_0_FPC_UART_DEFAULT_FLOW_CTRL                         (UART_0_FPC_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(UART_0_FPC_UART_RTS_FIFO_LEVEL) |                          UART_0_FPC_GET_UART_FLOW_CTRL_RTS_POLARITY (UART_0_FPC_UART_RTS_POLARITY)   |                          UART_0_FPC_GET_UART_FLOW_CTRL_CTS_POLARITY (UART_0_FPC_UART_CTS_POLARITY)   |                          UART_0_FPC_GET_UART_FLOW_CTRL_CTS_ENABLE   (UART_0_FPC_UART_CTS_ENABLE))
N
N    /* Interrupt sources */
N    #define UART_0_FPC_UART_DEFAULT_INTR_I2C_EC_MASK  (UART_0_FPC_NO_INTR_SOURCES)
N    #define UART_0_FPC_UART_DEFAULT_INTR_SPI_EC_MASK  (UART_0_FPC_NO_INTR_SOURCES)
N    #define UART_0_FPC_UART_DEFAULT_INTR_SLAVE_MASK   (UART_0_FPC_NO_INTR_SOURCES)
N    #define UART_0_FPC_UART_DEFAULT_INTR_MASTER_MASK  (UART_0_FPC_NO_INTR_SOURCES)
N    #define UART_0_FPC_UART_DEFAULT_INTR_RX_MASK      (UART_0_FPC_UART_INTR_RX_MASK)
N    #define UART_0_FPC_UART_DEFAULT_INTR_TX_MASK      (UART_0_FPC_UART_INTR_TX_MASK)
N
N#endif /* (UART_0_FPC_SCB_MODE_UART_CONST_CFG) */
N
N
N/***************************************
N* The following code is DEPRECATED and
N* must not be used.
N***************************************/
N
N#define UART_0_FPC_SPIM_ACTIVE_SS0    (UART_0_FPC_SPI_SLAVE_SELECT0)
N#define UART_0_FPC_SPIM_ACTIVE_SS1    (UART_0_FPC_SPI_SLAVE_SELECT1)
N#define UART_0_FPC_SPIM_ACTIVE_SS2    (UART_0_FPC_SPI_SLAVE_SELECT2)
N#define UART_0_FPC_SPIM_ACTIVE_SS3    (UART_0_FPC_SPI_SLAVE_SELECT3)
N
N#endif /* CY_SCB_SPI_UART_UART_0_FPC_H */
N
N
N/* [] END OF FILE */
L 29 "Generated_Source\PSoC4\project.h" 2
N#include "UART_0_FPC_PINS.h"
N#include "UART_0_FPC_SPI_UART_PVT.h"
L 1 "Generated_Source\PSoC4\UART_0_FPC_SPI_UART_PVT.h" 1
N/***************************************************************************//**
N* \file UART_0_FPC_SPI_UART_PVT.h
N* \version 4.0
N*
N* \brief
N*  This private file provides constants and parameter values for the
N*  SCB Component in SPI and UART modes.
N*  Please do not use this file or its content in your project.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation. All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_SPI_UART_PVT_UART_0_FPC_H)
X#if !0L
N#define CY_SCB_SPI_UART_PVT_UART_0_FPC_H
N
N#include "UART_0_FPC_SPI_UART.h"
N
N
N/***************************************
N*     Internal Global Vars
N***************************************/
N
N#if (UART_0_FPC_INTERNAL_RX_SW_BUFFER_CONST)
X#if (((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u)))))))
S    extern volatile uint32  UART_0_FPC_rxBufferHead;
S    extern volatile uint32  UART_0_FPC_rxBufferTail;
S    
S    /**
S    * \addtogroup group_globals
S    * @{
S    */
S    
S    /** Sets when internal software receive buffer overflow
S     *  was occurred.
S    */  
S    extern volatile uint8   UART_0_FPC_rxBufferOverflow;
S    /** @} globals */
N#endif /* (UART_0_FPC_INTERNAL_RX_SW_BUFFER_CONST) */
N
N#if (UART_0_FPC_INTERNAL_TX_SW_BUFFER_CONST)
X#if (((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u)))))))
S    extern volatile uint32  UART_0_FPC_txBufferHead;
S    extern volatile uint32  UART_0_FPC_txBufferTail;
N#endif /* (UART_0_FPC_INTERNAL_TX_SW_BUFFER_CONST) */
N
N#if (UART_0_FPC_INTERNAL_RX_SW_BUFFER)
X#if ((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u))))))
S    extern volatile uint8 UART_0_FPC_rxBufferInternal[UART_0_FPC_INTERNAL_RX_BUFFER_SIZE];
N#endif /* (UART_0_FPC_INTERNAL_RX_SW_BUFFER) */
N
N#if (UART_0_FPC_INTERNAL_TX_SW_BUFFER)
X#if ((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u))))))
S    extern volatile uint8 UART_0_FPC_txBufferInternal[UART_0_FPC_TX_BUFFER_SIZE];
N#endif /* (UART_0_FPC_INTERNAL_TX_SW_BUFFER) */
N
N
N/***************************************
N*     Private Function Prototypes
N***************************************/
N
Nvoid UART_0_FPC_SpiPostEnable(void);
Nvoid UART_0_FPC_SpiStop(void);
N
N#if (UART_0_FPC_SCB_MODE_SPI_CONST_CFG)
X#if (((0x02u) == (4u)))
S    void UART_0_FPC_SpiInit(void);
N#endif /* (UART_0_FPC_SCB_MODE_SPI_CONST_CFG) */
N
N#if (UART_0_FPC_SPI_WAKE_ENABLE_CONST)
X#if ((0u))
S    void UART_0_FPC_SpiSaveConfig(void);
S    void UART_0_FPC_SpiRestoreConfig(void);
N#endif /* (UART_0_FPC_SPI_WAKE_ENABLE_CONST) */
N
Nvoid UART_0_FPC_UartPostEnable(void);
Nvoid UART_0_FPC_UartStop(void);
N
N#if (UART_0_FPC_SCB_MODE_UART_CONST_CFG)
X#if (((0x04u) == (4u)))
N    void UART_0_FPC_UartInit(void);
N#endif /* (UART_0_FPC_SCB_MODE_UART_CONST_CFG) */
N
N#if (UART_0_FPC_UART_WAKE_ENABLE_CONST)
X#if ((0u != (0u)))
S    void UART_0_FPC_UartSaveConfig(void);
S    void UART_0_FPC_UartRestoreConfig(void);
N#endif /* (UART_0_FPC_UART_WAKE_ENABLE_CONST) */
N
N
N/***************************************
N*         UART API Constants
N***************************************/
N
N/* UART RX and TX position to be used in UART_0_FPC_SetPins() */
N#define UART_0_FPC_UART_RX_PIN_ENABLE    (UART_0_FPC_UART_RX)
N#define UART_0_FPC_UART_TX_PIN_ENABLE    (UART_0_FPC_UART_TX)
N
N/* UART RTS and CTS position to be used in  UART_0_FPC_SetPins() */
N#define UART_0_FPC_UART_RTS_PIN_ENABLE    (0x10u)
N#define UART_0_FPC_UART_CTS_PIN_ENABLE    (0x20u)
N
N
N/***************************************
N* The following code is DEPRECATED and
N* must not be used.
N***************************************/
N
N/* Interrupt processing */
N#define UART_0_FPC_SpiUartEnableIntRx(intSourceMask)  UART_0_FPC_SetRxInterruptMode(intSourceMask)
N#define UART_0_FPC_SpiUartEnableIntTx(intSourceMask)  UART_0_FPC_SetTxInterruptMode(intSourceMask)
Nuint32  UART_0_FPC_SpiUartDisableIntRx(void);
Nuint32  UART_0_FPC_SpiUartDisableIntTx(void);
N
N
N#endif /* (CY_SCB_SPI_UART_PVT_UART_0_FPC_H) */
N
N
N/* [] END OF FILE */
L 31 "Generated_Source\PSoC4\project.h" 2
N#include "UART_0_FPC_PVT.h"
L 1 "Generated_Source\PSoC4\UART_0_FPC_PVT.h" 1
N/***************************************************************************//**
N* \file .h
N* \version 4.0
N*
N* \brief
N*  This private file provides constants and parameter values for the
N*  SCB Component.
N*  Please do not use this file or its content in your project.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation. All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_PVT_UART_0_FPC_H)
X#if !0L
N#define CY_SCB_PVT_UART_0_FPC_H
N
N#include "UART_0_FPC.h"
N
N
N/***************************************
N*     Private Function Prototypes
N***************************************/
N
N/* APIs to service INTR_I2C_EC register */
N#define UART_0_FPC_SetI2CExtClkInterruptMode(interruptMask) UART_0_FPC_WRITE_INTR_I2C_EC_MASK(interruptMask)
N#define UART_0_FPC_ClearI2CExtClkInterruptSource(interruptMask) UART_0_FPC_CLEAR_INTR_I2C_EC(interruptMask)
N#define UART_0_FPC_GetI2CExtClkInterruptSource()                (UART_0_FPC_INTR_I2C_EC_REG)
N#define UART_0_FPC_GetI2CExtClkInterruptMode()                  (UART_0_FPC_INTR_I2C_EC_MASK_REG)
N#define UART_0_FPC_GetI2CExtClkInterruptSourceMasked()          (UART_0_FPC_INTR_I2C_EC_MASKED_REG)
N
N#if (!UART_0_FPC_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    /* APIs to service INTR_SPI_EC register */
N    #define UART_0_FPC_SetSpiExtClkInterruptMode(interruptMask) \
N                                                                UART_0_FPC_WRITE_INTR_SPI_EC_MASK(interruptMask)
X    #define UART_0_FPC_SetSpiExtClkInterruptMode(interruptMask)                                                                 UART_0_FPC_WRITE_INTR_SPI_EC_MASK(interruptMask)
N    #define UART_0_FPC_ClearSpiExtClkInterruptSource(interruptMask) \
N                                                                UART_0_FPC_CLEAR_INTR_SPI_EC(interruptMask)
X    #define UART_0_FPC_ClearSpiExtClkInterruptSource(interruptMask)                                                                 UART_0_FPC_CLEAR_INTR_SPI_EC(interruptMask)
N    #define UART_0_FPC_GetExtSpiClkInterruptSource()                 (UART_0_FPC_INTR_SPI_EC_REG)
N    #define UART_0_FPC_GetExtSpiClkInterruptMode()                   (UART_0_FPC_INTR_SPI_EC_MASK_REG)
N    #define UART_0_FPC_GetExtSpiClkInterruptSourceMasked()           (UART_0_FPC_INTR_SPI_EC_MASKED_REG)
N#endif /* (!UART_0_FPC_CY_SCBIP_V1) */
N
N#if(UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    extern void UART_0_FPC_SetPins(uint32 mode, uint32 subMode, uint32 uartEnableMask);
N#endif /* (UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N
N/***************************************
N*     Vars with External Linkage
N***************************************/
N
N#if (UART_0_FPC_SCB_IRQ_INTERNAL)
X#if ((0u == (0u)))
N#if !defined (CY_REMOVE_UART_0_FPC_CUSTOM_INTR_HANDLER)
X#if !0L
N    extern cyisraddress UART_0_FPC_customIntrHandler;
N#endif /* !defined (CY_REMOVE_UART_0_FPC_CUSTOM_INTR_HANDLER) */
N#endif /* (UART_0_FPC_SCB_IRQ_INTERNAL) */
N
Nextern UART_0_FPC_BACKUP_STRUCT UART_0_FPC_backup;
N
N#if(UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    /* Common configuration variables */
S    extern uint8 UART_0_FPC_scbMode;
S    extern uint8 UART_0_FPC_scbEnableWake;
S    extern uint8 UART_0_FPC_scbEnableIntr;
S
S    /* I2C configuration variables */
S    extern uint8 UART_0_FPC_mode;
S    extern uint8 UART_0_FPC_acceptAddr;
S
S    /* SPI/UART configuration variables */
S    extern volatile uint8 * UART_0_FPC_rxBuffer;
S    extern uint8   UART_0_FPC_rxDataBits;
S    extern uint32  UART_0_FPC_rxBufferSize;
S
S    extern volatile uint8 * UART_0_FPC_txBuffer;
S    extern uint8   UART_0_FPC_txDataBits;
S    extern uint32  UART_0_FPC_txBufferSize;
S
S    /* EZI2C configuration variables */
S    extern uint8 UART_0_FPC_numberOfAddr;
S    extern uint8 UART_0_FPC_subAddrSize;
N#endif /* (UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N#if (! (UART_0_FPC_SCB_MODE_I2C_CONST_CFG || \
N        UART_0_FPC_SCB_MODE_EZI2C_CONST_CFG))
X#if (! (((0x01u) == (4u)) ||         ((0x08u) == (4u))))
N    extern uint16 UART_0_FPC_IntrTxMask;
N#endif /* (! (UART_0_FPC_SCB_MODE_I2C_CONST_CFG || \
N              UART_0_FPC_SCB_MODE_EZI2C_CONST_CFG)) */
X#endif  
N
N
N/***************************************
N*        Conditional Macro
N****************************************/
N
N#if(UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    /* Defines run time operation mode */
S    #define UART_0_FPC_SCB_MODE_I2C_RUNTM_CFG     (UART_0_FPC_SCB_MODE_I2C      == UART_0_FPC_scbMode)
S    #define UART_0_FPC_SCB_MODE_SPI_RUNTM_CFG     (UART_0_FPC_SCB_MODE_SPI      == UART_0_FPC_scbMode)
S    #define UART_0_FPC_SCB_MODE_UART_RUNTM_CFG    (UART_0_FPC_SCB_MODE_UART     == UART_0_FPC_scbMode)
S    #define UART_0_FPC_SCB_MODE_EZI2C_RUNTM_CFG   (UART_0_FPC_SCB_MODE_EZI2C    == UART_0_FPC_scbMode)
S    #define UART_0_FPC_SCB_MODE_UNCONFIG_RUNTM_CFG \
S                                                        (UART_0_FPC_SCB_MODE_UNCONFIG == UART_0_FPC_scbMode)
X    #define UART_0_FPC_SCB_MODE_UNCONFIG_RUNTM_CFG                                                         (UART_0_FPC_SCB_MODE_UNCONFIG == UART_0_FPC_scbMode)
S
S    /* Defines wakeup enable */
S    #define UART_0_FPC_SCB_WAKE_ENABLE_CHECK       (0u != UART_0_FPC_scbEnableWake)
N#endif /* (UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N/* Defines maximum number of SCB pins */
N#if (!UART_0_FPC_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_0_FPC_SCB_PINS_NUMBER    (7u)
N#else
S    #define UART_0_FPC_SCB_PINS_NUMBER    (2u)
N#endif /* (!UART_0_FPC_CY_SCBIP_V1) */
N
N#endif /* (CY_SCB_PVT_UART_0_FPC_H) */
N
N
N/* [] END OF FILE */
L 32 "Generated_Source\PSoC4\project.h" 2
N#include "UART_0_FPC_BOOT.h"
L 1 "Generated_Source\PSoC4\UART_0_FPC_BOOT.h" 1
N/***************************************************************************//**
N* \file UART_0_FPC_BOOT.h
N* \version 4.0
N*
N* \brief
N*  This file provides constants and parameter values of the bootloader
N*  communication APIs for the SCB Component.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2014-2017, Cypress Semiconductor Corporation. All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_BOOT_UART_0_FPC_H)
X#if !0L
N#define CY_SCB_BOOT_UART_0_FPC_H
N
N#include "UART_0_FPC_PVT.h"
N
N#if (UART_0_FPC_SCB_MODE_I2C_INC)
X#if ((0u !=((0x01u) & (4u))))
S    #include "UART_0_FPC_I2C.h"
N#endif /* (UART_0_FPC_SCB_MODE_I2C_INC) */
N
N#if (UART_0_FPC_SCB_MODE_EZI2C_INC)
X#if ((0u !=((0x08u) & (4u))))
S    #include "UART_0_FPC_EZI2C.h"
N#endif /* (UART_0_FPC_SCB_MODE_EZI2C_INC) */
N
N#if (UART_0_FPC_SCB_MODE_SPI_INC || UART_0_FPC_SCB_MODE_UART_INC)
X#if ((0u !=((0x02u) & (4u))) || (0u !=((0x04u) & (4u))))
N    #include "UART_0_FPC_SPI_UART.h"
N#endif /* (UART_0_FPC_SCB_MODE_SPI_INC || UART_0_FPC_SCB_MODE_UART_INC) */
N
N
N/***************************************
N*  Conditional Compilation Parameters
N****************************************/
N
N/* Bootloader communication interface enable */
N#define UART_0_FPC_BTLDR_COMM_ENABLED ((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_0_FPC) || \
N                                             (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface))
X#define UART_0_FPC_BTLDR_COMM_ENABLED ((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_0_FPC) ||                                              (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface))
N
N/* Enable I2C bootloader communication */
N#if (UART_0_FPC_SCB_MODE_I2C_INC)
X#if ((0u !=((0x01u) & (4u))))
S    #define UART_0_FPC_I2C_BTLDR_COMM_ENABLED     (UART_0_FPC_BTLDR_COMM_ENABLED && \
S                                                            (UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG || \
S                                                             UART_0_FPC_I2C_SLAVE_CONST))
X    #define UART_0_FPC_I2C_BTLDR_COMM_ENABLED     (UART_0_FPC_BTLDR_COMM_ENABLED &&                                                             (UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG ||                                                              UART_0_FPC_I2C_SLAVE_CONST))
N#else
N     #define UART_0_FPC_I2C_BTLDR_COMM_ENABLED    (0u)
N#endif /* (UART_0_FPC_SCB_MODE_I2C_INC) */
N
N/* EZI2C does not support bootloader communication. Provide empty APIs */
N#if (UART_0_FPC_SCB_MODE_EZI2C_INC)
X#if ((0u !=((0x08u) & (4u))))
S    #define UART_0_FPC_EZI2C_BTLDR_COMM_ENABLED   (UART_0_FPC_BTLDR_COMM_ENABLED && \
S                                                         UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG)
X    #define UART_0_FPC_EZI2C_BTLDR_COMM_ENABLED   (UART_0_FPC_BTLDR_COMM_ENABLED &&                                                          UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG)
N#else
N    #define UART_0_FPC_EZI2C_BTLDR_COMM_ENABLED   (0u)
N#endif /* (UART_0_FPC_EZI2C_BTLDR_COMM_ENABLED) */
N
N/* Enable SPI bootloader communication */
N#if (UART_0_FPC_SCB_MODE_SPI_INC)
X#if ((0u !=((0x02u) & (4u))))
S    #define UART_0_FPC_SPI_BTLDR_COMM_ENABLED     (UART_0_FPC_BTLDR_COMM_ENABLED && \
S                                                            (UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG || \
S                                                             UART_0_FPC_SPI_SLAVE_CONST))
X    #define UART_0_FPC_SPI_BTLDR_COMM_ENABLED     (UART_0_FPC_BTLDR_COMM_ENABLED &&                                                             (UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG ||                                                              UART_0_FPC_SPI_SLAVE_CONST))
N#else
N        #define UART_0_FPC_SPI_BTLDR_COMM_ENABLED (0u)
N#endif /* (UART_0_FPC_SPI_BTLDR_COMM_ENABLED) */
N
N/* Enable UART bootloader communication */
N#if (UART_0_FPC_SCB_MODE_UART_INC)
X#if ((0u !=((0x04u) & (4u))))
N       #define UART_0_FPC_UART_BTLDR_COMM_ENABLED    (UART_0_FPC_BTLDR_COMM_ENABLED && \
N                                                            (UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG || \
N                                                             (UART_0_FPC_UART_RX_DIRECTION && \
N                                                              UART_0_FPC_UART_TX_DIRECTION)))
X       #define UART_0_FPC_UART_BTLDR_COMM_ENABLED    (UART_0_FPC_BTLDR_COMM_ENABLED &&                                                             (UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG ||                                                              (UART_0_FPC_UART_RX_DIRECTION &&                                                               UART_0_FPC_UART_TX_DIRECTION)))
N#else
S     #define UART_0_FPC_UART_BTLDR_COMM_ENABLED   (0u)
N#endif /* (UART_0_FPC_UART_BTLDR_COMM_ENABLED) */
N
N/* Enable bootloader communication */
N#define UART_0_FPC_BTLDR_COMM_MODE_ENABLED    (UART_0_FPC_I2C_BTLDR_COMM_ENABLED   || \
N                                                     UART_0_FPC_SPI_BTLDR_COMM_ENABLED   || \
N                                                     UART_0_FPC_EZI2C_BTLDR_COMM_ENABLED || \
N                                                     UART_0_FPC_UART_BTLDR_COMM_ENABLED)
X#define UART_0_FPC_BTLDR_COMM_MODE_ENABLED    (UART_0_FPC_I2C_BTLDR_COMM_ENABLED   ||                                                      UART_0_FPC_SPI_BTLDR_COMM_ENABLED   ||                                                      UART_0_FPC_EZI2C_BTLDR_COMM_ENABLED ||                                                      UART_0_FPC_UART_BTLDR_COMM_ENABLED)
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_0_FPC_I2C_BTLDR_COMM_ENABLED)
X#if 0L && ((0u))
S    /* I2C Bootloader physical layer functions */
S    void UART_0_FPC_I2CCyBtldrCommStart(void);
S    void UART_0_FPC_I2CCyBtldrCommStop (void);
S    void UART_0_FPC_I2CCyBtldrCommReset(void);
S    cystatus UART_0_FPC_I2CCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus UART_0_FPC_I2CCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    /* Map I2C specific bootloader communication APIs to SCB specific APIs */
S    #if (UART_0_FPC_SCB_MODE_I2C_CONST_CFG)
S        #define UART_0_FPC_CyBtldrCommStart   UART_0_FPC_I2CCyBtldrCommStart
S        #define UART_0_FPC_CyBtldrCommStop    UART_0_FPC_I2CCyBtldrCommStop
S        #define UART_0_FPC_CyBtldrCommReset   UART_0_FPC_I2CCyBtldrCommReset
S        #define UART_0_FPC_CyBtldrCommRead    UART_0_FPC_I2CCyBtldrCommRead
S        #define UART_0_FPC_CyBtldrCommWrite   UART_0_FPC_I2CCyBtldrCommWrite
S    #endif /* (UART_0_FPC_SCB_MODE_I2C_CONST_CFG) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_0_FPC_I2C_BTLDR_COMM_ENABLED) */
N
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_0_FPC_EZI2C_BTLDR_COMM_ENABLED)
X#if 0L && ((0u))
S    /* Bootloader physical layer functions */
S    void UART_0_FPC_EzI2CCyBtldrCommStart(void);
S    void UART_0_FPC_EzI2CCyBtldrCommStop (void);
S    void UART_0_FPC_EzI2CCyBtldrCommReset(void);
S    cystatus UART_0_FPC_EzI2CCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus UART_0_FPC_EzI2CCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    /* Map EZI2C specific bootloader communication APIs to SCB specific APIs */
S    #if (UART_0_FPC_SCB_MODE_EZI2C_CONST_CFG)
S        #define UART_0_FPC_CyBtldrCommStart   UART_0_FPC_EzI2CCyBtldrCommStart
S        #define UART_0_FPC_CyBtldrCommStop    UART_0_FPC_EzI2CCyBtldrCommStop
S        #define UART_0_FPC_CyBtldrCommReset   UART_0_FPC_EzI2CCyBtldrCommReset
S        #define UART_0_FPC_CyBtldrCommRead    UART_0_FPC_EzI2CCyBtldrCommRead
S        #define UART_0_FPC_CyBtldrCommWrite   UART_0_FPC_EzI2CCyBtldrCommWrite
S    #endif /* (UART_0_FPC_SCB_MODE_EZI2C_CONST_CFG) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_0_FPC_EZI2C_BTLDR_COMM_ENABLED) */
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_0_FPC_SPI_BTLDR_COMM_ENABLED)
X#if 0L && ((0u))
S    /* SPI Bootloader physical layer functions */
S    void UART_0_FPC_SpiCyBtldrCommStart(void);
S    void UART_0_FPC_SpiCyBtldrCommStop (void);
S    void UART_0_FPC_SpiCyBtldrCommReset(void);
S    cystatus UART_0_FPC_SpiCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus UART_0_FPC_SpiCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    /* Map SPI specific bootloader communication APIs to SCB specific APIs */
S    #if (UART_0_FPC_SCB_MODE_SPI_CONST_CFG)
S        #define UART_0_FPC_CyBtldrCommStart   UART_0_FPC_SpiCyBtldrCommStart
S        #define UART_0_FPC_CyBtldrCommStop    UART_0_FPC_SpiCyBtldrCommStop
S        #define UART_0_FPC_CyBtldrCommReset   UART_0_FPC_SpiCyBtldrCommReset
S        #define UART_0_FPC_CyBtldrCommRead    UART_0_FPC_SpiCyBtldrCommRead
S        #define UART_0_FPC_CyBtldrCommWrite   UART_0_FPC_SpiCyBtldrCommWrite
S    #endif /* (UART_0_FPC_SCB_MODE_SPI_CONST_CFG) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_0_FPC_SPI_BTLDR_COMM_ENABLED) */
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_0_FPC_UART_BTLDR_COMM_ENABLED)
X#if 0L && ((((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_0_FPC) || (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface)) && (((0xFFu) == (4u)) || ((0u != ((3u) & (1u))) && (0u != ((3u) & (2u)))))))
S    /* UART Bootloader physical layer functions */
S    void UART_0_FPC_UartCyBtldrCommStart(void);
S    void UART_0_FPC_UartCyBtldrCommStop (void);
S    void UART_0_FPC_UartCyBtldrCommReset(void);
S    cystatus UART_0_FPC_UartCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus UART_0_FPC_UartCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    /* Map UART specific bootloader communication APIs to SCB specific APIs */
S    #if (UART_0_FPC_SCB_MODE_UART_CONST_CFG)
S        #define UART_0_FPC_CyBtldrCommStart   UART_0_FPC_UartCyBtldrCommStart
S        #define UART_0_FPC_CyBtldrCommStop    UART_0_FPC_UartCyBtldrCommStop
S        #define UART_0_FPC_CyBtldrCommReset   UART_0_FPC_UartCyBtldrCommReset
S        #define UART_0_FPC_CyBtldrCommRead    UART_0_FPC_UartCyBtldrCommRead
S        #define UART_0_FPC_CyBtldrCommWrite   UART_0_FPC_UartCyBtldrCommWrite
S    #endif /* (UART_0_FPC_SCB_MODE_UART_CONST_CFG) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_0_FPC_UART_BTLDR_COMM_ENABLED) */
N
N/**
N* \addtogroup group_bootloader
N* @{
N*/
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_0_FPC_BTLDR_COMM_ENABLED)
X#if 0L && (((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_0_FPC) || (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface)))
S    #if (UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG)
S        /* Bootloader physical layer functions */
S        void UART_0_FPC_CyBtldrCommStart(void);
S        void UART_0_FPC_CyBtldrCommStop (void);
S        void UART_0_FPC_CyBtldrCommReset(void);
S        cystatus UART_0_FPC_CyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S        cystatus UART_0_FPC_CyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    #endif /* (UART_0_FPC_SCB_MODE_UNCONFIG_CONST_CFG) */
S
S    /* Map SCB specific bootloader communication APIs to common APIs */
S    #if (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_0_FPC)
S        #define CyBtldrCommStart    UART_0_FPC_CyBtldrCommStart
S        #define CyBtldrCommStop     UART_0_FPC_CyBtldrCommStop
S        #define CyBtldrCommReset    UART_0_FPC_CyBtldrCommReset
S        #define CyBtldrCommWrite    UART_0_FPC_CyBtldrCommWrite
S        #define CyBtldrCommRead     UART_0_FPC_CyBtldrCommRead
S    #endif /* (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_0_FPC) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_0_FPC_BTLDR_COMM_ENABLED) */
N
N/** @} group_bootloader */
N
N/***************************************
N*           API Constants
N***************************************/
N
N/* Timeout unit in milliseconds */
N#define UART_0_FPC_WAIT_1_MS  (1u)
N
N/* Return number of bytes to copy into bootloader buffer */
N#define UART_0_FPC_BYTES_TO_COPY(actBufSize, bufSize) \
N                            ( ((uint32)(actBufSize) < (uint32)(bufSize)) ? \
N                                ((uint32) (actBufSize)) : ((uint32) (bufSize)) )
X#define UART_0_FPC_BYTES_TO_COPY(actBufSize, bufSize)                             ( ((uint32)(actBufSize) < (uint32)(bufSize)) ?                                 ((uint32) (actBufSize)) : ((uint32) (bufSize)) )
N
N/* Size of Read/Write buffers for I2C bootloader  */
N#define UART_0_FPC_I2C_BTLDR_SIZEOF_READ_BUFFER   (64u)
N#define UART_0_FPC_I2C_BTLDR_SIZEOF_WRITE_BUFFER  (64u)
N
N/* Byte to byte time interval: calculated basing on current component
N* data rate configuration, can be defined in project if required.
N*/
N#ifndef UART_0_FPC_SPI_BYTE_TO_BYTE
N    #define UART_0_FPC_SPI_BYTE_TO_BYTE   (160u)
N#endif
N
N/* Byte to byte time interval: calculated basing on current component
N* baud rate configuration, can be defined in the project if required.
N*/
N#ifndef UART_0_FPC_UART_BYTE_TO_BYTE
N    #define UART_0_FPC_UART_BYTE_TO_BYTE  (346u)
N#endif /* UART_0_FPC_UART_BYTE_TO_BYTE */
N
N#endif /* (CY_SCB_BOOT_UART_0_FPC_H) */
N
N
N/* [] END OF FILE */
L 33 "Generated_Source\PSoC4\project.h" 2
N#include "UART_2_EXT.h"
L 1 "Generated_Source\PSoC4\UART_2_EXT.h" 1
N/***************************************************************************//**
N* \file UART_2_EXT.h
N* \version 4.0
N*
N* \brief
N*  This file provides constants and parameter values for the SCB Component.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_UART_2_EXT_H)
X#if !0L
N#define CY_SCB_UART_2_EXT_H
N
N#include <cydevice_trm.h>
N#include <cyfitter.h>
N#include <cytypes.h>
N#include <CyLib.h>
N
N/* SCB IP block v0 is available in PSoC 4100/PSoC 4200 */
N#define UART_2_EXT_CY_SCBIP_V0    (CYIPBLOCK_m0s8scb_VERSION == 0u)
N/* SCB IP block v1 is available in PSoC 4000 */
N#define UART_2_EXT_CY_SCBIP_V1    (CYIPBLOCK_m0s8scb_VERSION == 1u)
N/* SCB IP block v2 is available in all other devices */
N#define UART_2_EXT_CY_SCBIP_V2    (CYIPBLOCK_m0s8scb_VERSION >= 2u)
N
N/** Component version major.minor */
N#define UART_2_EXT_COMP_VERSION_MAJOR    (4)
N#define UART_2_EXT_COMP_VERSION_MINOR    (0)
N    
N#define UART_2_EXT_SCB_MODE           (4u)
N
N/* SCB modes enum */
N#define UART_2_EXT_SCB_MODE_I2C       (0x01u)
N#define UART_2_EXT_SCB_MODE_SPI       (0x02u)
N#define UART_2_EXT_SCB_MODE_UART      (0x04u)
N#define UART_2_EXT_SCB_MODE_EZI2C     (0x08u)
N#define UART_2_EXT_SCB_MODE_UNCONFIG  (0xFFu)
N
N/* Condition compilation depends on operation mode: Unconfigured implies apply to all modes */
N#define UART_2_EXT_SCB_MODE_I2C_CONST_CFG       (UART_2_EXT_SCB_MODE_I2C       == UART_2_EXT_SCB_MODE)
N#define UART_2_EXT_SCB_MODE_SPI_CONST_CFG       (UART_2_EXT_SCB_MODE_SPI       == UART_2_EXT_SCB_MODE)
N#define UART_2_EXT_SCB_MODE_UART_CONST_CFG      (UART_2_EXT_SCB_MODE_UART      == UART_2_EXT_SCB_MODE)
N#define UART_2_EXT_SCB_MODE_EZI2C_CONST_CFG     (UART_2_EXT_SCB_MODE_EZI2C     == UART_2_EXT_SCB_MODE)
N#define UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG  (UART_2_EXT_SCB_MODE_UNCONFIG  == UART_2_EXT_SCB_MODE)
N
N/* Condition compilation for includes */
N#define UART_2_EXT_SCB_MODE_I2C_INC      (0u !=(UART_2_EXT_SCB_MODE_I2C   & UART_2_EXT_SCB_MODE))
N#define UART_2_EXT_SCB_MODE_EZI2C_INC    (0u !=(UART_2_EXT_SCB_MODE_EZI2C & UART_2_EXT_SCB_MODE))
N#if (!UART_2_EXT_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_2_EXT_SCB_MODE_SPI_INC  (0u !=(UART_2_EXT_SCB_MODE_SPI   & UART_2_EXT_SCB_MODE))
N    #define UART_2_EXT_SCB_MODE_UART_INC (0u !=(UART_2_EXT_SCB_MODE_UART  & UART_2_EXT_SCB_MODE))
N#else
S    #define UART_2_EXT_SCB_MODE_SPI_INC  (0u)
S    #define UART_2_EXT_SCB_MODE_UART_INC (0u)
N#endif /* (!UART_2_EXT_CY_SCBIP_V1) */
N
N/* Interrupts remove options */
N#define UART_2_EXT_REMOVE_SCB_IRQ             (0u)
N#define UART_2_EXT_SCB_IRQ_INTERNAL           (0u == UART_2_EXT_REMOVE_SCB_IRQ)
N
N#define UART_2_EXT_REMOVE_UART_RX_WAKEUP_IRQ  (1u)
N#define UART_2_EXT_UART_RX_WAKEUP_IRQ         (0u == UART_2_EXT_REMOVE_UART_RX_WAKEUP_IRQ)
N
N/* SCB interrupt enum */
N#define UART_2_EXT_SCB_INTR_MODE_NONE     (0u)
N#define UART_2_EXT_SCB_INTR_MODE_INTERNAL (1u)
N#define UART_2_EXT_SCB_INTR_MODE_EXTERNAL (2u)
N
N/* Internal clock remove option */
N#define UART_2_EXT_REMOVE_SCB_CLK     (0u)
N#define UART_2_EXT_SCB_CLK_INTERNAL   (0u == UART_2_EXT_REMOVE_SCB_CLK)
N
N
N/***************************************
N*       Includes
N****************************************/
N
N#include "UART_2_EXT_PINS.h"
L 1 "Generated_Source\PSoC4\UART_2_EXT_PINS.h" 1
N/***************************************************************************//**
N* \file UART_2_EXT_PINS.h
N* \version 4.0
N*
N* \brief
N*  This file provides constants and parameter values for the pin components
N*  buried into SCB Component.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_PINS_UART_2_EXT_H)
X#if !0L
N#define CY_SCB_PINS_UART_2_EXT_H
N
N#include "cydevice_trm.h"
N#include "cyfitter.h"
N#include "cytypes.h"
N
N
N/***************************************
N*   Conditional Compilation Parameters
N****************************************/
N
N/* Unconfigured pins */
N#define UART_2_EXT_REMOVE_RX_WAKE_SCL_MOSI_PIN  (1u)
N#define UART_2_EXT_REMOVE_RX_SCL_MOSI_PIN      (1u)
N#define UART_2_EXT_REMOVE_TX_SDA_MISO_PIN      (1u)
N#define UART_2_EXT_REMOVE_CTS_SCLK_PIN      (1u)
N#define UART_2_EXT_REMOVE_RTS_SS0_PIN      (1u)
N#define UART_2_EXT_REMOVE_SS1_PIN                 (1u)
N#define UART_2_EXT_REMOVE_SS2_PIN                 (1u)
N#define UART_2_EXT_REMOVE_SS3_PIN                 (1u)
N
N/* Mode defined pins */
N#define UART_2_EXT_REMOVE_I2C_PINS                (1u)
N#define UART_2_EXT_REMOVE_SPI_MASTER_PINS         (1u)
N#define UART_2_EXT_REMOVE_SPI_MASTER_SCLK_PIN     (1u)
N#define UART_2_EXT_REMOVE_SPI_MASTER_MOSI_PIN     (1u)
N#define UART_2_EXT_REMOVE_SPI_MASTER_MISO_PIN     (1u)
N#define UART_2_EXT_REMOVE_SPI_MASTER_SS0_PIN      (1u)
N#define UART_2_EXT_REMOVE_SPI_MASTER_SS1_PIN      (1u)
N#define UART_2_EXT_REMOVE_SPI_MASTER_SS2_PIN      (1u)
N#define UART_2_EXT_REMOVE_SPI_MASTER_SS3_PIN      (1u)
N#define UART_2_EXT_REMOVE_SPI_SLAVE_PINS          (1u)
N#define UART_2_EXT_REMOVE_SPI_SLAVE_MOSI_PIN      (1u)
N#define UART_2_EXT_REMOVE_SPI_SLAVE_MISO_PIN      (1u)
N#define UART_2_EXT_REMOVE_UART_TX_PIN             (0u)
N#define UART_2_EXT_REMOVE_UART_RX_TX_PIN          (1u)
N#define UART_2_EXT_REMOVE_UART_RX_PIN             (0u)
N#define UART_2_EXT_REMOVE_UART_RX_WAKE_PIN        (1u)
N#define UART_2_EXT_REMOVE_UART_RTS_PIN            (1u)
N#define UART_2_EXT_REMOVE_UART_CTS_PIN            (1u)
N
N/* Unconfigured pins */
N#define UART_2_EXT_RX_WAKE_SCL_MOSI_PIN (0u == UART_2_EXT_REMOVE_RX_WAKE_SCL_MOSI_PIN)
N#define UART_2_EXT_RX_SCL_MOSI_PIN     (0u == UART_2_EXT_REMOVE_RX_SCL_MOSI_PIN)
N#define UART_2_EXT_TX_SDA_MISO_PIN     (0u == UART_2_EXT_REMOVE_TX_SDA_MISO_PIN)
N#define UART_2_EXT_CTS_SCLK_PIN     (0u == UART_2_EXT_REMOVE_CTS_SCLK_PIN)
N#define UART_2_EXT_RTS_SS0_PIN     (0u == UART_2_EXT_REMOVE_RTS_SS0_PIN)
N#define UART_2_EXT_SS1_PIN                (0u == UART_2_EXT_REMOVE_SS1_PIN)
N#define UART_2_EXT_SS2_PIN                (0u == UART_2_EXT_REMOVE_SS2_PIN)
N#define UART_2_EXT_SS3_PIN                (0u == UART_2_EXT_REMOVE_SS3_PIN)
N
N/* Mode defined pins */
N#define UART_2_EXT_I2C_PINS               (0u == UART_2_EXT_REMOVE_I2C_PINS)
N#define UART_2_EXT_SPI_MASTER_PINS        (0u == UART_2_EXT_REMOVE_SPI_MASTER_PINS)
N#define UART_2_EXT_SPI_MASTER_SCLK_PIN    (0u == UART_2_EXT_REMOVE_SPI_MASTER_SCLK_PIN)
N#define UART_2_EXT_SPI_MASTER_MOSI_PIN    (0u == UART_2_EXT_REMOVE_SPI_MASTER_MOSI_PIN)
N#define UART_2_EXT_SPI_MASTER_MISO_PIN    (0u == UART_2_EXT_REMOVE_SPI_MASTER_MISO_PIN)
N#define UART_2_EXT_SPI_MASTER_SS0_PIN     (0u == UART_2_EXT_REMOVE_SPI_MASTER_SS0_PIN)
N#define UART_2_EXT_SPI_MASTER_SS1_PIN     (0u == UART_2_EXT_REMOVE_SPI_MASTER_SS1_PIN)
N#define UART_2_EXT_SPI_MASTER_SS2_PIN     (0u == UART_2_EXT_REMOVE_SPI_MASTER_SS2_PIN)
N#define UART_2_EXT_SPI_MASTER_SS3_PIN     (0u == UART_2_EXT_REMOVE_SPI_MASTER_SS3_PIN)
N#define UART_2_EXT_SPI_SLAVE_PINS         (0u == UART_2_EXT_REMOVE_SPI_SLAVE_PINS)
N#define UART_2_EXT_SPI_SLAVE_MOSI_PIN     (0u == UART_2_EXT_REMOVE_SPI_SLAVE_MOSI_PIN)
N#define UART_2_EXT_SPI_SLAVE_MISO_PIN     (0u == UART_2_EXT_REMOVE_SPI_SLAVE_MISO_PIN)
N#define UART_2_EXT_UART_TX_PIN            (0u == UART_2_EXT_REMOVE_UART_TX_PIN)
N#define UART_2_EXT_UART_RX_TX_PIN         (0u == UART_2_EXT_REMOVE_UART_RX_TX_PIN)
N#define UART_2_EXT_UART_RX_PIN            (0u == UART_2_EXT_REMOVE_UART_RX_PIN)
N#define UART_2_EXT_UART_RX_WAKE_PIN       (0u == UART_2_EXT_REMOVE_UART_RX_WAKE_PIN)
N#define UART_2_EXT_UART_RTS_PIN           (0u == UART_2_EXT_REMOVE_UART_RTS_PIN)
N#define UART_2_EXT_UART_CTS_PIN           (0u == UART_2_EXT_REMOVE_UART_CTS_PIN)
N
N
N/***************************************
N*             Includes
N****************************************/
N
N#if (UART_2_EXT_RX_WAKE_SCL_MOSI_PIN)
X#if ((0u == (1u)))
S    #include "UART_2_EXT_uart_rx_wake_i2c_scl_spi_mosi.h"
N#endif /* (UART_2_EXT_RX_SCL_MOSI) */
N
N#if (UART_2_EXT_RX_SCL_MOSI_PIN)
X#if ((0u == (1u)))
S    #include "UART_2_EXT_uart_rx_i2c_scl_spi_mosi.h"
N#endif /* (UART_2_EXT_RX_SCL_MOSI) */
N
N#if (UART_2_EXT_TX_SDA_MISO_PIN)
X#if ((0u == (1u)))
S    #include "UART_2_EXT_uart_tx_i2c_sda_spi_miso.h"
N#endif /* (UART_2_EXT_TX_SDA_MISO) */
N
N#if (UART_2_EXT_CTS_SCLK_PIN)
X#if ((0u == (1u)))
S    #include "UART_2_EXT_uart_cts_spi_sclk.h"
N#endif /* (UART_2_EXT_CTS_SCLK) */
N
N#if (UART_2_EXT_RTS_SS0_PIN)
X#if ((0u == (1u)))
S    #include "UART_2_EXT_uart_rts_spi_ss0.h"
N#endif /* (UART_2_EXT_RTS_SS0_PIN) */
N
N#if (UART_2_EXT_SS1_PIN)
X#if ((0u == (1u)))
S    #include "UART_2_EXT_spi_ss1.h"
N#endif /* (UART_2_EXT_SS1_PIN) */
N
N#if (UART_2_EXT_SS2_PIN)
X#if ((0u == (1u)))
S    #include "UART_2_EXT_spi_ss2.h"
N#endif /* (UART_2_EXT_SS2_PIN) */
N
N#if (UART_2_EXT_SS3_PIN)
X#if ((0u == (1u)))
S    #include "UART_2_EXT_spi_ss3.h"
N#endif /* (UART_2_EXT_SS3_PIN) */
N
N#if (UART_2_EXT_I2C_PINS)
X#if ((0u == (1u)))
S    #include "UART_2_EXT_scl.h"
S    #include "UART_2_EXT_sda.h"
N#endif /* (UART_2_EXT_I2C_PINS) */
N
N#if (UART_2_EXT_SPI_MASTER_PINS)
X#if ((0u == (1u)))
S#if (UART_2_EXT_SPI_MASTER_SCLK_PIN)
S    #include "UART_2_EXT_sclk_m.h"
S#endif /* (UART_2_EXT_SPI_MASTER_SCLK_PIN) */
S
S#if (UART_2_EXT_SPI_MASTER_MOSI_PIN)
S    #include "UART_2_EXT_mosi_m.h"
S#endif /* (UART_2_EXT_SPI_MASTER_MOSI_PIN) */
S
S#if (UART_2_EXT_SPI_MASTER_MISO_PIN)
S    #include "UART_2_EXT_miso_m.h"
S#endif /*(UART_2_EXT_SPI_MASTER_MISO_PIN) */
N#endif /* (UART_2_EXT_SPI_MASTER_PINS) */
N
N#if (UART_2_EXT_SPI_SLAVE_PINS)
X#if ((0u == (1u)))
S    #include "UART_2_EXT_sclk_s.h"
S    #include "UART_2_EXT_ss_s.h"
S
S#if (UART_2_EXT_SPI_SLAVE_MOSI_PIN)
S    #include "UART_2_EXT_mosi_s.h"
S#endif /* (UART_2_EXT_SPI_SLAVE_MOSI_PIN) */
S
S#if (UART_2_EXT_SPI_SLAVE_MISO_PIN)
S    #include "UART_2_EXT_miso_s.h"
S#endif /*(UART_2_EXT_SPI_SLAVE_MISO_PIN) */
N#endif /* (UART_2_EXT_SPI_SLAVE_PINS) */
N
N#if (UART_2_EXT_SPI_MASTER_SS0_PIN)
X#if ((0u == (1u)))
S    #include "UART_2_EXT_ss0_m.h"
N#endif /* (UART_2_EXT_SPI_MASTER_SS0_PIN) */
N
N#if (UART_2_EXT_SPI_MASTER_SS1_PIN)
X#if ((0u == (1u)))
S    #include "UART_2_EXT_ss1_m.h"
N#endif /* (UART_2_EXT_SPI_MASTER_SS1_PIN) */
N
N#if (UART_2_EXT_SPI_MASTER_SS2_PIN)
X#if ((0u == (1u)))
S    #include "UART_2_EXT_ss2_m.h"
N#endif /* (UART_2_EXT_SPI_MASTER_SS2_PIN) */
N
N#if (UART_2_EXT_SPI_MASTER_SS3_PIN)
X#if ((0u == (1u)))
S    #include "UART_2_EXT_ss3_m.h"
N#endif /* (UART_2_EXT_SPI_MASTER_SS3_PIN) */
N
N#if (UART_2_EXT_UART_TX_PIN)
X#if ((0u == (0u)))
N    #include "UART_2_EXT_tx.h"
L 1 "Generated_Source\PSoC4\UART_2_EXT_tx.h" 1
N/*******************************************************************************
N* File Name: UART_2_EXT_tx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_2_EXT_tx_H) /* Pins UART_2_EXT_tx_H */
X#if !0L  
N#define CY_PINS_UART_2_EXT_tx_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "UART_2_EXT_tx_aliases.h"
L 1 "Generated_Source\PSoC4\UART_2_EXT_tx_aliases.h" 1
N/*******************************************************************************
N* File Name: UART_2_EXT_tx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_2_EXT_tx_ALIASES_H) /* Pins UART_2_EXT_tx_ALIASES_H */
X#if !0L  
N#define CY_PINS_UART_2_EXT_tx_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define UART_2_EXT_tx_0			(UART_2_EXT_tx__0__PC)
N#define UART_2_EXT_tx_0_PS		(UART_2_EXT_tx__0__PS)
N#define UART_2_EXT_tx_0_PC		(UART_2_EXT_tx__0__PC)
N#define UART_2_EXT_tx_0_DR		(UART_2_EXT_tx__0__DR)
N#define UART_2_EXT_tx_0_SHIFT	(UART_2_EXT_tx__0__SHIFT)
N#define UART_2_EXT_tx_0_INTR	((uint16)((uint16)0x0003u << (UART_2_EXT_tx__0__SHIFT*2u)))
N
N#define UART_2_EXT_tx_INTR_ALL	 ((uint16)(UART_2_EXT_tx_0_INTR))
N
N
N#endif /* End Pins UART_2_EXT_tx_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\UART_2_EXT_tx.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} UART_2_EXT_tx_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   UART_2_EXT_tx_Read(void);
Nvoid    UART_2_EXT_tx_Write(uint8 value);
Nuint8   UART_2_EXT_tx_ReadDataReg(void);
N#if defined(UART_2_EXT_tx__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    UART_2_EXT_tx_SetDriveMode(uint8 mode);
N#endif
Nvoid    UART_2_EXT_tx_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   UART_2_EXT_tx_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid UART_2_EXT_tx_Sleep(void); 
Nvoid UART_2_EXT_tx_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(UART_2_EXT_tx__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define UART_2_EXT_tx_DRIVE_MODE_BITS        (3)
N    #define UART_2_EXT_tx_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - UART_2_EXT_tx_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the UART_2_EXT_tx_SetDriveMode() function.
N         *  @{
N         */
N        #define UART_2_EXT_tx_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define UART_2_EXT_tx_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define UART_2_EXT_tx_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define UART_2_EXT_tx_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define UART_2_EXT_tx_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define UART_2_EXT_tx_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define UART_2_EXT_tx_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define UART_2_EXT_tx_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define UART_2_EXT_tx_MASK               UART_2_EXT_tx__MASK
N#define UART_2_EXT_tx_SHIFT              UART_2_EXT_tx__SHIFT
N#define UART_2_EXT_tx_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in UART_2_EXT_tx_SetInterruptMode() function.
N     *  @{
N     */
N        #define UART_2_EXT_tx_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define UART_2_EXT_tx_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define UART_2_EXT_tx_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define UART_2_EXT_tx_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(UART_2_EXT_tx__SIO)
X#if 0L
S    #define UART_2_EXT_tx_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(UART_2_EXT_tx__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define UART_2_EXT_tx_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define UART_2_EXT_tx_USBIO_DISABLE              ((uint32)(~UART_2_EXT_tx_USBIO_ENABLE))
S    #define UART_2_EXT_tx_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define UART_2_EXT_tx_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define UART_2_EXT_tx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_2_EXT_tx_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << UART_2_EXT_tx_USBIO_SUSPEND_DEL_SHIFT)))
X    #define UART_2_EXT_tx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_2_EXT_tx_USBIO_SUSPEND_SHIFT)                                                         | (1u << UART_2_EXT_tx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_2_EXT_tx_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << UART_2_EXT_tx_USBIO_SUSPEND_SHIFT)))
S    #define UART_2_EXT_tx_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << UART_2_EXT_tx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_2_EXT_tx_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(UART_2_EXT_tx__PC)
X#if 1L
N    /* Port Configuration */
N    #define UART_2_EXT_tx_PC                 (* (reg32 *) UART_2_EXT_tx__PC)
N#endif
N/* Pin State */
N#define UART_2_EXT_tx_PS                     (* (reg32 *) UART_2_EXT_tx__PS)
N/* Data Register */
N#define UART_2_EXT_tx_DR                     (* (reg32 *) UART_2_EXT_tx__DR)
N/* Input Buffer Disable Override */
N#define UART_2_EXT_tx_INP_DIS                (* (reg32 *) UART_2_EXT_tx__PC2)
N
N/* Interrupt configuration Registers */
N#define UART_2_EXT_tx_INTCFG                 (* (reg32 *) UART_2_EXT_tx__INTCFG)
N#define UART_2_EXT_tx_INTSTAT                (* (reg32 *) UART_2_EXT_tx__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define UART_2_EXT_tx_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(UART_2_EXT_tx__SIO)
X#if 0L
S    #define UART_2_EXT_tx_SIO_REG            (* (reg32 *) UART_2_EXT_tx__SIO)
N#endif /* (UART_2_EXT_tx__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(UART_2_EXT_tx__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define UART_2_EXT_tx_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define UART_2_EXT_tx_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define UART_2_EXT_tx_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define UART_2_EXT_tx_DRIVE_MODE_SHIFT       (0x00u)
N#define UART_2_EXT_tx_DRIVE_MODE_MASK        (0x07u << UART_2_EXT_tx_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins UART_2_EXT_tx_H */
N
N
N/* [] END OF FILE */
L 178 "Generated_Source\PSoC4\UART_2_EXT_PINS.h" 2
N#endif /* (UART_2_EXT_UART_TX_PIN) */
N
N#if (UART_2_EXT_UART_RX_TX_PIN)
X#if ((0u == (1u)))
S    #include "UART_2_EXT_rx_tx.h"
N#endif /* (UART_2_EXT_UART_RX_TX_PIN) */
N
N#if (UART_2_EXT_UART_RX_PIN)
X#if ((0u == (0u)))
N    #include "UART_2_EXT_rx.h"
L 1 "Generated_Source\PSoC4\UART_2_EXT_rx.h" 1
N/*******************************************************************************
N* File Name: UART_2_EXT_rx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_2_EXT_rx_H) /* Pins UART_2_EXT_rx_H */
X#if !0L  
N#define CY_PINS_UART_2_EXT_rx_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "UART_2_EXT_rx_aliases.h"
L 1 "Generated_Source\PSoC4\UART_2_EXT_rx_aliases.h" 1
N/*******************************************************************************
N* File Name: UART_2_EXT_rx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_2_EXT_rx_ALIASES_H) /* Pins UART_2_EXT_rx_ALIASES_H */
X#if !0L  
N#define CY_PINS_UART_2_EXT_rx_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define UART_2_EXT_rx_0			(UART_2_EXT_rx__0__PC)
N#define UART_2_EXT_rx_0_PS		(UART_2_EXT_rx__0__PS)
N#define UART_2_EXT_rx_0_PC		(UART_2_EXT_rx__0__PC)
N#define UART_2_EXT_rx_0_DR		(UART_2_EXT_rx__0__DR)
N#define UART_2_EXT_rx_0_SHIFT	(UART_2_EXT_rx__0__SHIFT)
N#define UART_2_EXT_rx_0_INTR	((uint16)((uint16)0x0003u << (UART_2_EXT_rx__0__SHIFT*2u)))
N
N#define UART_2_EXT_rx_INTR_ALL	 ((uint16)(UART_2_EXT_rx_0_INTR))
N
N
N#endif /* End Pins UART_2_EXT_rx_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\UART_2_EXT_rx.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} UART_2_EXT_rx_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   UART_2_EXT_rx_Read(void);
Nvoid    UART_2_EXT_rx_Write(uint8 value);
Nuint8   UART_2_EXT_rx_ReadDataReg(void);
N#if defined(UART_2_EXT_rx__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    UART_2_EXT_rx_SetDriveMode(uint8 mode);
N#endif
Nvoid    UART_2_EXT_rx_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   UART_2_EXT_rx_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid UART_2_EXT_rx_Sleep(void); 
Nvoid UART_2_EXT_rx_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(UART_2_EXT_rx__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define UART_2_EXT_rx_DRIVE_MODE_BITS        (3)
N    #define UART_2_EXT_rx_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - UART_2_EXT_rx_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the UART_2_EXT_rx_SetDriveMode() function.
N         *  @{
N         */
N        #define UART_2_EXT_rx_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define UART_2_EXT_rx_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define UART_2_EXT_rx_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define UART_2_EXT_rx_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define UART_2_EXT_rx_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define UART_2_EXT_rx_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define UART_2_EXT_rx_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define UART_2_EXT_rx_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define UART_2_EXT_rx_MASK               UART_2_EXT_rx__MASK
N#define UART_2_EXT_rx_SHIFT              UART_2_EXT_rx__SHIFT
N#define UART_2_EXT_rx_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in UART_2_EXT_rx_SetInterruptMode() function.
N     *  @{
N     */
N        #define UART_2_EXT_rx_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define UART_2_EXT_rx_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define UART_2_EXT_rx_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define UART_2_EXT_rx_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(UART_2_EXT_rx__SIO)
X#if 0L
S    #define UART_2_EXT_rx_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(UART_2_EXT_rx__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define UART_2_EXT_rx_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define UART_2_EXT_rx_USBIO_DISABLE              ((uint32)(~UART_2_EXT_rx_USBIO_ENABLE))
S    #define UART_2_EXT_rx_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define UART_2_EXT_rx_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define UART_2_EXT_rx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_2_EXT_rx_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << UART_2_EXT_rx_USBIO_SUSPEND_DEL_SHIFT)))
X    #define UART_2_EXT_rx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_2_EXT_rx_USBIO_SUSPEND_SHIFT)                                                         | (1u << UART_2_EXT_rx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_2_EXT_rx_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << UART_2_EXT_rx_USBIO_SUSPEND_SHIFT)))
S    #define UART_2_EXT_rx_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << UART_2_EXT_rx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_2_EXT_rx_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(UART_2_EXT_rx__PC)
X#if 1L
N    /* Port Configuration */
N    #define UART_2_EXT_rx_PC                 (* (reg32 *) UART_2_EXT_rx__PC)
N#endif
N/* Pin State */
N#define UART_2_EXT_rx_PS                     (* (reg32 *) UART_2_EXT_rx__PS)
N/* Data Register */
N#define UART_2_EXT_rx_DR                     (* (reg32 *) UART_2_EXT_rx__DR)
N/* Input Buffer Disable Override */
N#define UART_2_EXT_rx_INP_DIS                (* (reg32 *) UART_2_EXT_rx__PC2)
N
N/* Interrupt configuration Registers */
N#define UART_2_EXT_rx_INTCFG                 (* (reg32 *) UART_2_EXT_rx__INTCFG)
N#define UART_2_EXT_rx_INTSTAT                (* (reg32 *) UART_2_EXT_rx__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define UART_2_EXT_rx_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(UART_2_EXT_rx__SIO)
X#if 0L
S    #define UART_2_EXT_rx_SIO_REG            (* (reg32 *) UART_2_EXT_rx__SIO)
N#endif /* (UART_2_EXT_rx__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(UART_2_EXT_rx__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define UART_2_EXT_rx_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define UART_2_EXT_rx_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define UART_2_EXT_rx_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define UART_2_EXT_rx_DRIVE_MODE_SHIFT       (0x00u)
N#define UART_2_EXT_rx_DRIVE_MODE_MASK        (0x07u << UART_2_EXT_rx_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins UART_2_EXT_rx_H */
N
N
N/* [] END OF FILE */
L 186 "Generated_Source\PSoC4\UART_2_EXT_PINS.h" 2
N#endif /* (UART_2_EXT_UART_RX_PIN) */
N
N#if (UART_2_EXT_UART_RX_WAKE_PIN)
X#if ((0u == (1u)))
S    #include "UART_2_EXT_rx_wake.h"
N#endif /* (UART_2_EXT_UART_RX_WAKE_PIN) */
N
N#if (UART_2_EXT_UART_RTS_PIN)
X#if ((0u == (1u)))
S    #include "UART_2_EXT_rts.h"
N#endif /* (UART_2_EXT_UART_RTS_PIN) */
N
N#if (UART_2_EXT_UART_CTS_PIN)
X#if ((0u == (1u)))
S    #include "UART_2_EXT_cts.h"
N#endif /* (UART_2_EXT_UART_CTS_PIN) */
N
N
N/***************************************
N*              Registers
N***************************************/
N
N#if (UART_2_EXT_RX_SCL_MOSI_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_RX_SCL_MOSI_HSIOM_REG   (*(reg32 *) UART_2_EXT_uart_rx_i2c_scl_spi_mosi__0__HSIOM)
S    #define UART_2_EXT_RX_SCL_MOSI_HSIOM_PTR   ( (reg32 *) UART_2_EXT_uart_rx_i2c_scl_spi_mosi__0__HSIOM)
S    
S    #define UART_2_EXT_RX_SCL_MOSI_HSIOM_MASK      (UART_2_EXT_uart_rx_i2c_scl_spi_mosi__0__HSIOM_MASK)
S    #define UART_2_EXT_RX_SCL_MOSI_HSIOM_POS       (UART_2_EXT_uart_rx_i2c_scl_spi_mosi__0__HSIOM_SHIFT)
S    #define UART_2_EXT_RX_SCL_MOSI_HSIOM_SEL_GPIO  (UART_2_EXT_uart_rx_i2c_scl_spi_mosi__0__HSIOM_GPIO)
S    #define UART_2_EXT_RX_SCL_MOSI_HSIOM_SEL_I2C   (UART_2_EXT_uart_rx_i2c_scl_spi_mosi__0__HSIOM_I2C)
S    #define UART_2_EXT_RX_SCL_MOSI_HSIOM_SEL_SPI   (UART_2_EXT_uart_rx_i2c_scl_spi_mosi__0__HSIOM_SPI)
S    #define UART_2_EXT_RX_SCL_MOSI_HSIOM_SEL_UART  (UART_2_EXT_uart_rx_i2c_scl_spi_mosi__0__HSIOM_UART)
S    
S#elif (UART_2_EXT_RX_WAKE_SCL_MOSI_PIN)
X#elif ((0u == (1u)))
S    #define UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_REG   (*(reg32 *) UART_2_EXT_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM)
S    #define UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_PTR   ( (reg32 *) UART_2_EXT_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM)
S    
S    #define UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_MASK      (UART_2_EXT_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_MASK)
S    #define UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_POS       (UART_2_EXT_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_SHIFT)
S    #define UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_SEL_GPIO  (UART_2_EXT_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_GPIO)
S    #define UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_SEL_I2C   (UART_2_EXT_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_I2C)
S    #define UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_SEL_SPI   (UART_2_EXT_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_SPI)
S    #define UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_SEL_UART  (UART_2_EXT_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_UART)    
S   
S    #define UART_2_EXT_RX_WAKE_SCL_MOSI_INTCFG_REG (*(reg32 *) UART_2_EXT_uart_rx_wake_i2c_scl_spi_mosi__0__INTCFG)
S    #define UART_2_EXT_RX_WAKE_SCL_MOSI_INTCFG_PTR ( (reg32 *) UART_2_EXT_uart_rx_wake_i2c_scl_spi_mosi__0__INTCFG)
S    #define UART_2_EXT_RX_WAKE_SCL_MOSI_INTCFG_TYPE_POS  (UART_2_EXT_uart_rx_wake_i2c_scl_spi_mosi__SHIFT)
S    #define UART_2_EXT_RX_WAKE_SCL_MOSI_INTCFG_TYPE_MASK ((uint32) UART_2_EXT_INTCFG_TYPE_MASK << \
S                                                                           UART_2_EXT_RX_WAKE_SCL_MOSI_INTCFG_TYPE_POS)
X    #define UART_2_EXT_RX_WAKE_SCL_MOSI_INTCFG_TYPE_MASK ((uint32) UART_2_EXT_INTCFG_TYPE_MASK <<                                                                            UART_2_EXT_RX_WAKE_SCL_MOSI_INTCFG_TYPE_POS)
N#else
N    /* None of pins UART_2_EXT_RX_SCL_MOSI_PIN or UART_2_EXT_RX_WAKE_SCL_MOSI_PIN present.*/
N#endif /* (UART_2_EXT_RX_SCL_MOSI_PIN) */
N
N#if (UART_2_EXT_TX_SDA_MISO_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_TX_SDA_MISO_HSIOM_REG   (*(reg32 *) UART_2_EXT_uart_tx_i2c_sda_spi_miso__0__HSIOM)
S    #define UART_2_EXT_TX_SDA_MISO_HSIOM_PTR   ( (reg32 *) UART_2_EXT_uart_tx_i2c_sda_spi_miso__0__HSIOM)
S    
S    #define UART_2_EXT_TX_SDA_MISO_HSIOM_MASK      (UART_2_EXT_uart_tx_i2c_sda_spi_miso__0__HSIOM_MASK)
S    #define UART_2_EXT_TX_SDA_MISO_HSIOM_POS       (UART_2_EXT_uart_tx_i2c_sda_spi_miso__0__HSIOM_SHIFT)
S    #define UART_2_EXT_TX_SDA_MISO_HSIOM_SEL_GPIO  (UART_2_EXT_uart_tx_i2c_sda_spi_miso__0__HSIOM_GPIO)
S    #define UART_2_EXT_TX_SDA_MISO_HSIOM_SEL_I2C   (UART_2_EXT_uart_tx_i2c_sda_spi_miso__0__HSIOM_I2C)
S    #define UART_2_EXT_TX_SDA_MISO_HSIOM_SEL_SPI   (UART_2_EXT_uart_tx_i2c_sda_spi_miso__0__HSIOM_SPI)
S    #define UART_2_EXT_TX_SDA_MISO_HSIOM_SEL_UART  (UART_2_EXT_uart_tx_i2c_sda_spi_miso__0__HSIOM_UART)
N#endif /* (UART_2_EXT_TX_SDA_MISO_PIN) */
N
N#if (UART_2_EXT_CTS_SCLK_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_CTS_SCLK_HSIOM_REG   (*(reg32 *) UART_2_EXT_uart_cts_spi_sclk__0__HSIOM)
S    #define UART_2_EXT_CTS_SCLK_HSIOM_PTR   ( (reg32 *) UART_2_EXT_uart_cts_spi_sclk__0__HSIOM)
S    
S    #define UART_2_EXT_CTS_SCLK_HSIOM_MASK      (UART_2_EXT_uart_cts_spi_sclk__0__HSIOM_MASK)
S    #define UART_2_EXT_CTS_SCLK_HSIOM_POS       (UART_2_EXT_uart_cts_spi_sclk__0__HSIOM_SHIFT)
S    #define UART_2_EXT_CTS_SCLK_HSIOM_SEL_GPIO  (UART_2_EXT_uart_cts_spi_sclk__0__HSIOM_GPIO)
S    #define UART_2_EXT_CTS_SCLK_HSIOM_SEL_I2C   (UART_2_EXT_uart_cts_spi_sclk__0__HSIOM_I2C)
S    #define UART_2_EXT_CTS_SCLK_HSIOM_SEL_SPI   (UART_2_EXT_uart_cts_spi_sclk__0__HSIOM_SPI)
S    #define UART_2_EXT_CTS_SCLK_HSIOM_SEL_UART  (UART_2_EXT_uart_cts_spi_sclk__0__HSIOM_UART)
N#endif /* (UART_2_EXT_CTS_SCLK_PIN) */
N
N#if (UART_2_EXT_RTS_SS0_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_RTS_SS0_HSIOM_REG   (*(reg32 *) UART_2_EXT_uart_rts_spi_ss0__0__HSIOM)
S    #define UART_2_EXT_RTS_SS0_HSIOM_PTR   ( (reg32 *) UART_2_EXT_uart_rts_spi_ss0__0__HSIOM)
S    
S    #define UART_2_EXT_RTS_SS0_HSIOM_MASK      (UART_2_EXT_uart_rts_spi_ss0__0__HSIOM_MASK)
S    #define UART_2_EXT_RTS_SS0_HSIOM_POS       (UART_2_EXT_uart_rts_spi_ss0__0__HSIOM_SHIFT)
S    #define UART_2_EXT_RTS_SS0_HSIOM_SEL_GPIO  (UART_2_EXT_uart_rts_spi_ss0__0__HSIOM_GPIO)
S    #define UART_2_EXT_RTS_SS0_HSIOM_SEL_I2C   (UART_2_EXT_uart_rts_spi_ss0__0__HSIOM_I2C)
S    #define UART_2_EXT_RTS_SS0_HSIOM_SEL_SPI   (UART_2_EXT_uart_rts_spi_ss0__0__HSIOM_SPI)
S#if !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1)
S    #define UART_2_EXT_RTS_SS0_HSIOM_SEL_UART  (UART_2_EXT_uart_rts_spi_ss0__0__HSIOM_UART)
S#endif /* !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1) */
N#endif /* (UART_2_EXT_RTS_SS0_PIN) */
N
N#if (UART_2_EXT_SS1_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_SS1_HSIOM_REG  (*(reg32 *) UART_2_EXT_spi_ss1__0__HSIOM)
S    #define UART_2_EXT_SS1_HSIOM_PTR  ( (reg32 *) UART_2_EXT_spi_ss1__0__HSIOM)
S    
S    #define UART_2_EXT_SS1_HSIOM_MASK     (UART_2_EXT_spi_ss1__0__HSIOM_MASK)
S    #define UART_2_EXT_SS1_HSIOM_POS      (UART_2_EXT_spi_ss1__0__HSIOM_SHIFT)
S    #define UART_2_EXT_SS1_HSIOM_SEL_GPIO (UART_2_EXT_spi_ss1__0__HSIOM_GPIO)
S    #define UART_2_EXT_SS1_HSIOM_SEL_I2C  (UART_2_EXT_spi_ss1__0__HSIOM_I2C)
S    #define UART_2_EXT_SS1_HSIOM_SEL_SPI  (UART_2_EXT_spi_ss1__0__HSIOM_SPI)
N#endif /* (UART_2_EXT_SS1_PIN) */
N
N#if (UART_2_EXT_SS2_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_SS2_HSIOM_REG     (*(reg32 *) UART_2_EXT_spi_ss2__0__HSIOM)
S    #define UART_2_EXT_SS2_HSIOM_PTR     ( (reg32 *) UART_2_EXT_spi_ss2__0__HSIOM)
S    
S    #define UART_2_EXT_SS2_HSIOM_MASK     (UART_2_EXT_spi_ss2__0__HSIOM_MASK)
S    #define UART_2_EXT_SS2_HSIOM_POS      (UART_2_EXT_spi_ss2__0__HSIOM_SHIFT)
S    #define UART_2_EXT_SS2_HSIOM_SEL_GPIO (UART_2_EXT_spi_ss2__0__HSIOM_GPIO)
S    #define UART_2_EXT_SS2_HSIOM_SEL_I2C  (UART_2_EXT_spi_ss2__0__HSIOM_I2C)
S    #define UART_2_EXT_SS2_HSIOM_SEL_SPI  (UART_2_EXT_spi_ss2__0__HSIOM_SPI)
N#endif /* (UART_2_EXT_SS2_PIN) */
N
N#if (UART_2_EXT_SS3_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_SS3_HSIOM_REG     (*(reg32 *) UART_2_EXT_spi_ss3__0__HSIOM)
S    #define UART_2_EXT_SS3_HSIOM_PTR     ( (reg32 *) UART_2_EXT_spi_ss3__0__HSIOM)
S    
S    #define UART_2_EXT_SS3_HSIOM_MASK     (UART_2_EXT_spi_ss3__0__HSIOM_MASK)
S    #define UART_2_EXT_SS3_HSIOM_POS      (UART_2_EXT_spi_ss3__0__HSIOM_SHIFT)
S    #define UART_2_EXT_SS3_HSIOM_SEL_GPIO (UART_2_EXT_spi_ss3__0__HSIOM_GPIO)
S    #define UART_2_EXT_SS3_HSIOM_SEL_I2C  (UART_2_EXT_spi_ss3__0__HSIOM_I2C)
S    #define UART_2_EXT_SS3_HSIOM_SEL_SPI  (UART_2_EXT_spi_ss3__0__HSIOM_SPI)
N#endif /* (UART_2_EXT_SS3_PIN) */
N
N#if (UART_2_EXT_I2C_PINS)
X#if ((0u == (1u)))
S    #define UART_2_EXT_SCL_HSIOM_REG  (*(reg32 *) UART_2_EXT_scl__0__HSIOM)
S    #define UART_2_EXT_SCL_HSIOM_PTR  ( (reg32 *) UART_2_EXT_scl__0__HSIOM)
S    
S    #define UART_2_EXT_SCL_HSIOM_MASK     (UART_2_EXT_scl__0__HSIOM_MASK)
S    #define UART_2_EXT_SCL_HSIOM_POS      (UART_2_EXT_scl__0__HSIOM_SHIFT)
S    #define UART_2_EXT_SCL_HSIOM_SEL_GPIO (UART_2_EXT_sda__0__HSIOM_GPIO)
S    #define UART_2_EXT_SCL_HSIOM_SEL_I2C  (UART_2_EXT_sda__0__HSIOM_I2C)
S    
S    #define UART_2_EXT_SDA_HSIOM_REG  (*(reg32 *) UART_2_EXT_sda__0__HSIOM)
S    #define UART_2_EXT_SDA_HSIOM_PTR  ( (reg32 *) UART_2_EXT_sda__0__HSIOM)
S    
S    #define UART_2_EXT_SDA_HSIOM_MASK     (UART_2_EXT_sda__0__HSIOM_MASK)
S    #define UART_2_EXT_SDA_HSIOM_POS      (UART_2_EXT_sda__0__HSIOM_SHIFT)
S    #define UART_2_EXT_SDA_HSIOM_SEL_GPIO (UART_2_EXT_sda__0__HSIOM_GPIO)
S    #define UART_2_EXT_SDA_HSIOM_SEL_I2C  (UART_2_EXT_sda__0__HSIOM_I2C)
N#endif /* (UART_2_EXT_I2C_PINS) */
N
N#if (UART_2_EXT_SPI_SLAVE_PINS)
X#if ((0u == (1u)))
S    #define UART_2_EXT_SCLK_S_HSIOM_REG   (*(reg32 *) UART_2_EXT_sclk_s__0__HSIOM)
S    #define UART_2_EXT_SCLK_S_HSIOM_PTR   ( (reg32 *) UART_2_EXT_sclk_s__0__HSIOM)
S    
S    #define UART_2_EXT_SCLK_S_HSIOM_MASK      (UART_2_EXT_sclk_s__0__HSIOM_MASK)
S    #define UART_2_EXT_SCLK_S_HSIOM_POS       (UART_2_EXT_sclk_s__0__HSIOM_SHIFT)
S    #define UART_2_EXT_SCLK_S_HSIOM_SEL_GPIO  (UART_2_EXT_sclk_s__0__HSIOM_GPIO)
S    #define UART_2_EXT_SCLK_S_HSIOM_SEL_SPI   (UART_2_EXT_sclk_s__0__HSIOM_SPI)
S    
S    #define UART_2_EXT_SS0_S_HSIOM_REG    (*(reg32 *) UART_2_EXT_ss0_s__0__HSIOM)
S    #define UART_2_EXT_SS0_S_HSIOM_PTR    ( (reg32 *) UART_2_EXT_ss0_s__0__HSIOM)
S    
S    #define UART_2_EXT_SS0_S_HSIOM_MASK       (UART_2_EXT_ss0_s__0__HSIOM_MASK)
S    #define UART_2_EXT_SS0_S_HSIOM_POS        (UART_2_EXT_ss0_s__0__HSIOM_SHIFT)
S    #define UART_2_EXT_SS0_S_HSIOM_SEL_GPIO   (UART_2_EXT_ss0_s__0__HSIOM_GPIO)  
S    #define UART_2_EXT_SS0_S_HSIOM_SEL_SPI    (UART_2_EXT_ss0_s__0__HSIOM_SPI)
N#endif /* (UART_2_EXT_SPI_SLAVE_PINS) */
N
N#if (UART_2_EXT_SPI_SLAVE_MOSI_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_MOSI_S_HSIOM_REG   (*(reg32 *) UART_2_EXT_mosi_s__0__HSIOM)
S    #define UART_2_EXT_MOSI_S_HSIOM_PTR   ( (reg32 *) UART_2_EXT_mosi_s__0__HSIOM)
S    
S    #define UART_2_EXT_MOSI_S_HSIOM_MASK      (UART_2_EXT_mosi_s__0__HSIOM_MASK)
S    #define UART_2_EXT_MOSI_S_HSIOM_POS       (UART_2_EXT_mosi_s__0__HSIOM_SHIFT)
S    #define UART_2_EXT_MOSI_S_HSIOM_SEL_GPIO  (UART_2_EXT_mosi_s__0__HSIOM_GPIO)
S    #define UART_2_EXT_MOSI_S_HSIOM_SEL_SPI   (UART_2_EXT_mosi_s__0__HSIOM_SPI)
N#endif /* (UART_2_EXT_SPI_SLAVE_MOSI_PIN) */
N
N#if (UART_2_EXT_SPI_SLAVE_MISO_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_MISO_S_HSIOM_REG   (*(reg32 *) UART_2_EXT_miso_s__0__HSIOM)
S    #define UART_2_EXT_MISO_S_HSIOM_PTR   ( (reg32 *) UART_2_EXT_miso_s__0__HSIOM)
S    
S    #define UART_2_EXT_MISO_S_HSIOM_MASK      (UART_2_EXT_miso_s__0__HSIOM_MASK)
S    #define UART_2_EXT_MISO_S_HSIOM_POS       (UART_2_EXT_miso_s__0__HSIOM_SHIFT)
S    #define UART_2_EXT_MISO_S_HSIOM_SEL_GPIO  (UART_2_EXT_miso_s__0__HSIOM_GPIO)
S    #define UART_2_EXT_MISO_S_HSIOM_SEL_SPI   (UART_2_EXT_miso_s__0__HSIOM_SPI)
N#endif /* (UART_2_EXT_SPI_SLAVE_MISO_PIN) */
N
N#if (UART_2_EXT_SPI_MASTER_MISO_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_MISO_M_HSIOM_REG   (*(reg32 *) UART_2_EXT_miso_m__0__HSIOM)
S    #define UART_2_EXT_MISO_M_HSIOM_PTR   ( (reg32 *) UART_2_EXT_miso_m__0__HSIOM)
S    
S    #define UART_2_EXT_MISO_M_HSIOM_MASK      (UART_2_EXT_miso_m__0__HSIOM_MASK)
S    #define UART_2_EXT_MISO_M_HSIOM_POS       (UART_2_EXT_miso_m__0__HSIOM_SHIFT)
S    #define UART_2_EXT_MISO_M_HSIOM_SEL_GPIO  (UART_2_EXT_miso_m__0__HSIOM_GPIO)
S    #define UART_2_EXT_MISO_M_HSIOM_SEL_SPI   (UART_2_EXT_miso_m__0__HSIOM_SPI)
N#endif /* (UART_2_EXT_SPI_MASTER_MISO_PIN) */
N
N#if (UART_2_EXT_SPI_MASTER_MOSI_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_MOSI_M_HSIOM_REG   (*(reg32 *) UART_2_EXT_mosi_m__0__HSIOM)
S    #define UART_2_EXT_MOSI_M_HSIOM_PTR   ( (reg32 *) UART_2_EXT_mosi_m__0__HSIOM)
S    
S    #define UART_2_EXT_MOSI_M_HSIOM_MASK      (UART_2_EXT_mosi_m__0__HSIOM_MASK)
S    #define UART_2_EXT_MOSI_M_HSIOM_POS       (UART_2_EXT_mosi_m__0__HSIOM_SHIFT)
S    #define UART_2_EXT_MOSI_M_HSIOM_SEL_GPIO  (UART_2_EXT_mosi_m__0__HSIOM_GPIO)
S    #define UART_2_EXT_MOSI_M_HSIOM_SEL_SPI   (UART_2_EXT_mosi_m__0__HSIOM_SPI)
N#endif /* (UART_2_EXT_SPI_MASTER_MOSI_PIN) */
N
N#if (UART_2_EXT_SPI_MASTER_SCLK_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_SCLK_M_HSIOM_REG   (*(reg32 *) UART_2_EXT_sclk_m__0__HSIOM)
S    #define UART_2_EXT_SCLK_M_HSIOM_PTR   ( (reg32 *) UART_2_EXT_sclk_m__0__HSIOM)
S    
S    #define UART_2_EXT_SCLK_M_HSIOM_MASK      (UART_2_EXT_sclk_m__0__HSIOM_MASK)
S    #define UART_2_EXT_SCLK_M_HSIOM_POS       (UART_2_EXT_sclk_m__0__HSIOM_SHIFT)
S    #define UART_2_EXT_SCLK_M_HSIOM_SEL_GPIO  (UART_2_EXT_sclk_m__0__HSIOM_GPIO)
S    #define UART_2_EXT_SCLK_M_HSIOM_SEL_SPI   (UART_2_EXT_sclk_m__0__HSIOM_SPI)
N#endif /* (UART_2_EXT_SPI_MASTER_SCLK_PIN) */
N
N#if (UART_2_EXT_SPI_MASTER_SS0_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_SS0_M_HSIOM_REG    (*(reg32 *) UART_2_EXT_ss0_m__0__HSIOM)
S    #define UART_2_EXT_SS0_M_HSIOM_PTR    ( (reg32 *) UART_2_EXT_ss0_m__0__HSIOM)
S    
S    #define UART_2_EXT_SS0_M_HSIOM_MASK       (UART_2_EXT_ss0_m__0__HSIOM_MASK)
S    #define UART_2_EXT_SS0_M_HSIOM_POS        (UART_2_EXT_ss0_m__0__HSIOM_SHIFT)
S    #define UART_2_EXT_SS0_M_HSIOM_SEL_GPIO   (UART_2_EXT_ss0_m__0__HSIOM_GPIO)
S    #define UART_2_EXT_SS0_M_HSIOM_SEL_SPI    (UART_2_EXT_ss0_m__0__HSIOM_SPI)
N#endif /* (UART_2_EXT_SPI_MASTER_SS0_PIN) */
N
N#if (UART_2_EXT_SPI_MASTER_SS1_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_SS1_M_HSIOM_REG    (*(reg32 *) UART_2_EXT_ss1_m__0__HSIOM)
S    #define UART_2_EXT_SS1_M_HSIOM_PTR    ( (reg32 *) UART_2_EXT_ss1_m__0__HSIOM)
S    
S    #define UART_2_EXT_SS1_M_HSIOM_MASK       (UART_2_EXT_ss1_m__0__HSIOM_MASK)
S    #define UART_2_EXT_SS1_M_HSIOM_POS        (UART_2_EXT_ss1_m__0__HSIOM_SHIFT)
S    #define UART_2_EXT_SS1_M_HSIOM_SEL_GPIO   (UART_2_EXT_ss1_m__0__HSIOM_GPIO)
S    #define UART_2_EXT_SS1_M_HSIOM_SEL_SPI    (UART_2_EXT_ss1_m__0__HSIOM_SPI)
N#endif /* (UART_2_EXT_SPI_MASTER_SS1_PIN) */
N
N#if (UART_2_EXT_SPI_MASTER_SS2_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_SS2_M_HSIOM_REG    (*(reg32 *) UART_2_EXT_ss2_m__0__HSIOM)
S    #define UART_2_EXT_SS2_M_HSIOM_PTR    ( (reg32 *) UART_2_EXT_ss2_m__0__HSIOM)
S    
S    #define UART_2_EXT_SS2_M_HSIOM_MASK       (UART_2_EXT_ss2_m__0__HSIOM_MASK)
S    #define UART_2_EXT_SS2_M_HSIOM_POS        (UART_2_EXT_ss2_m__0__HSIOM_SHIFT)
S    #define UART_2_EXT_SS2_M_HSIOM_SEL_GPIO   (UART_2_EXT_ss2_m__0__HSIOM_GPIO)
S    #define UART_2_EXT_SS2_M_HSIOM_SEL_SPI    (UART_2_EXT_ss2_m__0__HSIOM_SPI)
N#endif /* (UART_2_EXT_SPI_MASTER_SS2_PIN) */
N
N#if (UART_2_EXT_SPI_MASTER_SS3_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_SS3_M_HSIOM_REG    (*(reg32 *) UART_2_EXT_ss3_m__0__HSIOM)
S    #define UART_2_EXT_SS3_M_HSIOM_PTR    ( (reg32 *) UART_2_EXT_ss3_m__0__HSIOM)
S    
S    #define UART_2_EXT_SS3_M_HSIOM_MASK      (UART_2_EXT_ss3_m__0__HSIOM_MASK)
S    #define UART_2_EXT_SS3_M_HSIOM_POS       (UART_2_EXT_ss3_m__0__HSIOM_SHIFT)
S    #define UART_2_EXT_SS3_M_HSIOM_SEL_GPIO  (UART_2_EXT_ss3_m__0__HSIOM_GPIO)
S    #define UART_2_EXT_SS3_M_HSIOM_SEL_SPI   (UART_2_EXT_ss3_m__0__HSIOM_SPI)
N#endif /* (UART_2_EXT_SPI_MASTER_SS3_PIN) */
N
N#if (UART_2_EXT_UART_RX_PIN)
X#if ((0u == (0u)))
N    #define UART_2_EXT_RX_HSIOM_REG   (*(reg32 *) UART_2_EXT_rx__0__HSIOM)
N    #define UART_2_EXT_RX_HSIOM_PTR   ( (reg32 *) UART_2_EXT_rx__0__HSIOM)
N    
N    #define UART_2_EXT_RX_HSIOM_MASK      (UART_2_EXT_rx__0__HSIOM_MASK)
N    #define UART_2_EXT_RX_HSIOM_POS       (UART_2_EXT_rx__0__HSIOM_SHIFT)
N    #define UART_2_EXT_RX_HSIOM_SEL_GPIO  (UART_2_EXT_rx__0__HSIOM_GPIO)
N    #define UART_2_EXT_RX_HSIOM_SEL_UART  (UART_2_EXT_rx__0__HSIOM_UART)
N#endif /* (UART_2_EXT_UART_RX_PIN) */
N
N#if (UART_2_EXT_UART_RX_WAKE_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_RX_WAKE_HSIOM_REG   (*(reg32 *) UART_2_EXT_rx_wake__0__HSIOM)
S    #define UART_2_EXT_RX_WAKE_HSIOM_PTR   ( (reg32 *) UART_2_EXT_rx_wake__0__HSIOM)
S    
S    #define UART_2_EXT_RX_WAKE_HSIOM_MASK      (UART_2_EXT_rx_wake__0__HSIOM_MASK)
S    #define UART_2_EXT_RX_WAKE_HSIOM_POS       (UART_2_EXT_rx_wake__0__HSIOM_SHIFT)
S    #define UART_2_EXT_RX_WAKE_HSIOM_SEL_GPIO  (UART_2_EXT_rx_wake__0__HSIOM_GPIO)
S    #define UART_2_EXT_RX_WAKE_HSIOM_SEL_UART  (UART_2_EXT_rx_wake__0__HSIOM_UART)
N#endif /* (UART_2_EXT_UART_WAKE_RX_PIN) */
N
N#if (UART_2_EXT_UART_CTS_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_CTS_HSIOM_REG   (*(reg32 *) UART_2_EXT_cts__0__HSIOM)
S    #define UART_2_EXT_CTS_HSIOM_PTR   ( (reg32 *) UART_2_EXT_cts__0__HSIOM)
S    
S    #define UART_2_EXT_CTS_HSIOM_MASK      (UART_2_EXT_cts__0__HSIOM_MASK)
S    #define UART_2_EXT_CTS_HSIOM_POS       (UART_2_EXT_cts__0__HSIOM_SHIFT)
S    #define UART_2_EXT_CTS_HSIOM_SEL_GPIO  (UART_2_EXT_cts__0__HSIOM_GPIO)
S    #define UART_2_EXT_CTS_HSIOM_SEL_UART  (UART_2_EXT_cts__0__HSIOM_UART)
N#endif /* (UART_2_EXT_UART_CTS_PIN) */
N
N#if (UART_2_EXT_UART_TX_PIN)
X#if ((0u == (0u)))
N    #define UART_2_EXT_TX_HSIOM_REG   (*(reg32 *) UART_2_EXT_tx__0__HSIOM)
N    #define UART_2_EXT_TX_HSIOM_PTR   ( (reg32 *) UART_2_EXT_tx__0__HSIOM)
N    
N    #define UART_2_EXT_TX_HSIOM_MASK      (UART_2_EXT_tx__0__HSIOM_MASK)
N    #define UART_2_EXT_TX_HSIOM_POS       (UART_2_EXT_tx__0__HSIOM_SHIFT)
N    #define UART_2_EXT_TX_HSIOM_SEL_GPIO  (UART_2_EXT_tx__0__HSIOM_GPIO)
N    #define UART_2_EXT_TX_HSIOM_SEL_UART  (UART_2_EXT_tx__0__HSIOM_UART)
N#endif /* (UART_2_EXT_UART_TX_PIN) */
N
N#if (UART_2_EXT_UART_RX_TX_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_RX_TX_HSIOM_REG   (*(reg32 *) UART_2_EXT_rx_tx__0__HSIOM)
S    #define UART_2_EXT_RX_TX_HSIOM_PTR   ( (reg32 *) UART_2_EXT_rx_tx__0__HSIOM)
S    
S    #define UART_2_EXT_RX_TX_HSIOM_MASK      (UART_2_EXT_rx_tx__0__HSIOM_MASK)
S    #define UART_2_EXT_RX_TX_HSIOM_POS       (UART_2_EXT_rx_tx__0__HSIOM_SHIFT)
S    #define UART_2_EXT_RX_TX_HSIOM_SEL_GPIO  (UART_2_EXT_rx_tx__0__HSIOM_GPIO)
S    #define UART_2_EXT_RX_TX_HSIOM_SEL_UART  (UART_2_EXT_rx_tx__0__HSIOM_UART)
N#endif /* (UART_2_EXT_UART_RX_TX_PIN) */
N
N#if (UART_2_EXT_UART_RTS_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_RTS_HSIOM_REG      (*(reg32 *) UART_2_EXT_rts__0__HSIOM)
S    #define UART_2_EXT_RTS_HSIOM_PTR      ( (reg32 *) UART_2_EXT_rts__0__HSIOM)
S    
S    #define UART_2_EXT_RTS_HSIOM_MASK     (UART_2_EXT_rts__0__HSIOM_MASK)
S    #define UART_2_EXT_RTS_HSIOM_POS      (UART_2_EXT_rts__0__HSIOM_SHIFT)    
S    #define UART_2_EXT_RTS_HSIOM_SEL_GPIO (UART_2_EXT_rts__0__HSIOM_GPIO)
S    #define UART_2_EXT_RTS_HSIOM_SEL_UART (UART_2_EXT_rts__0__HSIOM_UART)    
N#endif /* (UART_2_EXT_UART_RTS_PIN) */
N
N
N/***************************************
N*        Registers Constants
N***************************************/
N
N/* HSIOM switch values. */ 
N#define UART_2_EXT_HSIOM_DEF_SEL      (0x00u)
N#define UART_2_EXT_HSIOM_GPIO_SEL     (0x00u)
N/* The HSIOM values provided below are valid only for UART_2_EXT_CY_SCBIP_V0 
N* and UART_2_EXT_CY_SCBIP_V1. It is not recommended to use them for 
N* UART_2_EXT_CY_SCBIP_V2. Use pin name specific HSIOM constants provided 
N* above instead for any SCB IP block version.
N*/
N#define UART_2_EXT_HSIOM_UART_SEL     (0x09u)
N#define UART_2_EXT_HSIOM_I2C_SEL      (0x0Eu)
N#define UART_2_EXT_HSIOM_SPI_SEL      (0x0Fu)
N
N/* Pins settings index. */
N#define UART_2_EXT_RX_WAKE_SCL_MOSI_PIN_INDEX   (0u)
N#define UART_2_EXT_RX_SCL_MOSI_PIN_INDEX       (0u)
N#define UART_2_EXT_TX_SDA_MISO_PIN_INDEX       (1u)
N#define UART_2_EXT_CTS_SCLK_PIN_INDEX       (2u)
N#define UART_2_EXT_RTS_SS0_PIN_INDEX       (3u)
N#define UART_2_EXT_SS1_PIN_INDEX                  (4u)
N#define UART_2_EXT_SS2_PIN_INDEX                  (5u)
N#define UART_2_EXT_SS3_PIN_INDEX                  (6u)
N
N/* Pins settings mask. */
N#define UART_2_EXT_RX_WAKE_SCL_MOSI_PIN_MASK ((uint32) 0x01u << UART_2_EXT_RX_WAKE_SCL_MOSI_PIN_INDEX)
N#define UART_2_EXT_RX_SCL_MOSI_PIN_MASK     ((uint32) 0x01u << UART_2_EXT_RX_SCL_MOSI_PIN_INDEX)
N#define UART_2_EXT_TX_SDA_MISO_PIN_MASK     ((uint32) 0x01u << UART_2_EXT_TX_SDA_MISO_PIN_INDEX)
N#define UART_2_EXT_CTS_SCLK_PIN_MASK     ((uint32) 0x01u << UART_2_EXT_CTS_SCLK_PIN_INDEX)
N#define UART_2_EXT_RTS_SS0_PIN_MASK     ((uint32) 0x01u << UART_2_EXT_RTS_SS0_PIN_INDEX)
N#define UART_2_EXT_SS1_PIN_MASK                ((uint32) 0x01u << UART_2_EXT_SS1_PIN_INDEX)
N#define UART_2_EXT_SS2_PIN_MASK                ((uint32) 0x01u << UART_2_EXT_SS2_PIN_INDEX)
N#define UART_2_EXT_SS3_PIN_MASK                ((uint32) 0x01u << UART_2_EXT_SS3_PIN_INDEX)
N
N/* Pin interrupt constants. */
N#define UART_2_EXT_INTCFG_TYPE_MASK           (0x03u)
N#define UART_2_EXT_INTCFG_TYPE_FALLING_EDGE   (0x02u)
N
N/* Pin Drive Mode constants. */
N#define UART_2_EXT_PIN_DM_ALG_HIZ  (0u)
N#define UART_2_EXT_PIN_DM_DIG_HIZ  (1u)
N#define UART_2_EXT_PIN_DM_OD_LO    (4u)
N#define UART_2_EXT_PIN_DM_STRONG   (6u)
N
N
N/***************************************
N*          Macro Definitions
N***************************************/
N
N/* Return drive mode of the pin */
N#define UART_2_EXT_DM_MASK    (0x7u)
N#define UART_2_EXT_DM_SIZE    (3u)
N#define UART_2_EXT_GET_P4_PIN_DM(reg, pos) \
N    ( ((reg) & (uint32) ((uint32) UART_2_EXT_DM_MASK << (UART_2_EXT_DM_SIZE * (pos)))) >> \
N                                                              (UART_2_EXT_DM_SIZE * (pos)) )
X#define UART_2_EXT_GET_P4_PIN_DM(reg, pos)     ( ((reg) & (uint32) ((uint32) UART_2_EXT_DM_MASK << (UART_2_EXT_DM_SIZE * (pos)))) >>                                                               (UART_2_EXT_DM_SIZE * (pos)) )
N
N#if (UART_2_EXT_TX_SDA_MISO_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_CHECK_TX_SDA_MISO_PIN_USED \
S                (UART_2_EXT_PIN_DM_ALG_HIZ != \
S                    UART_2_EXT_GET_P4_PIN_DM(UART_2_EXT_uart_tx_i2c_sda_spi_miso_PC, \
S                                                   UART_2_EXT_uart_tx_i2c_sda_spi_miso_SHIFT))
X    #define UART_2_EXT_CHECK_TX_SDA_MISO_PIN_USED                 (UART_2_EXT_PIN_DM_ALG_HIZ !=                     UART_2_EXT_GET_P4_PIN_DM(UART_2_EXT_uart_tx_i2c_sda_spi_miso_PC,                                                    UART_2_EXT_uart_tx_i2c_sda_spi_miso_SHIFT))
N#endif /* (UART_2_EXT_TX_SDA_MISO_PIN) */
N
N#if (UART_2_EXT_RTS_SS0_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_CHECK_RTS_SS0_PIN_USED \
S                (UART_2_EXT_PIN_DM_ALG_HIZ != \
S                    UART_2_EXT_GET_P4_PIN_DM(UART_2_EXT_uart_rts_spi_ss0_PC, \
S                                                   UART_2_EXT_uart_rts_spi_ss0_SHIFT))
X    #define UART_2_EXT_CHECK_RTS_SS0_PIN_USED                 (UART_2_EXT_PIN_DM_ALG_HIZ !=                     UART_2_EXT_GET_P4_PIN_DM(UART_2_EXT_uart_rts_spi_ss0_PC,                                                    UART_2_EXT_uart_rts_spi_ss0_SHIFT))
N#endif /* (UART_2_EXT_RTS_SS0_PIN) */
N
N/* Set bits-mask in register */
N#define UART_2_EXT_SET_REGISTER_BITS(reg, mask, pos, mode) \
N                    do                                           \
N                    {                                            \
N                        (reg) = (((reg) & ((uint32) ~(uint32) (mask))) | ((uint32) ((uint32) (mode) << (pos)))); \
N                    }while(0)
X#define UART_2_EXT_SET_REGISTER_BITS(reg, mask, pos, mode)                     do                                                               {                                                                    (reg) = (((reg) & ((uint32) ~(uint32) (mask))) | ((uint32) ((uint32) (mode) << (pos))));                     }while(0)
N
N/* Set bit in the register */
N#define UART_2_EXT_SET_REGISTER_BIT(reg, mask, val) \
N                    ((val) ? ((reg) |= (mask)) : ((reg) &= ((uint32) ~((uint32) (mask)))))
X#define UART_2_EXT_SET_REGISTER_BIT(reg, mask, val)                     ((val) ? ((reg) |= (mask)) : ((reg) &= ((uint32) ~((uint32) (mask)))))
N
N#define UART_2_EXT_SET_HSIOM_SEL(reg, mask, pos, sel) UART_2_EXT_SET_REGISTER_BITS(reg, mask, pos, sel)
N#define UART_2_EXT_SET_INCFG_TYPE(reg, mask, pos, intType) \
N                                                        UART_2_EXT_SET_REGISTER_BITS(reg, mask, pos, intType)
X#define UART_2_EXT_SET_INCFG_TYPE(reg, mask, pos, intType)                                                         UART_2_EXT_SET_REGISTER_BITS(reg, mask, pos, intType)
N#define UART_2_EXT_SET_INP_DIS(reg, mask, val) UART_2_EXT_SET_REGISTER_BIT(reg, mask, val)
N
N/* UART_2_EXT_SET_I2C_SCL_DR(val) - Sets I2C SCL DR register.
N*  UART_2_EXT_SET_I2C_SCL_HSIOM_SEL(sel) - Sets I2C SCL HSIOM settings.
N*/
N/* SCB I2C: scl signal */
N#if (UART_2_EXT_CY_SCBIP_V0)
X#if ((2 == 0u))
S#if (UART_2_EXT_I2C_PINS)
S    #define UART_2_EXT_SET_I2C_SCL_DR(val) UART_2_EXT_scl_Write(val)
S
S    #define UART_2_EXT_SET_I2C_SCL_HSIOM_SEL(sel) \
S                          UART_2_EXT_SET_HSIOM_SEL(UART_2_EXT_SCL_HSIOM_REG,  \
S                                                         UART_2_EXT_SCL_HSIOM_MASK, \
S                                                         UART_2_EXT_SCL_HSIOM_POS,  \
S                                                         (sel))
X    #define UART_2_EXT_SET_I2C_SCL_HSIOM_SEL(sel)                           UART_2_EXT_SET_HSIOM_SEL(UART_2_EXT_SCL_HSIOM_REG,                                                           UART_2_EXT_SCL_HSIOM_MASK,                                                          UART_2_EXT_SCL_HSIOM_POS,                                                           (sel))
S    #define UART_2_EXT_WAIT_SCL_SET_HIGH  (0u == UART_2_EXT_scl_Read())
S
S/* Unconfigured SCB: scl signal */
S#elif (UART_2_EXT_RX_WAKE_SCL_MOSI_PIN)
S    #define UART_2_EXT_SET_I2C_SCL_DR(val) \
S                            UART_2_EXT_uart_rx_wake_i2c_scl_spi_mosi_Write(val)
X    #define UART_2_EXT_SET_I2C_SCL_DR(val)                             UART_2_EXT_uart_rx_wake_i2c_scl_spi_mosi_Write(val)
S
S    #define UART_2_EXT_SET_I2C_SCL_HSIOM_SEL(sel) \
S                    UART_2_EXT_SET_HSIOM_SEL(UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_REG,  \
S                                                   UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_MASK, \
S                                                   UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_POS,  \
S                                                   (sel))
X    #define UART_2_EXT_SET_I2C_SCL_HSIOM_SEL(sel)                     UART_2_EXT_SET_HSIOM_SEL(UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_REG,                                                     UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_MASK,                                                    UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_POS,                                                     (sel))
S
S    #define UART_2_EXT_WAIT_SCL_SET_HIGH  (0u == UART_2_EXT_uart_rx_wake_i2c_scl_spi_mosi_Read())
S
S#elif (UART_2_EXT_RX_SCL_MOSI_PIN)
S    #define UART_2_EXT_SET_I2C_SCL_DR(val) \
S                            UART_2_EXT_uart_rx_i2c_scl_spi_mosi_Write(val)
X    #define UART_2_EXT_SET_I2C_SCL_DR(val)                             UART_2_EXT_uart_rx_i2c_scl_spi_mosi_Write(val)
S
S
S    #define UART_2_EXT_SET_I2C_SCL_HSIOM_SEL(sel) \
S                            UART_2_EXT_SET_HSIOM_SEL(UART_2_EXT_RX_SCL_MOSI_HSIOM_REG,  \
S                                                           UART_2_EXT_RX_SCL_MOSI_HSIOM_MASK, \
S                                                           UART_2_EXT_RX_SCL_MOSI_HSIOM_POS,  \
S                                                           (sel))
X    #define UART_2_EXT_SET_I2C_SCL_HSIOM_SEL(sel)                             UART_2_EXT_SET_HSIOM_SEL(UART_2_EXT_RX_SCL_MOSI_HSIOM_REG,                                                             UART_2_EXT_RX_SCL_MOSI_HSIOM_MASK,                                                            UART_2_EXT_RX_SCL_MOSI_HSIOM_POS,                                                             (sel))
S
S    #define UART_2_EXT_WAIT_SCL_SET_HIGH  (0u == UART_2_EXT_uart_rx_i2c_scl_spi_mosi_Read())
S
S#else
S    #define UART_2_EXT_SET_I2C_SCL_DR(val)        do{ /* Does nothing */ }while(0)
S    #define UART_2_EXT_SET_I2C_SCL_HSIOM_SEL(sel) do{ /* Does nothing */ }while(0)
S
S    #define UART_2_EXT_WAIT_SCL_SET_HIGH  (0u)
S#endif /* (UART_2_EXT_I2C_PINS) */
S
S/* SCB I2C: sda signal */
S#if (UART_2_EXT_I2C_PINS)
S    #define UART_2_EXT_WAIT_SDA_SET_HIGH  (0u == UART_2_EXT_sda_Read())
S/* Unconfigured SCB: sda signal */
S#elif (UART_2_EXT_TX_SDA_MISO_PIN)
S    #define UART_2_EXT_WAIT_SDA_SET_HIGH  (0u == UART_2_EXT_uart_tx_i2c_sda_spi_miso_Read())
S#else
S    #define UART_2_EXT_WAIT_SDA_SET_HIGH  (0u)
S#endif /* (UART_2_EXT_MOSI_SCL_RX_PIN) */
N#endif /* (UART_2_EXT_CY_SCBIP_V0) */
N
N/* Clear UART wakeup source */
N#if (UART_2_EXT_RX_SCL_MOSI_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_CLEAR_UART_RX_WAKE_INTR        do{ /* Does nothing */ }while(0)
S    
S#elif (UART_2_EXT_RX_WAKE_SCL_MOSI_PIN)
X#elif ((0u == (1u)))
S    #define UART_2_EXT_CLEAR_UART_RX_WAKE_INTR \
S            do{                                      \
S                (void) UART_2_EXT_uart_rx_wake_i2c_scl_spi_mosi_ClearInterrupt(); \
S            }while(0)
X    #define UART_2_EXT_CLEAR_UART_RX_WAKE_INTR             do{                                                      (void) UART_2_EXT_uart_rx_wake_i2c_scl_spi_mosi_ClearInterrupt();             }while(0)
S
S#elif(UART_2_EXT_UART_RX_WAKE_PIN)
X#elif((0u == (1u)))
S    #define UART_2_EXT_CLEAR_UART_RX_WAKE_INTR \
S            do{                                      \
S                (void) UART_2_EXT_rx_wake_ClearInterrupt(); \
S            }while(0)
X    #define UART_2_EXT_CLEAR_UART_RX_WAKE_INTR             do{                                                      (void) UART_2_EXT_rx_wake_ClearInterrupt();             }while(0)
N#else
N#endif /* (UART_2_EXT_RX_SCL_MOSI_PIN) */
N
N
N/***************************************
N* The following code is DEPRECATED and
N* must not be used.
N***************************************/
N
N/* Unconfigured pins */
N#define UART_2_EXT_REMOVE_MOSI_SCL_RX_WAKE_PIN    UART_2_EXT_REMOVE_RX_WAKE_SCL_MOSI_PIN
N#define UART_2_EXT_REMOVE_MOSI_SCL_RX_PIN         UART_2_EXT_REMOVE_RX_SCL_MOSI_PIN
N#define UART_2_EXT_REMOVE_MISO_SDA_TX_PIN         UART_2_EXT_REMOVE_TX_SDA_MISO_PIN
N#ifndef UART_2_EXT_REMOVE_SCLK_PIN
N#define UART_2_EXT_REMOVE_SCLK_PIN                UART_2_EXT_REMOVE_CTS_SCLK_PIN
N#endif /* UART_2_EXT_REMOVE_SCLK_PIN */
N#ifndef UART_2_EXT_REMOVE_SS0_PIN
N#define UART_2_EXT_REMOVE_SS0_PIN                 UART_2_EXT_REMOVE_RTS_SS0_PIN
N#endif /* UART_2_EXT_REMOVE_SS0_PIN */
N
N/* Unconfigured pins */
N#define UART_2_EXT_MOSI_SCL_RX_WAKE_PIN   UART_2_EXT_RX_WAKE_SCL_MOSI_PIN
N#define UART_2_EXT_MOSI_SCL_RX_PIN        UART_2_EXT_RX_SCL_MOSI_PIN
N#define UART_2_EXT_MISO_SDA_TX_PIN        UART_2_EXT_TX_SDA_MISO_PIN
N#ifndef UART_2_EXT_SCLK_PIN
N#define UART_2_EXT_SCLK_PIN               UART_2_EXT_CTS_SCLK_PIN
N#endif /* UART_2_EXT_SCLK_PIN */
N#ifndef UART_2_EXT_SS0_PIN
N#define UART_2_EXT_SS0_PIN                UART_2_EXT_RTS_SS0_PIN
N#endif /* UART_2_EXT_SS0_PIN */
N
N#if (UART_2_EXT_MOSI_SCL_RX_WAKE_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_MOSI_SCL_RX_WAKE_HSIOM_REG     UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define UART_2_EXT_MOSI_SCL_RX_WAKE_HSIOM_PTR     UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define UART_2_EXT_MOSI_SCL_RX_WAKE_HSIOM_MASK    UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define UART_2_EXT_MOSI_SCL_RX_WAKE_HSIOM_POS     UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_REG
S
S    #define UART_2_EXT_MOSI_SCL_RX_WAKE_INTCFG_REG    UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define UART_2_EXT_MOSI_SCL_RX_WAKE_INTCFG_PTR    UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_REG
S
S    #define UART_2_EXT_MOSI_SCL_RX_WAKE_INTCFG_TYPE_POS   UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define UART_2_EXT_MOSI_SCL_RX_WAKE_INTCFG_TYPE_MASK  UART_2_EXT_RX_WAKE_SCL_MOSI_HSIOM_REG
N#endif /* (UART_2_EXT_RX_WAKE_SCL_MOSI_PIN) */
N
N#if (UART_2_EXT_MOSI_SCL_RX_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_MOSI_SCL_RX_HSIOM_REG      UART_2_EXT_RX_SCL_MOSI_HSIOM_REG
S    #define UART_2_EXT_MOSI_SCL_RX_HSIOM_PTR      UART_2_EXT_RX_SCL_MOSI_HSIOM_PTR
S    #define UART_2_EXT_MOSI_SCL_RX_HSIOM_MASK     UART_2_EXT_RX_SCL_MOSI_HSIOM_MASK
S    #define UART_2_EXT_MOSI_SCL_RX_HSIOM_POS      UART_2_EXT_RX_SCL_MOSI_HSIOM_POS
N#endif /* (UART_2_EXT_MOSI_SCL_RX_PIN) */
N
N#if (UART_2_EXT_MISO_SDA_TX_PIN)
X#if ((0u == (1u)))
S    #define UART_2_EXT_MISO_SDA_TX_HSIOM_REG      UART_2_EXT_TX_SDA_MISO_HSIOM_REG
S    #define UART_2_EXT_MISO_SDA_TX_HSIOM_PTR      UART_2_EXT_TX_SDA_MISO_HSIOM_REG
S    #define UART_2_EXT_MISO_SDA_TX_HSIOM_MASK     UART_2_EXT_TX_SDA_MISO_HSIOM_REG
S    #define UART_2_EXT_MISO_SDA_TX_HSIOM_POS      UART_2_EXT_TX_SDA_MISO_HSIOM_REG
N#endif /* (UART_2_EXT_MISO_SDA_TX_PIN_PIN) */
N
N#if (UART_2_EXT_SCLK_PIN)
X#if ((0u == (1u)))
S    #ifndef UART_2_EXT_SCLK_HSIOM_REG
S    #define UART_2_EXT_SCLK_HSIOM_REG     UART_2_EXT_CTS_SCLK_HSIOM_REG
S    #define UART_2_EXT_SCLK_HSIOM_PTR     UART_2_EXT_CTS_SCLK_HSIOM_PTR
S    #define UART_2_EXT_SCLK_HSIOM_MASK    UART_2_EXT_CTS_SCLK_HSIOM_MASK
S    #define UART_2_EXT_SCLK_HSIOM_POS     UART_2_EXT_CTS_SCLK_HSIOM_POS
S    #endif /* UART_2_EXT_SCLK_HSIOM_REG */
N#endif /* (UART_2_EXT_SCLK_PIN) */
N
N#if (UART_2_EXT_SS0_PIN)
X#if ((0u == (1u)))
S    #ifndef UART_2_EXT_SS0_HSIOM_REG
S    #define UART_2_EXT_SS0_HSIOM_REG      UART_2_EXT_RTS_SS0_HSIOM_REG
S    #define UART_2_EXT_SS0_HSIOM_PTR      UART_2_EXT_RTS_SS0_HSIOM_PTR
S    #define UART_2_EXT_SS0_HSIOM_MASK     UART_2_EXT_RTS_SS0_HSIOM_MASK
S    #define UART_2_EXT_SS0_HSIOM_POS      UART_2_EXT_RTS_SS0_HSIOM_POS
S    #endif /* UART_2_EXT_SS0_HSIOM_REG */
N#endif /* (UART_2_EXT_SS0_PIN) */
N
N#define UART_2_EXT_MOSI_SCL_RX_WAKE_PIN_INDEX UART_2_EXT_RX_WAKE_SCL_MOSI_PIN_INDEX
N#define UART_2_EXT_MOSI_SCL_RX_PIN_INDEX      UART_2_EXT_RX_SCL_MOSI_PIN_INDEX
N#define UART_2_EXT_MISO_SDA_TX_PIN_INDEX      UART_2_EXT_TX_SDA_MISO_PIN_INDEX
N#ifndef UART_2_EXT_SCLK_PIN_INDEX
N#define UART_2_EXT_SCLK_PIN_INDEX             UART_2_EXT_CTS_SCLK_PIN_INDEX
N#endif /* UART_2_EXT_SCLK_PIN_INDEX */
N#ifndef UART_2_EXT_SS0_PIN_INDEX
N#define UART_2_EXT_SS0_PIN_INDEX              UART_2_EXT_RTS_SS0_PIN_INDEX
N#endif /* UART_2_EXT_SS0_PIN_INDEX */
N
N#define UART_2_EXT_MOSI_SCL_RX_WAKE_PIN_MASK UART_2_EXT_RX_WAKE_SCL_MOSI_PIN_MASK
N#define UART_2_EXT_MOSI_SCL_RX_PIN_MASK      UART_2_EXT_RX_SCL_MOSI_PIN_MASK
N#define UART_2_EXT_MISO_SDA_TX_PIN_MASK      UART_2_EXT_TX_SDA_MISO_PIN_MASK
N#ifndef UART_2_EXT_SCLK_PIN_MASK
N#define UART_2_EXT_SCLK_PIN_MASK             UART_2_EXT_CTS_SCLK_PIN_MASK
N#endif /* UART_2_EXT_SCLK_PIN_MASK */
N#ifndef UART_2_EXT_SS0_PIN_MASK
N#define UART_2_EXT_SS0_PIN_MASK              UART_2_EXT_RTS_SS0_PIN_MASK
N#endif /* UART_2_EXT_SS0_PIN_MASK */
N
N#endif /* (CY_SCB_PINS_UART_2_EXT_H) */
N
N
N/* [] END OF FILE */
L 86 "Generated_Source\PSoC4\UART_2_EXT.h" 2
N
N#if (UART_2_EXT_SCB_CLK_INTERNAL)
X#if ((0u == (0u)))
N    #include "UART_2_EXT_SCBCLK.h"
L 1 "Generated_Source\PSoC4\UART_2_EXT_SCBCLK.h" 1
N/*******************************************************************************
N* File Name: UART_2_EXT_SCBCLK.h
N* Version 2.20
N*
N*  Description:
N*   Provides the function and constant definitions for the clock component.
N*
N*  Note:
N*
N********************************************************************************
N* Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_CLOCK_UART_2_EXT_SCBCLK_H)
X#if !0L
N#define CY_CLOCK_UART_2_EXT_SCBCLK_H
N
N#include <cytypes.h>
N#include <cyfitter.h>
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N#if defined CYREG_PERI_DIV_CMD
X#if 1L
N
Nvoid UART_2_EXT_SCBCLK_StartEx(uint32 alignClkDiv);
N#define UART_2_EXT_SCBCLK_Start() \
N    UART_2_EXT_SCBCLK_StartEx(UART_2_EXT_SCBCLK__PA_DIV_ID)
X#define UART_2_EXT_SCBCLK_Start()     UART_2_EXT_SCBCLK_StartEx(UART_2_EXT_SCBCLK__PA_DIV_ID)
N
N#else
S
Svoid UART_2_EXT_SCBCLK_Start(void);
S
N#endif/* CYREG_PERI_DIV_CMD */
N
Nvoid UART_2_EXT_SCBCLK_Stop(void);
N
Nvoid UART_2_EXT_SCBCLK_SetFractionalDividerRegister(uint16 clkDivider, uint8 clkFractional);
N
Nuint16 UART_2_EXT_SCBCLK_GetDividerRegister(void);
Nuint8  UART_2_EXT_SCBCLK_GetFractionalDividerRegister(void);
N
N#define UART_2_EXT_SCBCLK_Enable()                         UART_2_EXT_SCBCLK_Start()
N#define UART_2_EXT_SCBCLK_Disable()                        UART_2_EXT_SCBCLK_Stop()
N#define UART_2_EXT_SCBCLK_SetDividerRegister(clkDivider, reset)  \
N    UART_2_EXT_SCBCLK_SetFractionalDividerRegister((clkDivider), 0u)
X#define UART_2_EXT_SCBCLK_SetDividerRegister(clkDivider, reset)      UART_2_EXT_SCBCLK_SetFractionalDividerRegister((clkDivider), 0u)
N#define UART_2_EXT_SCBCLK_SetDivider(clkDivider)           UART_2_EXT_SCBCLK_SetDividerRegister((clkDivider), 1u)
N#define UART_2_EXT_SCBCLK_SetDividerValue(clkDivider)      UART_2_EXT_SCBCLK_SetDividerRegister((clkDivider) - 1u, 1u)
N
N
N/***************************************
N*             Registers
N***************************************/
N#if defined CYREG_PERI_DIV_CMD
X#if 1L
N
N#define UART_2_EXT_SCBCLK_DIV_ID     UART_2_EXT_SCBCLK__DIV_ID
N
N#define UART_2_EXT_SCBCLK_CMD_REG    (*(reg32 *)CYREG_PERI_DIV_CMD)
N#define UART_2_EXT_SCBCLK_CTRL_REG   (*(reg32 *)UART_2_EXT_SCBCLK__CTRL_REGISTER)
N#define UART_2_EXT_SCBCLK_DIV_REG    (*(reg32 *)UART_2_EXT_SCBCLK__DIV_REGISTER)
N
N#define UART_2_EXT_SCBCLK_CMD_DIV_SHIFT          (0u)
N#define UART_2_EXT_SCBCLK_CMD_PA_DIV_SHIFT       (8u)
N#define UART_2_EXT_SCBCLK_CMD_DISABLE_SHIFT      (30u)
N#define UART_2_EXT_SCBCLK_CMD_ENABLE_SHIFT       (31u)
N
N#define UART_2_EXT_SCBCLK_CMD_DISABLE_MASK       ((uint32)((uint32)1u << UART_2_EXT_SCBCLK_CMD_DISABLE_SHIFT))
N#define UART_2_EXT_SCBCLK_CMD_ENABLE_MASK        ((uint32)((uint32)1u << UART_2_EXT_SCBCLK_CMD_ENABLE_SHIFT))
N
N#define UART_2_EXT_SCBCLK_DIV_FRAC_MASK  (0x000000F8u)
N#define UART_2_EXT_SCBCLK_DIV_FRAC_SHIFT (3u)
N#define UART_2_EXT_SCBCLK_DIV_INT_MASK   (0xFFFFFF00u)
N#define UART_2_EXT_SCBCLK_DIV_INT_SHIFT  (8u)
N
N#else 
S
S#define UART_2_EXT_SCBCLK_DIV_REG        (*(reg32 *)UART_2_EXT_SCBCLK__REGISTER)
S#define UART_2_EXT_SCBCLK_ENABLE_REG     UART_2_EXT_SCBCLK_DIV_REG
S#define UART_2_EXT_SCBCLK_DIV_FRAC_MASK  UART_2_EXT_SCBCLK__FRAC_MASK
S#define UART_2_EXT_SCBCLK_DIV_FRAC_SHIFT (16u)
S#define UART_2_EXT_SCBCLK_DIV_INT_MASK   UART_2_EXT_SCBCLK__DIVIDER_MASK
S#define UART_2_EXT_SCBCLK_DIV_INT_SHIFT  (0u)
S
N#endif/* CYREG_PERI_DIV_CMD */
N
N#endif /* !defined(CY_CLOCK_UART_2_EXT_SCBCLK_H) */
N
N/* [] END OF FILE */
L 89 "Generated_Source\PSoC4\UART_2_EXT.h" 2
N#endif /* (UART_2_EXT_SCB_CLK_INTERNAL) */
N
N
N/***************************************
N*       Type Definitions
N***************************************/
N
Ntypedef struct
N{
N    uint8 enableState;
N} UART_2_EXT_BACKUP_STRUCT;
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
N/**
N* \addtogroup group_general
N* @{
N*/
N
N/* Start and Stop APIs */
Nvoid UART_2_EXT_Init(void);
Nvoid UART_2_EXT_Enable(void);
Nvoid UART_2_EXT_Start(void);
Nvoid UART_2_EXT_Stop(void);
N
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
N/* Sleep and Wakeup APis */
Nvoid UART_2_EXT_Sleep(void);
Nvoid UART_2_EXT_Wakeup(void);
N/** @} power */ 
N
N/**
N* \addtogroup group_interrupt
N* @{
N*/
N#if (UART_2_EXT_SCB_IRQ_INTERNAL)
X#if ((0u == (0u)))
N    /* Custom interrupt handler */
N    void UART_2_EXT_SetCustomInterruptHandler(void (*func)(void));
N#endif /* (UART_2_EXT_SCB_IRQ_INTERNAL) */
N/** @} interrupt */
N
N/* Interface to internal interrupt component */
N#if (UART_2_EXT_SCB_IRQ_INTERNAL)
X#if ((0u == (0u)))
N    /**
N    * \addtogroup group_interrupt
N    * @{
N    */    
N    /*******************************************************************************
N    * Function Name: UART_2_EXT_EnableInt
N    ****************************************************************************//**
N    *
N    *  When using an Internal interrupt, this enables the interrupt in the NVIC. 
N    *  When using an external interrupt the API for the interrupt component must 
N    *  be used to enable the interrupt.
N    *
N    *******************************************************************************/
N    #define UART_2_EXT_EnableInt()    CyIntEnable(UART_2_EXT_ISR_NUMBER)
N    
N    
N    /*******************************************************************************
N    * Function Name: UART_2_EXT_DisableInt
N    ****************************************************************************//**
N    *
N    *  When using an Internal interrupt, this disables the interrupt in the NVIC. 
N    *  When using an external interrupt the API for the interrupt component must 
N    *  be used to disable the interrupt.
N    *
N    *******************************************************************************/    
N    #define UART_2_EXT_DisableInt()   CyIntDisable(UART_2_EXT_ISR_NUMBER)
N    /** @} interrupt */
N
N    /*******************************************************************************
N    * Function Name: UART_2_EXT_ClearPendingInt
N    ****************************************************************************//**
N    *
N    *  This function clears the interrupt pending status in the NVIC. 
N    *
N    *******************************************************************************/
N    #define UART_2_EXT_ClearPendingInt()  CyIntClearPending(UART_2_EXT_ISR_NUMBER)
N#endif /* (UART_2_EXT_SCB_IRQ_INTERNAL) */
N
N#if (UART_2_EXT_UART_RX_WAKEUP_IRQ)
X#if ((0u == (1u)))
S    /*******************************************************************************
S    * Function Name: UART_2_EXT_RxWakeEnableInt
S    ****************************************************************************//**
S    *
S    *  This function enables the interrupt (RX_WAKE) pending status in the NVIC. 
S    *
S    *******************************************************************************/    
S    #define UART_2_EXT_RxWakeEnableInt()  CyIntEnable(UART_2_EXT_RX_WAKE_ISR_NUMBER)
S    
S
S    /*******************************************************************************
S    * Function Name: UART_2_EXT_RxWakeDisableInt
S    ****************************************************************************//**
S    *
S    *  This function disables the interrupt (RX_WAKE) pending status in the NVIC.  
S    *
S    *******************************************************************************/
S    #define UART_2_EXT_RxWakeDisableInt() CyIntDisable(UART_2_EXT_RX_WAKE_ISR_NUMBER)
S    
S    
S    /*******************************************************************************
S    * Function Name: UART_2_EXT_RxWakeClearPendingInt
S    ****************************************************************************//**
S    *
S    *  This function clears the interrupt (RX_WAKE) pending status in the NVIC. 
S    *
S    *******************************************************************************/    
S    #define UART_2_EXT_RxWakeClearPendingInt()  CyIntClearPending(UART_2_EXT_RX_WAKE_ISR_NUMBER)
N#endif /* (UART_2_EXT_UART_RX_WAKEUP_IRQ) */
N
N/**
N* \addtogroup group_interrupt
N* @{
N*/
N/* Get interrupt cause */
N/*******************************************************************************
N* Function Name: UART_2_EXT_GetInterruptCause
N****************************************************************************//**
N*
N*  Returns a mask of bits showing the source of the current triggered interrupt. 
N*  This is useful for modes of operation where an interrupt can be generated by 
N*  conditions in multiple interrupt source registers.
N*
N*  \return
N*   Mask with the OR of the following conditions that have been triggered.
N*    - UART_2_EXT_INTR_CAUSE_MASTER - Interrupt from Master
N*    - UART_2_EXT_INTR_CAUSE_SLAVE - Interrupt from Slave
N*    - UART_2_EXT_INTR_CAUSE_TX - Interrupt from TX
N*    - UART_2_EXT_INTR_CAUSE_RX - Interrupt from RX
N*
N*******************************************************************************/
N#define UART_2_EXT_GetInterruptCause()    (UART_2_EXT_INTR_CAUSE_REG)
N
N
N/* APIs to service INTR_RX register */
N/*******************************************************************************
N* Function Name: UART_2_EXT_GetRxInterruptSource
N****************************************************************************//**
N*
N*  Returns RX interrupt request register. This register contains current status 
N*  of RX interrupt sources.
N*
N*  \return
N*   Current status of RX interrupt sources.
N*   Each constant is a bit field value. The value returned may have multiple 
N*   bits set to indicate the current status.
N*   - UART_2_EXT_INTR_RX_FIFO_LEVEL - The number of data elements in the 
N      RX FIFO is greater than the value of RX FIFO level.
N*   - UART_2_EXT_INTR_RX_NOT_EMPTY - Receiver FIFO is not empty.
N*   - UART_2_EXT_INTR_RX_FULL - Receiver FIFO is full.
N*   - UART_2_EXT_INTR_RX_OVERFLOW - Attempt to write to a full 
N*     receiver FIFO.
N*   - UART_2_EXT_INTR_RX_UNDERFLOW - Attempt to read from an empty 
N*     receiver FIFO.
N*   - UART_2_EXT_INTR_RX_FRAME_ERROR - UART framing error detected.
N*   - UART_2_EXT_INTR_RX_PARITY_ERROR - UART parity error detected.
N*
N*******************************************************************************/
N#define UART_2_EXT_GetRxInterruptSource() (UART_2_EXT_INTR_RX_REG)
N
N
N/*******************************************************************************
N* Function Name: UART_2_EXT_SetRxInterruptMode
N****************************************************************************//**
N*
N*  Writes RX interrupt mask register. This register configures which bits from 
N*  RX interrupt request register will trigger an interrupt event.
N*
N*  \param interruptMask: RX interrupt sources to be enabled (refer to 
N*   UART_2_EXT_GetRxInterruptSource() function for bit fields values).
N*
N*******************************************************************************/
N#define UART_2_EXT_SetRxInterruptMode(interruptMask)     UART_2_EXT_WRITE_INTR_RX_MASK(interruptMask)
N
N
N/*******************************************************************************
N* Function Name: UART_2_EXT_GetRxInterruptMode
N****************************************************************************//**
N*
N*  Returns RX interrupt mask register This register specifies which bits from 
N*  RX interrupt request register will trigger an interrupt event.
N*
N*  \return 
N*   RX interrupt sources to be enabled (refer to 
N*   UART_2_EXT_GetRxInterruptSource() function for bit fields values).
N*
N*******************************************************************************/
N#define UART_2_EXT_GetRxInterruptMode()   (UART_2_EXT_INTR_RX_MASK_REG)
N
N
N/*******************************************************************************
N* Function Name: UART_2_EXT_GetRxInterruptSourceMasked
N****************************************************************************//**
N*
N*  Returns RX interrupt masked request register. This register contains logical
N*  AND of corresponding bits from RX interrupt request and mask registers.
N*  This function is intended to be used in the interrupt service routine to 
N*  identify which of enabled RX interrupt sources cause interrupt event.
N*
N*  \return 
N*   Current status of enabled RX interrupt sources (refer to 
N*   UART_2_EXT_GetRxInterruptSource() function for bit fields values).
N*
N*******************************************************************************/
N#define UART_2_EXT_GetRxInterruptSourceMasked()   (UART_2_EXT_INTR_RX_MASKED_REG)
N
N
N/*******************************************************************************
N* Function Name: UART_2_EXT_ClearRxInterruptSource
N****************************************************************************//**
N*
N*  Clears RX interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: RX interrupt sources to be cleared (refer to 
N*   UART_2_EXT_GetRxInterruptSource() function for bit fields values).
N*
N*  \sideeffects 
N*   The side effects are listed in the table below for each 
N*   affected interrupt source. Refer to section RX FIFO interrupt sources for 
N*   detailed description.
N*   - UART_2_EXT_INTR_RX_FIFO_LEVEL Interrupt source is not cleared when 
N*     the receiver FIFO has more entries than level.
N*   - UART_2_EXT_INTR_RX_NOT_EMPTY Interrupt source is not cleared when
N*     receiver FIFO is not empty.
N*   - UART_2_EXT_INTR_RX_FULL Interrupt source is not cleared when 
N*      receiver FIFO is full.
N*
N*******************************************************************************/
N#define UART_2_EXT_ClearRxInterruptSource(interruptMask)  UART_2_EXT_CLEAR_INTR_RX(interruptMask)
N
N
N/*******************************************************************************
N* Function Name: UART_2_EXT_SetRxInterrupt
N****************************************************************************//**
N*
N*  Sets RX interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: RX interrupt sources to set in the RX interrupt request 
N*   register (refer to UART_2_EXT_GetRxInterruptSource() function for bit 
N*   fields values).
N*
N*******************************************************************************/
N#define UART_2_EXT_SetRxInterrupt(interruptMask)  UART_2_EXT_SET_INTR_RX(interruptMask)
N
Nvoid UART_2_EXT_SetRxFifoLevel(uint32 level);
N
N
N/* APIs to service INTR_TX register */
N/*******************************************************************************
N* Function Name: UART_2_EXT_GetTxInterruptSource
N****************************************************************************//**
N*
N*  Returns TX interrupt request register. This register contains current status 
N*  of TX interrupt sources.
N* 
N*  \return 
N*   Current status of TX interrupt sources.
N*   Each constant is a bit field value. The value returned may have multiple 
N*   bits set to indicate the current status.
N*   - UART_2_EXT_INTR_TX_FIFO_LEVEL - The number of data elements in the 
N*     TX FIFO is less than the value of TX FIFO level.
N*   - UART_2_EXT_INTR_TX_NOT_FULL - Transmitter FIFO is not full.
N*   - UART_2_EXT_INTR_TX_EMPTY - Transmitter FIFO is empty.
N*   - UART_2_EXT_INTR_TX_OVERFLOW - Attempt to write to a full 
N*     transmitter FIFO.
N*   - UART_2_EXT_INTR_TX_UNDERFLOW - Attempt to read from an empty 
N*     transmitter FIFO.
N*   - UART_2_EXT_INTR_TX_UART_NACK - UART received a NACK in SmartCard 
N*   mode.
N*   - UART_2_EXT_INTR_TX_UART_DONE - UART transfer is complete. 
N*     All data elements from the TX FIFO are sent.
N*   - UART_2_EXT_INTR_TX_UART_ARB_LOST - Value on the TX line of the UART
N*     does not match the value on the RX line.
N*
N*******************************************************************************/
N#define UART_2_EXT_GetTxInterruptSource() (UART_2_EXT_INTR_TX_REG)
N
N
N/*******************************************************************************
N* Function Name: UART_2_EXT_SetTxInterruptMode
N****************************************************************************//**
N*
N*  Writes TX interrupt mask register. This register configures which bits from 
N*  TX interrupt request register will trigger an interrupt event.
N*
N*  \param interruptMask: TX interrupt sources to be enabled (refer to 
N*   UART_2_EXT_GetTxInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define UART_2_EXT_SetTxInterruptMode(interruptMask)  UART_2_EXT_WRITE_INTR_TX_MASK(interruptMask)
N
N
N/*******************************************************************************
N* Function Name: UART_2_EXT_GetTxInterruptMode
N****************************************************************************//**
N*
N*  Returns TX interrupt mask register This register specifies which bits from 
N*  TX interrupt request register will trigger an interrupt event.
N*
N*  \return 
N*   Enabled TX interrupt sources (refer to 
N*   UART_2_EXT_GetTxInterruptSource() function for bit field values).
N*   
N*******************************************************************************/
N#define UART_2_EXT_GetTxInterruptMode()   (UART_2_EXT_INTR_TX_MASK_REG)
N
N
N/*******************************************************************************
N* Function Name: UART_2_EXT_GetTxInterruptSourceMasked
N****************************************************************************//**
N*
N*  Returns TX interrupt masked request register. This register contains logical
N*  AND of corresponding bits from TX interrupt request and mask registers.
N*  This function is intended to be used in the interrupt service routine to identify 
N*  which of enabled TX interrupt sources cause interrupt event.
N*
N*  \return 
N*   Current status of enabled TX interrupt sources (refer to 
N*   UART_2_EXT_GetTxInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define UART_2_EXT_GetTxInterruptSourceMasked()   (UART_2_EXT_INTR_TX_MASKED_REG)
N
N
N/*******************************************************************************
N* Function Name: UART_2_EXT_ClearTxInterruptSource
N****************************************************************************//**
N*
N*  Clears TX interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: TX interrupt sources to be cleared (refer to 
N*   UART_2_EXT_GetTxInterruptSource() function for bit field values).
N*
N*  \sideeffects 
N*   The side effects are listed in the table below for each affected interrupt 
N*   source. Refer to section TX FIFO interrupt sources for detailed description.
N*   - UART_2_EXT_INTR_TX_FIFO_LEVEL - Interrupt source is not cleared when 
N*     transmitter FIFO has less entries than level.
N*   - UART_2_EXT_INTR_TX_NOT_FULL - Interrupt source is not cleared when
N*     transmitter FIFO has empty entries.
N*   - UART_2_EXT_INTR_TX_EMPTY - Interrupt source is not cleared when 
N*     transmitter FIFO is empty.
N*   - UART_2_EXT_INTR_TX_UNDERFLOW - Interrupt source is not cleared when 
N*     transmitter FIFO is empty and I2C mode with clock stretching is selected. 
N*     Put data into the transmitter FIFO before clearing it. This behavior only 
N*     applicable for PSoC 4100/PSoC 4200 devices.
N*
N*******************************************************************************/
N#define UART_2_EXT_ClearTxInterruptSource(interruptMask)  UART_2_EXT_CLEAR_INTR_TX(interruptMask)
N
N
N/*******************************************************************************
N* Function Name: UART_2_EXT_SetTxInterrupt
N****************************************************************************//**
N*
N*  Sets RX interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: RX interrupt sources to set in the RX interrupt request 
N*   register (refer to UART_2_EXT_GetRxInterruptSource() function for bit 
N*   fields values).
N*
N*******************************************************************************/
N#define UART_2_EXT_SetTxInterrupt(interruptMask)  UART_2_EXT_SET_INTR_TX(interruptMask)
N
Nvoid UART_2_EXT_SetTxFifoLevel(uint32 level);
N
N
N/* APIs to service INTR_MASTER register */
N/*******************************************************************************
N* Function Name: UART_2_EXT_GetMasterInterruptSource
N****************************************************************************//**
N*
N*  Returns Master interrupt request register. This register contains current 
N*  status of Master interrupt sources.
N*
N*  \return 
N*   Current status of Master interrupt sources. 
N*   Each constant is a bit field value. The value returned may have multiple 
N*   bits set to indicate the current status.
N*   - UART_2_EXT_INTR_MASTER_SPI_DONE - SPI master transfer is complete.
N*     Refer to Interrupt sources section for detailed description.
N*   - UART_2_EXT_INTR_MASTER_I2C_ARB_LOST - I2C master lost arbitration.
N*   - UART_2_EXT_INTR_MASTER_I2C_NACK - I2C master received negative 
N*    acknowledgement (NAK).
N*   - UART_2_EXT_INTR_MASTER_I2C_ACK - I2C master received acknowledgement.
N*   - UART_2_EXT_INTR_MASTER_I2C_STOP - I2C master generated STOP.
N*   - UART_2_EXT_INTR_MASTER_I2C_BUS_ERROR - I2C master bus error 
N*     (detection of unexpected START or STOP condition).
N*
N*******************************************************************************/
N#define UART_2_EXT_GetMasterInterruptSource() (UART_2_EXT_INTR_MASTER_REG)
N
N/*******************************************************************************
N* Function Name: UART_2_EXT_SetMasterInterruptMode
N****************************************************************************//**
N*
N*  Writes Master interrupt mask register. This register configures which bits 
N*  from Master interrupt request register will trigger an interrupt event.
N*
N*  \param interruptMask: Master interrupt sources to be enabled (refer to 
N*   UART_2_EXT_GetMasterInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define UART_2_EXT_SetMasterInterruptMode(interruptMask)  UART_2_EXT_WRITE_INTR_MASTER_MASK(interruptMask)
N
N/*******************************************************************************
N* Function Name: UART_2_EXT_GetMasterInterruptMode
N****************************************************************************//**
N*
N*  Returns Master interrupt mask register This register specifies which bits 
N*  from Master interrupt request register will trigger an interrupt event.
N*
N*  \return 
N*   Enabled Master interrupt sources (refer to 
N*   UART_2_EXT_GetMasterInterruptSource() function for return values).
N*
N*******************************************************************************/
N#define UART_2_EXT_GetMasterInterruptMode()   (UART_2_EXT_INTR_MASTER_MASK_REG)
N
N/*******************************************************************************
N* Function Name: UART_2_EXT_GetMasterInterruptSourceMasked
N****************************************************************************//**
N*
N*  Returns Master interrupt masked request register. This register contains 
N*  logical AND of corresponding bits from Master interrupt request and mask 
N*  registers.
N*  This function is intended to be used in the interrupt service routine to 
N*  identify which of enabled Master interrupt sources cause interrupt event.
N*
N*  \return 
N*   Current status of enabled Master interrupt sources (refer to 
N*   UART_2_EXT_GetMasterInterruptSource() function for return values).
N*
N*******************************************************************************/
N#define UART_2_EXT_GetMasterInterruptSourceMasked()   (UART_2_EXT_INTR_MASTER_MASKED_REG)
N
N/*******************************************************************************
N* Function Name: UART_2_EXT_ClearMasterInterruptSource
N****************************************************************************//**
N*
N*  Clears Master interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: Master interrupt sources to be cleared (refer to 
N*   UART_2_EXT_GetMasterInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define UART_2_EXT_ClearMasterInterruptSource(interruptMask)  UART_2_EXT_CLEAR_INTR_MASTER(interruptMask)
N
N/*******************************************************************************
N* Function Name: UART_2_EXT_SetMasterInterrupt
N****************************************************************************//**
N*
N*  Sets Master interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: Master interrupt sources to set in the Master interrupt
N*   request register (refer to UART_2_EXT_GetMasterInterruptSource() 
N*   function for bit field values).
N*
N*******************************************************************************/
N#define UART_2_EXT_SetMasterInterrupt(interruptMask)  UART_2_EXT_SET_INTR_MASTER(interruptMask)
N
N
N/* APIs to service INTR_SLAVE register */
N/*******************************************************************************
N* Function Name: UART_2_EXT_GetSlaveInterruptSource
N****************************************************************************//**
N*
N*  Returns Slave interrupt request register. This register contains current 
N*  status of Slave interrupt sources.
N*
N*  \return 
N*   Current status of Slave interrupt sources.
N*   Each constant is a bit field value. The value returned may have multiple 
N*   bits set to indicate the current status.
N*   - UART_2_EXT_INTR_SLAVE_I2C_ARB_LOST - I2C slave lost arbitration: 
N*     the value driven on the SDA line is not the same as the value observed 
N*     on the SDA line.
N*   - UART_2_EXT_INTR_SLAVE_I2C_NACK - I2C slave received negative 
N*     acknowledgement (NAK).
N*   - UART_2_EXT_INTR_SLAVE_I2C_ACK - I2C slave received 
N*     acknowledgement (ACK).
N*   - UART_2_EXT_INTR_SLAVE_I2C_WRITE_STOP - Stop or Repeated Start 
N*     event for write transfer intended for this slave (address matching 
N*     is performed).
N*   - UART_2_EXT_INTR_SLAVE_I2C_STOP - Stop or Repeated Start event 
N*     for (read or write) transfer intended for this slave (address matching 
N*     is performed).
N*   - UART_2_EXT_INTR_SLAVE_I2C_START - I2C slave received Start 
N*     condition.
N*   - UART_2_EXT_INTR_SLAVE_I2C_ADDR_MATCH - I2C slave received matching 
N*     address.
N*   - UART_2_EXT_INTR_SLAVE_I2C_GENERAL - I2C Slave received general 
N*     call address.
N*   - UART_2_EXT_INTR_SLAVE_I2C_BUS_ERROR - I2C slave bus error (detection 
N*      of unexpected Start or Stop condition).
N*   - UART_2_EXT_INTR_SLAVE_SPI_BUS_ERROR - SPI slave select line is 
N*      deselected at an expected time while the SPI transfer.
N*
N*******************************************************************************/
N#define UART_2_EXT_GetSlaveInterruptSource()  (UART_2_EXT_INTR_SLAVE_REG)
N
N/*******************************************************************************
N* Function Name: UART_2_EXT_SetSlaveInterruptMode
N****************************************************************************//**
N*
N*  Writes Slave interrupt mask register. 
N*  This register configures which bits from Slave interrupt request register 
N*  will trigger an interrupt event.
N*
N*  \param interruptMask: Slave interrupt sources to be enabled (refer to 
N*   UART_2_EXT_GetSlaveInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define UART_2_EXT_SetSlaveInterruptMode(interruptMask)   UART_2_EXT_WRITE_INTR_SLAVE_MASK(interruptMask)
N
N/*******************************************************************************
N* Function Name: UART_2_EXT_GetSlaveInterruptMode
N****************************************************************************//**
N*
N*  Returns Slave interrupt mask register.
N*  This register specifies which bits from Slave interrupt request register 
N*  will trigger an interrupt event.
N*
N*  \return 
N*   Enabled Slave interrupt sources(refer to 
N*   UART_2_EXT_GetSlaveInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define UART_2_EXT_GetSlaveInterruptMode()    (UART_2_EXT_INTR_SLAVE_MASK_REG)
N
N/*******************************************************************************
N* Function Name: UART_2_EXT_GetSlaveInterruptSourceMasked
N****************************************************************************//**
N*
N*  Returns Slave interrupt masked request register. This register contains 
N*  logical AND of corresponding bits from Slave interrupt request and mask 
N*  registers.
N*  This function is intended to be used in the interrupt service routine to 
N*  identify which of enabled Slave interrupt sources cause interrupt event.
N*
N*  \return 
N*   Current status of enabled Slave interrupt sources (refer to 
N*   UART_2_EXT_GetSlaveInterruptSource() function for return values).
N*
N*******************************************************************************/
N#define UART_2_EXT_GetSlaveInterruptSourceMasked()    (UART_2_EXT_INTR_SLAVE_MASKED_REG)
N
N/*******************************************************************************
N* Function Name: UART_2_EXT_ClearSlaveInterruptSource
N****************************************************************************//**
N*
N*  Clears Slave interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: Slave interrupt sources to be cleared (refer to 
N*   UART_2_EXT_GetSlaveInterruptSource() function for return values).
N*
N*******************************************************************************/
N#define UART_2_EXT_ClearSlaveInterruptSource(interruptMask)   UART_2_EXT_CLEAR_INTR_SLAVE(interruptMask)
N
N/*******************************************************************************
N* Function Name: UART_2_EXT_SetSlaveInterrupt
N****************************************************************************//**
N*
N*  Sets Slave interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: Slave interrupt sources to set in the Slave interrupt 
N*   request register (refer to UART_2_EXT_GetSlaveInterruptSource() 
N*   function for return values).
N*
N*******************************************************************************/
N#define UART_2_EXT_SetSlaveInterrupt(interruptMask)   UART_2_EXT_SET_INTR_SLAVE(interruptMask)
N
N/** @} interrupt */ 
N
N
N/***************************************
N*     Vars with External Linkage
N***************************************/
N
N/**
N* \addtogroup group_globals
N* @{
N*/
N
N/** UART_2_EXT_initVar indicates whether the UART_2_EXT 
N*  component has been initialized. The variable is initialized to 0 
N*  and set to 1 the first time SCB_Start() is called. This allows 
N*  the component to restart without reinitialization after the first 
N*  call to the UART_2_EXT_Start() routine.
N*
N*  If re-initialization of the component is required, then the 
N*  UART_2_EXT_Init() function can be called before the 
N*  UART_2_EXT_Start() or UART_2_EXT_Enable() function.
N*/
Nextern uint8 UART_2_EXT_initVar;
N/** @} globals */
N
N/***************************************
N*              Registers
N***************************************/
N
N#define UART_2_EXT_CTRL_REG               (*(reg32 *) UART_2_EXT_SCB__CTRL)
N#define UART_2_EXT_CTRL_PTR               ( (reg32 *) UART_2_EXT_SCB__CTRL)
N
N#define UART_2_EXT_STATUS_REG             (*(reg32 *) UART_2_EXT_SCB__STATUS)
N#define UART_2_EXT_STATUS_PTR             ( (reg32 *) UART_2_EXT_SCB__STATUS)
N
N#if (!UART_2_EXT_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_2_EXT_SPI_CTRL_REG           (*(reg32 *) UART_2_EXT_SCB__SPI_CTRL)
N    #define UART_2_EXT_SPI_CTRL_PTR           ( (reg32 *) UART_2_EXT_SCB__SPI_CTRL)
N
N    #define UART_2_EXT_SPI_STATUS_REG         (*(reg32 *) UART_2_EXT_SCB__SPI_STATUS)
N    #define UART_2_EXT_SPI_STATUS_PTR         ( (reg32 *) UART_2_EXT_SCB__SPI_STATUS)
N
N    #define UART_2_EXT_UART_CTRL_REG          (*(reg32 *) UART_2_EXT_SCB__UART_CTRL)
N    #define UART_2_EXT_UART_CTRL_PTR          ( (reg32 *) UART_2_EXT_SCB__UART_CTRL)
N
N    #define UART_2_EXT_UART_TX_CTRL_REG       (*(reg32 *) UART_2_EXT_SCB__UART_TX_CTRL)
N    #define UART_2_EXT_UART_TX_CTRL_PTR       ( (reg32 *) UART_2_EXT_SCB__UART_TX_CTRL)
N
N    #define UART_2_EXT_UART_RX_CTRL_REG       (*(reg32 *) UART_2_EXT_SCB__UART_RX_CTRL)
N    #define UART_2_EXT_UART_RX_CTRL_PTR       ( (reg32 *) UART_2_EXT_SCB__UART_RX_CTRL)
N
N    #define UART_2_EXT_UART_RX_STATUS_REG     (*(reg32 *) UART_2_EXT_SCB__UART_RX_STATUS)
N    #define UART_2_EXT_UART_RX_STATUS_PTR     ( (reg32 *) UART_2_EXT_SCB__UART_RX_STATUS)
N#endif /* (!UART_2_EXT_CY_SCBIP_V1) */
N
N#if !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define UART_2_EXT_UART_FLOW_CTRL_REG     (*(reg32 *) UART_2_EXT_SCB__UART_FLOW_CTRL)
N    #define UART_2_EXT_UART_FLOW_CTRL_PTR     ( (reg32 *) UART_2_EXT_SCB__UART_FLOW_CTRL)
N#endif /* !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1) */
N
N#define UART_2_EXT_I2C_CTRL_REG           (*(reg32 *) UART_2_EXT_SCB__I2C_CTRL)
N#define UART_2_EXT_I2C_CTRL_PTR           ( (reg32 *) UART_2_EXT_SCB__I2C_CTRL)
N
N#define UART_2_EXT_I2C_STATUS_REG         (*(reg32 *) UART_2_EXT_SCB__I2C_STATUS)
N#define UART_2_EXT_I2C_STATUS_PTR         ( (reg32 *) UART_2_EXT_SCB__I2C_STATUS)
N
N#define UART_2_EXT_I2C_MASTER_CMD_REG     (*(reg32 *) UART_2_EXT_SCB__I2C_M_CMD)
N#define UART_2_EXT_I2C_MASTER_CMD_PTR     ( (reg32 *) UART_2_EXT_SCB__I2C_M_CMD)
N
N#define UART_2_EXT_I2C_SLAVE_CMD_REG      (*(reg32 *) UART_2_EXT_SCB__I2C_S_CMD)
N#define UART_2_EXT_I2C_SLAVE_CMD_PTR      ( (reg32 *) UART_2_EXT_SCB__I2C_S_CMD)
N
N#define UART_2_EXT_I2C_CFG_REG            (*(reg32 *) UART_2_EXT_SCB__I2C_CFG)
N#define UART_2_EXT_I2C_CFG_PTR            ( (reg32 *) UART_2_EXT_SCB__I2C_CFG)
N
N#define UART_2_EXT_TX_CTRL_REG            (*(reg32 *) UART_2_EXT_SCB__TX_CTRL)
N#define UART_2_EXT_TX_CTRL_PTR            ( (reg32 *) UART_2_EXT_SCB__TX_CTRL)
N
N#define UART_2_EXT_TX_FIFO_CTRL_REG       (*(reg32 *) UART_2_EXT_SCB__TX_FIFO_CTRL)
N#define UART_2_EXT_TX_FIFO_CTRL_PTR       ( (reg32 *) UART_2_EXT_SCB__TX_FIFO_CTRL)
N
N#define UART_2_EXT_TX_FIFO_STATUS_REG     (*(reg32 *) UART_2_EXT_SCB__TX_FIFO_STATUS)
N#define UART_2_EXT_TX_FIFO_STATUS_PTR     ( (reg32 *) UART_2_EXT_SCB__TX_FIFO_STATUS)
N
N#define UART_2_EXT_TX_FIFO_WR_REG         (*(reg32 *) UART_2_EXT_SCB__TX_FIFO_WR)
N#define UART_2_EXT_TX_FIFO_WR_PTR         ( (reg32 *) UART_2_EXT_SCB__TX_FIFO_WR)
N
N#define UART_2_EXT_RX_CTRL_REG            (*(reg32 *) UART_2_EXT_SCB__RX_CTRL)
N#define UART_2_EXT_RX_CTRL_PTR            ( (reg32 *) UART_2_EXT_SCB__RX_CTRL)
N
N#define UART_2_EXT_RX_FIFO_CTRL_REG       (*(reg32 *) UART_2_EXT_SCB__RX_FIFO_CTRL)
N#define UART_2_EXT_RX_FIFO_CTRL_PTR       ( (reg32 *) UART_2_EXT_SCB__RX_FIFO_CTRL)
N
N#define UART_2_EXT_RX_FIFO_STATUS_REG     (*(reg32 *) UART_2_EXT_SCB__RX_FIFO_STATUS)
N#define UART_2_EXT_RX_FIFO_STATUS_PTR     ( (reg32 *) UART_2_EXT_SCB__RX_FIFO_STATUS)
N
N#define UART_2_EXT_RX_MATCH_REG           (*(reg32 *) UART_2_EXT_SCB__RX_MATCH)
N#define UART_2_EXT_RX_MATCH_PTR           ( (reg32 *) UART_2_EXT_SCB__RX_MATCH)
N
N#define UART_2_EXT_RX_FIFO_RD_REG         (*(reg32 *) UART_2_EXT_SCB__RX_FIFO_RD)
N#define UART_2_EXT_RX_FIFO_RD_PTR         ( (reg32 *) UART_2_EXT_SCB__RX_FIFO_RD)
N
N#define UART_2_EXT_RX_FIFO_RD_SILENT_REG  (*(reg32 *) UART_2_EXT_SCB__RX_FIFO_RD_SILENT)
N#define UART_2_EXT_RX_FIFO_RD_SILENT_PTR  ( (reg32 *) UART_2_EXT_SCB__RX_FIFO_RD_SILENT)
N
N#ifdef UART_2_EXT_SCB__EZ_DATA0
N    #define UART_2_EXT_EZBUF_DATA0_REG    (*(reg32 *) UART_2_EXT_SCB__EZ_DATA0)
N    #define UART_2_EXT_EZBUF_DATA0_PTR    ( (reg32 *) UART_2_EXT_SCB__EZ_DATA0)
N#else
S    #define UART_2_EXT_EZBUF_DATA0_REG    (*(reg32 *) UART_2_EXT_SCB__EZ_DATA00)
S    #define UART_2_EXT_EZBUF_DATA0_PTR    ( (reg32 *) UART_2_EXT_SCB__EZ_DATA00)
N#endif /* UART_2_EXT_SCB__EZ_DATA00 */
N
N#define UART_2_EXT_INTR_CAUSE_REG         (*(reg32 *) UART_2_EXT_SCB__INTR_CAUSE)
N#define UART_2_EXT_INTR_CAUSE_PTR         ( (reg32 *) UART_2_EXT_SCB__INTR_CAUSE)
N
N#define UART_2_EXT_INTR_I2C_EC_REG        (*(reg32 *) UART_2_EXT_SCB__INTR_I2C_EC)
N#define UART_2_EXT_INTR_I2C_EC_PTR        ( (reg32 *) UART_2_EXT_SCB__INTR_I2C_EC)
N
N#define UART_2_EXT_INTR_I2C_EC_MASK_REG   (*(reg32 *) UART_2_EXT_SCB__INTR_I2C_EC_MASK)
N#define UART_2_EXT_INTR_I2C_EC_MASK_PTR   ( (reg32 *) UART_2_EXT_SCB__INTR_I2C_EC_MASK)
N
N#define UART_2_EXT_INTR_I2C_EC_MASKED_REG (*(reg32 *) UART_2_EXT_SCB__INTR_I2C_EC_MASKED)
N#define UART_2_EXT_INTR_I2C_EC_MASKED_PTR ( (reg32 *) UART_2_EXT_SCB__INTR_I2C_EC_MASKED)
N
N#if (!UART_2_EXT_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_2_EXT_INTR_SPI_EC_REG        (*(reg32 *) UART_2_EXT_SCB__INTR_SPI_EC)
N    #define UART_2_EXT_INTR_SPI_EC_PTR        ( (reg32 *) UART_2_EXT_SCB__INTR_SPI_EC)
N
N    #define UART_2_EXT_INTR_SPI_EC_MASK_REG   (*(reg32 *) UART_2_EXT_SCB__INTR_SPI_EC_MASK)
N    #define UART_2_EXT_INTR_SPI_EC_MASK_PTR   ( (reg32 *) UART_2_EXT_SCB__INTR_SPI_EC_MASK)
N
N    #define UART_2_EXT_INTR_SPI_EC_MASKED_REG (*(reg32 *) UART_2_EXT_SCB__INTR_SPI_EC_MASKED)
N    #define UART_2_EXT_INTR_SPI_EC_MASKED_PTR ( (reg32 *) UART_2_EXT_SCB__INTR_SPI_EC_MASKED)
N#endif /* (!UART_2_EXT_CY_SCBIP_V1) */
N
N#define UART_2_EXT_INTR_MASTER_REG        (*(reg32 *) UART_2_EXT_SCB__INTR_M)
N#define UART_2_EXT_INTR_MASTER_PTR        ( (reg32 *) UART_2_EXT_SCB__INTR_M)
N
N#define UART_2_EXT_INTR_MASTER_SET_REG    (*(reg32 *) UART_2_EXT_SCB__INTR_M_SET)
N#define UART_2_EXT_INTR_MASTER_SET_PTR    ( (reg32 *) UART_2_EXT_SCB__INTR_M_SET)
N
N#define UART_2_EXT_INTR_MASTER_MASK_REG   (*(reg32 *) UART_2_EXT_SCB__INTR_M_MASK)
N#define UART_2_EXT_INTR_MASTER_MASK_PTR   ( (reg32 *) UART_2_EXT_SCB__INTR_M_MASK)
N
N#define UART_2_EXT_INTR_MASTER_MASKED_REG (*(reg32 *) UART_2_EXT_SCB__INTR_M_MASKED)
N#define UART_2_EXT_INTR_MASTER_MASKED_PTR ( (reg32 *) UART_2_EXT_SCB__INTR_M_MASKED)
N
N#define UART_2_EXT_INTR_SLAVE_REG         (*(reg32 *) UART_2_EXT_SCB__INTR_S)
N#define UART_2_EXT_INTR_SLAVE_PTR         ( (reg32 *) UART_2_EXT_SCB__INTR_S)
N
N#define UART_2_EXT_INTR_SLAVE_SET_REG     (*(reg32 *) UART_2_EXT_SCB__INTR_S_SET)
N#define UART_2_EXT_INTR_SLAVE_SET_PTR     ( (reg32 *) UART_2_EXT_SCB__INTR_S_SET)
N
N#define UART_2_EXT_INTR_SLAVE_MASK_REG    (*(reg32 *) UART_2_EXT_SCB__INTR_S_MASK)
N#define UART_2_EXT_INTR_SLAVE_MASK_PTR    ( (reg32 *) UART_2_EXT_SCB__INTR_S_MASK)
N
N#define UART_2_EXT_INTR_SLAVE_MASKED_REG  (*(reg32 *) UART_2_EXT_SCB__INTR_S_MASKED)
N#define UART_2_EXT_INTR_SLAVE_MASKED_PTR  ( (reg32 *) UART_2_EXT_SCB__INTR_S_MASKED)
N
N#define UART_2_EXT_INTR_TX_REG            (*(reg32 *) UART_2_EXT_SCB__INTR_TX)
N#define UART_2_EXT_INTR_TX_PTR            ( (reg32 *) UART_2_EXT_SCB__INTR_TX)
N
N#define UART_2_EXT_INTR_TX_SET_REG        (*(reg32 *) UART_2_EXT_SCB__INTR_TX_SET)
N#define UART_2_EXT_INTR_TX_SET_PTR        ( (reg32 *) UART_2_EXT_SCB__INTR_TX_SET)
N
N#define UART_2_EXT_INTR_TX_MASK_REG       (*(reg32 *) UART_2_EXT_SCB__INTR_TX_MASK)
N#define UART_2_EXT_INTR_TX_MASK_PTR       ( (reg32 *) UART_2_EXT_SCB__INTR_TX_MASK)
N
N#define UART_2_EXT_INTR_TX_MASKED_REG     (*(reg32 *) UART_2_EXT_SCB__INTR_TX_MASKED)
N#define UART_2_EXT_INTR_TX_MASKED_PTR     ( (reg32 *) UART_2_EXT_SCB__INTR_TX_MASKED)
N
N#define UART_2_EXT_INTR_RX_REG            (*(reg32 *) UART_2_EXT_SCB__INTR_RX)
N#define UART_2_EXT_INTR_RX_PTR            ( (reg32 *) UART_2_EXT_SCB__INTR_RX)
N
N#define UART_2_EXT_INTR_RX_SET_REG        (*(reg32 *) UART_2_EXT_SCB__INTR_RX_SET)
N#define UART_2_EXT_INTR_RX_SET_PTR        ( (reg32 *) UART_2_EXT_SCB__INTR_RX_SET)
N
N#define UART_2_EXT_INTR_RX_MASK_REG       (*(reg32 *) UART_2_EXT_SCB__INTR_RX_MASK)
N#define UART_2_EXT_INTR_RX_MASK_PTR       ( (reg32 *) UART_2_EXT_SCB__INTR_RX_MASK)
N
N#define UART_2_EXT_INTR_RX_MASKED_REG     (*(reg32 *) UART_2_EXT_SCB__INTR_RX_MASKED)
N#define UART_2_EXT_INTR_RX_MASKED_PTR     ( (reg32 *) UART_2_EXT_SCB__INTR_RX_MASKED)
N
N/* Defines get from SCB IP parameters. */
N#define UART_2_EXT_FIFO_SIZE      (8u)  /* TX or RX FIFO size. */
N#define UART_2_EXT_EZ_DATA_NR     (32u)  /* Number of words in EZ memory. */ 
N#define UART_2_EXT_ONE_BYTE_WIDTH (8u)            /* Number of bits in one byte. */
N#define UART_2_EXT_FF_DATA_NR_LOG2_MASK       (0x0Fu)      /* Number of bits to represent a FIFO address. */
N#define UART_2_EXT_FF_DATA_NR_LOG2_PLUS1_MASK (0x1Fu) /* Number of bits to represent #bytes in FIFO. */
N
N
N/***************************************
N*        Registers Constants
N***************************************/
N
N#if (UART_2_EXT_SCB_IRQ_INTERNAL)
X#if ((0u == (0u)))
N    #define UART_2_EXT_ISR_NUMBER     ((uint8) UART_2_EXT_SCB_IRQ__INTC_NUMBER)
N    #define UART_2_EXT_ISR_PRIORITY   ((uint8) UART_2_EXT_SCB_IRQ__INTC_PRIOR_NUM)
N#endif /* (UART_2_EXT_SCB_IRQ_INTERNAL) */
N
N#if (UART_2_EXT_UART_RX_WAKEUP_IRQ)
X#if ((0u == (1u)))
S    #define UART_2_EXT_RX_WAKE_ISR_NUMBER     ((uint8) UART_2_EXT_RX_WAKEUP_IRQ__INTC_NUMBER)
S    #define UART_2_EXT_RX_WAKE_ISR_PRIORITY   ((uint8) UART_2_EXT_RX_WAKEUP_IRQ__INTC_PRIOR_NUM)
N#endif /* (UART_2_EXT_UART_RX_WAKEUP_IRQ) */
N
N/* UART_2_EXT_CTRL_REG */
N#define UART_2_EXT_CTRL_OVS_POS           (0u)  /* [3:0]   Oversampling factor                 */
N#define UART_2_EXT_CTRL_EC_AM_MODE_POS    (8u)  /* [8]     Externally clocked address match    */
N#define UART_2_EXT_CTRL_EC_OP_MODE_POS    (9u)  /* [9]     Externally clocked operation mode   */
N#define UART_2_EXT_CTRL_EZBUF_MODE_POS    (10u) /* [10]    EZ buffer is enabled                */
N#if !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define UART_2_EXT_CTRL_BYTE_MODE_POS (11u) /* [11]    Determines the number of bits per FIFO data element */
N#endif /* !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1) */
N#define UART_2_EXT_CTRL_ADDR_ACCEPT_POS   (16u) /* [16]    Put matched address in RX FIFO       */
N#define UART_2_EXT_CTRL_BLOCK_POS         (17u) /* [17]    Ext and Int logic to resolve collide */
N#define UART_2_EXT_CTRL_MODE_POS          (24u) /* [25:24] Operation mode                       */
N#define UART_2_EXT_CTRL_ENABLED_POS       (31u) /* [31]    Enable SCB block                     */
N#define UART_2_EXT_CTRL_OVS_MASK          ((uint32) 0x0Fu)
N#define UART_2_EXT_CTRL_EC_AM_MODE        ((uint32) 0x01u << UART_2_EXT_CTRL_EC_AM_MODE_POS)
N#define UART_2_EXT_CTRL_EC_OP_MODE        ((uint32) 0x01u << UART_2_EXT_CTRL_EC_OP_MODE_POS)
N#define UART_2_EXT_CTRL_EZBUF_MODE        ((uint32) 0x01u << UART_2_EXT_CTRL_EZBUF_MODE_POS)
N#if !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define UART_2_EXT_CTRL_BYTE_MODE ((uint32) 0x01u << UART_2_EXT_CTRL_BYTE_MODE_POS)
N#endif /* !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1) */
N#define UART_2_EXT_CTRL_ADDR_ACCEPT       ((uint32) 0x01u << UART_2_EXT_CTRL_ADDR_ACCEPT_POS)
N#define UART_2_EXT_CTRL_BLOCK             ((uint32) 0x01u << UART_2_EXT_CTRL_BLOCK_POS)
N#define UART_2_EXT_CTRL_MODE_MASK         ((uint32) 0x03u << UART_2_EXT_CTRL_MODE_POS)
N#define UART_2_EXT_CTRL_MODE_I2C          ((uint32) 0x00u)
N#define UART_2_EXT_CTRL_MODE_SPI          ((uint32) 0x01u << UART_2_EXT_CTRL_MODE_POS)
N#define UART_2_EXT_CTRL_MODE_UART         ((uint32) 0x02u << UART_2_EXT_CTRL_MODE_POS)
N#define UART_2_EXT_CTRL_ENABLED           ((uint32) 0x01u << UART_2_EXT_CTRL_ENABLED_POS)
N
N/* UART_2_EXT_STATUS_REG */
N#define UART_2_EXT_STATUS_EC_BUSY_POS     (0u)  /* [0] Bus busy. Externally clocked logic access to EZ memory */
N#define UART_2_EXT_STATUS_EC_BUSY         ((uint32) 0x0Fu)
N
N/* UART_2_EXT_SPI_CTRL_REG  */
N#define UART_2_EXT_SPI_CTRL_CONTINUOUS_POS        (0u)  /* [0]     Continuous or Separated SPI data transfers */
N#define UART_2_EXT_SPI_CTRL_SELECT_PRECEDE_POS    (1u)  /* [1]     Precedes or coincides start of data frame  */
N#define UART_2_EXT_SPI_CTRL_CPHA_POS              (2u)  /* [2]     SCLK phase                                 */
N#define UART_2_EXT_SPI_CTRL_CPOL_POS              (3u)  /* [3]     SCLK polarity                              */
N#define UART_2_EXT_SPI_CTRL_LATE_MISO_SAMPLE_POS  (4u)  /* [4]     Late MISO sample enabled                   */
N#if !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define UART_2_EXT_SPI_CTRL_SCLK_CONTINUOUS_POS   (5u)  /* [5]     Enable continuous SCLK generation */
N    #define UART_2_EXT_SPI_CTRL_SSEL0_POLARITY_POS    (8u)  /* [8]     SS0 polarity                      */
N    #define UART_2_EXT_SPI_CTRL_SSEL1_POLARITY_POS    (9u)  /* [9]     SS1 polarity                      */
N    #define UART_2_EXT_SPI_CTRL_SSEL2_POLARITY_POS    (10u) /* [10]    SS2 polarity                      */
N    #define UART_2_EXT_SPI_CTRL_SSEL3_POLARITY_POS    (11u) /* [11]    SS3 polarity                      */
N#endif /* !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1) */
N#define UART_2_EXT_SPI_CTRL_LOOPBACK_POS          (16u) /* [16]    Local loop-back control enabled            */
N#define UART_2_EXT_SPI_CTRL_MODE_POS              (24u) /* [25:24] Submode of SPI operation                   */
N#define UART_2_EXT_SPI_CTRL_SLAVE_SELECT_POS      (26u) /* [27:26] Selects SPI SS signal                      */
N#define UART_2_EXT_SPI_CTRL_MASTER_MODE_POS       (31u) /* [31]    Master mode enabled                        */
N#define UART_2_EXT_SPI_CTRL_CONTINUOUS            ((uint32) 0x01u)
N#define UART_2_EXT_SPI_CTRL_SELECT_PRECEDE        ((uint32) 0x01u << UART_2_EXT_SPI_CTRL_SELECT_PRECEDE_POS)
N#define UART_2_EXT_SPI_CTRL_SCLK_MODE_MASK        ((uint32) 0x03u << UART_2_EXT_SPI_CTRL_CPHA_POS)
N#define UART_2_EXT_SPI_CTRL_CPHA                  ((uint32) 0x01u << UART_2_EXT_SPI_CTRL_CPHA_POS)
N#define UART_2_EXT_SPI_CTRL_CPOL                  ((uint32) 0x01u << UART_2_EXT_SPI_CTRL_CPOL_POS)
N#define UART_2_EXT_SPI_CTRL_LATE_MISO_SAMPLE      ((uint32) 0x01u << \
N                                                                    UART_2_EXT_SPI_CTRL_LATE_MISO_SAMPLE_POS)
X#define UART_2_EXT_SPI_CTRL_LATE_MISO_SAMPLE      ((uint32) 0x01u <<                                                                     UART_2_EXT_SPI_CTRL_LATE_MISO_SAMPLE_POS)
N#if !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define UART_2_EXT_SPI_CTRL_SCLK_CONTINUOUS  ((uint32) 0x01u << UART_2_EXT_SPI_CTRL_SCLK_CONTINUOUS_POS)
N    #define UART_2_EXT_SPI_CTRL_SSEL0_POLARITY   ((uint32) 0x01u << UART_2_EXT_SPI_CTRL_SSEL0_POLARITY_POS)
N    #define UART_2_EXT_SPI_CTRL_SSEL1_POLARITY   ((uint32) 0x01u << UART_2_EXT_SPI_CTRL_SSEL1_POLARITY_POS)
N    #define UART_2_EXT_SPI_CTRL_SSEL2_POLARITY   ((uint32) 0x01u << UART_2_EXT_SPI_CTRL_SSEL2_POLARITY_POS)
N    #define UART_2_EXT_SPI_CTRL_SSEL3_POLARITY   ((uint32) 0x01u << UART_2_EXT_SPI_CTRL_SSEL3_POLARITY_POS)
N    #define UART_2_EXT_SPI_CTRL_SSEL_POLARITY_MASK ((uint32)0x0Fu << UART_2_EXT_SPI_CTRL_SSEL0_POLARITY_POS)
N#endif /* !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1) */
N
N#define UART_2_EXT_SPI_CTRL_LOOPBACK              ((uint32) 0x01u << UART_2_EXT_SPI_CTRL_LOOPBACK_POS)
N#define UART_2_EXT_SPI_CTRL_MODE_MASK             ((uint32) 0x03u << UART_2_EXT_SPI_CTRL_MODE_POS)
N#define UART_2_EXT_SPI_CTRL_MODE_MOTOROLA         ((uint32) 0x00u)
N#define UART_2_EXT_SPI_CTRL_MODE_TI               ((uint32) 0x01u << UART_2_EXT_CTRL_MODE_POS)
N#define UART_2_EXT_SPI_CTRL_MODE_NS               ((uint32) 0x02u << UART_2_EXT_CTRL_MODE_POS)
N#define UART_2_EXT_SPI_CTRL_SLAVE_SELECT_MASK     ((uint32) 0x03u << UART_2_EXT_SPI_CTRL_SLAVE_SELECT_POS)
N#define UART_2_EXT_SPI_CTRL_SLAVE_SELECT0         ((uint32) 0x00u)
N#define UART_2_EXT_SPI_CTRL_SLAVE_SELECT1         ((uint32) 0x01u << UART_2_EXT_SPI_CTRL_SLAVE_SELECT_POS)
N#define UART_2_EXT_SPI_CTRL_SLAVE_SELECT2         ((uint32) 0x02u << UART_2_EXT_SPI_CTRL_SLAVE_SELECT_POS)
N#define UART_2_EXT_SPI_CTRL_SLAVE_SELECT3         ((uint32) 0x03u << UART_2_EXT_SPI_CTRL_SLAVE_SELECT_POS)
N#define UART_2_EXT_SPI_CTRL_MASTER                ((uint32) 0x01u << UART_2_EXT_SPI_CTRL_MASTER_MODE_POS)
N#define UART_2_EXT_SPI_CTRL_SLAVE                 ((uint32) 0x00u)
N
N/* UART_2_EXT_SPI_STATUS_REG  */
N#define UART_2_EXT_SPI_STATUS_BUS_BUSY_POS    (0u)  /* [0]    Bus busy - slave selected */
N#define UART_2_EXT_SPI_STATUS_EZBUF_ADDR_POS  (8u)  /* [15:8] EzAddress                 */
N#define UART_2_EXT_SPI_STATUS_BUS_BUSY        ((uint32) 0x01u)
N#define UART_2_EXT_SPI_STATUS_EZBUF_ADDR_MASK ((uint32) 0xFFu << UART_2_EXT_I2C_STATUS_EZBUF_ADDR_POS)
N
N/* UART_2_EXT_UART_CTRL */
N#define UART_2_EXT_UART_CTRL_LOOPBACK_POS         (16u) /* [16] Loop-back    */
N#define UART_2_EXT_UART_CTRL_MODE_POS             (24u) /* [24] UART subMode */
N#define UART_2_EXT_UART_CTRL_LOOPBACK             ((uint32) 0x01u << UART_2_EXT_UART_CTRL_LOOPBACK_POS)
N#define UART_2_EXT_UART_CTRL_MODE_UART_STD        ((uint32) 0x00u)
N#define UART_2_EXT_UART_CTRL_MODE_UART_SMARTCARD  ((uint32) 0x01u << UART_2_EXT_UART_CTRL_MODE_POS)
N#define UART_2_EXT_UART_CTRL_MODE_UART_IRDA       ((uint32) 0x02u << UART_2_EXT_UART_CTRL_MODE_POS)
N#define UART_2_EXT_UART_CTRL_MODE_MASK            ((uint32) 0x03u << UART_2_EXT_UART_CTRL_MODE_POS)
N
N/* UART_2_EXT_UART_TX_CTRL */
N#define UART_2_EXT_UART_TX_CTRL_STOP_BITS_POS         (0u)  /* [2:0] Stop bits: (Stop bits + 1) * 0.5 period */
N#define UART_2_EXT_UART_TX_CTRL_PARITY_POS            (4u)  /* [4]   Parity bit                              */
N#define UART_2_EXT_UART_TX_CTRL_PARITY_ENABLED_POS    (5u)  /* [5]   Parity enable                           */
N#define UART_2_EXT_UART_TX_CTRL_RETRY_ON_NACK_POS     (8u)  /* [8]   Smart Card: re-send frame on NACK       */
N#define UART_2_EXT_UART_TX_CTRL_ONE_STOP_BIT          ((uint32) 0x01u)
N#define UART_2_EXT_UART_TX_CTRL_ONE_HALF_STOP_BITS    ((uint32) 0x02u)
N#define UART_2_EXT_UART_TX_CTRL_TWO_STOP_BITS         ((uint32) 0x03u)
N#define UART_2_EXT_UART_TX_CTRL_STOP_BITS_MASK        ((uint32) 0x07u)
N#define UART_2_EXT_UART_TX_CTRL_PARITY                ((uint32) 0x01u << \
N                                                                    UART_2_EXT_UART_TX_CTRL_PARITY_POS)
X#define UART_2_EXT_UART_TX_CTRL_PARITY                ((uint32) 0x01u <<                                                                     UART_2_EXT_UART_TX_CTRL_PARITY_POS)
N#define UART_2_EXT_UART_TX_CTRL_PARITY_ENABLED        ((uint32) 0x01u << \
N                                                                    UART_2_EXT_UART_TX_CTRL_PARITY_ENABLED_POS)
X#define UART_2_EXT_UART_TX_CTRL_PARITY_ENABLED        ((uint32) 0x01u <<                                                                     UART_2_EXT_UART_TX_CTRL_PARITY_ENABLED_POS)
N#define UART_2_EXT_UART_TX_CTRL_RETRY_ON_NACK         ((uint32) 0x01u << \
N                                                                    UART_2_EXT_UART_TX_CTRL_RETRY_ON_NACK_POS)
X#define UART_2_EXT_UART_TX_CTRL_RETRY_ON_NACK         ((uint32) 0x01u <<                                                                     UART_2_EXT_UART_TX_CTRL_RETRY_ON_NACK_POS)
N
N/* UART_2_EXT_UART_RX_CTRL */
N#define UART_2_EXT_UART_RX_CTRL_STOP_BITS_POS             (0u)  /* [2:0] Stop bits: (Stop bits + 1) * 0.5 period*/
N#define UART_2_EXT_UART_RX_CTRL_PARITY_POS                (4u)  /* [4]   Parity bit                             */
N#define UART_2_EXT_UART_RX_CTRL_PARITY_ENABLED_POS        (5u)  /* [5]   Parity enable                          */
N#define UART_2_EXT_UART_RX_CTRL_POLARITY_POS              (6u)  /* [6]   IrDA: inverts polarity of RX signal    */
N#define UART_2_EXT_UART_RX_CTRL_DROP_ON_PARITY_ERR_POS    (8u)  /* [8]   Drop and lost RX FIFO on parity error  */
N#define UART_2_EXT_UART_RX_CTRL_DROP_ON_FRAME_ERR_POS     (9u)  /* [9]   Drop and lost RX FIFO on frame error   */
N#define UART_2_EXT_UART_RX_CTRL_MP_MODE_POS               (10u) /* [10]  Multi-processor mode                   */
N#define UART_2_EXT_UART_RX_CTRL_LIN_MODE_POS              (12u) /* [12]  Lin mode: applicable for UART Standard */
N#define UART_2_EXT_UART_RX_CTRL_SKIP_START_POS            (13u) /* [13]  Skip start not: only for UART Standard */
N#define UART_2_EXT_UART_RX_CTRL_BREAK_WIDTH_POS           (16u) /* [19:16]  Break width: (Break width + 1)      */
N#define UART_2_EXT_UART_TX_CTRL_ONE_STOP_BIT              ((uint32) 0x01u)
N#define UART_2_EXT_UART_TX_CTRL_ONE_HALF_STOP_BITS        ((uint32) 0x02u)
N#define UART_2_EXT_UART_TX_CTRL_TWO_STOP_BITS             ((uint32) 0x03u)
N#define UART_2_EXT_UART_RX_CTRL_STOP_BITS_MASK            ((uint32) 0x07u)
N#define UART_2_EXT_UART_RX_CTRL_PARITY                    ((uint32) 0x01u << \
N                                                                    UART_2_EXT_UART_RX_CTRL_PARITY_POS)
X#define UART_2_EXT_UART_RX_CTRL_PARITY                    ((uint32) 0x01u <<                                                                     UART_2_EXT_UART_RX_CTRL_PARITY_POS)
N#define UART_2_EXT_UART_RX_CTRL_PARITY_ENABLED            ((uint32) 0x01u << \
N                                                                    UART_2_EXT_UART_RX_CTRL_PARITY_ENABLED_POS)
X#define UART_2_EXT_UART_RX_CTRL_PARITY_ENABLED            ((uint32) 0x01u <<                                                                     UART_2_EXT_UART_RX_CTRL_PARITY_ENABLED_POS)
N#define UART_2_EXT_UART_RX_CTRL_POLARITY                  ((uint32) 0x01u << \
N                                                                    UART_2_EXT_UART_RX_CTRL_POLARITY_POS)
X#define UART_2_EXT_UART_RX_CTRL_POLARITY                  ((uint32) 0x01u <<                                                                     UART_2_EXT_UART_RX_CTRL_POLARITY_POS)
N#define UART_2_EXT_UART_RX_CTRL_DROP_ON_PARITY_ERR        ((uint32) 0x01u << \
N                                                                   UART_2_EXT_UART_RX_CTRL_DROP_ON_PARITY_ERR_POS)
X#define UART_2_EXT_UART_RX_CTRL_DROP_ON_PARITY_ERR        ((uint32) 0x01u <<                                                                    UART_2_EXT_UART_RX_CTRL_DROP_ON_PARITY_ERR_POS)
N#define UART_2_EXT_UART_RX_CTRL_DROP_ON_FRAME_ERR         ((uint32) 0x01u << \
N                                                                    UART_2_EXT_UART_RX_CTRL_DROP_ON_FRAME_ERR_POS)
X#define UART_2_EXT_UART_RX_CTRL_DROP_ON_FRAME_ERR         ((uint32) 0x01u <<                                                                     UART_2_EXT_UART_RX_CTRL_DROP_ON_FRAME_ERR_POS)
N#define UART_2_EXT_UART_RX_CTRL_MP_MODE                   ((uint32) 0x01u << \
N                                                                    UART_2_EXT_UART_RX_CTRL_MP_MODE_POS)
X#define UART_2_EXT_UART_RX_CTRL_MP_MODE                   ((uint32) 0x01u <<                                                                     UART_2_EXT_UART_RX_CTRL_MP_MODE_POS)
N#define UART_2_EXT_UART_RX_CTRL_LIN_MODE                  ((uint32) 0x01u << \
N                                                                    UART_2_EXT_UART_RX_CTRL_LIN_MODE_POS)
X#define UART_2_EXT_UART_RX_CTRL_LIN_MODE                  ((uint32) 0x01u <<                                                                     UART_2_EXT_UART_RX_CTRL_LIN_MODE_POS)
N#define UART_2_EXT_UART_RX_CTRL_SKIP_START                ((uint32) 0x01u << \
N                                                                    UART_2_EXT_UART_RX_CTRL_SKIP_START_POS)
X#define UART_2_EXT_UART_RX_CTRL_SKIP_START                ((uint32) 0x01u <<                                                                     UART_2_EXT_UART_RX_CTRL_SKIP_START_POS)
N#define UART_2_EXT_UART_RX_CTRL_BREAK_WIDTH_MASK          ((uint32) 0x0Fu << \
N                                                                    UART_2_EXT_UART_RX_CTRL_BREAK_WIDTH_POS)
X#define UART_2_EXT_UART_RX_CTRL_BREAK_WIDTH_MASK          ((uint32) 0x0Fu <<                                                                     UART_2_EXT_UART_RX_CTRL_BREAK_WIDTH_POS)
N/* UART_2_EXT_UART_RX_STATUS_REG */
N#define UART_2_EXT_UART_RX_STATUS_BR_COUNTER_POS     (0u)  /* [11:0] Baud Rate counter */
N#define UART_2_EXT_UART_RX_STATUS_BR_COUNTER_MASK    ((uint32) 0xFFFu)
N
N#if !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    /* UART_2_EXT_UART_FLOW_CTRL_REG */
N    #define UART_2_EXT_UART_FLOW_CTRL_TRIGGER_LEVEL_POS    (0u)  /* [7:0] RTS RX FIFO trigger level         */
N    #define UART_2_EXT_UART_FLOW_CTRL_RTS_POLARITY_POS     (16u) /* [16]  Polarity of the RTS output signal */
N    #define UART_2_EXT_UART_FLOW_CTRL_CTS_POLARITY_POS     (24u) /* [24]  Polarity of the CTS input signal  */
N    #define UART_2_EXT_UART_FLOW_CTRL_CTS_ENABLED_POS      (25u) /* [25]  Enable CTS signal                 */
N    #define UART_2_EXT_UART_FLOW_CTRL_TRIGGER_LEVEL_MASK   ((uint32) UART_2_EXT_FF_DATA_NR_LOG2_MASK)
N    #define UART_2_EXT_UART_FLOW_CTRL_RTS_POLARITY         ((uint32) 0x01u << \
N                                                                       UART_2_EXT_UART_FLOW_CTRL_RTS_POLARITY_POS)
X    #define UART_2_EXT_UART_FLOW_CTRL_RTS_POLARITY         ((uint32) 0x01u <<                                                                        UART_2_EXT_UART_FLOW_CTRL_RTS_POLARITY_POS)
N    #define UART_2_EXT_UART_FLOW_CTRL_CTS_POLARITY         ((uint32) 0x01u << \
N                                                                       UART_2_EXT_UART_FLOW_CTRL_CTS_POLARITY_POS)
X    #define UART_2_EXT_UART_FLOW_CTRL_CTS_POLARITY         ((uint32) 0x01u <<                                                                        UART_2_EXT_UART_FLOW_CTRL_CTS_POLARITY_POS)
N    #define UART_2_EXT_UART_FLOW_CTRL_CTS_ENABLE           ((uint32) 0x01u << \
N                                                                       UART_2_EXT_UART_FLOW_CTRL_CTS_ENABLED_POS)
X    #define UART_2_EXT_UART_FLOW_CTRL_CTS_ENABLE           ((uint32) 0x01u <<                                                                        UART_2_EXT_UART_FLOW_CTRL_CTS_ENABLED_POS)
N#endif /* !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1) */
N
N/* UART_2_EXT_I2C_CTRL */
N#define UART_2_EXT_I2C_CTRL_HIGH_PHASE_OVS_POS           (0u)   /* [3:0] Oversampling factor high: master only */
N#define UART_2_EXT_I2C_CTRL_LOW_PHASE_OVS_POS            (4u)   /* [7:4] Oversampling factor low:  master only */
N#define UART_2_EXT_I2C_CTRL_M_READY_DATA_ACK_POS         (8u)   /* [8]   Master ACKs data while RX FIFO != FULL*/
N#define UART_2_EXT_I2C_CTRL_M_NOT_READY_DATA_NACK_POS    (9u)   /* [9]   Master NACKs data if RX FIFO ==  FULL */
N#define UART_2_EXT_I2C_CTRL_S_GENERAL_IGNORE_POS         (11u)  /* [11]  Slave ignores General call            */
N#define UART_2_EXT_I2C_CTRL_S_READY_ADDR_ACK_POS         (12u)  /* [12]  Slave ACKs Address if RX FIFO != FULL */
N#define UART_2_EXT_I2C_CTRL_S_READY_DATA_ACK_POS         (13u)  /* [13]  Slave ACKs data while RX FIFO == FULL */
N#define UART_2_EXT_I2C_CTRL_S_NOT_READY_ADDR_NACK_POS    (14u)  /* [14]  Slave NACKs address if RX FIFO == FULL*/
N#define UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK_POS    (15u)  /* [15]  Slave NACKs data if RX FIFO is  FULL  */
N#define UART_2_EXT_I2C_CTRL_LOOPBACK_POS                 (16u)  /* [16]  Loop-back                             */
N#define UART_2_EXT_I2C_CTRL_SLAVE_MODE_POS               (30u)  /* [30]  Slave mode enabled                    */
N#define UART_2_EXT_I2C_CTRL_MASTER_MODE_POS              (31u)  /* [31]  Master mode enabled                   */
N#define UART_2_EXT_I2C_CTRL_HIGH_PHASE_OVS_MASK  ((uint32) 0x0Fu)
N#define UART_2_EXT_I2C_CTRL_LOW_PHASE_OVS_MASK   ((uint32) 0x0Fu << \
N                                                                UART_2_EXT_I2C_CTRL_LOW_PHASE_OVS_POS)
X#define UART_2_EXT_I2C_CTRL_LOW_PHASE_OVS_MASK   ((uint32) 0x0Fu <<                                                                 UART_2_EXT_I2C_CTRL_LOW_PHASE_OVS_POS)
N#define UART_2_EXT_I2C_CTRL_M_READY_DATA_ACK      ((uint32) 0x01u << \
N                                                                UART_2_EXT_I2C_CTRL_M_READY_DATA_ACK_POS)
X#define UART_2_EXT_I2C_CTRL_M_READY_DATA_ACK      ((uint32) 0x01u <<                                                                 UART_2_EXT_I2C_CTRL_M_READY_DATA_ACK_POS)
N#define UART_2_EXT_I2C_CTRL_M_NOT_READY_DATA_NACK ((uint32) 0x01u << \
N                                                                UART_2_EXT_I2C_CTRL_M_NOT_READY_DATA_NACK_POS)
X#define UART_2_EXT_I2C_CTRL_M_NOT_READY_DATA_NACK ((uint32) 0x01u <<                                                                 UART_2_EXT_I2C_CTRL_M_NOT_READY_DATA_NACK_POS)
N#define UART_2_EXT_I2C_CTRL_S_GENERAL_IGNORE      ((uint32) 0x01u << \
N                                                                UART_2_EXT_I2C_CTRL_S_GENERAL_IGNORE_POS)
X#define UART_2_EXT_I2C_CTRL_S_GENERAL_IGNORE      ((uint32) 0x01u <<                                                                 UART_2_EXT_I2C_CTRL_S_GENERAL_IGNORE_POS)
N#define UART_2_EXT_I2C_CTRL_S_READY_ADDR_ACK      ((uint32) 0x01u << \
N                                                                UART_2_EXT_I2C_CTRL_S_READY_ADDR_ACK_POS)
X#define UART_2_EXT_I2C_CTRL_S_READY_ADDR_ACK      ((uint32) 0x01u <<                                                                 UART_2_EXT_I2C_CTRL_S_READY_ADDR_ACK_POS)
N#define UART_2_EXT_I2C_CTRL_S_READY_DATA_ACK      ((uint32) 0x01u << \
N                                                                UART_2_EXT_I2C_CTRL_S_READY_DATA_ACK_POS)
X#define UART_2_EXT_I2C_CTRL_S_READY_DATA_ACK      ((uint32) 0x01u <<                                                                 UART_2_EXT_I2C_CTRL_S_READY_DATA_ACK_POS)
N#define UART_2_EXT_I2C_CTRL_S_NOT_READY_ADDR_NACK ((uint32) 0x01u << \
N                                                                UART_2_EXT_I2C_CTRL_S_NOT_READY_ADDR_NACK_POS)
X#define UART_2_EXT_I2C_CTRL_S_NOT_READY_ADDR_NACK ((uint32) 0x01u <<                                                                 UART_2_EXT_I2C_CTRL_S_NOT_READY_ADDR_NACK_POS)
N#define UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK ((uint32) 0x01u << \
N                                                                UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK_POS)
X#define UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK ((uint32) 0x01u <<                                                                 UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK_POS)
N#define UART_2_EXT_I2C_CTRL_LOOPBACK              ((uint32) 0x01u << \
N                                                                UART_2_EXT_I2C_CTRL_LOOPBACK_POS)
X#define UART_2_EXT_I2C_CTRL_LOOPBACK              ((uint32) 0x01u <<                                                                 UART_2_EXT_I2C_CTRL_LOOPBACK_POS)
N#define UART_2_EXT_I2C_CTRL_SLAVE_MODE            ((uint32) 0x01u << \
N                                                                UART_2_EXT_I2C_CTRL_SLAVE_MODE_POS)
X#define UART_2_EXT_I2C_CTRL_SLAVE_MODE            ((uint32) 0x01u <<                                                                 UART_2_EXT_I2C_CTRL_SLAVE_MODE_POS)
N#define UART_2_EXT_I2C_CTRL_MASTER_MODE           ((uint32) 0x01u << \
N                                                                UART_2_EXT_I2C_CTRL_MASTER_MODE_POS)
X#define UART_2_EXT_I2C_CTRL_MASTER_MODE           ((uint32) 0x01u <<                                                                 UART_2_EXT_I2C_CTRL_MASTER_MODE_POS)
N#define UART_2_EXT_I2C_CTRL_SLAVE_MASTER_MODE_MASK    ((uint32) 0x03u << \
N                                                                UART_2_EXT_I2C_CTRL_SLAVE_MODE_POS)
X#define UART_2_EXT_I2C_CTRL_SLAVE_MASTER_MODE_MASK    ((uint32) 0x03u <<                                                                 UART_2_EXT_I2C_CTRL_SLAVE_MODE_POS)
N
N/* UART_2_EXT_I2C_STATUS_REG  */
N#define UART_2_EXT_I2C_STATUS_BUS_BUSY_POS    (0u)  /* [0]    Bus busy: internally clocked */
N#define UART_2_EXT_I2C_STATUS_S_READ_POS      (4u)  /* [4]    Slave is read by master      */
N#define UART_2_EXT_I2C_STATUS_M_READ_POS      (5u)  /* [5]    Master reads Slave           */
N#define UART_2_EXT_I2C_STATUS_EZBUF_ADDR_POS  (8u)  /* [15:8] EZAddress                    */
N#define UART_2_EXT_I2C_STATUS_BUS_BUSY        ((uint32) 0x01u)
N#define UART_2_EXT_I2C_STATUS_S_READ          ((uint32) 0x01u << UART_2_EXT_I2C_STATUS_S_READ_POS)
N#define UART_2_EXT_I2C_STATUS_M_READ          ((uint32) 0x01u << UART_2_EXT_I2C_STATUS_M_READ_POS)
N#define UART_2_EXT_I2C_STATUS_EZBUF_ADDR_MASK ((uint32) 0xFFu << UART_2_EXT_I2C_STATUS_EZBUF_ADDR_POS)
N
N/* UART_2_EXT_I2C_MASTER_CMD_REG */
N#define UART_2_EXT_I2C_MASTER_CMD_M_START_POS             (0u)  /* [0] Master generate Start                */
N#define UART_2_EXT_I2C_MASTER_CMD_M_START_ON_IDLE_POS     (1u)  /* [1] Master generate Start if bus is free */
N#define UART_2_EXT_I2C_MASTER_CMD_M_ACK_POS               (2u)  /* [2] Master generate ACK                  */
N#define UART_2_EXT_I2C_MASTER_CMD_M_NACK_POS              (3u)  /* [3] Master generate NACK                 */
N#define UART_2_EXT_I2C_MASTER_CMD_M_STOP_POS              (4u)  /* [4] Master generate Stop                 */
N#define UART_2_EXT_I2C_MASTER_CMD_M_START         ((uint32) 0x01u)
N#define UART_2_EXT_I2C_MASTER_CMD_M_START_ON_IDLE ((uint32) 0x01u << \
N                                                                   UART_2_EXT_I2C_MASTER_CMD_M_START_ON_IDLE_POS)
X#define UART_2_EXT_I2C_MASTER_CMD_M_START_ON_IDLE ((uint32) 0x01u <<                                                                    UART_2_EXT_I2C_MASTER_CMD_M_START_ON_IDLE_POS)
N#define UART_2_EXT_I2C_MASTER_CMD_M_ACK           ((uint32) 0x01u << \
N                                                                   UART_2_EXT_I2C_MASTER_CMD_M_ACK_POS)
X#define UART_2_EXT_I2C_MASTER_CMD_M_ACK           ((uint32) 0x01u <<                                                                    UART_2_EXT_I2C_MASTER_CMD_M_ACK_POS)
N#define UART_2_EXT_I2C_MASTER_CMD_M_NACK          ((uint32) 0x01u << \
N                                                                    UART_2_EXT_I2C_MASTER_CMD_M_NACK_POS)
X#define UART_2_EXT_I2C_MASTER_CMD_M_NACK          ((uint32) 0x01u <<                                                                     UART_2_EXT_I2C_MASTER_CMD_M_NACK_POS)
N#define UART_2_EXT_I2C_MASTER_CMD_M_STOP          ((uint32) 0x01u << \
N                                                                    UART_2_EXT_I2C_MASTER_CMD_M_STOP_POS)
X#define UART_2_EXT_I2C_MASTER_CMD_M_STOP          ((uint32) 0x01u <<                                                                     UART_2_EXT_I2C_MASTER_CMD_M_STOP_POS)
N
N/* UART_2_EXT_I2C_SLAVE_CMD_REG  */
N#define UART_2_EXT_I2C_SLAVE_CMD_S_ACK_POS    (0u)  /* [0] Slave generate ACK  */
N#define UART_2_EXT_I2C_SLAVE_CMD_S_NACK_POS   (1u)  /* [1] Slave generate NACK */
N#define UART_2_EXT_I2C_SLAVE_CMD_S_ACK        ((uint32) 0x01u)
N#define UART_2_EXT_I2C_SLAVE_CMD_S_NACK       ((uint32) 0x01u << UART_2_EXT_I2C_SLAVE_CMD_S_NACK_POS)
N
N#define UART_2_EXT_I2C_SLAVE_CMD_S_ACK_POS    (0u)  /* [0] Slave generate ACK  */
N#define UART_2_EXT_I2C_SLAVE_CMD_S_NACK_POS   (1u)  /* [1] Slave generate NACK */
N#define UART_2_EXT_I2C_SLAVE_CMD_S_ACK        ((uint32) 0x01u)
N#define UART_2_EXT_I2C_SLAVE_CMD_S_NACK       ((uint32) 0x01u << UART_2_EXT_I2C_SLAVE_CMD_S_NACK_POS)
N
N/* UART_2_EXT_I2C_CFG_REG */
N#if (UART_2_EXT_CY_SCBIP_V0)
X#if ((2 == 0u))
S#define UART_2_EXT_I2C_CFG_SDA_FILT_HYS_POS           (0u)  /* [1:0]   Trim bits for the I2C SDA filter         */
S#define UART_2_EXT_I2C_CFG_SDA_FILT_TRIM_POS          (2u)  /* [3:2]   Trim bits for the I2C SDA filter         */
S#define UART_2_EXT_I2C_CFG_SCL_FILT_HYS_POS           (4u)  /* [5:4]   Trim bits for the I2C SCL filter         */
S#define UART_2_EXT_I2C_CFG_SCL_FILT_TRIM_POS          (6u)  /* [7:6]   Trim bits for the I2C SCL filter         */
S#define UART_2_EXT_I2C_CFG_SDA_FILT_OUT_HYS_POS       (8u)  /* [9:8]   Trim bits for I2C SDA filter output path */
S#define UART_2_EXT_I2C_CFG_SDA_FILT_OUT_TRIM_POS      (10u) /* [11:10] Trim bits for I2C SDA filter output path */
S#define UART_2_EXT_I2C_CFG_SDA_FILT_HS_POS            (16u) /* [16]    '0': 50 ns filter, '1': 10 ns filter     */
S#define UART_2_EXT_I2C_CFG_SDA_FILT_ENABLED_POS       (17u) /* [17]    I2C SDA filter enabled                   */
S#define UART_2_EXT_I2C_CFG_SCL_FILT_HS_POS            (24u) /* [24]    '0': 50 ns filter, '1': 10 ns filter     */
S#define UART_2_EXT_I2C_CFG_SCL_FILT_ENABLED_POS       (25u) /* [25]    I2C SCL filter enabled                   */
S#define UART_2_EXT_I2C_CFG_SDA_FILT_OUT_HS_POS        (26u) /* [26]    '0': 50 ns filter, '1': 10 ns filter     */
S#define UART_2_EXT_I2C_CFG_SDA_FILT_OUT_ENABLED_POS   (27u) /* [27]    I2C SDA output delay filter enabled      */
S#define UART_2_EXT_I2C_CFG_SDA_FILT_HYS_MASK          ((uint32) 0x03u)
S#define UART_2_EXT_I2C_CFG_SDA_FILT_TRIM_MASK         ((uint32) 0x03u << \
S                                                                UART_2_EXT_I2C_CFG_SDA_FILT_TRIM_POS)
X#define UART_2_EXT_I2C_CFG_SDA_FILT_TRIM_MASK         ((uint32) 0x03u <<                                                                 UART_2_EXT_I2C_CFG_SDA_FILT_TRIM_POS)
S#define UART_2_EXT_I2C_CFG_SCL_FILT_HYS_MASK          ((uint32) 0x03u << \
S                                                                UART_2_EXT_I2C_CFG_SCL_FILT_HYS_POS)
X#define UART_2_EXT_I2C_CFG_SCL_FILT_HYS_MASK          ((uint32) 0x03u <<                                                                 UART_2_EXT_I2C_CFG_SCL_FILT_HYS_POS)
S#define UART_2_EXT_I2C_CFG_SCL_FILT_TRIM_MASK         ((uint32) 0x03u << \
S                                                                UART_2_EXT_I2C_CFG_SCL_FILT_TRIM_POS)
X#define UART_2_EXT_I2C_CFG_SCL_FILT_TRIM_MASK         ((uint32) 0x03u <<                                                                 UART_2_EXT_I2C_CFG_SCL_FILT_TRIM_POS)
S#define UART_2_EXT_I2C_CFG_SDA_FILT_OUT_HYS_MASK      ((uint32) 0x03u << \
S                                                                UART_2_EXT_I2C_CFG_SDA_FILT_OUT_HYS_POS)
X#define UART_2_EXT_I2C_CFG_SDA_FILT_OUT_HYS_MASK      ((uint32) 0x03u <<                                                                 UART_2_EXT_I2C_CFG_SDA_FILT_OUT_HYS_POS)
S#define UART_2_EXT_I2C_CFG_SDA_FILT_OUT_TRIM_MASK     ((uint32) 0x03u << \
S                                                                UART_2_EXT_I2C_CFG_SDA_FILT_OUT_TRIM_POS)
X#define UART_2_EXT_I2C_CFG_SDA_FILT_OUT_TRIM_MASK     ((uint32) 0x03u <<                                                                 UART_2_EXT_I2C_CFG_SDA_FILT_OUT_TRIM_POS)
S#define UART_2_EXT_I2C_CFG_SDA_FILT_HS                ((uint32) 0x01u << \
S                                                                UART_2_EXT_I2C_CFG_SDA_FILT_HS_POS)
X#define UART_2_EXT_I2C_CFG_SDA_FILT_HS                ((uint32) 0x01u <<                                                                 UART_2_EXT_I2C_CFG_SDA_FILT_HS_POS)
S#define UART_2_EXT_I2C_CFG_SDA_FILT_ENABLED           ((uint32) 0x01u << \
S                                                                UART_2_EXT_I2C_CFG_SDA_FILT_ENABLED_POS)
X#define UART_2_EXT_I2C_CFG_SDA_FILT_ENABLED           ((uint32) 0x01u <<                                                                 UART_2_EXT_I2C_CFG_SDA_FILT_ENABLED_POS)
S#define UART_2_EXT_I2C_CFG_SCL_FILT_HS                ((uint32) 0x01u << \
S                                                                UART_2_EXT_I2C_CFG_SCL_FILT_HS_POS)
X#define UART_2_EXT_I2C_CFG_SCL_FILT_HS                ((uint32) 0x01u <<                                                                 UART_2_EXT_I2C_CFG_SCL_FILT_HS_POS)
S#define UART_2_EXT_I2C_CFG_SCL_FILT_ENABLED           ((uint32) 0x01u << \
S                                                                UART_2_EXT_I2C_CFG_SCL_FILT_ENABLED_POS)
X#define UART_2_EXT_I2C_CFG_SCL_FILT_ENABLED           ((uint32) 0x01u <<                                                                 UART_2_EXT_I2C_CFG_SCL_FILT_ENABLED_POS)
S#define UART_2_EXT_I2C_CFG_SDA_FILT_OUT_HS            ((uint32) 0x01u << \
S                                                                UART_2_EXT_I2C_CFG_SDA_FILT_OUT_HS_POS)
X#define UART_2_EXT_I2C_CFG_SDA_FILT_OUT_HS            ((uint32) 0x01u <<                                                                 UART_2_EXT_I2C_CFG_SDA_FILT_OUT_HS_POS)
S#define UART_2_EXT_I2C_CFG_SDA_FILT_OUT_ENABLED       ((uint32) 0x01u << \
S                                                                UART_2_EXT_I2C_CFG_SDA_FILT_OUT_ENABLED_POS)
X#define UART_2_EXT_I2C_CFG_SDA_FILT_OUT_ENABLED       ((uint32) 0x01u <<                                                                 UART_2_EXT_I2C_CFG_SDA_FILT_OUT_ENABLED_POS)
N#else
N#define UART_2_EXT_I2C_CFG_SDA_IN_FILT_TRIM_POS   (0u)  /* [1:0] Trim bits for "i2c_sda_in" 50 ns filter */
N#define UART_2_EXT_I2C_CFG_SDA_IN_FILT_SEL_POS    (4u)  /* [4]   "i2c_sda_in" filter delay: 0 ns and 50 ns */
N#define UART_2_EXT_I2C_CFG_SCL_IN_FILT_TRIM_POS   (8u)  /* [9:8] Trim bits for "i2c_scl_in" 50 ns filter */
N#define UART_2_EXT_I2C_CFG_SCL_IN_FILT_SEL_POS    (12u) /* [12]  "i2c_scl_in" filter delay: 0 ns and 50 ns */
N#define UART_2_EXT_I2C_CFG_SDA_OUT_FILT0_TRIM_POS (16u) /* [17:16] Trim bits for "i2c_sda_out" 50 ns filter 0 */
N#define UART_2_EXT_I2C_CFG_SDA_OUT_FILT1_TRIM_POS (18u) /* [19:18] Trim bits for "i2c_sda_out" 50 ns filter 1 */
N#define UART_2_EXT_I2C_CFG_SDA_OUT_FILT2_TRIM_POS (20u) /* [21:20] Trim bits for "i2c_sda_out" 50 ns filter 2 */
N#define UART_2_EXT_I2C_CFG_SDA_OUT_FILT_SEL_POS   (28u) /* [29:28] Cumulative "i2c_sda_out" filter delay: */
N
N#define UART_2_EXT_I2C_CFG_SDA_IN_FILT_TRIM_MASK  ((uint32) 0x03u)
N#define UART_2_EXT_I2C_CFG_SDA_IN_FILT_SEL        ((uint32) 0x01u << UART_2_EXT_I2C_CFG_SDA_IN_FILT_SEL_POS)
N#define UART_2_EXT_I2C_CFG_SCL_IN_FILT_TRIM_MASK  ((uint32) 0x03u << \
N                                                            UART_2_EXT_I2C_CFG_SCL_IN_FILT_TRIM_POS)
X#define UART_2_EXT_I2C_CFG_SCL_IN_FILT_TRIM_MASK  ((uint32) 0x03u <<                                                             UART_2_EXT_I2C_CFG_SCL_IN_FILT_TRIM_POS)
N#define UART_2_EXT_I2C_CFG_SCL_IN_FILT_SEL        ((uint32) 0x01u << UART_2_EXT_I2C_CFG_SCL_IN_FILT_SEL_POS)
N#define UART_2_EXT_I2C_CFG_SDA_OUT_FILT0_TRIM_MASK ((uint32) 0x03u << \
N                                                            UART_2_EXT_I2C_CFG_SDA_OUT_FILT0_TRIM_POS)
X#define UART_2_EXT_I2C_CFG_SDA_OUT_FILT0_TRIM_MASK ((uint32) 0x03u <<                                                             UART_2_EXT_I2C_CFG_SDA_OUT_FILT0_TRIM_POS)
N#define UART_2_EXT_I2C_CFG_SDA_OUT_FILT1_TRIM_MASK ((uint32) 0x03u << \
N                                                            UART_2_EXT_I2C_CFG_SDA_OUT_FILT1_TRIM_POS)
X#define UART_2_EXT_I2C_CFG_SDA_OUT_FILT1_TRIM_MASK ((uint32) 0x03u <<                                                             UART_2_EXT_I2C_CFG_SDA_OUT_FILT1_TRIM_POS)
N#define UART_2_EXT_I2C_CFG_SDA_OUT_FILT2_TRIM_MASK ((uint32) 0x03u << \
N                                                            UART_2_EXT_I2C_CFG_SDA_OUT_FILT2_TRIM_POS)
X#define UART_2_EXT_I2C_CFG_SDA_OUT_FILT2_TRIM_MASK ((uint32) 0x03u <<                                                             UART_2_EXT_I2C_CFG_SDA_OUT_FILT2_TRIM_POS)
N#define UART_2_EXT_I2C_CFG_SDA_OUT_FILT_SEL_MASK   ((uint32) 0x03u << \
N                                                            UART_2_EXT_I2C_CFG_SDA_OUT_FILT_SEL_POS)
X#define UART_2_EXT_I2C_CFG_SDA_OUT_FILT_SEL_MASK   ((uint32) 0x03u <<                                                             UART_2_EXT_I2C_CFG_SDA_OUT_FILT_SEL_POS)
N#endif /* (UART_2_EXT_CY_SCBIP_V0) */
N
N
N/* UART_2_EXT_TX_CTRL_REG */
N#define UART_2_EXT_TX_CTRL_DATA_WIDTH_POS     (0u)  /* [3:0] Data frame width: (Data width - 1) */
N#define UART_2_EXT_TX_CTRL_MSB_FIRST_POS      (8u)  /* [8]   MSB first shifter-out             */
N#define UART_2_EXT_TX_CTRL_ENABLED_POS        (31u) /* [31]  Transmitter enabled               */
N#define UART_2_EXT_TX_CTRL_DATA_WIDTH_MASK    ((uint32) 0x0Fu)
N#define UART_2_EXT_TX_CTRL_MSB_FIRST          ((uint32) 0x01u << UART_2_EXT_TX_CTRL_MSB_FIRST_POS)
N#define UART_2_EXT_TX_CTRL_LSB_FIRST          ((uint32) 0x00u)
N#define UART_2_EXT_TX_CTRL_ENABLED            ((uint32) 0x01u << UART_2_EXT_TX_CTRL_ENABLED_POS)
N
N/* UART_2_EXT_TX_CTRL_FIFO_REG */
N#define UART_2_EXT_TX_FIFO_CTRL_TRIGGER_LEVEL_POS     (0u)  /* [2:0] Trigger level                              */
N#define UART_2_EXT_TX_FIFO_CTRL_CLEAR_POS             (16u) /* [16]  Clear TX FIFO: cleared after set           */
N#define UART_2_EXT_TX_FIFO_CTRL_FREEZE_POS            (17u) /* [17]  Freeze TX FIFO: HW do not inc read pointer */
N#define UART_2_EXT_TX_FIFO_CTRL_TRIGGER_LEVEL_MASK    ((uint32) UART_2_EXT_FF_DATA_NR_LOG2_MASK)
N#define UART_2_EXT_TX_FIFO_CTRL_CLEAR                 ((uint32) 0x01u << UART_2_EXT_TX_FIFO_CTRL_CLEAR_POS)
N#define UART_2_EXT_TX_FIFO_CTRL_FREEZE                ((uint32) 0x01u << UART_2_EXT_TX_FIFO_CTRL_FREEZE_POS)
N
N/* UART_2_EXT_TX_FIFO_STATUS_REG */
N#define UART_2_EXT_TX_FIFO_STATUS_USED_POS    (0u)  /* [3:0]   Amount of entries in TX FIFO */
N#define UART_2_EXT_TX_FIFO_SR_VALID_POS       (15u) /* [15]    Shifter status of TX FIFO    */
N#define UART_2_EXT_TX_FIFO_STATUS_RD_PTR_POS  (16u) /* [18:16] TX FIFO read pointer         */
N#define UART_2_EXT_TX_FIFO_STATUS_WR_PTR_POS  (24u) /* [26:24] TX FIFO write pointer        */
N#define UART_2_EXT_TX_FIFO_STATUS_USED_MASK   ((uint32) UART_2_EXT_FF_DATA_NR_LOG2_PLUS1_MASK)
N#define UART_2_EXT_TX_FIFO_SR_VALID           ((uint32) 0x01u << UART_2_EXT_TX_FIFO_SR_VALID_POS)
N#define UART_2_EXT_TX_FIFO_STATUS_RD_PTR_MASK ((uint32) UART_2_EXT_FF_DATA_NR_LOG2_MASK << \
N                                                                    UART_2_EXT_TX_FIFO_STATUS_RD_PTR_POS)
X#define UART_2_EXT_TX_FIFO_STATUS_RD_PTR_MASK ((uint32) UART_2_EXT_FF_DATA_NR_LOG2_MASK <<                                                                     UART_2_EXT_TX_FIFO_STATUS_RD_PTR_POS)
N#define UART_2_EXT_TX_FIFO_STATUS_WR_PTR_MASK ((uint32) UART_2_EXT_FF_DATA_NR_LOG2_MASK << \
N                                                                    UART_2_EXT_TX_FIFO_STATUS_WR_PTR_POS)
X#define UART_2_EXT_TX_FIFO_STATUS_WR_PTR_MASK ((uint32) UART_2_EXT_FF_DATA_NR_LOG2_MASK <<                                                                     UART_2_EXT_TX_FIFO_STATUS_WR_PTR_POS)
N
N/* UART_2_EXT_TX_FIFO_WR_REG */
N#define UART_2_EXT_TX_FIFO_WR_POS    (0u)  /* [15:0] Data written into TX FIFO */
N#define UART_2_EXT_TX_FIFO_WR_MASK   ((uint32) 0xFFu)
N
N/* UART_2_EXT_RX_CTRL_REG */
N#define UART_2_EXT_RX_CTRL_DATA_WIDTH_POS     (0u)  /* [3:0] Data frame width: (Data width - 1) */
N#define UART_2_EXT_RX_CTRL_MSB_FIRST_POS      (8u)  /* [8]   MSB first shifter-out             */
N#define UART_2_EXT_RX_CTRL_MEDIAN_POS         (9u)  /* [9]   Median filter                     */
N#define UART_2_EXT_RX_CTRL_ENABLED_POS        (31u) /* [31]  Receiver enabled                  */
N#define UART_2_EXT_RX_CTRL_DATA_WIDTH_MASK    ((uint32) 0x0Fu)
N#define UART_2_EXT_RX_CTRL_MSB_FIRST          ((uint32) 0x01u << UART_2_EXT_RX_CTRL_MSB_FIRST_POS)
N#define UART_2_EXT_RX_CTRL_LSB_FIRST          ((uint32) 0x00u)
N#define UART_2_EXT_RX_CTRL_MEDIAN             ((uint32) 0x01u << UART_2_EXT_RX_CTRL_MEDIAN_POS)
N#define UART_2_EXT_RX_CTRL_ENABLED            ((uint32) 0x01u << UART_2_EXT_RX_CTRL_ENABLED_POS)
N
N
N/* UART_2_EXT_RX_FIFO_CTRL_REG */
N#define UART_2_EXT_RX_FIFO_CTRL_TRIGGER_LEVEL_POS     (0u)   /* [2:0] Trigger level                            */
N#define UART_2_EXT_RX_FIFO_CTRL_CLEAR_POS             (16u)  /* [16]  Clear RX FIFO: clear after set           */
N#define UART_2_EXT_RX_FIFO_CTRL_FREEZE_POS            (17u)  /* [17]  Freeze RX FIFO: HW writes has not effect */
N#define UART_2_EXT_RX_FIFO_CTRL_TRIGGER_LEVEL_MASK    ((uint32) UART_2_EXT_FF_DATA_NR_LOG2_MASK)
N#define UART_2_EXT_RX_FIFO_CTRL_CLEAR                 ((uint32) 0x01u << UART_2_EXT_RX_FIFO_CTRL_CLEAR_POS)
N#define UART_2_EXT_RX_FIFO_CTRL_FREEZE                ((uint32) 0x01u << UART_2_EXT_RX_FIFO_CTRL_FREEZE_POS)
N
N/* UART_2_EXT_RX_FIFO_STATUS_REG */
N#define UART_2_EXT_RX_FIFO_STATUS_USED_POS    (0u)   /* [3:0]   Amount of entries in RX FIFO */
N#define UART_2_EXT_RX_FIFO_SR_VALID_POS       (15u)  /* [15]    Shifter status of RX FIFO    */
N#define UART_2_EXT_RX_FIFO_STATUS_RD_PTR_POS  (16u)  /* [18:16] RX FIFO read pointer         */
N#define UART_2_EXT_RX_FIFO_STATUS_WR_PTR_POS  (24u)  /* [26:24] RX FIFO write pointer        */
N#define UART_2_EXT_RX_FIFO_STATUS_USED_MASK   ((uint32) UART_2_EXT_FF_DATA_NR_LOG2_PLUS1_MASK)
N#define UART_2_EXT_RX_FIFO_SR_VALID           ((uint32) 0x01u << UART_2_EXT_RX_FIFO_SR_VALID_POS)
N#define UART_2_EXT_RX_FIFO_STATUS_RD_PTR_MASK ((uint32) UART_2_EXT_FF_DATA_NR_LOG2_MASK << \
N                                                                    UART_2_EXT_RX_FIFO_STATUS_RD_PTR_POS)
X#define UART_2_EXT_RX_FIFO_STATUS_RD_PTR_MASK ((uint32) UART_2_EXT_FF_DATA_NR_LOG2_MASK <<                                                                     UART_2_EXT_RX_FIFO_STATUS_RD_PTR_POS)
N#define UART_2_EXT_RX_FIFO_STATUS_WR_PTR_MASK ((uint32) UART_2_EXT_FF_DATA_NR_LOG2_MASK << \
N                                                                    UART_2_EXT_RX_FIFO_STATUS_WR_PTR_POS)
X#define UART_2_EXT_RX_FIFO_STATUS_WR_PTR_MASK ((uint32) UART_2_EXT_FF_DATA_NR_LOG2_MASK <<                                                                     UART_2_EXT_RX_FIFO_STATUS_WR_PTR_POS)
N
N/* UART_2_EXT_RX_MATCH_REG */
N#define UART_2_EXT_RX_MATCH_ADDR_POS     (0u)  /* [7:0]   Slave address                        */
N#define UART_2_EXT_RX_MATCH_MASK_POS     (16u) /* [23:16] Slave address mask: 0 - doesn't care */
N#define UART_2_EXT_RX_MATCH_ADDR_MASK    ((uint32) 0xFFu)
N#define UART_2_EXT_RX_MATCH_MASK_MASK    ((uint32) 0xFFu << UART_2_EXT_RX_MATCH_MASK_POS)
N
N/* UART_2_EXT_RX_FIFO_WR_REG */
N#define UART_2_EXT_RX_FIFO_RD_POS    (0u)  /* [15:0] Data read from RX FIFO */
N#define UART_2_EXT_RX_FIFO_RD_MASK   ((uint32) 0xFFu)
N
N/* UART_2_EXT_RX_FIFO_RD_SILENT_REG */
N#define UART_2_EXT_RX_FIFO_RD_SILENT_POS     (0u)  /* [15:0] Data read from RX FIFO: not remove data from FIFO */
N#define UART_2_EXT_RX_FIFO_RD_SILENT_MASK    ((uint32) 0xFFu)
N
N/* UART_2_EXT_RX_FIFO_RD_SILENT_REG */
N#define UART_2_EXT_RX_FIFO_RD_SILENT_POS     (0u)  /* [15:0] Data read from RX FIFO: not remove data from FIFO */
N#define UART_2_EXT_RX_FIFO_RD_SILENT_MASK    ((uint32) 0xFFu)
N
N/* UART_2_EXT_EZBUF_DATA_REG */
N#define UART_2_EXT_EZBUF_DATA_POS   (0u)  /* [7:0] Data from EZ Memory */
N#define UART_2_EXT_EZBUF_DATA_MASK  ((uint32) 0xFFu)
N
N/*  UART_2_EXT_INTR_CAUSE_REG */
N#define UART_2_EXT_INTR_CAUSE_MASTER_POS  (0u)  /* [0] Master interrupt active                 */
N#define UART_2_EXT_INTR_CAUSE_SLAVE_POS   (1u)  /* [1] Slave interrupt active                  */
N#define UART_2_EXT_INTR_CAUSE_TX_POS      (2u)  /* [2] Transmitter interrupt active            */
N#define UART_2_EXT_INTR_CAUSE_RX_POS      (3u)  /* [3] Receiver interrupt active               */
N#define UART_2_EXT_INTR_CAUSE_I2C_EC_POS  (4u)  /* [4] Externally clock I2C interrupt active   */
N#define UART_2_EXT_INTR_CAUSE_SPI_EC_POS  (5u)  /* [5] Externally clocked SPI interrupt active */
N#define UART_2_EXT_INTR_CAUSE_MASTER      ((uint32) 0x01u)
N#define UART_2_EXT_INTR_CAUSE_SLAVE       ((uint32) 0x01u << UART_2_EXT_INTR_CAUSE_SLAVE_POS)
N#define UART_2_EXT_INTR_CAUSE_TX          ((uint32) 0x01u << UART_2_EXT_INTR_CAUSE_TX_POS)
N#define UART_2_EXT_INTR_CAUSE_RX          ((uint32) 0x01u << UART_2_EXT_INTR_CAUSE_RX_POS)
N#define UART_2_EXT_INTR_CAUSE_I2C_EC      ((uint32) 0x01u << UART_2_EXT_INTR_CAUSE_I2C_EC_POS)
N#define UART_2_EXT_INTR_CAUSE_SPI_EC      ((uint32) 0x01u << UART_2_EXT_INTR_CAUSE_SPI_EC_POS)
N
N/* UART_2_EXT_INTR_SPI_EC_REG, UART_2_EXT_INTR_SPI_EC_MASK_REG, UART_2_EXT_INTR_SPI_EC_MASKED_REG */
N#define UART_2_EXT_INTR_SPI_EC_WAKE_UP_POS          (0u)  /* [0] Address match: triggers wakeup of chip */
N#define UART_2_EXT_INTR_SPI_EC_EZBUF_STOP_POS       (1u)  /* [1] Externally clocked Stop detected       */
N#define UART_2_EXT_INTR_SPI_EC_EZBUF_WRITE_STOP_POS (2u)  /* [2] Externally clocked Write Stop detected */
N#define UART_2_EXT_INTR_SPI_EC_WAKE_UP              ((uint32) 0x01u)
N#define UART_2_EXT_INTR_SPI_EC_EZBUF_STOP           ((uint32) 0x01u << \
N                                                                    UART_2_EXT_INTR_SPI_EC_EZBUF_STOP_POS)
X#define UART_2_EXT_INTR_SPI_EC_EZBUF_STOP           ((uint32) 0x01u <<                                                                     UART_2_EXT_INTR_SPI_EC_EZBUF_STOP_POS)
N#define UART_2_EXT_INTR_SPI_EC_EZBUF_WRITE_STOP     ((uint32) 0x01u << \
N                                                                    UART_2_EXT_INTR_SPI_EC_EZBUF_WRITE_STOP_POS)
X#define UART_2_EXT_INTR_SPI_EC_EZBUF_WRITE_STOP     ((uint32) 0x01u <<                                                                     UART_2_EXT_INTR_SPI_EC_EZBUF_WRITE_STOP_POS)
N
N/* UART_2_EXT_INTR_I2C_EC, UART_2_EXT_INTR_I2C_EC_MASK, UART_2_EXT_INTR_I2C_EC_MASKED */
N#define UART_2_EXT_INTR_I2C_EC_WAKE_UP_POS          (0u)  /* [0] Address match: triggers wakeup of chip */
N#define UART_2_EXT_INTR_I2C_EC_EZBUF_STOP_POS       (1u)  /* [1] Externally clocked Stop detected       */
N#define UART_2_EXT_INTR_I2C_EC_EZBUF_WRITE_STOP_POS (2u)  /* [2] Externally clocked Write Stop detected */
N#define UART_2_EXT_INTR_I2C_EC_WAKE_UP              ((uint32) 0x01u)
N#define UART_2_EXT_INTR_I2C_EC_EZBUF_STOP           ((uint32) 0x01u << \
N                                                                    UART_2_EXT_INTR_I2C_EC_EZBUF_STOP_POS)
X#define UART_2_EXT_INTR_I2C_EC_EZBUF_STOP           ((uint32) 0x01u <<                                                                     UART_2_EXT_INTR_I2C_EC_EZBUF_STOP_POS)
N#define UART_2_EXT_INTR_I2C_EC_EZBUF_WRITE_STOP     ((uint32) 0x01u << \
N                                                                    UART_2_EXT_INTR_I2C_EC_EZBUF_WRITE_STOP_POS)
X#define UART_2_EXT_INTR_I2C_EC_EZBUF_WRITE_STOP     ((uint32) 0x01u <<                                                                     UART_2_EXT_INTR_I2C_EC_EZBUF_WRITE_STOP_POS)
N
N/* UART_2_EXT_INTR_MASTER, UART_2_EXT_INTR_MASTER_SET,
N   UART_2_EXT_INTR_MASTER_MASK, UART_2_EXT_INTR_MASTER_MASKED */
N#define UART_2_EXT_INTR_MASTER_I2C_ARB_LOST_POS   (0u)  /* [0] Master lost arbitration                          */
N#define UART_2_EXT_INTR_MASTER_I2C_NACK_POS       (1u)  /* [1] Master receives NACK: address or write to slave  */
N#define UART_2_EXT_INTR_MASTER_I2C_ACK_POS        (2u)  /* [2] Master receives NACK: address or write to slave  */
N#define UART_2_EXT_INTR_MASTER_I2C_STOP_POS       (4u)  /* [4] Master detects the Stop: only self generated Stop*/
N#define UART_2_EXT_INTR_MASTER_I2C_BUS_ERROR_POS  (8u)  /* [8] Master detects bus error: misplaced Start or Stop*/
N#define UART_2_EXT_INTR_MASTER_SPI_DONE_POS       (9u)  /* [9] Master complete transfer: Only for SPI           */
N#define UART_2_EXT_INTR_MASTER_I2C_ARB_LOST       ((uint32) 0x01u)
N#define UART_2_EXT_INTR_MASTER_I2C_NACK           ((uint32) 0x01u << UART_2_EXT_INTR_MASTER_I2C_NACK_POS)
N#define UART_2_EXT_INTR_MASTER_I2C_ACK            ((uint32) 0x01u << UART_2_EXT_INTR_MASTER_I2C_ACK_POS)
N#define UART_2_EXT_INTR_MASTER_I2C_STOP           ((uint32) 0x01u << UART_2_EXT_INTR_MASTER_I2C_STOP_POS)
N#define UART_2_EXT_INTR_MASTER_I2C_BUS_ERROR      ((uint32) 0x01u << \
N                                                                    UART_2_EXT_INTR_MASTER_I2C_BUS_ERROR_POS)
X#define UART_2_EXT_INTR_MASTER_I2C_BUS_ERROR      ((uint32) 0x01u <<                                                                     UART_2_EXT_INTR_MASTER_I2C_BUS_ERROR_POS)
N#define UART_2_EXT_INTR_MASTER_SPI_DONE           ((uint32) 0x01u << UART_2_EXT_INTR_MASTER_SPI_DONE_POS)
N
N/*
N* UART_2_EXT_INTR_SLAVE, UART_2_EXT_INTR_SLAVE_SET,
N* UART_2_EXT_INTR_SLAVE_MASK, UART_2_EXT_INTR_SLAVE_MASKED
N*/
N#define UART_2_EXT_INTR_SLAVE_I2C_ARB_LOST_POS         (0u)  /* [0]  Slave lost arbitration                   */
N#define UART_2_EXT_INTR_SLAVE_I2C_NACK_POS             (1u)  /* [1]  Slave receives NACK: master reads data   */
N#define UART_2_EXT_INTR_SLAVE_I2C_ACK_POS              (2u)  /* [2]  Slave receives ACK: master reads data    */
N#define UART_2_EXT_INTR_SLAVE_I2C_WRITE_STOP_POS       (3u)  /* [3]  Slave detects end of write transaction   */
N#define UART_2_EXT_INTR_SLAVE_I2C_STOP_POS             (4u)  /* [4]  Slave detects end of transaction intended */
N#define UART_2_EXT_INTR_SLAVE_I2C_START_POS            (5u)  /* [5]  Slave detects Start                      */
N#define UART_2_EXT_INTR_SLAVE_I2C_ADDR_MATCH_POS       (6u)  /* [6]  Slave address matches                    */
N#define UART_2_EXT_INTR_SLAVE_I2C_GENERAL_POS          (7u)  /* [7]  General call received                    */
N#define UART_2_EXT_INTR_SLAVE_I2C_BUS_ERROR_POS        (8u)  /* [8]  Slave detects bus error                  */
N#define UART_2_EXT_INTR_SLAVE_SPI_EZBUF_WRITE_STOP_POS (9u)  /* [9]  Slave write complete: Only for SPI       */
N#define UART_2_EXT_INTR_SLAVE_SPI_EZBUF_STOP_POS       (10u) /* [10] Slave end of transaction: Only for SPI   */
N#define UART_2_EXT_INTR_SLAVE_SPI_BUS_ERROR_POS        (11u) /* [11] Slave detects bus error: Only for SPI    */
N#define UART_2_EXT_INTR_SLAVE_I2C_ARB_LOST             ((uint32) 0x01u)
N#define UART_2_EXT_INTR_SLAVE_I2C_NACK                 ((uint32) 0x01u << \
N                                                                    UART_2_EXT_INTR_SLAVE_I2C_NACK_POS)
X#define UART_2_EXT_INTR_SLAVE_I2C_NACK                 ((uint32) 0x01u <<                                                                     UART_2_EXT_INTR_SLAVE_I2C_NACK_POS)
N#define UART_2_EXT_INTR_SLAVE_I2C_ACK                  ((uint32) 0x01u << \
N                                                                    UART_2_EXT_INTR_SLAVE_I2C_ACK_POS)
X#define UART_2_EXT_INTR_SLAVE_I2C_ACK                  ((uint32) 0x01u <<                                                                     UART_2_EXT_INTR_SLAVE_I2C_ACK_POS)
N#define UART_2_EXT_INTR_SLAVE_I2C_WRITE_STOP           ((uint32) 0x01u << \
N                                                                    UART_2_EXT_INTR_SLAVE_I2C_WRITE_STOP_POS)
X#define UART_2_EXT_INTR_SLAVE_I2C_WRITE_STOP           ((uint32) 0x01u <<                                                                     UART_2_EXT_INTR_SLAVE_I2C_WRITE_STOP_POS)
N#define UART_2_EXT_INTR_SLAVE_I2C_STOP                 ((uint32) 0x01u << \
N                                                                    UART_2_EXT_INTR_SLAVE_I2C_STOP_POS)
X#define UART_2_EXT_INTR_SLAVE_I2C_STOP                 ((uint32) 0x01u <<                                                                     UART_2_EXT_INTR_SLAVE_I2C_STOP_POS)
N#define UART_2_EXT_INTR_SLAVE_I2C_START                ((uint32) 0x01u << \
N                                                                    UART_2_EXT_INTR_SLAVE_I2C_START_POS)
X#define UART_2_EXT_INTR_SLAVE_I2C_START                ((uint32) 0x01u <<                                                                     UART_2_EXT_INTR_SLAVE_I2C_START_POS)
N#define UART_2_EXT_INTR_SLAVE_I2C_ADDR_MATCH           ((uint32) 0x01u << \
N                                                                    UART_2_EXT_INTR_SLAVE_I2C_ADDR_MATCH_POS)
X#define UART_2_EXT_INTR_SLAVE_I2C_ADDR_MATCH           ((uint32) 0x01u <<                                                                     UART_2_EXT_INTR_SLAVE_I2C_ADDR_MATCH_POS)
N#define UART_2_EXT_INTR_SLAVE_I2C_GENERAL              ((uint32) 0x01u << \
N                                                                    UART_2_EXT_INTR_SLAVE_I2C_GENERAL_POS)
X#define UART_2_EXT_INTR_SLAVE_I2C_GENERAL              ((uint32) 0x01u <<                                                                     UART_2_EXT_INTR_SLAVE_I2C_GENERAL_POS)
N#define UART_2_EXT_INTR_SLAVE_I2C_BUS_ERROR            ((uint32) 0x01u << \
N                                                                    UART_2_EXT_INTR_SLAVE_I2C_BUS_ERROR_POS)
X#define UART_2_EXT_INTR_SLAVE_I2C_BUS_ERROR            ((uint32) 0x01u <<                                                                     UART_2_EXT_INTR_SLAVE_I2C_BUS_ERROR_POS)
N#define UART_2_EXT_INTR_SLAVE_SPI_EZBUF_WRITE_STOP     ((uint32) 0x01u << \
N                                                                   UART_2_EXT_INTR_SLAVE_SPI_EZBUF_WRITE_STOP_POS)
X#define UART_2_EXT_INTR_SLAVE_SPI_EZBUF_WRITE_STOP     ((uint32) 0x01u <<                                                                    UART_2_EXT_INTR_SLAVE_SPI_EZBUF_WRITE_STOP_POS)
N#define UART_2_EXT_INTR_SLAVE_SPI_EZBUF_STOP           ((uint32) 0x01u << \
N                                                                    UART_2_EXT_INTR_SLAVE_SPI_EZBUF_STOP_POS)
X#define UART_2_EXT_INTR_SLAVE_SPI_EZBUF_STOP           ((uint32) 0x01u <<                                                                     UART_2_EXT_INTR_SLAVE_SPI_EZBUF_STOP_POS)
N#define UART_2_EXT_INTR_SLAVE_SPI_BUS_ERROR           ((uint32) 0x01u << \
N                                                                    UART_2_EXT_INTR_SLAVE_SPI_BUS_ERROR_POS)
X#define UART_2_EXT_INTR_SLAVE_SPI_BUS_ERROR           ((uint32) 0x01u <<                                                                     UART_2_EXT_INTR_SLAVE_SPI_BUS_ERROR_POS)
N
N/*
N* UART_2_EXT_INTR_TX, UART_2_EXT_INTR_TX_SET,
N* UART_2_EXT_INTR_TX_MASK, UART_2_EXT_INTR_TX_MASKED
N*/
N#define UART_2_EXT_INTR_TX_TRIGGER_POS        (0u)  /* [0]  Trigger on TX FIFO entires                       */
N#define UART_2_EXT_INTR_TX_NOT_FULL_POS       (1u)  /* [1]  TX FIFO is not full                              */
N#define UART_2_EXT_INTR_TX_EMPTY_POS          (4u)  /* [4]  TX FIFO is empty                                 */
N#define UART_2_EXT_INTR_TX_OVERFLOW_POS       (5u)  /* [5]  Attempt to write to a full TX FIFO               */
N#define UART_2_EXT_INTR_TX_UNDERFLOW_POS      (6u)  /* [6]  Attempt to read from an empty TX FIFO            */
N#define UART_2_EXT_INTR_TX_BLOCKED_POS        (7u)  /* [7]  No access to the EZ memory                       */
N#define UART_2_EXT_INTR_TX_UART_NACK_POS      (8u)  /* [8]  UART transmitter received a NACK: SmartCard mode */
N#define UART_2_EXT_INTR_TX_UART_DONE_POS      (9u)  /* [9]  UART transmitter done even                       */
N#define UART_2_EXT_INTR_TX_UART_ARB_LOST_POS  (10u) /* [10] UART lost arbitration: LIN or SmartCard          */
N#define UART_2_EXT_INTR_TX_TRIGGER            ((uint32) 0x01u)
N#define UART_2_EXT_INTR_TX_FIFO_LEVEL         (UART_2_EXT_INTR_TX_TRIGGER)
N#define UART_2_EXT_INTR_TX_NOT_FULL           ((uint32) 0x01u << UART_2_EXT_INTR_TX_NOT_FULL_POS)
N#define UART_2_EXT_INTR_TX_EMPTY              ((uint32) 0x01u << UART_2_EXT_INTR_TX_EMPTY_POS)
N#define UART_2_EXT_INTR_TX_OVERFLOW           ((uint32) 0x01u << UART_2_EXT_INTR_TX_OVERFLOW_POS)
N#define UART_2_EXT_INTR_TX_UNDERFLOW          ((uint32) 0x01u << UART_2_EXT_INTR_TX_UNDERFLOW_POS)
N#define UART_2_EXT_INTR_TX_BLOCKED            ((uint32) 0x01u << UART_2_EXT_INTR_TX_BLOCKED_POS)
N#define UART_2_EXT_INTR_TX_UART_NACK          ((uint32) 0x01u << UART_2_EXT_INTR_TX_UART_NACK_POS)
N#define UART_2_EXT_INTR_TX_UART_DONE          ((uint32) 0x01u << UART_2_EXT_INTR_TX_UART_DONE_POS)
N#define UART_2_EXT_INTR_TX_UART_ARB_LOST      ((uint32) 0x01u << UART_2_EXT_INTR_TX_UART_ARB_LOST_POS)
N
N/*
N* UART_2_EXT_INTR_RX, UART_2_EXT_INTR_RX_SET,
N* UART_2_EXT_INTR_RX_MASK, UART_2_EXT_INTR_RX_MASKED
N*/
N#define UART_2_EXT_INTR_RX_TRIGGER_POS        (0u)   /* [0]  Trigger on RX FIFO entires            */
N#define UART_2_EXT_INTR_RX_NOT_EMPTY_POS      (2u)   /* [2]  RX FIFO is not empty                  */
N#define UART_2_EXT_INTR_RX_FULL_POS           (3u)   /* [3]  RX FIFO is full                       */
N#define UART_2_EXT_INTR_RX_OVERFLOW_POS       (5u)   /* [5]  Attempt to write to a full RX FIFO    */
N#define UART_2_EXT_INTR_RX_UNDERFLOW_POS      (6u)   /* [6]  Attempt to read from an empty RX FIFO */
N#define UART_2_EXT_INTR_RX_BLOCKED_POS        (7u)   /* [7]  No access to the EZ memory            */
N#define UART_2_EXT_INTR_RX_FRAME_ERROR_POS    (8u)   /* [8]  Frame error in received data frame    */
N#define UART_2_EXT_INTR_RX_PARITY_ERROR_POS   (9u)   /* [9]  Parity error in received data frame   */
N#define UART_2_EXT_INTR_RX_BAUD_DETECT_POS    (10u)  /* [10] LIN baud rate detection is completed   */
N#define UART_2_EXT_INTR_RX_BREAK_DETECT_POS   (11u)  /* [11] Break detection is successful         */
N#define UART_2_EXT_INTR_RX_TRIGGER            ((uint32) 0x01u)
N#define UART_2_EXT_INTR_RX_FIFO_LEVEL         (UART_2_EXT_INTR_RX_TRIGGER)
N#define UART_2_EXT_INTR_RX_NOT_EMPTY          ((uint32) 0x01u << UART_2_EXT_INTR_RX_NOT_EMPTY_POS)
N#define UART_2_EXT_INTR_RX_FULL               ((uint32) 0x01u << UART_2_EXT_INTR_RX_FULL_POS)
N#define UART_2_EXT_INTR_RX_OVERFLOW           ((uint32) 0x01u << UART_2_EXT_INTR_RX_OVERFLOW_POS)
N#define UART_2_EXT_INTR_RX_UNDERFLOW          ((uint32) 0x01u << UART_2_EXT_INTR_RX_UNDERFLOW_POS)
N#define UART_2_EXT_INTR_RX_BLOCKED            ((uint32) 0x01u << UART_2_EXT_INTR_RX_BLOCKED_POS)
N#define UART_2_EXT_INTR_RX_FRAME_ERROR        ((uint32) 0x01u << UART_2_EXT_INTR_RX_FRAME_ERROR_POS)
N#define UART_2_EXT_INTR_RX_PARITY_ERROR       ((uint32) 0x01u << UART_2_EXT_INTR_RX_PARITY_ERROR_POS)
N#define UART_2_EXT_INTR_RX_BAUD_DETECT        ((uint32) 0x01u << UART_2_EXT_INTR_RX_BAUD_DETECT_POS)
N#define UART_2_EXT_INTR_RX_BREAK_DETECT       ((uint32) 0x01u << UART_2_EXT_INTR_RX_BREAK_DETECT_POS)
N
N/* Define all interrupt sources */
N#define UART_2_EXT_INTR_I2C_EC_ALL    (UART_2_EXT_INTR_I2C_EC_WAKE_UP    | \
N                                             UART_2_EXT_INTR_I2C_EC_EZBUF_STOP | \
N                                             UART_2_EXT_INTR_I2C_EC_EZBUF_WRITE_STOP)
X#define UART_2_EXT_INTR_I2C_EC_ALL    (UART_2_EXT_INTR_I2C_EC_WAKE_UP    |                                              UART_2_EXT_INTR_I2C_EC_EZBUF_STOP |                                              UART_2_EXT_INTR_I2C_EC_EZBUF_WRITE_STOP)
N
N#define UART_2_EXT_INTR_SPI_EC_ALL    (UART_2_EXT_INTR_SPI_EC_WAKE_UP    | \
N                                             UART_2_EXT_INTR_SPI_EC_EZBUF_STOP | \
N                                             UART_2_EXT_INTR_SPI_EC_EZBUF_WRITE_STOP)
X#define UART_2_EXT_INTR_SPI_EC_ALL    (UART_2_EXT_INTR_SPI_EC_WAKE_UP    |                                              UART_2_EXT_INTR_SPI_EC_EZBUF_STOP |                                              UART_2_EXT_INTR_SPI_EC_EZBUF_WRITE_STOP)
N
N#define UART_2_EXT_INTR_MASTER_ALL    (UART_2_EXT_INTR_MASTER_I2C_ARB_LOST  | \
N                                             UART_2_EXT_INTR_MASTER_I2C_NACK      | \
N                                             UART_2_EXT_INTR_MASTER_I2C_ACK       | \
N                                             UART_2_EXT_INTR_MASTER_I2C_STOP      | \
N                                             UART_2_EXT_INTR_MASTER_I2C_BUS_ERROR | \
N                                             UART_2_EXT_INTR_MASTER_SPI_DONE)
X#define UART_2_EXT_INTR_MASTER_ALL    (UART_2_EXT_INTR_MASTER_I2C_ARB_LOST  |                                              UART_2_EXT_INTR_MASTER_I2C_NACK      |                                              UART_2_EXT_INTR_MASTER_I2C_ACK       |                                              UART_2_EXT_INTR_MASTER_I2C_STOP      |                                              UART_2_EXT_INTR_MASTER_I2C_BUS_ERROR |                                              UART_2_EXT_INTR_MASTER_SPI_DONE)
N
N#define UART_2_EXT_INTR_SLAVE_ALL     (UART_2_EXT_INTR_SLAVE_I2C_ARB_LOST      | \
N                                             UART_2_EXT_INTR_SLAVE_I2C_NACK          | \
N                                             UART_2_EXT_INTR_SLAVE_I2C_ACK           | \
N                                             UART_2_EXT_INTR_SLAVE_I2C_WRITE_STOP    | \
N                                             UART_2_EXT_INTR_SLAVE_I2C_STOP          | \
N                                             UART_2_EXT_INTR_SLAVE_I2C_START         | \
N                                             UART_2_EXT_INTR_SLAVE_I2C_ADDR_MATCH    | \
N                                             UART_2_EXT_INTR_SLAVE_I2C_GENERAL       | \
N                                             UART_2_EXT_INTR_SLAVE_I2C_BUS_ERROR     | \
N                                             UART_2_EXT_INTR_SLAVE_SPI_EZBUF_WRITE_STOP | \
N                                             UART_2_EXT_INTR_SLAVE_SPI_EZBUF_STOP       | \
N                                             UART_2_EXT_INTR_SLAVE_SPI_BUS_ERROR)
X#define UART_2_EXT_INTR_SLAVE_ALL     (UART_2_EXT_INTR_SLAVE_I2C_ARB_LOST      |                                              UART_2_EXT_INTR_SLAVE_I2C_NACK          |                                              UART_2_EXT_INTR_SLAVE_I2C_ACK           |                                              UART_2_EXT_INTR_SLAVE_I2C_WRITE_STOP    |                                              UART_2_EXT_INTR_SLAVE_I2C_STOP          |                                              UART_2_EXT_INTR_SLAVE_I2C_START         |                                              UART_2_EXT_INTR_SLAVE_I2C_ADDR_MATCH    |                                              UART_2_EXT_INTR_SLAVE_I2C_GENERAL       |                                              UART_2_EXT_INTR_SLAVE_I2C_BUS_ERROR     |                                              UART_2_EXT_INTR_SLAVE_SPI_EZBUF_WRITE_STOP |                                              UART_2_EXT_INTR_SLAVE_SPI_EZBUF_STOP       |                                              UART_2_EXT_INTR_SLAVE_SPI_BUS_ERROR)
N
N#define UART_2_EXT_INTR_TX_ALL        (UART_2_EXT_INTR_TX_TRIGGER   | \
N                                             UART_2_EXT_INTR_TX_NOT_FULL  | \
N                                             UART_2_EXT_INTR_TX_EMPTY     | \
N                                             UART_2_EXT_INTR_TX_OVERFLOW  | \
N                                             UART_2_EXT_INTR_TX_UNDERFLOW | \
N                                             UART_2_EXT_INTR_TX_BLOCKED   | \
N                                             UART_2_EXT_INTR_TX_UART_NACK | \
N                                             UART_2_EXT_INTR_TX_UART_DONE | \
N                                             UART_2_EXT_INTR_TX_UART_ARB_LOST)
X#define UART_2_EXT_INTR_TX_ALL        (UART_2_EXT_INTR_TX_TRIGGER   |                                              UART_2_EXT_INTR_TX_NOT_FULL  |                                              UART_2_EXT_INTR_TX_EMPTY     |                                              UART_2_EXT_INTR_TX_OVERFLOW  |                                              UART_2_EXT_INTR_TX_UNDERFLOW |                                              UART_2_EXT_INTR_TX_BLOCKED   |                                              UART_2_EXT_INTR_TX_UART_NACK |                                              UART_2_EXT_INTR_TX_UART_DONE |                                              UART_2_EXT_INTR_TX_UART_ARB_LOST)
N
N#define UART_2_EXT_INTR_RX_ALL        (UART_2_EXT_INTR_RX_TRIGGER      | \
N                                             UART_2_EXT_INTR_RX_NOT_EMPTY    | \
N                                             UART_2_EXT_INTR_RX_FULL         | \
N                                             UART_2_EXT_INTR_RX_OVERFLOW     | \
N                                             UART_2_EXT_INTR_RX_UNDERFLOW    | \
N                                             UART_2_EXT_INTR_RX_BLOCKED      | \
N                                             UART_2_EXT_INTR_RX_FRAME_ERROR  | \
N                                             UART_2_EXT_INTR_RX_PARITY_ERROR | \
N                                             UART_2_EXT_INTR_RX_BAUD_DETECT  | \
N                                             UART_2_EXT_INTR_RX_BREAK_DETECT)
X#define UART_2_EXT_INTR_RX_ALL        (UART_2_EXT_INTR_RX_TRIGGER      |                                              UART_2_EXT_INTR_RX_NOT_EMPTY    |                                              UART_2_EXT_INTR_RX_FULL         |                                              UART_2_EXT_INTR_RX_OVERFLOW     |                                              UART_2_EXT_INTR_RX_UNDERFLOW    |                                              UART_2_EXT_INTR_RX_BLOCKED      |                                              UART_2_EXT_INTR_RX_FRAME_ERROR  |                                              UART_2_EXT_INTR_RX_PARITY_ERROR |                                              UART_2_EXT_INTR_RX_BAUD_DETECT  |                                              UART_2_EXT_INTR_RX_BREAK_DETECT)
N
N/* I2C and EZI2C slave address defines */
N#define UART_2_EXT_I2C_SLAVE_ADDR_POS    (0x01u)    /* 7-bit address shift */
N#define UART_2_EXT_I2C_SLAVE_ADDR_MASK   (0xFEu)    /* 8-bit address mask */
N
N/* OVS constants for IrDA Low Power operation */
N#define UART_2_EXT_CTRL_OVS_IRDA_LP_OVS16     (0x00u)
N#define UART_2_EXT_CTRL_OVS_IRDA_LP_OVS32     (0x01u)
N#define UART_2_EXT_CTRL_OVS_IRDA_LP_OVS48     (0x02u)
N#define UART_2_EXT_CTRL_OVS_IRDA_LP_OVS96     (0x03u)
N#define UART_2_EXT_CTRL_OVS_IRDA_LP_OVS192    (0x04u)
N#define UART_2_EXT_CTRL_OVS_IRDA_LP_OVS768    (0x05u)
N#define UART_2_EXT_CTRL_OVS_IRDA_LP_OVS1536   (0x06u)
N
N/* OVS constant for IrDA */
N#define UART_2_EXT_CTRL_OVS_IRDA_OVS16        (UART_2_EXT_UART_IRDA_LP_OVS16)
N
N
N/***************************************
N*    Common Macro Definitions
N***************************************/
N
N/* Re-enables the SCB IP. A clear enable bit has a different effect
N* on the scb IP depending on the version:
N*  CY_SCBIP_V0: resets state, status, TX and RX FIFOs.
N*  CY_SCBIP_V1 or later: resets state, status, TX and RX FIFOs and interrupt sources.
N* Clear I2C command registers are because they are not impacted by re-enable.
N*/
N#define UART_2_EXT_SCB_SW_RESET   UART_2_EXT_I2CFwBlockReset()
N
N/* TX FIFO macro */
N#define UART_2_EXT_CLEAR_TX_FIFO \
N                            do{        \
N                                UART_2_EXT_TX_FIFO_CTRL_REG |= ((uint32)  UART_2_EXT_TX_FIFO_CTRL_CLEAR); \
N                                UART_2_EXT_TX_FIFO_CTRL_REG &= ((uint32) ~UART_2_EXT_TX_FIFO_CTRL_CLEAR); \
N                            }while(0)
X#define UART_2_EXT_CLEAR_TX_FIFO                             do{                                        UART_2_EXT_TX_FIFO_CTRL_REG |= ((uint32)  UART_2_EXT_TX_FIFO_CTRL_CLEAR);                                 UART_2_EXT_TX_FIFO_CTRL_REG &= ((uint32) ~UART_2_EXT_TX_FIFO_CTRL_CLEAR);                             }while(0)
N
N#define UART_2_EXT_GET_TX_FIFO_ENTRIES    (UART_2_EXT_TX_FIFO_STATUS_REG & \
N                                                 UART_2_EXT_TX_FIFO_STATUS_USED_MASK)
X#define UART_2_EXT_GET_TX_FIFO_ENTRIES    (UART_2_EXT_TX_FIFO_STATUS_REG &                                                  UART_2_EXT_TX_FIFO_STATUS_USED_MASK)
N
N#define UART_2_EXT_GET_TX_FIFO_SR_VALID   ((0u != (UART_2_EXT_TX_FIFO_STATUS_REG & \
N                                                         UART_2_EXT_TX_FIFO_SR_VALID)) ? (1u) : (0u))
X#define UART_2_EXT_GET_TX_FIFO_SR_VALID   ((0u != (UART_2_EXT_TX_FIFO_STATUS_REG &                                                          UART_2_EXT_TX_FIFO_SR_VALID)) ? (1u) : (0u))
N
N/* RX FIFO macro */
N#define UART_2_EXT_CLEAR_RX_FIFO \
N                            do{        \
N                                UART_2_EXT_RX_FIFO_CTRL_REG |= ((uint32)  UART_2_EXT_RX_FIFO_CTRL_CLEAR); \
N                                UART_2_EXT_RX_FIFO_CTRL_REG &= ((uint32) ~UART_2_EXT_RX_FIFO_CTRL_CLEAR); \
N                            }while(0)
X#define UART_2_EXT_CLEAR_RX_FIFO                             do{                                        UART_2_EXT_RX_FIFO_CTRL_REG |= ((uint32)  UART_2_EXT_RX_FIFO_CTRL_CLEAR);                                 UART_2_EXT_RX_FIFO_CTRL_REG &= ((uint32) ~UART_2_EXT_RX_FIFO_CTRL_CLEAR);                             }while(0)
N
N#define UART_2_EXT_GET_RX_FIFO_ENTRIES    (UART_2_EXT_RX_FIFO_STATUS_REG & \
N                                                    UART_2_EXT_RX_FIFO_STATUS_USED_MASK)
X#define UART_2_EXT_GET_RX_FIFO_ENTRIES    (UART_2_EXT_RX_FIFO_STATUS_REG &                                                     UART_2_EXT_RX_FIFO_STATUS_USED_MASK)
N
N#define UART_2_EXT_GET_RX_FIFO_SR_VALID   ((0u != (UART_2_EXT_RX_FIFO_STATUS_REG & \
N                                                         UART_2_EXT_RX_FIFO_SR_VALID)) ? (1u) : (0u))
X#define UART_2_EXT_GET_RX_FIFO_SR_VALID   ((0u != (UART_2_EXT_RX_FIFO_STATUS_REG &                                                          UART_2_EXT_RX_FIFO_SR_VALID)) ? (1u) : (0u))
N
N/* Write interrupt source: set sourceMask bits in UART_2_EXT_INTR_X_MASK_REG */
N#define UART_2_EXT_WRITE_INTR_I2C_EC_MASK(sourceMask) \
N                                                do{         \
N                                                    UART_2_EXT_INTR_I2C_EC_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_2_EXT_WRITE_INTR_I2C_EC_MASK(sourceMask)                                                 do{                                                             UART_2_EXT_INTR_I2C_EC_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#if (!UART_2_EXT_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_2_EXT_WRITE_INTR_SPI_EC_MASK(sourceMask) \
N                                                do{         \
N                                                    UART_2_EXT_INTR_SPI_EC_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X    #define UART_2_EXT_WRITE_INTR_SPI_EC_MASK(sourceMask)                                                 do{                                                             UART_2_EXT_INTR_SPI_EC_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N#endif /* (!UART_2_EXT_CY_SCBIP_V1) */
N
N#define UART_2_EXT_WRITE_INTR_MASTER_MASK(sourceMask) \
N                                                do{         \
N                                                    UART_2_EXT_INTR_MASTER_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_2_EXT_WRITE_INTR_MASTER_MASK(sourceMask)                                                 do{                                                             UART_2_EXT_INTR_MASTER_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_2_EXT_WRITE_INTR_SLAVE_MASK(sourceMask)  \
N                                                do{         \
N                                                    UART_2_EXT_INTR_SLAVE_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_2_EXT_WRITE_INTR_SLAVE_MASK(sourceMask)                                                  do{                                                             UART_2_EXT_INTR_SLAVE_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_2_EXT_WRITE_INTR_TX_MASK(sourceMask)     \
N                                                do{         \
N                                                    UART_2_EXT_INTR_TX_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_2_EXT_WRITE_INTR_TX_MASK(sourceMask)                                                     do{                                                             UART_2_EXT_INTR_TX_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_2_EXT_WRITE_INTR_RX_MASK(sourceMask)     \
N                                                do{         \
N                                                    UART_2_EXT_INTR_RX_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_2_EXT_WRITE_INTR_RX_MASK(sourceMask)                                                     do{                                                             UART_2_EXT_INTR_RX_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N/* Enable interrupt source: set sourceMask bits in UART_2_EXT_INTR_X_MASK_REG */
N#define UART_2_EXT_ENABLE_INTR_I2C_EC(sourceMask) \
N                                                do{     \
N                                                    UART_2_EXT_INTR_I2C_EC_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_2_EXT_ENABLE_INTR_I2C_EC(sourceMask)                                                 do{                                                         UART_2_EXT_INTR_I2C_EC_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N#if (!UART_2_EXT_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_2_EXT_ENABLE_INTR_SPI_EC(sourceMask) \
N                                                do{     \
N                                                    UART_2_EXT_INTR_SPI_EC_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X    #define UART_2_EXT_ENABLE_INTR_SPI_EC(sourceMask)                                                 do{                                                         UART_2_EXT_INTR_SPI_EC_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N#endif /* (!UART_2_EXT_CY_SCBIP_V1) */
N
N#define UART_2_EXT_ENABLE_INTR_MASTER(sourceMask) \
N                                                do{     \
N                                                    UART_2_EXT_INTR_MASTER_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_2_EXT_ENABLE_INTR_MASTER(sourceMask)                                                 do{                                                         UART_2_EXT_INTR_MASTER_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_2_EXT_ENABLE_INTR_SLAVE(sourceMask)  \
N                                                do{     \
N                                                    UART_2_EXT_INTR_SLAVE_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_2_EXT_ENABLE_INTR_SLAVE(sourceMask)                                                  do{                                                         UART_2_EXT_INTR_SLAVE_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_2_EXT_ENABLE_INTR_TX(sourceMask)     \
N                                                do{     \
N                                                    UART_2_EXT_INTR_TX_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_2_EXT_ENABLE_INTR_TX(sourceMask)                                                     do{                                                         UART_2_EXT_INTR_TX_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_2_EXT_ENABLE_INTR_RX(sourceMask)     \
N                                                do{     \
N                                                    UART_2_EXT_INTR_RX_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_2_EXT_ENABLE_INTR_RX(sourceMask)                                                     do{                                                         UART_2_EXT_INTR_RX_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N/* Disable interrupt source: clear sourceMask bits in UART_2_EXT_INTR_X_MASK_REG */
N#define UART_2_EXT_DISABLE_INTR_I2C_EC(sourceMask) \
N                                do{                      \
N                                    UART_2_EXT_INTR_I2C_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define UART_2_EXT_DISABLE_INTR_I2C_EC(sourceMask)                                 do{                                                          UART_2_EXT_INTR_I2C_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N#if (!UART_2_EXT_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_2_EXT_DISABLE_INTR_SPI_EC(sourceMask) \
N                                do{                      \
N                                    UART_2_EXT_INTR_SPI_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                 }while(0)
X    #define UART_2_EXT_DISABLE_INTR_SPI_EC(sourceMask)                                 do{                                                          UART_2_EXT_INTR_SPI_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                  }while(0)
N#endif /* (!UART_2_EXT_CY_SCBIP_V1) */
N
N#define UART_2_EXT_DISABLE_INTR_MASTER(sourceMask) \
N                                do{                      \
N                                UART_2_EXT_INTR_MASTER_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define UART_2_EXT_DISABLE_INTR_MASTER(sourceMask)                                 do{                                                      UART_2_EXT_INTR_MASTER_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N#define UART_2_EXT_DISABLE_INTR_SLAVE(sourceMask) \
N                                do{                     \
N                                    UART_2_EXT_INTR_SLAVE_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define UART_2_EXT_DISABLE_INTR_SLAVE(sourceMask)                                 do{                                                         UART_2_EXT_INTR_SLAVE_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N#define UART_2_EXT_DISABLE_INTR_TX(sourceMask)    \
N                                do{                     \
N                                    UART_2_EXT_INTR_TX_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                 }while(0)
X#define UART_2_EXT_DISABLE_INTR_TX(sourceMask)                                    do{                                                         UART_2_EXT_INTR_TX_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                  }while(0)
N
N#define UART_2_EXT_DISABLE_INTR_RX(sourceMask)    \
N                                do{                     \
N                                    UART_2_EXT_INTR_RX_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define UART_2_EXT_DISABLE_INTR_RX(sourceMask)                                    do{                                                         UART_2_EXT_INTR_RX_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N/* Set interrupt sources: write sourceMask bits in UART_2_EXT_INTR_X_SET_REG */
N#define UART_2_EXT_SET_INTR_MASTER(sourceMask)    \
N                                                do{     \
N                                                    UART_2_EXT_INTR_MASTER_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_2_EXT_SET_INTR_MASTER(sourceMask)                                                    do{                                                         UART_2_EXT_INTR_MASTER_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_2_EXT_SET_INTR_SLAVE(sourceMask) \
N                                                do{ \
N                                                    UART_2_EXT_INTR_SLAVE_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_2_EXT_SET_INTR_SLAVE(sourceMask)                                                 do{                                                     UART_2_EXT_INTR_SLAVE_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_2_EXT_SET_INTR_TX(sourceMask)    \
N                                                do{ \
N                                                    UART_2_EXT_INTR_TX_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_2_EXT_SET_INTR_TX(sourceMask)                                                    do{                                                     UART_2_EXT_INTR_TX_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_2_EXT_SET_INTR_RX(sourceMask)    \
N                                                do{ \
N                                                    UART_2_EXT_INTR_RX_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_2_EXT_SET_INTR_RX(sourceMask)                                                    do{                                                     UART_2_EXT_INTR_RX_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N/* Clear interrupt sources: write sourceMask bits in UART_2_EXT_INTR_X_REG */
N#define UART_2_EXT_CLEAR_INTR_I2C_EC(sourceMask)  \
N                                                do{     \
N                                                    UART_2_EXT_INTR_I2C_EC_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_2_EXT_CLEAR_INTR_I2C_EC(sourceMask)                                                  do{                                                         UART_2_EXT_INTR_I2C_EC_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#if (!UART_2_EXT_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_2_EXT_CLEAR_INTR_SPI_EC(sourceMask)  \
N                                                do{     \
N                                                    UART_2_EXT_INTR_SPI_EC_REG = (uint32) (sourceMask); \
N                                                }while(0)
X    #define UART_2_EXT_CLEAR_INTR_SPI_EC(sourceMask)                                                  do{                                                         UART_2_EXT_INTR_SPI_EC_REG = (uint32) (sourceMask);                                                 }while(0)
N#endif /* (!UART_2_EXT_CY_SCBIP_V1) */
N
N#define UART_2_EXT_CLEAR_INTR_MASTER(sourceMask)  \
N                                                do{     \
N                                                    UART_2_EXT_INTR_MASTER_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_2_EXT_CLEAR_INTR_MASTER(sourceMask)                                                  do{                                                         UART_2_EXT_INTR_MASTER_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_2_EXT_CLEAR_INTR_SLAVE(sourceMask)   \
N                                                do{     \
N                                                    UART_2_EXT_INTR_SLAVE_REG  = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_2_EXT_CLEAR_INTR_SLAVE(sourceMask)                                                   do{                                                         UART_2_EXT_INTR_SLAVE_REG  = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_2_EXT_CLEAR_INTR_TX(sourceMask)      \
N                                                do{     \
N                                                    UART_2_EXT_INTR_TX_REG     = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_2_EXT_CLEAR_INTR_TX(sourceMask)                                                      do{                                                         UART_2_EXT_INTR_TX_REG     = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_2_EXT_CLEAR_INTR_RX(sourceMask)      \
N                                                do{     \
N                                                    UART_2_EXT_INTR_RX_REG     = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_2_EXT_CLEAR_INTR_RX(sourceMask)                                                      do{                                                         UART_2_EXT_INTR_RX_REG     = (uint32) (sourceMask);                                                 }while(0)
N
N/* Return true if sourceMask is set in UART_2_EXT_INTR_CAUSE_REG */
N#define UART_2_EXT_CHECK_CAUSE_INTR(sourceMask)    (0u != (UART_2_EXT_INTR_CAUSE_REG & (sourceMask)))
N
N/* Return true if sourceMask is set in INTR_X_MASKED_REG */
N#define UART_2_EXT_CHECK_INTR_I2C_EC(sourceMask)  (0u != (UART_2_EXT_INTR_I2C_EC_REG & (sourceMask)))
N#if (!UART_2_EXT_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_2_EXT_CHECK_INTR_SPI_EC(sourceMask)  (0u != (UART_2_EXT_INTR_SPI_EC_REG & (sourceMask)))
N#endif /* (!UART_2_EXT_CY_SCBIP_V1) */
N#define UART_2_EXT_CHECK_INTR_MASTER(sourceMask)  (0u != (UART_2_EXT_INTR_MASTER_REG & (sourceMask)))
N#define UART_2_EXT_CHECK_INTR_SLAVE(sourceMask)   (0u != (UART_2_EXT_INTR_SLAVE_REG  & (sourceMask)))
N#define UART_2_EXT_CHECK_INTR_TX(sourceMask)      (0u != (UART_2_EXT_INTR_TX_REG     & (sourceMask)))
N#define UART_2_EXT_CHECK_INTR_RX(sourceMask)      (0u != (UART_2_EXT_INTR_RX_REG     & (sourceMask)))
N
N/* Return true if sourceMask is set in UART_2_EXT_INTR_X_MASKED_REG */
N#define UART_2_EXT_CHECK_INTR_I2C_EC_MASKED(sourceMask)   (0u != (UART_2_EXT_INTR_I2C_EC_MASKED_REG & \
N                                                                       (sourceMask)))
X#define UART_2_EXT_CHECK_INTR_I2C_EC_MASKED(sourceMask)   (0u != (UART_2_EXT_INTR_I2C_EC_MASKED_REG &                                                                        (sourceMask)))
N#if (!UART_2_EXT_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_2_EXT_CHECK_INTR_SPI_EC_MASKED(sourceMask)   (0u != (UART_2_EXT_INTR_SPI_EC_MASKED_REG & \
N                                                                       (sourceMask)))
X    #define UART_2_EXT_CHECK_INTR_SPI_EC_MASKED(sourceMask)   (0u != (UART_2_EXT_INTR_SPI_EC_MASKED_REG &                                                                        (sourceMask)))
N#endif /* (!UART_2_EXT_CY_SCBIP_V1) */
N#define UART_2_EXT_CHECK_INTR_MASTER_MASKED(sourceMask)   (0u != (UART_2_EXT_INTR_MASTER_MASKED_REG & \
N                                                                       (sourceMask)))
X#define UART_2_EXT_CHECK_INTR_MASTER_MASKED(sourceMask)   (0u != (UART_2_EXT_INTR_MASTER_MASKED_REG &                                                                        (sourceMask)))
N#define UART_2_EXT_CHECK_INTR_SLAVE_MASKED(sourceMask)    (0u != (UART_2_EXT_INTR_SLAVE_MASKED_REG  & \
N                                                                       (sourceMask)))
X#define UART_2_EXT_CHECK_INTR_SLAVE_MASKED(sourceMask)    (0u != (UART_2_EXT_INTR_SLAVE_MASKED_REG  &                                                                        (sourceMask)))
N#define UART_2_EXT_CHECK_INTR_TX_MASKED(sourceMask)       (0u != (UART_2_EXT_INTR_TX_MASKED_REG     & \
N                                                                       (sourceMask)))
X#define UART_2_EXT_CHECK_INTR_TX_MASKED(sourceMask)       (0u != (UART_2_EXT_INTR_TX_MASKED_REG     &                                                                        (sourceMask)))
N#define UART_2_EXT_CHECK_INTR_RX_MASKED(sourceMask)       (0u != (UART_2_EXT_INTR_RX_MASKED_REG     & \
N                                                                       (sourceMask)))
X#define UART_2_EXT_CHECK_INTR_RX_MASKED(sourceMask)       (0u != (UART_2_EXT_INTR_RX_MASKED_REG     &                                                                        (sourceMask)))
N
N/* Return true if sourceMask is set in UART_2_EXT_CTRL_REG: generally is used to check enable bit */
N#define UART_2_EXT_GET_CTRL_ENABLED    (0u != (UART_2_EXT_CTRL_REG & UART_2_EXT_CTRL_ENABLED))
N
N#define UART_2_EXT_CHECK_SLAVE_AUTO_ADDR_NACK     (0u != (UART_2_EXT_I2C_CTRL_REG & \
N                                                                UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK))
X#define UART_2_EXT_CHECK_SLAVE_AUTO_ADDR_NACK     (0u != (UART_2_EXT_I2C_CTRL_REG &                                                                 UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK))
N
N
N/***************************************
N*      I2C Macro Definitions
N***************************************/
N
N/* Enable auto ACK/NACK */
N#define UART_2_EXT_ENABLE_SLAVE_AUTO_ADDR_NACK \
N                            do{                      \
N                                UART_2_EXT_I2C_CTRL_REG |= UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_2_EXT_ENABLE_SLAVE_AUTO_ADDR_NACK                             do{                                                      UART_2_EXT_I2C_CTRL_REG |= UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define UART_2_EXT_ENABLE_SLAVE_AUTO_DATA_ACK \
N                            do{                     \
N                                UART_2_EXT_I2C_CTRL_REG |= UART_2_EXT_I2C_CTRL_S_READY_DATA_ACK; \
N                            }while(0)
X#define UART_2_EXT_ENABLE_SLAVE_AUTO_DATA_ACK                             do{                                                     UART_2_EXT_I2C_CTRL_REG |= UART_2_EXT_I2C_CTRL_S_READY_DATA_ACK;                             }while(0)
N
N#define UART_2_EXT_ENABLE_SLAVE_AUTO_DATA_NACK \
N                            do{                      \
N                                UART_2_EXT_I2C_CTRL_REG |= UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_2_EXT_ENABLE_SLAVE_AUTO_DATA_NACK                             do{                                                      UART_2_EXT_I2C_CTRL_REG |= UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define UART_2_EXT_ENABLE_MASTER_AUTO_DATA_ACK \
N                            do{                      \
N                                UART_2_EXT_I2C_CTRL_REG |= UART_2_EXT_I2C_CTRL_M_READY_DATA_ACK; \
N                            }while(0)
X#define UART_2_EXT_ENABLE_MASTER_AUTO_DATA_ACK                             do{                                                      UART_2_EXT_I2C_CTRL_REG |= UART_2_EXT_I2C_CTRL_M_READY_DATA_ACK;                             }while(0)
N
N#define UART_2_EXT_ENABLE_MASTER_AUTO_DATA_NACK \
N                            do{                       \
N                                UART_2_EXT_I2C_CTRL_REG |= UART_2_EXT_I2C_CTRL_M_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_2_EXT_ENABLE_MASTER_AUTO_DATA_NACK                             do{                                                       UART_2_EXT_I2C_CTRL_REG |= UART_2_EXT_I2C_CTRL_M_NOT_READY_DATA_NACK;                             }while(0)
N
N/* Disable auto ACK/NACK */
N#define UART_2_EXT_DISABLE_SLAVE_AUTO_ADDR_NACK \
N                            do{                       \
N                                UART_2_EXT_I2C_CTRL_REG &= ~UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_2_EXT_DISABLE_SLAVE_AUTO_ADDR_NACK                             do{                                                       UART_2_EXT_I2C_CTRL_REG &= ~UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define UART_2_EXT_DISABLE_SLAVE_AUTO_DATA_ACK \
N                            do{                      \
N                                UART_2_EXT_I2C_CTRL_REG &= ~UART_2_EXT_I2C_CTRL_S_READY_DATA_ACK; \
N                            }while(0)
X#define UART_2_EXT_DISABLE_SLAVE_AUTO_DATA_ACK                             do{                                                      UART_2_EXT_I2C_CTRL_REG &= ~UART_2_EXT_I2C_CTRL_S_READY_DATA_ACK;                             }while(0)
N
N#define UART_2_EXT_DISABLE_SLAVE_AUTO_DATA_NACK \
N                            do{                       \
N                                UART_2_EXT_I2C_CTRL_REG &= ~UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_2_EXT_DISABLE_SLAVE_AUTO_DATA_NACK                             do{                                                       UART_2_EXT_I2C_CTRL_REG &= ~UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define UART_2_EXT_DISABLE_MASTER_AUTO_DATA_ACK \
N                            do{                       \
N                                UART_2_EXT_I2C_CTRL_REG &= ~UART_2_EXT_I2C_CTRL_M_READY_DATA_ACK; \
N                            }while(0)
X#define UART_2_EXT_DISABLE_MASTER_AUTO_DATA_ACK                             do{                                                       UART_2_EXT_I2C_CTRL_REG &= ~UART_2_EXT_I2C_CTRL_M_READY_DATA_ACK;                             }while(0)
N
N#define UART_2_EXT_DISABLE_MASTER_AUTO_DATA_NACK \
N                            do{                        \
N                                UART_2_EXT_I2C_CTRL_REG &= ~UART_2_EXT_I2C_CTRL_M_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_2_EXT_DISABLE_MASTER_AUTO_DATA_NACK                             do{                                                        UART_2_EXT_I2C_CTRL_REG &= ~UART_2_EXT_I2C_CTRL_M_NOT_READY_DATA_NACK;                             }while(0)
N
N/* Enable Slave autoACK/NACK Data */
N#define UART_2_EXT_ENABLE_SLAVE_AUTO_DATA \
N                            do{                 \
N                                UART_2_EXT_I2C_CTRL_REG |= (UART_2_EXT_I2C_CTRL_S_READY_DATA_ACK |      \
N                                                                  UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK); \
N                            }while(0)
X#define UART_2_EXT_ENABLE_SLAVE_AUTO_DATA                             do{                                                 UART_2_EXT_I2C_CTRL_REG |= (UART_2_EXT_I2C_CTRL_S_READY_DATA_ACK |                                                                        UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK);                             }while(0)
N
N/* Disable Slave autoACK/NACK Data */
N#define UART_2_EXT_DISABLE_SLAVE_AUTO_DATA \
N                            do{                  \
N                                UART_2_EXT_I2C_CTRL_REG &= ((uint32) \
N                                                                  ~(UART_2_EXT_I2C_CTRL_S_READY_DATA_ACK |       \
N                                                                    UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK)); \
N                            }while(0)
X#define UART_2_EXT_DISABLE_SLAVE_AUTO_DATA                             do{                                                  UART_2_EXT_I2C_CTRL_REG &= ((uint32)                                                                   ~(UART_2_EXT_I2C_CTRL_S_READY_DATA_ACK |                                                                           UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK));                             }while(0)
N
N/* Disable Master autoACK/NACK Data */
N#define UART_2_EXT_DISABLE_MASTER_AUTO_DATA \
N                            do{                   \
N                                UART_2_EXT_I2C_CTRL_REG &= ((uint32) \
N                                                                  ~(UART_2_EXT_I2C_CTRL_M_READY_DATA_ACK |       \
N                                                                    UART_2_EXT_I2C_CTRL_M_NOT_READY_DATA_NACK)); \
N                            }while(0)
X#define UART_2_EXT_DISABLE_MASTER_AUTO_DATA                             do{                                                   UART_2_EXT_I2C_CTRL_REG &= ((uint32)                                                                   ~(UART_2_EXT_I2C_CTRL_M_READY_DATA_ACK |                                                                           UART_2_EXT_I2C_CTRL_M_NOT_READY_DATA_NACK));                             }while(0)
N/* Disables auto data ACK/NACK bits */
N#define UART_2_EXT_DISABLE_AUTO_DATA \
N                do{                        \
N                    UART_2_EXT_I2C_CTRL_REG &= ((uint32) ~(UART_2_EXT_I2C_CTRL_M_READY_DATA_ACK      |  \
N                                                                 UART_2_EXT_I2C_CTRL_M_NOT_READY_DATA_NACK |  \
N                                                                 UART_2_EXT_I2C_CTRL_S_READY_DATA_ACK      |  \
N                                                                 UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK)); \
N                }while(0)
X#define UART_2_EXT_DISABLE_AUTO_DATA                 do{                                            UART_2_EXT_I2C_CTRL_REG &= ((uint32) ~(UART_2_EXT_I2C_CTRL_M_READY_DATA_ACK      |                                                                   UART_2_EXT_I2C_CTRL_M_NOT_READY_DATA_NACK |                                                                   UART_2_EXT_I2C_CTRL_S_READY_DATA_ACK      |                                                                   UART_2_EXT_I2C_CTRL_S_NOT_READY_DATA_NACK));                 }while(0)
N
N/* Master commands */
N#define UART_2_EXT_I2C_MASTER_GENERATE_START \
N                            do{                    \
N                                UART_2_EXT_I2C_MASTER_CMD_REG = UART_2_EXT_I2C_MASTER_CMD_M_START_ON_IDLE; \
N                            }while(0)
X#define UART_2_EXT_I2C_MASTER_GENERATE_START                             do{                                                    UART_2_EXT_I2C_MASTER_CMD_REG = UART_2_EXT_I2C_MASTER_CMD_M_START_ON_IDLE;                             }while(0)
N
N#define UART_2_EXT_I2C_MASTER_CLEAR_START \
N                            do{                 \
N                                UART_2_EXT_I2C_MASTER_CMD_REG =  ((uint32) 0u); \
N                            }while(0)
X#define UART_2_EXT_I2C_MASTER_CLEAR_START                             do{                                                 UART_2_EXT_I2C_MASTER_CMD_REG =  ((uint32) 0u);                             }while(0)
N
N#define UART_2_EXT_I2C_MASTER_GENERATE_RESTART UART_2_EXT_I2CReStartGeneration()
N
N#define UART_2_EXT_I2C_MASTER_GENERATE_STOP \
N                            do{                   \
N                                UART_2_EXT_I2C_MASTER_CMD_REG =                                            \
N                                    (UART_2_EXT_I2C_MASTER_CMD_M_STOP |                                    \
N                                        (UART_2_EXT_CHECK_I2C_STATUS(UART_2_EXT_I2C_STATUS_M_READ) ? \
N                                            (UART_2_EXT_I2C_MASTER_CMD_M_NACK) : (0u)));                   \
N                            }while(0)
X#define UART_2_EXT_I2C_MASTER_GENERATE_STOP                             do{                                                   UART_2_EXT_I2C_MASTER_CMD_REG =                                                                                (UART_2_EXT_I2C_MASTER_CMD_M_STOP |                                                                            (UART_2_EXT_CHECK_I2C_STATUS(UART_2_EXT_I2C_STATUS_M_READ) ?                                             (UART_2_EXT_I2C_MASTER_CMD_M_NACK) : (0u)));                                               }while(0)
N
N#define UART_2_EXT_I2C_MASTER_GENERATE_ACK \
N                            do{                  \
N                                UART_2_EXT_I2C_MASTER_CMD_REG = UART_2_EXT_I2C_MASTER_CMD_M_ACK; \
N                            }while(0)
X#define UART_2_EXT_I2C_MASTER_GENERATE_ACK                             do{                                                  UART_2_EXT_I2C_MASTER_CMD_REG = UART_2_EXT_I2C_MASTER_CMD_M_ACK;                             }while(0)
N
N#define UART_2_EXT_I2C_MASTER_GENERATE_NACK \
N                            do{                   \
N                                UART_2_EXT_I2C_MASTER_CMD_REG = UART_2_EXT_I2C_MASTER_CMD_M_NACK; \
N                            }while(0)
X#define UART_2_EXT_I2C_MASTER_GENERATE_NACK                             do{                                                   UART_2_EXT_I2C_MASTER_CMD_REG = UART_2_EXT_I2C_MASTER_CMD_M_NACK;                             }while(0)
N
N/* Slave commands */
N#define UART_2_EXT_I2C_SLAVE_GENERATE_ACK \
N                            do{                 \
N                                UART_2_EXT_I2C_SLAVE_CMD_REG = UART_2_EXT_I2C_SLAVE_CMD_S_ACK; \
N                            }while(0)
X#define UART_2_EXT_I2C_SLAVE_GENERATE_ACK                             do{                                                 UART_2_EXT_I2C_SLAVE_CMD_REG = UART_2_EXT_I2C_SLAVE_CMD_S_ACK;                             }while(0)
N
N#if (UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1)
X#if ((2 == 0u) || (2 == 1u))
S    /* Slave NACK generation for EC_AM logic on address phase. Ticket ID #183902 */
S    void UART_2_EXT_I2CSlaveNackGeneration(void);
S    #define UART_2_EXT_I2C_SLAVE_GENERATE_NACK UART_2_EXT_I2CSlaveNackGeneration()
S
N#else
N    #define UART_2_EXT_I2C_SLAVE_GENERATE_NACK \
N                            do{                      \
N                                UART_2_EXT_I2C_SLAVE_CMD_REG = UART_2_EXT_I2C_SLAVE_CMD_S_NACK; \
N                            }while(0)
X    #define UART_2_EXT_I2C_SLAVE_GENERATE_NACK                             do{                                                      UART_2_EXT_I2C_SLAVE_CMD_REG = UART_2_EXT_I2C_SLAVE_CMD_S_NACK;                             }while(0)
N#endif /* (UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1) */
N
N#define UART_2_EXT_I2C_SLAVE_CLEAR_NACK \
N                            do{               \
N                                UART_2_EXT_I2C_SLAVE_CMD_REG = 0u; \
N                            }while(0)
X#define UART_2_EXT_I2C_SLAVE_CLEAR_NACK                             do{                                               UART_2_EXT_I2C_SLAVE_CMD_REG = 0u;                             }while(0)
N
N/* Return 8-bit address. The input address should be 7-bits */
N#define UART_2_EXT_GET_I2C_8BIT_ADDRESS(addr) (((uint32) ((uint32) (addr) << \
N                                                                    UART_2_EXT_I2C_SLAVE_ADDR_POS)) & \
N                                                                        UART_2_EXT_I2C_SLAVE_ADDR_MASK)
X#define UART_2_EXT_GET_I2C_8BIT_ADDRESS(addr) (((uint32) ((uint32) (addr) <<                                                                     UART_2_EXT_I2C_SLAVE_ADDR_POS)) &                                                                         UART_2_EXT_I2C_SLAVE_ADDR_MASK)
N
N#define UART_2_EXT_GET_I2C_7BIT_ADDRESS(addr) ((uint32) (addr) >> UART_2_EXT_I2C_SLAVE_ADDR_POS)
N
N/* Adjust SDA filter Trim settings */
N#define UART_2_EXT_DEFAULT_I2C_CFG_SDA_FILT_TRIM  (0x02u)
N#define UART_2_EXT_EC_AM_I2C_CFG_SDA_FILT_TRIM    (0x03u)
N
N#if (UART_2_EXT_CY_SCBIP_V0)
X#if ((2 == 0u))
S    #define UART_2_EXT_SET_I2C_CFG_SDA_FILT_TRIM(sdaTrim) \
S        do{                                                 \
S            UART_2_EXT_I2C_CFG_REG =                  \
S                            ((UART_2_EXT_I2C_CFG_REG & (uint32) ~UART_2_EXT_I2C_CFG_SDA_FILT_TRIM_MASK) | \
S                             ((uint32) ((uint32) (sdaTrim) <<UART_2_EXT_I2C_CFG_SDA_FILT_TRIM_POS)));           \
S        }while(0)
X    #define UART_2_EXT_SET_I2C_CFG_SDA_FILT_TRIM(sdaTrim)         do{                                                             UART_2_EXT_I2C_CFG_REG =                                              ((UART_2_EXT_I2C_CFG_REG & (uint32) ~UART_2_EXT_I2C_CFG_SDA_FILT_TRIM_MASK) |                              ((uint32) ((uint32) (sdaTrim) <<UART_2_EXT_I2C_CFG_SDA_FILT_TRIM_POS)));                   }while(0)
N#endif /* (UART_2_EXT_CY_SCBIP_V0) */
N
N/* Enable/Disable analog and digital filter */
N#define UART_2_EXT_DIGITAL_FILTER_DISABLE    (0u)
N#define UART_2_EXT_DIGITAL_FILTER_ENABLE     (1u)
N#define UART_2_EXT_I2C_DATA_RATE_FS_MODE_MAX (400u)
N#if (UART_2_EXT_CY_SCBIP_V0)
X#if ((2 == 0u))
S    /* UART_2_EXT_I2C_CFG_SDA_FILT_OUT_ENABLED is disabled by default */
S    #define UART_2_EXT_I2C_CFG_FILT_MASK  (UART_2_EXT_I2C_CFG_SDA_FILT_ENABLED | \
S                                                 UART_2_EXT_I2C_CFG_SCL_FILT_ENABLED)
X    #define UART_2_EXT_I2C_CFG_FILT_MASK  (UART_2_EXT_I2C_CFG_SDA_FILT_ENABLED |                                                  UART_2_EXT_I2C_CFG_SCL_FILT_ENABLED)
N#else
N    /* UART_2_EXT_I2C_CFG_SDA_OUT_FILT_SEL_MASK is disabled by default */
N    #define UART_2_EXT_I2C_CFG_FILT_MASK  (UART_2_EXT_I2C_CFG_SDA_IN_FILT_SEL | \
N                                                 UART_2_EXT_I2C_CFG_SCL_IN_FILT_SEL)
X    #define UART_2_EXT_I2C_CFG_FILT_MASK  (UART_2_EXT_I2C_CFG_SDA_IN_FILT_SEL |                                                  UART_2_EXT_I2C_CFG_SCL_IN_FILT_SEL)
N#endif /* (UART_2_EXT_CY_SCBIP_V0) */
N
N#define UART_2_EXT_I2C_CFG_ANALOG_FITER_DISABLE \
N        do{                                           \
N            UART_2_EXT_I2C_CFG_REG &= (uint32) ~UART_2_EXT_I2C_CFG_FILT_MASK; \
N        }while(0)
X#define UART_2_EXT_I2C_CFG_ANALOG_FITER_DISABLE         do{                                                       UART_2_EXT_I2C_CFG_REG &= (uint32) ~UART_2_EXT_I2C_CFG_FILT_MASK;         }while(0)
N
N#define UART_2_EXT_I2C_CFG_ANALOG_FITER_ENABLE \
N        do{                                          \
N            UART_2_EXT_I2C_CFG_REG |= (uint32)  UART_2_EXT_I2C_CFG_FILT_MASK; \
N        }while(0)
X#define UART_2_EXT_I2C_CFG_ANALOG_FITER_ENABLE         do{                                                      UART_2_EXT_I2C_CFG_REG |= (uint32)  UART_2_EXT_I2C_CFG_FILT_MASK;         }while(0)
N
N/* Return slave select number from SPI_CTRL register */
N#define UART_2_EXT_GET_SPI_CTRL_SS(activeSelect) (((uint32) ((uint32) (activeSelect) << \
N                                                                    UART_2_EXT_SPI_CTRL_SLAVE_SELECT_POS)) & \
N                                                                        UART_2_EXT_SPI_CTRL_SLAVE_SELECT_MASK)
X#define UART_2_EXT_GET_SPI_CTRL_SS(activeSelect) (((uint32) ((uint32) (activeSelect) <<                                                                     UART_2_EXT_SPI_CTRL_SLAVE_SELECT_POS)) &                                                                         UART_2_EXT_SPI_CTRL_SLAVE_SELECT_MASK)
N
N/* Return true if bit is set in UART_2_EXT_I2C_STATUS_REG */
N#define UART_2_EXT_CHECK_I2C_STATUS(sourceMask)   (0u != (UART_2_EXT_I2C_STATUS_REG & (sourceMask)))
N
N/* Return true if bit is set in UART_2_EXT_SPI_STATUS_REG */
N#define UART_2_EXT_CHECK_SPI_STATUS(sourceMask)   (0u != (UART_2_EXT_SPI_STATUS_REG & (sourceMask)))
N
N/* Return FIFO size depends on UART_2_EXT_CTRL_BYTE_MODE bit */
N#define UART_2_EXT_GET_FIFO_SIZE(condition) ((0u != (condition)) ? \
N                                                    (2u * UART_2_EXT_FIFO_SIZE) : (UART_2_EXT_FIFO_SIZE))
X#define UART_2_EXT_GET_FIFO_SIZE(condition) ((0u != (condition)) ?                                                     (2u * UART_2_EXT_FIFO_SIZE) : (UART_2_EXT_FIFO_SIZE))
N
N
N/***************************************
N*       Get Macros Definitions
N***************************************/
N
N/* UART_2_EXT_CTRL */
N#define UART_2_EXT_GET_CTRL_OVS(oversample)       (((uint32) (oversample) - 1u) & UART_2_EXT_CTRL_OVS_MASK)
N
N#define UART_2_EXT_GET_CTRL_EC_OP_MODE(opMode)        ((0u != (opMode)) ? \
N                                                                (UART_2_EXT_CTRL_EC_OP_MODE)  : (0u))
X#define UART_2_EXT_GET_CTRL_EC_OP_MODE(opMode)        ((0u != (opMode)) ?                                                                 (UART_2_EXT_CTRL_EC_OP_MODE)  : (0u))
N
N#define UART_2_EXT_GET_CTRL_EC_AM_MODE(amMode)        ((0u != (amMode)) ? \
N                                                                (UART_2_EXT_CTRL_EC_AM_MODE)  : (0u))
X#define UART_2_EXT_GET_CTRL_EC_AM_MODE(amMode)        ((0u != (amMode)) ?                                                                 (UART_2_EXT_CTRL_EC_AM_MODE)  : (0u))
N
N#define UART_2_EXT_GET_CTRL_BLOCK(block)              ((0u != (block))  ? \
N                                                                (UART_2_EXT_CTRL_BLOCK)       : (0u))
X#define UART_2_EXT_GET_CTRL_BLOCK(block)              ((0u != (block))  ?                                                                 (UART_2_EXT_CTRL_BLOCK)       : (0u))
N
N#define UART_2_EXT_GET_CTRL_ADDR_ACCEPT(acceptAddr)   ((0u != (acceptAddr)) ? \
N                                                                (UART_2_EXT_CTRL_ADDR_ACCEPT) : (0u))
X#define UART_2_EXT_GET_CTRL_ADDR_ACCEPT(acceptAddr)   ((0u != (acceptAddr)) ?                                                                 (UART_2_EXT_CTRL_ADDR_ACCEPT) : (0u))
N
N#if (UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1)
X#if ((2 == 0u) || (2 == 1u))
S    #define UART_2_EXT_GET_CTRL_BYTE_MODE(mode)   (0u)
N#else
N    #define UART_2_EXT_GET_CTRL_BYTE_MODE(mode)   ((0u != (mode)) ? \
N                                                            (UART_2_EXT_CTRL_BYTE_MODE) : (0u))
X    #define UART_2_EXT_GET_CTRL_BYTE_MODE(mode)   ((0u != (mode)) ?                                                             (UART_2_EXT_CTRL_BYTE_MODE) : (0u))
N#endif /* (UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1) */
N
N/* UART_2_EXT_I2C_CTRL */
N#define UART_2_EXT_GET_I2C_CTRL_HIGH_PHASE_OVS(oversampleHigh) (((uint32) (oversampleHigh) - 1u) & \
N                                                                        UART_2_EXT_I2C_CTRL_HIGH_PHASE_OVS_MASK)
X#define UART_2_EXT_GET_I2C_CTRL_HIGH_PHASE_OVS(oversampleHigh) (((uint32) (oversampleHigh) - 1u) &                                                                         UART_2_EXT_I2C_CTRL_HIGH_PHASE_OVS_MASK)
N
N#define UART_2_EXT_GET_I2C_CTRL_LOW_PHASE_OVS(oversampleLow)  ((((uint32) (oversampleLow) - 1u) << \
N                                                                    UART_2_EXT_I2C_CTRL_LOW_PHASE_OVS_POS) &  \
N                                                                    UART_2_EXT_I2C_CTRL_LOW_PHASE_OVS_MASK)
X#define UART_2_EXT_GET_I2C_CTRL_LOW_PHASE_OVS(oversampleLow)  ((((uint32) (oversampleLow) - 1u) <<                                                                     UART_2_EXT_I2C_CTRL_LOW_PHASE_OVS_POS) &                                                                      UART_2_EXT_I2C_CTRL_LOW_PHASE_OVS_MASK)
N
N#define UART_2_EXT_GET_I2C_CTRL_S_NOT_READY_ADDR_NACK(wakeNack) ((0u != (wakeNack)) ? \
N                                                            (UART_2_EXT_I2C_CTRL_S_NOT_READY_ADDR_NACK) : (0u))
X#define UART_2_EXT_GET_I2C_CTRL_S_NOT_READY_ADDR_NACK(wakeNack) ((0u != (wakeNack)) ?                                                             (UART_2_EXT_I2C_CTRL_S_NOT_READY_ADDR_NACK) : (0u))
N
N#define UART_2_EXT_GET_I2C_CTRL_S_GENERAL_IGNORE(genCall) ((0u != (genCall)) ? \
N                                                                    (UART_2_EXT_I2C_CTRL_S_GENERAL_IGNORE) : (0u))
X#define UART_2_EXT_GET_I2C_CTRL_S_GENERAL_IGNORE(genCall) ((0u != (genCall)) ?                                                                     (UART_2_EXT_I2C_CTRL_S_GENERAL_IGNORE) : (0u))
N
N#define UART_2_EXT_GET_I2C_CTRL_SL_MSTR_MODE(mode)    ((uint32)(mode) << UART_2_EXT_I2C_CTRL_SLAVE_MODE_POS)
N
N/* UART_2_EXT_SPI_CTRL */
N#define UART_2_EXT_GET_SPI_CTRL_CONTINUOUS(separate)  ((0u != (separate)) ? \
N                                                                (UART_2_EXT_SPI_CTRL_CONTINUOUS) : (0u))
X#define UART_2_EXT_GET_SPI_CTRL_CONTINUOUS(separate)  ((0u != (separate)) ?                                                                 (UART_2_EXT_SPI_CTRL_CONTINUOUS) : (0u))
N
N#define UART_2_EXT_GET_SPI_CTRL_SELECT_PRECEDE(mode)  ((0u != (mode)) ? \
N                                                                      (UART_2_EXT_SPI_CTRL_SELECT_PRECEDE) : (0u))
X#define UART_2_EXT_GET_SPI_CTRL_SELECT_PRECEDE(mode)  ((0u != (mode)) ?                                                                       (UART_2_EXT_SPI_CTRL_SELECT_PRECEDE) : (0u))
N
N#define UART_2_EXT_GET_SPI_CTRL_SCLK_MODE(mode)       (((uint32) (mode) << \
N                                                                        UART_2_EXT_SPI_CTRL_CPHA_POS) & \
N                                                                        UART_2_EXT_SPI_CTRL_SCLK_MODE_MASK)
X#define UART_2_EXT_GET_SPI_CTRL_SCLK_MODE(mode)       (((uint32) (mode) <<                                                                         UART_2_EXT_SPI_CTRL_CPHA_POS) &                                                                         UART_2_EXT_SPI_CTRL_SCLK_MODE_MASK)
N
N#define UART_2_EXT_GET_SPI_CTRL_LATE_MISO_SAMPLE(lateMiso) ((0u != (lateMiso)) ? \
N                                                                    (UART_2_EXT_SPI_CTRL_LATE_MISO_SAMPLE) : (0u))
X#define UART_2_EXT_GET_SPI_CTRL_LATE_MISO_SAMPLE(lateMiso) ((0u != (lateMiso)) ?                                                                     (UART_2_EXT_SPI_CTRL_LATE_MISO_SAMPLE) : (0u))
N
N#if (UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1)
X#if ((2 == 0u) || (2 == 1u))
S    #define UART_2_EXT_GET_SPI_CTRL_SCLK_CONTINUOUS(sclkType) (0u)
S    #define UART_2_EXT_GET_SPI_CTRL_SSEL_POLARITY(polarity)   (0u)
N#else
N    #define UART_2_EXT_GET_SPI_CTRL_SCLK_CONTINUOUS(sclkType) ((0u != (sclkType)) ? \
N                                                                    (UART_2_EXT_SPI_CTRL_SCLK_CONTINUOUS) : (0u))
X    #define UART_2_EXT_GET_SPI_CTRL_SCLK_CONTINUOUS(sclkType) ((0u != (sclkType)) ?                                                                     (UART_2_EXT_SPI_CTRL_SCLK_CONTINUOUS) : (0u))
N
N    #define UART_2_EXT_GET_SPI_CTRL_SSEL_POLARITY(polarity)   (((uint32) (polarity) << \
N                                                                     UART_2_EXT_SPI_CTRL_SSEL0_POLARITY_POS) & \
N                                                                     UART_2_EXT_SPI_CTRL_SSEL_POLARITY_MASK)
X    #define UART_2_EXT_GET_SPI_CTRL_SSEL_POLARITY(polarity)   (((uint32) (polarity) <<                                                                      UART_2_EXT_SPI_CTRL_SSEL0_POLARITY_POS) &                                                                      UART_2_EXT_SPI_CTRL_SSEL_POLARITY_MASK)
N#endif /* ((UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1) */
N
N#define UART_2_EXT_GET_SPI_CTRL_SUB_MODE(mode)        (((uint32) (mode) << UART_2_EXT_SPI_CTRL_MODE_POS) & \
N                                                                                 UART_2_EXT_SPI_CTRL_MODE_MASK)
X#define UART_2_EXT_GET_SPI_CTRL_SUB_MODE(mode)        (((uint32) (mode) << UART_2_EXT_SPI_CTRL_MODE_POS) &                                                                                  UART_2_EXT_SPI_CTRL_MODE_MASK)
N
N#define UART_2_EXT_GET_SPI_CTRL_SLAVE_SELECT(select)  (((uint32) (select) << \
N                                                                      UART_2_EXT_SPI_CTRL_SLAVE_SELECT_POS) & \
N                                                                      UART_2_EXT_SPI_CTRL_SLAVE_SELECT_MASK)
X#define UART_2_EXT_GET_SPI_CTRL_SLAVE_SELECT(select)  (((uint32) (select) <<                                                                       UART_2_EXT_SPI_CTRL_SLAVE_SELECT_POS) &                                                                       UART_2_EXT_SPI_CTRL_SLAVE_SELECT_MASK)
N
N#define UART_2_EXT_GET_SPI_CTRL_MASTER_MODE(mode)     ((0u != (mode)) ? \
N                                                                (UART_2_EXT_SPI_CTRL_MASTER) : (0u))
X#define UART_2_EXT_GET_SPI_CTRL_MASTER_MODE(mode)     ((0u != (mode)) ?                                                                 (UART_2_EXT_SPI_CTRL_MASTER) : (0u))
N
N/* UART_2_EXT_UART_CTRL */
N#define UART_2_EXT_GET_UART_CTRL_MODE(mode)           (((uint32) (mode) << \
N                                                                            UART_2_EXT_UART_CTRL_MODE_POS) & \
N                                                                            UART_2_EXT_UART_CTRL_MODE_MASK)
X#define UART_2_EXT_GET_UART_CTRL_MODE(mode)           (((uint32) (mode) <<                                                                             UART_2_EXT_UART_CTRL_MODE_POS) &                                                                             UART_2_EXT_UART_CTRL_MODE_MASK)
N
N/* UART_2_EXT_UART_RX_CTRL */
N#define UART_2_EXT_GET_UART_RX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) & \
N                                                                        UART_2_EXT_UART_RX_CTRL_STOP_BITS_MASK)
X#define UART_2_EXT_GET_UART_RX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) &                                                                         UART_2_EXT_UART_RX_CTRL_STOP_BITS_MASK)
N
N#define UART_2_EXT_GET_UART_RX_CTRL_PARITY(parity)    ((0u != (parity)) ? \
N                                                                    (UART_2_EXT_UART_RX_CTRL_PARITY) : (0u))
X#define UART_2_EXT_GET_UART_RX_CTRL_PARITY(parity)    ((0u != (parity)) ?                                                                     (UART_2_EXT_UART_RX_CTRL_PARITY) : (0u))
N
N#define UART_2_EXT_GET_UART_RX_CTRL_POLARITY(polarity)    ((0u != (polarity)) ? \
N                                                                    (UART_2_EXT_UART_RX_CTRL_POLARITY) : (0u))
X#define UART_2_EXT_GET_UART_RX_CTRL_POLARITY(polarity)    ((0u != (polarity)) ?                                                                     (UART_2_EXT_UART_RX_CTRL_POLARITY) : (0u))
N
N#define UART_2_EXT_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(dropErr) ((0u != (dropErr)) ? \
N                                                        (UART_2_EXT_UART_RX_CTRL_DROP_ON_PARITY_ERR) : (0u))
X#define UART_2_EXT_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(dropErr) ((0u != (dropErr)) ?                                                         (UART_2_EXT_UART_RX_CTRL_DROP_ON_PARITY_ERR) : (0u))
N
N#define UART_2_EXT_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(dropErr) ((0u != (dropErr)) ? \
N                                                        (UART_2_EXT_UART_RX_CTRL_DROP_ON_FRAME_ERR) : (0u))
X#define UART_2_EXT_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(dropErr) ((0u != (dropErr)) ?                                                         (UART_2_EXT_UART_RX_CTRL_DROP_ON_FRAME_ERR) : (0u))
N
N#define UART_2_EXT_GET_UART_RX_CTRL_MP_MODE(mpMode)   ((0u != (mpMode)) ? \
N                                                        (UART_2_EXT_UART_RX_CTRL_MP_MODE) : (0u))
X#define UART_2_EXT_GET_UART_RX_CTRL_MP_MODE(mpMode)   ((0u != (mpMode)) ?                                                         (UART_2_EXT_UART_RX_CTRL_MP_MODE) : (0u))
N
N#define UART_2_EXT_GET_UART_RX_CTRL_BREAK_WIDTH(width)    (((uint32) ((uint32) (width) - 1u) << \
N                                                                    UART_2_EXT_UART_RX_CTRL_BREAK_WIDTH_POS) & \
N                                                                    UART_2_EXT_UART_RX_CTRL_BREAK_WIDTH_MASK)
X#define UART_2_EXT_GET_UART_RX_CTRL_BREAK_WIDTH(width)    (((uint32) ((uint32) (width) - 1u) <<                                                                     UART_2_EXT_UART_RX_CTRL_BREAK_WIDTH_POS) &                                                                     UART_2_EXT_UART_RX_CTRL_BREAK_WIDTH_MASK)
N
N/* UART_2_EXT_UART_TX_CTRL */
N#define UART_2_EXT_GET_UART_TX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) & \
N                                                                UART_2_EXT_UART_RX_CTRL_STOP_BITS_MASK)
X#define UART_2_EXT_GET_UART_TX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) &                                                                 UART_2_EXT_UART_RX_CTRL_STOP_BITS_MASK)
N
N#define UART_2_EXT_GET_UART_TX_CTRL_PARITY(parity)    ((0u != (parity)) ? \
N                                                               (UART_2_EXT_UART_TX_CTRL_PARITY) : (0u))
X#define UART_2_EXT_GET_UART_TX_CTRL_PARITY(parity)    ((0u != (parity)) ?                                                                (UART_2_EXT_UART_TX_CTRL_PARITY) : (0u))
N
N#define UART_2_EXT_GET_UART_TX_CTRL_RETRY_NACK(nack)  ((0u != (nack)) ? \
N                                                               (UART_2_EXT_UART_TX_CTRL_RETRY_ON_NACK) : (0u))
X#define UART_2_EXT_GET_UART_TX_CTRL_RETRY_NACK(nack)  ((0u != (nack)) ?                                                                (UART_2_EXT_UART_TX_CTRL_RETRY_ON_NACK) : (0u))
N
N/* UART_2_EXT_UART_FLOW_CTRL */
N#if !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define UART_2_EXT_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(level)   ( (uint32) (level) & \
N                                                                 UART_2_EXT_UART_FLOW_CTRL_TRIGGER_LEVEL_MASK)
X    #define UART_2_EXT_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(level)   ( (uint32) (level) &                                                                  UART_2_EXT_UART_FLOW_CTRL_TRIGGER_LEVEL_MASK)
N
N    #define UART_2_EXT_GET_UART_FLOW_CTRL_RTS_POLARITY(polarity) ((0u != (polarity)) ? \
N                                                                (UART_2_EXT_UART_FLOW_CTRL_RTS_POLARITY) : (0u))
X    #define UART_2_EXT_GET_UART_FLOW_CTRL_RTS_POLARITY(polarity) ((0u != (polarity)) ?                                                                 (UART_2_EXT_UART_FLOW_CTRL_RTS_POLARITY) : (0u))
N
N    #define UART_2_EXT_GET_UART_FLOW_CTRL_CTS_POLARITY(polarity) ((0u != (polarity)) ? \
N                                                                (UART_2_EXT_UART_FLOW_CTRL_CTS_POLARITY) : (0u))
X    #define UART_2_EXT_GET_UART_FLOW_CTRL_CTS_POLARITY(polarity) ((0u != (polarity)) ?                                                                 (UART_2_EXT_UART_FLOW_CTRL_CTS_POLARITY) : (0u))
N
N    #define UART_2_EXT_GET_UART_FLOW_CTRL_CTS_ENABLE(ctsEn)      ((0u != (ctsEn)) ? \
N                                                                (UART_2_EXT_UART_FLOW_CTRL_CTS_ENABLE) : (0u))
X    #define UART_2_EXT_GET_UART_FLOW_CTRL_CTS_ENABLE(ctsEn)      ((0u != (ctsEn)) ?                                                                 (UART_2_EXT_UART_FLOW_CTRL_CTS_ENABLE) : (0u))
N#endif /* !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1) */
N
N/* UART_2_EXT_RX_CTRL */
N#define UART_2_EXT_GET_RX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) & \
N                                                                UART_2_EXT_RX_CTRL_DATA_WIDTH_MASK)
X#define UART_2_EXT_GET_RX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) &                                                                 UART_2_EXT_RX_CTRL_DATA_WIDTH_MASK)
N
N#define UART_2_EXT_GET_RX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ? \
N                                                                (UART_2_EXT_RX_CTRL_MSB_FIRST) : (0u))
X#define UART_2_EXT_GET_RX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ?                                                                 (UART_2_EXT_RX_CTRL_MSB_FIRST) : (0u))
N
N#define UART_2_EXT_GET_RX_CTRL_MEDIAN(filterEn)       ((0u != (filterEn)) ? \
N                                                                (UART_2_EXT_RX_CTRL_MEDIAN) : (0u))
X#define UART_2_EXT_GET_RX_CTRL_MEDIAN(filterEn)       ((0u != (filterEn)) ?                                                                 (UART_2_EXT_RX_CTRL_MEDIAN) : (0u))
N
N/* UART_2_EXT_RX_MATCH */
N#define UART_2_EXT_GET_RX_MATCH_ADDR(addr)    ((uint32) (addr) & UART_2_EXT_RX_MATCH_ADDR_MASK)
N#define UART_2_EXT_GET_RX_MATCH_MASK(mask)    (((uint32) (mask) << \
N                                                            UART_2_EXT_RX_MATCH_MASK_POS) & \
N                                                            UART_2_EXT_RX_MATCH_MASK_MASK)
X#define UART_2_EXT_GET_RX_MATCH_MASK(mask)    (((uint32) (mask) <<                                                             UART_2_EXT_RX_MATCH_MASK_POS) &                                                             UART_2_EXT_RX_MATCH_MASK_MASK)
N
N/* UART_2_EXT_RX_FIFO_CTRL */
N#define UART_2_EXT_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) & \
N                                                                    UART_2_EXT_RX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
X#define UART_2_EXT_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) &                                                                     UART_2_EXT_RX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
N
N/* UART_2_EXT_TX_CTRL */
N#define UART_2_EXT_GET_TX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) & \
N                                                                UART_2_EXT_TX_CTRL_DATA_WIDTH_MASK)
X#define UART_2_EXT_GET_TX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) &                                                                 UART_2_EXT_TX_CTRL_DATA_WIDTH_MASK)
N
N#define UART_2_EXT_GET_TX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ? \
N                                                                (UART_2_EXT_TX_CTRL_MSB_FIRST) : (0u))
X#define UART_2_EXT_GET_TX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ?                                                                 (UART_2_EXT_TX_CTRL_MSB_FIRST) : (0u))
N
N/* UART_2_EXT_TX_FIFO_CTRL */
N#define UART_2_EXT_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) & \
N                                                                    UART_2_EXT_TX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
X#define UART_2_EXT_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) &                                                                     UART_2_EXT_TX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
N
N/* UART_2_EXT_INTR_SLAVE_I2C_GENERAL */
N#define UART_2_EXT_GET_INTR_SLAVE_I2C_GENERAL(genCall)  ((0u != (genCall)) ? \
N                                                                (UART_2_EXT_INTR_SLAVE_I2C_GENERAL) : (0u))
X#define UART_2_EXT_GET_INTR_SLAVE_I2C_GENERAL(genCall)  ((0u != (genCall)) ?                                                                 (UART_2_EXT_INTR_SLAVE_I2C_GENERAL) : (0u))
N
N/* Return true if master mode is enabled UART_2_EXT_SPI_CTRL_REG */
N#define UART_2_EXT_CHECK_SPI_MASTER   (0u != (UART_2_EXT_SPI_CTRL_REG & UART_2_EXT_SPI_CTRL_MASTER))
N
N/* Return inactive state of SPI SCLK line depends on CPOL */
N#define UART_2_EXT_GET_SPI_SCLK_INACTIVE \
N            ((0u == (UART_2_EXT_SPI_CTRL_REG & UART_2_EXT_SPI_CTRL_CPOL)) ? (0u) : (1u))
X#define UART_2_EXT_GET_SPI_SCLK_INACTIVE             ((0u == (UART_2_EXT_SPI_CTRL_REG & UART_2_EXT_SPI_CTRL_CPOL)) ? (0u) : (1u))
N
N/* Get output pin inactive state */
N#if (UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1)
X#if ((2 == 0u) || (2 == 1u))
S#define UART_2_EXT_GET_SPI_SS0_INACTIVE       (1u)
S#define UART_2_EXT_GET_SPI_SS1_INACTIVE       (1u)
S#define UART_2_EXT_GET_SPI_SS2_INACTIVE       (1u)
S#define UART_2_EXT_GET_SPI_SS3_INACTIVE       (1u)
S#define UART_2_EXT_GET_UART_RTS_INACTIVE      (1u)
S
N#else
N#define UART_2_EXT_GET_SPI_SS0_INACTIVE  \
N        ((0u != (UART_2_EXT_SPI_CTRL_REG & UART_2_EXT_SPI_CTRL_SSEL0_POLARITY)) ? (0u) : (1u))
X#define UART_2_EXT_GET_SPI_SS0_INACTIVE          ((0u != (UART_2_EXT_SPI_CTRL_REG & UART_2_EXT_SPI_CTRL_SSEL0_POLARITY)) ? (0u) : (1u))
N
N#define UART_2_EXT_GET_SPI_SS1_INACTIVE  \
N        ((0u != (UART_2_EXT_SPI_CTRL_REG & UART_2_EXT_SPI_CTRL_SSEL1_POLARITY)) ? (0u) : (1u))
X#define UART_2_EXT_GET_SPI_SS1_INACTIVE          ((0u != (UART_2_EXT_SPI_CTRL_REG & UART_2_EXT_SPI_CTRL_SSEL1_POLARITY)) ? (0u) : (1u))
N
N#define UART_2_EXT_GET_SPI_SS2_INACTIVE  \
N        ((0u != (UART_2_EXT_SPI_CTRL_REG & UART_2_EXT_SPI_CTRL_SSEL2_POLARITY)) ? (0u) : (1u))
X#define UART_2_EXT_GET_SPI_SS2_INACTIVE          ((0u != (UART_2_EXT_SPI_CTRL_REG & UART_2_EXT_SPI_CTRL_SSEL2_POLARITY)) ? (0u) : (1u))
N
N#define UART_2_EXT_GET_SPI_SS3_INACTIVE  \
N        ((0u != (UART_2_EXT_SPI_CTRL_REG & UART_2_EXT_SPI_CTRL_SSEL3_POLARITY)) ? (0u) : (1u))
X#define UART_2_EXT_GET_SPI_SS3_INACTIVE          ((0u != (UART_2_EXT_SPI_CTRL_REG & UART_2_EXT_SPI_CTRL_SSEL3_POLARITY)) ? (0u) : (1u))
N
N#define UART_2_EXT_GET_UART_RTS_INACTIVE \
N        ((0u == (UART_2_EXT_UART_FLOW_CTRL_REG & UART_2_EXT_UART_FLOW_CTRL_RTS_POLARITY)) ? (0u) : (1u))
X#define UART_2_EXT_GET_UART_RTS_INACTIVE         ((0u == (UART_2_EXT_UART_FLOW_CTRL_REG & UART_2_EXT_UART_FLOW_CTRL_RTS_POLARITY)) ? (0u) : (1u))
N
N#endif /*(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1) */
N
N/* Clear register constants for configuration and interrupt mask */
N#define UART_2_EXT_CLEAR_REG          ((uint32) (0u))
N#define UART_2_EXT_NO_INTR_SOURCES    ((uint32) (0u))
N#define UART_2_EXT_DUMMY_PARAM        ((uint32) (0u))
N#define UART_2_EXT_SUBMODE_SPI_SLAVE  ((uint32) (0u))
N
N/* Return in case of I2C read error */
N#define UART_2_EXT_I2C_INVALID_BYTE   ((uint32) 0xFFFFFFFFu)
N#define UART_2_EXT_CHECK_VALID_BYTE   ((uint32) 0x80000000u)
N
N
N/***************************************
N* The following code is DEPRECATED and
N* must not be used.
N***************************************/
N
N#define UART_2_EXT_CHECK_INTR_EC_I2C(sourceMask)  UART_2_EXT_CHECK_INTR_I2C_EC(sourceMask)
N#if (!UART_2_EXT_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_2_EXT_CHECK_INTR_EC_SPI(sourceMask)  UART_2_EXT_CHECK_INTR_SPI_EC(sourceMask)
N#endif /* (!UART_2_EXT_CY_SCBIP_V1) */
N
N#define UART_2_EXT_CY_SCBIP_V1_I2C_ONLY   (UART_2_EXT_CY_SCBIP_V1)
N#define UART_2_EXT_EZBUFFER_SIZE          (UART_2_EXT_EZ_DATA_NR)
N
N#define UART_2_EXT_EZBUF_DATA00_REG   UART_2_EXT_EZBUF_DATA0_REG
N#define UART_2_EXT_EZBUF_DATA00_PTR   UART_2_EXT_EZBUF_DATA0_PTR
N
N#endif /* (CY_SCB_UART_2_EXT_H) */
N
N
N/* [] END OF FILE */
L 34 "Generated_Source\PSoC4\project.h" 2
N#include "UART_2_EXT_SPI_UART.h"
L 1 "Generated_Source\PSoC4\UART_2_EXT_SPI_UART.h" 1
N/***************************************************************************//**
N* \file UART_2_EXT_SPI_UART.h
N* \version 4.0
N*
N* \brief
N*  This file provides constants and parameter values for the SCB Component in
N*  SPI and UART modes.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_SPI_UART_UART_2_EXT_H)
X#if !0L
N#define CY_SCB_SPI_UART_UART_2_EXT_H
N
N#include "UART_2_EXT.h"
N
N
N/***************************************
N*   SPI Initial Parameter Constants
N****************************************/
N
N#define UART_2_EXT_SPI_MODE                   (0u)
N#define UART_2_EXT_SPI_SUB_MODE               (0u)
N#define UART_2_EXT_SPI_CLOCK_MODE             (0u)
N#define UART_2_EXT_SPI_OVS_FACTOR             (16u)
N#define UART_2_EXT_SPI_MEDIAN_FILTER_ENABLE   (0u)
N#define UART_2_EXT_SPI_LATE_MISO_SAMPLE_ENABLE (0u)
N#define UART_2_EXT_SPI_RX_DATA_BITS_NUM       (8u)
N#define UART_2_EXT_SPI_TX_DATA_BITS_NUM       (8u)
N#define UART_2_EXT_SPI_WAKE_ENABLE            (0u)
N#define UART_2_EXT_SPI_BITS_ORDER             (1u)
N#define UART_2_EXT_SPI_TRANSFER_SEPARATION    (1u)
N#define UART_2_EXT_SPI_NUMBER_OF_SS_LINES     (1u)
N#define UART_2_EXT_SPI_RX_BUFFER_SIZE         (8u)
N#define UART_2_EXT_SPI_TX_BUFFER_SIZE         (8u)
N
N#define UART_2_EXT_SPI_INTERRUPT_MODE         (0u)
N
N#define UART_2_EXT_SPI_INTR_RX_MASK           (0x0u)
N#define UART_2_EXT_SPI_INTR_TX_MASK           (0x0u)
N
N#define UART_2_EXT_SPI_RX_TRIGGER_LEVEL       (7u)
N#define UART_2_EXT_SPI_TX_TRIGGER_LEVEL       (0u)
N
N#define UART_2_EXT_SPI_BYTE_MODE_ENABLE       (0u)
N#define UART_2_EXT_SPI_FREE_RUN_SCLK_ENABLE   (0u)
N#define UART_2_EXT_SPI_SS0_POLARITY           (0u)
N#define UART_2_EXT_SPI_SS1_POLARITY           (0u)
N#define UART_2_EXT_SPI_SS2_POLARITY           (0u)
N#define UART_2_EXT_SPI_SS3_POLARITY           (0u)
N
N
N/***************************************
N*   UART Initial Parameter Constants
N****************************************/
N
N#define UART_2_EXT_UART_SUB_MODE              (0u)
N#define UART_2_EXT_UART_DIRECTION             (3u)
N#define UART_2_EXT_UART_DATA_BITS_NUM         (8u)
N#define UART_2_EXT_UART_PARITY_TYPE           (2u)
N#define UART_2_EXT_UART_STOP_BITS_NUM         (2u)
N#define UART_2_EXT_UART_OVS_FACTOR            (12u)
N#define UART_2_EXT_UART_IRDA_LOW_POWER        (0u)
N#define UART_2_EXT_UART_MEDIAN_FILTER_ENABLE  (0u)
N#define UART_2_EXT_UART_RETRY_ON_NACK         (0u)
N#define UART_2_EXT_UART_IRDA_POLARITY         (0u)
N#define UART_2_EXT_UART_DROP_ON_FRAME_ERR     (0u)
N#define UART_2_EXT_UART_DROP_ON_PARITY_ERR    (0u)
N#define UART_2_EXT_UART_WAKE_ENABLE           (0u)
N#define UART_2_EXT_UART_RX_BUFFER_SIZE        (8u)
N#define UART_2_EXT_UART_TX_BUFFER_SIZE        (8u)
N#define UART_2_EXT_UART_MP_MODE_ENABLE        (0u)
N#define UART_2_EXT_UART_MP_ACCEPT_ADDRESS     (0u)
N#define UART_2_EXT_UART_MP_RX_ADDRESS         (0x2u)
N#define UART_2_EXT_UART_MP_RX_ADDRESS_MASK    (0xFFu)
N
N#define UART_2_EXT_UART_INTERRUPT_MODE        (1u)
N
N#define UART_2_EXT_UART_INTR_RX_MASK          (0x4u)
N#define UART_2_EXT_UART_INTR_TX_MASK          (0x0u)
N
N#define UART_2_EXT_UART_RX_TRIGGER_LEVEL      (7u)
N#define UART_2_EXT_UART_TX_TRIGGER_LEVEL      (0u)
N
N#define UART_2_EXT_UART_BYTE_MODE_ENABLE      (0u)
N#define UART_2_EXT_UART_CTS_ENABLE            (0u)
N#define UART_2_EXT_UART_CTS_POLARITY          (0u)
N#define UART_2_EXT_UART_RTS_ENABLE            (0u)
N#define UART_2_EXT_UART_RTS_POLARITY          (0u)
N#define UART_2_EXT_UART_RTS_FIFO_LEVEL        (4u)
N
N#define UART_2_EXT_UART_RX_BREAK_WIDTH        (11u)
N
N/* SPI mode enum */
N#define UART_2_EXT_SPI_SLAVE  (0u)
N#define UART_2_EXT_SPI_MASTER (1u)
N
N/* UART direction enum */
N#define UART_2_EXT_UART_RX    (1u)
N#define UART_2_EXT_UART_TX    (2u)
N#define UART_2_EXT_UART_TX_RX (3u)
N
N
N/***************************************
N*   Conditional Compilation Parameters
N****************************************/
N
N#if(UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S
S    /* Mode */
S    #define UART_2_EXT_SPI_SLAVE_CONST        (1u)
S    #define UART_2_EXT_SPI_MASTER_CONST       (1u)
S
S    /* Direction */
S    #define UART_2_EXT_RX_DIRECTION           (1u)
S    #define UART_2_EXT_TX_DIRECTION           (1u)
S    #define UART_2_EXT_UART_RX_DIRECTION      (1u)
S    #define UART_2_EXT_UART_TX_DIRECTION      (1u)
S
S    /* Only external RX and TX buffer for Uncofigured mode */
S    #define UART_2_EXT_INTERNAL_RX_SW_BUFFER   (0u)
S    #define UART_2_EXT_INTERNAL_TX_SW_BUFFER   (0u)
S
S    /* Get RX and TX buffer size */
S    #define UART_2_EXT_INTERNAL_RX_BUFFER_SIZE    (UART_2_EXT_rxBufferSize + 1u)
S    #define UART_2_EXT_RX_BUFFER_SIZE             (UART_2_EXT_rxBufferSize)
S    #define UART_2_EXT_TX_BUFFER_SIZE             (UART_2_EXT_txBufferSize)
S
S    /* Return true if buffer is provided */
S    #define UART_2_EXT_CHECK_RX_SW_BUFFER (NULL != UART_2_EXT_rxBuffer)
S    #define UART_2_EXT_CHECK_TX_SW_BUFFER (NULL != UART_2_EXT_txBuffer)
S
S    /* Always provide global variables to support RX and TX buffers */
S    #define UART_2_EXT_INTERNAL_RX_SW_BUFFER_CONST    (1u)
S    #define UART_2_EXT_INTERNAL_TX_SW_BUFFER_CONST    (1u)
S
S    /* Get wakeup enable option */
S    #define UART_2_EXT_SPI_WAKE_ENABLE_CONST  (1u)
S    #define UART_2_EXT_UART_WAKE_ENABLE_CONST (1u)
S    #define UART_2_EXT_CHECK_SPI_WAKE_ENABLE  ((0u != UART_2_EXT_scbEnableWake) && UART_2_EXT_SCB_MODE_SPI_RUNTM_CFG)
S    #define UART_2_EXT_CHECK_UART_WAKE_ENABLE ((0u != UART_2_EXT_scbEnableWake) && UART_2_EXT_SCB_MODE_UART_RUNTM_CFG)
S
S    /* SPI/UART: TX or RX FIFO size */
S    #if (UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1)
S        #define UART_2_EXT_SPI_UART_FIFO_SIZE             (UART_2_EXT_FIFO_SIZE)
S        #define UART_2_EXT_CHECK_UART_RTS_CONTROL_FLOW    (0u)
S    #else
S        #define UART_2_EXT_SPI_UART_FIFO_SIZE (UART_2_EXT_GET_FIFO_SIZE(UART_2_EXT_CTRL_REG & \
S                                                                                    UART_2_EXT_CTRL_BYTE_MODE))
X        #define UART_2_EXT_SPI_UART_FIFO_SIZE (UART_2_EXT_GET_FIFO_SIZE(UART_2_EXT_CTRL_REG &                                                                                     UART_2_EXT_CTRL_BYTE_MODE))
S
S        #define UART_2_EXT_CHECK_UART_RTS_CONTROL_FLOW \
S                    ((UART_2_EXT_SCB_MODE_UART_RUNTM_CFG) && \
S                     (0u != UART_2_EXT_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(UART_2_EXT_UART_FLOW_CTRL_REG)))
X        #define UART_2_EXT_CHECK_UART_RTS_CONTROL_FLOW                     ((UART_2_EXT_SCB_MODE_UART_RUNTM_CFG) &&                      (0u != UART_2_EXT_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(UART_2_EXT_UART_FLOW_CTRL_REG)))
S    #endif /* (UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1) */
S
N#else
N
N    /* Internal RX and TX buffer: for SPI or UART */
N    #if (UART_2_EXT_SCB_MODE_SPI_CONST_CFG)
X    #if (((0x02u) == (4u)))
S
S        /* SPI Direction */
S        #define UART_2_EXT_SPI_RX_DIRECTION (1u)
S        #define UART_2_EXT_SPI_TX_DIRECTION (1u)
S
S        /* Get FIFO size */
S        #define UART_2_EXT_SPI_UART_FIFO_SIZE UART_2_EXT_GET_FIFO_SIZE(UART_2_EXT_SPI_BYTE_MODE_ENABLE)
S
S        /* SPI internal RX and TX buffers */
S        #define UART_2_EXT_INTERNAL_SPI_RX_SW_BUFFER  (UART_2_EXT_SPI_RX_BUFFER_SIZE > \
S                                                                UART_2_EXT_SPI_UART_FIFO_SIZE)
X        #define UART_2_EXT_INTERNAL_SPI_RX_SW_BUFFER  (UART_2_EXT_SPI_RX_BUFFER_SIZE >                                                                 UART_2_EXT_SPI_UART_FIFO_SIZE)
S        #define UART_2_EXT_INTERNAL_SPI_TX_SW_BUFFER  (UART_2_EXT_SPI_TX_BUFFER_SIZE > \
S                                                                UART_2_EXT_SPI_UART_FIFO_SIZE)
X        #define UART_2_EXT_INTERNAL_SPI_TX_SW_BUFFER  (UART_2_EXT_SPI_TX_BUFFER_SIZE >                                                                 UART_2_EXT_SPI_UART_FIFO_SIZE)
S
S        /* Internal SPI RX and TX buffer */
S        #define UART_2_EXT_INTERNAL_RX_SW_BUFFER  (UART_2_EXT_INTERNAL_SPI_RX_SW_BUFFER)
S        #define UART_2_EXT_INTERNAL_TX_SW_BUFFER  (UART_2_EXT_INTERNAL_SPI_TX_SW_BUFFER)
S
S        /* Internal SPI RX and TX buffer size */
S        #define UART_2_EXT_INTERNAL_RX_BUFFER_SIZE    (UART_2_EXT_SPI_RX_BUFFER_SIZE + 1u)
S        #define UART_2_EXT_RX_BUFFER_SIZE             (UART_2_EXT_SPI_RX_BUFFER_SIZE)
S        #define UART_2_EXT_TX_BUFFER_SIZE             (UART_2_EXT_SPI_TX_BUFFER_SIZE)
S
S        /* Get wakeup enable option */
S        #define UART_2_EXT_SPI_WAKE_ENABLE_CONST  (0u != UART_2_EXT_SPI_WAKE_ENABLE)
S        #define UART_2_EXT_UART_WAKE_ENABLE_CONST (0u)
S
N    #else
N
N        /* UART Direction */
N        #define UART_2_EXT_UART_RX_DIRECTION (0u != (UART_2_EXT_UART_DIRECTION & UART_2_EXT_UART_RX))
N        #define UART_2_EXT_UART_TX_DIRECTION (0u != (UART_2_EXT_UART_DIRECTION & UART_2_EXT_UART_TX))
N
N        /* Get FIFO size */
N        #define UART_2_EXT_SPI_UART_FIFO_SIZE UART_2_EXT_GET_FIFO_SIZE(UART_2_EXT_UART_BYTE_MODE_ENABLE)
N
N        /* UART internal RX and TX buffers */
N        #define UART_2_EXT_INTERNAL_UART_RX_SW_BUFFER  (UART_2_EXT_UART_RX_BUFFER_SIZE > \
N                                                                UART_2_EXT_SPI_UART_FIFO_SIZE)
X        #define UART_2_EXT_INTERNAL_UART_RX_SW_BUFFER  (UART_2_EXT_UART_RX_BUFFER_SIZE >                                                                 UART_2_EXT_SPI_UART_FIFO_SIZE)
N        #define UART_2_EXT_INTERNAL_UART_TX_SW_BUFFER  (UART_2_EXT_UART_TX_BUFFER_SIZE > \
N                                                                    UART_2_EXT_SPI_UART_FIFO_SIZE)
X        #define UART_2_EXT_INTERNAL_UART_TX_SW_BUFFER  (UART_2_EXT_UART_TX_BUFFER_SIZE >                                                                     UART_2_EXT_SPI_UART_FIFO_SIZE)
N
N        /* Internal UART RX and TX buffer */
N        #define UART_2_EXT_INTERNAL_RX_SW_BUFFER  (UART_2_EXT_INTERNAL_UART_RX_SW_BUFFER)
N        #define UART_2_EXT_INTERNAL_TX_SW_BUFFER  (UART_2_EXT_INTERNAL_UART_TX_SW_BUFFER)
N
N        /* Internal UART RX and TX buffer size */
N        #define UART_2_EXT_INTERNAL_RX_BUFFER_SIZE    (UART_2_EXT_UART_RX_BUFFER_SIZE + 1u)
N        #define UART_2_EXT_RX_BUFFER_SIZE             (UART_2_EXT_UART_RX_BUFFER_SIZE)
N        #define UART_2_EXT_TX_BUFFER_SIZE             (UART_2_EXT_UART_TX_BUFFER_SIZE)
N
N        /* Get wakeup enable option */
N        #define UART_2_EXT_SPI_WAKE_ENABLE_CONST  (0u)
N        #define UART_2_EXT_UART_WAKE_ENABLE_CONST (0u != UART_2_EXT_UART_WAKE_ENABLE)
N
N    #endif /* (UART_2_EXT_SCB_MODE_SPI_CONST_CFG) */
N
N    /* Mode */
N    #define UART_2_EXT_SPI_SLAVE_CONST    (UART_2_EXT_SPI_MODE == UART_2_EXT_SPI_SLAVE)
N    #define UART_2_EXT_SPI_MASTER_CONST   (UART_2_EXT_SPI_MODE == UART_2_EXT_SPI_MASTER)
N
N    /* Direction */
N    #define UART_2_EXT_RX_DIRECTION ((UART_2_EXT_SCB_MODE_SPI_CONST_CFG) ? \
N                                            (UART_2_EXT_SPI_RX_DIRECTION) : (UART_2_EXT_UART_RX_DIRECTION))
X    #define UART_2_EXT_RX_DIRECTION ((UART_2_EXT_SCB_MODE_SPI_CONST_CFG) ?                                             (UART_2_EXT_SPI_RX_DIRECTION) : (UART_2_EXT_UART_RX_DIRECTION))
N
N    #define UART_2_EXT_TX_DIRECTION ((UART_2_EXT_SCB_MODE_SPI_CONST_CFG) ? \
N                                            (UART_2_EXT_SPI_TX_DIRECTION) : (UART_2_EXT_UART_TX_DIRECTION))
X    #define UART_2_EXT_TX_DIRECTION ((UART_2_EXT_SCB_MODE_SPI_CONST_CFG) ?                                             (UART_2_EXT_SPI_TX_DIRECTION) : (UART_2_EXT_UART_TX_DIRECTION))
N
N    /* Internal RX and TX buffer: for SPI or UART. Used in conditional compilation check */
N    #define UART_2_EXT_CHECK_RX_SW_BUFFER (UART_2_EXT_INTERNAL_RX_SW_BUFFER)
N    #define UART_2_EXT_CHECK_TX_SW_BUFFER (UART_2_EXT_INTERNAL_TX_SW_BUFFER)
N
N    /* Provide global variables to support RX and TX buffers */
N    #define UART_2_EXT_INTERNAL_RX_SW_BUFFER_CONST    (UART_2_EXT_INTERNAL_RX_SW_BUFFER)
N    #define UART_2_EXT_INTERNAL_TX_SW_BUFFER_CONST    (UART_2_EXT_INTERNAL_TX_SW_BUFFER)
N
N    /* Wake up enable */
N    #define UART_2_EXT_CHECK_SPI_WAKE_ENABLE  (UART_2_EXT_SPI_WAKE_ENABLE_CONST)
N    #define UART_2_EXT_CHECK_UART_WAKE_ENABLE (UART_2_EXT_UART_WAKE_ENABLE_CONST)
N
N    /* UART flow control: not applicable for CY_SCBIP_V0 || CY_SCBIP_V1 */
N    #define UART_2_EXT_CHECK_UART_RTS_CONTROL_FLOW    (UART_2_EXT_SCB_MODE_UART_CONST_CFG && \
N                                                             UART_2_EXT_UART_RTS_ENABLE)
X    #define UART_2_EXT_CHECK_UART_RTS_CONTROL_FLOW    (UART_2_EXT_SCB_MODE_UART_CONST_CFG &&                                                              UART_2_EXT_UART_RTS_ENABLE)
N
N#endif /* End (UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N
N/***************************************
N*       Type Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N
N/* UART_2_EXT_SPI_INIT_STRUCT */
Ntypedef struct
N{
N    /** Mode of operation for SPI. The following defines are available choices:
N     *  - UART_2_EXT_SPI_SLAVE
N     *  - UART_2_EXT_SPI_MASTE
N    */
N    uint32 mode;
N
N    /** Submode of operation for SPI. The following defines are available
N     *  choices:
N     *  - UART_2_EXT_SPI_MODE_MOTOROLA
N     *  - UART_2_EXT_SPI_MODE_TI_COINCIDES
N     *  - UART_2_EXT_SPI_MODE_TI_PRECEDES
N     *  - UART_2_EXT_SPI_MODE_NATIONAL
N    */
N    uint32 submode;
N
N    /** Determines the sclk relationship for Motorola submode. Ignored
N     *  for other submodes. The following defines are available choices:
N     *  - UART_2_EXT_SPI_SCLK_CPHA0_CPOL0
N     *  - UART_2_EXT_SPI_SCLK_CPHA0_CPOL1
N     *  - UART_2_EXT_SPI_SCLK_CPHA1_CPOL0
N     *  - UART_2_EXT_SPI_SCLK_CPHA1_CPOL1
N    */
N    uint32 sclkMode;
N
N    /** Oversampling factor for the SPI clock. Ignored for Slave mode operation.
N    */
N    uint32 oversample;
N
N    /** Applies median filter on the input lines: 0  not applied, 1  applied.
N    */
N    uint32 enableMedianFilter;
N
N    /** Applies late sampling of MISO line: 0  not applied, 1  applied.
N     *  Ignored for slave mode.
N    */
N    uint32 enableLateSampling;
N
N    /** Enables wakeup from low power mode: 0  disable, 1  enable.
N     *  Ignored for master mode.
N    */
N    uint32 enableWake;
N
N    /** Number of data bits for RX direction.
N     *  Different dataBitsRx and dataBitsTx are only allowed for National
N     *  submode.
N    */
N    uint32 rxDataBits;
N
N    /** Number of data bits for TX direction.
N     *  Different dataBitsRx and dataBitsTx are only allowed for National
N     *  submode.
N    */
N    uint32 txDataBits;
N
N    /** Determines the bit ordering. The following defines are available
N     *  choices:
N     *  - UART_2_EXT_BITS_ORDER_LSB_FIRST
N     *  - UART_2_EXT_BITS_ORDER_MSB_FIRST
N    */
N    uint32 bitOrder;
N
N    /** Determines whether transfers are back to back or have SS disabled
N     *  between words. Ignored for slave mode. The following defines are
N     *  available choices:
N     *  - UART_2_EXT_SPI_TRANSFER_CONTINUOUS
N     *  - UART_2_EXT_SPI_TRANSFER_SEPARATED
N    */
N    uint32 transferSeperation;
N
N    /** Size of the RX buffer in bytes/words (depends on rxDataBits parameter).
N     *  A value equal to the RX FIFO depth implies the usage of buffering in
N     *  hardware. A value greater than the RX FIFO depth results in a software
N     *  buffer.
N     *  The UART_2_EXT_INTR _RX_NOT_EMPTY interrupt has to be enabled to
N     *  transfer data into the software buffer.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words for PSoC 4100 /
N     *    PSoC 4200 devices.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words or 16
N     *    bytes (Byte mode is enabled) for PSoC 4100 BLE / PSoC 4200 BLE /
N     *    PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *    PSoC Analog Coprocessor devices.
N    */
N    uint32 rxBufferSize;
N
N    /** Buffer space provided for a RX software buffer:
N     *  - A NULL pointer must be provided to use hardware buffering.
N     *  - A pointer to an allocated buffer must be provided to use software
N     *    buffering. The buffer size must equal (rxBufferSize + 1) in bytes if
N     *    dataBitsRx is less or equal to 8, otherwise (2 * (rxBufferSize + 1))
N     *    in bytes. The software RX buffer always keeps one element empty.
N     *    For correct operation the allocated RX buffer has to be one element
N     *    greater than maximum packet size expected to be received.
N    */
N    uint8* rxBuffer;
N
N    /** Size of the TX buffer in bytes/words(depends on txDataBits parameter).
N     *  A value equal to the TX FIFO depth implies the usage of buffering in
N     *  hardware. A value greater than the TX FIFO depth results in a software
N     *  buffer.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words for PSoC 4100 /
N     *    PSoC 4200 devices.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words or 16
N     *    bytes (Byte mode is enabled) for PSoC 4100 BLE / PSoC 4200 BLE /
N     *    PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *    PSoC Analog Coprocessor devices.
N    */
N    uint32 txBufferSize;
N
N    /** Buffer space provided for a TX software buffer:
N     *  - A NULL pointer must be provided to use hardware buffering.
N     *  - A pointer to an allocated buffer must be provided to use software
N     *    buffering. The buffer size must equal txBufferSize if dataBitsTx is
N     *    less or equal to 8, otherwise (2* txBufferSize).
N    */
N    uint8* txBuffer;
N
N    /** Enables component interrupt: 0  disable, 1  enable.
N     *  The interrupt has to be enabled if software buffer is used.
N    */
N    uint32 enableInterrupt;
N
N    /** Mask of enabled interrupt sources for the RX direction. This mask is
N     *  written regardless of the setting of the enable Interrupt field.
N     *  Multiple sources are enabled by providing a value that is the OR of
N     *  all of the following sources to enable:
N     *  - UART_2_EXT_INTR_RX_FIFO_LEVEL
N     *  - UART_2_EXT_INTR_RX_NOT_EMPTY
N     *  - UART_2_EXT_INTR_RX_FULL
N     *  - UART_2_EXT_INTR_RX_OVERFLOW
N     *  - UART_2_EXT_INTR_RX_UNDERFLOW
N     *  - UART_2_EXT_INTR_SLAVE_SPI_BUS_ERROR
N    */
N    uint32 rxInterruptMask;
N
N    /** FIFO level for an RX FIFO level interrupt. This value is written
N     *  regardless of whether the RX FIFO level interrupt source is enabled.
N    */
N    uint32 rxTriggerLevel;
N
N    /** Mask of enabled interrupt sources for the TX direction. This mask is
N     *  written regardless of the setting of the enable Interrupt field.
N     *  Multiple sources are enabled by providing a value that is the OR of
N     *  all of the following sources to enable:
N     *  - UART_2_EXT_INTR_TX_FIFO_LEVEL
N     *  - UART_2_EXT_INTR_TX_NOT_FULL
N     *  - UART_2_EXT_INTR_TX_EMPTY
N     *  - UART_2_EXT_INTR_TX_OVERFLOW
N     *  - UART_2_EXT_INTR_TX_UNDERFLOW
N     *  - UART_2_EXT_INTR_MASTER_SPI_DONE
N    */
N    uint32 txInterruptMask;
N
N    /** FIFO level for a TX FIFO level interrupt. This value is written
N     * regardless of whether the TX FIFO level interrupt source is enabled.
N    */
N    uint32 txTriggerLevel;
N
N    /** When enabled the TX and RX FIFO depth is doubled and equal to
N     *  16 bytes: 0  disable, 1  enable. This implies that number of
N     *  TX and RX data bits must be less than or equal to 8.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 enableByteMode;
N
N    /** Enables continuous SCLK generation by the SPI master: 0  disable,
N     *  1  enable.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 enableFreeRunSclk;
N
N    /** Active polarity of slave select lines 0-3. This is bit mask where bit
N     *  UART_2_EXT_SPI_SLAVE_SELECT0 corresponds to slave select 0
N     *  polarity, bit UART_2_EXT_SPI_SLAVE_SELECT1  slave select 1
N     *  polarity and so on. Polarity constants are:
N     *  - UART_2_EXT_SPI_SS_ACTIVE_LOW
N     *  - UART_2_EXT_SPI_SS_ACTIVE_HIGH
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 polaritySs;
N} UART_2_EXT_SPI_INIT_STRUCT;
N
N
N/* UART_2_EXT_UART_INIT_STRUCT */
Ntypedef struct
N{
N    /** Mode of operation for the UART. The following defines are available
N     *  choices:
N     *  - UART_2_EXT_UART_MODE_STD
N     *  - UART_2_EXT_UART_MODE_SMARTCARD
N     *  - UART_2_EXT_UART_MODE_IRDA
N    */
N    uint32 mode;
N
N    /** Direction of operation for the UART. The following defines are available
N     *  choices:
N     *  - UART_2_EXT_UART_TX_RX
N     *  - UART_2_EXT_UART_RX
N     *  - UART_2_EXT_UART_TX
N    */
N    uint32 direction;
N
N    /** Number of data bits.
N    */
N    uint32 dataBits;
N
N    /** Determines the parity. The following defines are available choices:
N     *  - UART_2_EXT_UART_PARITY_EVEN
N     *  - UART_2_EXT_UART_PARITY_ODD
N     *  - UART_2_EXT_UART_PARITY_NONE
N    */
N    uint32 parity;
N
N    /** Determines the number of stop bits. The following defines are available
N     *  choices:
N     *  - UART_2_EXT_UART_STOP_BITS_1
N     *  - UART_2_EXT_UART_STOP_BITS_1_5
N     *  - UART_2_EXT_UART_STOP_BITS_2
N    */
N    uint32 stopBits;
N
N    /** Oversampling factor for the UART.
N     *
N     *  Note The oversampling factor values are changed when enableIrdaLowPower
N     *  is enabled:
N     *  - UART_2_EXT_UART_IRDA_LP_OVS16
N     *  - UART_2_EXT_UART_IRDA_LP_OVS32
N     *  - UART_2_EXT_UART_IRDA_LP_OVS48
N     *  - UART_2_EXT_UART_IRDA_LP_OVS96
N     *  - UART_2_EXT_UART_IRDA_LP_OVS192
N     *  - UART_2_EXT_UART_IRDA_LP_OVS768
N     *  - UART_2_EXT_UART_IRDA_LP_OVS1536
N    */
N    uint32 oversample;
N
N    /** Enables IrDA low power RX mode operation: 0  disable, 1  enable.
N     *  The TX functionality does not work when enabled.
N    */
N    uint32 enableIrdaLowPower;
N
N    /** Applies median filter on the input lines:  0  not applied, 1  applied.
N    */
N    uint32 enableMedianFilter;
N
N    /** Enables retry when NACK response was received: 0  disable, 1  enable.
N     *  Only current content of TX FIFO is re-sent.
N     *  Ignored for modes other than SmartCard.
N    */
N    uint32 enableRetryNack;
N
N    /** Inverts polarity of RX line: 0  non-inverting, 1  inverting.
N     *  Ignored for modes other than IrDA.
N    */
N    uint32 enableInvertedRx;
N
N    /** Drop data from RX FIFO if parity error is detected: 0  disable,
N     *  1  enable.
N    */
N    uint32 dropOnParityErr;
N
N    /** Drop data from RX FIFO if a frame error is detected: 0  disable,
N     *  1  enable.
N    */
N    uint32 dropOnFrameErr;
N
N    /** Enables wakeup from low power mode: 0  disable, 1  enable.
N     *  Ignored for modes other than standard UART. The RX functionality
N     *  has to be enabled.
N    */
N    uint32 enableWake;
N
N    /** Size of the RX buffer in bytes/words (depends on rxDataBits parameter).
N     *  A value equal to the RX FIFO depth implies the usage of buffering in
N     *  hardware. A value greater than the RX FIFO depth results in a software
N     *  buffer.
N     *  The UART_2_EXT_INTR _RX_NOT_EMPTY interrupt has to be enabled to
N     *  transfer data into the software buffer.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words for PSoC 4100 /
N     *    PSoC 4200 devices.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words or 16
N     *    bytes (Byte mode is enabled) for PSoC 4100 BLE / PSoC 4200 BLE /
N     *    PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *    PSoC Analog Coprocessor devices.
N    */
N    uint32 rxBufferSize;
N
N    /** Buffer space provided for a RX software buffer:
N     *  - A NULL pointer must be provided to use hardware buffering.
N     *  - A pointer to an allocated buffer must be provided to use software
N     *    buffering. The buffer size must equal (rxBufferSize + 1) in bytes if
N     *    dataBitsRx is less or equal to 8, otherwise (2 * (rxBufferSize + 1))
N     *    in bytes. The software RX buffer always keeps one element empty.
N     *    For correct operation the allocated RX buffer has to be one element
N     *    greater than maximum packet size expected to be received.
N    */
N    uint8* rxBuffer;
N
N    /** Size of the TX buffer in bytes/words(depends on txDataBits parameter).
N     *  A value equal to the TX FIFO depth implies the usage of buffering in
N     *  hardware. A value greater than the TX FIFO depth results in a software
N     *  buffer.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words for PSoC 4100 /
N     *    PSoC 4200 devices.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words or 16
N     *    bytes (Byte mode is enabled) for PSoC 4100 BLE / PSoC 4200 BLE /
N     *    PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *    PSoC Analog Coprocessor devices.
N    */
N    uint32 txBufferSize;
N
N    /** Buffer space provided for a TX software buffer:
N     *  - A NULL pointer must be provided to use hardware buffering.
N     *  - A pointer to an allocated buffer must be provided to use software
N     *    buffering. The buffer size must equal txBufferSize if dataBitsTx is
N     *    less or equal to 8, otherwise (2* txBufferSize).
N    */
N    uint8* txBuffer;
N
N    /** Enables multiprocessor mode: 0  disable, 1  enable.
N    */
N    uint32 enableMultiproc;
N
N    /** Enables matched address to be accepted: 0  disable, 1  enable.
N    */
N    uint32 multiprocAcceptAddr;
N
N    /** 8 bit address to match in Multiprocessor mode. Ignored for other modes.
N    */
N    uint32 multiprocAddr;
N
N    /** 8 bit mask of address bits that are compared for a Multiprocessor
N     *  address match. Ignored for other modes.
N     *  - Bit value 0  excludes bit from address comparison.
N     *  - Bit value 1  the bit needs to match with the corresponding bit
N     *   of the device address.
N    */
N    uint32 multiprocAddrMask;
N
N    /** Enables component interrupt: 0  disable, 1  enable.
N     *  The interrupt has to be enabled if software buffer is used.
N    */
N    uint32 enableInterrupt;
N
N    /** Mask of interrupt sources to enable in the RX direction. This mask is
N     *  written regardless of the setting of the enableInterrupt field.
N     *  Multiple sources are enabled by providing a value that is the OR of
N     *  all of the following sources to enable:
N     *  - UART_2_EXT_INTR_RX_FIFO_LEVEL
N     *  - UART_2_EXT_INTR_RX_NOT_EMPTY
N     *  - UART_2_EXT_INTR_RX_FULL
N     *  - UART_2_EXT_INTR_RX_OVERFLOW
N     *  - UART_2_EXT_INTR_RX_UNDERFLOW
N     *  - UART_2_EXT_INTR_RX_FRAME_ERROR
N     *  - UART_2_EXT_INTR_RX_PARITY_ERROR
N    */
N    uint32 rxInterruptMask;
N
N    /** FIFO level for an RX FIFO level interrupt. This value is written
N     *  regardless of whether the RX FIFO level interrupt source is enabled.
N    */
N    uint32 rxTriggerLevel;
N
N    /** Mask of interrupt sources to enable in the TX direction. This mask is
N     *  written regardless of the setting of the enableInterrupt field.
N     *  Multiple sources are enabled by providing a value that is the OR of
N     *  all of the following sources to enable:
N     *  - UART_2_EXT_INTR_TX_FIFO_LEVEL
N     *  - UART_2_EXT_INTR_TX_NOT_FULL
N     *  - UART_2_EXT_INTR_TX_EMPTY
N     *  - UART_2_EXT_INTR_TX_OVERFLOW
N     *  - UART_2_EXT_INTR_TX_UNDERFLOW
N     *  - UART_2_EXT_INTR_TX_UART_DONE
N     *  - UART_2_EXT_INTR_TX_UART_NACK
N     *  - UART_2_EXT_INTR_TX_UART_ARB_LOST
N    */
N    uint32 txInterruptMask;
N
N    /** FIFO level for a TX FIFO level interrupt. This value is written
N     *  regardless of whether the TX FIFO level interrupt source is enabled.
N    */
N    uint32 txTriggerLevel;
N
N    /** When enabled the TX and RX FIFO depth is doubled and equal to
N     *  16 bytes: 0  disable, 1  enable. This implies that number of
N     *  Data bits must be less than or equal to 8.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 enableByteMode;
N
N    /** Enables usage of CTS input signal by the UART transmitter : 0  disable,
N     *  1  enable.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 enableCts;
N
N    /** Sets active polarity of CTS input signal:
N     *  - UART_2_EXT_UART_CTS_ACTIVE_LOW
N     *  - UART_2_EXT_UART_CTS_ACTIVE_HIGH
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 ctsPolarity;
N
N    /** RX FIFO level for RTS signal activation. While the RX FIFO has fewer
N     *  entries than the RTS FIFO level value the RTS signal remains active,
N     *  otherwise the RTS signal becomes inactive. By setting this field to 0,
N     *  RTS signal activation is disabled.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 rtsRxFifoLevel;
N
N    /** Sets active polarity of RTS output signal:
N     *  - UART_2_EXT_UART_RTS_ ACTIVE_LOW
N     *  - UART_2_EXT_UART_RTS_ACTIVE_HIGH
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 rtsPolarity;
N
N    /** Configures the width of a break signal in that triggers the break
N     *  detection interrupt source. A Break is a low level on the RX line.
N     *  Valid range is 1-16 UART bits times.
N    */
N    uint8 breakWidth;
N} UART_2_EXT_UART_INIT_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
N/**
N* \addtogroup group_spi
N* @{
N*/
N/* SPI specific functions */
N#if(UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    void UART_2_EXT_SpiInit(const UART_2_EXT_SPI_INIT_STRUCT *config);
N#endif /* (UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N
N#if(UART_2_EXT_SCB_MODE_SPI_INC)
X#if((0u !=((0x02u) & (4u))))
S    /*******************************************************************************
S    * Function Name: UART_2_EXT_SpiIsBusBusy
S    ****************************************************************************//**
S    *
S    *  Returns the current status on the bus. The bus status is determined using
S    *  the slave select signal.
S    *  - Motorola and National Semiconductor sub-modes: The bus is busy after
S    *    the slave select line is activated and lasts until the slave select line
S    *    is deactivated.
S    *  - Texas Instrument sub-modes: The bus is busy at the moment of the initial
S    *    pulse on the slave select line and lasts until the transfer is complete.
S    *    If SPI Master is configured to use "Separated transfers"
S    *    (see Continuous versus Separated Transfer Separation), the bus is busy
S    *    during each element transfer and is free between each element transfer.
S    *    The Master does not activate SS line immediately after data has been
S    *    written into the TX FIFO.
S    *
S    *  \return slaveSelect: Current status on the bus.
S    *   If the returned value is nonzero, the bus is busy.
S    *   If zero is returned, the bus is free. The bus status is determined using
S    *   the slave select signal.
S    *
S    *******************************************************************************/
S    #define UART_2_EXT_SpiIsBusBusy() ((uint32) (0u != (UART_2_EXT_SPI_STATUS_REG & \
S                                                              UART_2_EXT_SPI_STATUS_BUS_BUSY)))
X    #define UART_2_EXT_SpiIsBusBusy() ((uint32) (0u != (UART_2_EXT_SPI_STATUS_REG &                                                               UART_2_EXT_SPI_STATUS_BUS_BUSY)))
S
S    #if (UART_2_EXT_SPI_MASTER_CONST)
S        void UART_2_EXT_SpiSetActiveSlaveSelect(uint32 slaveSelect);
S    #endif /*(UART_2_EXT_SPI_MASTER_CONST) */
S
S    #if !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1)
S        void UART_2_EXT_SpiSetSlaveSelectPolarity(uint32 slaveSelect, uint32 polarity);
S    #endif /* !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1) */
N#endif /* (UART_2_EXT_SCB_MODE_SPI_INC) */
N/** @} spi */
N
N/**
N* \addtogroup group_uart
N* @{
N*/
N/* UART specific functions */
N#if(UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    void UART_2_EXT_UartInit(const UART_2_EXT_UART_INIT_STRUCT *config);
N#endif /* (UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N#if(UART_2_EXT_SCB_MODE_UART_INC)
X#if((0u !=((0x04u) & (4u))))
N    void UART_2_EXT_UartSetRxAddress(uint32 address);
N    void UART_2_EXT_UartSetRxAddressMask(uint32 addressMask);
N
N
N    /* UART RX direction APIs */
N    #if(UART_2_EXT_UART_RX_DIRECTION)
X    #if((0u != ((3u) & (1u))))
N        uint32 UART_2_EXT_UartGetChar(void);
N        uint32 UART_2_EXT_UartGetByte(void);
N
N        #if !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1)
X        #if !((2 == 0u) || (2 == 1u))
N            /* UART APIs for Flow Control */
N            void UART_2_EXT_UartSetRtsPolarity(uint32 polarity);
N            void UART_2_EXT_UartSetRtsFifoLevel(uint32 level);
N        #endif /* !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1) */
N    #endif /* (UART_2_EXT_UART_RX_DIRECTION) */
N
N    /* UART TX direction APIs */
N    #if(UART_2_EXT_UART_TX_DIRECTION)
X    #if((0u != ((3u) & (2u))))
N        /*******************************************************************************
N        * Function Name: UART_2_EXT_UartPutChar
N        ****************************************************************************//**
N        *
N        *  Places a byte of data in the transmit buffer to be sent at the next available
N        *  bus time. This function is blocking and waits until there is a space
N        *  available to put requested data in the transmit buffer.
N        *  For UART Multi Processor mode this function can send 9-bits data as well.
N        *  Use UART_2_EXT_UART_MP_MARK to add a mark to create an address byte.
N        *
N        *  \param txDataByte: the data to be transmitted.
N        *
N        *******************************************************************************/
N        #define UART_2_EXT_UartPutChar(ch)    UART_2_EXT_SpiUartWriteTxData((uint32)(ch))
N
N        void UART_2_EXT_UartPutString(const char8 string[]);
N        void UART_2_EXT_UartPutCRLF(uint32 txDataByte);
N        void UART_2_EXT_UartSendBreakBlocking(uint32 breakWidth);
N
N        #if !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1)
X        #if !((2 == 0u) || (2 == 1u))
N            /* UART APIs for Flow Control */
N            void UART_2_EXT_UartEnableCts(void);
N            void UART_2_EXT_UartDisableCts(void);
N            void UART_2_EXT_UartSetCtsPolarity(uint32 polarity);
N        #endif /* !(UART_2_EXT_CY_SCBIP_V0 || UART_2_EXT_CY_SCBIP_V1) */
N    #endif /* (UART_2_EXT_UART_TX_DIRECTION) */
N#endif /* (UART_2_EXT_SCB_MODE_UART_INC) */
N/** @} uart */
N
N/**
N* \addtogroup group_spi_uart
N* @{
N*/
N#if(UART_2_EXT_RX_DIRECTION)
X#if(((((0x02u) == (4u))) ? (UART_2_EXT_SPI_RX_DIRECTION) : ((0u != ((3u) & (1u))))))
N    uint32 UART_2_EXT_SpiUartReadRxData(void);
N    uint32 UART_2_EXT_SpiUartGetRxBufferSize(void);
N    void   UART_2_EXT_SpiUartClearRxBuffer(void);
N#endif /* (UART_2_EXT_RX_DIRECTION) */
N
N/* Common APIs TX direction */
N#if(UART_2_EXT_TX_DIRECTION)
X#if(((((0x02u) == (4u))) ? (UART_2_EXT_SPI_TX_DIRECTION) : ((0u != ((3u) & (2u))))))
N    void   UART_2_EXT_SpiUartWriteTxData(uint32 txData);
N    void   UART_2_EXT_SpiUartPutArray(const uint8 wrBuf[], uint32 count);
N    uint32 UART_2_EXT_SpiUartGetTxBufferSize(void);
N    void   UART_2_EXT_SpiUartClearTxBuffer(void);
N#endif /* (UART_2_EXT_TX_DIRECTION) */
N/** @} spi_uart */
N
NCY_ISR_PROTO(UART_2_EXT_SPI_UART_ISR);
Xvoid UART_2_EXT_SPI_UART_ISR (void);
N
N#if(UART_2_EXT_UART_RX_WAKEUP_IRQ)
X#if((0u == (1u)))
S    CY_ISR_PROTO(UART_2_EXT_UART_WAKEUP_ISR);
N#endif /* (UART_2_EXT_UART_RX_WAKEUP_IRQ) */
N
N
N/***************************************
N*     Buffer Access Macro Definitions
N***************************************/
N
N#if(UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    /* RX direction */
S    void   UART_2_EXT_PutWordInRxBuffer  (uint32 idx, uint32 rxDataByte);
S    uint32 UART_2_EXT_GetWordFromRxBuffer(uint32 idx);
S
S    /* TX direction */
S    void   UART_2_EXT_PutWordInTxBuffer  (uint32 idx, uint32 txDataByte);
S    uint32 UART_2_EXT_GetWordFromTxBuffer(uint32 idx);
S
N#else
N    /* RX direction */
N    #if(UART_2_EXT_INTERNAL_RX_SW_BUFFER_CONST)
X    #if(((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u)))))))
S        #define UART_2_EXT_PutWordInRxBuffer(idx, rxDataByte) \
S                do{                                                 \
S                    UART_2_EXT_rxBufferInternal[(idx)] = ((uint8) (rxDataByte)); \
S                }while(0)
X        #define UART_2_EXT_PutWordInRxBuffer(idx, rxDataByte)                 do{                                                                     UART_2_EXT_rxBufferInternal[(idx)] = ((uint8) (rxDataByte));                 }while(0)
S
S        #define UART_2_EXT_GetWordFromRxBuffer(idx) UART_2_EXT_rxBufferInternal[(idx)]
S
N    #endif /* (UART_2_EXT_INTERNAL_RX_SW_BUFFER_CONST) */
N
N    /* TX direction */
N    #if(UART_2_EXT_INTERNAL_TX_SW_BUFFER_CONST)
X    #if(((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u)))))))
S        #define UART_2_EXT_PutWordInTxBuffer(idx, txDataByte) \
S                    do{                                             \
S                        UART_2_EXT_txBufferInternal[(idx)] = ((uint8) (txDataByte)); \
S                    }while(0)
X        #define UART_2_EXT_PutWordInTxBuffer(idx, txDataByte)                     do{                                                                     UART_2_EXT_txBufferInternal[(idx)] = ((uint8) (txDataByte));                     }while(0)
S
S        #define UART_2_EXT_GetWordFromTxBuffer(idx) UART_2_EXT_txBufferInternal[(idx)]
S
N    #endif /* (UART_2_EXT_INTERNAL_TX_SW_BUFFER_CONST) */
N
N#endif /* (UART_2_EXT_TX_SW_BUFFER_ENABLE) */
N
N
N/***************************************
N*         SPI API Constants
N***************************************/
N
N/* SPI sub mode enum */
N#define UART_2_EXT_SPI_MODE_MOTOROLA      (0x00u)
N#define UART_2_EXT_SPI_MODE_TI_COINCIDES  (0x01u)
N#define UART_2_EXT_SPI_MODE_TI_PRECEDES   (0x11u)
N#define UART_2_EXT_SPI_MODE_NATIONAL      (0x02u)
N#define UART_2_EXT_SPI_MODE_MASK          (0x03u)
N#define UART_2_EXT_SPI_MODE_TI_PRECEDES_MASK  (0x10u)
N#define UART_2_EXT_SPI_MODE_NS_MICROWIRE  (UART_2_EXT_SPI_MODE_NATIONAL)
N
N/* SPI phase and polarity mode enum */
N#define UART_2_EXT_SPI_SCLK_CPHA0_CPOL0   (0x00u)
N#define UART_2_EXT_SPI_SCLK_CPHA0_CPOL1   (0x02u)
N#define UART_2_EXT_SPI_SCLK_CPHA1_CPOL0   (0x01u)
N#define UART_2_EXT_SPI_SCLK_CPHA1_CPOL1   (0x03u)
N
N/* SPI bits order enum */
N#define UART_2_EXT_BITS_ORDER_LSB_FIRST   (0u)
N#define UART_2_EXT_BITS_ORDER_MSB_FIRST   (1u)
N
N/* SPI transfer separation enum */
N#define UART_2_EXT_SPI_TRANSFER_SEPARATED     (0u)
N#define UART_2_EXT_SPI_TRANSFER_CONTINUOUS    (1u)
N
N/* SPI slave select constants */
N#define UART_2_EXT_SPI_SLAVE_SELECT0    (UART_2_EXT_SCB__SS0_POSISTION)
N#define UART_2_EXT_SPI_SLAVE_SELECT1    (UART_2_EXT_SCB__SS1_POSISTION)
N#define UART_2_EXT_SPI_SLAVE_SELECT2    (UART_2_EXT_SCB__SS2_POSISTION)
N#define UART_2_EXT_SPI_SLAVE_SELECT3    (UART_2_EXT_SCB__SS3_POSISTION)
N
N/* SPI slave select polarity settings */
N#define UART_2_EXT_SPI_SS_ACTIVE_LOW  (0u)
N#define UART_2_EXT_SPI_SS_ACTIVE_HIGH (1u)
N
N#define UART_2_EXT_INTR_SPIM_TX_RESTORE   (UART_2_EXT_INTR_TX_OVERFLOW)
N
N#define UART_2_EXT_INTR_SPIS_TX_RESTORE     (UART_2_EXT_INTR_TX_OVERFLOW | \
N                                                 UART_2_EXT_INTR_TX_UNDERFLOW)
X#define UART_2_EXT_INTR_SPIS_TX_RESTORE     (UART_2_EXT_INTR_TX_OVERFLOW |                                                  UART_2_EXT_INTR_TX_UNDERFLOW)
N
N/***************************************
N*         UART API Constants
N***************************************/
N
N/* UART sub-modes enum */
N#define UART_2_EXT_UART_MODE_STD          (0u)
N#define UART_2_EXT_UART_MODE_SMARTCARD    (1u)
N#define UART_2_EXT_UART_MODE_IRDA         (2u)
N
N/* UART direction enum */
N#define UART_2_EXT_UART_RX    (1u)
N#define UART_2_EXT_UART_TX    (2u)
N#define UART_2_EXT_UART_TX_RX (3u)
N
N/* UART parity enum */
N#define UART_2_EXT_UART_PARITY_EVEN   (0u)
N#define UART_2_EXT_UART_PARITY_ODD    (1u)
N#define UART_2_EXT_UART_PARITY_NONE   (2u)
N
N/* UART stop bits enum */
N#define UART_2_EXT_UART_STOP_BITS_1   (2u)
N#define UART_2_EXT_UART_STOP_BITS_1_5 (3u)
N#define UART_2_EXT_UART_STOP_BITS_2   (4u)
N
N/* UART IrDA low power OVS enum */
N#define UART_2_EXT_UART_IRDA_LP_OVS16     (16u)
N#define UART_2_EXT_UART_IRDA_LP_OVS32     (32u)
N#define UART_2_EXT_UART_IRDA_LP_OVS48     (48u)
N#define UART_2_EXT_UART_IRDA_LP_OVS96     (96u)
N#define UART_2_EXT_UART_IRDA_LP_OVS192    (192u)
N#define UART_2_EXT_UART_IRDA_LP_OVS768    (768u)
N#define UART_2_EXT_UART_IRDA_LP_OVS1536   (1536u)
N
N/* Uart MP: mark (address) and space (data) bit definitions */
N#define UART_2_EXT_UART_MP_MARK       (0x100u)
N#define UART_2_EXT_UART_MP_SPACE      (0x000u)
N
N/* UART CTS/RTS polarity settings */
N#define UART_2_EXT_UART_CTS_ACTIVE_LOW    (0u)
N#define UART_2_EXT_UART_CTS_ACTIVE_HIGH   (1u)
N#define UART_2_EXT_UART_RTS_ACTIVE_LOW    (0u)
N#define UART_2_EXT_UART_RTS_ACTIVE_HIGH   (1u)
N
N/* Sources of RX errors */
N#define UART_2_EXT_INTR_RX_ERR        (UART_2_EXT_INTR_RX_OVERFLOW    | \
N                                             UART_2_EXT_INTR_RX_UNDERFLOW   | \
N                                             UART_2_EXT_INTR_RX_FRAME_ERROR | \
N                                             UART_2_EXT_INTR_RX_PARITY_ERROR)
X#define UART_2_EXT_INTR_RX_ERR        (UART_2_EXT_INTR_RX_OVERFLOW    |                                              UART_2_EXT_INTR_RX_UNDERFLOW   |                                              UART_2_EXT_INTR_RX_FRAME_ERROR |                                              UART_2_EXT_INTR_RX_PARITY_ERROR)
N
N/* Shifted INTR_RX_ERR defines ONLY for UART_2_EXT_UartGetByte() */
N#define UART_2_EXT_UART_RX_OVERFLOW       (UART_2_EXT_INTR_RX_OVERFLOW << 8u)
N#define UART_2_EXT_UART_RX_UNDERFLOW      (UART_2_EXT_INTR_RX_UNDERFLOW << 8u)
N#define UART_2_EXT_UART_RX_FRAME_ERROR    (UART_2_EXT_INTR_RX_FRAME_ERROR << 8u)
N#define UART_2_EXT_UART_RX_PARITY_ERROR   (UART_2_EXT_INTR_RX_PARITY_ERROR << 8u)
N#define UART_2_EXT_UART_RX_ERROR_MASK     (UART_2_EXT_UART_RX_OVERFLOW    | \
N                                                 UART_2_EXT_UART_RX_UNDERFLOW   | \
N                                                 UART_2_EXT_UART_RX_FRAME_ERROR | \
N                                                 UART_2_EXT_UART_RX_PARITY_ERROR)
X#define UART_2_EXT_UART_RX_ERROR_MASK     (UART_2_EXT_UART_RX_OVERFLOW    |                                                  UART_2_EXT_UART_RX_UNDERFLOW   |                                                  UART_2_EXT_UART_RX_FRAME_ERROR |                                                  UART_2_EXT_UART_RX_PARITY_ERROR)
N
N#define UART_2_EXT_INTR_UART_TX_RESTORE   (UART_2_EXT_INTR_TX_OVERFLOW  | \
N                                                 UART_2_EXT_INTR_TX_UART_NACK | \
N                                                 UART_2_EXT_INTR_TX_UART_DONE | \
N                                                 UART_2_EXT_INTR_TX_UART_ARB_LOST)
X#define UART_2_EXT_INTR_UART_TX_RESTORE   (UART_2_EXT_INTR_TX_OVERFLOW  |                                                  UART_2_EXT_INTR_TX_UART_NACK |                                                  UART_2_EXT_INTR_TX_UART_DONE |                                                  UART_2_EXT_INTR_TX_UART_ARB_LOST)
N
N
N/***************************************
N*     Vars with External Linkage
N***************************************/
N
N#if(UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    extern const UART_2_EXT_SPI_INIT_STRUCT  UART_2_EXT_configSpi;
S    extern const UART_2_EXT_UART_INIT_STRUCT UART_2_EXT_configUart;
N#endif /* (UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N#if (UART_2_EXT_UART_WAKE_ENABLE_CONST && UART_2_EXT_UART_RX_WAKEUP_IRQ)
X#if ((0u != (0u)) && (0u == (1u)))
S    extern uint8 UART_2_EXT_skipStart;
N#endif /* (UART_2_EXT_UART_WAKE_ENABLE_CONST && UART_2_EXT_UART_RX_WAKEUP_IRQ) */
N
N
N/***************************************
N*    Specific SPI Macro Definitions
N***************************************/
N
N#define UART_2_EXT_GET_SPI_INTR_SLAVE_MASK(sourceMask)  ((sourceMask) & UART_2_EXT_INTR_SLAVE_SPI_BUS_ERROR)
N#define UART_2_EXT_GET_SPI_INTR_MASTER_MASK(sourceMask) ((sourceMask) & UART_2_EXT_INTR_MASTER_SPI_DONE)
N#define UART_2_EXT_GET_SPI_INTR_RX_MASK(sourceMask) \
N                                             ((sourceMask) & (uint32) ~UART_2_EXT_INTR_SLAVE_SPI_BUS_ERROR)
X#define UART_2_EXT_GET_SPI_INTR_RX_MASK(sourceMask)                                              ((sourceMask) & (uint32) ~UART_2_EXT_INTR_SLAVE_SPI_BUS_ERROR)
N
N#define UART_2_EXT_GET_SPI_INTR_TX_MASK(sourceMask) \
N                                             ((sourceMask) & (uint32) ~UART_2_EXT_INTR_MASTER_SPI_DONE)
X#define UART_2_EXT_GET_SPI_INTR_TX_MASK(sourceMask)                                              ((sourceMask) & (uint32) ~UART_2_EXT_INTR_MASTER_SPI_DONE)
N
N
N/***************************************
N*    Specific UART Macro Definitions
N***************************************/
N
N#define UART_2_EXT_UART_GET_CTRL_OVS_IRDA_LP(oversample) \
N        ((UART_2_EXT_UART_IRDA_LP_OVS16   == (oversample)) ? UART_2_EXT_CTRL_OVS_IRDA_LP_OVS16 : \
N         ((UART_2_EXT_UART_IRDA_LP_OVS32   == (oversample)) ? UART_2_EXT_CTRL_OVS_IRDA_LP_OVS32 : \
N          ((UART_2_EXT_UART_IRDA_LP_OVS48   == (oversample)) ? UART_2_EXT_CTRL_OVS_IRDA_LP_OVS48 : \
N           ((UART_2_EXT_UART_IRDA_LP_OVS96   == (oversample)) ? UART_2_EXT_CTRL_OVS_IRDA_LP_OVS96 : \
N            ((UART_2_EXT_UART_IRDA_LP_OVS192  == (oversample)) ? UART_2_EXT_CTRL_OVS_IRDA_LP_OVS192 : \
N             ((UART_2_EXT_UART_IRDA_LP_OVS768  == (oversample)) ? UART_2_EXT_CTRL_OVS_IRDA_LP_OVS768 : \
N              ((UART_2_EXT_UART_IRDA_LP_OVS1536 == (oversample)) ? UART_2_EXT_CTRL_OVS_IRDA_LP_OVS1536 : \
N                                                                          UART_2_EXT_CTRL_OVS_IRDA_LP_OVS16)))))))
X#define UART_2_EXT_UART_GET_CTRL_OVS_IRDA_LP(oversample)         ((UART_2_EXT_UART_IRDA_LP_OVS16   == (oversample)) ? UART_2_EXT_CTRL_OVS_IRDA_LP_OVS16 :          ((UART_2_EXT_UART_IRDA_LP_OVS32   == (oversample)) ? UART_2_EXT_CTRL_OVS_IRDA_LP_OVS32 :           ((UART_2_EXT_UART_IRDA_LP_OVS48   == (oversample)) ? UART_2_EXT_CTRL_OVS_IRDA_LP_OVS48 :            ((UART_2_EXT_UART_IRDA_LP_OVS96   == (oversample)) ? UART_2_EXT_CTRL_OVS_IRDA_LP_OVS96 :             ((UART_2_EXT_UART_IRDA_LP_OVS192  == (oversample)) ? UART_2_EXT_CTRL_OVS_IRDA_LP_OVS192 :              ((UART_2_EXT_UART_IRDA_LP_OVS768  == (oversample)) ? UART_2_EXT_CTRL_OVS_IRDA_LP_OVS768 :               ((UART_2_EXT_UART_IRDA_LP_OVS1536 == (oversample)) ? UART_2_EXT_CTRL_OVS_IRDA_LP_OVS1536 :                                                                           UART_2_EXT_CTRL_OVS_IRDA_LP_OVS16)))))))
N
N#define UART_2_EXT_GET_UART_RX_CTRL_ENABLED(direction) ((0u != (UART_2_EXT_UART_RX & (direction))) ? \
N                                                                     (UART_2_EXT_RX_CTRL_ENABLED) : (0u))
X#define UART_2_EXT_GET_UART_RX_CTRL_ENABLED(direction) ((0u != (UART_2_EXT_UART_RX & (direction))) ?                                                                      (UART_2_EXT_RX_CTRL_ENABLED) : (0u))
N
N#define UART_2_EXT_GET_UART_TX_CTRL_ENABLED(direction) ((0u != (UART_2_EXT_UART_TX & (direction))) ? \
N                                                                     (UART_2_EXT_TX_CTRL_ENABLED) : (0u))
X#define UART_2_EXT_GET_UART_TX_CTRL_ENABLED(direction) ((0u != (UART_2_EXT_UART_TX & (direction))) ?                                                                      (UART_2_EXT_TX_CTRL_ENABLED) : (0u))
N
N
N/***************************************
N*        SPI Register Settings
N***************************************/
N
N#define UART_2_EXT_CTRL_SPI      (UART_2_EXT_CTRL_MODE_SPI)
N#define UART_2_EXT_SPI_RX_CTRL   (UART_2_EXT_RX_CTRL_ENABLED)
N#define UART_2_EXT_SPI_TX_CTRL   (UART_2_EXT_TX_CTRL_ENABLED)
N
N
N/***************************************
N*       SPI Init Register Settings
N***************************************/
N
N#define UART_2_EXT_SPI_SS_POLARITY \
N             (((uint32) UART_2_EXT_SPI_SS0_POLARITY << UART_2_EXT_SPI_SLAVE_SELECT0) | \
N              ((uint32) UART_2_EXT_SPI_SS1_POLARITY << UART_2_EXT_SPI_SLAVE_SELECT1) | \
N              ((uint32) UART_2_EXT_SPI_SS2_POLARITY << UART_2_EXT_SPI_SLAVE_SELECT2) | \
N              ((uint32) UART_2_EXT_SPI_SS3_POLARITY << UART_2_EXT_SPI_SLAVE_SELECT3))
X#define UART_2_EXT_SPI_SS_POLARITY              (((uint32) UART_2_EXT_SPI_SS0_POLARITY << UART_2_EXT_SPI_SLAVE_SELECT0) |               ((uint32) UART_2_EXT_SPI_SS1_POLARITY << UART_2_EXT_SPI_SLAVE_SELECT1) |               ((uint32) UART_2_EXT_SPI_SS2_POLARITY << UART_2_EXT_SPI_SLAVE_SELECT2) |               ((uint32) UART_2_EXT_SPI_SS3_POLARITY << UART_2_EXT_SPI_SLAVE_SELECT3))
N
N#if(UART_2_EXT_SCB_MODE_SPI_CONST_CFG)
X#if(((0x02u) == (4u)))
S
S    /* SPI Configuration */
S    #define UART_2_EXT_SPI_DEFAULT_CTRL \
S                    (UART_2_EXT_GET_CTRL_OVS(UART_2_EXT_SPI_OVS_FACTOR) | \
S                     UART_2_EXT_GET_CTRL_BYTE_MODE (UART_2_EXT_SPI_BYTE_MODE_ENABLE) | \
S                     UART_2_EXT_GET_CTRL_EC_AM_MODE(UART_2_EXT_SPI_WAKE_ENABLE)      | \
S                     UART_2_EXT_CTRL_SPI)
X    #define UART_2_EXT_SPI_DEFAULT_CTRL                     (UART_2_EXT_GET_CTRL_OVS(UART_2_EXT_SPI_OVS_FACTOR) |                      UART_2_EXT_GET_CTRL_BYTE_MODE (UART_2_EXT_SPI_BYTE_MODE_ENABLE) |                      UART_2_EXT_GET_CTRL_EC_AM_MODE(UART_2_EXT_SPI_WAKE_ENABLE)      |                      UART_2_EXT_CTRL_SPI)
S
S    #define UART_2_EXT_SPI_DEFAULT_SPI_CTRL \
S                    (UART_2_EXT_GET_SPI_CTRL_CONTINUOUS    (UART_2_EXT_SPI_TRANSFER_SEPARATION)       | \
S                     UART_2_EXT_GET_SPI_CTRL_SELECT_PRECEDE(UART_2_EXT_SPI_SUB_MODE &                   \
S                                                                  UART_2_EXT_SPI_MODE_TI_PRECEDES_MASK)     | \
S                     UART_2_EXT_GET_SPI_CTRL_SCLK_MODE     (UART_2_EXT_SPI_CLOCK_MODE)                | \
S                     UART_2_EXT_GET_SPI_CTRL_LATE_MISO_SAMPLE(UART_2_EXT_SPI_LATE_MISO_SAMPLE_ENABLE) | \
S                     UART_2_EXT_GET_SPI_CTRL_SCLK_CONTINUOUS(UART_2_EXT_SPI_FREE_RUN_SCLK_ENABLE)     | \
S                     UART_2_EXT_GET_SPI_CTRL_SSEL_POLARITY (UART_2_EXT_SPI_SS_POLARITY)               | \
S                     UART_2_EXT_GET_SPI_CTRL_SUB_MODE      (UART_2_EXT_SPI_SUB_MODE)                  | \
S                     UART_2_EXT_GET_SPI_CTRL_MASTER_MODE   (UART_2_EXT_SPI_MODE))
X    #define UART_2_EXT_SPI_DEFAULT_SPI_CTRL                     (UART_2_EXT_GET_SPI_CTRL_CONTINUOUS    (UART_2_EXT_SPI_TRANSFER_SEPARATION)       |                      UART_2_EXT_GET_SPI_CTRL_SELECT_PRECEDE(UART_2_EXT_SPI_SUB_MODE &                                                                                     UART_2_EXT_SPI_MODE_TI_PRECEDES_MASK)     |                      UART_2_EXT_GET_SPI_CTRL_SCLK_MODE     (UART_2_EXT_SPI_CLOCK_MODE)                |                      UART_2_EXT_GET_SPI_CTRL_LATE_MISO_SAMPLE(UART_2_EXT_SPI_LATE_MISO_SAMPLE_ENABLE) |                      UART_2_EXT_GET_SPI_CTRL_SCLK_CONTINUOUS(UART_2_EXT_SPI_FREE_RUN_SCLK_ENABLE)     |                      UART_2_EXT_GET_SPI_CTRL_SSEL_POLARITY (UART_2_EXT_SPI_SS_POLARITY)               |                      UART_2_EXT_GET_SPI_CTRL_SUB_MODE      (UART_2_EXT_SPI_SUB_MODE)                  |                      UART_2_EXT_GET_SPI_CTRL_MASTER_MODE   (UART_2_EXT_SPI_MODE))
S
S    /* RX direction */
S    #define UART_2_EXT_SPI_DEFAULT_RX_CTRL \
S                    (UART_2_EXT_GET_RX_CTRL_DATA_WIDTH(UART_2_EXT_SPI_RX_DATA_BITS_NUM)     | \
S                     UART_2_EXT_GET_RX_CTRL_BIT_ORDER (UART_2_EXT_SPI_BITS_ORDER)           | \
S                     UART_2_EXT_GET_RX_CTRL_MEDIAN    (UART_2_EXT_SPI_MEDIAN_FILTER_ENABLE) | \
S                     UART_2_EXT_SPI_RX_CTRL)
X    #define UART_2_EXT_SPI_DEFAULT_RX_CTRL                     (UART_2_EXT_GET_RX_CTRL_DATA_WIDTH(UART_2_EXT_SPI_RX_DATA_BITS_NUM)     |                      UART_2_EXT_GET_RX_CTRL_BIT_ORDER (UART_2_EXT_SPI_BITS_ORDER)           |                      UART_2_EXT_GET_RX_CTRL_MEDIAN    (UART_2_EXT_SPI_MEDIAN_FILTER_ENABLE) |                      UART_2_EXT_SPI_RX_CTRL)
S
S    #define UART_2_EXT_SPI_DEFAULT_RX_FIFO_CTRL \
S                    UART_2_EXT_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(UART_2_EXT_SPI_RX_TRIGGER_LEVEL)
X    #define UART_2_EXT_SPI_DEFAULT_RX_FIFO_CTRL                     UART_2_EXT_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(UART_2_EXT_SPI_RX_TRIGGER_LEVEL)
S
S    /* TX direction */
S    #define UART_2_EXT_SPI_DEFAULT_TX_CTRL \
S                    (UART_2_EXT_GET_TX_CTRL_DATA_WIDTH(UART_2_EXT_SPI_TX_DATA_BITS_NUM) | \
S                     UART_2_EXT_GET_TX_CTRL_BIT_ORDER (UART_2_EXT_SPI_BITS_ORDER)       | \
S                     UART_2_EXT_SPI_TX_CTRL)
X    #define UART_2_EXT_SPI_DEFAULT_TX_CTRL                     (UART_2_EXT_GET_TX_CTRL_DATA_WIDTH(UART_2_EXT_SPI_TX_DATA_BITS_NUM) |                      UART_2_EXT_GET_TX_CTRL_BIT_ORDER (UART_2_EXT_SPI_BITS_ORDER)       |                      UART_2_EXT_SPI_TX_CTRL)
S
S    #define UART_2_EXT_SPI_DEFAULT_TX_FIFO_CTRL \
S                    UART_2_EXT_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(UART_2_EXT_SPI_TX_TRIGGER_LEVEL)
X    #define UART_2_EXT_SPI_DEFAULT_TX_FIFO_CTRL                     UART_2_EXT_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(UART_2_EXT_SPI_TX_TRIGGER_LEVEL)
S
S    /* Interrupt sources */
S    #define UART_2_EXT_SPI_DEFAULT_INTR_SPI_EC_MASK   (UART_2_EXT_NO_INTR_SOURCES)
S
S    #define UART_2_EXT_SPI_DEFAULT_INTR_I2C_EC_MASK   (UART_2_EXT_NO_INTR_SOURCES)
S    #define UART_2_EXT_SPI_DEFAULT_INTR_SLAVE_MASK \
S                    (UART_2_EXT_SPI_INTR_RX_MASK & UART_2_EXT_INTR_SLAVE_SPI_BUS_ERROR)
X    #define UART_2_EXT_SPI_DEFAULT_INTR_SLAVE_MASK                     (UART_2_EXT_SPI_INTR_RX_MASK & UART_2_EXT_INTR_SLAVE_SPI_BUS_ERROR)
S
S    #define UART_2_EXT_SPI_DEFAULT_INTR_MASTER_MASK \
S                    (UART_2_EXT_SPI_INTR_TX_MASK & UART_2_EXT_INTR_MASTER_SPI_DONE)
X    #define UART_2_EXT_SPI_DEFAULT_INTR_MASTER_MASK                     (UART_2_EXT_SPI_INTR_TX_MASK & UART_2_EXT_INTR_MASTER_SPI_DONE)
S
S    #define UART_2_EXT_SPI_DEFAULT_INTR_RX_MASK \
S                    (UART_2_EXT_SPI_INTR_RX_MASK & (uint32) ~UART_2_EXT_INTR_SLAVE_SPI_BUS_ERROR)
X    #define UART_2_EXT_SPI_DEFAULT_INTR_RX_MASK                     (UART_2_EXT_SPI_INTR_RX_MASK & (uint32) ~UART_2_EXT_INTR_SLAVE_SPI_BUS_ERROR)
S
S    #define UART_2_EXT_SPI_DEFAULT_INTR_TX_MASK \
S                    (UART_2_EXT_SPI_INTR_TX_MASK & (uint32) ~UART_2_EXT_INTR_MASTER_SPI_DONE)
X    #define UART_2_EXT_SPI_DEFAULT_INTR_TX_MASK                     (UART_2_EXT_SPI_INTR_TX_MASK & (uint32) ~UART_2_EXT_INTR_MASTER_SPI_DONE)
S
N#endif /* (UART_2_EXT_SCB_MODE_SPI_CONST_CFG) */
N
N
N/***************************************
N*        UART Register Settings
N***************************************/
N
N#define UART_2_EXT_CTRL_UART      (UART_2_EXT_CTRL_MODE_UART)
N#define UART_2_EXT_UART_RX_CTRL   (UART_2_EXT_RX_CTRL_LSB_FIRST) /* LSB for UART goes first */
N#define UART_2_EXT_UART_TX_CTRL   (UART_2_EXT_TX_CTRL_LSB_FIRST) /* LSB for UART goes first */
N
N
N/***************************************
N*      UART Init Register Settings
N***************************************/
N
N#if(UART_2_EXT_SCB_MODE_UART_CONST_CFG)
X#if(((0x04u) == (4u)))
N
N    /* UART configuration */
N    #if(UART_2_EXT_UART_MODE_IRDA == UART_2_EXT_UART_SUB_MODE)
X    #if((2u) == (0u))
S
S        #define UART_2_EXT_DEFAULT_CTRL_OVS   ((0u != UART_2_EXT_UART_IRDA_LOW_POWER) ?              \
S                                (UART_2_EXT_UART_GET_CTRL_OVS_IRDA_LP(UART_2_EXT_UART_OVS_FACTOR)) : \
S                                (UART_2_EXT_CTRL_OVS_IRDA_OVS16))
X        #define UART_2_EXT_DEFAULT_CTRL_OVS   ((0u != UART_2_EXT_UART_IRDA_LOW_POWER) ?                                              (UART_2_EXT_UART_GET_CTRL_OVS_IRDA_LP(UART_2_EXT_UART_OVS_FACTOR)) :                                 (UART_2_EXT_CTRL_OVS_IRDA_OVS16))
S
N    #else
N
N        #define UART_2_EXT_DEFAULT_CTRL_OVS   UART_2_EXT_GET_CTRL_OVS(UART_2_EXT_UART_OVS_FACTOR)
N
N    #endif /* (UART_2_EXT_UART_MODE_IRDA == UART_2_EXT_UART_SUB_MODE) */
N
N    #define UART_2_EXT_UART_DEFAULT_CTRL \
N                                (UART_2_EXT_GET_CTRL_BYTE_MODE  (UART_2_EXT_UART_BYTE_MODE_ENABLE)  | \
N                                 UART_2_EXT_GET_CTRL_ADDR_ACCEPT(UART_2_EXT_UART_MP_ACCEPT_ADDRESS) | \
N                                 UART_2_EXT_DEFAULT_CTRL_OVS                                              | \
N                                 UART_2_EXT_CTRL_UART)
X    #define UART_2_EXT_UART_DEFAULT_CTRL                                 (UART_2_EXT_GET_CTRL_BYTE_MODE  (UART_2_EXT_UART_BYTE_MODE_ENABLE)  |                                  UART_2_EXT_GET_CTRL_ADDR_ACCEPT(UART_2_EXT_UART_MP_ACCEPT_ADDRESS) |                                  UART_2_EXT_DEFAULT_CTRL_OVS                                              |                                  UART_2_EXT_CTRL_UART)
N
N    #define UART_2_EXT_UART_DEFAULT_UART_CTRL \
N                                    (UART_2_EXT_GET_UART_CTRL_MODE(UART_2_EXT_UART_SUB_MODE))
X    #define UART_2_EXT_UART_DEFAULT_UART_CTRL                                     (UART_2_EXT_GET_UART_CTRL_MODE(UART_2_EXT_UART_SUB_MODE))
N
N    /* RX direction */
N    #define UART_2_EXT_UART_DEFAULT_RX_CTRL_PARITY \
N                                ((UART_2_EXT_UART_PARITY_NONE != UART_2_EXT_UART_PARITY_TYPE) ?      \
N                                  (UART_2_EXT_GET_UART_RX_CTRL_PARITY(UART_2_EXT_UART_PARITY_TYPE) | \
N                                   UART_2_EXT_UART_RX_CTRL_PARITY_ENABLED) : (0u))
X    #define UART_2_EXT_UART_DEFAULT_RX_CTRL_PARITY                                 ((UART_2_EXT_UART_PARITY_NONE != UART_2_EXT_UART_PARITY_TYPE) ?                                        (UART_2_EXT_GET_UART_RX_CTRL_PARITY(UART_2_EXT_UART_PARITY_TYPE) |                                    UART_2_EXT_UART_RX_CTRL_PARITY_ENABLED) : (0u))
N
N    #define UART_2_EXT_UART_DEFAULT_UART_RX_CTRL \
N                    (UART_2_EXT_GET_UART_RX_CTRL_MODE(UART_2_EXT_UART_STOP_BITS_NUM)                    | \
N                     UART_2_EXT_GET_UART_RX_CTRL_POLARITY(UART_2_EXT_UART_IRDA_POLARITY)                | \
N                     UART_2_EXT_GET_UART_RX_CTRL_MP_MODE(UART_2_EXT_UART_MP_MODE_ENABLE)                | \
N                     UART_2_EXT_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(UART_2_EXT_UART_DROP_ON_PARITY_ERR) | \
N                     UART_2_EXT_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(UART_2_EXT_UART_DROP_ON_FRAME_ERR)   | \
N                     UART_2_EXT_GET_UART_RX_CTRL_BREAK_WIDTH(UART_2_EXT_UART_RX_BREAK_WIDTH)            | \
N                     UART_2_EXT_UART_DEFAULT_RX_CTRL_PARITY)
X    #define UART_2_EXT_UART_DEFAULT_UART_RX_CTRL                     (UART_2_EXT_GET_UART_RX_CTRL_MODE(UART_2_EXT_UART_STOP_BITS_NUM)                    |                      UART_2_EXT_GET_UART_RX_CTRL_POLARITY(UART_2_EXT_UART_IRDA_POLARITY)                |                      UART_2_EXT_GET_UART_RX_CTRL_MP_MODE(UART_2_EXT_UART_MP_MODE_ENABLE)                |                      UART_2_EXT_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(UART_2_EXT_UART_DROP_ON_PARITY_ERR) |                      UART_2_EXT_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(UART_2_EXT_UART_DROP_ON_FRAME_ERR)   |                      UART_2_EXT_GET_UART_RX_CTRL_BREAK_WIDTH(UART_2_EXT_UART_RX_BREAK_WIDTH)            |                      UART_2_EXT_UART_DEFAULT_RX_CTRL_PARITY)
N
N
N    #define UART_2_EXT_UART_DEFAULT_RX_CTRL \
N                                (UART_2_EXT_GET_RX_CTRL_DATA_WIDTH(UART_2_EXT_UART_DATA_BITS_NUM)        | \
N                                 UART_2_EXT_GET_RX_CTRL_MEDIAN    (UART_2_EXT_UART_MEDIAN_FILTER_ENABLE) | \
N                                 UART_2_EXT_GET_UART_RX_CTRL_ENABLED(UART_2_EXT_UART_DIRECTION))
X    #define UART_2_EXT_UART_DEFAULT_RX_CTRL                                 (UART_2_EXT_GET_RX_CTRL_DATA_WIDTH(UART_2_EXT_UART_DATA_BITS_NUM)        |                                  UART_2_EXT_GET_RX_CTRL_MEDIAN    (UART_2_EXT_UART_MEDIAN_FILTER_ENABLE) |                                  UART_2_EXT_GET_UART_RX_CTRL_ENABLED(UART_2_EXT_UART_DIRECTION))
N
N    #define UART_2_EXT_UART_DEFAULT_RX_FIFO_CTRL \
N                                UART_2_EXT_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(UART_2_EXT_UART_RX_TRIGGER_LEVEL)
X    #define UART_2_EXT_UART_DEFAULT_RX_FIFO_CTRL                                 UART_2_EXT_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(UART_2_EXT_UART_RX_TRIGGER_LEVEL)
N
N    #define UART_2_EXT_UART_DEFAULT_RX_MATCH_REG  ((0u != UART_2_EXT_UART_MP_MODE_ENABLE) ?          \
N                                (UART_2_EXT_GET_RX_MATCH_ADDR(UART_2_EXT_UART_MP_RX_ADDRESS) | \
N                                 UART_2_EXT_GET_RX_MATCH_MASK(UART_2_EXT_UART_MP_RX_ADDRESS_MASK)) : (0u))
X    #define UART_2_EXT_UART_DEFAULT_RX_MATCH_REG  ((0u != UART_2_EXT_UART_MP_MODE_ENABLE) ?                                          (UART_2_EXT_GET_RX_MATCH_ADDR(UART_2_EXT_UART_MP_RX_ADDRESS) |                                  UART_2_EXT_GET_RX_MATCH_MASK(UART_2_EXT_UART_MP_RX_ADDRESS_MASK)) : (0u))
N
N    /* TX direction */
N    #define UART_2_EXT_UART_DEFAULT_TX_CTRL_PARITY (UART_2_EXT_UART_DEFAULT_RX_CTRL_PARITY)
N
N    #define UART_2_EXT_UART_DEFAULT_UART_TX_CTRL \
N                                (UART_2_EXT_GET_UART_TX_CTRL_MODE(UART_2_EXT_UART_STOP_BITS_NUM)       | \
N                                 UART_2_EXT_GET_UART_TX_CTRL_RETRY_NACK(UART_2_EXT_UART_RETRY_ON_NACK) | \
N                                 UART_2_EXT_UART_DEFAULT_TX_CTRL_PARITY)
X    #define UART_2_EXT_UART_DEFAULT_UART_TX_CTRL                                 (UART_2_EXT_GET_UART_TX_CTRL_MODE(UART_2_EXT_UART_STOP_BITS_NUM)       |                                  UART_2_EXT_GET_UART_TX_CTRL_RETRY_NACK(UART_2_EXT_UART_RETRY_ON_NACK) |                                  UART_2_EXT_UART_DEFAULT_TX_CTRL_PARITY)
N
N    #define UART_2_EXT_UART_DEFAULT_TX_CTRL \
N                                (UART_2_EXT_GET_TX_CTRL_DATA_WIDTH(UART_2_EXT_UART_DATA_BITS_NUM) | \
N                                 UART_2_EXT_GET_UART_TX_CTRL_ENABLED(UART_2_EXT_UART_DIRECTION))
X    #define UART_2_EXT_UART_DEFAULT_TX_CTRL                                 (UART_2_EXT_GET_TX_CTRL_DATA_WIDTH(UART_2_EXT_UART_DATA_BITS_NUM) |                                  UART_2_EXT_GET_UART_TX_CTRL_ENABLED(UART_2_EXT_UART_DIRECTION))
N
N    #define UART_2_EXT_UART_DEFAULT_TX_FIFO_CTRL \
N                                UART_2_EXT_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(UART_2_EXT_UART_TX_TRIGGER_LEVEL)
X    #define UART_2_EXT_UART_DEFAULT_TX_FIFO_CTRL                                 UART_2_EXT_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(UART_2_EXT_UART_TX_TRIGGER_LEVEL)
N
N    #define UART_2_EXT_UART_DEFAULT_FLOW_CTRL \
N                        (UART_2_EXT_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(UART_2_EXT_UART_RTS_FIFO_LEVEL) | \
N                         UART_2_EXT_GET_UART_FLOW_CTRL_RTS_POLARITY (UART_2_EXT_UART_RTS_POLARITY)   | \
N                         UART_2_EXT_GET_UART_FLOW_CTRL_CTS_POLARITY (UART_2_EXT_UART_CTS_POLARITY)   | \
N                         UART_2_EXT_GET_UART_FLOW_CTRL_CTS_ENABLE   (UART_2_EXT_UART_CTS_ENABLE))
X    #define UART_2_EXT_UART_DEFAULT_FLOW_CTRL                         (UART_2_EXT_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(UART_2_EXT_UART_RTS_FIFO_LEVEL) |                          UART_2_EXT_GET_UART_FLOW_CTRL_RTS_POLARITY (UART_2_EXT_UART_RTS_POLARITY)   |                          UART_2_EXT_GET_UART_FLOW_CTRL_CTS_POLARITY (UART_2_EXT_UART_CTS_POLARITY)   |                          UART_2_EXT_GET_UART_FLOW_CTRL_CTS_ENABLE   (UART_2_EXT_UART_CTS_ENABLE))
N
N    /* Interrupt sources */
N    #define UART_2_EXT_UART_DEFAULT_INTR_I2C_EC_MASK  (UART_2_EXT_NO_INTR_SOURCES)
N    #define UART_2_EXT_UART_DEFAULT_INTR_SPI_EC_MASK  (UART_2_EXT_NO_INTR_SOURCES)
N    #define UART_2_EXT_UART_DEFAULT_INTR_SLAVE_MASK   (UART_2_EXT_NO_INTR_SOURCES)
N    #define UART_2_EXT_UART_DEFAULT_INTR_MASTER_MASK  (UART_2_EXT_NO_INTR_SOURCES)
N    #define UART_2_EXT_UART_DEFAULT_INTR_RX_MASK      (UART_2_EXT_UART_INTR_RX_MASK)
N    #define UART_2_EXT_UART_DEFAULT_INTR_TX_MASK      (UART_2_EXT_UART_INTR_TX_MASK)
N
N#endif /* (UART_2_EXT_SCB_MODE_UART_CONST_CFG) */
N
N
N/***************************************
N* The following code is DEPRECATED and
N* must not be used.
N***************************************/
N
N#define UART_2_EXT_SPIM_ACTIVE_SS0    (UART_2_EXT_SPI_SLAVE_SELECT0)
N#define UART_2_EXT_SPIM_ACTIVE_SS1    (UART_2_EXT_SPI_SLAVE_SELECT1)
N#define UART_2_EXT_SPIM_ACTIVE_SS2    (UART_2_EXT_SPI_SLAVE_SELECT2)
N#define UART_2_EXT_SPIM_ACTIVE_SS3    (UART_2_EXT_SPI_SLAVE_SELECT3)
N
N#endif /* CY_SCB_SPI_UART_UART_2_EXT_H */
N
N
N/* [] END OF FILE */
L 35 "Generated_Source\PSoC4\project.h" 2
N#include "UART_2_EXT_PINS.h"
N#include "UART_2_EXT_SPI_UART_PVT.h"
L 1 "Generated_Source\PSoC4\UART_2_EXT_SPI_UART_PVT.h" 1
N/***************************************************************************//**
N* \file UART_2_EXT_SPI_UART_PVT.h
N* \version 4.0
N*
N* \brief
N*  This private file provides constants and parameter values for the
N*  SCB Component in SPI and UART modes.
N*  Please do not use this file or its content in your project.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation. All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_SPI_UART_PVT_UART_2_EXT_H)
X#if !0L
N#define CY_SCB_SPI_UART_PVT_UART_2_EXT_H
N
N#include "UART_2_EXT_SPI_UART.h"
N
N
N/***************************************
N*     Internal Global Vars
N***************************************/
N
N#if (UART_2_EXT_INTERNAL_RX_SW_BUFFER_CONST)
X#if (((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u)))))))
S    extern volatile uint32  UART_2_EXT_rxBufferHead;
S    extern volatile uint32  UART_2_EXT_rxBufferTail;
S    
S    /**
S    * \addtogroup group_globals
S    * @{
S    */
S    
S    /** Sets when internal software receive buffer overflow
S     *  was occurred.
S    */  
S    extern volatile uint8   UART_2_EXT_rxBufferOverflow;
S    /** @} globals */
N#endif /* (UART_2_EXT_INTERNAL_RX_SW_BUFFER_CONST) */
N
N#if (UART_2_EXT_INTERNAL_TX_SW_BUFFER_CONST)
X#if (((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u)))))))
S    extern volatile uint32  UART_2_EXT_txBufferHead;
S    extern volatile uint32  UART_2_EXT_txBufferTail;
N#endif /* (UART_2_EXT_INTERNAL_TX_SW_BUFFER_CONST) */
N
N#if (UART_2_EXT_INTERNAL_RX_SW_BUFFER)
X#if ((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u))))))
S    extern volatile uint8 UART_2_EXT_rxBufferInternal[UART_2_EXT_INTERNAL_RX_BUFFER_SIZE];
N#endif /* (UART_2_EXT_INTERNAL_RX_SW_BUFFER) */
N
N#if (UART_2_EXT_INTERNAL_TX_SW_BUFFER)
X#if ((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u))))))
S    extern volatile uint8 UART_2_EXT_txBufferInternal[UART_2_EXT_TX_BUFFER_SIZE];
N#endif /* (UART_2_EXT_INTERNAL_TX_SW_BUFFER) */
N
N
N/***************************************
N*     Private Function Prototypes
N***************************************/
N
Nvoid UART_2_EXT_SpiPostEnable(void);
Nvoid UART_2_EXT_SpiStop(void);
N
N#if (UART_2_EXT_SCB_MODE_SPI_CONST_CFG)
X#if (((0x02u) == (4u)))
S    void UART_2_EXT_SpiInit(void);
N#endif /* (UART_2_EXT_SCB_MODE_SPI_CONST_CFG) */
N
N#if (UART_2_EXT_SPI_WAKE_ENABLE_CONST)
X#if ((0u))
S    void UART_2_EXT_SpiSaveConfig(void);
S    void UART_2_EXT_SpiRestoreConfig(void);
N#endif /* (UART_2_EXT_SPI_WAKE_ENABLE_CONST) */
N
Nvoid UART_2_EXT_UartPostEnable(void);
Nvoid UART_2_EXT_UartStop(void);
N
N#if (UART_2_EXT_SCB_MODE_UART_CONST_CFG)
X#if (((0x04u) == (4u)))
N    void UART_2_EXT_UartInit(void);
N#endif /* (UART_2_EXT_SCB_MODE_UART_CONST_CFG) */
N
N#if (UART_2_EXT_UART_WAKE_ENABLE_CONST)
X#if ((0u != (0u)))
S    void UART_2_EXT_UartSaveConfig(void);
S    void UART_2_EXT_UartRestoreConfig(void);
N#endif /* (UART_2_EXT_UART_WAKE_ENABLE_CONST) */
N
N
N/***************************************
N*         UART API Constants
N***************************************/
N
N/* UART RX and TX position to be used in UART_2_EXT_SetPins() */
N#define UART_2_EXT_UART_RX_PIN_ENABLE    (UART_2_EXT_UART_RX)
N#define UART_2_EXT_UART_TX_PIN_ENABLE    (UART_2_EXT_UART_TX)
N
N/* UART RTS and CTS position to be used in  UART_2_EXT_SetPins() */
N#define UART_2_EXT_UART_RTS_PIN_ENABLE    (0x10u)
N#define UART_2_EXT_UART_CTS_PIN_ENABLE    (0x20u)
N
N
N/***************************************
N* The following code is DEPRECATED and
N* must not be used.
N***************************************/
N
N/* Interrupt processing */
N#define UART_2_EXT_SpiUartEnableIntRx(intSourceMask)  UART_2_EXT_SetRxInterruptMode(intSourceMask)
N#define UART_2_EXT_SpiUartEnableIntTx(intSourceMask)  UART_2_EXT_SetTxInterruptMode(intSourceMask)
Nuint32  UART_2_EXT_SpiUartDisableIntRx(void);
Nuint32  UART_2_EXT_SpiUartDisableIntTx(void);
N
N
N#endif /* (CY_SCB_SPI_UART_PVT_UART_2_EXT_H) */
N
N
N/* [] END OF FILE */
L 37 "Generated_Source\PSoC4\project.h" 2
N#include "UART_2_EXT_PVT.h"
L 1 "Generated_Source\PSoC4\UART_2_EXT_PVT.h" 1
N/***************************************************************************//**
N* \file .h
N* \version 4.0
N*
N* \brief
N*  This private file provides constants and parameter values for the
N*  SCB Component.
N*  Please do not use this file or its content in your project.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation. All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_PVT_UART_2_EXT_H)
X#if !0L
N#define CY_SCB_PVT_UART_2_EXT_H
N
N#include "UART_2_EXT.h"
N
N
N/***************************************
N*     Private Function Prototypes
N***************************************/
N
N/* APIs to service INTR_I2C_EC register */
N#define UART_2_EXT_SetI2CExtClkInterruptMode(interruptMask) UART_2_EXT_WRITE_INTR_I2C_EC_MASK(interruptMask)
N#define UART_2_EXT_ClearI2CExtClkInterruptSource(interruptMask) UART_2_EXT_CLEAR_INTR_I2C_EC(interruptMask)
N#define UART_2_EXT_GetI2CExtClkInterruptSource()                (UART_2_EXT_INTR_I2C_EC_REG)
N#define UART_2_EXT_GetI2CExtClkInterruptMode()                  (UART_2_EXT_INTR_I2C_EC_MASK_REG)
N#define UART_2_EXT_GetI2CExtClkInterruptSourceMasked()          (UART_2_EXT_INTR_I2C_EC_MASKED_REG)
N
N#if (!UART_2_EXT_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    /* APIs to service INTR_SPI_EC register */
N    #define UART_2_EXT_SetSpiExtClkInterruptMode(interruptMask) \
N                                                                UART_2_EXT_WRITE_INTR_SPI_EC_MASK(interruptMask)
X    #define UART_2_EXT_SetSpiExtClkInterruptMode(interruptMask)                                                                 UART_2_EXT_WRITE_INTR_SPI_EC_MASK(interruptMask)
N    #define UART_2_EXT_ClearSpiExtClkInterruptSource(interruptMask) \
N                                                                UART_2_EXT_CLEAR_INTR_SPI_EC(interruptMask)
X    #define UART_2_EXT_ClearSpiExtClkInterruptSource(interruptMask)                                                                 UART_2_EXT_CLEAR_INTR_SPI_EC(interruptMask)
N    #define UART_2_EXT_GetExtSpiClkInterruptSource()                 (UART_2_EXT_INTR_SPI_EC_REG)
N    #define UART_2_EXT_GetExtSpiClkInterruptMode()                   (UART_2_EXT_INTR_SPI_EC_MASK_REG)
N    #define UART_2_EXT_GetExtSpiClkInterruptSourceMasked()           (UART_2_EXT_INTR_SPI_EC_MASKED_REG)
N#endif /* (!UART_2_EXT_CY_SCBIP_V1) */
N
N#if(UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    extern void UART_2_EXT_SetPins(uint32 mode, uint32 subMode, uint32 uartEnableMask);
N#endif /* (UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N
N/***************************************
N*     Vars with External Linkage
N***************************************/
N
N#if (UART_2_EXT_SCB_IRQ_INTERNAL)
X#if ((0u == (0u)))
N#if !defined (CY_REMOVE_UART_2_EXT_CUSTOM_INTR_HANDLER)
X#if !0L
N    extern cyisraddress UART_2_EXT_customIntrHandler;
N#endif /* !defined (CY_REMOVE_UART_2_EXT_CUSTOM_INTR_HANDLER) */
N#endif /* (UART_2_EXT_SCB_IRQ_INTERNAL) */
N
Nextern UART_2_EXT_BACKUP_STRUCT UART_2_EXT_backup;
N
N#if(UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    /* Common configuration variables */
S    extern uint8 UART_2_EXT_scbMode;
S    extern uint8 UART_2_EXT_scbEnableWake;
S    extern uint8 UART_2_EXT_scbEnableIntr;
S
S    /* I2C configuration variables */
S    extern uint8 UART_2_EXT_mode;
S    extern uint8 UART_2_EXT_acceptAddr;
S
S    /* SPI/UART configuration variables */
S    extern volatile uint8 * UART_2_EXT_rxBuffer;
S    extern uint8   UART_2_EXT_rxDataBits;
S    extern uint32  UART_2_EXT_rxBufferSize;
S
S    extern volatile uint8 * UART_2_EXT_txBuffer;
S    extern uint8   UART_2_EXT_txDataBits;
S    extern uint32  UART_2_EXT_txBufferSize;
S
S    /* EZI2C configuration variables */
S    extern uint8 UART_2_EXT_numberOfAddr;
S    extern uint8 UART_2_EXT_subAddrSize;
N#endif /* (UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N#if (! (UART_2_EXT_SCB_MODE_I2C_CONST_CFG || \
N        UART_2_EXT_SCB_MODE_EZI2C_CONST_CFG))
X#if (! (((0x01u) == (4u)) ||         ((0x08u) == (4u))))
N    extern uint16 UART_2_EXT_IntrTxMask;
N#endif /* (! (UART_2_EXT_SCB_MODE_I2C_CONST_CFG || \
N              UART_2_EXT_SCB_MODE_EZI2C_CONST_CFG)) */
X#endif  
N
N
N/***************************************
N*        Conditional Macro
N****************************************/
N
N#if(UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    /* Defines run time operation mode */
S    #define UART_2_EXT_SCB_MODE_I2C_RUNTM_CFG     (UART_2_EXT_SCB_MODE_I2C      == UART_2_EXT_scbMode)
S    #define UART_2_EXT_SCB_MODE_SPI_RUNTM_CFG     (UART_2_EXT_SCB_MODE_SPI      == UART_2_EXT_scbMode)
S    #define UART_2_EXT_SCB_MODE_UART_RUNTM_CFG    (UART_2_EXT_SCB_MODE_UART     == UART_2_EXT_scbMode)
S    #define UART_2_EXT_SCB_MODE_EZI2C_RUNTM_CFG   (UART_2_EXT_SCB_MODE_EZI2C    == UART_2_EXT_scbMode)
S    #define UART_2_EXT_SCB_MODE_UNCONFIG_RUNTM_CFG \
S                                                        (UART_2_EXT_SCB_MODE_UNCONFIG == UART_2_EXT_scbMode)
X    #define UART_2_EXT_SCB_MODE_UNCONFIG_RUNTM_CFG                                                         (UART_2_EXT_SCB_MODE_UNCONFIG == UART_2_EXT_scbMode)
S
S    /* Defines wakeup enable */
S    #define UART_2_EXT_SCB_WAKE_ENABLE_CHECK       (0u != UART_2_EXT_scbEnableWake)
N#endif /* (UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N/* Defines maximum number of SCB pins */
N#if (!UART_2_EXT_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define UART_2_EXT_SCB_PINS_NUMBER    (7u)
N#else
S    #define UART_2_EXT_SCB_PINS_NUMBER    (2u)
N#endif /* (!UART_2_EXT_CY_SCBIP_V1) */
N
N#endif /* (CY_SCB_PVT_UART_2_EXT_H) */
N
N
N/* [] END OF FILE */
L 38 "Generated_Source\PSoC4\project.h" 2
N#include "UART_2_EXT_BOOT.h"
L 1 "Generated_Source\PSoC4\UART_2_EXT_BOOT.h" 1
N/***************************************************************************//**
N* \file UART_2_EXT_BOOT.h
N* \version 4.0
N*
N* \brief
N*  This file provides constants and parameter values of the bootloader
N*  communication APIs for the SCB Component.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2014-2017, Cypress Semiconductor Corporation. All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_BOOT_UART_2_EXT_H)
X#if !0L
N#define CY_SCB_BOOT_UART_2_EXT_H
N
N#include "UART_2_EXT_PVT.h"
N
N#if (UART_2_EXT_SCB_MODE_I2C_INC)
X#if ((0u !=((0x01u) & (4u))))
S    #include "UART_2_EXT_I2C.h"
N#endif /* (UART_2_EXT_SCB_MODE_I2C_INC) */
N
N#if (UART_2_EXT_SCB_MODE_EZI2C_INC)
X#if ((0u !=((0x08u) & (4u))))
S    #include "UART_2_EXT_EZI2C.h"
N#endif /* (UART_2_EXT_SCB_MODE_EZI2C_INC) */
N
N#if (UART_2_EXT_SCB_MODE_SPI_INC || UART_2_EXT_SCB_MODE_UART_INC)
X#if ((0u !=((0x02u) & (4u))) || (0u !=((0x04u) & (4u))))
N    #include "UART_2_EXT_SPI_UART.h"
N#endif /* (UART_2_EXT_SCB_MODE_SPI_INC || UART_2_EXT_SCB_MODE_UART_INC) */
N
N
N/***************************************
N*  Conditional Compilation Parameters
N****************************************/
N
N/* Bootloader communication interface enable */
N#define UART_2_EXT_BTLDR_COMM_ENABLED ((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_2_EXT) || \
N                                             (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface))
X#define UART_2_EXT_BTLDR_COMM_ENABLED ((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_2_EXT) ||                                              (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface))
N
N/* Enable I2C bootloader communication */
N#if (UART_2_EXT_SCB_MODE_I2C_INC)
X#if ((0u !=((0x01u) & (4u))))
S    #define UART_2_EXT_I2C_BTLDR_COMM_ENABLED     (UART_2_EXT_BTLDR_COMM_ENABLED && \
S                                                            (UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG || \
S                                                             UART_2_EXT_I2C_SLAVE_CONST))
X    #define UART_2_EXT_I2C_BTLDR_COMM_ENABLED     (UART_2_EXT_BTLDR_COMM_ENABLED &&                                                             (UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG ||                                                              UART_2_EXT_I2C_SLAVE_CONST))
N#else
N     #define UART_2_EXT_I2C_BTLDR_COMM_ENABLED    (0u)
N#endif /* (UART_2_EXT_SCB_MODE_I2C_INC) */
N
N/* EZI2C does not support bootloader communication. Provide empty APIs */
N#if (UART_2_EXT_SCB_MODE_EZI2C_INC)
X#if ((0u !=((0x08u) & (4u))))
S    #define UART_2_EXT_EZI2C_BTLDR_COMM_ENABLED   (UART_2_EXT_BTLDR_COMM_ENABLED && \
S                                                         UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG)
X    #define UART_2_EXT_EZI2C_BTLDR_COMM_ENABLED   (UART_2_EXT_BTLDR_COMM_ENABLED &&                                                          UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG)
N#else
N    #define UART_2_EXT_EZI2C_BTLDR_COMM_ENABLED   (0u)
N#endif /* (UART_2_EXT_EZI2C_BTLDR_COMM_ENABLED) */
N
N/* Enable SPI bootloader communication */
N#if (UART_2_EXT_SCB_MODE_SPI_INC)
X#if ((0u !=((0x02u) & (4u))))
S    #define UART_2_EXT_SPI_BTLDR_COMM_ENABLED     (UART_2_EXT_BTLDR_COMM_ENABLED && \
S                                                            (UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG || \
S                                                             UART_2_EXT_SPI_SLAVE_CONST))
X    #define UART_2_EXT_SPI_BTLDR_COMM_ENABLED     (UART_2_EXT_BTLDR_COMM_ENABLED &&                                                             (UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG ||                                                              UART_2_EXT_SPI_SLAVE_CONST))
N#else
N        #define UART_2_EXT_SPI_BTLDR_COMM_ENABLED (0u)
N#endif /* (UART_2_EXT_SPI_BTLDR_COMM_ENABLED) */
N
N/* Enable UART bootloader communication */
N#if (UART_2_EXT_SCB_MODE_UART_INC)
X#if ((0u !=((0x04u) & (4u))))
N       #define UART_2_EXT_UART_BTLDR_COMM_ENABLED    (UART_2_EXT_BTLDR_COMM_ENABLED && \
N                                                            (UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG || \
N                                                             (UART_2_EXT_UART_RX_DIRECTION && \
N                                                              UART_2_EXT_UART_TX_DIRECTION)))
X       #define UART_2_EXT_UART_BTLDR_COMM_ENABLED    (UART_2_EXT_BTLDR_COMM_ENABLED &&                                                             (UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG ||                                                              (UART_2_EXT_UART_RX_DIRECTION &&                                                               UART_2_EXT_UART_TX_DIRECTION)))
N#else
S     #define UART_2_EXT_UART_BTLDR_COMM_ENABLED   (0u)
N#endif /* (UART_2_EXT_UART_BTLDR_COMM_ENABLED) */
N
N/* Enable bootloader communication */
N#define UART_2_EXT_BTLDR_COMM_MODE_ENABLED    (UART_2_EXT_I2C_BTLDR_COMM_ENABLED   || \
N                                                     UART_2_EXT_SPI_BTLDR_COMM_ENABLED   || \
N                                                     UART_2_EXT_EZI2C_BTLDR_COMM_ENABLED || \
N                                                     UART_2_EXT_UART_BTLDR_COMM_ENABLED)
X#define UART_2_EXT_BTLDR_COMM_MODE_ENABLED    (UART_2_EXT_I2C_BTLDR_COMM_ENABLED   ||                                                      UART_2_EXT_SPI_BTLDR_COMM_ENABLED   ||                                                      UART_2_EXT_EZI2C_BTLDR_COMM_ENABLED ||                                                      UART_2_EXT_UART_BTLDR_COMM_ENABLED)
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_2_EXT_I2C_BTLDR_COMM_ENABLED)
X#if 0L && ((0u))
S    /* I2C Bootloader physical layer functions */
S    void UART_2_EXT_I2CCyBtldrCommStart(void);
S    void UART_2_EXT_I2CCyBtldrCommStop (void);
S    void UART_2_EXT_I2CCyBtldrCommReset(void);
S    cystatus UART_2_EXT_I2CCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus UART_2_EXT_I2CCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    /* Map I2C specific bootloader communication APIs to SCB specific APIs */
S    #if (UART_2_EXT_SCB_MODE_I2C_CONST_CFG)
S        #define UART_2_EXT_CyBtldrCommStart   UART_2_EXT_I2CCyBtldrCommStart
S        #define UART_2_EXT_CyBtldrCommStop    UART_2_EXT_I2CCyBtldrCommStop
S        #define UART_2_EXT_CyBtldrCommReset   UART_2_EXT_I2CCyBtldrCommReset
S        #define UART_2_EXT_CyBtldrCommRead    UART_2_EXT_I2CCyBtldrCommRead
S        #define UART_2_EXT_CyBtldrCommWrite   UART_2_EXT_I2CCyBtldrCommWrite
S    #endif /* (UART_2_EXT_SCB_MODE_I2C_CONST_CFG) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_2_EXT_I2C_BTLDR_COMM_ENABLED) */
N
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_2_EXT_EZI2C_BTLDR_COMM_ENABLED)
X#if 0L && ((0u))
S    /* Bootloader physical layer functions */
S    void UART_2_EXT_EzI2CCyBtldrCommStart(void);
S    void UART_2_EXT_EzI2CCyBtldrCommStop (void);
S    void UART_2_EXT_EzI2CCyBtldrCommReset(void);
S    cystatus UART_2_EXT_EzI2CCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus UART_2_EXT_EzI2CCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    /* Map EZI2C specific bootloader communication APIs to SCB specific APIs */
S    #if (UART_2_EXT_SCB_MODE_EZI2C_CONST_CFG)
S        #define UART_2_EXT_CyBtldrCommStart   UART_2_EXT_EzI2CCyBtldrCommStart
S        #define UART_2_EXT_CyBtldrCommStop    UART_2_EXT_EzI2CCyBtldrCommStop
S        #define UART_2_EXT_CyBtldrCommReset   UART_2_EXT_EzI2CCyBtldrCommReset
S        #define UART_2_EXT_CyBtldrCommRead    UART_2_EXT_EzI2CCyBtldrCommRead
S        #define UART_2_EXT_CyBtldrCommWrite   UART_2_EXT_EzI2CCyBtldrCommWrite
S    #endif /* (UART_2_EXT_SCB_MODE_EZI2C_CONST_CFG) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_2_EXT_EZI2C_BTLDR_COMM_ENABLED) */
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_2_EXT_SPI_BTLDR_COMM_ENABLED)
X#if 0L && ((0u))
S    /* SPI Bootloader physical layer functions */
S    void UART_2_EXT_SpiCyBtldrCommStart(void);
S    void UART_2_EXT_SpiCyBtldrCommStop (void);
S    void UART_2_EXT_SpiCyBtldrCommReset(void);
S    cystatus UART_2_EXT_SpiCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus UART_2_EXT_SpiCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    /* Map SPI specific bootloader communication APIs to SCB specific APIs */
S    #if (UART_2_EXT_SCB_MODE_SPI_CONST_CFG)
S        #define UART_2_EXT_CyBtldrCommStart   UART_2_EXT_SpiCyBtldrCommStart
S        #define UART_2_EXT_CyBtldrCommStop    UART_2_EXT_SpiCyBtldrCommStop
S        #define UART_2_EXT_CyBtldrCommReset   UART_2_EXT_SpiCyBtldrCommReset
S        #define UART_2_EXT_CyBtldrCommRead    UART_2_EXT_SpiCyBtldrCommRead
S        #define UART_2_EXT_CyBtldrCommWrite   UART_2_EXT_SpiCyBtldrCommWrite
S    #endif /* (UART_2_EXT_SCB_MODE_SPI_CONST_CFG) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_2_EXT_SPI_BTLDR_COMM_ENABLED) */
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_2_EXT_UART_BTLDR_COMM_ENABLED)
X#if 0L && ((((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_2_EXT) || (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface)) && (((0xFFu) == (4u)) || ((0u != ((3u) & (1u))) && (0u != ((3u) & (2u)))))))
S    /* UART Bootloader physical layer functions */
S    void UART_2_EXT_UartCyBtldrCommStart(void);
S    void UART_2_EXT_UartCyBtldrCommStop (void);
S    void UART_2_EXT_UartCyBtldrCommReset(void);
S    cystatus UART_2_EXT_UartCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus UART_2_EXT_UartCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    /* Map UART specific bootloader communication APIs to SCB specific APIs */
S    #if (UART_2_EXT_SCB_MODE_UART_CONST_CFG)
S        #define UART_2_EXT_CyBtldrCommStart   UART_2_EXT_UartCyBtldrCommStart
S        #define UART_2_EXT_CyBtldrCommStop    UART_2_EXT_UartCyBtldrCommStop
S        #define UART_2_EXT_CyBtldrCommReset   UART_2_EXT_UartCyBtldrCommReset
S        #define UART_2_EXT_CyBtldrCommRead    UART_2_EXT_UartCyBtldrCommRead
S        #define UART_2_EXT_CyBtldrCommWrite   UART_2_EXT_UartCyBtldrCommWrite
S    #endif /* (UART_2_EXT_SCB_MODE_UART_CONST_CFG) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_2_EXT_UART_BTLDR_COMM_ENABLED) */
N
N/**
N* \addtogroup group_bootloader
N* @{
N*/
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_2_EXT_BTLDR_COMM_ENABLED)
X#if 0L && (((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_2_EXT) || (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface)))
S    #if (UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG)
S        /* Bootloader physical layer functions */
S        void UART_2_EXT_CyBtldrCommStart(void);
S        void UART_2_EXT_CyBtldrCommStop (void);
S        void UART_2_EXT_CyBtldrCommReset(void);
S        cystatus UART_2_EXT_CyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S        cystatus UART_2_EXT_CyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    #endif /* (UART_2_EXT_SCB_MODE_UNCONFIG_CONST_CFG) */
S
S    /* Map SCB specific bootloader communication APIs to common APIs */
S    #if (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_2_EXT)
S        #define CyBtldrCommStart    UART_2_EXT_CyBtldrCommStart
S        #define CyBtldrCommStop     UART_2_EXT_CyBtldrCommStop
S        #define CyBtldrCommReset    UART_2_EXT_CyBtldrCommReset
S        #define CyBtldrCommWrite    UART_2_EXT_CyBtldrCommWrite
S        #define CyBtldrCommRead     UART_2_EXT_CyBtldrCommRead
S    #endif /* (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_2_EXT) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_2_EXT_BTLDR_COMM_ENABLED) */
N
N/** @} group_bootloader */
N
N/***************************************
N*           API Constants
N***************************************/
N
N/* Timeout unit in milliseconds */
N#define UART_2_EXT_WAIT_1_MS  (1u)
N
N/* Return number of bytes to copy into bootloader buffer */
N#define UART_2_EXT_BYTES_TO_COPY(actBufSize, bufSize) \
N                            ( ((uint32)(actBufSize) < (uint32)(bufSize)) ? \
N                                ((uint32) (actBufSize)) : ((uint32) (bufSize)) )
X#define UART_2_EXT_BYTES_TO_COPY(actBufSize, bufSize)                             ( ((uint32)(actBufSize) < (uint32)(bufSize)) ?                                 ((uint32) (actBufSize)) : ((uint32) (bufSize)) )
N
N/* Size of Read/Write buffers for I2C bootloader  */
N#define UART_2_EXT_I2C_BTLDR_SIZEOF_READ_BUFFER   (64u)
N#define UART_2_EXT_I2C_BTLDR_SIZEOF_WRITE_BUFFER  (64u)
N
N/* Byte to byte time interval: calculated basing on current component
N* data rate configuration, can be defined in project if required.
N*/
N#ifndef UART_2_EXT_SPI_BYTE_TO_BYTE
N    #define UART_2_EXT_SPI_BYTE_TO_BYTE   (160u)
N#endif
N
N/* Byte to byte time interval: calculated basing on current component
N* baud rate configuration, can be defined in the project if required.
N*/
N#ifndef UART_2_EXT_UART_BYTE_TO_BYTE
N    #define UART_2_EXT_UART_BYTE_TO_BYTE  (175u)
N#endif /* UART_2_EXT_UART_BYTE_TO_BYTE */
N
N#endif /* (CY_SCB_BOOT_UART_2_EXT_H) */
N
N
N/* [] END OF FILE */
L 39 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH.h" 1
N/***************************************************************************//**
N* \file SPI_0_OLED_FLASH.h
N* \version 4.0
N*
N* \brief
N*  This file provides constants and parameter values for the SCB Component.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_SPI_0_OLED_FLASH_H)
X#if !0L
N#define CY_SCB_SPI_0_OLED_FLASH_H
N
N#include <cydevice_trm.h>
N#include <cyfitter.h>
N#include <cytypes.h>
N#include <CyLib.h>
N
N/* SCB IP block v0 is available in PSoC 4100/PSoC 4200 */
N#define SPI_0_OLED_FLASH_CY_SCBIP_V0    (CYIPBLOCK_m0s8scb_VERSION == 0u)
N/* SCB IP block v1 is available in PSoC 4000 */
N#define SPI_0_OLED_FLASH_CY_SCBIP_V1    (CYIPBLOCK_m0s8scb_VERSION == 1u)
N/* SCB IP block v2 is available in all other devices */
N#define SPI_0_OLED_FLASH_CY_SCBIP_V2    (CYIPBLOCK_m0s8scb_VERSION >= 2u)
N
N/** Component version major.minor */
N#define SPI_0_OLED_FLASH_COMP_VERSION_MAJOR    (4)
N#define SPI_0_OLED_FLASH_COMP_VERSION_MINOR    (0)
N    
N#define SPI_0_OLED_FLASH_SCB_MODE           (2u)
N
N/* SCB modes enum */
N#define SPI_0_OLED_FLASH_SCB_MODE_I2C       (0x01u)
N#define SPI_0_OLED_FLASH_SCB_MODE_SPI       (0x02u)
N#define SPI_0_OLED_FLASH_SCB_MODE_UART      (0x04u)
N#define SPI_0_OLED_FLASH_SCB_MODE_EZI2C     (0x08u)
N#define SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG  (0xFFu)
N
N/* Condition compilation depends on operation mode: Unconfigured implies apply to all modes */
N#define SPI_0_OLED_FLASH_SCB_MODE_I2C_CONST_CFG       (SPI_0_OLED_FLASH_SCB_MODE_I2C       == SPI_0_OLED_FLASH_SCB_MODE)
N#define SPI_0_OLED_FLASH_SCB_MODE_SPI_CONST_CFG       (SPI_0_OLED_FLASH_SCB_MODE_SPI       == SPI_0_OLED_FLASH_SCB_MODE)
N#define SPI_0_OLED_FLASH_SCB_MODE_UART_CONST_CFG      (SPI_0_OLED_FLASH_SCB_MODE_UART      == SPI_0_OLED_FLASH_SCB_MODE)
N#define SPI_0_OLED_FLASH_SCB_MODE_EZI2C_CONST_CFG     (SPI_0_OLED_FLASH_SCB_MODE_EZI2C     == SPI_0_OLED_FLASH_SCB_MODE)
N#define SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG  (SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG  == SPI_0_OLED_FLASH_SCB_MODE)
N
N/* Condition compilation for includes */
N#define SPI_0_OLED_FLASH_SCB_MODE_I2C_INC      (0u !=(SPI_0_OLED_FLASH_SCB_MODE_I2C   & SPI_0_OLED_FLASH_SCB_MODE))
N#define SPI_0_OLED_FLASH_SCB_MODE_EZI2C_INC    (0u !=(SPI_0_OLED_FLASH_SCB_MODE_EZI2C & SPI_0_OLED_FLASH_SCB_MODE))
N#if (!SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_0_OLED_FLASH_SCB_MODE_SPI_INC  (0u !=(SPI_0_OLED_FLASH_SCB_MODE_SPI   & SPI_0_OLED_FLASH_SCB_MODE))
N    #define SPI_0_OLED_FLASH_SCB_MODE_UART_INC (0u !=(SPI_0_OLED_FLASH_SCB_MODE_UART  & SPI_0_OLED_FLASH_SCB_MODE))
N#else
S    #define SPI_0_OLED_FLASH_SCB_MODE_SPI_INC  (0u)
S    #define SPI_0_OLED_FLASH_SCB_MODE_UART_INC (0u)
N#endif /* (!SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N
N/* Interrupts remove options */
N#define SPI_0_OLED_FLASH_REMOVE_SCB_IRQ             (1u)
N#define SPI_0_OLED_FLASH_SCB_IRQ_INTERNAL           (0u == SPI_0_OLED_FLASH_REMOVE_SCB_IRQ)
N
N#define SPI_0_OLED_FLASH_REMOVE_UART_RX_WAKEUP_IRQ  (1u)
N#define SPI_0_OLED_FLASH_UART_RX_WAKEUP_IRQ         (0u == SPI_0_OLED_FLASH_REMOVE_UART_RX_WAKEUP_IRQ)
N
N/* SCB interrupt enum */
N#define SPI_0_OLED_FLASH_SCB_INTR_MODE_NONE     (0u)
N#define SPI_0_OLED_FLASH_SCB_INTR_MODE_INTERNAL (1u)
N#define SPI_0_OLED_FLASH_SCB_INTR_MODE_EXTERNAL (2u)
N
N/* Internal clock remove option */
N#define SPI_0_OLED_FLASH_REMOVE_SCB_CLK     (0u)
N#define SPI_0_OLED_FLASH_SCB_CLK_INTERNAL   (0u == SPI_0_OLED_FLASH_REMOVE_SCB_CLK)
N
N
N/***************************************
N*       Includes
N****************************************/
N
N#include "SPI_0_OLED_FLASH_PINS.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_PINS.h" 1
N/***************************************************************************//**
N* \file SPI_0_OLED_FLASH_PINS.h
N* \version 4.0
N*
N* \brief
N*  This file provides constants and parameter values for the pin components
N*  buried into SCB Component.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_PINS_SPI_0_OLED_FLASH_H)
X#if !0L
N#define CY_SCB_PINS_SPI_0_OLED_FLASH_H
N
N#include "cydevice_trm.h"
N#include "cyfitter.h"
N#include "cytypes.h"
N
N
N/***************************************
N*   Conditional Compilation Parameters
N****************************************/
N
N/* Unconfigured pins */
N#define SPI_0_OLED_FLASH_REMOVE_RX_WAKE_SCL_MOSI_PIN  (1u)
N#define SPI_0_OLED_FLASH_REMOVE_RX_SCL_MOSI_PIN      (1u)
N#define SPI_0_OLED_FLASH_REMOVE_TX_SDA_MISO_PIN      (1u)
N#define SPI_0_OLED_FLASH_REMOVE_CTS_SCLK_PIN      (1u)
N#define SPI_0_OLED_FLASH_REMOVE_RTS_SS0_PIN      (1u)
N#define SPI_0_OLED_FLASH_REMOVE_SS1_PIN                 (1u)
N#define SPI_0_OLED_FLASH_REMOVE_SS2_PIN                 (1u)
N#define SPI_0_OLED_FLASH_REMOVE_SS3_PIN                 (1u)
N
N/* Mode defined pins */
N#define SPI_0_OLED_FLASH_REMOVE_I2C_PINS                (1u)
N#define SPI_0_OLED_FLASH_REMOVE_SPI_MASTER_PINS         (0u)
N#define SPI_0_OLED_FLASH_REMOVE_SPI_MASTER_SCLK_PIN     (0u)
N#define SPI_0_OLED_FLASH_REMOVE_SPI_MASTER_MOSI_PIN     (0u)
N#define SPI_0_OLED_FLASH_REMOVE_SPI_MASTER_MISO_PIN     (0u)
N#define SPI_0_OLED_FLASH_REMOVE_SPI_MASTER_SS0_PIN      (0u)
N#define SPI_0_OLED_FLASH_REMOVE_SPI_MASTER_SS1_PIN      (0u)
N#define SPI_0_OLED_FLASH_REMOVE_SPI_MASTER_SS2_PIN      (1u)
N#define SPI_0_OLED_FLASH_REMOVE_SPI_MASTER_SS3_PIN      (1u)
N#define SPI_0_OLED_FLASH_REMOVE_SPI_SLAVE_PINS          (1u)
N#define SPI_0_OLED_FLASH_REMOVE_SPI_SLAVE_MOSI_PIN      (1u)
N#define SPI_0_OLED_FLASH_REMOVE_SPI_SLAVE_MISO_PIN      (1u)
N#define SPI_0_OLED_FLASH_REMOVE_UART_TX_PIN             (1u)
N#define SPI_0_OLED_FLASH_REMOVE_UART_RX_TX_PIN          (1u)
N#define SPI_0_OLED_FLASH_REMOVE_UART_RX_PIN             (1u)
N#define SPI_0_OLED_FLASH_REMOVE_UART_RX_WAKE_PIN        (1u)
N#define SPI_0_OLED_FLASH_REMOVE_UART_RTS_PIN            (1u)
N#define SPI_0_OLED_FLASH_REMOVE_UART_CTS_PIN            (1u)
N
N/* Unconfigured pins */
N#define SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_PIN (0u == SPI_0_OLED_FLASH_REMOVE_RX_WAKE_SCL_MOSI_PIN)
N#define SPI_0_OLED_FLASH_RX_SCL_MOSI_PIN     (0u == SPI_0_OLED_FLASH_REMOVE_RX_SCL_MOSI_PIN)
N#define SPI_0_OLED_FLASH_TX_SDA_MISO_PIN     (0u == SPI_0_OLED_FLASH_REMOVE_TX_SDA_MISO_PIN)
N#define SPI_0_OLED_FLASH_CTS_SCLK_PIN     (0u == SPI_0_OLED_FLASH_REMOVE_CTS_SCLK_PIN)
N#define SPI_0_OLED_FLASH_RTS_SS0_PIN     (0u == SPI_0_OLED_FLASH_REMOVE_RTS_SS0_PIN)
N#define SPI_0_OLED_FLASH_SS1_PIN                (0u == SPI_0_OLED_FLASH_REMOVE_SS1_PIN)
N#define SPI_0_OLED_FLASH_SS2_PIN                (0u == SPI_0_OLED_FLASH_REMOVE_SS2_PIN)
N#define SPI_0_OLED_FLASH_SS3_PIN                (0u == SPI_0_OLED_FLASH_REMOVE_SS3_PIN)
N
N/* Mode defined pins */
N#define SPI_0_OLED_FLASH_I2C_PINS               (0u == SPI_0_OLED_FLASH_REMOVE_I2C_PINS)
N#define SPI_0_OLED_FLASH_SPI_MASTER_PINS        (0u == SPI_0_OLED_FLASH_REMOVE_SPI_MASTER_PINS)
N#define SPI_0_OLED_FLASH_SPI_MASTER_SCLK_PIN    (0u == SPI_0_OLED_FLASH_REMOVE_SPI_MASTER_SCLK_PIN)
N#define SPI_0_OLED_FLASH_SPI_MASTER_MOSI_PIN    (0u == SPI_0_OLED_FLASH_REMOVE_SPI_MASTER_MOSI_PIN)
N#define SPI_0_OLED_FLASH_SPI_MASTER_MISO_PIN    (0u == SPI_0_OLED_FLASH_REMOVE_SPI_MASTER_MISO_PIN)
N#define SPI_0_OLED_FLASH_SPI_MASTER_SS0_PIN     (0u == SPI_0_OLED_FLASH_REMOVE_SPI_MASTER_SS0_PIN)
N#define SPI_0_OLED_FLASH_SPI_MASTER_SS1_PIN     (0u == SPI_0_OLED_FLASH_REMOVE_SPI_MASTER_SS1_PIN)
N#define SPI_0_OLED_FLASH_SPI_MASTER_SS2_PIN     (0u == SPI_0_OLED_FLASH_REMOVE_SPI_MASTER_SS2_PIN)
N#define SPI_0_OLED_FLASH_SPI_MASTER_SS3_PIN     (0u == SPI_0_OLED_FLASH_REMOVE_SPI_MASTER_SS3_PIN)
N#define SPI_0_OLED_FLASH_SPI_SLAVE_PINS         (0u == SPI_0_OLED_FLASH_REMOVE_SPI_SLAVE_PINS)
N#define SPI_0_OLED_FLASH_SPI_SLAVE_MOSI_PIN     (0u == SPI_0_OLED_FLASH_REMOVE_SPI_SLAVE_MOSI_PIN)
N#define SPI_0_OLED_FLASH_SPI_SLAVE_MISO_PIN     (0u == SPI_0_OLED_FLASH_REMOVE_SPI_SLAVE_MISO_PIN)
N#define SPI_0_OLED_FLASH_UART_TX_PIN            (0u == SPI_0_OLED_FLASH_REMOVE_UART_TX_PIN)
N#define SPI_0_OLED_FLASH_UART_RX_TX_PIN         (0u == SPI_0_OLED_FLASH_REMOVE_UART_RX_TX_PIN)
N#define SPI_0_OLED_FLASH_UART_RX_PIN            (0u == SPI_0_OLED_FLASH_REMOVE_UART_RX_PIN)
N#define SPI_0_OLED_FLASH_UART_RX_WAKE_PIN       (0u == SPI_0_OLED_FLASH_REMOVE_UART_RX_WAKE_PIN)
N#define SPI_0_OLED_FLASH_UART_RTS_PIN           (0u == SPI_0_OLED_FLASH_REMOVE_UART_RTS_PIN)
N#define SPI_0_OLED_FLASH_UART_CTS_PIN           (0u == SPI_0_OLED_FLASH_REMOVE_UART_CTS_PIN)
N
N
N/***************************************
N*             Includes
N****************************************/
N
N#if (SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_PIN)
X#if ((0u == (1u)))
S    #include "SPI_0_OLED_FLASH_uart_rx_wake_i2c_scl_spi_mosi.h"
N#endif /* (SPI_0_OLED_FLASH_RX_SCL_MOSI) */
N
N#if (SPI_0_OLED_FLASH_RX_SCL_MOSI_PIN)
X#if ((0u == (1u)))
S    #include "SPI_0_OLED_FLASH_uart_rx_i2c_scl_spi_mosi.h"
N#endif /* (SPI_0_OLED_FLASH_RX_SCL_MOSI) */
N
N#if (SPI_0_OLED_FLASH_TX_SDA_MISO_PIN)
X#if ((0u == (1u)))
S    #include "SPI_0_OLED_FLASH_uart_tx_i2c_sda_spi_miso.h"
N#endif /* (SPI_0_OLED_FLASH_TX_SDA_MISO) */
N
N#if (SPI_0_OLED_FLASH_CTS_SCLK_PIN)
X#if ((0u == (1u)))
S    #include "SPI_0_OLED_FLASH_uart_cts_spi_sclk.h"
N#endif /* (SPI_0_OLED_FLASH_CTS_SCLK) */
N
N#if (SPI_0_OLED_FLASH_RTS_SS0_PIN)
X#if ((0u == (1u)))
S    #include "SPI_0_OLED_FLASH_uart_rts_spi_ss0.h"
N#endif /* (SPI_0_OLED_FLASH_RTS_SS0_PIN) */
N
N#if (SPI_0_OLED_FLASH_SS1_PIN)
X#if ((0u == (1u)))
S    #include "SPI_0_OLED_FLASH_spi_ss1.h"
N#endif /* (SPI_0_OLED_FLASH_SS1_PIN) */
N
N#if (SPI_0_OLED_FLASH_SS2_PIN)
X#if ((0u == (1u)))
S    #include "SPI_0_OLED_FLASH_spi_ss2.h"
N#endif /* (SPI_0_OLED_FLASH_SS2_PIN) */
N
N#if (SPI_0_OLED_FLASH_SS3_PIN)
X#if ((0u == (1u)))
S    #include "SPI_0_OLED_FLASH_spi_ss3.h"
N#endif /* (SPI_0_OLED_FLASH_SS3_PIN) */
N
N#if (SPI_0_OLED_FLASH_I2C_PINS)
X#if ((0u == (1u)))
S    #include "SPI_0_OLED_FLASH_scl.h"
S    #include "SPI_0_OLED_FLASH_sda.h"
N#endif /* (SPI_0_OLED_FLASH_I2C_PINS) */
N
N#if (SPI_0_OLED_FLASH_SPI_MASTER_PINS)
X#if ((0u == (0u)))
N#if (SPI_0_OLED_FLASH_SPI_MASTER_SCLK_PIN)
X#if ((0u == (0u)))
N    #include "SPI_0_OLED_FLASH_sclk_m.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_sclk_m.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_sclk_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_sclk_m_H) /* Pins SPI_0_OLED_FLASH_sclk_m_H */
X#if !0L  
N#define CY_PINS_SPI_0_OLED_FLASH_sclk_m_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "SPI_0_OLED_FLASH_sclk_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_sclk_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_sclk_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_sclk_m_ALIASES_H) /* Pins SPI_0_OLED_FLASH_sclk_m_ALIASES_H */
X#if !0L  
N#define CY_PINS_SPI_0_OLED_FLASH_sclk_m_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define SPI_0_OLED_FLASH_sclk_m_0			(SPI_0_OLED_FLASH_sclk_m__0__PC)
N#define SPI_0_OLED_FLASH_sclk_m_0_PS		(SPI_0_OLED_FLASH_sclk_m__0__PS)
N#define SPI_0_OLED_FLASH_sclk_m_0_PC		(SPI_0_OLED_FLASH_sclk_m__0__PC)
N#define SPI_0_OLED_FLASH_sclk_m_0_DR		(SPI_0_OLED_FLASH_sclk_m__0__DR)
N#define SPI_0_OLED_FLASH_sclk_m_0_SHIFT	(SPI_0_OLED_FLASH_sclk_m__0__SHIFT)
N#define SPI_0_OLED_FLASH_sclk_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_0_OLED_FLASH_sclk_m__0__SHIFT*2u)))
N
N#define SPI_0_OLED_FLASH_sclk_m_INTR_ALL	 ((uint16)(SPI_0_OLED_FLASH_sclk_m_0_INTR))
N
N
N#endif /* End Pins SPI_0_OLED_FLASH_sclk_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_sclk_m.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} SPI_0_OLED_FLASH_sclk_m_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   SPI_0_OLED_FLASH_sclk_m_Read(void);
Nvoid    SPI_0_OLED_FLASH_sclk_m_Write(uint8 value);
Nuint8   SPI_0_OLED_FLASH_sclk_m_ReadDataReg(void);
N#if defined(SPI_0_OLED_FLASH_sclk_m__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    SPI_0_OLED_FLASH_sclk_m_SetDriveMode(uint8 mode);
N#endif
Nvoid    SPI_0_OLED_FLASH_sclk_m_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   SPI_0_OLED_FLASH_sclk_m_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid SPI_0_OLED_FLASH_sclk_m_Sleep(void); 
Nvoid SPI_0_OLED_FLASH_sclk_m_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(SPI_0_OLED_FLASH_sclk_m__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define SPI_0_OLED_FLASH_sclk_m_DRIVE_MODE_BITS        (3)
N    #define SPI_0_OLED_FLASH_sclk_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_0_OLED_FLASH_sclk_m_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the SPI_0_OLED_FLASH_sclk_m_SetDriveMode() function.
N         *  @{
N         */
N        #define SPI_0_OLED_FLASH_sclk_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define SPI_0_OLED_FLASH_sclk_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define SPI_0_OLED_FLASH_sclk_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define SPI_0_OLED_FLASH_sclk_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define SPI_0_OLED_FLASH_sclk_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define SPI_0_OLED_FLASH_sclk_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define SPI_0_OLED_FLASH_sclk_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define SPI_0_OLED_FLASH_sclk_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define SPI_0_OLED_FLASH_sclk_m_MASK               SPI_0_OLED_FLASH_sclk_m__MASK
N#define SPI_0_OLED_FLASH_sclk_m_SHIFT              SPI_0_OLED_FLASH_sclk_m__SHIFT
N#define SPI_0_OLED_FLASH_sclk_m_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in SPI_0_OLED_FLASH_sclk_m_SetInterruptMode() function.
N     *  @{
N     */
N        #define SPI_0_OLED_FLASH_sclk_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define SPI_0_OLED_FLASH_sclk_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define SPI_0_OLED_FLASH_sclk_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define SPI_0_OLED_FLASH_sclk_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(SPI_0_OLED_FLASH_sclk_m__SIO)
X#if 0L
S    #define SPI_0_OLED_FLASH_sclk_m_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(SPI_0_OLED_FLASH_sclk_m__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_DISABLE              ((uint32)(~SPI_0_OLED_FLASH_sclk_m_USBIO_ENABLE))
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_0_OLED_FLASH_sclk_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(SPI_0_OLED_FLASH_sclk_m__PC)
X#if 1L
N    /* Port Configuration */
N    #define SPI_0_OLED_FLASH_sclk_m_PC                 (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__PC)
N#endif
N/* Pin State */
N#define SPI_0_OLED_FLASH_sclk_m_PS                     (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__PS)
N/* Data Register */
N#define SPI_0_OLED_FLASH_sclk_m_DR                     (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__DR)
N/* Input Buffer Disable Override */
N#define SPI_0_OLED_FLASH_sclk_m_INP_DIS                (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__PC2)
N
N/* Interrupt configuration Registers */
N#define SPI_0_OLED_FLASH_sclk_m_INTCFG                 (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__INTCFG)
N#define SPI_0_OLED_FLASH_sclk_m_INTSTAT                (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define SPI_0_OLED_FLASH_sclk_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(SPI_0_OLED_FLASH_sclk_m__SIO)
X#if 0L
S    #define SPI_0_OLED_FLASH_sclk_m_SIO_REG            (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__SIO)
N#endif /* (SPI_0_OLED_FLASH_sclk_m__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(SPI_0_OLED_FLASH_sclk_m__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define SPI_0_OLED_FLASH_sclk_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_0_OLED_FLASH_sclk_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define SPI_0_OLED_FLASH_sclk_m_DRIVE_MODE_SHIFT       (0x00u)
N#define SPI_0_OLED_FLASH_sclk_m_DRIVE_MODE_MASK        (0x07u << SPI_0_OLED_FLASH_sclk_m_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins SPI_0_OLED_FLASH_sclk_m_H */
N
N
N/* [] END OF FILE */
L 136 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_PINS.h" 2
N#endif /* (SPI_0_OLED_FLASH_SPI_MASTER_SCLK_PIN) */
N
N#if (SPI_0_OLED_FLASH_SPI_MASTER_MOSI_PIN)
X#if ((0u == (0u)))
N    #include "SPI_0_OLED_FLASH_mosi_m.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_mosi_m.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_mosi_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_mosi_m_H) /* Pins SPI_0_OLED_FLASH_mosi_m_H */
X#if !0L  
N#define CY_PINS_SPI_0_OLED_FLASH_mosi_m_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "SPI_0_OLED_FLASH_mosi_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_mosi_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_mosi_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_mosi_m_ALIASES_H) /* Pins SPI_0_OLED_FLASH_mosi_m_ALIASES_H */
X#if !0L  
N#define CY_PINS_SPI_0_OLED_FLASH_mosi_m_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define SPI_0_OLED_FLASH_mosi_m_0			(SPI_0_OLED_FLASH_mosi_m__0__PC)
N#define SPI_0_OLED_FLASH_mosi_m_0_PS		(SPI_0_OLED_FLASH_mosi_m__0__PS)
N#define SPI_0_OLED_FLASH_mosi_m_0_PC		(SPI_0_OLED_FLASH_mosi_m__0__PC)
N#define SPI_0_OLED_FLASH_mosi_m_0_DR		(SPI_0_OLED_FLASH_mosi_m__0__DR)
N#define SPI_0_OLED_FLASH_mosi_m_0_SHIFT	(SPI_0_OLED_FLASH_mosi_m__0__SHIFT)
N#define SPI_0_OLED_FLASH_mosi_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_0_OLED_FLASH_mosi_m__0__SHIFT*2u)))
N
N#define SPI_0_OLED_FLASH_mosi_m_INTR_ALL	 ((uint16)(SPI_0_OLED_FLASH_mosi_m_0_INTR))
N
N
N#endif /* End Pins SPI_0_OLED_FLASH_mosi_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_mosi_m.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} SPI_0_OLED_FLASH_mosi_m_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   SPI_0_OLED_FLASH_mosi_m_Read(void);
Nvoid    SPI_0_OLED_FLASH_mosi_m_Write(uint8 value);
Nuint8   SPI_0_OLED_FLASH_mosi_m_ReadDataReg(void);
N#if defined(SPI_0_OLED_FLASH_mosi_m__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    SPI_0_OLED_FLASH_mosi_m_SetDriveMode(uint8 mode);
N#endif
Nvoid    SPI_0_OLED_FLASH_mosi_m_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   SPI_0_OLED_FLASH_mosi_m_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid SPI_0_OLED_FLASH_mosi_m_Sleep(void); 
Nvoid SPI_0_OLED_FLASH_mosi_m_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(SPI_0_OLED_FLASH_mosi_m__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define SPI_0_OLED_FLASH_mosi_m_DRIVE_MODE_BITS        (3)
N    #define SPI_0_OLED_FLASH_mosi_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_0_OLED_FLASH_mosi_m_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the SPI_0_OLED_FLASH_mosi_m_SetDriveMode() function.
N         *  @{
N         */
N        #define SPI_0_OLED_FLASH_mosi_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define SPI_0_OLED_FLASH_mosi_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define SPI_0_OLED_FLASH_mosi_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define SPI_0_OLED_FLASH_mosi_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define SPI_0_OLED_FLASH_mosi_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define SPI_0_OLED_FLASH_mosi_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define SPI_0_OLED_FLASH_mosi_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define SPI_0_OLED_FLASH_mosi_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define SPI_0_OLED_FLASH_mosi_m_MASK               SPI_0_OLED_FLASH_mosi_m__MASK
N#define SPI_0_OLED_FLASH_mosi_m_SHIFT              SPI_0_OLED_FLASH_mosi_m__SHIFT
N#define SPI_0_OLED_FLASH_mosi_m_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in SPI_0_OLED_FLASH_mosi_m_SetInterruptMode() function.
N     *  @{
N     */
N        #define SPI_0_OLED_FLASH_mosi_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define SPI_0_OLED_FLASH_mosi_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define SPI_0_OLED_FLASH_mosi_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define SPI_0_OLED_FLASH_mosi_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(SPI_0_OLED_FLASH_mosi_m__SIO)
X#if 0L
S    #define SPI_0_OLED_FLASH_mosi_m_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(SPI_0_OLED_FLASH_mosi_m__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_DISABLE              ((uint32)(~SPI_0_OLED_FLASH_mosi_m_USBIO_ENABLE))
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_0_OLED_FLASH_mosi_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(SPI_0_OLED_FLASH_mosi_m__PC)
X#if 1L
N    /* Port Configuration */
N    #define SPI_0_OLED_FLASH_mosi_m_PC                 (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__PC)
N#endif
N/* Pin State */
N#define SPI_0_OLED_FLASH_mosi_m_PS                     (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__PS)
N/* Data Register */
N#define SPI_0_OLED_FLASH_mosi_m_DR                     (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__DR)
N/* Input Buffer Disable Override */
N#define SPI_0_OLED_FLASH_mosi_m_INP_DIS                (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__PC2)
N
N/* Interrupt configuration Registers */
N#define SPI_0_OLED_FLASH_mosi_m_INTCFG                 (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__INTCFG)
N#define SPI_0_OLED_FLASH_mosi_m_INTSTAT                (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define SPI_0_OLED_FLASH_mosi_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(SPI_0_OLED_FLASH_mosi_m__SIO)
X#if 0L
S    #define SPI_0_OLED_FLASH_mosi_m_SIO_REG            (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__SIO)
N#endif /* (SPI_0_OLED_FLASH_mosi_m__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(SPI_0_OLED_FLASH_mosi_m__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define SPI_0_OLED_FLASH_mosi_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_0_OLED_FLASH_mosi_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define SPI_0_OLED_FLASH_mosi_m_DRIVE_MODE_SHIFT       (0x00u)
N#define SPI_0_OLED_FLASH_mosi_m_DRIVE_MODE_MASK        (0x07u << SPI_0_OLED_FLASH_mosi_m_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins SPI_0_OLED_FLASH_mosi_m_H */
N
N
N/* [] END OF FILE */
L 140 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_PINS.h" 2
N#endif /* (SPI_0_OLED_FLASH_SPI_MASTER_MOSI_PIN) */
N
N#if (SPI_0_OLED_FLASH_SPI_MASTER_MISO_PIN)
X#if ((0u == (0u)))
N    #include "SPI_0_OLED_FLASH_miso_m.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_miso_m.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_miso_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_miso_m_H) /* Pins SPI_0_OLED_FLASH_miso_m_H */
X#if !0L  
N#define CY_PINS_SPI_0_OLED_FLASH_miso_m_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "SPI_0_OLED_FLASH_miso_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_miso_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_miso_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_miso_m_ALIASES_H) /* Pins SPI_0_OLED_FLASH_miso_m_ALIASES_H */
X#if !0L  
N#define CY_PINS_SPI_0_OLED_FLASH_miso_m_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define SPI_0_OLED_FLASH_miso_m_0			(SPI_0_OLED_FLASH_miso_m__0__PC)
N#define SPI_0_OLED_FLASH_miso_m_0_PS		(SPI_0_OLED_FLASH_miso_m__0__PS)
N#define SPI_0_OLED_FLASH_miso_m_0_PC		(SPI_0_OLED_FLASH_miso_m__0__PC)
N#define SPI_0_OLED_FLASH_miso_m_0_DR		(SPI_0_OLED_FLASH_miso_m__0__DR)
N#define SPI_0_OLED_FLASH_miso_m_0_SHIFT	(SPI_0_OLED_FLASH_miso_m__0__SHIFT)
N#define SPI_0_OLED_FLASH_miso_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_0_OLED_FLASH_miso_m__0__SHIFT*2u)))
N
N#define SPI_0_OLED_FLASH_miso_m_INTR_ALL	 ((uint16)(SPI_0_OLED_FLASH_miso_m_0_INTR))
N
N
N#endif /* End Pins SPI_0_OLED_FLASH_miso_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_miso_m.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} SPI_0_OLED_FLASH_miso_m_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   SPI_0_OLED_FLASH_miso_m_Read(void);
Nvoid    SPI_0_OLED_FLASH_miso_m_Write(uint8 value);
Nuint8   SPI_0_OLED_FLASH_miso_m_ReadDataReg(void);
N#if defined(SPI_0_OLED_FLASH_miso_m__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    SPI_0_OLED_FLASH_miso_m_SetDriveMode(uint8 mode);
N#endif
Nvoid    SPI_0_OLED_FLASH_miso_m_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   SPI_0_OLED_FLASH_miso_m_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid SPI_0_OLED_FLASH_miso_m_Sleep(void); 
Nvoid SPI_0_OLED_FLASH_miso_m_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(SPI_0_OLED_FLASH_miso_m__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define SPI_0_OLED_FLASH_miso_m_DRIVE_MODE_BITS        (3)
N    #define SPI_0_OLED_FLASH_miso_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_0_OLED_FLASH_miso_m_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the SPI_0_OLED_FLASH_miso_m_SetDriveMode() function.
N         *  @{
N         */
N        #define SPI_0_OLED_FLASH_miso_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define SPI_0_OLED_FLASH_miso_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define SPI_0_OLED_FLASH_miso_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define SPI_0_OLED_FLASH_miso_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define SPI_0_OLED_FLASH_miso_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define SPI_0_OLED_FLASH_miso_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define SPI_0_OLED_FLASH_miso_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define SPI_0_OLED_FLASH_miso_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define SPI_0_OLED_FLASH_miso_m_MASK               SPI_0_OLED_FLASH_miso_m__MASK
N#define SPI_0_OLED_FLASH_miso_m_SHIFT              SPI_0_OLED_FLASH_miso_m__SHIFT
N#define SPI_0_OLED_FLASH_miso_m_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in SPI_0_OLED_FLASH_miso_m_SetInterruptMode() function.
N     *  @{
N     */
N        #define SPI_0_OLED_FLASH_miso_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define SPI_0_OLED_FLASH_miso_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define SPI_0_OLED_FLASH_miso_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define SPI_0_OLED_FLASH_miso_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(SPI_0_OLED_FLASH_miso_m__SIO)
X#if 0L
S    #define SPI_0_OLED_FLASH_miso_m_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(SPI_0_OLED_FLASH_miso_m__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_DISABLE              ((uint32)(~SPI_0_OLED_FLASH_miso_m_USBIO_ENABLE))
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_0_OLED_FLASH_miso_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(SPI_0_OLED_FLASH_miso_m__PC)
X#if 1L
N    /* Port Configuration */
N    #define SPI_0_OLED_FLASH_miso_m_PC                 (* (reg32 *) SPI_0_OLED_FLASH_miso_m__PC)
N#endif
N/* Pin State */
N#define SPI_0_OLED_FLASH_miso_m_PS                     (* (reg32 *) SPI_0_OLED_FLASH_miso_m__PS)
N/* Data Register */
N#define SPI_0_OLED_FLASH_miso_m_DR                     (* (reg32 *) SPI_0_OLED_FLASH_miso_m__DR)
N/* Input Buffer Disable Override */
N#define SPI_0_OLED_FLASH_miso_m_INP_DIS                (* (reg32 *) SPI_0_OLED_FLASH_miso_m__PC2)
N
N/* Interrupt configuration Registers */
N#define SPI_0_OLED_FLASH_miso_m_INTCFG                 (* (reg32 *) SPI_0_OLED_FLASH_miso_m__INTCFG)
N#define SPI_0_OLED_FLASH_miso_m_INTSTAT                (* (reg32 *) SPI_0_OLED_FLASH_miso_m__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define SPI_0_OLED_FLASH_miso_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(SPI_0_OLED_FLASH_miso_m__SIO)
X#if 0L
S    #define SPI_0_OLED_FLASH_miso_m_SIO_REG            (* (reg32 *) SPI_0_OLED_FLASH_miso_m__SIO)
N#endif /* (SPI_0_OLED_FLASH_miso_m__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(SPI_0_OLED_FLASH_miso_m__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define SPI_0_OLED_FLASH_miso_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_0_OLED_FLASH_miso_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define SPI_0_OLED_FLASH_miso_m_DRIVE_MODE_SHIFT       (0x00u)
N#define SPI_0_OLED_FLASH_miso_m_DRIVE_MODE_MASK        (0x07u << SPI_0_OLED_FLASH_miso_m_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins SPI_0_OLED_FLASH_miso_m_H */
N
N
N/* [] END OF FILE */
L 144 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_PINS.h" 2
N#endif /*(SPI_0_OLED_FLASH_SPI_MASTER_MISO_PIN) */
N#endif /* (SPI_0_OLED_FLASH_SPI_MASTER_PINS) */
N
N#if (SPI_0_OLED_FLASH_SPI_SLAVE_PINS)
X#if ((0u == (1u)))
S    #include "SPI_0_OLED_FLASH_sclk_s.h"
S    #include "SPI_0_OLED_FLASH_ss_s.h"
S
S#if (SPI_0_OLED_FLASH_SPI_SLAVE_MOSI_PIN)
S    #include "SPI_0_OLED_FLASH_mosi_s.h"
S#endif /* (SPI_0_OLED_FLASH_SPI_SLAVE_MOSI_PIN) */
S
S#if (SPI_0_OLED_FLASH_SPI_SLAVE_MISO_PIN)
S    #include "SPI_0_OLED_FLASH_miso_s.h"
S#endif /*(SPI_0_OLED_FLASH_SPI_SLAVE_MISO_PIN) */
N#endif /* (SPI_0_OLED_FLASH_SPI_SLAVE_PINS) */
N
N#if (SPI_0_OLED_FLASH_SPI_MASTER_SS0_PIN)
X#if ((0u == (0u)))
N    #include "SPI_0_OLED_FLASH_ss0_m.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_ss0_m.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_ss0_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_ss0_m_H) /* Pins SPI_0_OLED_FLASH_ss0_m_H */
X#if !0L  
N#define CY_PINS_SPI_0_OLED_FLASH_ss0_m_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "SPI_0_OLED_FLASH_ss0_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_ss0_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_ss0_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_ss0_m_ALIASES_H) /* Pins SPI_0_OLED_FLASH_ss0_m_ALIASES_H */
X#if !0L  
N#define CY_PINS_SPI_0_OLED_FLASH_ss0_m_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define SPI_0_OLED_FLASH_ss0_m_0			(SPI_0_OLED_FLASH_ss0_m__0__PC)
N#define SPI_0_OLED_FLASH_ss0_m_0_PS		(SPI_0_OLED_FLASH_ss0_m__0__PS)
N#define SPI_0_OLED_FLASH_ss0_m_0_PC		(SPI_0_OLED_FLASH_ss0_m__0__PC)
N#define SPI_0_OLED_FLASH_ss0_m_0_DR		(SPI_0_OLED_FLASH_ss0_m__0__DR)
N#define SPI_0_OLED_FLASH_ss0_m_0_SHIFT	(SPI_0_OLED_FLASH_ss0_m__0__SHIFT)
N#define SPI_0_OLED_FLASH_ss0_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_0_OLED_FLASH_ss0_m__0__SHIFT*2u)))
N
N#define SPI_0_OLED_FLASH_ss0_m_INTR_ALL	 ((uint16)(SPI_0_OLED_FLASH_ss0_m_0_INTR))
N
N
N#endif /* End Pins SPI_0_OLED_FLASH_ss0_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_ss0_m.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} SPI_0_OLED_FLASH_ss0_m_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   SPI_0_OLED_FLASH_ss0_m_Read(void);
Nvoid    SPI_0_OLED_FLASH_ss0_m_Write(uint8 value);
Nuint8   SPI_0_OLED_FLASH_ss0_m_ReadDataReg(void);
N#if defined(SPI_0_OLED_FLASH_ss0_m__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    SPI_0_OLED_FLASH_ss0_m_SetDriveMode(uint8 mode);
N#endif
Nvoid    SPI_0_OLED_FLASH_ss0_m_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   SPI_0_OLED_FLASH_ss0_m_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid SPI_0_OLED_FLASH_ss0_m_Sleep(void); 
Nvoid SPI_0_OLED_FLASH_ss0_m_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(SPI_0_OLED_FLASH_ss0_m__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define SPI_0_OLED_FLASH_ss0_m_DRIVE_MODE_BITS        (3)
N    #define SPI_0_OLED_FLASH_ss0_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_0_OLED_FLASH_ss0_m_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the SPI_0_OLED_FLASH_ss0_m_SetDriveMode() function.
N         *  @{
N         */
N        #define SPI_0_OLED_FLASH_ss0_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define SPI_0_OLED_FLASH_ss0_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define SPI_0_OLED_FLASH_ss0_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define SPI_0_OLED_FLASH_ss0_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define SPI_0_OLED_FLASH_ss0_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define SPI_0_OLED_FLASH_ss0_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define SPI_0_OLED_FLASH_ss0_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define SPI_0_OLED_FLASH_ss0_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define SPI_0_OLED_FLASH_ss0_m_MASK               SPI_0_OLED_FLASH_ss0_m__MASK
N#define SPI_0_OLED_FLASH_ss0_m_SHIFT              SPI_0_OLED_FLASH_ss0_m__SHIFT
N#define SPI_0_OLED_FLASH_ss0_m_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in SPI_0_OLED_FLASH_ss0_m_SetInterruptMode() function.
N     *  @{
N     */
N        #define SPI_0_OLED_FLASH_ss0_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define SPI_0_OLED_FLASH_ss0_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define SPI_0_OLED_FLASH_ss0_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define SPI_0_OLED_FLASH_ss0_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(SPI_0_OLED_FLASH_ss0_m__SIO)
X#if 0L
S    #define SPI_0_OLED_FLASH_ss0_m_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(SPI_0_OLED_FLASH_ss0_m__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_DISABLE              ((uint32)(~SPI_0_OLED_FLASH_ss0_m_USBIO_ENABLE))
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_0_OLED_FLASH_ss0_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(SPI_0_OLED_FLASH_ss0_m__PC)
X#if 1L
N    /* Port Configuration */
N    #define SPI_0_OLED_FLASH_ss0_m_PC                 (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__PC)
N#endif
N/* Pin State */
N#define SPI_0_OLED_FLASH_ss0_m_PS                     (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__PS)
N/* Data Register */
N#define SPI_0_OLED_FLASH_ss0_m_DR                     (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__DR)
N/* Input Buffer Disable Override */
N#define SPI_0_OLED_FLASH_ss0_m_INP_DIS                (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__PC2)
N
N/* Interrupt configuration Registers */
N#define SPI_0_OLED_FLASH_ss0_m_INTCFG                 (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__INTCFG)
N#define SPI_0_OLED_FLASH_ss0_m_INTSTAT                (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define SPI_0_OLED_FLASH_ss0_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(SPI_0_OLED_FLASH_ss0_m__SIO)
X#if 0L
S    #define SPI_0_OLED_FLASH_ss0_m_SIO_REG            (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__SIO)
N#endif /* (SPI_0_OLED_FLASH_ss0_m__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(SPI_0_OLED_FLASH_ss0_m__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define SPI_0_OLED_FLASH_ss0_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_0_OLED_FLASH_ss0_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define SPI_0_OLED_FLASH_ss0_m_DRIVE_MODE_SHIFT       (0x00u)
N#define SPI_0_OLED_FLASH_ss0_m_DRIVE_MODE_MASK        (0x07u << SPI_0_OLED_FLASH_ss0_m_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins SPI_0_OLED_FLASH_ss0_m_H */
N
N
N/* [] END OF FILE */
L 162 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_PINS.h" 2
N#endif /* (SPI_0_OLED_FLASH_SPI_MASTER_SS0_PIN) */
N
N#if (SPI_0_OLED_FLASH_SPI_MASTER_SS1_PIN)
X#if ((0u == (0u)))
N    #include "SPI_0_OLED_FLASH_ss1_m.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_ss1_m.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_ss1_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_ss1_m_H) /* Pins SPI_0_OLED_FLASH_ss1_m_H */
X#if !0L  
N#define CY_PINS_SPI_0_OLED_FLASH_ss1_m_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "SPI_0_OLED_FLASH_ss1_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_ss1_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_ss1_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_ss1_m_ALIASES_H) /* Pins SPI_0_OLED_FLASH_ss1_m_ALIASES_H */
X#if !0L  
N#define CY_PINS_SPI_0_OLED_FLASH_ss1_m_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define SPI_0_OLED_FLASH_ss1_m_0			(SPI_0_OLED_FLASH_ss1_m__0__PC)
N#define SPI_0_OLED_FLASH_ss1_m_0_PS		(SPI_0_OLED_FLASH_ss1_m__0__PS)
N#define SPI_0_OLED_FLASH_ss1_m_0_PC		(SPI_0_OLED_FLASH_ss1_m__0__PC)
N#define SPI_0_OLED_FLASH_ss1_m_0_DR		(SPI_0_OLED_FLASH_ss1_m__0__DR)
N#define SPI_0_OLED_FLASH_ss1_m_0_SHIFT	(SPI_0_OLED_FLASH_ss1_m__0__SHIFT)
N#define SPI_0_OLED_FLASH_ss1_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_0_OLED_FLASH_ss1_m__0__SHIFT*2u)))
N
N#define SPI_0_OLED_FLASH_ss1_m_INTR_ALL	 ((uint16)(SPI_0_OLED_FLASH_ss1_m_0_INTR))
N
N
N#endif /* End Pins SPI_0_OLED_FLASH_ss1_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_ss1_m.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} SPI_0_OLED_FLASH_ss1_m_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   SPI_0_OLED_FLASH_ss1_m_Read(void);
Nvoid    SPI_0_OLED_FLASH_ss1_m_Write(uint8 value);
Nuint8   SPI_0_OLED_FLASH_ss1_m_ReadDataReg(void);
N#if defined(SPI_0_OLED_FLASH_ss1_m__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    SPI_0_OLED_FLASH_ss1_m_SetDriveMode(uint8 mode);
N#endif
Nvoid    SPI_0_OLED_FLASH_ss1_m_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   SPI_0_OLED_FLASH_ss1_m_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid SPI_0_OLED_FLASH_ss1_m_Sleep(void); 
Nvoid SPI_0_OLED_FLASH_ss1_m_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(SPI_0_OLED_FLASH_ss1_m__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define SPI_0_OLED_FLASH_ss1_m_DRIVE_MODE_BITS        (3)
N    #define SPI_0_OLED_FLASH_ss1_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_0_OLED_FLASH_ss1_m_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the SPI_0_OLED_FLASH_ss1_m_SetDriveMode() function.
N         *  @{
N         */
N        #define SPI_0_OLED_FLASH_ss1_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define SPI_0_OLED_FLASH_ss1_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define SPI_0_OLED_FLASH_ss1_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define SPI_0_OLED_FLASH_ss1_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define SPI_0_OLED_FLASH_ss1_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define SPI_0_OLED_FLASH_ss1_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define SPI_0_OLED_FLASH_ss1_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define SPI_0_OLED_FLASH_ss1_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define SPI_0_OLED_FLASH_ss1_m_MASK               SPI_0_OLED_FLASH_ss1_m__MASK
N#define SPI_0_OLED_FLASH_ss1_m_SHIFT              SPI_0_OLED_FLASH_ss1_m__SHIFT
N#define SPI_0_OLED_FLASH_ss1_m_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in SPI_0_OLED_FLASH_ss1_m_SetInterruptMode() function.
N     *  @{
N     */
N        #define SPI_0_OLED_FLASH_ss1_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define SPI_0_OLED_FLASH_ss1_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define SPI_0_OLED_FLASH_ss1_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define SPI_0_OLED_FLASH_ss1_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(SPI_0_OLED_FLASH_ss1_m__SIO)
X#if 0L
S    #define SPI_0_OLED_FLASH_ss1_m_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(SPI_0_OLED_FLASH_ss1_m__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_DISABLE              ((uint32)(~SPI_0_OLED_FLASH_ss1_m_USBIO_ENABLE))
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_0_OLED_FLASH_ss1_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(SPI_0_OLED_FLASH_ss1_m__PC)
X#if 1L
N    /* Port Configuration */
N    #define SPI_0_OLED_FLASH_ss1_m_PC                 (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__PC)
N#endif
N/* Pin State */
N#define SPI_0_OLED_FLASH_ss1_m_PS                     (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__PS)
N/* Data Register */
N#define SPI_0_OLED_FLASH_ss1_m_DR                     (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__DR)
N/* Input Buffer Disable Override */
N#define SPI_0_OLED_FLASH_ss1_m_INP_DIS                (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__PC2)
N
N/* Interrupt configuration Registers */
N#define SPI_0_OLED_FLASH_ss1_m_INTCFG                 (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__INTCFG)
N#define SPI_0_OLED_FLASH_ss1_m_INTSTAT                (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define SPI_0_OLED_FLASH_ss1_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(SPI_0_OLED_FLASH_ss1_m__SIO)
X#if 0L
S    #define SPI_0_OLED_FLASH_ss1_m_SIO_REG            (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__SIO)
N#endif /* (SPI_0_OLED_FLASH_ss1_m__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(SPI_0_OLED_FLASH_ss1_m__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define SPI_0_OLED_FLASH_ss1_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_0_OLED_FLASH_ss1_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define SPI_0_OLED_FLASH_ss1_m_DRIVE_MODE_SHIFT       (0x00u)
N#define SPI_0_OLED_FLASH_ss1_m_DRIVE_MODE_MASK        (0x07u << SPI_0_OLED_FLASH_ss1_m_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins SPI_0_OLED_FLASH_ss1_m_H */
N
N
N/* [] END OF FILE */
L 166 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_PINS.h" 2
N#endif /* (SPI_0_OLED_FLASH_SPI_MASTER_SS1_PIN) */
N
N#if (SPI_0_OLED_FLASH_SPI_MASTER_SS2_PIN)
X#if ((0u == (1u)))
S    #include "SPI_0_OLED_FLASH_ss2_m.h"
N#endif /* (SPI_0_OLED_FLASH_SPI_MASTER_SS2_PIN) */
N
N#if (SPI_0_OLED_FLASH_SPI_MASTER_SS3_PIN)
X#if ((0u == (1u)))
S    #include "SPI_0_OLED_FLASH_ss3_m.h"
N#endif /* (SPI_0_OLED_FLASH_SPI_MASTER_SS3_PIN) */
N
N#if (SPI_0_OLED_FLASH_UART_TX_PIN)
X#if ((0u == (1u)))
S    #include "SPI_0_OLED_FLASH_tx.h"
N#endif /* (SPI_0_OLED_FLASH_UART_TX_PIN) */
N
N#if (SPI_0_OLED_FLASH_UART_RX_TX_PIN)
X#if ((0u == (1u)))
S    #include "SPI_0_OLED_FLASH_rx_tx.h"
N#endif /* (SPI_0_OLED_FLASH_UART_RX_TX_PIN) */
N
N#if (SPI_0_OLED_FLASH_UART_RX_PIN)
X#if ((0u == (1u)))
S    #include "SPI_0_OLED_FLASH_rx.h"
N#endif /* (SPI_0_OLED_FLASH_UART_RX_PIN) */
N
N#if (SPI_0_OLED_FLASH_UART_RX_WAKE_PIN)
X#if ((0u == (1u)))
S    #include "SPI_0_OLED_FLASH_rx_wake.h"
N#endif /* (SPI_0_OLED_FLASH_UART_RX_WAKE_PIN) */
N
N#if (SPI_0_OLED_FLASH_UART_RTS_PIN)
X#if ((0u == (1u)))
S    #include "SPI_0_OLED_FLASH_rts.h"
N#endif /* (SPI_0_OLED_FLASH_UART_RTS_PIN) */
N
N#if (SPI_0_OLED_FLASH_UART_CTS_PIN)
X#if ((0u == (1u)))
S    #include "SPI_0_OLED_FLASH_cts.h"
N#endif /* (SPI_0_OLED_FLASH_UART_CTS_PIN) */
N
N
N/***************************************
N*              Registers
N***************************************/
N
N#if (SPI_0_OLED_FLASH_RX_SCL_MOSI_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_RX_SCL_MOSI_HSIOM_REG   (*(reg32 *) SPI_0_OLED_FLASH_uart_rx_i2c_scl_spi_mosi__0__HSIOM)
S    #define SPI_0_OLED_FLASH_RX_SCL_MOSI_HSIOM_PTR   ( (reg32 *) SPI_0_OLED_FLASH_uart_rx_i2c_scl_spi_mosi__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_RX_SCL_MOSI_HSIOM_MASK      (SPI_0_OLED_FLASH_uart_rx_i2c_scl_spi_mosi__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_RX_SCL_MOSI_HSIOM_POS       (SPI_0_OLED_FLASH_uart_rx_i2c_scl_spi_mosi__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_RX_SCL_MOSI_HSIOM_SEL_GPIO  (SPI_0_OLED_FLASH_uart_rx_i2c_scl_spi_mosi__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_RX_SCL_MOSI_HSIOM_SEL_I2C   (SPI_0_OLED_FLASH_uart_rx_i2c_scl_spi_mosi__0__HSIOM_I2C)
S    #define SPI_0_OLED_FLASH_RX_SCL_MOSI_HSIOM_SEL_SPI   (SPI_0_OLED_FLASH_uart_rx_i2c_scl_spi_mosi__0__HSIOM_SPI)
S    #define SPI_0_OLED_FLASH_RX_SCL_MOSI_HSIOM_SEL_UART  (SPI_0_OLED_FLASH_uart_rx_i2c_scl_spi_mosi__0__HSIOM_UART)
S    
S#elif (SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_PIN)
X#elif ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_REG   (*(reg32 *) SPI_0_OLED_FLASH_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM)
S    #define SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_PTR   ( (reg32 *) SPI_0_OLED_FLASH_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_MASK      (SPI_0_OLED_FLASH_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_POS       (SPI_0_OLED_FLASH_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_SEL_GPIO  (SPI_0_OLED_FLASH_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_SEL_I2C   (SPI_0_OLED_FLASH_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_I2C)
S    #define SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_SEL_SPI   (SPI_0_OLED_FLASH_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_SPI)
S    #define SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_SEL_UART  (SPI_0_OLED_FLASH_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_UART)    
S   
S    #define SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_INTCFG_REG (*(reg32 *) SPI_0_OLED_FLASH_uart_rx_wake_i2c_scl_spi_mosi__0__INTCFG)
S    #define SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_INTCFG_PTR ( (reg32 *) SPI_0_OLED_FLASH_uart_rx_wake_i2c_scl_spi_mosi__0__INTCFG)
S    #define SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_INTCFG_TYPE_POS  (SPI_0_OLED_FLASH_uart_rx_wake_i2c_scl_spi_mosi__SHIFT)
S    #define SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_INTCFG_TYPE_MASK ((uint32) SPI_0_OLED_FLASH_INTCFG_TYPE_MASK << \
S                                                                           SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_INTCFG_TYPE_POS)
X    #define SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_INTCFG_TYPE_MASK ((uint32) SPI_0_OLED_FLASH_INTCFG_TYPE_MASK <<                                                                            SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_INTCFG_TYPE_POS)
N#else
N    /* None of pins SPI_0_OLED_FLASH_RX_SCL_MOSI_PIN or SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_PIN present.*/
N#endif /* (SPI_0_OLED_FLASH_RX_SCL_MOSI_PIN) */
N
N#if (SPI_0_OLED_FLASH_TX_SDA_MISO_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_TX_SDA_MISO_HSIOM_REG   (*(reg32 *) SPI_0_OLED_FLASH_uart_tx_i2c_sda_spi_miso__0__HSIOM)
S    #define SPI_0_OLED_FLASH_TX_SDA_MISO_HSIOM_PTR   ( (reg32 *) SPI_0_OLED_FLASH_uart_tx_i2c_sda_spi_miso__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_TX_SDA_MISO_HSIOM_MASK      (SPI_0_OLED_FLASH_uart_tx_i2c_sda_spi_miso__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_TX_SDA_MISO_HSIOM_POS       (SPI_0_OLED_FLASH_uart_tx_i2c_sda_spi_miso__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_TX_SDA_MISO_HSIOM_SEL_GPIO  (SPI_0_OLED_FLASH_uart_tx_i2c_sda_spi_miso__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_TX_SDA_MISO_HSIOM_SEL_I2C   (SPI_0_OLED_FLASH_uart_tx_i2c_sda_spi_miso__0__HSIOM_I2C)
S    #define SPI_0_OLED_FLASH_TX_SDA_MISO_HSIOM_SEL_SPI   (SPI_0_OLED_FLASH_uart_tx_i2c_sda_spi_miso__0__HSIOM_SPI)
S    #define SPI_0_OLED_FLASH_TX_SDA_MISO_HSIOM_SEL_UART  (SPI_0_OLED_FLASH_uart_tx_i2c_sda_spi_miso__0__HSIOM_UART)
N#endif /* (SPI_0_OLED_FLASH_TX_SDA_MISO_PIN) */
N
N#if (SPI_0_OLED_FLASH_CTS_SCLK_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_CTS_SCLK_HSIOM_REG   (*(reg32 *) SPI_0_OLED_FLASH_uart_cts_spi_sclk__0__HSIOM)
S    #define SPI_0_OLED_FLASH_CTS_SCLK_HSIOM_PTR   ( (reg32 *) SPI_0_OLED_FLASH_uart_cts_spi_sclk__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_CTS_SCLK_HSIOM_MASK      (SPI_0_OLED_FLASH_uart_cts_spi_sclk__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_CTS_SCLK_HSIOM_POS       (SPI_0_OLED_FLASH_uart_cts_spi_sclk__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_CTS_SCLK_HSIOM_SEL_GPIO  (SPI_0_OLED_FLASH_uart_cts_spi_sclk__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_CTS_SCLK_HSIOM_SEL_I2C   (SPI_0_OLED_FLASH_uart_cts_spi_sclk__0__HSIOM_I2C)
S    #define SPI_0_OLED_FLASH_CTS_SCLK_HSIOM_SEL_SPI   (SPI_0_OLED_FLASH_uart_cts_spi_sclk__0__HSIOM_SPI)
S    #define SPI_0_OLED_FLASH_CTS_SCLK_HSIOM_SEL_UART  (SPI_0_OLED_FLASH_uart_cts_spi_sclk__0__HSIOM_UART)
N#endif /* (SPI_0_OLED_FLASH_CTS_SCLK_PIN) */
N
N#if (SPI_0_OLED_FLASH_RTS_SS0_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_RTS_SS0_HSIOM_REG   (*(reg32 *) SPI_0_OLED_FLASH_uart_rts_spi_ss0__0__HSIOM)
S    #define SPI_0_OLED_FLASH_RTS_SS0_HSIOM_PTR   ( (reg32 *) SPI_0_OLED_FLASH_uart_rts_spi_ss0__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_RTS_SS0_HSIOM_MASK      (SPI_0_OLED_FLASH_uart_rts_spi_ss0__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_RTS_SS0_HSIOM_POS       (SPI_0_OLED_FLASH_uart_rts_spi_ss0__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_RTS_SS0_HSIOM_SEL_GPIO  (SPI_0_OLED_FLASH_uart_rts_spi_ss0__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_RTS_SS0_HSIOM_SEL_I2C   (SPI_0_OLED_FLASH_uart_rts_spi_ss0__0__HSIOM_I2C)
S    #define SPI_0_OLED_FLASH_RTS_SS0_HSIOM_SEL_SPI   (SPI_0_OLED_FLASH_uart_rts_spi_ss0__0__HSIOM_SPI)
S#if !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1)
S    #define SPI_0_OLED_FLASH_RTS_SS0_HSIOM_SEL_UART  (SPI_0_OLED_FLASH_uart_rts_spi_ss0__0__HSIOM_UART)
S#endif /* !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N#endif /* (SPI_0_OLED_FLASH_RTS_SS0_PIN) */
N
N#if (SPI_0_OLED_FLASH_SS1_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_SS1_HSIOM_REG  (*(reg32 *) SPI_0_OLED_FLASH_spi_ss1__0__HSIOM)
S    #define SPI_0_OLED_FLASH_SS1_HSIOM_PTR  ( (reg32 *) SPI_0_OLED_FLASH_spi_ss1__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_SS1_HSIOM_MASK     (SPI_0_OLED_FLASH_spi_ss1__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_SS1_HSIOM_POS      (SPI_0_OLED_FLASH_spi_ss1__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_SS1_HSIOM_SEL_GPIO (SPI_0_OLED_FLASH_spi_ss1__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_SS1_HSIOM_SEL_I2C  (SPI_0_OLED_FLASH_spi_ss1__0__HSIOM_I2C)
S    #define SPI_0_OLED_FLASH_SS1_HSIOM_SEL_SPI  (SPI_0_OLED_FLASH_spi_ss1__0__HSIOM_SPI)
N#endif /* (SPI_0_OLED_FLASH_SS1_PIN) */
N
N#if (SPI_0_OLED_FLASH_SS2_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_SS2_HSIOM_REG     (*(reg32 *) SPI_0_OLED_FLASH_spi_ss2__0__HSIOM)
S    #define SPI_0_OLED_FLASH_SS2_HSIOM_PTR     ( (reg32 *) SPI_0_OLED_FLASH_spi_ss2__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_SS2_HSIOM_MASK     (SPI_0_OLED_FLASH_spi_ss2__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_SS2_HSIOM_POS      (SPI_0_OLED_FLASH_spi_ss2__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_SS2_HSIOM_SEL_GPIO (SPI_0_OLED_FLASH_spi_ss2__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_SS2_HSIOM_SEL_I2C  (SPI_0_OLED_FLASH_spi_ss2__0__HSIOM_I2C)
S    #define SPI_0_OLED_FLASH_SS2_HSIOM_SEL_SPI  (SPI_0_OLED_FLASH_spi_ss2__0__HSIOM_SPI)
N#endif /* (SPI_0_OLED_FLASH_SS2_PIN) */
N
N#if (SPI_0_OLED_FLASH_SS3_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_SS3_HSIOM_REG     (*(reg32 *) SPI_0_OLED_FLASH_spi_ss3__0__HSIOM)
S    #define SPI_0_OLED_FLASH_SS3_HSIOM_PTR     ( (reg32 *) SPI_0_OLED_FLASH_spi_ss3__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_SS3_HSIOM_MASK     (SPI_0_OLED_FLASH_spi_ss3__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_SS3_HSIOM_POS      (SPI_0_OLED_FLASH_spi_ss3__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_SS3_HSIOM_SEL_GPIO (SPI_0_OLED_FLASH_spi_ss3__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_SS3_HSIOM_SEL_I2C  (SPI_0_OLED_FLASH_spi_ss3__0__HSIOM_I2C)
S    #define SPI_0_OLED_FLASH_SS3_HSIOM_SEL_SPI  (SPI_0_OLED_FLASH_spi_ss3__0__HSIOM_SPI)
N#endif /* (SPI_0_OLED_FLASH_SS3_PIN) */
N
N#if (SPI_0_OLED_FLASH_I2C_PINS)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_SCL_HSIOM_REG  (*(reg32 *) SPI_0_OLED_FLASH_scl__0__HSIOM)
S    #define SPI_0_OLED_FLASH_SCL_HSIOM_PTR  ( (reg32 *) SPI_0_OLED_FLASH_scl__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_SCL_HSIOM_MASK     (SPI_0_OLED_FLASH_scl__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_SCL_HSIOM_POS      (SPI_0_OLED_FLASH_scl__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_SCL_HSIOM_SEL_GPIO (SPI_0_OLED_FLASH_sda__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_SCL_HSIOM_SEL_I2C  (SPI_0_OLED_FLASH_sda__0__HSIOM_I2C)
S    
S    #define SPI_0_OLED_FLASH_SDA_HSIOM_REG  (*(reg32 *) SPI_0_OLED_FLASH_sda__0__HSIOM)
S    #define SPI_0_OLED_FLASH_SDA_HSIOM_PTR  ( (reg32 *) SPI_0_OLED_FLASH_sda__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_SDA_HSIOM_MASK     (SPI_0_OLED_FLASH_sda__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_SDA_HSIOM_POS      (SPI_0_OLED_FLASH_sda__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_SDA_HSIOM_SEL_GPIO (SPI_0_OLED_FLASH_sda__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_SDA_HSIOM_SEL_I2C  (SPI_0_OLED_FLASH_sda__0__HSIOM_I2C)
N#endif /* (SPI_0_OLED_FLASH_I2C_PINS) */
N
N#if (SPI_0_OLED_FLASH_SPI_SLAVE_PINS)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_SCLK_S_HSIOM_REG   (*(reg32 *) SPI_0_OLED_FLASH_sclk_s__0__HSIOM)
S    #define SPI_0_OLED_FLASH_SCLK_S_HSIOM_PTR   ( (reg32 *) SPI_0_OLED_FLASH_sclk_s__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_SCLK_S_HSIOM_MASK      (SPI_0_OLED_FLASH_sclk_s__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_SCLK_S_HSIOM_POS       (SPI_0_OLED_FLASH_sclk_s__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_SCLK_S_HSIOM_SEL_GPIO  (SPI_0_OLED_FLASH_sclk_s__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_SCLK_S_HSIOM_SEL_SPI   (SPI_0_OLED_FLASH_sclk_s__0__HSIOM_SPI)
S    
S    #define SPI_0_OLED_FLASH_SS0_S_HSIOM_REG    (*(reg32 *) SPI_0_OLED_FLASH_ss0_s__0__HSIOM)
S    #define SPI_0_OLED_FLASH_SS0_S_HSIOM_PTR    ( (reg32 *) SPI_0_OLED_FLASH_ss0_s__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_SS0_S_HSIOM_MASK       (SPI_0_OLED_FLASH_ss0_s__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_SS0_S_HSIOM_POS        (SPI_0_OLED_FLASH_ss0_s__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_SS0_S_HSIOM_SEL_GPIO   (SPI_0_OLED_FLASH_ss0_s__0__HSIOM_GPIO)  
S    #define SPI_0_OLED_FLASH_SS0_S_HSIOM_SEL_SPI    (SPI_0_OLED_FLASH_ss0_s__0__HSIOM_SPI)
N#endif /* (SPI_0_OLED_FLASH_SPI_SLAVE_PINS) */
N
N#if (SPI_0_OLED_FLASH_SPI_SLAVE_MOSI_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_MOSI_S_HSIOM_REG   (*(reg32 *) SPI_0_OLED_FLASH_mosi_s__0__HSIOM)
S    #define SPI_0_OLED_FLASH_MOSI_S_HSIOM_PTR   ( (reg32 *) SPI_0_OLED_FLASH_mosi_s__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_MOSI_S_HSIOM_MASK      (SPI_0_OLED_FLASH_mosi_s__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_MOSI_S_HSIOM_POS       (SPI_0_OLED_FLASH_mosi_s__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_MOSI_S_HSIOM_SEL_GPIO  (SPI_0_OLED_FLASH_mosi_s__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_MOSI_S_HSIOM_SEL_SPI   (SPI_0_OLED_FLASH_mosi_s__0__HSIOM_SPI)
N#endif /* (SPI_0_OLED_FLASH_SPI_SLAVE_MOSI_PIN) */
N
N#if (SPI_0_OLED_FLASH_SPI_SLAVE_MISO_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_MISO_S_HSIOM_REG   (*(reg32 *) SPI_0_OLED_FLASH_miso_s__0__HSIOM)
S    #define SPI_0_OLED_FLASH_MISO_S_HSIOM_PTR   ( (reg32 *) SPI_0_OLED_FLASH_miso_s__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_MISO_S_HSIOM_MASK      (SPI_0_OLED_FLASH_miso_s__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_MISO_S_HSIOM_POS       (SPI_0_OLED_FLASH_miso_s__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_MISO_S_HSIOM_SEL_GPIO  (SPI_0_OLED_FLASH_miso_s__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_MISO_S_HSIOM_SEL_SPI   (SPI_0_OLED_FLASH_miso_s__0__HSIOM_SPI)
N#endif /* (SPI_0_OLED_FLASH_SPI_SLAVE_MISO_PIN) */
N
N#if (SPI_0_OLED_FLASH_SPI_MASTER_MISO_PIN)
X#if ((0u == (0u)))
N    #define SPI_0_OLED_FLASH_MISO_M_HSIOM_REG   (*(reg32 *) SPI_0_OLED_FLASH_miso_m__0__HSIOM)
N    #define SPI_0_OLED_FLASH_MISO_M_HSIOM_PTR   ( (reg32 *) SPI_0_OLED_FLASH_miso_m__0__HSIOM)
N    
N    #define SPI_0_OLED_FLASH_MISO_M_HSIOM_MASK      (SPI_0_OLED_FLASH_miso_m__0__HSIOM_MASK)
N    #define SPI_0_OLED_FLASH_MISO_M_HSIOM_POS       (SPI_0_OLED_FLASH_miso_m__0__HSIOM_SHIFT)
N    #define SPI_0_OLED_FLASH_MISO_M_HSIOM_SEL_GPIO  (SPI_0_OLED_FLASH_miso_m__0__HSIOM_GPIO)
N    #define SPI_0_OLED_FLASH_MISO_M_HSIOM_SEL_SPI   (SPI_0_OLED_FLASH_miso_m__0__HSIOM_SPI)
N#endif /* (SPI_0_OLED_FLASH_SPI_MASTER_MISO_PIN) */
N
N#if (SPI_0_OLED_FLASH_SPI_MASTER_MOSI_PIN)
X#if ((0u == (0u)))
N    #define SPI_0_OLED_FLASH_MOSI_M_HSIOM_REG   (*(reg32 *) SPI_0_OLED_FLASH_mosi_m__0__HSIOM)
N    #define SPI_0_OLED_FLASH_MOSI_M_HSIOM_PTR   ( (reg32 *) SPI_0_OLED_FLASH_mosi_m__0__HSIOM)
N    
N    #define SPI_0_OLED_FLASH_MOSI_M_HSIOM_MASK      (SPI_0_OLED_FLASH_mosi_m__0__HSIOM_MASK)
N    #define SPI_0_OLED_FLASH_MOSI_M_HSIOM_POS       (SPI_0_OLED_FLASH_mosi_m__0__HSIOM_SHIFT)
N    #define SPI_0_OLED_FLASH_MOSI_M_HSIOM_SEL_GPIO  (SPI_0_OLED_FLASH_mosi_m__0__HSIOM_GPIO)
N    #define SPI_0_OLED_FLASH_MOSI_M_HSIOM_SEL_SPI   (SPI_0_OLED_FLASH_mosi_m__0__HSIOM_SPI)
N#endif /* (SPI_0_OLED_FLASH_SPI_MASTER_MOSI_PIN) */
N
N#if (SPI_0_OLED_FLASH_SPI_MASTER_SCLK_PIN)
X#if ((0u == (0u)))
N    #define SPI_0_OLED_FLASH_SCLK_M_HSIOM_REG   (*(reg32 *) SPI_0_OLED_FLASH_sclk_m__0__HSIOM)
N    #define SPI_0_OLED_FLASH_SCLK_M_HSIOM_PTR   ( (reg32 *) SPI_0_OLED_FLASH_sclk_m__0__HSIOM)
N    
N    #define SPI_0_OLED_FLASH_SCLK_M_HSIOM_MASK      (SPI_0_OLED_FLASH_sclk_m__0__HSIOM_MASK)
N    #define SPI_0_OLED_FLASH_SCLK_M_HSIOM_POS       (SPI_0_OLED_FLASH_sclk_m__0__HSIOM_SHIFT)
N    #define SPI_0_OLED_FLASH_SCLK_M_HSIOM_SEL_GPIO  (SPI_0_OLED_FLASH_sclk_m__0__HSIOM_GPIO)
N    #define SPI_0_OLED_FLASH_SCLK_M_HSIOM_SEL_SPI   (SPI_0_OLED_FLASH_sclk_m__0__HSIOM_SPI)
N#endif /* (SPI_0_OLED_FLASH_SPI_MASTER_SCLK_PIN) */
N
N#if (SPI_0_OLED_FLASH_SPI_MASTER_SS0_PIN)
X#if ((0u == (0u)))
N    #define SPI_0_OLED_FLASH_SS0_M_HSIOM_REG    (*(reg32 *) SPI_0_OLED_FLASH_ss0_m__0__HSIOM)
N    #define SPI_0_OLED_FLASH_SS0_M_HSIOM_PTR    ( (reg32 *) SPI_0_OLED_FLASH_ss0_m__0__HSIOM)
N    
N    #define SPI_0_OLED_FLASH_SS0_M_HSIOM_MASK       (SPI_0_OLED_FLASH_ss0_m__0__HSIOM_MASK)
N    #define SPI_0_OLED_FLASH_SS0_M_HSIOM_POS        (SPI_0_OLED_FLASH_ss0_m__0__HSIOM_SHIFT)
N    #define SPI_0_OLED_FLASH_SS0_M_HSIOM_SEL_GPIO   (SPI_0_OLED_FLASH_ss0_m__0__HSIOM_GPIO)
N    #define SPI_0_OLED_FLASH_SS0_M_HSIOM_SEL_SPI    (SPI_0_OLED_FLASH_ss0_m__0__HSIOM_SPI)
N#endif /* (SPI_0_OLED_FLASH_SPI_MASTER_SS0_PIN) */
N
N#if (SPI_0_OLED_FLASH_SPI_MASTER_SS1_PIN)
X#if ((0u == (0u)))
N    #define SPI_0_OLED_FLASH_SS1_M_HSIOM_REG    (*(reg32 *) SPI_0_OLED_FLASH_ss1_m__0__HSIOM)
N    #define SPI_0_OLED_FLASH_SS1_M_HSIOM_PTR    ( (reg32 *) SPI_0_OLED_FLASH_ss1_m__0__HSIOM)
N    
N    #define SPI_0_OLED_FLASH_SS1_M_HSIOM_MASK       (SPI_0_OLED_FLASH_ss1_m__0__HSIOM_MASK)
N    #define SPI_0_OLED_FLASH_SS1_M_HSIOM_POS        (SPI_0_OLED_FLASH_ss1_m__0__HSIOM_SHIFT)
N    #define SPI_0_OLED_FLASH_SS1_M_HSIOM_SEL_GPIO   (SPI_0_OLED_FLASH_ss1_m__0__HSIOM_GPIO)
N    #define SPI_0_OLED_FLASH_SS1_M_HSIOM_SEL_SPI    (SPI_0_OLED_FLASH_ss1_m__0__HSIOM_SPI)
N#endif /* (SPI_0_OLED_FLASH_SPI_MASTER_SS1_PIN) */
N
N#if (SPI_0_OLED_FLASH_SPI_MASTER_SS2_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_SS2_M_HSIOM_REG    (*(reg32 *) SPI_0_OLED_FLASH_ss2_m__0__HSIOM)
S    #define SPI_0_OLED_FLASH_SS2_M_HSIOM_PTR    ( (reg32 *) SPI_0_OLED_FLASH_ss2_m__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_SS2_M_HSIOM_MASK       (SPI_0_OLED_FLASH_ss2_m__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_SS2_M_HSIOM_POS        (SPI_0_OLED_FLASH_ss2_m__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_SS2_M_HSIOM_SEL_GPIO   (SPI_0_OLED_FLASH_ss2_m__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_SS2_M_HSIOM_SEL_SPI    (SPI_0_OLED_FLASH_ss2_m__0__HSIOM_SPI)
N#endif /* (SPI_0_OLED_FLASH_SPI_MASTER_SS2_PIN) */
N
N#if (SPI_0_OLED_FLASH_SPI_MASTER_SS3_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_SS3_M_HSIOM_REG    (*(reg32 *) SPI_0_OLED_FLASH_ss3_m__0__HSIOM)
S    #define SPI_0_OLED_FLASH_SS3_M_HSIOM_PTR    ( (reg32 *) SPI_0_OLED_FLASH_ss3_m__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_SS3_M_HSIOM_MASK      (SPI_0_OLED_FLASH_ss3_m__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_SS3_M_HSIOM_POS       (SPI_0_OLED_FLASH_ss3_m__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_SS3_M_HSIOM_SEL_GPIO  (SPI_0_OLED_FLASH_ss3_m__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_SS3_M_HSIOM_SEL_SPI   (SPI_0_OLED_FLASH_ss3_m__0__HSIOM_SPI)
N#endif /* (SPI_0_OLED_FLASH_SPI_MASTER_SS3_PIN) */
N
N#if (SPI_0_OLED_FLASH_UART_RX_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_RX_HSIOM_REG   (*(reg32 *) SPI_0_OLED_FLASH_rx__0__HSIOM)
S    #define SPI_0_OLED_FLASH_RX_HSIOM_PTR   ( (reg32 *) SPI_0_OLED_FLASH_rx__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_RX_HSIOM_MASK      (SPI_0_OLED_FLASH_rx__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_RX_HSIOM_POS       (SPI_0_OLED_FLASH_rx__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_RX_HSIOM_SEL_GPIO  (SPI_0_OLED_FLASH_rx__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_RX_HSIOM_SEL_UART  (SPI_0_OLED_FLASH_rx__0__HSIOM_UART)
N#endif /* (SPI_0_OLED_FLASH_UART_RX_PIN) */
N
N#if (SPI_0_OLED_FLASH_UART_RX_WAKE_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_RX_WAKE_HSIOM_REG   (*(reg32 *) SPI_0_OLED_FLASH_rx_wake__0__HSIOM)
S    #define SPI_0_OLED_FLASH_RX_WAKE_HSIOM_PTR   ( (reg32 *) SPI_0_OLED_FLASH_rx_wake__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_RX_WAKE_HSIOM_MASK      (SPI_0_OLED_FLASH_rx_wake__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_RX_WAKE_HSIOM_POS       (SPI_0_OLED_FLASH_rx_wake__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_RX_WAKE_HSIOM_SEL_GPIO  (SPI_0_OLED_FLASH_rx_wake__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_RX_WAKE_HSIOM_SEL_UART  (SPI_0_OLED_FLASH_rx_wake__0__HSIOM_UART)
N#endif /* (SPI_0_OLED_FLASH_UART_WAKE_RX_PIN) */
N
N#if (SPI_0_OLED_FLASH_UART_CTS_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_CTS_HSIOM_REG   (*(reg32 *) SPI_0_OLED_FLASH_cts__0__HSIOM)
S    #define SPI_0_OLED_FLASH_CTS_HSIOM_PTR   ( (reg32 *) SPI_0_OLED_FLASH_cts__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_CTS_HSIOM_MASK      (SPI_0_OLED_FLASH_cts__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_CTS_HSIOM_POS       (SPI_0_OLED_FLASH_cts__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_CTS_HSIOM_SEL_GPIO  (SPI_0_OLED_FLASH_cts__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_CTS_HSIOM_SEL_UART  (SPI_0_OLED_FLASH_cts__0__HSIOM_UART)
N#endif /* (SPI_0_OLED_FLASH_UART_CTS_PIN) */
N
N#if (SPI_0_OLED_FLASH_UART_TX_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_TX_HSIOM_REG   (*(reg32 *) SPI_0_OLED_FLASH_tx__0__HSIOM)
S    #define SPI_0_OLED_FLASH_TX_HSIOM_PTR   ( (reg32 *) SPI_0_OLED_FLASH_tx__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_TX_HSIOM_MASK      (SPI_0_OLED_FLASH_tx__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_TX_HSIOM_POS       (SPI_0_OLED_FLASH_tx__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_TX_HSIOM_SEL_GPIO  (SPI_0_OLED_FLASH_tx__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_TX_HSIOM_SEL_UART  (SPI_0_OLED_FLASH_tx__0__HSIOM_UART)
N#endif /* (SPI_0_OLED_FLASH_UART_TX_PIN) */
N
N#if (SPI_0_OLED_FLASH_UART_RX_TX_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_RX_TX_HSIOM_REG   (*(reg32 *) SPI_0_OLED_FLASH_rx_tx__0__HSIOM)
S    #define SPI_0_OLED_FLASH_RX_TX_HSIOM_PTR   ( (reg32 *) SPI_0_OLED_FLASH_rx_tx__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_RX_TX_HSIOM_MASK      (SPI_0_OLED_FLASH_rx_tx__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_RX_TX_HSIOM_POS       (SPI_0_OLED_FLASH_rx_tx__0__HSIOM_SHIFT)
S    #define SPI_0_OLED_FLASH_RX_TX_HSIOM_SEL_GPIO  (SPI_0_OLED_FLASH_rx_tx__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_RX_TX_HSIOM_SEL_UART  (SPI_0_OLED_FLASH_rx_tx__0__HSIOM_UART)
N#endif /* (SPI_0_OLED_FLASH_UART_RX_TX_PIN) */
N
N#if (SPI_0_OLED_FLASH_UART_RTS_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_RTS_HSIOM_REG      (*(reg32 *) SPI_0_OLED_FLASH_rts__0__HSIOM)
S    #define SPI_0_OLED_FLASH_RTS_HSIOM_PTR      ( (reg32 *) SPI_0_OLED_FLASH_rts__0__HSIOM)
S    
S    #define SPI_0_OLED_FLASH_RTS_HSIOM_MASK     (SPI_0_OLED_FLASH_rts__0__HSIOM_MASK)
S    #define SPI_0_OLED_FLASH_RTS_HSIOM_POS      (SPI_0_OLED_FLASH_rts__0__HSIOM_SHIFT)    
S    #define SPI_0_OLED_FLASH_RTS_HSIOM_SEL_GPIO (SPI_0_OLED_FLASH_rts__0__HSIOM_GPIO)
S    #define SPI_0_OLED_FLASH_RTS_HSIOM_SEL_UART (SPI_0_OLED_FLASH_rts__0__HSIOM_UART)    
N#endif /* (SPI_0_OLED_FLASH_UART_RTS_PIN) */
N
N
N/***************************************
N*        Registers Constants
N***************************************/
N
N/* HSIOM switch values. */ 
N#define SPI_0_OLED_FLASH_HSIOM_DEF_SEL      (0x00u)
N#define SPI_0_OLED_FLASH_HSIOM_GPIO_SEL     (0x00u)
N/* The HSIOM values provided below are valid only for SPI_0_OLED_FLASH_CY_SCBIP_V0 
N* and SPI_0_OLED_FLASH_CY_SCBIP_V1. It is not recommended to use them for 
N* SPI_0_OLED_FLASH_CY_SCBIP_V2. Use pin name specific HSIOM constants provided 
N* above instead for any SCB IP block version.
N*/
N#define SPI_0_OLED_FLASH_HSIOM_UART_SEL     (0x09u)
N#define SPI_0_OLED_FLASH_HSIOM_I2C_SEL      (0x0Eu)
N#define SPI_0_OLED_FLASH_HSIOM_SPI_SEL      (0x0Fu)
N
N/* Pins settings index. */
N#define SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_PIN_INDEX   (0u)
N#define SPI_0_OLED_FLASH_RX_SCL_MOSI_PIN_INDEX       (0u)
N#define SPI_0_OLED_FLASH_TX_SDA_MISO_PIN_INDEX       (1u)
N#define SPI_0_OLED_FLASH_CTS_SCLK_PIN_INDEX       (2u)
N#define SPI_0_OLED_FLASH_RTS_SS0_PIN_INDEX       (3u)
N#define SPI_0_OLED_FLASH_SS1_PIN_INDEX                  (4u)
N#define SPI_0_OLED_FLASH_SS2_PIN_INDEX                  (5u)
N#define SPI_0_OLED_FLASH_SS3_PIN_INDEX                  (6u)
N
N/* Pins settings mask. */
N#define SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_PIN_MASK ((uint32) 0x01u << SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_PIN_INDEX)
N#define SPI_0_OLED_FLASH_RX_SCL_MOSI_PIN_MASK     ((uint32) 0x01u << SPI_0_OLED_FLASH_RX_SCL_MOSI_PIN_INDEX)
N#define SPI_0_OLED_FLASH_TX_SDA_MISO_PIN_MASK     ((uint32) 0x01u << SPI_0_OLED_FLASH_TX_SDA_MISO_PIN_INDEX)
N#define SPI_0_OLED_FLASH_CTS_SCLK_PIN_MASK     ((uint32) 0x01u << SPI_0_OLED_FLASH_CTS_SCLK_PIN_INDEX)
N#define SPI_0_OLED_FLASH_RTS_SS0_PIN_MASK     ((uint32) 0x01u << SPI_0_OLED_FLASH_RTS_SS0_PIN_INDEX)
N#define SPI_0_OLED_FLASH_SS1_PIN_MASK                ((uint32) 0x01u << SPI_0_OLED_FLASH_SS1_PIN_INDEX)
N#define SPI_0_OLED_FLASH_SS2_PIN_MASK                ((uint32) 0x01u << SPI_0_OLED_FLASH_SS2_PIN_INDEX)
N#define SPI_0_OLED_FLASH_SS3_PIN_MASK                ((uint32) 0x01u << SPI_0_OLED_FLASH_SS3_PIN_INDEX)
N
N/* Pin interrupt constants. */
N#define SPI_0_OLED_FLASH_INTCFG_TYPE_MASK           (0x03u)
N#define SPI_0_OLED_FLASH_INTCFG_TYPE_FALLING_EDGE   (0x02u)
N
N/* Pin Drive Mode constants. */
N#define SPI_0_OLED_FLASH_PIN_DM_ALG_HIZ  (0u)
N#define SPI_0_OLED_FLASH_PIN_DM_DIG_HIZ  (1u)
N#define SPI_0_OLED_FLASH_PIN_DM_OD_LO    (4u)
N#define SPI_0_OLED_FLASH_PIN_DM_STRONG   (6u)
N
N
N/***************************************
N*          Macro Definitions
N***************************************/
N
N/* Return drive mode of the pin */
N#define SPI_0_OLED_FLASH_DM_MASK    (0x7u)
N#define SPI_0_OLED_FLASH_DM_SIZE    (3u)
N#define SPI_0_OLED_FLASH_GET_P4_PIN_DM(reg, pos) \
N    ( ((reg) & (uint32) ((uint32) SPI_0_OLED_FLASH_DM_MASK << (SPI_0_OLED_FLASH_DM_SIZE * (pos)))) >> \
N                                                              (SPI_0_OLED_FLASH_DM_SIZE * (pos)) )
X#define SPI_0_OLED_FLASH_GET_P4_PIN_DM(reg, pos)     ( ((reg) & (uint32) ((uint32) SPI_0_OLED_FLASH_DM_MASK << (SPI_0_OLED_FLASH_DM_SIZE * (pos)))) >>                                                               (SPI_0_OLED_FLASH_DM_SIZE * (pos)) )
N
N#if (SPI_0_OLED_FLASH_TX_SDA_MISO_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_CHECK_TX_SDA_MISO_PIN_USED \
S                (SPI_0_OLED_FLASH_PIN_DM_ALG_HIZ != \
S                    SPI_0_OLED_FLASH_GET_P4_PIN_DM(SPI_0_OLED_FLASH_uart_tx_i2c_sda_spi_miso_PC, \
S                                                   SPI_0_OLED_FLASH_uart_tx_i2c_sda_spi_miso_SHIFT))
X    #define SPI_0_OLED_FLASH_CHECK_TX_SDA_MISO_PIN_USED                 (SPI_0_OLED_FLASH_PIN_DM_ALG_HIZ !=                     SPI_0_OLED_FLASH_GET_P4_PIN_DM(SPI_0_OLED_FLASH_uart_tx_i2c_sda_spi_miso_PC,                                                    SPI_0_OLED_FLASH_uart_tx_i2c_sda_spi_miso_SHIFT))
N#endif /* (SPI_0_OLED_FLASH_TX_SDA_MISO_PIN) */
N
N#if (SPI_0_OLED_FLASH_RTS_SS0_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_CHECK_RTS_SS0_PIN_USED \
S                (SPI_0_OLED_FLASH_PIN_DM_ALG_HIZ != \
S                    SPI_0_OLED_FLASH_GET_P4_PIN_DM(SPI_0_OLED_FLASH_uart_rts_spi_ss0_PC, \
S                                                   SPI_0_OLED_FLASH_uart_rts_spi_ss0_SHIFT))
X    #define SPI_0_OLED_FLASH_CHECK_RTS_SS0_PIN_USED                 (SPI_0_OLED_FLASH_PIN_DM_ALG_HIZ !=                     SPI_0_OLED_FLASH_GET_P4_PIN_DM(SPI_0_OLED_FLASH_uart_rts_spi_ss0_PC,                                                    SPI_0_OLED_FLASH_uart_rts_spi_ss0_SHIFT))
N#endif /* (SPI_0_OLED_FLASH_RTS_SS0_PIN) */
N
N/* Set bits-mask in register */
N#define SPI_0_OLED_FLASH_SET_REGISTER_BITS(reg, mask, pos, mode) \
N                    do                                           \
N                    {                                            \
N                        (reg) = (((reg) & ((uint32) ~(uint32) (mask))) | ((uint32) ((uint32) (mode) << (pos)))); \
N                    }while(0)
X#define SPI_0_OLED_FLASH_SET_REGISTER_BITS(reg, mask, pos, mode)                     do                                                               {                                                                    (reg) = (((reg) & ((uint32) ~(uint32) (mask))) | ((uint32) ((uint32) (mode) << (pos))));                     }while(0)
N
N/* Set bit in the register */
N#define SPI_0_OLED_FLASH_SET_REGISTER_BIT(reg, mask, val) \
N                    ((val) ? ((reg) |= (mask)) : ((reg) &= ((uint32) ~((uint32) (mask)))))
X#define SPI_0_OLED_FLASH_SET_REGISTER_BIT(reg, mask, val)                     ((val) ? ((reg) |= (mask)) : ((reg) &= ((uint32) ~((uint32) (mask)))))
N
N#define SPI_0_OLED_FLASH_SET_HSIOM_SEL(reg, mask, pos, sel) SPI_0_OLED_FLASH_SET_REGISTER_BITS(reg, mask, pos, sel)
N#define SPI_0_OLED_FLASH_SET_INCFG_TYPE(reg, mask, pos, intType) \
N                                                        SPI_0_OLED_FLASH_SET_REGISTER_BITS(reg, mask, pos, intType)
X#define SPI_0_OLED_FLASH_SET_INCFG_TYPE(reg, mask, pos, intType)                                                         SPI_0_OLED_FLASH_SET_REGISTER_BITS(reg, mask, pos, intType)
N#define SPI_0_OLED_FLASH_SET_INP_DIS(reg, mask, val) SPI_0_OLED_FLASH_SET_REGISTER_BIT(reg, mask, val)
N
N/* SPI_0_OLED_FLASH_SET_I2C_SCL_DR(val) - Sets I2C SCL DR register.
N*  SPI_0_OLED_FLASH_SET_I2C_SCL_HSIOM_SEL(sel) - Sets I2C SCL HSIOM settings.
N*/
N/* SCB I2C: scl signal */
N#if (SPI_0_OLED_FLASH_CY_SCBIP_V0)
X#if ((2 == 0u))
S#if (SPI_0_OLED_FLASH_I2C_PINS)
S    #define SPI_0_OLED_FLASH_SET_I2C_SCL_DR(val) SPI_0_OLED_FLASH_scl_Write(val)
S
S    #define SPI_0_OLED_FLASH_SET_I2C_SCL_HSIOM_SEL(sel) \
S                          SPI_0_OLED_FLASH_SET_HSIOM_SEL(SPI_0_OLED_FLASH_SCL_HSIOM_REG,  \
S                                                         SPI_0_OLED_FLASH_SCL_HSIOM_MASK, \
S                                                         SPI_0_OLED_FLASH_SCL_HSIOM_POS,  \
S                                                         (sel))
X    #define SPI_0_OLED_FLASH_SET_I2C_SCL_HSIOM_SEL(sel)                           SPI_0_OLED_FLASH_SET_HSIOM_SEL(SPI_0_OLED_FLASH_SCL_HSIOM_REG,                                                           SPI_0_OLED_FLASH_SCL_HSIOM_MASK,                                                          SPI_0_OLED_FLASH_SCL_HSIOM_POS,                                                           (sel))
S    #define SPI_0_OLED_FLASH_WAIT_SCL_SET_HIGH  (0u == SPI_0_OLED_FLASH_scl_Read())
S
S/* Unconfigured SCB: scl signal */
S#elif (SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_PIN)
S    #define SPI_0_OLED_FLASH_SET_I2C_SCL_DR(val) \
S                            SPI_0_OLED_FLASH_uart_rx_wake_i2c_scl_spi_mosi_Write(val)
X    #define SPI_0_OLED_FLASH_SET_I2C_SCL_DR(val)                             SPI_0_OLED_FLASH_uart_rx_wake_i2c_scl_spi_mosi_Write(val)
S
S    #define SPI_0_OLED_FLASH_SET_I2C_SCL_HSIOM_SEL(sel) \
S                    SPI_0_OLED_FLASH_SET_HSIOM_SEL(SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_REG,  \
S                                                   SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_MASK, \
S                                                   SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_POS,  \
S                                                   (sel))
X    #define SPI_0_OLED_FLASH_SET_I2C_SCL_HSIOM_SEL(sel)                     SPI_0_OLED_FLASH_SET_HSIOM_SEL(SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_REG,                                                     SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_MASK,                                                    SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_POS,                                                     (sel))
S
S    #define SPI_0_OLED_FLASH_WAIT_SCL_SET_HIGH  (0u == SPI_0_OLED_FLASH_uart_rx_wake_i2c_scl_spi_mosi_Read())
S
S#elif (SPI_0_OLED_FLASH_RX_SCL_MOSI_PIN)
S    #define SPI_0_OLED_FLASH_SET_I2C_SCL_DR(val) \
S                            SPI_0_OLED_FLASH_uart_rx_i2c_scl_spi_mosi_Write(val)
X    #define SPI_0_OLED_FLASH_SET_I2C_SCL_DR(val)                             SPI_0_OLED_FLASH_uart_rx_i2c_scl_spi_mosi_Write(val)
S
S
S    #define SPI_0_OLED_FLASH_SET_I2C_SCL_HSIOM_SEL(sel) \
S                            SPI_0_OLED_FLASH_SET_HSIOM_SEL(SPI_0_OLED_FLASH_RX_SCL_MOSI_HSIOM_REG,  \
S                                                           SPI_0_OLED_FLASH_RX_SCL_MOSI_HSIOM_MASK, \
S                                                           SPI_0_OLED_FLASH_RX_SCL_MOSI_HSIOM_POS,  \
S                                                           (sel))
X    #define SPI_0_OLED_FLASH_SET_I2C_SCL_HSIOM_SEL(sel)                             SPI_0_OLED_FLASH_SET_HSIOM_SEL(SPI_0_OLED_FLASH_RX_SCL_MOSI_HSIOM_REG,                                                             SPI_0_OLED_FLASH_RX_SCL_MOSI_HSIOM_MASK,                                                            SPI_0_OLED_FLASH_RX_SCL_MOSI_HSIOM_POS,                                                             (sel))
S
S    #define SPI_0_OLED_FLASH_WAIT_SCL_SET_HIGH  (0u == SPI_0_OLED_FLASH_uart_rx_i2c_scl_spi_mosi_Read())
S
S#else
S    #define SPI_0_OLED_FLASH_SET_I2C_SCL_DR(val)        do{ /* Does nothing */ }while(0)
S    #define SPI_0_OLED_FLASH_SET_I2C_SCL_HSIOM_SEL(sel) do{ /* Does nothing */ }while(0)
S
S    #define SPI_0_OLED_FLASH_WAIT_SCL_SET_HIGH  (0u)
S#endif /* (SPI_0_OLED_FLASH_I2C_PINS) */
S
S/* SCB I2C: sda signal */
S#if (SPI_0_OLED_FLASH_I2C_PINS)
S    #define SPI_0_OLED_FLASH_WAIT_SDA_SET_HIGH  (0u == SPI_0_OLED_FLASH_sda_Read())
S/* Unconfigured SCB: sda signal */
S#elif (SPI_0_OLED_FLASH_TX_SDA_MISO_PIN)
S    #define SPI_0_OLED_FLASH_WAIT_SDA_SET_HIGH  (0u == SPI_0_OLED_FLASH_uart_tx_i2c_sda_spi_miso_Read())
S#else
S    #define SPI_0_OLED_FLASH_WAIT_SDA_SET_HIGH  (0u)
S#endif /* (SPI_0_OLED_FLASH_MOSI_SCL_RX_PIN) */
N#endif /* (SPI_0_OLED_FLASH_CY_SCBIP_V0) */
N
N/* Clear UART wakeup source */
N#if (SPI_0_OLED_FLASH_RX_SCL_MOSI_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_CLEAR_UART_RX_WAKE_INTR        do{ /* Does nothing */ }while(0)
S    
S#elif (SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_PIN)
X#elif ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_CLEAR_UART_RX_WAKE_INTR \
S            do{                                      \
S                (void) SPI_0_OLED_FLASH_uart_rx_wake_i2c_scl_spi_mosi_ClearInterrupt(); \
S            }while(0)
X    #define SPI_0_OLED_FLASH_CLEAR_UART_RX_WAKE_INTR             do{                                                      (void) SPI_0_OLED_FLASH_uart_rx_wake_i2c_scl_spi_mosi_ClearInterrupt();             }while(0)
S
S#elif(SPI_0_OLED_FLASH_UART_RX_WAKE_PIN)
X#elif((0u == (1u)))
S    #define SPI_0_OLED_FLASH_CLEAR_UART_RX_WAKE_INTR \
S            do{                                      \
S                (void) SPI_0_OLED_FLASH_rx_wake_ClearInterrupt(); \
S            }while(0)
X    #define SPI_0_OLED_FLASH_CLEAR_UART_RX_WAKE_INTR             do{                                                      (void) SPI_0_OLED_FLASH_rx_wake_ClearInterrupt();             }while(0)
N#else
N#endif /* (SPI_0_OLED_FLASH_RX_SCL_MOSI_PIN) */
N
N
N/***************************************
N* The following code is DEPRECATED and
N* must not be used.
N***************************************/
N
N/* Unconfigured pins */
N#define SPI_0_OLED_FLASH_REMOVE_MOSI_SCL_RX_WAKE_PIN    SPI_0_OLED_FLASH_REMOVE_RX_WAKE_SCL_MOSI_PIN
N#define SPI_0_OLED_FLASH_REMOVE_MOSI_SCL_RX_PIN         SPI_0_OLED_FLASH_REMOVE_RX_SCL_MOSI_PIN
N#define SPI_0_OLED_FLASH_REMOVE_MISO_SDA_TX_PIN         SPI_0_OLED_FLASH_REMOVE_TX_SDA_MISO_PIN
N#ifndef SPI_0_OLED_FLASH_REMOVE_SCLK_PIN
N#define SPI_0_OLED_FLASH_REMOVE_SCLK_PIN                SPI_0_OLED_FLASH_REMOVE_CTS_SCLK_PIN
N#endif /* SPI_0_OLED_FLASH_REMOVE_SCLK_PIN */
N#ifndef SPI_0_OLED_FLASH_REMOVE_SS0_PIN
N#define SPI_0_OLED_FLASH_REMOVE_SS0_PIN                 SPI_0_OLED_FLASH_REMOVE_RTS_SS0_PIN
N#endif /* SPI_0_OLED_FLASH_REMOVE_SS0_PIN */
N
N/* Unconfigured pins */
N#define SPI_0_OLED_FLASH_MOSI_SCL_RX_WAKE_PIN   SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_PIN
N#define SPI_0_OLED_FLASH_MOSI_SCL_RX_PIN        SPI_0_OLED_FLASH_RX_SCL_MOSI_PIN
N#define SPI_0_OLED_FLASH_MISO_SDA_TX_PIN        SPI_0_OLED_FLASH_TX_SDA_MISO_PIN
N#ifndef SPI_0_OLED_FLASH_SCLK_PIN
N#define SPI_0_OLED_FLASH_SCLK_PIN               SPI_0_OLED_FLASH_CTS_SCLK_PIN
N#endif /* SPI_0_OLED_FLASH_SCLK_PIN */
N#ifndef SPI_0_OLED_FLASH_SS0_PIN
N#define SPI_0_OLED_FLASH_SS0_PIN                SPI_0_OLED_FLASH_RTS_SS0_PIN
N#endif /* SPI_0_OLED_FLASH_SS0_PIN */
N
N#if (SPI_0_OLED_FLASH_MOSI_SCL_RX_WAKE_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_MOSI_SCL_RX_WAKE_HSIOM_REG     SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define SPI_0_OLED_FLASH_MOSI_SCL_RX_WAKE_HSIOM_PTR     SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define SPI_0_OLED_FLASH_MOSI_SCL_RX_WAKE_HSIOM_MASK    SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define SPI_0_OLED_FLASH_MOSI_SCL_RX_WAKE_HSIOM_POS     SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_REG
S
S    #define SPI_0_OLED_FLASH_MOSI_SCL_RX_WAKE_INTCFG_REG    SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define SPI_0_OLED_FLASH_MOSI_SCL_RX_WAKE_INTCFG_PTR    SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_REG
S
S    #define SPI_0_OLED_FLASH_MOSI_SCL_RX_WAKE_INTCFG_TYPE_POS   SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define SPI_0_OLED_FLASH_MOSI_SCL_RX_WAKE_INTCFG_TYPE_MASK  SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_HSIOM_REG
N#endif /* (SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_PIN) */
N
N#if (SPI_0_OLED_FLASH_MOSI_SCL_RX_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_MOSI_SCL_RX_HSIOM_REG      SPI_0_OLED_FLASH_RX_SCL_MOSI_HSIOM_REG
S    #define SPI_0_OLED_FLASH_MOSI_SCL_RX_HSIOM_PTR      SPI_0_OLED_FLASH_RX_SCL_MOSI_HSIOM_PTR
S    #define SPI_0_OLED_FLASH_MOSI_SCL_RX_HSIOM_MASK     SPI_0_OLED_FLASH_RX_SCL_MOSI_HSIOM_MASK
S    #define SPI_0_OLED_FLASH_MOSI_SCL_RX_HSIOM_POS      SPI_0_OLED_FLASH_RX_SCL_MOSI_HSIOM_POS
N#endif /* (SPI_0_OLED_FLASH_MOSI_SCL_RX_PIN) */
N
N#if (SPI_0_OLED_FLASH_MISO_SDA_TX_PIN)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_MISO_SDA_TX_HSIOM_REG      SPI_0_OLED_FLASH_TX_SDA_MISO_HSIOM_REG
S    #define SPI_0_OLED_FLASH_MISO_SDA_TX_HSIOM_PTR      SPI_0_OLED_FLASH_TX_SDA_MISO_HSIOM_REG
S    #define SPI_0_OLED_FLASH_MISO_SDA_TX_HSIOM_MASK     SPI_0_OLED_FLASH_TX_SDA_MISO_HSIOM_REG
S    #define SPI_0_OLED_FLASH_MISO_SDA_TX_HSIOM_POS      SPI_0_OLED_FLASH_TX_SDA_MISO_HSIOM_REG
N#endif /* (SPI_0_OLED_FLASH_MISO_SDA_TX_PIN_PIN) */
N
N#if (SPI_0_OLED_FLASH_SCLK_PIN)
X#if ((0u == (1u)))
S    #ifndef SPI_0_OLED_FLASH_SCLK_HSIOM_REG
S    #define SPI_0_OLED_FLASH_SCLK_HSIOM_REG     SPI_0_OLED_FLASH_CTS_SCLK_HSIOM_REG
S    #define SPI_0_OLED_FLASH_SCLK_HSIOM_PTR     SPI_0_OLED_FLASH_CTS_SCLK_HSIOM_PTR
S    #define SPI_0_OLED_FLASH_SCLK_HSIOM_MASK    SPI_0_OLED_FLASH_CTS_SCLK_HSIOM_MASK
S    #define SPI_0_OLED_FLASH_SCLK_HSIOM_POS     SPI_0_OLED_FLASH_CTS_SCLK_HSIOM_POS
S    #endif /* SPI_0_OLED_FLASH_SCLK_HSIOM_REG */
N#endif /* (SPI_0_OLED_FLASH_SCLK_PIN) */
N
N#if (SPI_0_OLED_FLASH_SS0_PIN)
X#if ((0u == (1u)))
S    #ifndef SPI_0_OLED_FLASH_SS0_HSIOM_REG
S    #define SPI_0_OLED_FLASH_SS0_HSIOM_REG      SPI_0_OLED_FLASH_RTS_SS0_HSIOM_REG
S    #define SPI_0_OLED_FLASH_SS0_HSIOM_PTR      SPI_0_OLED_FLASH_RTS_SS0_HSIOM_PTR
S    #define SPI_0_OLED_FLASH_SS0_HSIOM_MASK     SPI_0_OLED_FLASH_RTS_SS0_HSIOM_MASK
S    #define SPI_0_OLED_FLASH_SS0_HSIOM_POS      SPI_0_OLED_FLASH_RTS_SS0_HSIOM_POS
S    #endif /* SPI_0_OLED_FLASH_SS0_HSIOM_REG */
N#endif /* (SPI_0_OLED_FLASH_SS0_PIN) */
N
N#define SPI_0_OLED_FLASH_MOSI_SCL_RX_WAKE_PIN_INDEX SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_PIN_INDEX
N#define SPI_0_OLED_FLASH_MOSI_SCL_RX_PIN_INDEX      SPI_0_OLED_FLASH_RX_SCL_MOSI_PIN_INDEX
N#define SPI_0_OLED_FLASH_MISO_SDA_TX_PIN_INDEX      SPI_0_OLED_FLASH_TX_SDA_MISO_PIN_INDEX
N#ifndef SPI_0_OLED_FLASH_SCLK_PIN_INDEX
N#define SPI_0_OLED_FLASH_SCLK_PIN_INDEX             SPI_0_OLED_FLASH_CTS_SCLK_PIN_INDEX
N#endif /* SPI_0_OLED_FLASH_SCLK_PIN_INDEX */
N#ifndef SPI_0_OLED_FLASH_SS0_PIN_INDEX
N#define SPI_0_OLED_FLASH_SS0_PIN_INDEX              SPI_0_OLED_FLASH_RTS_SS0_PIN_INDEX
N#endif /* SPI_0_OLED_FLASH_SS0_PIN_INDEX */
N
N#define SPI_0_OLED_FLASH_MOSI_SCL_RX_WAKE_PIN_MASK SPI_0_OLED_FLASH_RX_WAKE_SCL_MOSI_PIN_MASK
N#define SPI_0_OLED_FLASH_MOSI_SCL_RX_PIN_MASK      SPI_0_OLED_FLASH_RX_SCL_MOSI_PIN_MASK
N#define SPI_0_OLED_FLASH_MISO_SDA_TX_PIN_MASK      SPI_0_OLED_FLASH_TX_SDA_MISO_PIN_MASK
N#ifndef SPI_0_OLED_FLASH_SCLK_PIN_MASK
N#define SPI_0_OLED_FLASH_SCLK_PIN_MASK             SPI_0_OLED_FLASH_CTS_SCLK_PIN_MASK
N#endif /* SPI_0_OLED_FLASH_SCLK_PIN_MASK */
N#ifndef SPI_0_OLED_FLASH_SS0_PIN_MASK
N#define SPI_0_OLED_FLASH_SS0_PIN_MASK              SPI_0_OLED_FLASH_RTS_SS0_PIN_MASK
N#endif /* SPI_0_OLED_FLASH_SS0_PIN_MASK */
N
N#endif /* (CY_SCB_PINS_SPI_0_OLED_FLASH_H) */
N
N
N/* [] END OF FILE */
L 86 "Generated_Source\PSoC4\SPI_0_OLED_FLASH.h" 2
N
N#if (SPI_0_OLED_FLASH_SCB_CLK_INTERNAL)
X#if ((0u == (0u)))
N    #include "SPI_0_OLED_FLASH_SCBCLK.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_SCBCLK.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_SCBCLK.h
N* Version 2.20
N*
N*  Description:
N*   Provides the function and constant definitions for the clock component.
N*
N*  Note:
N*
N********************************************************************************
N* Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_CLOCK_SPI_0_OLED_FLASH_SCBCLK_H)
X#if !0L
N#define CY_CLOCK_SPI_0_OLED_FLASH_SCBCLK_H
N
N#include <cytypes.h>
N#include <cyfitter.h>
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N#if defined CYREG_PERI_DIV_CMD
X#if 1L
N
Nvoid SPI_0_OLED_FLASH_SCBCLK_StartEx(uint32 alignClkDiv);
N#define SPI_0_OLED_FLASH_SCBCLK_Start() \
N    SPI_0_OLED_FLASH_SCBCLK_StartEx(SPI_0_OLED_FLASH_SCBCLK__PA_DIV_ID)
X#define SPI_0_OLED_FLASH_SCBCLK_Start()     SPI_0_OLED_FLASH_SCBCLK_StartEx(SPI_0_OLED_FLASH_SCBCLK__PA_DIV_ID)
N
N#else
S
Svoid SPI_0_OLED_FLASH_SCBCLK_Start(void);
S
N#endif/* CYREG_PERI_DIV_CMD */
N
Nvoid SPI_0_OLED_FLASH_SCBCLK_Stop(void);
N
Nvoid SPI_0_OLED_FLASH_SCBCLK_SetFractionalDividerRegister(uint16 clkDivider, uint8 clkFractional);
N
Nuint16 SPI_0_OLED_FLASH_SCBCLK_GetDividerRegister(void);
Nuint8  SPI_0_OLED_FLASH_SCBCLK_GetFractionalDividerRegister(void);
N
N#define SPI_0_OLED_FLASH_SCBCLK_Enable()                         SPI_0_OLED_FLASH_SCBCLK_Start()
N#define SPI_0_OLED_FLASH_SCBCLK_Disable()                        SPI_0_OLED_FLASH_SCBCLK_Stop()
N#define SPI_0_OLED_FLASH_SCBCLK_SetDividerRegister(clkDivider, reset)  \
N    SPI_0_OLED_FLASH_SCBCLK_SetFractionalDividerRegister((clkDivider), 0u)
X#define SPI_0_OLED_FLASH_SCBCLK_SetDividerRegister(clkDivider, reset)      SPI_0_OLED_FLASH_SCBCLK_SetFractionalDividerRegister((clkDivider), 0u)
N#define SPI_0_OLED_FLASH_SCBCLK_SetDivider(clkDivider)           SPI_0_OLED_FLASH_SCBCLK_SetDividerRegister((clkDivider), 1u)
N#define SPI_0_OLED_FLASH_SCBCLK_SetDividerValue(clkDivider)      SPI_0_OLED_FLASH_SCBCLK_SetDividerRegister((clkDivider) - 1u, 1u)
N
N
N/***************************************
N*             Registers
N***************************************/
N#if defined CYREG_PERI_DIV_CMD
X#if 1L
N
N#define SPI_0_OLED_FLASH_SCBCLK_DIV_ID     SPI_0_OLED_FLASH_SCBCLK__DIV_ID
N
N#define SPI_0_OLED_FLASH_SCBCLK_CMD_REG    (*(reg32 *)CYREG_PERI_DIV_CMD)
N#define SPI_0_OLED_FLASH_SCBCLK_CTRL_REG   (*(reg32 *)SPI_0_OLED_FLASH_SCBCLK__CTRL_REGISTER)
N#define SPI_0_OLED_FLASH_SCBCLK_DIV_REG    (*(reg32 *)SPI_0_OLED_FLASH_SCBCLK__DIV_REGISTER)
N
N#define SPI_0_OLED_FLASH_SCBCLK_CMD_DIV_SHIFT          (0u)
N#define SPI_0_OLED_FLASH_SCBCLK_CMD_PA_DIV_SHIFT       (8u)
N#define SPI_0_OLED_FLASH_SCBCLK_CMD_DISABLE_SHIFT      (30u)
N#define SPI_0_OLED_FLASH_SCBCLK_CMD_ENABLE_SHIFT       (31u)
N
N#define SPI_0_OLED_FLASH_SCBCLK_CMD_DISABLE_MASK       ((uint32)((uint32)1u << SPI_0_OLED_FLASH_SCBCLK_CMD_DISABLE_SHIFT))
N#define SPI_0_OLED_FLASH_SCBCLK_CMD_ENABLE_MASK        ((uint32)((uint32)1u << SPI_0_OLED_FLASH_SCBCLK_CMD_ENABLE_SHIFT))
N
N#define SPI_0_OLED_FLASH_SCBCLK_DIV_FRAC_MASK  (0x000000F8u)
N#define SPI_0_OLED_FLASH_SCBCLK_DIV_FRAC_SHIFT (3u)
N#define SPI_0_OLED_FLASH_SCBCLK_DIV_INT_MASK   (0xFFFFFF00u)
N#define SPI_0_OLED_FLASH_SCBCLK_DIV_INT_SHIFT  (8u)
N
N#else 
S
S#define SPI_0_OLED_FLASH_SCBCLK_DIV_REG        (*(reg32 *)SPI_0_OLED_FLASH_SCBCLK__REGISTER)
S#define SPI_0_OLED_FLASH_SCBCLK_ENABLE_REG     SPI_0_OLED_FLASH_SCBCLK_DIV_REG
S#define SPI_0_OLED_FLASH_SCBCLK_DIV_FRAC_MASK  SPI_0_OLED_FLASH_SCBCLK__FRAC_MASK
S#define SPI_0_OLED_FLASH_SCBCLK_DIV_FRAC_SHIFT (16u)
S#define SPI_0_OLED_FLASH_SCBCLK_DIV_INT_MASK   SPI_0_OLED_FLASH_SCBCLK__DIVIDER_MASK
S#define SPI_0_OLED_FLASH_SCBCLK_DIV_INT_SHIFT  (0u)
S
N#endif/* CYREG_PERI_DIV_CMD */
N
N#endif /* !defined(CY_CLOCK_SPI_0_OLED_FLASH_SCBCLK_H) */
N
N/* [] END OF FILE */
L 89 "Generated_Source\PSoC4\SPI_0_OLED_FLASH.h" 2
N#endif /* (SPI_0_OLED_FLASH_SCB_CLK_INTERNAL) */
N
N
N/***************************************
N*       Type Definitions
N***************************************/
N
Ntypedef struct
N{
N    uint8 enableState;
N} SPI_0_OLED_FLASH_BACKUP_STRUCT;
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
N/**
N* \addtogroup group_general
N* @{
N*/
N
N/* Start and Stop APIs */
Nvoid SPI_0_OLED_FLASH_Init(void);
Nvoid SPI_0_OLED_FLASH_Enable(void);
Nvoid SPI_0_OLED_FLASH_Start(void);
Nvoid SPI_0_OLED_FLASH_Stop(void);
N
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
N/* Sleep and Wakeup APis */
Nvoid SPI_0_OLED_FLASH_Sleep(void);
Nvoid SPI_0_OLED_FLASH_Wakeup(void);
N/** @} power */ 
N
N/**
N* \addtogroup group_interrupt
N* @{
N*/
N#if (SPI_0_OLED_FLASH_SCB_IRQ_INTERNAL)
X#if ((0u == (1u)))
S    /* Custom interrupt handler */
S    void SPI_0_OLED_FLASH_SetCustomInterruptHandler(void (*func)(void));
N#endif /* (SPI_0_OLED_FLASH_SCB_IRQ_INTERNAL) */
N/** @} interrupt */
N
N/* Interface to internal interrupt component */
N#if (SPI_0_OLED_FLASH_SCB_IRQ_INTERNAL)
X#if ((0u == (1u)))
S    /**
S    * \addtogroup group_interrupt
S    * @{
S    */    
S    /*******************************************************************************
S    * Function Name: SPI_0_OLED_FLASH_EnableInt
S    ****************************************************************************//**
S    *
S    *  When using an Internal interrupt, this enables the interrupt in the NVIC. 
S    *  When using an external interrupt the API for the interrupt component must 
S    *  be used to enable the interrupt.
S    *
S    *******************************************************************************/
S    #define SPI_0_OLED_FLASH_EnableInt()    CyIntEnable(SPI_0_OLED_FLASH_ISR_NUMBER)
S    
S    
S    /*******************************************************************************
S    * Function Name: SPI_0_OLED_FLASH_DisableInt
S    ****************************************************************************//**
S    *
S    *  When using an Internal interrupt, this disables the interrupt in the NVIC. 
S    *  When using an external interrupt the API for the interrupt component must 
S    *  be used to disable the interrupt.
S    *
S    *******************************************************************************/    
S    #define SPI_0_OLED_FLASH_DisableInt()   CyIntDisable(SPI_0_OLED_FLASH_ISR_NUMBER)
S    /** @} interrupt */
S
S    /*******************************************************************************
S    * Function Name: SPI_0_OLED_FLASH_ClearPendingInt
S    ****************************************************************************//**
S    *
S    *  This function clears the interrupt pending status in the NVIC. 
S    *
S    *******************************************************************************/
S    #define SPI_0_OLED_FLASH_ClearPendingInt()  CyIntClearPending(SPI_0_OLED_FLASH_ISR_NUMBER)
N#endif /* (SPI_0_OLED_FLASH_SCB_IRQ_INTERNAL) */
N
N#if (SPI_0_OLED_FLASH_UART_RX_WAKEUP_IRQ)
X#if ((0u == (1u)))
S    /*******************************************************************************
S    * Function Name: SPI_0_OLED_FLASH_RxWakeEnableInt
S    ****************************************************************************//**
S    *
S    *  This function enables the interrupt (RX_WAKE) pending status in the NVIC. 
S    *
S    *******************************************************************************/    
S    #define SPI_0_OLED_FLASH_RxWakeEnableInt()  CyIntEnable(SPI_0_OLED_FLASH_RX_WAKE_ISR_NUMBER)
S    
S
S    /*******************************************************************************
S    * Function Name: SPI_0_OLED_FLASH_RxWakeDisableInt
S    ****************************************************************************//**
S    *
S    *  This function disables the interrupt (RX_WAKE) pending status in the NVIC.  
S    *
S    *******************************************************************************/
S    #define SPI_0_OLED_FLASH_RxWakeDisableInt() CyIntDisable(SPI_0_OLED_FLASH_RX_WAKE_ISR_NUMBER)
S    
S    
S    /*******************************************************************************
S    * Function Name: SPI_0_OLED_FLASH_RxWakeClearPendingInt
S    ****************************************************************************//**
S    *
S    *  This function clears the interrupt (RX_WAKE) pending status in the NVIC. 
S    *
S    *******************************************************************************/    
S    #define SPI_0_OLED_FLASH_RxWakeClearPendingInt()  CyIntClearPending(SPI_0_OLED_FLASH_RX_WAKE_ISR_NUMBER)
N#endif /* (SPI_0_OLED_FLASH_UART_RX_WAKEUP_IRQ) */
N
N/**
N* \addtogroup group_interrupt
N* @{
N*/
N/* Get interrupt cause */
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_GetInterruptCause
N****************************************************************************//**
N*
N*  Returns a mask of bits showing the source of the current triggered interrupt. 
N*  This is useful for modes of operation where an interrupt can be generated by 
N*  conditions in multiple interrupt source registers.
N*
N*  \return
N*   Mask with the OR of the following conditions that have been triggered.
N*    - SPI_0_OLED_FLASH_INTR_CAUSE_MASTER - Interrupt from Master
N*    - SPI_0_OLED_FLASH_INTR_CAUSE_SLAVE - Interrupt from Slave
N*    - SPI_0_OLED_FLASH_INTR_CAUSE_TX - Interrupt from TX
N*    - SPI_0_OLED_FLASH_INTR_CAUSE_RX - Interrupt from RX
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_GetInterruptCause()    (SPI_0_OLED_FLASH_INTR_CAUSE_REG)
N
N
N/* APIs to service INTR_RX register */
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_GetRxInterruptSource
N****************************************************************************//**
N*
N*  Returns RX interrupt request register. This register contains current status 
N*  of RX interrupt sources.
N*
N*  \return
N*   Current status of RX interrupt sources.
N*   Each constant is a bit field value. The value returned may have multiple 
N*   bits set to indicate the current status.
N*   - SPI_0_OLED_FLASH_INTR_RX_FIFO_LEVEL - The number of data elements in the 
N      RX FIFO is greater than the value of RX FIFO level.
N*   - SPI_0_OLED_FLASH_INTR_RX_NOT_EMPTY - Receiver FIFO is not empty.
N*   - SPI_0_OLED_FLASH_INTR_RX_FULL - Receiver FIFO is full.
N*   - SPI_0_OLED_FLASH_INTR_RX_OVERFLOW - Attempt to write to a full 
N*     receiver FIFO.
N*   - SPI_0_OLED_FLASH_INTR_RX_UNDERFLOW - Attempt to read from an empty 
N*     receiver FIFO.
N*   - SPI_0_OLED_FLASH_INTR_RX_FRAME_ERROR - UART framing error detected.
N*   - SPI_0_OLED_FLASH_INTR_RX_PARITY_ERROR - UART parity error detected.
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_GetRxInterruptSource() (SPI_0_OLED_FLASH_INTR_RX_REG)
N
N
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_SetRxInterruptMode
N****************************************************************************//**
N*
N*  Writes RX interrupt mask register. This register configures which bits from 
N*  RX interrupt request register will trigger an interrupt event.
N*
N*  \param interruptMask: RX interrupt sources to be enabled (refer to 
N*   SPI_0_OLED_FLASH_GetRxInterruptSource() function for bit fields values).
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_SetRxInterruptMode(interruptMask)     SPI_0_OLED_FLASH_WRITE_INTR_RX_MASK(interruptMask)
N
N
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_GetRxInterruptMode
N****************************************************************************//**
N*
N*  Returns RX interrupt mask register This register specifies which bits from 
N*  RX interrupt request register will trigger an interrupt event.
N*
N*  \return 
N*   RX interrupt sources to be enabled (refer to 
N*   SPI_0_OLED_FLASH_GetRxInterruptSource() function for bit fields values).
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_GetRxInterruptMode()   (SPI_0_OLED_FLASH_INTR_RX_MASK_REG)
N
N
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_GetRxInterruptSourceMasked
N****************************************************************************//**
N*
N*  Returns RX interrupt masked request register. This register contains logical
N*  AND of corresponding bits from RX interrupt request and mask registers.
N*  This function is intended to be used in the interrupt service routine to 
N*  identify which of enabled RX interrupt sources cause interrupt event.
N*
N*  \return 
N*   Current status of enabled RX interrupt sources (refer to 
N*   SPI_0_OLED_FLASH_GetRxInterruptSource() function for bit fields values).
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_GetRxInterruptSourceMasked()   (SPI_0_OLED_FLASH_INTR_RX_MASKED_REG)
N
N
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_ClearRxInterruptSource
N****************************************************************************//**
N*
N*  Clears RX interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: RX interrupt sources to be cleared (refer to 
N*   SPI_0_OLED_FLASH_GetRxInterruptSource() function for bit fields values).
N*
N*  \sideeffects 
N*   The side effects are listed in the table below for each 
N*   affected interrupt source. Refer to section RX FIFO interrupt sources for 
N*   detailed description.
N*   - SPI_0_OLED_FLASH_INTR_RX_FIFO_LEVEL Interrupt source is not cleared when 
N*     the receiver FIFO has more entries than level.
N*   - SPI_0_OLED_FLASH_INTR_RX_NOT_EMPTY Interrupt source is not cleared when
N*     receiver FIFO is not empty.
N*   - SPI_0_OLED_FLASH_INTR_RX_FULL Interrupt source is not cleared when 
N*      receiver FIFO is full.
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_ClearRxInterruptSource(interruptMask)  SPI_0_OLED_FLASH_CLEAR_INTR_RX(interruptMask)
N
N
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_SetRxInterrupt
N****************************************************************************//**
N*
N*  Sets RX interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: RX interrupt sources to set in the RX interrupt request 
N*   register (refer to SPI_0_OLED_FLASH_GetRxInterruptSource() function for bit 
N*   fields values).
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_SetRxInterrupt(interruptMask)  SPI_0_OLED_FLASH_SET_INTR_RX(interruptMask)
N
Nvoid SPI_0_OLED_FLASH_SetRxFifoLevel(uint32 level);
N
N
N/* APIs to service INTR_TX register */
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_GetTxInterruptSource
N****************************************************************************//**
N*
N*  Returns TX interrupt request register. This register contains current status 
N*  of TX interrupt sources.
N* 
N*  \return 
N*   Current status of TX interrupt sources.
N*   Each constant is a bit field value. The value returned may have multiple 
N*   bits set to indicate the current status.
N*   - SPI_0_OLED_FLASH_INTR_TX_FIFO_LEVEL - The number of data elements in the 
N*     TX FIFO is less than the value of TX FIFO level.
N*   - SPI_0_OLED_FLASH_INTR_TX_NOT_FULL - Transmitter FIFO is not full.
N*   - SPI_0_OLED_FLASH_INTR_TX_EMPTY - Transmitter FIFO is empty.
N*   - SPI_0_OLED_FLASH_INTR_TX_OVERFLOW - Attempt to write to a full 
N*     transmitter FIFO.
N*   - SPI_0_OLED_FLASH_INTR_TX_UNDERFLOW - Attempt to read from an empty 
N*     transmitter FIFO.
N*   - SPI_0_OLED_FLASH_INTR_TX_UART_NACK - UART received a NACK in SmartCard 
N*   mode.
N*   - SPI_0_OLED_FLASH_INTR_TX_UART_DONE - UART transfer is complete. 
N*     All data elements from the TX FIFO are sent.
N*   - SPI_0_OLED_FLASH_INTR_TX_UART_ARB_LOST - Value on the TX line of the UART
N*     does not match the value on the RX line.
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_GetTxInterruptSource() (SPI_0_OLED_FLASH_INTR_TX_REG)
N
N
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_SetTxInterruptMode
N****************************************************************************//**
N*
N*  Writes TX interrupt mask register. This register configures which bits from 
N*  TX interrupt request register will trigger an interrupt event.
N*
N*  \param interruptMask: TX interrupt sources to be enabled (refer to 
N*   SPI_0_OLED_FLASH_GetTxInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_SetTxInterruptMode(interruptMask)  SPI_0_OLED_FLASH_WRITE_INTR_TX_MASK(interruptMask)
N
N
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_GetTxInterruptMode
N****************************************************************************//**
N*
N*  Returns TX interrupt mask register This register specifies which bits from 
N*  TX interrupt request register will trigger an interrupt event.
N*
N*  \return 
N*   Enabled TX interrupt sources (refer to 
N*   SPI_0_OLED_FLASH_GetTxInterruptSource() function for bit field values).
N*   
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_GetTxInterruptMode()   (SPI_0_OLED_FLASH_INTR_TX_MASK_REG)
N
N
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_GetTxInterruptSourceMasked
N****************************************************************************//**
N*
N*  Returns TX interrupt masked request register. This register contains logical
N*  AND of corresponding bits from TX interrupt request and mask registers.
N*  This function is intended to be used in the interrupt service routine to identify 
N*  which of enabled TX interrupt sources cause interrupt event.
N*
N*  \return 
N*   Current status of enabled TX interrupt sources (refer to 
N*   SPI_0_OLED_FLASH_GetTxInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_GetTxInterruptSourceMasked()   (SPI_0_OLED_FLASH_INTR_TX_MASKED_REG)
N
N
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_ClearTxInterruptSource
N****************************************************************************//**
N*
N*  Clears TX interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: TX interrupt sources to be cleared (refer to 
N*   SPI_0_OLED_FLASH_GetTxInterruptSource() function for bit field values).
N*
N*  \sideeffects 
N*   The side effects are listed in the table below for each affected interrupt 
N*   source. Refer to section TX FIFO interrupt sources for detailed description.
N*   - SPI_0_OLED_FLASH_INTR_TX_FIFO_LEVEL - Interrupt source is not cleared when 
N*     transmitter FIFO has less entries than level.
N*   - SPI_0_OLED_FLASH_INTR_TX_NOT_FULL - Interrupt source is not cleared when
N*     transmitter FIFO has empty entries.
N*   - SPI_0_OLED_FLASH_INTR_TX_EMPTY - Interrupt source is not cleared when 
N*     transmitter FIFO is empty.
N*   - SPI_0_OLED_FLASH_INTR_TX_UNDERFLOW - Interrupt source is not cleared when 
N*     transmitter FIFO is empty and I2C mode with clock stretching is selected. 
N*     Put data into the transmitter FIFO before clearing it. This behavior only 
N*     applicable for PSoC 4100/PSoC 4200 devices.
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_ClearTxInterruptSource(interruptMask)  SPI_0_OLED_FLASH_CLEAR_INTR_TX(interruptMask)
N
N
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_SetTxInterrupt
N****************************************************************************//**
N*
N*  Sets RX interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: RX interrupt sources to set in the RX interrupt request 
N*   register (refer to SPI_0_OLED_FLASH_GetRxInterruptSource() function for bit 
N*   fields values).
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_SetTxInterrupt(interruptMask)  SPI_0_OLED_FLASH_SET_INTR_TX(interruptMask)
N
Nvoid SPI_0_OLED_FLASH_SetTxFifoLevel(uint32 level);
N
N
N/* APIs to service INTR_MASTER register */
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_GetMasterInterruptSource
N****************************************************************************//**
N*
N*  Returns Master interrupt request register. This register contains current 
N*  status of Master interrupt sources.
N*
N*  \return 
N*   Current status of Master interrupt sources. 
N*   Each constant is a bit field value. The value returned may have multiple 
N*   bits set to indicate the current status.
N*   - SPI_0_OLED_FLASH_INTR_MASTER_SPI_DONE - SPI master transfer is complete.
N*     Refer to Interrupt sources section for detailed description.
N*   - SPI_0_OLED_FLASH_INTR_MASTER_I2C_ARB_LOST - I2C master lost arbitration.
N*   - SPI_0_OLED_FLASH_INTR_MASTER_I2C_NACK - I2C master received negative 
N*    acknowledgement (NAK).
N*   - SPI_0_OLED_FLASH_INTR_MASTER_I2C_ACK - I2C master received acknowledgement.
N*   - SPI_0_OLED_FLASH_INTR_MASTER_I2C_STOP - I2C master generated STOP.
N*   - SPI_0_OLED_FLASH_INTR_MASTER_I2C_BUS_ERROR - I2C master bus error 
N*     (detection of unexpected START or STOP condition).
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_GetMasterInterruptSource() (SPI_0_OLED_FLASH_INTR_MASTER_REG)
N
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_SetMasterInterruptMode
N****************************************************************************//**
N*
N*  Writes Master interrupt mask register. This register configures which bits 
N*  from Master interrupt request register will trigger an interrupt event.
N*
N*  \param interruptMask: Master interrupt sources to be enabled (refer to 
N*   SPI_0_OLED_FLASH_GetMasterInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_SetMasterInterruptMode(interruptMask)  SPI_0_OLED_FLASH_WRITE_INTR_MASTER_MASK(interruptMask)
N
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_GetMasterInterruptMode
N****************************************************************************//**
N*
N*  Returns Master interrupt mask register This register specifies which bits 
N*  from Master interrupt request register will trigger an interrupt event.
N*
N*  \return 
N*   Enabled Master interrupt sources (refer to 
N*   SPI_0_OLED_FLASH_GetMasterInterruptSource() function for return values).
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_GetMasterInterruptMode()   (SPI_0_OLED_FLASH_INTR_MASTER_MASK_REG)
N
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_GetMasterInterruptSourceMasked
N****************************************************************************//**
N*
N*  Returns Master interrupt masked request register. This register contains 
N*  logical AND of corresponding bits from Master interrupt request and mask 
N*  registers.
N*  This function is intended to be used in the interrupt service routine to 
N*  identify which of enabled Master interrupt sources cause interrupt event.
N*
N*  \return 
N*   Current status of enabled Master interrupt sources (refer to 
N*   SPI_0_OLED_FLASH_GetMasterInterruptSource() function for return values).
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_GetMasterInterruptSourceMasked()   (SPI_0_OLED_FLASH_INTR_MASTER_MASKED_REG)
N
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_ClearMasterInterruptSource
N****************************************************************************//**
N*
N*  Clears Master interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: Master interrupt sources to be cleared (refer to 
N*   SPI_0_OLED_FLASH_GetMasterInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_ClearMasterInterruptSource(interruptMask)  SPI_0_OLED_FLASH_CLEAR_INTR_MASTER(interruptMask)
N
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_SetMasterInterrupt
N****************************************************************************//**
N*
N*  Sets Master interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: Master interrupt sources to set in the Master interrupt
N*   request register (refer to SPI_0_OLED_FLASH_GetMasterInterruptSource() 
N*   function for bit field values).
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_SetMasterInterrupt(interruptMask)  SPI_0_OLED_FLASH_SET_INTR_MASTER(interruptMask)
N
N
N/* APIs to service INTR_SLAVE register */
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_GetSlaveInterruptSource
N****************************************************************************//**
N*
N*  Returns Slave interrupt request register. This register contains current 
N*  status of Slave interrupt sources.
N*
N*  \return 
N*   Current status of Slave interrupt sources.
N*   Each constant is a bit field value. The value returned may have multiple 
N*   bits set to indicate the current status.
N*   - SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ARB_LOST - I2C slave lost arbitration: 
N*     the value driven on the SDA line is not the same as the value observed 
N*     on the SDA line.
N*   - SPI_0_OLED_FLASH_INTR_SLAVE_I2C_NACK - I2C slave received negative 
N*     acknowledgement (NAK).
N*   - SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ACK - I2C slave received 
N*     acknowledgement (ACK).
N*   - SPI_0_OLED_FLASH_INTR_SLAVE_I2C_WRITE_STOP - Stop or Repeated Start 
N*     event for write transfer intended for this slave (address matching 
N*     is performed).
N*   - SPI_0_OLED_FLASH_INTR_SLAVE_I2C_STOP - Stop or Repeated Start event 
N*     for (read or write) transfer intended for this slave (address matching 
N*     is performed).
N*   - SPI_0_OLED_FLASH_INTR_SLAVE_I2C_START - I2C slave received Start 
N*     condition.
N*   - SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ADDR_MATCH - I2C slave received matching 
N*     address.
N*   - SPI_0_OLED_FLASH_INTR_SLAVE_I2C_GENERAL - I2C Slave received general 
N*     call address.
N*   - SPI_0_OLED_FLASH_INTR_SLAVE_I2C_BUS_ERROR - I2C slave bus error (detection 
N*      of unexpected Start or Stop condition).
N*   - SPI_0_OLED_FLASH_INTR_SLAVE_SPI_BUS_ERROR - SPI slave select line is 
N*      deselected at an expected time while the SPI transfer.
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_GetSlaveInterruptSource()  (SPI_0_OLED_FLASH_INTR_SLAVE_REG)
N
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_SetSlaveInterruptMode
N****************************************************************************//**
N*
N*  Writes Slave interrupt mask register. 
N*  This register configures which bits from Slave interrupt request register 
N*  will trigger an interrupt event.
N*
N*  \param interruptMask: Slave interrupt sources to be enabled (refer to 
N*   SPI_0_OLED_FLASH_GetSlaveInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_SetSlaveInterruptMode(interruptMask)   SPI_0_OLED_FLASH_WRITE_INTR_SLAVE_MASK(interruptMask)
N
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_GetSlaveInterruptMode
N****************************************************************************//**
N*
N*  Returns Slave interrupt mask register.
N*  This register specifies which bits from Slave interrupt request register 
N*  will trigger an interrupt event.
N*
N*  \return 
N*   Enabled Slave interrupt sources(refer to 
N*   SPI_0_OLED_FLASH_GetSlaveInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_GetSlaveInterruptMode()    (SPI_0_OLED_FLASH_INTR_SLAVE_MASK_REG)
N
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_GetSlaveInterruptSourceMasked
N****************************************************************************//**
N*
N*  Returns Slave interrupt masked request register. This register contains 
N*  logical AND of corresponding bits from Slave interrupt request and mask 
N*  registers.
N*  This function is intended to be used in the interrupt service routine to 
N*  identify which of enabled Slave interrupt sources cause interrupt event.
N*
N*  \return 
N*   Current status of enabled Slave interrupt sources (refer to 
N*   SPI_0_OLED_FLASH_GetSlaveInterruptSource() function for return values).
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_GetSlaveInterruptSourceMasked()    (SPI_0_OLED_FLASH_INTR_SLAVE_MASKED_REG)
N
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_ClearSlaveInterruptSource
N****************************************************************************//**
N*
N*  Clears Slave interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: Slave interrupt sources to be cleared (refer to 
N*   SPI_0_OLED_FLASH_GetSlaveInterruptSource() function for return values).
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_ClearSlaveInterruptSource(interruptMask)   SPI_0_OLED_FLASH_CLEAR_INTR_SLAVE(interruptMask)
N
N/*******************************************************************************
N* Function Name: SPI_0_OLED_FLASH_SetSlaveInterrupt
N****************************************************************************//**
N*
N*  Sets Slave interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: Slave interrupt sources to set in the Slave interrupt 
N*   request register (refer to SPI_0_OLED_FLASH_GetSlaveInterruptSource() 
N*   function for return values).
N*
N*******************************************************************************/
N#define SPI_0_OLED_FLASH_SetSlaveInterrupt(interruptMask)   SPI_0_OLED_FLASH_SET_INTR_SLAVE(interruptMask)
N
N/** @} interrupt */ 
N
N
N/***************************************
N*     Vars with External Linkage
N***************************************/
N
N/**
N* \addtogroup group_globals
N* @{
N*/
N
N/** SPI_0_OLED_FLASH_initVar indicates whether the SPI_0_OLED_FLASH 
N*  component has been initialized. The variable is initialized to 0 
N*  and set to 1 the first time SCB_Start() is called. This allows 
N*  the component to restart without reinitialization after the first 
N*  call to the SPI_0_OLED_FLASH_Start() routine.
N*
N*  If re-initialization of the component is required, then the 
N*  SPI_0_OLED_FLASH_Init() function can be called before the 
N*  SPI_0_OLED_FLASH_Start() or SPI_0_OLED_FLASH_Enable() function.
N*/
Nextern uint8 SPI_0_OLED_FLASH_initVar;
N/** @} globals */
N
N/***************************************
N*              Registers
N***************************************/
N
N#define SPI_0_OLED_FLASH_CTRL_REG               (*(reg32 *) SPI_0_OLED_FLASH_SCB__CTRL)
N#define SPI_0_OLED_FLASH_CTRL_PTR               ( (reg32 *) SPI_0_OLED_FLASH_SCB__CTRL)
N
N#define SPI_0_OLED_FLASH_STATUS_REG             (*(reg32 *) SPI_0_OLED_FLASH_SCB__STATUS)
N#define SPI_0_OLED_FLASH_STATUS_PTR             ( (reg32 *) SPI_0_OLED_FLASH_SCB__STATUS)
N
N#if (!SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_0_OLED_FLASH_SPI_CTRL_REG           (*(reg32 *) SPI_0_OLED_FLASH_SCB__SPI_CTRL)
N    #define SPI_0_OLED_FLASH_SPI_CTRL_PTR           ( (reg32 *) SPI_0_OLED_FLASH_SCB__SPI_CTRL)
N
N    #define SPI_0_OLED_FLASH_SPI_STATUS_REG         (*(reg32 *) SPI_0_OLED_FLASH_SCB__SPI_STATUS)
N    #define SPI_0_OLED_FLASH_SPI_STATUS_PTR         ( (reg32 *) SPI_0_OLED_FLASH_SCB__SPI_STATUS)
N
N    #define SPI_0_OLED_FLASH_UART_CTRL_REG          (*(reg32 *) SPI_0_OLED_FLASH_SCB__UART_CTRL)
N    #define SPI_0_OLED_FLASH_UART_CTRL_PTR          ( (reg32 *) SPI_0_OLED_FLASH_SCB__UART_CTRL)
N
N    #define SPI_0_OLED_FLASH_UART_TX_CTRL_REG       (*(reg32 *) SPI_0_OLED_FLASH_SCB__UART_TX_CTRL)
N    #define SPI_0_OLED_FLASH_UART_TX_CTRL_PTR       ( (reg32 *) SPI_0_OLED_FLASH_SCB__UART_TX_CTRL)
N
N    #define SPI_0_OLED_FLASH_UART_RX_CTRL_REG       (*(reg32 *) SPI_0_OLED_FLASH_SCB__UART_RX_CTRL)
N    #define SPI_0_OLED_FLASH_UART_RX_CTRL_PTR       ( (reg32 *) SPI_0_OLED_FLASH_SCB__UART_RX_CTRL)
N
N    #define SPI_0_OLED_FLASH_UART_RX_STATUS_REG     (*(reg32 *) SPI_0_OLED_FLASH_SCB__UART_RX_STATUS)
N    #define SPI_0_OLED_FLASH_UART_RX_STATUS_PTR     ( (reg32 *) SPI_0_OLED_FLASH_SCB__UART_RX_STATUS)
N#endif /* (!SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N
N#if !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define SPI_0_OLED_FLASH_UART_FLOW_CTRL_REG     (*(reg32 *) SPI_0_OLED_FLASH_SCB__UART_FLOW_CTRL)
N    #define SPI_0_OLED_FLASH_UART_FLOW_CTRL_PTR     ( (reg32 *) SPI_0_OLED_FLASH_SCB__UART_FLOW_CTRL)
N#endif /* !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N
N#define SPI_0_OLED_FLASH_I2C_CTRL_REG           (*(reg32 *) SPI_0_OLED_FLASH_SCB__I2C_CTRL)
N#define SPI_0_OLED_FLASH_I2C_CTRL_PTR           ( (reg32 *) SPI_0_OLED_FLASH_SCB__I2C_CTRL)
N
N#define SPI_0_OLED_FLASH_I2C_STATUS_REG         (*(reg32 *) SPI_0_OLED_FLASH_SCB__I2C_STATUS)
N#define SPI_0_OLED_FLASH_I2C_STATUS_PTR         ( (reg32 *) SPI_0_OLED_FLASH_SCB__I2C_STATUS)
N
N#define SPI_0_OLED_FLASH_I2C_MASTER_CMD_REG     (*(reg32 *) SPI_0_OLED_FLASH_SCB__I2C_M_CMD)
N#define SPI_0_OLED_FLASH_I2C_MASTER_CMD_PTR     ( (reg32 *) SPI_0_OLED_FLASH_SCB__I2C_M_CMD)
N
N#define SPI_0_OLED_FLASH_I2C_SLAVE_CMD_REG      (*(reg32 *) SPI_0_OLED_FLASH_SCB__I2C_S_CMD)
N#define SPI_0_OLED_FLASH_I2C_SLAVE_CMD_PTR      ( (reg32 *) SPI_0_OLED_FLASH_SCB__I2C_S_CMD)
N
N#define SPI_0_OLED_FLASH_I2C_CFG_REG            (*(reg32 *) SPI_0_OLED_FLASH_SCB__I2C_CFG)
N#define SPI_0_OLED_FLASH_I2C_CFG_PTR            ( (reg32 *) SPI_0_OLED_FLASH_SCB__I2C_CFG)
N
N#define SPI_0_OLED_FLASH_TX_CTRL_REG            (*(reg32 *) SPI_0_OLED_FLASH_SCB__TX_CTRL)
N#define SPI_0_OLED_FLASH_TX_CTRL_PTR            ( (reg32 *) SPI_0_OLED_FLASH_SCB__TX_CTRL)
N
N#define SPI_0_OLED_FLASH_TX_FIFO_CTRL_REG       (*(reg32 *) SPI_0_OLED_FLASH_SCB__TX_FIFO_CTRL)
N#define SPI_0_OLED_FLASH_TX_FIFO_CTRL_PTR       ( (reg32 *) SPI_0_OLED_FLASH_SCB__TX_FIFO_CTRL)
N
N#define SPI_0_OLED_FLASH_TX_FIFO_STATUS_REG     (*(reg32 *) SPI_0_OLED_FLASH_SCB__TX_FIFO_STATUS)
N#define SPI_0_OLED_FLASH_TX_FIFO_STATUS_PTR     ( (reg32 *) SPI_0_OLED_FLASH_SCB__TX_FIFO_STATUS)
N
N#define SPI_0_OLED_FLASH_TX_FIFO_WR_REG         (*(reg32 *) SPI_0_OLED_FLASH_SCB__TX_FIFO_WR)
N#define SPI_0_OLED_FLASH_TX_FIFO_WR_PTR         ( (reg32 *) SPI_0_OLED_FLASH_SCB__TX_FIFO_WR)
N
N#define SPI_0_OLED_FLASH_RX_CTRL_REG            (*(reg32 *) SPI_0_OLED_FLASH_SCB__RX_CTRL)
N#define SPI_0_OLED_FLASH_RX_CTRL_PTR            ( (reg32 *) SPI_0_OLED_FLASH_SCB__RX_CTRL)
N
N#define SPI_0_OLED_FLASH_RX_FIFO_CTRL_REG       (*(reg32 *) SPI_0_OLED_FLASH_SCB__RX_FIFO_CTRL)
N#define SPI_0_OLED_FLASH_RX_FIFO_CTRL_PTR       ( (reg32 *) SPI_0_OLED_FLASH_SCB__RX_FIFO_CTRL)
N
N#define SPI_0_OLED_FLASH_RX_FIFO_STATUS_REG     (*(reg32 *) SPI_0_OLED_FLASH_SCB__RX_FIFO_STATUS)
N#define SPI_0_OLED_FLASH_RX_FIFO_STATUS_PTR     ( (reg32 *) SPI_0_OLED_FLASH_SCB__RX_FIFO_STATUS)
N
N#define SPI_0_OLED_FLASH_RX_MATCH_REG           (*(reg32 *) SPI_0_OLED_FLASH_SCB__RX_MATCH)
N#define SPI_0_OLED_FLASH_RX_MATCH_PTR           ( (reg32 *) SPI_0_OLED_FLASH_SCB__RX_MATCH)
N
N#define SPI_0_OLED_FLASH_RX_FIFO_RD_REG         (*(reg32 *) SPI_0_OLED_FLASH_SCB__RX_FIFO_RD)
N#define SPI_0_OLED_FLASH_RX_FIFO_RD_PTR         ( (reg32 *) SPI_0_OLED_FLASH_SCB__RX_FIFO_RD)
N
N#define SPI_0_OLED_FLASH_RX_FIFO_RD_SILENT_REG  (*(reg32 *) SPI_0_OLED_FLASH_SCB__RX_FIFO_RD_SILENT)
N#define SPI_0_OLED_FLASH_RX_FIFO_RD_SILENT_PTR  ( (reg32 *) SPI_0_OLED_FLASH_SCB__RX_FIFO_RD_SILENT)
N
N#ifdef SPI_0_OLED_FLASH_SCB__EZ_DATA0
N    #define SPI_0_OLED_FLASH_EZBUF_DATA0_REG    (*(reg32 *) SPI_0_OLED_FLASH_SCB__EZ_DATA0)
N    #define SPI_0_OLED_FLASH_EZBUF_DATA0_PTR    ( (reg32 *) SPI_0_OLED_FLASH_SCB__EZ_DATA0)
N#else
S    #define SPI_0_OLED_FLASH_EZBUF_DATA0_REG    (*(reg32 *) SPI_0_OLED_FLASH_SCB__EZ_DATA00)
S    #define SPI_0_OLED_FLASH_EZBUF_DATA0_PTR    ( (reg32 *) SPI_0_OLED_FLASH_SCB__EZ_DATA00)
N#endif /* SPI_0_OLED_FLASH_SCB__EZ_DATA00 */
N
N#define SPI_0_OLED_FLASH_INTR_CAUSE_REG         (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_CAUSE)
N#define SPI_0_OLED_FLASH_INTR_CAUSE_PTR         ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_CAUSE)
N
N#define SPI_0_OLED_FLASH_INTR_I2C_EC_REG        (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_I2C_EC)
N#define SPI_0_OLED_FLASH_INTR_I2C_EC_PTR        ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_I2C_EC)
N
N#define SPI_0_OLED_FLASH_INTR_I2C_EC_MASK_REG   (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_I2C_EC_MASK)
N#define SPI_0_OLED_FLASH_INTR_I2C_EC_MASK_PTR   ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_I2C_EC_MASK)
N
N#define SPI_0_OLED_FLASH_INTR_I2C_EC_MASKED_REG (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_I2C_EC_MASKED)
N#define SPI_0_OLED_FLASH_INTR_I2C_EC_MASKED_PTR ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_I2C_EC_MASKED)
N
N#if (!SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_0_OLED_FLASH_INTR_SPI_EC_REG        (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_SPI_EC)
N    #define SPI_0_OLED_FLASH_INTR_SPI_EC_PTR        ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_SPI_EC)
N
N    #define SPI_0_OLED_FLASH_INTR_SPI_EC_MASK_REG   (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_SPI_EC_MASK)
N    #define SPI_0_OLED_FLASH_INTR_SPI_EC_MASK_PTR   ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_SPI_EC_MASK)
N
N    #define SPI_0_OLED_FLASH_INTR_SPI_EC_MASKED_REG (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_SPI_EC_MASKED)
N    #define SPI_0_OLED_FLASH_INTR_SPI_EC_MASKED_PTR ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_SPI_EC_MASKED)
N#endif /* (!SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N
N#define SPI_0_OLED_FLASH_INTR_MASTER_REG        (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_M)
N#define SPI_0_OLED_FLASH_INTR_MASTER_PTR        ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_M)
N
N#define SPI_0_OLED_FLASH_INTR_MASTER_SET_REG    (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_M_SET)
N#define SPI_0_OLED_FLASH_INTR_MASTER_SET_PTR    ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_M_SET)
N
N#define SPI_0_OLED_FLASH_INTR_MASTER_MASK_REG   (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_M_MASK)
N#define SPI_0_OLED_FLASH_INTR_MASTER_MASK_PTR   ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_M_MASK)
N
N#define SPI_0_OLED_FLASH_INTR_MASTER_MASKED_REG (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_M_MASKED)
N#define SPI_0_OLED_FLASH_INTR_MASTER_MASKED_PTR ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_M_MASKED)
N
N#define SPI_0_OLED_FLASH_INTR_SLAVE_REG         (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_S)
N#define SPI_0_OLED_FLASH_INTR_SLAVE_PTR         ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_S)
N
N#define SPI_0_OLED_FLASH_INTR_SLAVE_SET_REG     (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_S_SET)
N#define SPI_0_OLED_FLASH_INTR_SLAVE_SET_PTR     ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_S_SET)
N
N#define SPI_0_OLED_FLASH_INTR_SLAVE_MASK_REG    (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_S_MASK)
N#define SPI_0_OLED_FLASH_INTR_SLAVE_MASK_PTR    ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_S_MASK)
N
N#define SPI_0_OLED_FLASH_INTR_SLAVE_MASKED_REG  (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_S_MASKED)
N#define SPI_0_OLED_FLASH_INTR_SLAVE_MASKED_PTR  ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_S_MASKED)
N
N#define SPI_0_OLED_FLASH_INTR_TX_REG            (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_TX)
N#define SPI_0_OLED_FLASH_INTR_TX_PTR            ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_TX)
N
N#define SPI_0_OLED_FLASH_INTR_TX_SET_REG        (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_TX_SET)
N#define SPI_0_OLED_FLASH_INTR_TX_SET_PTR        ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_TX_SET)
N
N#define SPI_0_OLED_FLASH_INTR_TX_MASK_REG       (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_TX_MASK)
N#define SPI_0_OLED_FLASH_INTR_TX_MASK_PTR       ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_TX_MASK)
N
N#define SPI_0_OLED_FLASH_INTR_TX_MASKED_REG     (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_TX_MASKED)
N#define SPI_0_OLED_FLASH_INTR_TX_MASKED_PTR     ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_TX_MASKED)
N
N#define SPI_0_OLED_FLASH_INTR_RX_REG            (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_RX)
N#define SPI_0_OLED_FLASH_INTR_RX_PTR            ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_RX)
N
N#define SPI_0_OLED_FLASH_INTR_RX_SET_REG        (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_RX_SET)
N#define SPI_0_OLED_FLASH_INTR_RX_SET_PTR        ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_RX_SET)
N
N#define SPI_0_OLED_FLASH_INTR_RX_MASK_REG       (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_RX_MASK)
N#define SPI_0_OLED_FLASH_INTR_RX_MASK_PTR       ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_RX_MASK)
N
N#define SPI_0_OLED_FLASH_INTR_RX_MASKED_REG     (*(reg32 *) SPI_0_OLED_FLASH_SCB__INTR_RX_MASKED)
N#define SPI_0_OLED_FLASH_INTR_RX_MASKED_PTR     ( (reg32 *) SPI_0_OLED_FLASH_SCB__INTR_RX_MASKED)
N
N/* Defines get from SCB IP parameters. */
N#define SPI_0_OLED_FLASH_FIFO_SIZE      (8u)  /* TX or RX FIFO size. */
N#define SPI_0_OLED_FLASH_EZ_DATA_NR     (32u)  /* Number of words in EZ memory. */ 
N#define SPI_0_OLED_FLASH_ONE_BYTE_WIDTH (8u)            /* Number of bits in one byte. */
N#define SPI_0_OLED_FLASH_FF_DATA_NR_LOG2_MASK       (0x0Fu)      /* Number of bits to represent a FIFO address. */
N#define SPI_0_OLED_FLASH_FF_DATA_NR_LOG2_PLUS1_MASK (0x1Fu) /* Number of bits to represent #bytes in FIFO. */
N
N
N/***************************************
N*        Registers Constants
N***************************************/
N
N#if (SPI_0_OLED_FLASH_SCB_IRQ_INTERNAL)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_ISR_NUMBER     ((uint8) SPI_0_OLED_FLASH_SCB_IRQ__INTC_NUMBER)
S    #define SPI_0_OLED_FLASH_ISR_PRIORITY   ((uint8) SPI_0_OLED_FLASH_SCB_IRQ__INTC_PRIOR_NUM)
N#endif /* (SPI_0_OLED_FLASH_SCB_IRQ_INTERNAL) */
N
N#if (SPI_0_OLED_FLASH_UART_RX_WAKEUP_IRQ)
X#if ((0u == (1u)))
S    #define SPI_0_OLED_FLASH_RX_WAKE_ISR_NUMBER     ((uint8) SPI_0_OLED_FLASH_RX_WAKEUP_IRQ__INTC_NUMBER)
S    #define SPI_0_OLED_FLASH_RX_WAKE_ISR_PRIORITY   ((uint8) SPI_0_OLED_FLASH_RX_WAKEUP_IRQ__INTC_PRIOR_NUM)
N#endif /* (SPI_0_OLED_FLASH_UART_RX_WAKEUP_IRQ) */
N
N/* SPI_0_OLED_FLASH_CTRL_REG */
N#define SPI_0_OLED_FLASH_CTRL_OVS_POS           (0u)  /* [3:0]   Oversampling factor                 */
N#define SPI_0_OLED_FLASH_CTRL_EC_AM_MODE_POS    (8u)  /* [8]     Externally clocked address match    */
N#define SPI_0_OLED_FLASH_CTRL_EC_OP_MODE_POS    (9u)  /* [9]     Externally clocked operation mode   */
N#define SPI_0_OLED_FLASH_CTRL_EZBUF_MODE_POS    (10u) /* [10]    EZ buffer is enabled                */
N#if !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define SPI_0_OLED_FLASH_CTRL_BYTE_MODE_POS (11u) /* [11]    Determines the number of bits per FIFO data element */
N#endif /* !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N#define SPI_0_OLED_FLASH_CTRL_ADDR_ACCEPT_POS   (16u) /* [16]    Put matched address in RX FIFO       */
N#define SPI_0_OLED_FLASH_CTRL_BLOCK_POS         (17u) /* [17]    Ext and Int logic to resolve collide */
N#define SPI_0_OLED_FLASH_CTRL_MODE_POS          (24u) /* [25:24] Operation mode                       */
N#define SPI_0_OLED_FLASH_CTRL_ENABLED_POS       (31u) /* [31]    Enable SCB block                     */
N#define SPI_0_OLED_FLASH_CTRL_OVS_MASK          ((uint32) 0x0Fu)
N#define SPI_0_OLED_FLASH_CTRL_EC_AM_MODE        ((uint32) 0x01u << SPI_0_OLED_FLASH_CTRL_EC_AM_MODE_POS)
N#define SPI_0_OLED_FLASH_CTRL_EC_OP_MODE        ((uint32) 0x01u << SPI_0_OLED_FLASH_CTRL_EC_OP_MODE_POS)
N#define SPI_0_OLED_FLASH_CTRL_EZBUF_MODE        ((uint32) 0x01u << SPI_0_OLED_FLASH_CTRL_EZBUF_MODE_POS)
N#if !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define SPI_0_OLED_FLASH_CTRL_BYTE_MODE ((uint32) 0x01u << SPI_0_OLED_FLASH_CTRL_BYTE_MODE_POS)
N#endif /* !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N#define SPI_0_OLED_FLASH_CTRL_ADDR_ACCEPT       ((uint32) 0x01u << SPI_0_OLED_FLASH_CTRL_ADDR_ACCEPT_POS)
N#define SPI_0_OLED_FLASH_CTRL_BLOCK             ((uint32) 0x01u << SPI_0_OLED_FLASH_CTRL_BLOCK_POS)
N#define SPI_0_OLED_FLASH_CTRL_MODE_MASK         ((uint32) 0x03u << SPI_0_OLED_FLASH_CTRL_MODE_POS)
N#define SPI_0_OLED_FLASH_CTRL_MODE_I2C          ((uint32) 0x00u)
N#define SPI_0_OLED_FLASH_CTRL_MODE_SPI          ((uint32) 0x01u << SPI_0_OLED_FLASH_CTRL_MODE_POS)
N#define SPI_0_OLED_FLASH_CTRL_MODE_UART         ((uint32) 0x02u << SPI_0_OLED_FLASH_CTRL_MODE_POS)
N#define SPI_0_OLED_FLASH_CTRL_ENABLED           ((uint32) 0x01u << SPI_0_OLED_FLASH_CTRL_ENABLED_POS)
N
N/* SPI_0_OLED_FLASH_STATUS_REG */
N#define SPI_0_OLED_FLASH_STATUS_EC_BUSY_POS     (0u)  /* [0] Bus busy. Externally clocked logic access to EZ memory */
N#define SPI_0_OLED_FLASH_STATUS_EC_BUSY         ((uint32) 0x0Fu)
N
N/* SPI_0_OLED_FLASH_SPI_CTRL_REG  */
N#define SPI_0_OLED_FLASH_SPI_CTRL_CONTINUOUS_POS        (0u)  /* [0]     Continuous or Separated SPI data transfers */
N#define SPI_0_OLED_FLASH_SPI_CTRL_SELECT_PRECEDE_POS    (1u)  /* [1]     Precedes or coincides start of data frame  */
N#define SPI_0_OLED_FLASH_SPI_CTRL_CPHA_POS              (2u)  /* [2]     SCLK phase                                 */
N#define SPI_0_OLED_FLASH_SPI_CTRL_CPOL_POS              (3u)  /* [3]     SCLK polarity                              */
N#define SPI_0_OLED_FLASH_SPI_CTRL_LATE_MISO_SAMPLE_POS  (4u)  /* [4]     Late MISO sample enabled                   */
N#if !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define SPI_0_OLED_FLASH_SPI_CTRL_SCLK_CONTINUOUS_POS   (5u)  /* [5]     Enable continuous SCLK generation */
N    #define SPI_0_OLED_FLASH_SPI_CTRL_SSEL0_POLARITY_POS    (8u)  /* [8]     SS0 polarity                      */
N    #define SPI_0_OLED_FLASH_SPI_CTRL_SSEL1_POLARITY_POS    (9u)  /* [9]     SS1 polarity                      */
N    #define SPI_0_OLED_FLASH_SPI_CTRL_SSEL2_POLARITY_POS    (10u) /* [10]    SS2 polarity                      */
N    #define SPI_0_OLED_FLASH_SPI_CTRL_SSEL3_POLARITY_POS    (11u) /* [11]    SS3 polarity                      */
N#endif /* !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N#define SPI_0_OLED_FLASH_SPI_CTRL_LOOPBACK_POS          (16u) /* [16]    Local loop-back control enabled            */
N#define SPI_0_OLED_FLASH_SPI_CTRL_MODE_POS              (24u) /* [25:24] Submode of SPI operation                   */
N#define SPI_0_OLED_FLASH_SPI_CTRL_SLAVE_SELECT_POS      (26u) /* [27:26] Selects SPI SS signal                      */
N#define SPI_0_OLED_FLASH_SPI_CTRL_MASTER_MODE_POS       (31u) /* [31]    Master mode enabled                        */
N#define SPI_0_OLED_FLASH_SPI_CTRL_CONTINUOUS            ((uint32) 0x01u)
N#define SPI_0_OLED_FLASH_SPI_CTRL_SELECT_PRECEDE        ((uint32) 0x01u << SPI_0_OLED_FLASH_SPI_CTRL_SELECT_PRECEDE_POS)
N#define SPI_0_OLED_FLASH_SPI_CTRL_SCLK_MODE_MASK        ((uint32) 0x03u << SPI_0_OLED_FLASH_SPI_CTRL_CPHA_POS)
N#define SPI_0_OLED_FLASH_SPI_CTRL_CPHA                  ((uint32) 0x01u << SPI_0_OLED_FLASH_SPI_CTRL_CPHA_POS)
N#define SPI_0_OLED_FLASH_SPI_CTRL_CPOL                  ((uint32) 0x01u << SPI_0_OLED_FLASH_SPI_CTRL_CPOL_POS)
N#define SPI_0_OLED_FLASH_SPI_CTRL_LATE_MISO_SAMPLE      ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_SPI_CTRL_LATE_MISO_SAMPLE_POS)
X#define SPI_0_OLED_FLASH_SPI_CTRL_LATE_MISO_SAMPLE      ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_SPI_CTRL_LATE_MISO_SAMPLE_POS)
N#if !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define SPI_0_OLED_FLASH_SPI_CTRL_SCLK_CONTINUOUS  ((uint32) 0x01u << SPI_0_OLED_FLASH_SPI_CTRL_SCLK_CONTINUOUS_POS)
N    #define SPI_0_OLED_FLASH_SPI_CTRL_SSEL0_POLARITY   ((uint32) 0x01u << SPI_0_OLED_FLASH_SPI_CTRL_SSEL0_POLARITY_POS)
N    #define SPI_0_OLED_FLASH_SPI_CTRL_SSEL1_POLARITY   ((uint32) 0x01u << SPI_0_OLED_FLASH_SPI_CTRL_SSEL1_POLARITY_POS)
N    #define SPI_0_OLED_FLASH_SPI_CTRL_SSEL2_POLARITY   ((uint32) 0x01u << SPI_0_OLED_FLASH_SPI_CTRL_SSEL2_POLARITY_POS)
N    #define SPI_0_OLED_FLASH_SPI_CTRL_SSEL3_POLARITY   ((uint32) 0x01u << SPI_0_OLED_FLASH_SPI_CTRL_SSEL3_POLARITY_POS)
N    #define SPI_0_OLED_FLASH_SPI_CTRL_SSEL_POLARITY_MASK ((uint32)0x0Fu << SPI_0_OLED_FLASH_SPI_CTRL_SSEL0_POLARITY_POS)
N#endif /* !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N
N#define SPI_0_OLED_FLASH_SPI_CTRL_LOOPBACK              ((uint32) 0x01u << SPI_0_OLED_FLASH_SPI_CTRL_LOOPBACK_POS)
N#define SPI_0_OLED_FLASH_SPI_CTRL_MODE_MASK             ((uint32) 0x03u << SPI_0_OLED_FLASH_SPI_CTRL_MODE_POS)
N#define SPI_0_OLED_FLASH_SPI_CTRL_MODE_MOTOROLA         ((uint32) 0x00u)
N#define SPI_0_OLED_FLASH_SPI_CTRL_MODE_TI               ((uint32) 0x01u << SPI_0_OLED_FLASH_CTRL_MODE_POS)
N#define SPI_0_OLED_FLASH_SPI_CTRL_MODE_NS               ((uint32) 0x02u << SPI_0_OLED_FLASH_CTRL_MODE_POS)
N#define SPI_0_OLED_FLASH_SPI_CTRL_SLAVE_SELECT_MASK     ((uint32) 0x03u << SPI_0_OLED_FLASH_SPI_CTRL_SLAVE_SELECT_POS)
N#define SPI_0_OLED_FLASH_SPI_CTRL_SLAVE_SELECT0         ((uint32) 0x00u)
N#define SPI_0_OLED_FLASH_SPI_CTRL_SLAVE_SELECT1         ((uint32) 0x01u << SPI_0_OLED_FLASH_SPI_CTRL_SLAVE_SELECT_POS)
N#define SPI_0_OLED_FLASH_SPI_CTRL_SLAVE_SELECT2         ((uint32) 0x02u << SPI_0_OLED_FLASH_SPI_CTRL_SLAVE_SELECT_POS)
N#define SPI_0_OLED_FLASH_SPI_CTRL_SLAVE_SELECT3         ((uint32) 0x03u << SPI_0_OLED_FLASH_SPI_CTRL_SLAVE_SELECT_POS)
N#define SPI_0_OLED_FLASH_SPI_CTRL_MASTER                ((uint32) 0x01u << SPI_0_OLED_FLASH_SPI_CTRL_MASTER_MODE_POS)
N#define SPI_0_OLED_FLASH_SPI_CTRL_SLAVE                 ((uint32) 0x00u)
N
N/* SPI_0_OLED_FLASH_SPI_STATUS_REG  */
N#define SPI_0_OLED_FLASH_SPI_STATUS_BUS_BUSY_POS    (0u)  /* [0]    Bus busy - slave selected */
N#define SPI_0_OLED_FLASH_SPI_STATUS_EZBUF_ADDR_POS  (8u)  /* [15:8] EzAddress                 */
N#define SPI_0_OLED_FLASH_SPI_STATUS_BUS_BUSY        ((uint32) 0x01u)
N#define SPI_0_OLED_FLASH_SPI_STATUS_EZBUF_ADDR_MASK ((uint32) 0xFFu << SPI_0_OLED_FLASH_I2C_STATUS_EZBUF_ADDR_POS)
N
N/* SPI_0_OLED_FLASH_UART_CTRL */
N#define SPI_0_OLED_FLASH_UART_CTRL_LOOPBACK_POS         (16u) /* [16] Loop-back    */
N#define SPI_0_OLED_FLASH_UART_CTRL_MODE_POS             (24u) /* [24] UART subMode */
N#define SPI_0_OLED_FLASH_UART_CTRL_LOOPBACK             ((uint32) 0x01u << SPI_0_OLED_FLASH_UART_CTRL_LOOPBACK_POS)
N#define SPI_0_OLED_FLASH_UART_CTRL_MODE_UART_STD        ((uint32) 0x00u)
N#define SPI_0_OLED_FLASH_UART_CTRL_MODE_UART_SMARTCARD  ((uint32) 0x01u << SPI_0_OLED_FLASH_UART_CTRL_MODE_POS)
N#define SPI_0_OLED_FLASH_UART_CTRL_MODE_UART_IRDA       ((uint32) 0x02u << SPI_0_OLED_FLASH_UART_CTRL_MODE_POS)
N#define SPI_0_OLED_FLASH_UART_CTRL_MODE_MASK            ((uint32) 0x03u << SPI_0_OLED_FLASH_UART_CTRL_MODE_POS)
N
N/* SPI_0_OLED_FLASH_UART_TX_CTRL */
N#define SPI_0_OLED_FLASH_UART_TX_CTRL_STOP_BITS_POS         (0u)  /* [2:0] Stop bits: (Stop bits + 1) * 0.5 period */
N#define SPI_0_OLED_FLASH_UART_TX_CTRL_PARITY_POS            (4u)  /* [4]   Parity bit                              */
N#define SPI_0_OLED_FLASH_UART_TX_CTRL_PARITY_ENABLED_POS    (5u)  /* [5]   Parity enable                           */
N#define SPI_0_OLED_FLASH_UART_TX_CTRL_RETRY_ON_NACK_POS     (8u)  /* [8]   Smart Card: re-send frame on NACK       */
N#define SPI_0_OLED_FLASH_UART_TX_CTRL_ONE_STOP_BIT          ((uint32) 0x01u)
N#define SPI_0_OLED_FLASH_UART_TX_CTRL_ONE_HALF_STOP_BITS    ((uint32) 0x02u)
N#define SPI_0_OLED_FLASH_UART_TX_CTRL_TWO_STOP_BITS         ((uint32) 0x03u)
N#define SPI_0_OLED_FLASH_UART_TX_CTRL_STOP_BITS_MASK        ((uint32) 0x07u)
N#define SPI_0_OLED_FLASH_UART_TX_CTRL_PARITY                ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_UART_TX_CTRL_PARITY_POS)
X#define SPI_0_OLED_FLASH_UART_TX_CTRL_PARITY                ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_UART_TX_CTRL_PARITY_POS)
N#define SPI_0_OLED_FLASH_UART_TX_CTRL_PARITY_ENABLED        ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_UART_TX_CTRL_PARITY_ENABLED_POS)
X#define SPI_0_OLED_FLASH_UART_TX_CTRL_PARITY_ENABLED        ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_UART_TX_CTRL_PARITY_ENABLED_POS)
N#define SPI_0_OLED_FLASH_UART_TX_CTRL_RETRY_ON_NACK         ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_UART_TX_CTRL_RETRY_ON_NACK_POS)
X#define SPI_0_OLED_FLASH_UART_TX_CTRL_RETRY_ON_NACK         ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_UART_TX_CTRL_RETRY_ON_NACK_POS)
N
N/* SPI_0_OLED_FLASH_UART_RX_CTRL */
N#define SPI_0_OLED_FLASH_UART_RX_CTRL_STOP_BITS_POS             (0u)  /* [2:0] Stop bits: (Stop bits + 1) * 0.5 period*/
N#define SPI_0_OLED_FLASH_UART_RX_CTRL_PARITY_POS                (4u)  /* [4]   Parity bit                             */
N#define SPI_0_OLED_FLASH_UART_RX_CTRL_PARITY_ENABLED_POS        (5u)  /* [5]   Parity enable                          */
N#define SPI_0_OLED_FLASH_UART_RX_CTRL_POLARITY_POS              (6u)  /* [6]   IrDA: inverts polarity of RX signal    */
N#define SPI_0_OLED_FLASH_UART_RX_CTRL_DROP_ON_PARITY_ERR_POS    (8u)  /* [8]   Drop and lost RX FIFO on parity error  */
N#define SPI_0_OLED_FLASH_UART_RX_CTRL_DROP_ON_FRAME_ERR_POS     (9u)  /* [9]   Drop and lost RX FIFO on frame error   */
N#define SPI_0_OLED_FLASH_UART_RX_CTRL_MP_MODE_POS               (10u) /* [10]  Multi-processor mode                   */
N#define SPI_0_OLED_FLASH_UART_RX_CTRL_LIN_MODE_POS              (12u) /* [12]  Lin mode: applicable for UART Standard */
N#define SPI_0_OLED_FLASH_UART_RX_CTRL_SKIP_START_POS            (13u) /* [13]  Skip start not: only for UART Standard */
N#define SPI_0_OLED_FLASH_UART_RX_CTRL_BREAK_WIDTH_POS           (16u) /* [19:16]  Break width: (Break width + 1)      */
N#define SPI_0_OLED_FLASH_UART_TX_CTRL_ONE_STOP_BIT              ((uint32) 0x01u)
N#define SPI_0_OLED_FLASH_UART_TX_CTRL_ONE_HALF_STOP_BITS        ((uint32) 0x02u)
N#define SPI_0_OLED_FLASH_UART_TX_CTRL_TWO_STOP_BITS             ((uint32) 0x03u)
N#define SPI_0_OLED_FLASH_UART_RX_CTRL_STOP_BITS_MASK            ((uint32) 0x07u)
N#define SPI_0_OLED_FLASH_UART_RX_CTRL_PARITY                    ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_UART_RX_CTRL_PARITY_POS)
X#define SPI_0_OLED_FLASH_UART_RX_CTRL_PARITY                    ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_UART_RX_CTRL_PARITY_POS)
N#define SPI_0_OLED_FLASH_UART_RX_CTRL_PARITY_ENABLED            ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_UART_RX_CTRL_PARITY_ENABLED_POS)
X#define SPI_0_OLED_FLASH_UART_RX_CTRL_PARITY_ENABLED            ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_UART_RX_CTRL_PARITY_ENABLED_POS)
N#define SPI_0_OLED_FLASH_UART_RX_CTRL_POLARITY                  ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_UART_RX_CTRL_POLARITY_POS)
X#define SPI_0_OLED_FLASH_UART_RX_CTRL_POLARITY                  ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_UART_RX_CTRL_POLARITY_POS)
N#define SPI_0_OLED_FLASH_UART_RX_CTRL_DROP_ON_PARITY_ERR        ((uint32) 0x01u << \
N                                                                   SPI_0_OLED_FLASH_UART_RX_CTRL_DROP_ON_PARITY_ERR_POS)
X#define SPI_0_OLED_FLASH_UART_RX_CTRL_DROP_ON_PARITY_ERR        ((uint32) 0x01u <<                                                                    SPI_0_OLED_FLASH_UART_RX_CTRL_DROP_ON_PARITY_ERR_POS)
N#define SPI_0_OLED_FLASH_UART_RX_CTRL_DROP_ON_FRAME_ERR         ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_UART_RX_CTRL_DROP_ON_FRAME_ERR_POS)
X#define SPI_0_OLED_FLASH_UART_RX_CTRL_DROP_ON_FRAME_ERR         ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_UART_RX_CTRL_DROP_ON_FRAME_ERR_POS)
N#define SPI_0_OLED_FLASH_UART_RX_CTRL_MP_MODE                   ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_UART_RX_CTRL_MP_MODE_POS)
X#define SPI_0_OLED_FLASH_UART_RX_CTRL_MP_MODE                   ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_UART_RX_CTRL_MP_MODE_POS)
N#define SPI_0_OLED_FLASH_UART_RX_CTRL_LIN_MODE                  ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_UART_RX_CTRL_LIN_MODE_POS)
X#define SPI_0_OLED_FLASH_UART_RX_CTRL_LIN_MODE                  ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_UART_RX_CTRL_LIN_MODE_POS)
N#define SPI_0_OLED_FLASH_UART_RX_CTRL_SKIP_START                ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_UART_RX_CTRL_SKIP_START_POS)
X#define SPI_0_OLED_FLASH_UART_RX_CTRL_SKIP_START                ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_UART_RX_CTRL_SKIP_START_POS)
N#define SPI_0_OLED_FLASH_UART_RX_CTRL_BREAK_WIDTH_MASK          ((uint32) 0x0Fu << \
N                                                                    SPI_0_OLED_FLASH_UART_RX_CTRL_BREAK_WIDTH_POS)
X#define SPI_0_OLED_FLASH_UART_RX_CTRL_BREAK_WIDTH_MASK          ((uint32) 0x0Fu <<                                                                     SPI_0_OLED_FLASH_UART_RX_CTRL_BREAK_WIDTH_POS)
N/* SPI_0_OLED_FLASH_UART_RX_STATUS_REG */
N#define SPI_0_OLED_FLASH_UART_RX_STATUS_BR_COUNTER_POS     (0u)  /* [11:0] Baud Rate counter */
N#define SPI_0_OLED_FLASH_UART_RX_STATUS_BR_COUNTER_MASK    ((uint32) 0xFFFu)
N
N#if !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    /* SPI_0_OLED_FLASH_UART_FLOW_CTRL_REG */
N    #define SPI_0_OLED_FLASH_UART_FLOW_CTRL_TRIGGER_LEVEL_POS    (0u)  /* [7:0] RTS RX FIFO trigger level         */
N    #define SPI_0_OLED_FLASH_UART_FLOW_CTRL_RTS_POLARITY_POS     (16u) /* [16]  Polarity of the RTS output signal */
N    #define SPI_0_OLED_FLASH_UART_FLOW_CTRL_CTS_POLARITY_POS     (24u) /* [24]  Polarity of the CTS input signal  */
N    #define SPI_0_OLED_FLASH_UART_FLOW_CTRL_CTS_ENABLED_POS      (25u) /* [25]  Enable CTS signal                 */
N    #define SPI_0_OLED_FLASH_UART_FLOW_CTRL_TRIGGER_LEVEL_MASK   ((uint32) SPI_0_OLED_FLASH_FF_DATA_NR_LOG2_MASK)
N    #define SPI_0_OLED_FLASH_UART_FLOW_CTRL_RTS_POLARITY         ((uint32) 0x01u << \
N                                                                       SPI_0_OLED_FLASH_UART_FLOW_CTRL_RTS_POLARITY_POS)
X    #define SPI_0_OLED_FLASH_UART_FLOW_CTRL_RTS_POLARITY         ((uint32) 0x01u <<                                                                        SPI_0_OLED_FLASH_UART_FLOW_CTRL_RTS_POLARITY_POS)
N    #define SPI_0_OLED_FLASH_UART_FLOW_CTRL_CTS_POLARITY         ((uint32) 0x01u << \
N                                                                       SPI_0_OLED_FLASH_UART_FLOW_CTRL_CTS_POLARITY_POS)
X    #define SPI_0_OLED_FLASH_UART_FLOW_CTRL_CTS_POLARITY         ((uint32) 0x01u <<                                                                        SPI_0_OLED_FLASH_UART_FLOW_CTRL_CTS_POLARITY_POS)
N    #define SPI_0_OLED_FLASH_UART_FLOW_CTRL_CTS_ENABLE           ((uint32) 0x01u << \
N                                                                       SPI_0_OLED_FLASH_UART_FLOW_CTRL_CTS_ENABLED_POS)
X    #define SPI_0_OLED_FLASH_UART_FLOW_CTRL_CTS_ENABLE           ((uint32) 0x01u <<                                                                        SPI_0_OLED_FLASH_UART_FLOW_CTRL_CTS_ENABLED_POS)
N#endif /* !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N
N/* SPI_0_OLED_FLASH_I2C_CTRL */
N#define SPI_0_OLED_FLASH_I2C_CTRL_HIGH_PHASE_OVS_POS           (0u)   /* [3:0] Oversampling factor high: master only */
N#define SPI_0_OLED_FLASH_I2C_CTRL_LOW_PHASE_OVS_POS            (4u)   /* [7:4] Oversampling factor low:  master only */
N#define SPI_0_OLED_FLASH_I2C_CTRL_M_READY_DATA_ACK_POS         (8u)   /* [8]   Master ACKs data while RX FIFO != FULL*/
N#define SPI_0_OLED_FLASH_I2C_CTRL_M_NOT_READY_DATA_NACK_POS    (9u)   /* [9]   Master NACKs data if RX FIFO ==  FULL */
N#define SPI_0_OLED_FLASH_I2C_CTRL_S_GENERAL_IGNORE_POS         (11u)  /* [11]  Slave ignores General call            */
N#define SPI_0_OLED_FLASH_I2C_CTRL_S_READY_ADDR_ACK_POS         (12u)  /* [12]  Slave ACKs Address if RX FIFO != FULL */
N#define SPI_0_OLED_FLASH_I2C_CTRL_S_READY_DATA_ACK_POS         (13u)  /* [13]  Slave ACKs data while RX FIFO == FULL */
N#define SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_ADDR_NACK_POS    (14u)  /* [14]  Slave NACKs address if RX FIFO == FULL*/
N#define SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK_POS    (15u)  /* [15]  Slave NACKs data if RX FIFO is  FULL  */
N#define SPI_0_OLED_FLASH_I2C_CTRL_LOOPBACK_POS                 (16u)  /* [16]  Loop-back                             */
N#define SPI_0_OLED_FLASH_I2C_CTRL_SLAVE_MODE_POS               (30u)  /* [30]  Slave mode enabled                    */
N#define SPI_0_OLED_FLASH_I2C_CTRL_MASTER_MODE_POS              (31u)  /* [31]  Master mode enabled                   */
N#define SPI_0_OLED_FLASH_I2C_CTRL_HIGH_PHASE_OVS_MASK  ((uint32) 0x0Fu)
N#define SPI_0_OLED_FLASH_I2C_CTRL_LOW_PHASE_OVS_MASK   ((uint32) 0x0Fu << \
N                                                                SPI_0_OLED_FLASH_I2C_CTRL_LOW_PHASE_OVS_POS)
X#define SPI_0_OLED_FLASH_I2C_CTRL_LOW_PHASE_OVS_MASK   ((uint32) 0x0Fu <<                                                                 SPI_0_OLED_FLASH_I2C_CTRL_LOW_PHASE_OVS_POS)
N#define SPI_0_OLED_FLASH_I2C_CTRL_M_READY_DATA_ACK      ((uint32) 0x01u << \
N                                                                SPI_0_OLED_FLASH_I2C_CTRL_M_READY_DATA_ACK_POS)
X#define SPI_0_OLED_FLASH_I2C_CTRL_M_READY_DATA_ACK      ((uint32) 0x01u <<                                                                 SPI_0_OLED_FLASH_I2C_CTRL_M_READY_DATA_ACK_POS)
N#define SPI_0_OLED_FLASH_I2C_CTRL_M_NOT_READY_DATA_NACK ((uint32) 0x01u << \
N                                                                SPI_0_OLED_FLASH_I2C_CTRL_M_NOT_READY_DATA_NACK_POS)
X#define SPI_0_OLED_FLASH_I2C_CTRL_M_NOT_READY_DATA_NACK ((uint32) 0x01u <<                                                                 SPI_0_OLED_FLASH_I2C_CTRL_M_NOT_READY_DATA_NACK_POS)
N#define SPI_0_OLED_FLASH_I2C_CTRL_S_GENERAL_IGNORE      ((uint32) 0x01u << \
N                                                                SPI_0_OLED_FLASH_I2C_CTRL_S_GENERAL_IGNORE_POS)
X#define SPI_0_OLED_FLASH_I2C_CTRL_S_GENERAL_IGNORE      ((uint32) 0x01u <<                                                                 SPI_0_OLED_FLASH_I2C_CTRL_S_GENERAL_IGNORE_POS)
N#define SPI_0_OLED_FLASH_I2C_CTRL_S_READY_ADDR_ACK      ((uint32) 0x01u << \
N                                                                SPI_0_OLED_FLASH_I2C_CTRL_S_READY_ADDR_ACK_POS)
X#define SPI_0_OLED_FLASH_I2C_CTRL_S_READY_ADDR_ACK      ((uint32) 0x01u <<                                                                 SPI_0_OLED_FLASH_I2C_CTRL_S_READY_ADDR_ACK_POS)
N#define SPI_0_OLED_FLASH_I2C_CTRL_S_READY_DATA_ACK      ((uint32) 0x01u << \
N                                                                SPI_0_OLED_FLASH_I2C_CTRL_S_READY_DATA_ACK_POS)
X#define SPI_0_OLED_FLASH_I2C_CTRL_S_READY_DATA_ACK      ((uint32) 0x01u <<                                                                 SPI_0_OLED_FLASH_I2C_CTRL_S_READY_DATA_ACK_POS)
N#define SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_ADDR_NACK ((uint32) 0x01u << \
N                                                                SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_ADDR_NACK_POS)
X#define SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_ADDR_NACK ((uint32) 0x01u <<                                                                 SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_ADDR_NACK_POS)
N#define SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK ((uint32) 0x01u << \
N                                                                SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK_POS)
X#define SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK ((uint32) 0x01u <<                                                                 SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK_POS)
N#define SPI_0_OLED_FLASH_I2C_CTRL_LOOPBACK              ((uint32) 0x01u << \
N                                                                SPI_0_OLED_FLASH_I2C_CTRL_LOOPBACK_POS)
X#define SPI_0_OLED_FLASH_I2C_CTRL_LOOPBACK              ((uint32) 0x01u <<                                                                 SPI_0_OLED_FLASH_I2C_CTRL_LOOPBACK_POS)
N#define SPI_0_OLED_FLASH_I2C_CTRL_SLAVE_MODE            ((uint32) 0x01u << \
N                                                                SPI_0_OLED_FLASH_I2C_CTRL_SLAVE_MODE_POS)
X#define SPI_0_OLED_FLASH_I2C_CTRL_SLAVE_MODE            ((uint32) 0x01u <<                                                                 SPI_0_OLED_FLASH_I2C_CTRL_SLAVE_MODE_POS)
N#define SPI_0_OLED_FLASH_I2C_CTRL_MASTER_MODE           ((uint32) 0x01u << \
N                                                                SPI_0_OLED_FLASH_I2C_CTRL_MASTER_MODE_POS)
X#define SPI_0_OLED_FLASH_I2C_CTRL_MASTER_MODE           ((uint32) 0x01u <<                                                                 SPI_0_OLED_FLASH_I2C_CTRL_MASTER_MODE_POS)
N#define SPI_0_OLED_FLASH_I2C_CTRL_SLAVE_MASTER_MODE_MASK    ((uint32) 0x03u << \
N                                                                SPI_0_OLED_FLASH_I2C_CTRL_SLAVE_MODE_POS)
X#define SPI_0_OLED_FLASH_I2C_CTRL_SLAVE_MASTER_MODE_MASK    ((uint32) 0x03u <<                                                                 SPI_0_OLED_FLASH_I2C_CTRL_SLAVE_MODE_POS)
N
N/* SPI_0_OLED_FLASH_I2C_STATUS_REG  */
N#define SPI_0_OLED_FLASH_I2C_STATUS_BUS_BUSY_POS    (0u)  /* [0]    Bus busy: internally clocked */
N#define SPI_0_OLED_FLASH_I2C_STATUS_S_READ_POS      (4u)  /* [4]    Slave is read by master      */
N#define SPI_0_OLED_FLASH_I2C_STATUS_M_READ_POS      (5u)  /* [5]    Master reads Slave           */
N#define SPI_0_OLED_FLASH_I2C_STATUS_EZBUF_ADDR_POS  (8u)  /* [15:8] EZAddress                    */
N#define SPI_0_OLED_FLASH_I2C_STATUS_BUS_BUSY        ((uint32) 0x01u)
N#define SPI_0_OLED_FLASH_I2C_STATUS_S_READ          ((uint32) 0x01u << SPI_0_OLED_FLASH_I2C_STATUS_S_READ_POS)
N#define SPI_0_OLED_FLASH_I2C_STATUS_M_READ          ((uint32) 0x01u << SPI_0_OLED_FLASH_I2C_STATUS_M_READ_POS)
N#define SPI_0_OLED_FLASH_I2C_STATUS_EZBUF_ADDR_MASK ((uint32) 0xFFu << SPI_0_OLED_FLASH_I2C_STATUS_EZBUF_ADDR_POS)
N
N/* SPI_0_OLED_FLASH_I2C_MASTER_CMD_REG */
N#define SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_START_POS             (0u)  /* [0] Master generate Start                */
N#define SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_START_ON_IDLE_POS     (1u)  /* [1] Master generate Start if bus is free */
N#define SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_ACK_POS               (2u)  /* [2] Master generate ACK                  */
N#define SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_NACK_POS              (3u)  /* [3] Master generate NACK                 */
N#define SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_STOP_POS              (4u)  /* [4] Master generate Stop                 */
N#define SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_START         ((uint32) 0x01u)
N#define SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_START_ON_IDLE ((uint32) 0x01u << \
N                                                                   SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_START_ON_IDLE_POS)
X#define SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_START_ON_IDLE ((uint32) 0x01u <<                                                                    SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_START_ON_IDLE_POS)
N#define SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_ACK           ((uint32) 0x01u << \
N                                                                   SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_ACK_POS)
X#define SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_ACK           ((uint32) 0x01u <<                                                                    SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_ACK_POS)
N#define SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_NACK          ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_NACK_POS)
X#define SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_NACK          ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_NACK_POS)
N#define SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_STOP          ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_STOP_POS)
X#define SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_STOP          ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_STOP_POS)
N
N/* SPI_0_OLED_FLASH_I2C_SLAVE_CMD_REG  */
N#define SPI_0_OLED_FLASH_I2C_SLAVE_CMD_S_ACK_POS    (0u)  /* [0] Slave generate ACK  */
N#define SPI_0_OLED_FLASH_I2C_SLAVE_CMD_S_NACK_POS   (1u)  /* [1] Slave generate NACK */
N#define SPI_0_OLED_FLASH_I2C_SLAVE_CMD_S_ACK        ((uint32) 0x01u)
N#define SPI_0_OLED_FLASH_I2C_SLAVE_CMD_S_NACK       ((uint32) 0x01u << SPI_0_OLED_FLASH_I2C_SLAVE_CMD_S_NACK_POS)
N
N#define SPI_0_OLED_FLASH_I2C_SLAVE_CMD_S_ACK_POS    (0u)  /* [0] Slave generate ACK  */
N#define SPI_0_OLED_FLASH_I2C_SLAVE_CMD_S_NACK_POS   (1u)  /* [1] Slave generate NACK */
N#define SPI_0_OLED_FLASH_I2C_SLAVE_CMD_S_ACK        ((uint32) 0x01u)
N#define SPI_0_OLED_FLASH_I2C_SLAVE_CMD_S_NACK       ((uint32) 0x01u << SPI_0_OLED_FLASH_I2C_SLAVE_CMD_S_NACK_POS)
N
N/* SPI_0_OLED_FLASH_I2C_CFG_REG */
N#if (SPI_0_OLED_FLASH_CY_SCBIP_V0)
X#if ((2 == 0u))
S#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_HYS_POS           (0u)  /* [1:0]   Trim bits for the I2C SDA filter         */
S#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_TRIM_POS          (2u)  /* [3:2]   Trim bits for the I2C SDA filter         */
S#define SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_HYS_POS           (4u)  /* [5:4]   Trim bits for the I2C SCL filter         */
S#define SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_TRIM_POS          (6u)  /* [7:6]   Trim bits for the I2C SCL filter         */
S#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_HYS_POS       (8u)  /* [9:8]   Trim bits for I2C SDA filter output path */
S#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_TRIM_POS      (10u) /* [11:10] Trim bits for I2C SDA filter output path */
S#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_HS_POS            (16u) /* [16]    '0': 50 ns filter, '1': 10 ns filter     */
S#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_ENABLED_POS       (17u) /* [17]    I2C SDA filter enabled                   */
S#define SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_HS_POS            (24u) /* [24]    '0': 50 ns filter, '1': 10 ns filter     */
S#define SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_ENABLED_POS       (25u) /* [25]    I2C SCL filter enabled                   */
S#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_HS_POS        (26u) /* [26]    '0': 50 ns filter, '1': 10 ns filter     */
S#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_ENABLED_POS   (27u) /* [27]    I2C SDA output delay filter enabled      */
S#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_HYS_MASK          ((uint32) 0x03u)
S#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_TRIM_MASK         ((uint32) 0x03u << \
S                                                                SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_TRIM_POS)
X#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_TRIM_MASK         ((uint32) 0x03u <<                                                                 SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_TRIM_POS)
S#define SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_HYS_MASK          ((uint32) 0x03u << \
S                                                                SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_HYS_POS)
X#define SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_HYS_MASK          ((uint32) 0x03u <<                                                                 SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_HYS_POS)
S#define SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_TRIM_MASK         ((uint32) 0x03u << \
S                                                                SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_TRIM_POS)
X#define SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_TRIM_MASK         ((uint32) 0x03u <<                                                                 SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_TRIM_POS)
S#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_HYS_MASK      ((uint32) 0x03u << \
S                                                                SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_HYS_POS)
X#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_HYS_MASK      ((uint32) 0x03u <<                                                                 SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_HYS_POS)
S#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_TRIM_MASK     ((uint32) 0x03u << \
S                                                                SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_TRIM_POS)
X#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_TRIM_MASK     ((uint32) 0x03u <<                                                                 SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_TRIM_POS)
S#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_HS                ((uint32) 0x01u << \
S                                                                SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_HS_POS)
X#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_HS                ((uint32) 0x01u <<                                                                 SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_HS_POS)
S#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_ENABLED           ((uint32) 0x01u << \
S                                                                SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_ENABLED_POS)
X#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_ENABLED           ((uint32) 0x01u <<                                                                 SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_ENABLED_POS)
S#define SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_HS                ((uint32) 0x01u << \
S                                                                SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_HS_POS)
X#define SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_HS                ((uint32) 0x01u <<                                                                 SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_HS_POS)
S#define SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_ENABLED           ((uint32) 0x01u << \
S                                                                SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_ENABLED_POS)
X#define SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_ENABLED           ((uint32) 0x01u <<                                                                 SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_ENABLED_POS)
S#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_HS            ((uint32) 0x01u << \
S                                                                SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_HS_POS)
X#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_HS            ((uint32) 0x01u <<                                                                 SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_HS_POS)
S#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_ENABLED       ((uint32) 0x01u << \
S                                                                SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_ENABLED_POS)
X#define SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_ENABLED       ((uint32) 0x01u <<                                                                 SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_ENABLED_POS)
N#else
N#define SPI_0_OLED_FLASH_I2C_CFG_SDA_IN_FILT_TRIM_POS   (0u)  /* [1:0] Trim bits for "i2c_sda_in" 50 ns filter */
N#define SPI_0_OLED_FLASH_I2C_CFG_SDA_IN_FILT_SEL_POS    (4u)  /* [4]   "i2c_sda_in" filter delay: 0 ns and 50 ns */
N#define SPI_0_OLED_FLASH_I2C_CFG_SCL_IN_FILT_TRIM_POS   (8u)  /* [9:8] Trim bits for "i2c_scl_in" 50 ns filter */
N#define SPI_0_OLED_FLASH_I2C_CFG_SCL_IN_FILT_SEL_POS    (12u) /* [12]  "i2c_scl_in" filter delay: 0 ns and 50 ns */
N#define SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT0_TRIM_POS (16u) /* [17:16] Trim bits for "i2c_sda_out" 50 ns filter 0 */
N#define SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT1_TRIM_POS (18u) /* [19:18] Trim bits for "i2c_sda_out" 50 ns filter 1 */
N#define SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT2_TRIM_POS (20u) /* [21:20] Trim bits for "i2c_sda_out" 50 ns filter 2 */
N#define SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT_SEL_POS   (28u) /* [29:28] Cumulative "i2c_sda_out" filter delay: */
N
N#define SPI_0_OLED_FLASH_I2C_CFG_SDA_IN_FILT_TRIM_MASK  ((uint32) 0x03u)
N#define SPI_0_OLED_FLASH_I2C_CFG_SDA_IN_FILT_SEL        ((uint32) 0x01u << SPI_0_OLED_FLASH_I2C_CFG_SDA_IN_FILT_SEL_POS)
N#define SPI_0_OLED_FLASH_I2C_CFG_SCL_IN_FILT_TRIM_MASK  ((uint32) 0x03u << \
N                                                            SPI_0_OLED_FLASH_I2C_CFG_SCL_IN_FILT_TRIM_POS)
X#define SPI_0_OLED_FLASH_I2C_CFG_SCL_IN_FILT_TRIM_MASK  ((uint32) 0x03u <<                                                             SPI_0_OLED_FLASH_I2C_CFG_SCL_IN_FILT_TRIM_POS)
N#define SPI_0_OLED_FLASH_I2C_CFG_SCL_IN_FILT_SEL        ((uint32) 0x01u << SPI_0_OLED_FLASH_I2C_CFG_SCL_IN_FILT_SEL_POS)
N#define SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT0_TRIM_MASK ((uint32) 0x03u << \
N                                                            SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT0_TRIM_POS)
X#define SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT0_TRIM_MASK ((uint32) 0x03u <<                                                             SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT0_TRIM_POS)
N#define SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT1_TRIM_MASK ((uint32) 0x03u << \
N                                                            SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT1_TRIM_POS)
X#define SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT1_TRIM_MASK ((uint32) 0x03u <<                                                             SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT1_TRIM_POS)
N#define SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT2_TRIM_MASK ((uint32) 0x03u << \
N                                                            SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT2_TRIM_POS)
X#define SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT2_TRIM_MASK ((uint32) 0x03u <<                                                             SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT2_TRIM_POS)
N#define SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT_SEL_MASK   ((uint32) 0x03u << \
N                                                            SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT_SEL_POS)
X#define SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT_SEL_MASK   ((uint32) 0x03u <<                                                             SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT_SEL_POS)
N#endif /* (SPI_0_OLED_FLASH_CY_SCBIP_V0) */
N
N
N/* SPI_0_OLED_FLASH_TX_CTRL_REG */
N#define SPI_0_OLED_FLASH_TX_CTRL_DATA_WIDTH_POS     (0u)  /* [3:0] Data frame width: (Data width - 1) */
N#define SPI_0_OLED_FLASH_TX_CTRL_MSB_FIRST_POS      (8u)  /* [8]   MSB first shifter-out             */
N#define SPI_0_OLED_FLASH_TX_CTRL_ENABLED_POS        (31u) /* [31]  Transmitter enabled               */
N#define SPI_0_OLED_FLASH_TX_CTRL_DATA_WIDTH_MASK    ((uint32) 0x0Fu)
N#define SPI_0_OLED_FLASH_TX_CTRL_MSB_FIRST          ((uint32) 0x01u << SPI_0_OLED_FLASH_TX_CTRL_MSB_FIRST_POS)
N#define SPI_0_OLED_FLASH_TX_CTRL_LSB_FIRST          ((uint32) 0x00u)
N#define SPI_0_OLED_FLASH_TX_CTRL_ENABLED            ((uint32) 0x01u << SPI_0_OLED_FLASH_TX_CTRL_ENABLED_POS)
N
N/* SPI_0_OLED_FLASH_TX_CTRL_FIFO_REG */
N#define SPI_0_OLED_FLASH_TX_FIFO_CTRL_TRIGGER_LEVEL_POS     (0u)  /* [2:0] Trigger level                              */
N#define SPI_0_OLED_FLASH_TX_FIFO_CTRL_CLEAR_POS             (16u) /* [16]  Clear TX FIFO: cleared after set           */
N#define SPI_0_OLED_FLASH_TX_FIFO_CTRL_FREEZE_POS            (17u) /* [17]  Freeze TX FIFO: HW do not inc read pointer */
N#define SPI_0_OLED_FLASH_TX_FIFO_CTRL_TRIGGER_LEVEL_MASK    ((uint32) SPI_0_OLED_FLASH_FF_DATA_NR_LOG2_MASK)
N#define SPI_0_OLED_FLASH_TX_FIFO_CTRL_CLEAR                 ((uint32) 0x01u << SPI_0_OLED_FLASH_TX_FIFO_CTRL_CLEAR_POS)
N#define SPI_0_OLED_FLASH_TX_FIFO_CTRL_FREEZE                ((uint32) 0x01u << SPI_0_OLED_FLASH_TX_FIFO_CTRL_FREEZE_POS)
N
N/* SPI_0_OLED_FLASH_TX_FIFO_STATUS_REG */
N#define SPI_0_OLED_FLASH_TX_FIFO_STATUS_USED_POS    (0u)  /* [3:0]   Amount of entries in TX FIFO */
N#define SPI_0_OLED_FLASH_TX_FIFO_SR_VALID_POS       (15u) /* [15]    Shifter status of TX FIFO    */
N#define SPI_0_OLED_FLASH_TX_FIFO_STATUS_RD_PTR_POS  (16u) /* [18:16] TX FIFO read pointer         */
N#define SPI_0_OLED_FLASH_TX_FIFO_STATUS_WR_PTR_POS  (24u) /* [26:24] TX FIFO write pointer        */
N#define SPI_0_OLED_FLASH_TX_FIFO_STATUS_USED_MASK   ((uint32) SPI_0_OLED_FLASH_FF_DATA_NR_LOG2_PLUS1_MASK)
N#define SPI_0_OLED_FLASH_TX_FIFO_SR_VALID           ((uint32) 0x01u << SPI_0_OLED_FLASH_TX_FIFO_SR_VALID_POS)
N#define SPI_0_OLED_FLASH_TX_FIFO_STATUS_RD_PTR_MASK ((uint32) SPI_0_OLED_FLASH_FF_DATA_NR_LOG2_MASK << \
N                                                                    SPI_0_OLED_FLASH_TX_FIFO_STATUS_RD_PTR_POS)
X#define SPI_0_OLED_FLASH_TX_FIFO_STATUS_RD_PTR_MASK ((uint32) SPI_0_OLED_FLASH_FF_DATA_NR_LOG2_MASK <<                                                                     SPI_0_OLED_FLASH_TX_FIFO_STATUS_RD_PTR_POS)
N#define SPI_0_OLED_FLASH_TX_FIFO_STATUS_WR_PTR_MASK ((uint32) SPI_0_OLED_FLASH_FF_DATA_NR_LOG2_MASK << \
N                                                                    SPI_0_OLED_FLASH_TX_FIFO_STATUS_WR_PTR_POS)
X#define SPI_0_OLED_FLASH_TX_FIFO_STATUS_WR_PTR_MASK ((uint32) SPI_0_OLED_FLASH_FF_DATA_NR_LOG2_MASK <<                                                                     SPI_0_OLED_FLASH_TX_FIFO_STATUS_WR_PTR_POS)
N
N/* SPI_0_OLED_FLASH_TX_FIFO_WR_REG */
N#define SPI_0_OLED_FLASH_TX_FIFO_WR_POS    (0u)  /* [15:0] Data written into TX FIFO */
N#define SPI_0_OLED_FLASH_TX_FIFO_WR_MASK   ((uint32) 0xFFu)
N
N/* SPI_0_OLED_FLASH_RX_CTRL_REG */
N#define SPI_0_OLED_FLASH_RX_CTRL_DATA_WIDTH_POS     (0u)  /* [3:0] Data frame width: (Data width - 1) */
N#define SPI_0_OLED_FLASH_RX_CTRL_MSB_FIRST_POS      (8u)  /* [8]   MSB first shifter-out             */
N#define SPI_0_OLED_FLASH_RX_CTRL_MEDIAN_POS         (9u)  /* [9]   Median filter                     */
N#define SPI_0_OLED_FLASH_RX_CTRL_ENABLED_POS        (31u) /* [31]  Receiver enabled                  */
N#define SPI_0_OLED_FLASH_RX_CTRL_DATA_WIDTH_MASK    ((uint32) 0x0Fu)
N#define SPI_0_OLED_FLASH_RX_CTRL_MSB_FIRST          ((uint32) 0x01u << SPI_0_OLED_FLASH_RX_CTRL_MSB_FIRST_POS)
N#define SPI_0_OLED_FLASH_RX_CTRL_LSB_FIRST          ((uint32) 0x00u)
N#define SPI_0_OLED_FLASH_RX_CTRL_MEDIAN             ((uint32) 0x01u << SPI_0_OLED_FLASH_RX_CTRL_MEDIAN_POS)
N#define SPI_0_OLED_FLASH_RX_CTRL_ENABLED            ((uint32) 0x01u << SPI_0_OLED_FLASH_RX_CTRL_ENABLED_POS)
N
N
N/* SPI_0_OLED_FLASH_RX_FIFO_CTRL_REG */
N#define SPI_0_OLED_FLASH_RX_FIFO_CTRL_TRIGGER_LEVEL_POS     (0u)   /* [2:0] Trigger level                            */
N#define SPI_0_OLED_FLASH_RX_FIFO_CTRL_CLEAR_POS             (16u)  /* [16]  Clear RX FIFO: clear after set           */
N#define SPI_0_OLED_FLASH_RX_FIFO_CTRL_FREEZE_POS            (17u)  /* [17]  Freeze RX FIFO: HW writes has not effect */
N#define SPI_0_OLED_FLASH_RX_FIFO_CTRL_TRIGGER_LEVEL_MASK    ((uint32) SPI_0_OLED_FLASH_FF_DATA_NR_LOG2_MASK)
N#define SPI_0_OLED_FLASH_RX_FIFO_CTRL_CLEAR                 ((uint32) 0x01u << SPI_0_OLED_FLASH_RX_FIFO_CTRL_CLEAR_POS)
N#define SPI_0_OLED_FLASH_RX_FIFO_CTRL_FREEZE                ((uint32) 0x01u << SPI_0_OLED_FLASH_RX_FIFO_CTRL_FREEZE_POS)
N
N/* SPI_0_OLED_FLASH_RX_FIFO_STATUS_REG */
N#define SPI_0_OLED_FLASH_RX_FIFO_STATUS_USED_POS    (0u)   /* [3:0]   Amount of entries in RX FIFO */
N#define SPI_0_OLED_FLASH_RX_FIFO_SR_VALID_POS       (15u)  /* [15]    Shifter status of RX FIFO    */
N#define SPI_0_OLED_FLASH_RX_FIFO_STATUS_RD_PTR_POS  (16u)  /* [18:16] RX FIFO read pointer         */
N#define SPI_0_OLED_FLASH_RX_FIFO_STATUS_WR_PTR_POS  (24u)  /* [26:24] RX FIFO write pointer        */
N#define SPI_0_OLED_FLASH_RX_FIFO_STATUS_USED_MASK   ((uint32) SPI_0_OLED_FLASH_FF_DATA_NR_LOG2_PLUS1_MASK)
N#define SPI_0_OLED_FLASH_RX_FIFO_SR_VALID           ((uint32) 0x01u << SPI_0_OLED_FLASH_RX_FIFO_SR_VALID_POS)
N#define SPI_0_OLED_FLASH_RX_FIFO_STATUS_RD_PTR_MASK ((uint32) SPI_0_OLED_FLASH_FF_DATA_NR_LOG2_MASK << \
N                                                                    SPI_0_OLED_FLASH_RX_FIFO_STATUS_RD_PTR_POS)
X#define SPI_0_OLED_FLASH_RX_FIFO_STATUS_RD_PTR_MASK ((uint32) SPI_0_OLED_FLASH_FF_DATA_NR_LOG2_MASK <<                                                                     SPI_0_OLED_FLASH_RX_FIFO_STATUS_RD_PTR_POS)
N#define SPI_0_OLED_FLASH_RX_FIFO_STATUS_WR_PTR_MASK ((uint32) SPI_0_OLED_FLASH_FF_DATA_NR_LOG2_MASK << \
N                                                                    SPI_0_OLED_FLASH_RX_FIFO_STATUS_WR_PTR_POS)
X#define SPI_0_OLED_FLASH_RX_FIFO_STATUS_WR_PTR_MASK ((uint32) SPI_0_OLED_FLASH_FF_DATA_NR_LOG2_MASK <<                                                                     SPI_0_OLED_FLASH_RX_FIFO_STATUS_WR_PTR_POS)
N
N/* SPI_0_OLED_FLASH_RX_MATCH_REG */
N#define SPI_0_OLED_FLASH_RX_MATCH_ADDR_POS     (0u)  /* [7:0]   Slave address                        */
N#define SPI_0_OLED_FLASH_RX_MATCH_MASK_POS     (16u) /* [23:16] Slave address mask: 0 - doesn't care */
N#define SPI_0_OLED_FLASH_RX_MATCH_ADDR_MASK    ((uint32) 0xFFu)
N#define SPI_0_OLED_FLASH_RX_MATCH_MASK_MASK    ((uint32) 0xFFu << SPI_0_OLED_FLASH_RX_MATCH_MASK_POS)
N
N/* SPI_0_OLED_FLASH_RX_FIFO_WR_REG */
N#define SPI_0_OLED_FLASH_RX_FIFO_RD_POS    (0u)  /* [15:0] Data read from RX FIFO */
N#define SPI_0_OLED_FLASH_RX_FIFO_RD_MASK   ((uint32) 0xFFu)
N
N/* SPI_0_OLED_FLASH_RX_FIFO_RD_SILENT_REG */
N#define SPI_0_OLED_FLASH_RX_FIFO_RD_SILENT_POS     (0u)  /* [15:0] Data read from RX FIFO: not remove data from FIFO */
N#define SPI_0_OLED_FLASH_RX_FIFO_RD_SILENT_MASK    ((uint32) 0xFFu)
N
N/* SPI_0_OLED_FLASH_RX_FIFO_RD_SILENT_REG */
N#define SPI_0_OLED_FLASH_RX_FIFO_RD_SILENT_POS     (0u)  /* [15:0] Data read from RX FIFO: not remove data from FIFO */
N#define SPI_0_OLED_FLASH_RX_FIFO_RD_SILENT_MASK    ((uint32) 0xFFu)
N
N/* SPI_0_OLED_FLASH_EZBUF_DATA_REG */
N#define SPI_0_OLED_FLASH_EZBUF_DATA_POS   (0u)  /* [7:0] Data from EZ Memory */
N#define SPI_0_OLED_FLASH_EZBUF_DATA_MASK  ((uint32) 0xFFu)
N
N/*  SPI_0_OLED_FLASH_INTR_CAUSE_REG */
N#define SPI_0_OLED_FLASH_INTR_CAUSE_MASTER_POS  (0u)  /* [0] Master interrupt active                 */
N#define SPI_0_OLED_FLASH_INTR_CAUSE_SLAVE_POS   (1u)  /* [1] Slave interrupt active                  */
N#define SPI_0_OLED_FLASH_INTR_CAUSE_TX_POS      (2u)  /* [2] Transmitter interrupt active            */
N#define SPI_0_OLED_FLASH_INTR_CAUSE_RX_POS      (3u)  /* [3] Receiver interrupt active               */
N#define SPI_0_OLED_FLASH_INTR_CAUSE_I2C_EC_POS  (4u)  /* [4] Externally clock I2C interrupt active   */
N#define SPI_0_OLED_FLASH_INTR_CAUSE_SPI_EC_POS  (5u)  /* [5] Externally clocked SPI interrupt active */
N#define SPI_0_OLED_FLASH_INTR_CAUSE_MASTER      ((uint32) 0x01u)
N#define SPI_0_OLED_FLASH_INTR_CAUSE_SLAVE       ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_CAUSE_SLAVE_POS)
N#define SPI_0_OLED_FLASH_INTR_CAUSE_TX          ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_CAUSE_TX_POS)
N#define SPI_0_OLED_FLASH_INTR_CAUSE_RX          ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_CAUSE_RX_POS)
N#define SPI_0_OLED_FLASH_INTR_CAUSE_I2C_EC      ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_CAUSE_I2C_EC_POS)
N#define SPI_0_OLED_FLASH_INTR_CAUSE_SPI_EC      ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_CAUSE_SPI_EC_POS)
N
N/* SPI_0_OLED_FLASH_INTR_SPI_EC_REG, SPI_0_OLED_FLASH_INTR_SPI_EC_MASK_REG, SPI_0_OLED_FLASH_INTR_SPI_EC_MASKED_REG */
N#define SPI_0_OLED_FLASH_INTR_SPI_EC_WAKE_UP_POS          (0u)  /* [0] Address match: triggers wakeup of chip */
N#define SPI_0_OLED_FLASH_INTR_SPI_EC_EZBUF_STOP_POS       (1u)  /* [1] Externally clocked Stop detected       */
N#define SPI_0_OLED_FLASH_INTR_SPI_EC_EZBUF_WRITE_STOP_POS (2u)  /* [2] Externally clocked Write Stop detected */
N#define SPI_0_OLED_FLASH_INTR_SPI_EC_WAKE_UP              ((uint32) 0x01u)
N#define SPI_0_OLED_FLASH_INTR_SPI_EC_EZBUF_STOP           ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_INTR_SPI_EC_EZBUF_STOP_POS)
X#define SPI_0_OLED_FLASH_INTR_SPI_EC_EZBUF_STOP           ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_INTR_SPI_EC_EZBUF_STOP_POS)
N#define SPI_0_OLED_FLASH_INTR_SPI_EC_EZBUF_WRITE_STOP     ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_INTR_SPI_EC_EZBUF_WRITE_STOP_POS)
X#define SPI_0_OLED_FLASH_INTR_SPI_EC_EZBUF_WRITE_STOP     ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_INTR_SPI_EC_EZBUF_WRITE_STOP_POS)
N
N/* SPI_0_OLED_FLASH_INTR_I2C_EC, SPI_0_OLED_FLASH_INTR_I2C_EC_MASK, SPI_0_OLED_FLASH_INTR_I2C_EC_MASKED */
N#define SPI_0_OLED_FLASH_INTR_I2C_EC_WAKE_UP_POS          (0u)  /* [0] Address match: triggers wakeup of chip */
N#define SPI_0_OLED_FLASH_INTR_I2C_EC_EZBUF_STOP_POS       (1u)  /* [1] Externally clocked Stop detected       */
N#define SPI_0_OLED_FLASH_INTR_I2C_EC_EZBUF_WRITE_STOP_POS (2u)  /* [2] Externally clocked Write Stop detected */
N#define SPI_0_OLED_FLASH_INTR_I2C_EC_WAKE_UP              ((uint32) 0x01u)
N#define SPI_0_OLED_FLASH_INTR_I2C_EC_EZBUF_STOP           ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_INTR_I2C_EC_EZBUF_STOP_POS)
X#define SPI_0_OLED_FLASH_INTR_I2C_EC_EZBUF_STOP           ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_INTR_I2C_EC_EZBUF_STOP_POS)
N#define SPI_0_OLED_FLASH_INTR_I2C_EC_EZBUF_WRITE_STOP     ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_INTR_I2C_EC_EZBUF_WRITE_STOP_POS)
X#define SPI_0_OLED_FLASH_INTR_I2C_EC_EZBUF_WRITE_STOP     ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_INTR_I2C_EC_EZBUF_WRITE_STOP_POS)
N
N/* SPI_0_OLED_FLASH_INTR_MASTER, SPI_0_OLED_FLASH_INTR_MASTER_SET,
N   SPI_0_OLED_FLASH_INTR_MASTER_MASK, SPI_0_OLED_FLASH_INTR_MASTER_MASKED */
N#define SPI_0_OLED_FLASH_INTR_MASTER_I2C_ARB_LOST_POS   (0u)  /* [0] Master lost arbitration                          */
N#define SPI_0_OLED_FLASH_INTR_MASTER_I2C_NACK_POS       (1u)  /* [1] Master receives NACK: address or write to slave  */
N#define SPI_0_OLED_FLASH_INTR_MASTER_I2C_ACK_POS        (2u)  /* [2] Master receives NACK: address or write to slave  */
N#define SPI_0_OLED_FLASH_INTR_MASTER_I2C_STOP_POS       (4u)  /* [4] Master detects the Stop: only self generated Stop*/
N#define SPI_0_OLED_FLASH_INTR_MASTER_I2C_BUS_ERROR_POS  (8u)  /* [8] Master detects bus error: misplaced Start or Stop*/
N#define SPI_0_OLED_FLASH_INTR_MASTER_SPI_DONE_POS       (9u)  /* [9] Master complete transfer: Only for SPI           */
N#define SPI_0_OLED_FLASH_INTR_MASTER_I2C_ARB_LOST       ((uint32) 0x01u)
N#define SPI_0_OLED_FLASH_INTR_MASTER_I2C_NACK           ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_MASTER_I2C_NACK_POS)
N#define SPI_0_OLED_FLASH_INTR_MASTER_I2C_ACK            ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_MASTER_I2C_ACK_POS)
N#define SPI_0_OLED_FLASH_INTR_MASTER_I2C_STOP           ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_MASTER_I2C_STOP_POS)
N#define SPI_0_OLED_FLASH_INTR_MASTER_I2C_BUS_ERROR      ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_INTR_MASTER_I2C_BUS_ERROR_POS)
X#define SPI_0_OLED_FLASH_INTR_MASTER_I2C_BUS_ERROR      ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_INTR_MASTER_I2C_BUS_ERROR_POS)
N#define SPI_0_OLED_FLASH_INTR_MASTER_SPI_DONE           ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_MASTER_SPI_DONE_POS)
N
N/*
N* SPI_0_OLED_FLASH_INTR_SLAVE, SPI_0_OLED_FLASH_INTR_SLAVE_SET,
N* SPI_0_OLED_FLASH_INTR_SLAVE_MASK, SPI_0_OLED_FLASH_INTR_SLAVE_MASKED
N*/
N#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ARB_LOST_POS         (0u)  /* [0]  Slave lost arbitration                   */
N#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_NACK_POS             (1u)  /* [1]  Slave receives NACK: master reads data   */
N#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ACK_POS              (2u)  /* [2]  Slave receives ACK: master reads data    */
N#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_WRITE_STOP_POS       (3u)  /* [3]  Slave detects end of write transaction   */
N#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_STOP_POS             (4u)  /* [4]  Slave detects end of transaction intended */
N#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_START_POS            (5u)  /* [5]  Slave detects Start                      */
N#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ADDR_MATCH_POS       (6u)  /* [6]  Slave address matches                    */
N#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_GENERAL_POS          (7u)  /* [7]  General call received                    */
N#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_BUS_ERROR_POS        (8u)  /* [8]  Slave detects bus error                  */
N#define SPI_0_OLED_FLASH_INTR_SLAVE_SPI_EZBUF_WRITE_STOP_POS (9u)  /* [9]  Slave write complete: Only for SPI       */
N#define SPI_0_OLED_FLASH_INTR_SLAVE_SPI_EZBUF_STOP_POS       (10u) /* [10] Slave end of transaction: Only for SPI   */
N#define SPI_0_OLED_FLASH_INTR_SLAVE_SPI_BUS_ERROR_POS        (11u) /* [11] Slave detects bus error: Only for SPI    */
N#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ARB_LOST             ((uint32) 0x01u)
N#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_NACK                 ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_INTR_SLAVE_I2C_NACK_POS)
X#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_NACK                 ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_INTR_SLAVE_I2C_NACK_POS)
N#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ACK                  ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ACK_POS)
X#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ACK                  ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ACK_POS)
N#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_WRITE_STOP           ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_INTR_SLAVE_I2C_WRITE_STOP_POS)
X#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_WRITE_STOP           ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_INTR_SLAVE_I2C_WRITE_STOP_POS)
N#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_STOP                 ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_INTR_SLAVE_I2C_STOP_POS)
X#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_STOP                 ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_INTR_SLAVE_I2C_STOP_POS)
N#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_START                ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_INTR_SLAVE_I2C_START_POS)
X#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_START                ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_INTR_SLAVE_I2C_START_POS)
N#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ADDR_MATCH           ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ADDR_MATCH_POS)
X#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ADDR_MATCH           ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ADDR_MATCH_POS)
N#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_GENERAL              ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_INTR_SLAVE_I2C_GENERAL_POS)
X#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_GENERAL              ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_INTR_SLAVE_I2C_GENERAL_POS)
N#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_BUS_ERROR            ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_INTR_SLAVE_I2C_BUS_ERROR_POS)
X#define SPI_0_OLED_FLASH_INTR_SLAVE_I2C_BUS_ERROR            ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_INTR_SLAVE_I2C_BUS_ERROR_POS)
N#define SPI_0_OLED_FLASH_INTR_SLAVE_SPI_EZBUF_WRITE_STOP     ((uint32) 0x01u << \
N                                                                   SPI_0_OLED_FLASH_INTR_SLAVE_SPI_EZBUF_WRITE_STOP_POS)
X#define SPI_0_OLED_FLASH_INTR_SLAVE_SPI_EZBUF_WRITE_STOP     ((uint32) 0x01u <<                                                                    SPI_0_OLED_FLASH_INTR_SLAVE_SPI_EZBUF_WRITE_STOP_POS)
N#define SPI_0_OLED_FLASH_INTR_SLAVE_SPI_EZBUF_STOP           ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_INTR_SLAVE_SPI_EZBUF_STOP_POS)
X#define SPI_0_OLED_FLASH_INTR_SLAVE_SPI_EZBUF_STOP           ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_INTR_SLAVE_SPI_EZBUF_STOP_POS)
N#define SPI_0_OLED_FLASH_INTR_SLAVE_SPI_BUS_ERROR           ((uint32) 0x01u << \
N                                                                    SPI_0_OLED_FLASH_INTR_SLAVE_SPI_BUS_ERROR_POS)
X#define SPI_0_OLED_FLASH_INTR_SLAVE_SPI_BUS_ERROR           ((uint32) 0x01u <<                                                                     SPI_0_OLED_FLASH_INTR_SLAVE_SPI_BUS_ERROR_POS)
N
N/*
N* SPI_0_OLED_FLASH_INTR_TX, SPI_0_OLED_FLASH_INTR_TX_SET,
N* SPI_0_OLED_FLASH_INTR_TX_MASK, SPI_0_OLED_FLASH_INTR_TX_MASKED
N*/
N#define SPI_0_OLED_FLASH_INTR_TX_TRIGGER_POS        (0u)  /* [0]  Trigger on TX FIFO entires                       */
N#define SPI_0_OLED_FLASH_INTR_TX_NOT_FULL_POS       (1u)  /* [1]  TX FIFO is not full                              */
N#define SPI_0_OLED_FLASH_INTR_TX_EMPTY_POS          (4u)  /* [4]  TX FIFO is empty                                 */
N#define SPI_0_OLED_FLASH_INTR_TX_OVERFLOW_POS       (5u)  /* [5]  Attempt to write to a full TX FIFO               */
N#define SPI_0_OLED_FLASH_INTR_TX_UNDERFLOW_POS      (6u)  /* [6]  Attempt to read from an empty TX FIFO            */
N#define SPI_0_OLED_FLASH_INTR_TX_BLOCKED_POS        (7u)  /* [7]  No access to the EZ memory                       */
N#define SPI_0_OLED_FLASH_INTR_TX_UART_NACK_POS      (8u)  /* [8]  UART transmitter received a NACK: SmartCard mode */
N#define SPI_0_OLED_FLASH_INTR_TX_UART_DONE_POS      (9u)  /* [9]  UART transmitter done even                       */
N#define SPI_0_OLED_FLASH_INTR_TX_UART_ARB_LOST_POS  (10u) /* [10] UART lost arbitration: LIN or SmartCard          */
N#define SPI_0_OLED_FLASH_INTR_TX_TRIGGER            ((uint32) 0x01u)
N#define SPI_0_OLED_FLASH_INTR_TX_FIFO_LEVEL         (SPI_0_OLED_FLASH_INTR_TX_TRIGGER)
N#define SPI_0_OLED_FLASH_INTR_TX_NOT_FULL           ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_TX_NOT_FULL_POS)
N#define SPI_0_OLED_FLASH_INTR_TX_EMPTY              ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_TX_EMPTY_POS)
N#define SPI_0_OLED_FLASH_INTR_TX_OVERFLOW           ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_TX_OVERFLOW_POS)
N#define SPI_0_OLED_FLASH_INTR_TX_UNDERFLOW          ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_TX_UNDERFLOW_POS)
N#define SPI_0_OLED_FLASH_INTR_TX_BLOCKED            ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_TX_BLOCKED_POS)
N#define SPI_0_OLED_FLASH_INTR_TX_UART_NACK          ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_TX_UART_NACK_POS)
N#define SPI_0_OLED_FLASH_INTR_TX_UART_DONE          ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_TX_UART_DONE_POS)
N#define SPI_0_OLED_FLASH_INTR_TX_UART_ARB_LOST      ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_TX_UART_ARB_LOST_POS)
N
N/*
N* SPI_0_OLED_FLASH_INTR_RX, SPI_0_OLED_FLASH_INTR_RX_SET,
N* SPI_0_OLED_FLASH_INTR_RX_MASK, SPI_0_OLED_FLASH_INTR_RX_MASKED
N*/
N#define SPI_0_OLED_FLASH_INTR_RX_TRIGGER_POS        (0u)   /* [0]  Trigger on RX FIFO entires            */
N#define SPI_0_OLED_FLASH_INTR_RX_NOT_EMPTY_POS      (2u)   /* [2]  RX FIFO is not empty                  */
N#define SPI_0_OLED_FLASH_INTR_RX_FULL_POS           (3u)   /* [3]  RX FIFO is full                       */
N#define SPI_0_OLED_FLASH_INTR_RX_OVERFLOW_POS       (5u)   /* [5]  Attempt to write to a full RX FIFO    */
N#define SPI_0_OLED_FLASH_INTR_RX_UNDERFLOW_POS      (6u)   /* [6]  Attempt to read from an empty RX FIFO */
N#define SPI_0_OLED_FLASH_INTR_RX_BLOCKED_POS        (7u)   /* [7]  No access to the EZ memory            */
N#define SPI_0_OLED_FLASH_INTR_RX_FRAME_ERROR_POS    (8u)   /* [8]  Frame error in received data frame    */
N#define SPI_0_OLED_FLASH_INTR_RX_PARITY_ERROR_POS   (9u)   /* [9]  Parity error in received data frame   */
N#define SPI_0_OLED_FLASH_INTR_RX_BAUD_DETECT_POS    (10u)  /* [10] LIN baud rate detection is completed   */
N#define SPI_0_OLED_FLASH_INTR_RX_BREAK_DETECT_POS   (11u)  /* [11] Break detection is successful         */
N#define SPI_0_OLED_FLASH_INTR_RX_TRIGGER            ((uint32) 0x01u)
N#define SPI_0_OLED_FLASH_INTR_RX_FIFO_LEVEL         (SPI_0_OLED_FLASH_INTR_RX_TRIGGER)
N#define SPI_0_OLED_FLASH_INTR_RX_NOT_EMPTY          ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_RX_NOT_EMPTY_POS)
N#define SPI_0_OLED_FLASH_INTR_RX_FULL               ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_RX_FULL_POS)
N#define SPI_0_OLED_FLASH_INTR_RX_OVERFLOW           ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_RX_OVERFLOW_POS)
N#define SPI_0_OLED_FLASH_INTR_RX_UNDERFLOW          ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_RX_UNDERFLOW_POS)
N#define SPI_0_OLED_FLASH_INTR_RX_BLOCKED            ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_RX_BLOCKED_POS)
N#define SPI_0_OLED_FLASH_INTR_RX_FRAME_ERROR        ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_RX_FRAME_ERROR_POS)
N#define SPI_0_OLED_FLASH_INTR_RX_PARITY_ERROR       ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_RX_PARITY_ERROR_POS)
N#define SPI_0_OLED_FLASH_INTR_RX_BAUD_DETECT        ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_RX_BAUD_DETECT_POS)
N#define SPI_0_OLED_FLASH_INTR_RX_BREAK_DETECT       ((uint32) 0x01u << SPI_0_OLED_FLASH_INTR_RX_BREAK_DETECT_POS)
N
N/* Define all interrupt sources */
N#define SPI_0_OLED_FLASH_INTR_I2C_EC_ALL    (SPI_0_OLED_FLASH_INTR_I2C_EC_WAKE_UP    | \
N                                             SPI_0_OLED_FLASH_INTR_I2C_EC_EZBUF_STOP | \
N                                             SPI_0_OLED_FLASH_INTR_I2C_EC_EZBUF_WRITE_STOP)
X#define SPI_0_OLED_FLASH_INTR_I2C_EC_ALL    (SPI_0_OLED_FLASH_INTR_I2C_EC_WAKE_UP    |                                              SPI_0_OLED_FLASH_INTR_I2C_EC_EZBUF_STOP |                                              SPI_0_OLED_FLASH_INTR_I2C_EC_EZBUF_WRITE_STOP)
N
N#define SPI_0_OLED_FLASH_INTR_SPI_EC_ALL    (SPI_0_OLED_FLASH_INTR_SPI_EC_WAKE_UP    | \
N                                             SPI_0_OLED_FLASH_INTR_SPI_EC_EZBUF_STOP | \
N                                             SPI_0_OLED_FLASH_INTR_SPI_EC_EZBUF_WRITE_STOP)
X#define SPI_0_OLED_FLASH_INTR_SPI_EC_ALL    (SPI_0_OLED_FLASH_INTR_SPI_EC_WAKE_UP    |                                              SPI_0_OLED_FLASH_INTR_SPI_EC_EZBUF_STOP |                                              SPI_0_OLED_FLASH_INTR_SPI_EC_EZBUF_WRITE_STOP)
N
N#define SPI_0_OLED_FLASH_INTR_MASTER_ALL    (SPI_0_OLED_FLASH_INTR_MASTER_I2C_ARB_LOST  | \
N                                             SPI_0_OLED_FLASH_INTR_MASTER_I2C_NACK      | \
N                                             SPI_0_OLED_FLASH_INTR_MASTER_I2C_ACK       | \
N                                             SPI_0_OLED_FLASH_INTR_MASTER_I2C_STOP      | \
N                                             SPI_0_OLED_FLASH_INTR_MASTER_I2C_BUS_ERROR | \
N                                             SPI_0_OLED_FLASH_INTR_MASTER_SPI_DONE)
X#define SPI_0_OLED_FLASH_INTR_MASTER_ALL    (SPI_0_OLED_FLASH_INTR_MASTER_I2C_ARB_LOST  |                                              SPI_0_OLED_FLASH_INTR_MASTER_I2C_NACK      |                                              SPI_0_OLED_FLASH_INTR_MASTER_I2C_ACK       |                                              SPI_0_OLED_FLASH_INTR_MASTER_I2C_STOP      |                                              SPI_0_OLED_FLASH_INTR_MASTER_I2C_BUS_ERROR |                                              SPI_0_OLED_FLASH_INTR_MASTER_SPI_DONE)
N
N#define SPI_0_OLED_FLASH_INTR_SLAVE_ALL     (SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ARB_LOST      | \
N                                             SPI_0_OLED_FLASH_INTR_SLAVE_I2C_NACK          | \
N                                             SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ACK           | \
N                                             SPI_0_OLED_FLASH_INTR_SLAVE_I2C_WRITE_STOP    | \
N                                             SPI_0_OLED_FLASH_INTR_SLAVE_I2C_STOP          | \
N                                             SPI_0_OLED_FLASH_INTR_SLAVE_I2C_START         | \
N                                             SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ADDR_MATCH    | \
N                                             SPI_0_OLED_FLASH_INTR_SLAVE_I2C_GENERAL       | \
N                                             SPI_0_OLED_FLASH_INTR_SLAVE_I2C_BUS_ERROR     | \
N                                             SPI_0_OLED_FLASH_INTR_SLAVE_SPI_EZBUF_WRITE_STOP | \
N                                             SPI_0_OLED_FLASH_INTR_SLAVE_SPI_EZBUF_STOP       | \
N                                             SPI_0_OLED_FLASH_INTR_SLAVE_SPI_BUS_ERROR)
X#define SPI_0_OLED_FLASH_INTR_SLAVE_ALL     (SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ARB_LOST      |                                              SPI_0_OLED_FLASH_INTR_SLAVE_I2C_NACK          |                                              SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ACK           |                                              SPI_0_OLED_FLASH_INTR_SLAVE_I2C_WRITE_STOP    |                                              SPI_0_OLED_FLASH_INTR_SLAVE_I2C_STOP          |                                              SPI_0_OLED_FLASH_INTR_SLAVE_I2C_START         |                                              SPI_0_OLED_FLASH_INTR_SLAVE_I2C_ADDR_MATCH    |                                              SPI_0_OLED_FLASH_INTR_SLAVE_I2C_GENERAL       |                                              SPI_0_OLED_FLASH_INTR_SLAVE_I2C_BUS_ERROR     |                                              SPI_0_OLED_FLASH_INTR_SLAVE_SPI_EZBUF_WRITE_STOP |                                              SPI_0_OLED_FLASH_INTR_SLAVE_SPI_EZBUF_STOP       |                                              SPI_0_OLED_FLASH_INTR_SLAVE_SPI_BUS_ERROR)
N
N#define SPI_0_OLED_FLASH_INTR_TX_ALL        (SPI_0_OLED_FLASH_INTR_TX_TRIGGER   | \
N                                             SPI_0_OLED_FLASH_INTR_TX_NOT_FULL  | \
N                                             SPI_0_OLED_FLASH_INTR_TX_EMPTY     | \
N                                             SPI_0_OLED_FLASH_INTR_TX_OVERFLOW  | \
N                                             SPI_0_OLED_FLASH_INTR_TX_UNDERFLOW | \
N                                             SPI_0_OLED_FLASH_INTR_TX_BLOCKED   | \
N                                             SPI_0_OLED_FLASH_INTR_TX_UART_NACK | \
N                                             SPI_0_OLED_FLASH_INTR_TX_UART_DONE | \
N                                             SPI_0_OLED_FLASH_INTR_TX_UART_ARB_LOST)
X#define SPI_0_OLED_FLASH_INTR_TX_ALL        (SPI_0_OLED_FLASH_INTR_TX_TRIGGER   |                                              SPI_0_OLED_FLASH_INTR_TX_NOT_FULL  |                                              SPI_0_OLED_FLASH_INTR_TX_EMPTY     |                                              SPI_0_OLED_FLASH_INTR_TX_OVERFLOW  |                                              SPI_0_OLED_FLASH_INTR_TX_UNDERFLOW |                                              SPI_0_OLED_FLASH_INTR_TX_BLOCKED   |                                              SPI_0_OLED_FLASH_INTR_TX_UART_NACK |                                              SPI_0_OLED_FLASH_INTR_TX_UART_DONE |                                              SPI_0_OLED_FLASH_INTR_TX_UART_ARB_LOST)
N
N#define SPI_0_OLED_FLASH_INTR_RX_ALL        (SPI_0_OLED_FLASH_INTR_RX_TRIGGER      | \
N                                             SPI_0_OLED_FLASH_INTR_RX_NOT_EMPTY    | \
N                                             SPI_0_OLED_FLASH_INTR_RX_FULL         | \
N                                             SPI_0_OLED_FLASH_INTR_RX_OVERFLOW     | \
N                                             SPI_0_OLED_FLASH_INTR_RX_UNDERFLOW    | \
N                                             SPI_0_OLED_FLASH_INTR_RX_BLOCKED      | \
N                                             SPI_0_OLED_FLASH_INTR_RX_FRAME_ERROR  | \
N                                             SPI_0_OLED_FLASH_INTR_RX_PARITY_ERROR | \
N                                             SPI_0_OLED_FLASH_INTR_RX_BAUD_DETECT  | \
N                                             SPI_0_OLED_FLASH_INTR_RX_BREAK_DETECT)
X#define SPI_0_OLED_FLASH_INTR_RX_ALL        (SPI_0_OLED_FLASH_INTR_RX_TRIGGER      |                                              SPI_0_OLED_FLASH_INTR_RX_NOT_EMPTY    |                                              SPI_0_OLED_FLASH_INTR_RX_FULL         |                                              SPI_0_OLED_FLASH_INTR_RX_OVERFLOW     |                                              SPI_0_OLED_FLASH_INTR_RX_UNDERFLOW    |                                              SPI_0_OLED_FLASH_INTR_RX_BLOCKED      |                                              SPI_0_OLED_FLASH_INTR_RX_FRAME_ERROR  |                                              SPI_0_OLED_FLASH_INTR_RX_PARITY_ERROR |                                              SPI_0_OLED_FLASH_INTR_RX_BAUD_DETECT  |                                              SPI_0_OLED_FLASH_INTR_RX_BREAK_DETECT)
N
N/* I2C and EZI2C slave address defines */
N#define SPI_0_OLED_FLASH_I2C_SLAVE_ADDR_POS    (0x01u)    /* 7-bit address shift */
N#define SPI_0_OLED_FLASH_I2C_SLAVE_ADDR_MASK   (0xFEu)    /* 8-bit address mask */
N
N/* OVS constants for IrDA Low Power operation */
N#define SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS16     (0x00u)
N#define SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS32     (0x01u)
N#define SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS48     (0x02u)
N#define SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS96     (0x03u)
N#define SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS192    (0x04u)
N#define SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS768    (0x05u)
N#define SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS1536   (0x06u)
N
N/* OVS constant for IrDA */
N#define SPI_0_OLED_FLASH_CTRL_OVS_IRDA_OVS16        (SPI_0_OLED_FLASH_UART_IRDA_LP_OVS16)
N
N
N/***************************************
N*    Common Macro Definitions
N***************************************/
N
N/* Re-enables the SCB IP. A clear enable bit has a different effect
N* on the scb IP depending on the version:
N*  CY_SCBIP_V0: resets state, status, TX and RX FIFOs.
N*  CY_SCBIP_V1 or later: resets state, status, TX and RX FIFOs and interrupt sources.
N* Clear I2C command registers are because they are not impacted by re-enable.
N*/
N#define SPI_0_OLED_FLASH_SCB_SW_RESET   SPI_0_OLED_FLASH_I2CFwBlockReset()
N
N/* TX FIFO macro */
N#define SPI_0_OLED_FLASH_CLEAR_TX_FIFO \
N                            do{        \
N                                SPI_0_OLED_FLASH_TX_FIFO_CTRL_REG |= ((uint32)  SPI_0_OLED_FLASH_TX_FIFO_CTRL_CLEAR); \
N                                SPI_0_OLED_FLASH_TX_FIFO_CTRL_REG &= ((uint32) ~SPI_0_OLED_FLASH_TX_FIFO_CTRL_CLEAR); \
N                            }while(0)
X#define SPI_0_OLED_FLASH_CLEAR_TX_FIFO                             do{                                        SPI_0_OLED_FLASH_TX_FIFO_CTRL_REG |= ((uint32)  SPI_0_OLED_FLASH_TX_FIFO_CTRL_CLEAR);                                 SPI_0_OLED_FLASH_TX_FIFO_CTRL_REG &= ((uint32) ~SPI_0_OLED_FLASH_TX_FIFO_CTRL_CLEAR);                             }while(0)
N
N#define SPI_0_OLED_FLASH_GET_TX_FIFO_ENTRIES    (SPI_0_OLED_FLASH_TX_FIFO_STATUS_REG & \
N                                                 SPI_0_OLED_FLASH_TX_FIFO_STATUS_USED_MASK)
X#define SPI_0_OLED_FLASH_GET_TX_FIFO_ENTRIES    (SPI_0_OLED_FLASH_TX_FIFO_STATUS_REG &                                                  SPI_0_OLED_FLASH_TX_FIFO_STATUS_USED_MASK)
N
N#define SPI_0_OLED_FLASH_GET_TX_FIFO_SR_VALID   ((0u != (SPI_0_OLED_FLASH_TX_FIFO_STATUS_REG & \
N                                                         SPI_0_OLED_FLASH_TX_FIFO_SR_VALID)) ? (1u) : (0u))
X#define SPI_0_OLED_FLASH_GET_TX_FIFO_SR_VALID   ((0u != (SPI_0_OLED_FLASH_TX_FIFO_STATUS_REG &                                                          SPI_0_OLED_FLASH_TX_FIFO_SR_VALID)) ? (1u) : (0u))
N
N/* RX FIFO macro */
N#define SPI_0_OLED_FLASH_CLEAR_RX_FIFO \
N                            do{        \
N                                SPI_0_OLED_FLASH_RX_FIFO_CTRL_REG |= ((uint32)  SPI_0_OLED_FLASH_RX_FIFO_CTRL_CLEAR); \
N                                SPI_0_OLED_FLASH_RX_FIFO_CTRL_REG &= ((uint32) ~SPI_0_OLED_FLASH_RX_FIFO_CTRL_CLEAR); \
N                            }while(0)
X#define SPI_0_OLED_FLASH_CLEAR_RX_FIFO                             do{                                        SPI_0_OLED_FLASH_RX_FIFO_CTRL_REG |= ((uint32)  SPI_0_OLED_FLASH_RX_FIFO_CTRL_CLEAR);                                 SPI_0_OLED_FLASH_RX_FIFO_CTRL_REG &= ((uint32) ~SPI_0_OLED_FLASH_RX_FIFO_CTRL_CLEAR);                             }while(0)
N
N#define SPI_0_OLED_FLASH_GET_RX_FIFO_ENTRIES    (SPI_0_OLED_FLASH_RX_FIFO_STATUS_REG & \
N                                                    SPI_0_OLED_FLASH_RX_FIFO_STATUS_USED_MASK)
X#define SPI_0_OLED_FLASH_GET_RX_FIFO_ENTRIES    (SPI_0_OLED_FLASH_RX_FIFO_STATUS_REG &                                                     SPI_0_OLED_FLASH_RX_FIFO_STATUS_USED_MASK)
N
N#define SPI_0_OLED_FLASH_GET_RX_FIFO_SR_VALID   ((0u != (SPI_0_OLED_FLASH_RX_FIFO_STATUS_REG & \
N                                                         SPI_0_OLED_FLASH_RX_FIFO_SR_VALID)) ? (1u) : (0u))
X#define SPI_0_OLED_FLASH_GET_RX_FIFO_SR_VALID   ((0u != (SPI_0_OLED_FLASH_RX_FIFO_STATUS_REG &                                                          SPI_0_OLED_FLASH_RX_FIFO_SR_VALID)) ? (1u) : (0u))
N
N/* Write interrupt source: set sourceMask bits in SPI_0_OLED_FLASH_INTR_X_MASK_REG */
N#define SPI_0_OLED_FLASH_WRITE_INTR_I2C_EC_MASK(sourceMask) \
N                                                do{         \
N                                                    SPI_0_OLED_FLASH_INTR_I2C_EC_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_0_OLED_FLASH_WRITE_INTR_I2C_EC_MASK(sourceMask)                                                 do{                                                             SPI_0_OLED_FLASH_INTR_I2C_EC_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#if (!SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_0_OLED_FLASH_WRITE_INTR_SPI_EC_MASK(sourceMask) \
N                                                do{         \
N                                                    SPI_0_OLED_FLASH_INTR_SPI_EC_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X    #define SPI_0_OLED_FLASH_WRITE_INTR_SPI_EC_MASK(sourceMask)                                                 do{                                                             SPI_0_OLED_FLASH_INTR_SPI_EC_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N#endif /* (!SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N
N#define SPI_0_OLED_FLASH_WRITE_INTR_MASTER_MASK(sourceMask) \
N                                                do{         \
N                                                    SPI_0_OLED_FLASH_INTR_MASTER_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_0_OLED_FLASH_WRITE_INTR_MASTER_MASK(sourceMask)                                                 do{                                                             SPI_0_OLED_FLASH_INTR_MASTER_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_0_OLED_FLASH_WRITE_INTR_SLAVE_MASK(sourceMask)  \
N                                                do{         \
N                                                    SPI_0_OLED_FLASH_INTR_SLAVE_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_0_OLED_FLASH_WRITE_INTR_SLAVE_MASK(sourceMask)                                                  do{                                                             SPI_0_OLED_FLASH_INTR_SLAVE_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_0_OLED_FLASH_WRITE_INTR_TX_MASK(sourceMask)     \
N                                                do{         \
N                                                    SPI_0_OLED_FLASH_INTR_TX_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_0_OLED_FLASH_WRITE_INTR_TX_MASK(sourceMask)                                                     do{                                                             SPI_0_OLED_FLASH_INTR_TX_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_0_OLED_FLASH_WRITE_INTR_RX_MASK(sourceMask)     \
N                                                do{         \
N                                                    SPI_0_OLED_FLASH_INTR_RX_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_0_OLED_FLASH_WRITE_INTR_RX_MASK(sourceMask)                                                     do{                                                             SPI_0_OLED_FLASH_INTR_RX_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N/* Enable interrupt source: set sourceMask bits in SPI_0_OLED_FLASH_INTR_X_MASK_REG */
N#define SPI_0_OLED_FLASH_ENABLE_INTR_I2C_EC(sourceMask) \
N                                                do{     \
N                                                    SPI_0_OLED_FLASH_INTR_I2C_EC_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_0_OLED_FLASH_ENABLE_INTR_I2C_EC(sourceMask)                                                 do{                                                         SPI_0_OLED_FLASH_INTR_I2C_EC_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N#if (!SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_0_OLED_FLASH_ENABLE_INTR_SPI_EC(sourceMask) \
N                                                do{     \
N                                                    SPI_0_OLED_FLASH_INTR_SPI_EC_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X    #define SPI_0_OLED_FLASH_ENABLE_INTR_SPI_EC(sourceMask)                                                 do{                                                         SPI_0_OLED_FLASH_INTR_SPI_EC_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N#endif /* (!SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N
N#define SPI_0_OLED_FLASH_ENABLE_INTR_MASTER(sourceMask) \
N                                                do{     \
N                                                    SPI_0_OLED_FLASH_INTR_MASTER_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_0_OLED_FLASH_ENABLE_INTR_MASTER(sourceMask)                                                 do{                                                         SPI_0_OLED_FLASH_INTR_MASTER_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_0_OLED_FLASH_ENABLE_INTR_SLAVE(sourceMask)  \
N                                                do{     \
N                                                    SPI_0_OLED_FLASH_INTR_SLAVE_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_0_OLED_FLASH_ENABLE_INTR_SLAVE(sourceMask)                                                  do{                                                         SPI_0_OLED_FLASH_INTR_SLAVE_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_0_OLED_FLASH_ENABLE_INTR_TX(sourceMask)     \
N                                                do{     \
N                                                    SPI_0_OLED_FLASH_INTR_TX_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_0_OLED_FLASH_ENABLE_INTR_TX(sourceMask)                                                     do{                                                         SPI_0_OLED_FLASH_INTR_TX_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_0_OLED_FLASH_ENABLE_INTR_RX(sourceMask)     \
N                                                do{     \
N                                                    SPI_0_OLED_FLASH_INTR_RX_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_0_OLED_FLASH_ENABLE_INTR_RX(sourceMask)                                                     do{                                                         SPI_0_OLED_FLASH_INTR_RX_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N/* Disable interrupt source: clear sourceMask bits in SPI_0_OLED_FLASH_INTR_X_MASK_REG */
N#define SPI_0_OLED_FLASH_DISABLE_INTR_I2C_EC(sourceMask) \
N                                do{                      \
N                                    SPI_0_OLED_FLASH_INTR_I2C_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define SPI_0_OLED_FLASH_DISABLE_INTR_I2C_EC(sourceMask)                                 do{                                                          SPI_0_OLED_FLASH_INTR_I2C_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N#if (!SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_0_OLED_FLASH_DISABLE_INTR_SPI_EC(sourceMask) \
N                                do{                      \
N                                    SPI_0_OLED_FLASH_INTR_SPI_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                 }while(0)
X    #define SPI_0_OLED_FLASH_DISABLE_INTR_SPI_EC(sourceMask)                                 do{                                                          SPI_0_OLED_FLASH_INTR_SPI_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                  }while(0)
N#endif /* (!SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N
N#define SPI_0_OLED_FLASH_DISABLE_INTR_MASTER(sourceMask) \
N                                do{                      \
N                                SPI_0_OLED_FLASH_INTR_MASTER_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define SPI_0_OLED_FLASH_DISABLE_INTR_MASTER(sourceMask)                                 do{                                                      SPI_0_OLED_FLASH_INTR_MASTER_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N#define SPI_0_OLED_FLASH_DISABLE_INTR_SLAVE(sourceMask) \
N                                do{                     \
N                                    SPI_0_OLED_FLASH_INTR_SLAVE_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define SPI_0_OLED_FLASH_DISABLE_INTR_SLAVE(sourceMask)                                 do{                                                         SPI_0_OLED_FLASH_INTR_SLAVE_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N#define SPI_0_OLED_FLASH_DISABLE_INTR_TX(sourceMask)    \
N                                do{                     \
N                                    SPI_0_OLED_FLASH_INTR_TX_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                 }while(0)
X#define SPI_0_OLED_FLASH_DISABLE_INTR_TX(sourceMask)                                    do{                                                         SPI_0_OLED_FLASH_INTR_TX_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                  }while(0)
N
N#define SPI_0_OLED_FLASH_DISABLE_INTR_RX(sourceMask)    \
N                                do{                     \
N                                    SPI_0_OLED_FLASH_INTR_RX_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define SPI_0_OLED_FLASH_DISABLE_INTR_RX(sourceMask)                                    do{                                                         SPI_0_OLED_FLASH_INTR_RX_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N/* Set interrupt sources: write sourceMask bits in SPI_0_OLED_FLASH_INTR_X_SET_REG */
N#define SPI_0_OLED_FLASH_SET_INTR_MASTER(sourceMask)    \
N                                                do{     \
N                                                    SPI_0_OLED_FLASH_INTR_MASTER_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_0_OLED_FLASH_SET_INTR_MASTER(sourceMask)                                                    do{                                                         SPI_0_OLED_FLASH_INTR_MASTER_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_0_OLED_FLASH_SET_INTR_SLAVE(sourceMask) \
N                                                do{ \
N                                                    SPI_0_OLED_FLASH_INTR_SLAVE_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_0_OLED_FLASH_SET_INTR_SLAVE(sourceMask)                                                 do{                                                     SPI_0_OLED_FLASH_INTR_SLAVE_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_0_OLED_FLASH_SET_INTR_TX(sourceMask)    \
N                                                do{ \
N                                                    SPI_0_OLED_FLASH_INTR_TX_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_0_OLED_FLASH_SET_INTR_TX(sourceMask)                                                    do{                                                     SPI_0_OLED_FLASH_INTR_TX_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_0_OLED_FLASH_SET_INTR_RX(sourceMask)    \
N                                                do{ \
N                                                    SPI_0_OLED_FLASH_INTR_RX_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_0_OLED_FLASH_SET_INTR_RX(sourceMask)                                                    do{                                                     SPI_0_OLED_FLASH_INTR_RX_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N/* Clear interrupt sources: write sourceMask bits in SPI_0_OLED_FLASH_INTR_X_REG */
N#define SPI_0_OLED_FLASH_CLEAR_INTR_I2C_EC(sourceMask)  \
N                                                do{     \
N                                                    SPI_0_OLED_FLASH_INTR_I2C_EC_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_0_OLED_FLASH_CLEAR_INTR_I2C_EC(sourceMask)                                                  do{                                                         SPI_0_OLED_FLASH_INTR_I2C_EC_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#if (!SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_0_OLED_FLASH_CLEAR_INTR_SPI_EC(sourceMask)  \
N                                                do{     \
N                                                    SPI_0_OLED_FLASH_INTR_SPI_EC_REG = (uint32) (sourceMask); \
N                                                }while(0)
X    #define SPI_0_OLED_FLASH_CLEAR_INTR_SPI_EC(sourceMask)                                                  do{                                                         SPI_0_OLED_FLASH_INTR_SPI_EC_REG = (uint32) (sourceMask);                                                 }while(0)
N#endif /* (!SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N
N#define SPI_0_OLED_FLASH_CLEAR_INTR_MASTER(sourceMask)  \
N                                                do{     \
N                                                    SPI_0_OLED_FLASH_INTR_MASTER_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_0_OLED_FLASH_CLEAR_INTR_MASTER(sourceMask)                                                  do{                                                         SPI_0_OLED_FLASH_INTR_MASTER_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_0_OLED_FLASH_CLEAR_INTR_SLAVE(sourceMask)   \
N                                                do{     \
N                                                    SPI_0_OLED_FLASH_INTR_SLAVE_REG  = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_0_OLED_FLASH_CLEAR_INTR_SLAVE(sourceMask)                                                   do{                                                         SPI_0_OLED_FLASH_INTR_SLAVE_REG  = (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_0_OLED_FLASH_CLEAR_INTR_TX(sourceMask)      \
N                                                do{     \
N                                                    SPI_0_OLED_FLASH_INTR_TX_REG     = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_0_OLED_FLASH_CLEAR_INTR_TX(sourceMask)                                                      do{                                                         SPI_0_OLED_FLASH_INTR_TX_REG     = (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_0_OLED_FLASH_CLEAR_INTR_RX(sourceMask)      \
N                                                do{     \
N                                                    SPI_0_OLED_FLASH_INTR_RX_REG     = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_0_OLED_FLASH_CLEAR_INTR_RX(sourceMask)                                                      do{                                                         SPI_0_OLED_FLASH_INTR_RX_REG     = (uint32) (sourceMask);                                                 }while(0)
N
N/* Return true if sourceMask is set in SPI_0_OLED_FLASH_INTR_CAUSE_REG */
N#define SPI_0_OLED_FLASH_CHECK_CAUSE_INTR(sourceMask)    (0u != (SPI_0_OLED_FLASH_INTR_CAUSE_REG & (sourceMask)))
N
N/* Return true if sourceMask is set in INTR_X_MASKED_REG */
N#define SPI_0_OLED_FLASH_CHECK_INTR_I2C_EC(sourceMask)  (0u != (SPI_0_OLED_FLASH_INTR_I2C_EC_REG & (sourceMask)))
N#if (!SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_0_OLED_FLASH_CHECK_INTR_SPI_EC(sourceMask)  (0u != (SPI_0_OLED_FLASH_INTR_SPI_EC_REG & (sourceMask)))
N#endif /* (!SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N#define SPI_0_OLED_FLASH_CHECK_INTR_MASTER(sourceMask)  (0u != (SPI_0_OLED_FLASH_INTR_MASTER_REG & (sourceMask)))
N#define SPI_0_OLED_FLASH_CHECK_INTR_SLAVE(sourceMask)   (0u != (SPI_0_OLED_FLASH_INTR_SLAVE_REG  & (sourceMask)))
N#define SPI_0_OLED_FLASH_CHECK_INTR_TX(sourceMask)      (0u != (SPI_0_OLED_FLASH_INTR_TX_REG     & (sourceMask)))
N#define SPI_0_OLED_FLASH_CHECK_INTR_RX(sourceMask)      (0u != (SPI_0_OLED_FLASH_INTR_RX_REG     & (sourceMask)))
N
N/* Return true if sourceMask is set in SPI_0_OLED_FLASH_INTR_X_MASKED_REG */
N#define SPI_0_OLED_FLASH_CHECK_INTR_I2C_EC_MASKED(sourceMask)   (0u != (SPI_0_OLED_FLASH_INTR_I2C_EC_MASKED_REG & \
N                                                                       (sourceMask)))
X#define SPI_0_OLED_FLASH_CHECK_INTR_I2C_EC_MASKED(sourceMask)   (0u != (SPI_0_OLED_FLASH_INTR_I2C_EC_MASKED_REG &                                                                        (sourceMask)))
N#if (!SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_0_OLED_FLASH_CHECK_INTR_SPI_EC_MASKED(sourceMask)   (0u != (SPI_0_OLED_FLASH_INTR_SPI_EC_MASKED_REG & \
N                                                                       (sourceMask)))
X    #define SPI_0_OLED_FLASH_CHECK_INTR_SPI_EC_MASKED(sourceMask)   (0u != (SPI_0_OLED_FLASH_INTR_SPI_EC_MASKED_REG &                                                                        (sourceMask)))
N#endif /* (!SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N#define SPI_0_OLED_FLASH_CHECK_INTR_MASTER_MASKED(sourceMask)   (0u != (SPI_0_OLED_FLASH_INTR_MASTER_MASKED_REG & \
N                                                                       (sourceMask)))
X#define SPI_0_OLED_FLASH_CHECK_INTR_MASTER_MASKED(sourceMask)   (0u != (SPI_0_OLED_FLASH_INTR_MASTER_MASKED_REG &                                                                        (sourceMask)))
N#define SPI_0_OLED_FLASH_CHECK_INTR_SLAVE_MASKED(sourceMask)    (0u != (SPI_0_OLED_FLASH_INTR_SLAVE_MASKED_REG  & \
N                                                                       (sourceMask)))
X#define SPI_0_OLED_FLASH_CHECK_INTR_SLAVE_MASKED(sourceMask)    (0u != (SPI_0_OLED_FLASH_INTR_SLAVE_MASKED_REG  &                                                                        (sourceMask)))
N#define SPI_0_OLED_FLASH_CHECK_INTR_TX_MASKED(sourceMask)       (0u != (SPI_0_OLED_FLASH_INTR_TX_MASKED_REG     & \
N                                                                       (sourceMask)))
X#define SPI_0_OLED_FLASH_CHECK_INTR_TX_MASKED(sourceMask)       (0u != (SPI_0_OLED_FLASH_INTR_TX_MASKED_REG     &                                                                        (sourceMask)))
N#define SPI_0_OLED_FLASH_CHECK_INTR_RX_MASKED(sourceMask)       (0u != (SPI_0_OLED_FLASH_INTR_RX_MASKED_REG     & \
N                                                                       (sourceMask)))
X#define SPI_0_OLED_FLASH_CHECK_INTR_RX_MASKED(sourceMask)       (0u != (SPI_0_OLED_FLASH_INTR_RX_MASKED_REG     &                                                                        (sourceMask)))
N
N/* Return true if sourceMask is set in SPI_0_OLED_FLASH_CTRL_REG: generally is used to check enable bit */
N#define SPI_0_OLED_FLASH_GET_CTRL_ENABLED    (0u != (SPI_0_OLED_FLASH_CTRL_REG & SPI_0_OLED_FLASH_CTRL_ENABLED))
N
N#define SPI_0_OLED_FLASH_CHECK_SLAVE_AUTO_ADDR_NACK     (0u != (SPI_0_OLED_FLASH_I2C_CTRL_REG & \
N                                                                SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK))
X#define SPI_0_OLED_FLASH_CHECK_SLAVE_AUTO_ADDR_NACK     (0u != (SPI_0_OLED_FLASH_I2C_CTRL_REG &                                                                 SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK))
N
N
N/***************************************
N*      I2C Macro Definitions
N***************************************/
N
N/* Enable auto ACK/NACK */
N#define SPI_0_OLED_FLASH_ENABLE_SLAVE_AUTO_ADDR_NACK \
N                            do{                      \
N                                SPI_0_OLED_FLASH_I2C_CTRL_REG |= SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define SPI_0_OLED_FLASH_ENABLE_SLAVE_AUTO_ADDR_NACK                             do{                                                      SPI_0_OLED_FLASH_I2C_CTRL_REG |= SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define SPI_0_OLED_FLASH_ENABLE_SLAVE_AUTO_DATA_ACK \
N                            do{                     \
N                                SPI_0_OLED_FLASH_I2C_CTRL_REG |= SPI_0_OLED_FLASH_I2C_CTRL_S_READY_DATA_ACK; \
N                            }while(0)
X#define SPI_0_OLED_FLASH_ENABLE_SLAVE_AUTO_DATA_ACK                             do{                                                     SPI_0_OLED_FLASH_I2C_CTRL_REG |= SPI_0_OLED_FLASH_I2C_CTRL_S_READY_DATA_ACK;                             }while(0)
N
N#define SPI_0_OLED_FLASH_ENABLE_SLAVE_AUTO_DATA_NACK \
N                            do{                      \
N                                SPI_0_OLED_FLASH_I2C_CTRL_REG |= SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define SPI_0_OLED_FLASH_ENABLE_SLAVE_AUTO_DATA_NACK                             do{                                                      SPI_0_OLED_FLASH_I2C_CTRL_REG |= SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define SPI_0_OLED_FLASH_ENABLE_MASTER_AUTO_DATA_ACK \
N                            do{                      \
N                                SPI_0_OLED_FLASH_I2C_CTRL_REG |= SPI_0_OLED_FLASH_I2C_CTRL_M_READY_DATA_ACK; \
N                            }while(0)
X#define SPI_0_OLED_FLASH_ENABLE_MASTER_AUTO_DATA_ACK                             do{                                                      SPI_0_OLED_FLASH_I2C_CTRL_REG |= SPI_0_OLED_FLASH_I2C_CTRL_M_READY_DATA_ACK;                             }while(0)
N
N#define SPI_0_OLED_FLASH_ENABLE_MASTER_AUTO_DATA_NACK \
N                            do{                       \
N                                SPI_0_OLED_FLASH_I2C_CTRL_REG |= SPI_0_OLED_FLASH_I2C_CTRL_M_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define SPI_0_OLED_FLASH_ENABLE_MASTER_AUTO_DATA_NACK                             do{                                                       SPI_0_OLED_FLASH_I2C_CTRL_REG |= SPI_0_OLED_FLASH_I2C_CTRL_M_NOT_READY_DATA_NACK;                             }while(0)
N
N/* Disable auto ACK/NACK */
N#define SPI_0_OLED_FLASH_DISABLE_SLAVE_AUTO_ADDR_NACK \
N                            do{                       \
N                                SPI_0_OLED_FLASH_I2C_CTRL_REG &= ~SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define SPI_0_OLED_FLASH_DISABLE_SLAVE_AUTO_ADDR_NACK                             do{                                                       SPI_0_OLED_FLASH_I2C_CTRL_REG &= ~SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define SPI_0_OLED_FLASH_DISABLE_SLAVE_AUTO_DATA_ACK \
N                            do{                      \
N                                SPI_0_OLED_FLASH_I2C_CTRL_REG &= ~SPI_0_OLED_FLASH_I2C_CTRL_S_READY_DATA_ACK; \
N                            }while(0)
X#define SPI_0_OLED_FLASH_DISABLE_SLAVE_AUTO_DATA_ACK                             do{                                                      SPI_0_OLED_FLASH_I2C_CTRL_REG &= ~SPI_0_OLED_FLASH_I2C_CTRL_S_READY_DATA_ACK;                             }while(0)
N
N#define SPI_0_OLED_FLASH_DISABLE_SLAVE_AUTO_DATA_NACK \
N                            do{                       \
N                                SPI_0_OLED_FLASH_I2C_CTRL_REG &= ~SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define SPI_0_OLED_FLASH_DISABLE_SLAVE_AUTO_DATA_NACK                             do{                                                       SPI_0_OLED_FLASH_I2C_CTRL_REG &= ~SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define SPI_0_OLED_FLASH_DISABLE_MASTER_AUTO_DATA_ACK \
N                            do{                       \
N                                SPI_0_OLED_FLASH_I2C_CTRL_REG &= ~SPI_0_OLED_FLASH_I2C_CTRL_M_READY_DATA_ACK; \
N                            }while(0)
X#define SPI_0_OLED_FLASH_DISABLE_MASTER_AUTO_DATA_ACK                             do{                                                       SPI_0_OLED_FLASH_I2C_CTRL_REG &= ~SPI_0_OLED_FLASH_I2C_CTRL_M_READY_DATA_ACK;                             }while(0)
N
N#define SPI_0_OLED_FLASH_DISABLE_MASTER_AUTO_DATA_NACK \
N                            do{                        \
N                                SPI_0_OLED_FLASH_I2C_CTRL_REG &= ~SPI_0_OLED_FLASH_I2C_CTRL_M_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define SPI_0_OLED_FLASH_DISABLE_MASTER_AUTO_DATA_NACK                             do{                                                        SPI_0_OLED_FLASH_I2C_CTRL_REG &= ~SPI_0_OLED_FLASH_I2C_CTRL_M_NOT_READY_DATA_NACK;                             }while(0)
N
N/* Enable Slave autoACK/NACK Data */
N#define SPI_0_OLED_FLASH_ENABLE_SLAVE_AUTO_DATA \
N                            do{                 \
N                                SPI_0_OLED_FLASH_I2C_CTRL_REG |= (SPI_0_OLED_FLASH_I2C_CTRL_S_READY_DATA_ACK |      \
N                                                                  SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK); \
N                            }while(0)
X#define SPI_0_OLED_FLASH_ENABLE_SLAVE_AUTO_DATA                             do{                                                 SPI_0_OLED_FLASH_I2C_CTRL_REG |= (SPI_0_OLED_FLASH_I2C_CTRL_S_READY_DATA_ACK |                                                                        SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK);                             }while(0)
N
N/* Disable Slave autoACK/NACK Data */
N#define SPI_0_OLED_FLASH_DISABLE_SLAVE_AUTO_DATA \
N                            do{                  \
N                                SPI_0_OLED_FLASH_I2C_CTRL_REG &= ((uint32) \
N                                                                  ~(SPI_0_OLED_FLASH_I2C_CTRL_S_READY_DATA_ACK |       \
N                                                                    SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK)); \
N                            }while(0)
X#define SPI_0_OLED_FLASH_DISABLE_SLAVE_AUTO_DATA                             do{                                                  SPI_0_OLED_FLASH_I2C_CTRL_REG &= ((uint32)                                                                   ~(SPI_0_OLED_FLASH_I2C_CTRL_S_READY_DATA_ACK |                                                                           SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK));                             }while(0)
N
N/* Disable Master autoACK/NACK Data */
N#define SPI_0_OLED_FLASH_DISABLE_MASTER_AUTO_DATA \
N                            do{                   \
N                                SPI_0_OLED_FLASH_I2C_CTRL_REG &= ((uint32) \
N                                                                  ~(SPI_0_OLED_FLASH_I2C_CTRL_M_READY_DATA_ACK |       \
N                                                                    SPI_0_OLED_FLASH_I2C_CTRL_M_NOT_READY_DATA_NACK)); \
N                            }while(0)
X#define SPI_0_OLED_FLASH_DISABLE_MASTER_AUTO_DATA                             do{                                                   SPI_0_OLED_FLASH_I2C_CTRL_REG &= ((uint32)                                                                   ~(SPI_0_OLED_FLASH_I2C_CTRL_M_READY_DATA_ACK |                                                                           SPI_0_OLED_FLASH_I2C_CTRL_M_NOT_READY_DATA_NACK));                             }while(0)
N/* Disables auto data ACK/NACK bits */
N#define SPI_0_OLED_FLASH_DISABLE_AUTO_DATA \
N                do{                        \
N                    SPI_0_OLED_FLASH_I2C_CTRL_REG &= ((uint32) ~(SPI_0_OLED_FLASH_I2C_CTRL_M_READY_DATA_ACK      |  \
N                                                                 SPI_0_OLED_FLASH_I2C_CTRL_M_NOT_READY_DATA_NACK |  \
N                                                                 SPI_0_OLED_FLASH_I2C_CTRL_S_READY_DATA_ACK      |  \
N                                                                 SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK)); \
N                }while(0)
X#define SPI_0_OLED_FLASH_DISABLE_AUTO_DATA                 do{                                            SPI_0_OLED_FLASH_I2C_CTRL_REG &= ((uint32) ~(SPI_0_OLED_FLASH_I2C_CTRL_M_READY_DATA_ACK      |                                                                   SPI_0_OLED_FLASH_I2C_CTRL_M_NOT_READY_DATA_NACK |                                                                   SPI_0_OLED_FLASH_I2C_CTRL_S_READY_DATA_ACK      |                                                                   SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_DATA_NACK));                 }while(0)
N
N/* Master commands */
N#define SPI_0_OLED_FLASH_I2C_MASTER_GENERATE_START \
N                            do{                    \
N                                SPI_0_OLED_FLASH_I2C_MASTER_CMD_REG = SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_START_ON_IDLE; \
N                            }while(0)
X#define SPI_0_OLED_FLASH_I2C_MASTER_GENERATE_START                             do{                                                    SPI_0_OLED_FLASH_I2C_MASTER_CMD_REG = SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_START_ON_IDLE;                             }while(0)
N
N#define SPI_0_OLED_FLASH_I2C_MASTER_CLEAR_START \
N                            do{                 \
N                                SPI_0_OLED_FLASH_I2C_MASTER_CMD_REG =  ((uint32) 0u); \
N                            }while(0)
X#define SPI_0_OLED_FLASH_I2C_MASTER_CLEAR_START                             do{                                                 SPI_0_OLED_FLASH_I2C_MASTER_CMD_REG =  ((uint32) 0u);                             }while(0)
N
N#define SPI_0_OLED_FLASH_I2C_MASTER_GENERATE_RESTART SPI_0_OLED_FLASH_I2CReStartGeneration()
N
N#define SPI_0_OLED_FLASH_I2C_MASTER_GENERATE_STOP \
N                            do{                   \
N                                SPI_0_OLED_FLASH_I2C_MASTER_CMD_REG =                                            \
N                                    (SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_STOP |                                    \
N                                        (SPI_0_OLED_FLASH_CHECK_I2C_STATUS(SPI_0_OLED_FLASH_I2C_STATUS_M_READ) ? \
N                                            (SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_NACK) : (0u)));                   \
N                            }while(0)
X#define SPI_0_OLED_FLASH_I2C_MASTER_GENERATE_STOP                             do{                                                   SPI_0_OLED_FLASH_I2C_MASTER_CMD_REG =                                                                                (SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_STOP |                                                                            (SPI_0_OLED_FLASH_CHECK_I2C_STATUS(SPI_0_OLED_FLASH_I2C_STATUS_M_READ) ?                                             (SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_NACK) : (0u)));                                               }while(0)
N
N#define SPI_0_OLED_FLASH_I2C_MASTER_GENERATE_ACK \
N                            do{                  \
N                                SPI_0_OLED_FLASH_I2C_MASTER_CMD_REG = SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_ACK; \
N                            }while(0)
X#define SPI_0_OLED_FLASH_I2C_MASTER_GENERATE_ACK                             do{                                                  SPI_0_OLED_FLASH_I2C_MASTER_CMD_REG = SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_ACK;                             }while(0)
N
N#define SPI_0_OLED_FLASH_I2C_MASTER_GENERATE_NACK \
N                            do{                   \
N                                SPI_0_OLED_FLASH_I2C_MASTER_CMD_REG = SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_NACK; \
N                            }while(0)
X#define SPI_0_OLED_FLASH_I2C_MASTER_GENERATE_NACK                             do{                                                   SPI_0_OLED_FLASH_I2C_MASTER_CMD_REG = SPI_0_OLED_FLASH_I2C_MASTER_CMD_M_NACK;                             }while(0)
N
N/* Slave commands */
N#define SPI_0_OLED_FLASH_I2C_SLAVE_GENERATE_ACK \
N                            do{                 \
N                                SPI_0_OLED_FLASH_I2C_SLAVE_CMD_REG = SPI_0_OLED_FLASH_I2C_SLAVE_CMD_S_ACK; \
N                            }while(0)
X#define SPI_0_OLED_FLASH_I2C_SLAVE_GENERATE_ACK                             do{                                                 SPI_0_OLED_FLASH_I2C_SLAVE_CMD_REG = SPI_0_OLED_FLASH_I2C_SLAVE_CMD_S_ACK;                             }while(0)
N
N#if (SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if ((2 == 0u) || (2 == 1u))
S    /* Slave NACK generation for EC_AM logic on address phase. Ticket ID #183902 */
S    void SPI_0_OLED_FLASH_I2CSlaveNackGeneration(void);
S    #define SPI_0_OLED_FLASH_I2C_SLAVE_GENERATE_NACK SPI_0_OLED_FLASH_I2CSlaveNackGeneration()
S
N#else
N    #define SPI_0_OLED_FLASH_I2C_SLAVE_GENERATE_NACK \
N                            do{                      \
N                                SPI_0_OLED_FLASH_I2C_SLAVE_CMD_REG = SPI_0_OLED_FLASH_I2C_SLAVE_CMD_S_NACK; \
N                            }while(0)
X    #define SPI_0_OLED_FLASH_I2C_SLAVE_GENERATE_NACK                             do{                                                      SPI_0_OLED_FLASH_I2C_SLAVE_CMD_REG = SPI_0_OLED_FLASH_I2C_SLAVE_CMD_S_NACK;                             }while(0)
N#endif /* (SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N
N#define SPI_0_OLED_FLASH_I2C_SLAVE_CLEAR_NACK \
N                            do{               \
N                                SPI_0_OLED_FLASH_I2C_SLAVE_CMD_REG = 0u; \
N                            }while(0)
X#define SPI_0_OLED_FLASH_I2C_SLAVE_CLEAR_NACK                             do{                                               SPI_0_OLED_FLASH_I2C_SLAVE_CMD_REG = 0u;                             }while(0)
N
N/* Return 8-bit address. The input address should be 7-bits */
N#define SPI_0_OLED_FLASH_GET_I2C_8BIT_ADDRESS(addr) (((uint32) ((uint32) (addr) << \
N                                                                    SPI_0_OLED_FLASH_I2C_SLAVE_ADDR_POS)) & \
N                                                                        SPI_0_OLED_FLASH_I2C_SLAVE_ADDR_MASK)
X#define SPI_0_OLED_FLASH_GET_I2C_8BIT_ADDRESS(addr) (((uint32) ((uint32) (addr) <<                                                                     SPI_0_OLED_FLASH_I2C_SLAVE_ADDR_POS)) &                                                                         SPI_0_OLED_FLASH_I2C_SLAVE_ADDR_MASK)
N
N#define SPI_0_OLED_FLASH_GET_I2C_7BIT_ADDRESS(addr) ((uint32) (addr) >> SPI_0_OLED_FLASH_I2C_SLAVE_ADDR_POS)
N
N/* Adjust SDA filter Trim settings */
N#define SPI_0_OLED_FLASH_DEFAULT_I2C_CFG_SDA_FILT_TRIM  (0x02u)
N#define SPI_0_OLED_FLASH_EC_AM_I2C_CFG_SDA_FILT_TRIM    (0x03u)
N
N#if (SPI_0_OLED_FLASH_CY_SCBIP_V0)
X#if ((2 == 0u))
S    #define SPI_0_OLED_FLASH_SET_I2C_CFG_SDA_FILT_TRIM(sdaTrim) \
S        do{                                                 \
S            SPI_0_OLED_FLASH_I2C_CFG_REG =                  \
S                            ((SPI_0_OLED_FLASH_I2C_CFG_REG & (uint32) ~SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_TRIM_MASK) | \
S                             ((uint32) ((uint32) (sdaTrim) <<SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_TRIM_POS)));           \
S        }while(0)
X    #define SPI_0_OLED_FLASH_SET_I2C_CFG_SDA_FILT_TRIM(sdaTrim)         do{                                                             SPI_0_OLED_FLASH_I2C_CFG_REG =                                              ((SPI_0_OLED_FLASH_I2C_CFG_REG & (uint32) ~SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_TRIM_MASK) |                              ((uint32) ((uint32) (sdaTrim) <<SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_TRIM_POS)));                   }while(0)
N#endif /* (SPI_0_OLED_FLASH_CY_SCBIP_V0) */
N
N/* Enable/Disable analog and digital filter */
N#define SPI_0_OLED_FLASH_DIGITAL_FILTER_DISABLE    (0u)
N#define SPI_0_OLED_FLASH_DIGITAL_FILTER_ENABLE     (1u)
N#define SPI_0_OLED_FLASH_I2C_DATA_RATE_FS_MODE_MAX (400u)
N#if (SPI_0_OLED_FLASH_CY_SCBIP_V0)
X#if ((2 == 0u))
S    /* SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_OUT_ENABLED is disabled by default */
S    #define SPI_0_OLED_FLASH_I2C_CFG_FILT_MASK  (SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_ENABLED | \
S                                                 SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_ENABLED)
X    #define SPI_0_OLED_FLASH_I2C_CFG_FILT_MASK  (SPI_0_OLED_FLASH_I2C_CFG_SDA_FILT_ENABLED |                                                  SPI_0_OLED_FLASH_I2C_CFG_SCL_FILT_ENABLED)
N#else
N    /* SPI_0_OLED_FLASH_I2C_CFG_SDA_OUT_FILT_SEL_MASK is disabled by default */
N    #define SPI_0_OLED_FLASH_I2C_CFG_FILT_MASK  (SPI_0_OLED_FLASH_I2C_CFG_SDA_IN_FILT_SEL | \
N                                                 SPI_0_OLED_FLASH_I2C_CFG_SCL_IN_FILT_SEL)
X    #define SPI_0_OLED_FLASH_I2C_CFG_FILT_MASK  (SPI_0_OLED_FLASH_I2C_CFG_SDA_IN_FILT_SEL |                                                  SPI_0_OLED_FLASH_I2C_CFG_SCL_IN_FILT_SEL)
N#endif /* (SPI_0_OLED_FLASH_CY_SCBIP_V0) */
N
N#define SPI_0_OLED_FLASH_I2C_CFG_ANALOG_FITER_DISABLE \
N        do{                                           \
N            SPI_0_OLED_FLASH_I2C_CFG_REG &= (uint32) ~SPI_0_OLED_FLASH_I2C_CFG_FILT_MASK; \
N        }while(0)
X#define SPI_0_OLED_FLASH_I2C_CFG_ANALOG_FITER_DISABLE         do{                                                       SPI_0_OLED_FLASH_I2C_CFG_REG &= (uint32) ~SPI_0_OLED_FLASH_I2C_CFG_FILT_MASK;         }while(0)
N
N#define SPI_0_OLED_FLASH_I2C_CFG_ANALOG_FITER_ENABLE \
N        do{                                          \
N            SPI_0_OLED_FLASH_I2C_CFG_REG |= (uint32)  SPI_0_OLED_FLASH_I2C_CFG_FILT_MASK; \
N        }while(0)
X#define SPI_0_OLED_FLASH_I2C_CFG_ANALOG_FITER_ENABLE         do{                                                      SPI_0_OLED_FLASH_I2C_CFG_REG |= (uint32)  SPI_0_OLED_FLASH_I2C_CFG_FILT_MASK;         }while(0)
N
N/* Return slave select number from SPI_CTRL register */
N#define SPI_0_OLED_FLASH_GET_SPI_CTRL_SS(activeSelect) (((uint32) ((uint32) (activeSelect) << \
N                                                                    SPI_0_OLED_FLASH_SPI_CTRL_SLAVE_SELECT_POS)) & \
N                                                                        SPI_0_OLED_FLASH_SPI_CTRL_SLAVE_SELECT_MASK)
X#define SPI_0_OLED_FLASH_GET_SPI_CTRL_SS(activeSelect) (((uint32) ((uint32) (activeSelect) <<                                                                     SPI_0_OLED_FLASH_SPI_CTRL_SLAVE_SELECT_POS)) &                                                                         SPI_0_OLED_FLASH_SPI_CTRL_SLAVE_SELECT_MASK)
N
N/* Return true if bit is set in SPI_0_OLED_FLASH_I2C_STATUS_REG */
N#define SPI_0_OLED_FLASH_CHECK_I2C_STATUS(sourceMask)   (0u != (SPI_0_OLED_FLASH_I2C_STATUS_REG & (sourceMask)))
N
N/* Return true if bit is set in SPI_0_OLED_FLASH_SPI_STATUS_REG */
N#define SPI_0_OLED_FLASH_CHECK_SPI_STATUS(sourceMask)   (0u != (SPI_0_OLED_FLASH_SPI_STATUS_REG & (sourceMask)))
N
N/* Return FIFO size depends on SPI_0_OLED_FLASH_CTRL_BYTE_MODE bit */
N#define SPI_0_OLED_FLASH_GET_FIFO_SIZE(condition) ((0u != (condition)) ? \
N                                                    (2u * SPI_0_OLED_FLASH_FIFO_SIZE) : (SPI_0_OLED_FLASH_FIFO_SIZE))
X#define SPI_0_OLED_FLASH_GET_FIFO_SIZE(condition) ((0u != (condition)) ?                                                     (2u * SPI_0_OLED_FLASH_FIFO_SIZE) : (SPI_0_OLED_FLASH_FIFO_SIZE))
N
N
N/***************************************
N*       Get Macros Definitions
N***************************************/
N
N/* SPI_0_OLED_FLASH_CTRL */
N#define SPI_0_OLED_FLASH_GET_CTRL_OVS(oversample)       (((uint32) (oversample) - 1u) & SPI_0_OLED_FLASH_CTRL_OVS_MASK)
N
N#define SPI_0_OLED_FLASH_GET_CTRL_EC_OP_MODE(opMode)        ((0u != (opMode)) ? \
N                                                                (SPI_0_OLED_FLASH_CTRL_EC_OP_MODE)  : (0u))
X#define SPI_0_OLED_FLASH_GET_CTRL_EC_OP_MODE(opMode)        ((0u != (opMode)) ?                                                                 (SPI_0_OLED_FLASH_CTRL_EC_OP_MODE)  : (0u))
N
N#define SPI_0_OLED_FLASH_GET_CTRL_EC_AM_MODE(amMode)        ((0u != (amMode)) ? \
N                                                                (SPI_0_OLED_FLASH_CTRL_EC_AM_MODE)  : (0u))
X#define SPI_0_OLED_FLASH_GET_CTRL_EC_AM_MODE(amMode)        ((0u != (amMode)) ?                                                                 (SPI_0_OLED_FLASH_CTRL_EC_AM_MODE)  : (0u))
N
N#define SPI_0_OLED_FLASH_GET_CTRL_BLOCK(block)              ((0u != (block))  ? \
N                                                                (SPI_0_OLED_FLASH_CTRL_BLOCK)       : (0u))
X#define SPI_0_OLED_FLASH_GET_CTRL_BLOCK(block)              ((0u != (block))  ?                                                                 (SPI_0_OLED_FLASH_CTRL_BLOCK)       : (0u))
N
N#define SPI_0_OLED_FLASH_GET_CTRL_ADDR_ACCEPT(acceptAddr)   ((0u != (acceptAddr)) ? \
N                                                                (SPI_0_OLED_FLASH_CTRL_ADDR_ACCEPT) : (0u))
X#define SPI_0_OLED_FLASH_GET_CTRL_ADDR_ACCEPT(acceptAddr)   ((0u != (acceptAddr)) ?                                                                 (SPI_0_OLED_FLASH_CTRL_ADDR_ACCEPT) : (0u))
N
N#if (SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if ((2 == 0u) || (2 == 1u))
S    #define SPI_0_OLED_FLASH_GET_CTRL_BYTE_MODE(mode)   (0u)
N#else
N    #define SPI_0_OLED_FLASH_GET_CTRL_BYTE_MODE(mode)   ((0u != (mode)) ? \
N                                                            (SPI_0_OLED_FLASH_CTRL_BYTE_MODE) : (0u))
X    #define SPI_0_OLED_FLASH_GET_CTRL_BYTE_MODE(mode)   ((0u != (mode)) ?                                                             (SPI_0_OLED_FLASH_CTRL_BYTE_MODE) : (0u))
N#endif /* (SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N
N/* SPI_0_OLED_FLASH_I2C_CTRL */
N#define SPI_0_OLED_FLASH_GET_I2C_CTRL_HIGH_PHASE_OVS(oversampleHigh) (((uint32) (oversampleHigh) - 1u) & \
N                                                                        SPI_0_OLED_FLASH_I2C_CTRL_HIGH_PHASE_OVS_MASK)
X#define SPI_0_OLED_FLASH_GET_I2C_CTRL_HIGH_PHASE_OVS(oversampleHigh) (((uint32) (oversampleHigh) - 1u) &                                                                         SPI_0_OLED_FLASH_I2C_CTRL_HIGH_PHASE_OVS_MASK)
N
N#define SPI_0_OLED_FLASH_GET_I2C_CTRL_LOW_PHASE_OVS(oversampleLow)  ((((uint32) (oversampleLow) - 1u) << \
N                                                                    SPI_0_OLED_FLASH_I2C_CTRL_LOW_PHASE_OVS_POS) &  \
N                                                                    SPI_0_OLED_FLASH_I2C_CTRL_LOW_PHASE_OVS_MASK)
X#define SPI_0_OLED_FLASH_GET_I2C_CTRL_LOW_PHASE_OVS(oversampleLow)  ((((uint32) (oversampleLow) - 1u) <<                                                                     SPI_0_OLED_FLASH_I2C_CTRL_LOW_PHASE_OVS_POS) &                                                                      SPI_0_OLED_FLASH_I2C_CTRL_LOW_PHASE_OVS_MASK)
N
N#define SPI_0_OLED_FLASH_GET_I2C_CTRL_S_NOT_READY_ADDR_NACK(wakeNack) ((0u != (wakeNack)) ? \
N                                                            (SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_ADDR_NACK) : (0u))
X#define SPI_0_OLED_FLASH_GET_I2C_CTRL_S_NOT_READY_ADDR_NACK(wakeNack) ((0u != (wakeNack)) ?                                                             (SPI_0_OLED_FLASH_I2C_CTRL_S_NOT_READY_ADDR_NACK) : (0u))
N
N#define SPI_0_OLED_FLASH_GET_I2C_CTRL_S_GENERAL_IGNORE(genCall) ((0u != (genCall)) ? \
N                                                                    (SPI_0_OLED_FLASH_I2C_CTRL_S_GENERAL_IGNORE) : (0u))
X#define SPI_0_OLED_FLASH_GET_I2C_CTRL_S_GENERAL_IGNORE(genCall) ((0u != (genCall)) ?                                                                     (SPI_0_OLED_FLASH_I2C_CTRL_S_GENERAL_IGNORE) : (0u))
N
N#define SPI_0_OLED_FLASH_GET_I2C_CTRL_SL_MSTR_MODE(mode)    ((uint32)(mode) << SPI_0_OLED_FLASH_I2C_CTRL_SLAVE_MODE_POS)
N
N/* SPI_0_OLED_FLASH_SPI_CTRL */
N#define SPI_0_OLED_FLASH_GET_SPI_CTRL_CONTINUOUS(separate)  ((0u != (separate)) ? \
N                                                                (SPI_0_OLED_FLASH_SPI_CTRL_CONTINUOUS) : (0u))
X#define SPI_0_OLED_FLASH_GET_SPI_CTRL_CONTINUOUS(separate)  ((0u != (separate)) ?                                                                 (SPI_0_OLED_FLASH_SPI_CTRL_CONTINUOUS) : (0u))
N
N#define SPI_0_OLED_FLASH_GET_SPI_CTRL_SELECT_PRECEDE(mode)  ((0u != (mode)) ? \
N                                                                      (SPI_0_OLED_FLASH_SPI_CTRL_SELECT_PRECEDE) : (0u))
X#define SPI_0_OLED_FLASH_GET_SPI_CTRL_SELECT_PRECEDE(mode)  ((0u != (mode)) ?                                                                       (SPI_0_OLED_FLASH_SPI_CTRL_SELECT_PRECEDE) : (0u))
N
N#define SPI_0_OLED_FLASH_GET_SPI_CTRL_SCLK_MODE(mode)       (((uint32) (mode) << \
N                                                                        SPI_0_OLED_FLASH_SPI_CTRL_CPHA_POS) & \
N                                                                        SPI_0_OLED_FLASH_SPI_CTRL_SCLK_MODE_MASK)
X#define SPI_0_OLED_FLASH_GET_SPI_CTRL_SCLK_MODE(mode)       (((uint32) (mode) <<                                                                         SPI_0_OLED_FLASH_SPI_CTRL_CPHA_POS) &                                                                         SPI_0_OLED_FLASH_SPI_CTRL_SCLK_MODE_MASK)
N
N#define SPI_0_OLED_FLASH_GET_SPI_CTRL_LATE_MISO_SAMPLE(lateMiso) ((0u != (lateMiso)) ? \
N                                                                    (SPI_0_OLED_FLASH_SPI_CTRL_LATE_MISO_SAMPLE) : (0u))
X#define SPI_0_OLED_FLASH_GET_SPI_CTRL_LATE_MISO_SAMPLE(lateMiso) ((0u != (lateMiso)) ?                                                                     (SPI_0_OLED_FLASH_SPI_CTRL_LATE_MISO_SAMPLE) : (0u))
N
N#if (SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if ((2 == 0u) || (2 == 1u))
S    #define SPI_0_OLED_FLASH_GET_SPI_CTRL_SCLK_CONTINUOUS(sclkType) (0u)
S    #define SPI_0_OLED_FLASH_GET_SPI_CTRL_SSEL_POLARITY(polarity)   (0u)
N#else
N    #define SPI_0_OLED_FLASH_GET_SPI_CTRL_SCLK_CONTINUOUS(sclkType) ((0u != (sclkType)) ? \
N                                                                    (SPI_0_OLED_FLASH_SPI_CTRL_SCLK_CONTINUOUS) : (0u))
X    #define SPI_0_OLED_FLASH_GET_SPI_CTRL_SCLK_CONTINUOUS(sclkType) ((0u != (sclkType)) ?                                                                     (SPI_0_OLED_FLASH_SPI_CTRL_SCLK_CONTINUOUS) : (0u))
N
N    #define SPI_0_OLED_FLASH_GET_SPI_CTRL_SSEL_POLARITY(polarity)   (((uint32) (polarity) << \
N                                                                     SPI_0_OLED_FLASH_SPI_CTRL_SSEL0_POLARITY_POS) & \
N                                                                     SPI_0_OLED_FLASH_SPI_CTRL_SSEL_POLARITY_MASK)
X    #define SPI_0_OLED_FLASH_GET_SPI_CTRL_SSEL_POLARITY(polarity)   (((uint32) (polarity) <<                                                                      SPI_0_OLED_FLASH_SPI_CTRL_SSEL0_POLARITY_POS) &                                                                      SPI_0_OLED_FLASH_SPI_CTRL_SSEL_POLARITY_MASK)
N#endif /* ((SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N
N#define SPI_0_OLED_FLASH_GET_SPI_CTRL_SUB_MODE(mode)        (((uint32) (mode) << SPI_0_OLED_FLASH_SPI_CTRL_MODE_POS) & \
N                                                                                 SPI_0_OLED_FLASH_SPI_CTRL_MODE_MASK)
X#define SPI_0_OLED_FLASH_GET_SPI_CTRL_SUB_MODE(mode)        (((uint32) (mode) << SPI_0_OLED_FLASH_SPI_CTRL_MODE_POS) &                                                                                  SPI_0_OLED_FLASH_SPI_CTRL_MODE_MASK)
N
N#define SPI_0_OLED_FLASH_GET_SPI_CTRL_SLAVE_SELECT(select)  (((uint32) (select) << \
N                                                                      SPI_0_OLED_FLASH_SPI_CTRL_SLAVE_SELECT_POS) & \
N                                                                      SPI_0_OLED_FLASH_SPI_CTRL_SLAVE_SELECT_MASK)
X#define SPI_0_OLED_FLASH_GET_SPI_CTRL_SLAVE_SELECT(select)  (((uint32) (select) <<                                                                       SPI_0_OLED_FLASH_SPI_CTRL_SLAVE_SELECT_POS) &                                                                       SPI_0_OLED_FLASH_SPI_CTRL_SLAVE_SELECT_MASK)
N
N#define SPI_0_OLED_FLASH_GET_SPI_CTRL_MASTER_MODE(mode)     ((0u != (mode)) ? \
N                                                                (SPI_0_OLED_FLASH_SPI_CTRL_MASTER) : (0u))
X#define SPI_0_OLED_FLASH_GET_SPI_CTRL_MASTER_MODE(mode)     ((0u != (mode)) ?                                                                 (SPI_0_OLED_FLASH_SPI_CTRL_MASTER) : (0u))
N
N/* SPI_0_OLED_FLASH_UART_CTRL */
N#define SPI_0_OLED_FLASH_GET_UART_CTRL_MODE(mode)           (((uint32) (mode) << \
N                                                                            SPI_0_OLED_FLASH_UART_CTRL_MODE_POS) & \
N                                                                            SPI_0_OLED_FLASH_UART_CTRL_MODE_MASK)
X#define SPI_0_OLED_FLASH_GET_UART_CTRL_MODE(mode)           (((uint32) (mode) <<                                                                             SPI_0_OLED_FLASH_UART_CTRL_MODE_POS) &                                                                             SPI_0_OLED_FLASH_UART_CTRL_MODE_MASK)
N
N/* SPI_0_OLED_FLASH_UART_RX_CTRL */
N#define SPI_0_OLED_FLASH_GET_UART_RX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) & \
N                                                                        SPI_0_OLED_FLASH_UART_RX_CTRL_STOP_BITS_MASK)
X#define SPI_0_OLED_FLASH_GET_UART_RX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) &                                                                         SPI_0_OLED_FLASH_UART_RX_CTRL_STOP_BITS_MASK)
N
N#define SPI_0_OLED_FLASH_GET_UART_RX_CTRL_PARITY(parity)    ((0u != (parity)) ? \
N                                                                    (SPI_0_OLED_FLASH_UART_RX_CTRL_PARITY) : (0u))
X#define SPI_0_OLED_FLASH_GET_UART_RX_CTRL_PARITY(parity)    ((0u != (parity)) ?                                                                     (SPI_0_OLED_FLASH_UART_RX_CTRL_PARITY) : (0u))
N
N#define SPI_0_OLED_FLASH_GET_UART_RX_CTRL_POLARITY(polarity)    ((0u != (polarity)) ? \
N                                                                    (SPI_0_OLED_FLASH_UART_RX_CTRL_POLARITY) : (0u))
X#define SPI_0_OLED_FLASH_GET_UART_RX_CTRL_POLARITY(polarity)    ((0u != (polarity)) ?                                                                     (SPI_0_OLED_FLASH_UART_RX_CTRL_POLARITY) : (0u))
N
N#define SPI_0_OLED_FLASH_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(dropErr) ((0u != (dropErr)) ? \
N                                                        (SPI_0_OLED_FLASH_UART_RX_CTRL_DROP_ON_PARITY_ERR) : (0u))
X#define SPI_0_OLED_FLASH_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(dropErr) ((0u != (dropErr)) ?                                                         (SPI_0_OLED_FLASH_UART_RX_CTRL_DROP_ON_PARITY_ERR) : (0u))
N
N#define SPI_0_OLED_FLASH_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(dropErr) ((0u != (dropErr)) ? \
N                                                        (SPI_0_OLED_FLASH_UART_RX_CTRL_DROP_ON_FRAME_ERR) : (0u))
X#define SPI_0_OLED_FLASH_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(dropErr) ((0u != (dropErr)) ?                                                         (SPI_0_OLED_FLASH_UART_RX_CTRL_DROP_ON_FRAME_ERR) : (0u))
N
N#define SPI_0_OLED_FLASH_GET_UART_RX_CTRL_MP_MODE(mpMode)   ((0u != (mpMode)) ? \
N                                                        (SPI_0_OLED_FLASH_UART_RX_CTRL_MP_MODE) : (0u))
X#define SPI_0_OLED_FLASH_GET_UART_RX_CTRL_MP_MODE(mpMode)   ((0u != (mpMode)) ?                                                         (SPI_0_OLED_FLASH_UART_RX_CTRL_MP_MODE) : (0u))
N
N#define SPI_0_OLED_FLASH_GET_UART_RX_CTRL_BREAK_WIDTH(width)    (((uint32) ((uint32) (width) - 1u) << \
N                                                                    SPI_0_OLED_FLASH_UART_RX_CTRL_BREAK_WIDTH_POS) & \
N                                                                    SPI_0_OLED_FLASH_UART_RX_CTRL_BREAK_WIDTH_MASK)
X#define SPI_0_OLED_FLASH_GET_UART_RX_CTRL_BREAK_WIDTH(width)    (((uint32) ((uint32) (width) - 1u) <<                                                                     SPI_0_OLED_FLASH_UART_RX_CTRL_BREAK_WIDTH_POS) &                                                                     SPI_0_OLED_FLASH_UART_RX_CTRL_BREAK_WIDTH_MASK)
N
N/* SPI_0_OLED_FLASH_UART_TX_CTRL */
N#define SPI_0_OLED_FLASH_GET_UART_TX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) & \
N                                                                SPI_0_OLED_FLASH_UART_RX_CTRL_STOP_BITS_MASK)
X#define SPI_0_OLED_FLASH_GET_UART_TX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) &                                                                 SPI_0_OLED_FLASH_UART_RX_CTRL_STOP_BITS_MASK)
N
N#define SPI_0_OLED_FLASH_GET_UART_TX_CTRL_PARITY(parity)    ((0u != (parity)) ? \
N                                                               (SPI_0_OLED_FLASH_UART_TX_CTRL_PARITY) : (0u))
X#define SPI_0_OLED_FLASH_GET_UART_TX_CTRL_PARITY(parity)    ((0u != (parity)) ?                                                                (SPI_0_OLED_FLASH_UART_TX_CTRL_PARITY) : (0u))
N
N#define SPI_0_OLED_FLASH_GET_UART_TX_CTRL_RETRY_NACK(nack)  ((0u != (nack)) ? \
N                                                               (SPI_0_OLED_FLASH_UART_TX_CTRL_RETRY_ON_NACK) : (0u))
X#define SPI_0_OLED_FLASH_GET_UART_TX_CTRL_RETRY_NACK(nack)  ((0u != (nack)) ?                                                                (SPI_0_OLED_FLASH_UART_TX_CTRL_RETRY_ON_NACK) : (0u))
N
N/* SPI_0_OLED_FLASH_UART_FLOW_CTRL */
N#if !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define SPI_0_OLED_FLASH_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(level)   ( (uint32) (level) & \
N                                                                 SPI_0_OLED_FLASH_UART_FLOW_CTRL_TRIGGER_LEVEL_MASK)
X    #define SPI_0_OLED_FLASH_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(level)   ( (uint32) (level) &                                                                  SPI_0_OLED_FLASH_UART_FLOW_CTRL_TRIGGER_LEVEL_MASK)
N
N    #define SPI_0_OLED_FLASH_GET_UART_FLOW_CTRL_RTS_POLARITY(polarity) ((0u != (polarity)) ? \
N                                                                (SPI_0_OLED_FLASH_UART_FLOW_CTRL_RTS_POLARITY) : (0u))
X    #define SPI_0_OLED_FLASH_GET_UART_FLOW_CTRL_RTS_POLARITY(polarity) ((0u != (polarity)) ?                                                                 (SPI_0_OLED_FLASH_UART_FLOW_CTRL_RTS_POLARITY) : (0u))
N
N    #define SPI_0_OLED_FLASH_GET_UART_FLOW_CTRL_CTS_POLARITY(polarity) ((0u != (polarity)) ? \
N                                                                (SPI_0_OLED_FLASH_UART_FLOW_CTRL_CTS_POLARITY) : (0u))
X    #define SPI_0_OLED_FLASH_GET_UART_FLOW_CTRL_CTS_POLARITY(polarity) ((0u != (polarity)) ?                                                                 (SPI_0_OLED_FLASH_UART_FLOW_CTRL_CTS_POLARITY) : (0u))
N
N    #define SPI_0_OLED_FLASH_GET_UART_FLOW_CTRL_CTS_ENABLE(ctsEn)      ((0u != (ctsEn)) ? \
N                                                                (SPI_0_OLED_FLASH_UART_FLOW_CTRL_CTS_ENABLE) : (0u))
X    #define SPI_0_OLED_FLASH_GET_UART_FLOW_CTRL_CTS_ENABLE(ctsEn)      ((0u != (ctsEn)) ?                                                                 (SPI_0_OLED_FLASH_UART_FLOW_CTRL_CTS_ENABLE) : (0u))
N#endif /* !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N
N/* SPI_0_OLED_FLASH_RX_CTRL */
N#define SPI_0_OLED_FLASH_GET_RX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) & \
N                                                                SPI_0_OLED_FLASH_RX_CTRL_DATA_WIDTH_MASK)
X#define SPI_0_OLED_FLASH_GET_RX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) &                                                                 SPI_0_OLED_FLASH_RX_CTRL_DATA_WIDTH_MASK)
N
N#define SPI_0_OLED_FLASH_GET_RX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ? \
N                                                                (SPI_0_OLED_FLASH_RX_CTRL_MSB_FIRST) : (0u))
X#define SPI_0_OLED_FLASH_GET_RX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ?                                                                 (SPI_0_OLED_FLASH_RX_CTRL_MSB_FIRST) : (0u))
N
N#define SPI_0_OLED_FLASH_GET_RX_CTRL_MEDIAN(filterEn)       ((0u != (filterEn)) ? \
N                                                                (SPI_0_OLED_FLASH_RX_CTRL_MEDIAN) : (0u))
X#define SPI_0_OLED_FLASH_GET_RX_CTRL_MEDIAN(filterEn)       ((0u != (filterEn)) ?                                                                 (SPI_0_OLED_FLASH_RX_CTRL_MEDIAN) : (0u))
N
N/* SPI_0_OLED_FLASH_RX_MATCH */
N#define SPI_0_OLED_FLASH_GET_RX_MATCH_ADDR(addr)    ((uint32) (addr) & SPI_0_OLED_FLASH_RX_MATCH_ADDR_MASK)
N#define SPI_0_OLED_FLASH_GET_RX_MATCH_MASK(mask)    (((uint32) (mask) << \
N                                                            SPI_0_OLED_FLASH_RX_MATCH_MASK_POS) & \
N                                                            SPI_0_OLED_FLASH_RX_MATCH_MASK_MASK)
X#define SPI_0_OLED_FLASH_GET_RX_MATCH_MASK(mask)    (((uint32) (mask) <<                                                             SPI_0_OLED_FLASH_RX_MATCH_MASK_POS) &                                                             SPI_0_OLED_FLASH_RX_MATCH_MASK_MASK)
N
N/* SPI_0_OLED_FLASH_RX_FIFO_CTRL */
N#define SPI_0_OLED_FLASH_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) & \
N                                                                    SPI_0_OLED_FLASH_RX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
X#define SPI_0_OLED_FLASH_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) &                                                                     SPI_0_OLED_FLASH_RX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
N
N/* SPI_0_OLED_FLASH_TX_CTRL */
N#define SPI_0_OLED_FLASH_GET_TX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) & \
N                                                                SPI_0_OLED_FLASH_TX_CTRL_DATA_WIDTH_MASK)
X#define SPI_0_OLED_FLASH_GET_TX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) &                                                                 SPI_0_OLED_FLASH_TX_CTRL_DATA_WIDTH_MASK)
N
N#define SPI_0_OLED_FLASH_GET_TX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ? \
N                                                                (SPI_0_OLED_FLASH_TX_CTRL_MSB_FIRST) : (0u))
X#define SPI_0_OLED_FLASH_GET_TX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ?                                                                 (SPI_0_OLED_FLASH_TX_CTRL_MSB_FIRST) : (0u))
N
N/* SPI_0_OLED_FLASH_TX_FIFO_CTRL */
N#define SPI_0_OLED_FLASH_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) & \
N                                                                    SPI_0_OLED_FLASH_TX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
X#define SPI_0_OLED_FLASH_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) &                                                                     SPI_0_OLED_FLASH_TX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
N
N/* SPI_0_OLED_FLASH_INTR_SLAVE_I2C_GENERAL */
N#define SPI_0_OLED_FLASH_GET_INTR_SLAVE_I2C_GENERAL(genCall)  ((0u != (genCall)) ? \
N                                                                (SPI_0_OLED_FLASH_INTR_SLAVE_I2C_GENERAL) : (0u))
X#define SPI_0_OLED_FLASH_GET_INTR_SLAVE_I2C_GENERAL(genCall)  ((0u != (genCall)) ?                                                                 (SPI_0_OLED_FLASH_INTR_SLAVE_I2C_GENERAL) : (0u))
N
N/* Return true if master mode is enabled SPI_0_OLED_FLASH_SPI_CTRL_REG */
N#define SPI_0_OLED_FLASH_CHECK_SPI_MASTER   (0u != (SPI_0_OLED_FLASH_SPI_CTRL_REG & SPI_0_OLED_FLASH_SPI_CTRL_MASTER))
N
N/* Return inactive state of SPI SCLK line depends on CPOL */
N#define SPI_0_OLED_FLASH_GET_SPI_SCLK_INACTIVE \
N            ((0u == (SPI_0_OLED_FLASH_SPI_CTRL_REG & SPI_0_OLED_FLASH_SPI_CTRL_CPOL)) ? (0u) : (1u))
X#define SPI_0_OLED_FLASH_GET_SPI_SCLK_INACTIVE             ((0u == (SPI_0_OLED_FLASH_SPI_CTRL_REG & SPI_0_OLED_FLASH_SPI_CTRL_CPOL)) ? (0u) : (1u))
N
N/* Get output pin inactive state */
N#if (SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if ((2 == 0u) || (2 == 1u))
S#define SPI_0_OLED_FLASH_GET_SPI_SS0_INACTIVE       (1u)
S#define SPI_0_OLED_FLASH_GET_SPI_SS1_INACTIVE       (1u)
S#define SPI_0_OLED_FLASH_GET_SPI_SS2_INACTIVE       (1u)
S#define SPI_0_OLED_FLASH_GET_SPI_SS3_INACTIVE       (1u)
S#define SPI_0_OLED_FLASH_GET_UART_RTS_INACTIVE      (1u)
S
N#else
N#define SPI_0_OLED_FLASH_GET_SPI_SS0_INACTIVE  \
N        ((0u != (SPI_0_OLED_FLASH_SPI_CTRL_REG & SPI_0_OLED_FLASH_SPI_CTRL_SSEL0_POLARITY)) ? (0u) : (1u))
X#define SPI_0_OLED_FLASH_GET_SPI_SS0_INACTIVE          ((0u != (SPI_0_OLED_FLASH_SPI_CTRL_REG & SPI_0_OLED_FLASH_SPI_CTRL_SSEL0_POLARITY)) ? (0u) : (1u))
N
N#define SPI_0_OLED_FLASH_GET_SPI_SS1_INACTIVE  \
N        ((0u != (SPI_0_OLED_FLASH_SPI_CTRL_REG & SPI_0_OLED_FLASH_SPI_CTRL_SSEL1_POLARITY)) ? (0u) : (1u))
X#define SPI_0_OLED_FLASH_GET_SPI_SS1_INACTIVE          ((0u != (SPI_0_OLED_FLASH_SPI_CTRL_REG & SPI_0_OLED_FLASH_SPI_CTRL_SSEL1_POLARITY)) ? (0u) : (1u))
N
N#define SPI_0_OLED_FLASH_GET_SPI_SS2_INACTIVE  \
N        ((0u != (SPI_0_OLED_FLASH_SPI_CTRL_REG & SPI_0_OLED_FLASH_SPI_CTRL_SSEL2_POLARITY)) ? (0u) : (1u))
X#define SPI_0_OLED_FLASH_GET_SPI_SS2_INACTIVE          ((0u != (SPI_0_OLED_FLASH_SPI_CTRL_REG & SPI_0_OLED_FLASH_SPI_CTRL_SSEL2_POLARITY)) ? (0u) : (1u))
N
N#define SPI_0_OLED_FLASH_GET_SPI_SS3_INACTIVE  \
N        ((0u != (SPI_0_OLED_FLASH_SPI_CTRL_REG & SPI_0_OLED_FLASH_SPI_CTRL_SSEL3_POLARITY)) ? (0u) : (1u))
X#define SPI_0_OLED_FLASH_GET_SPI_SS3_INACTIVE          ((0u != (SPI_0_OLED_FLASH_SPI_CTRL_REG & SPI_0_OLED_FLASH_SPI_CTRL_SSEL3_POLARITY)) ? (0u) : (1u))
N
N#define SPI_0_OLED_FLASH_GET_UART_RTS_INACTIVE \
N        ((0u == (SPI_0_OLED_FLASH_UART_FLOW_CTRL_REG & SPI_0_OLED_FLASH_UART_FLOW_CTRL_RTS_POLARITY)) ? (0u) : (1u))
X#define SPI_0_OLED_FLASH_GET_UART_RTS_INACTIVE         ((0u == (SPI_0_OLED_FLASH_UART_FLOW_CTRL_REG & SPI_0_OLED_FLASH_UART_FLOW_CTRL_RTS_POLARITY)) ? (0u) : (1u))
N
N#endif /*(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N
N/* Clear register constants for configuration and interrupt mask */
N#define SPI_0_OLED_FLASH_CLEAR_REG          ((uint32) (0u))
N#define SPI_0_OLED_FLASH_NO_INTR_SOURCES    ((uint32) (0u))
N#define SPI_0_OLED_FLASH_DUMMY_PARAM        ((uint32) (0u))
N#define SPI_0_OLED_FLASH_SUBMODE_SPI_SLAVE  ((uint32) (0u))
N
N/* Return in case of I2C read error */
N#define SPI_0_OLED_FLASH_I2C_INVALID_BYTE   ((uint32) 0xFFFFFFFFu)
N#define SPI_0_OLED_FLASH_CHECK_VALID_BYTE   ((uint32) 0x80000000u)
N
N
N/***************************************
N* The following code is DEPRECATED and
N* must not be used.
N***************************************/
N
N#define SPI_0_OLED_FLASH_CHECK_INTR_EC_I2C(sourceMask)  SPI_0_OLED_FLASH_CHECK_INTR_I2C_EC(sourceMask)
N#if (!SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_0_OLED_FLASH_CHECK_INTR_EC_SPI(sourceMask)  SPI_0_OLED_FLASH_CHECK_INTR_SPI_EC(sourceMask)
N#endif /* (!SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N
N#define SPI_0_OLED_FLASH_CY_SCBIP_V1_I2C_ONLY   (SPI_0_OLED_FLASH_CY_SCBIP_V1)
N#define SPI_0_OLED_FLASH_EZBUFFER_SIZE          (SPI_0_OLED_FLASH_EZ_DATA_NR)
N
N#define SPI_0_OLED_FLASH_EZBUF_DATA00_REG   SPI_0_OLED_FLASH_EZBUF_DATA0_REG
N#define SPI_0_OLED_FLASH_EZBUF_DATA00_PTR   SPI_0_OLED_FLASH_EZBUF_DATA0_PTR
N
N#endif /* (CY_SCB_SPI_0_OLED_FLASH_H) */
N
N
N/* [] END OF FILE */
L 40 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_SPI_UART.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_SPI_UART.h" 1
N/***************************************************************************//**
N* \file SPI_0_OLED_FLASH_SPI_UART.h
N* \version 4.0
N*
N* \brief
N*  This file provides constants and parameter values for the SCB Component in
N*  SPI and UART modes.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_SPI_UART_SPI_0_OLED_FLASH_H)
X#if !0L
N#define CY_SCB_SPI_UART_SPI_0_OLED_FLASH_H
N
N#include "SPI_0_OLED_FLASH.h"
N
N
N/***************************************
N*   SPI Initial Parameter Constants
N****************************************/
N
N#define SPI_0_OLED_FLASH_SPI_MODE                   (1u)
N#define SPI_0_OLED_FLASH_SPI_SUB_MODE               (0u)
N#define SPI_0_OLED_FLASH_SPI_CLOCK_MODE             (0u)
N#define SPI_0_OLED_FLASH_SPI_OVS_FACTOR             (6u)
N#define SPI_0_OLED_FLASH_SPI_MEDIAN_FILTER_ENABLE   (0u)
N#define SPI_0_OLED_FLASH_SPI_LATE_MISO_SAMPLE_ENABLE (0u)
N#define SPI_0_OLED_FLASH_SPI_RX_DATA_BITS_NUM       (8u)
N#define SPI_0_OLED_FLASH_SPI_TX_DATA_BITS_NUM       (8u)
N#define SPI_0_OLED_FLASH_SPI_WAKE_ENABLE            (0u)
N#define SPI_0_OLED_FLASH_SPI_BITS_ORDER             (1u)
N#define SPI_0_OLED_FLASH_SPI_TRANSFER_SEPARATION    (1u)
N#define SPI_0_OLED_FLASH_SPI_NUMBER_OF_SS_LINES     (2u)
N#define SPI_0_OLED_FLASH_SPI_RX_BUFFER_SIZE         (16u)
N#define SPI_0_OLED_FLASH_SPI_TX_BUFFER_SIZE         (16u)
N
N#define SPI_0_OLED_FLASH_SPI_INTERRUPT_MODE         (0u)
N
N#define SPI_0_OLED_FLASH_SPI_INTR_RX_MASK           (0x0u)
N#define SPI_0_OLED_FLASH_SPI_INTR_TX_MASK           (0x0u)
N
N#define SPI_0_OLED_FLASH_SPI_RX_TRIGGER_LEVEL       (15u)
N#define SPI_0_OLED_FLASH_SPI_TX_TRIGGER_LEVEL       (15u)
N
N#define SPI_0_OLED_FLASH_SPI_BYTE_MODE_ENABLE       (1u)
N#define SPI_0_OLED_FLASH_SPI_FREE_RUN_SCLK_ENABLE   (0u)
N#define SPI_0_OLED_FLASH_SPI_SS0_POLARITY           (0u)
N#define SPI_0_OLED_FLASH_SPI_SS1_POLARITY           (0u)
N#define SPI_0_OLED_FLASH_SPI_SS2_POLARITY           (0u)
N#define SPI_0_OLED_FLASH_SPI_SS3_POLARITY           (0u)
N
N
N/***************************************
N*   UART Initial Parameter Constants
N****************************************/
N
N#define SPI_0_OLED_FLASH_UART_SUB_MODE              (0u)
N#define SPI_0_OLED_FLASH_UART_DIRECTION             (3u)
N#define SPI_0_OLED_FLASH_UART_DATA_BITS_NUM         (8u)
N#define SPI_0_OLED_FLASH_UART_PARITY_TYPE           (2u)
N#define SPI_0_OLED_FLASH_UART_STOP_BITS_NUM         (2u)
N#define SPI_0_OLED_FLASH_UART_OVS_FACTOR            (12u)
N#define SPI_0_OLED_FLASH_UART_IRDA_LOW_POWER        (0u)
N#define SPI_0_OLED_FLASH_UART_MEDIAN_FILTER_ENABLE  (0u)
N#define SPI_0_OLED_FLASH_UART_RETRY_ON_NACK         (0u)
N#define SPI_0_OLED_FLASH_UART_IRDA_POLARITY         (0u)
N#define SPI_0_OLED_FLASH_UART_DROP_ON_FRAME_ERR     (0u)
N#define SPI_0_OLED_FLASH_UART_DROP_ON_PARITY_ERR    (0u)
N#define SPI_0_OLED_FLASH_UART_WAKE_ENABLE           (0u)
N#define SPI_0_OLED_FLASH_UART_RX_BUFFER_SIZE        (8u)
N#define SPI_0_OLED_FLASH_UART_TX_BUFFER_SIZE        (8u)
N#define SPI_0_OLED_FLASH_UART_MP_MODE_ENABLE        (0u)
N#define SPI_0_OLED_FLASH_UART_MP_ACCEPT_ADDRESS     (0u)
N#define SPI_0_OLED_FLASH_UART_MP_RX_ADDRESS         (0x2u)
N#define SPI_0_OLED_FLASH_UART_MP_RX_ADDRESS_MASK    (0xFFu)
N
N#define SPI_0_OLED_FLASH_UART_INTERRUPT_MODE        (0u)
N
N#define SPI_0_OLED_FLASH_UART_INTR_RX_MASK          (0x0u)
N#define SPI_0_OLED_FLASH_UART_INTR_TX_MASK          (0x0u)
N
N#define SPI_0_OLED_FLASH_UART_RX_TRIGGER_LEVEL      (7u)
N#define SPI_0_OLED_FLASH_UART_TX_TRIGGER_LEVEL      (0u)
N
N#define SPI_0_OLED_FLASH_UART_BYTE_MODE_ENABLE      (0u)
N#define SPI_0_OLED_FLASH_UART_CTS_ENABLE            (0u)
N#define SPI_0_OLED_FLASH_UART_CTS_POLARITY          (0u)
N#define SPI_0_OLED_FLASH_UART_RTS_ENABLE            (0u)
N#define SPI_0_OLED_FLASH_UART_RTS_POLARITY          (0u)
N#define SPI_0_OLED_FLASH_UART_RTS_FIFO_LEVEL        (4u)
N
N#define SPI_0_OLED_FLASH_UART_RX_BREAK_WIDTH        (11u)
N
N/* SPI mode enum */
N#define SPI_0_OLED_FLASH_SPI_SLAVE  (0u)
N#define SPI_0_OLED_FLASH_SPI_MASTER (1u)
N
N/* UART direction enum */
N#define SPI_0_OLED_FLASH_UART_RX    (1u)
N#define SPI_0_OLED_FLASH_UART_TX    (2u)
N#define SPI_0_OLED_FLASH_UART_TX_RX (3u)
N
N
N/***************************************
N*   Conditional Compilation Parameters
N****************************************/
N
N#if(SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (2u)))
S
S    /* Mode */
S    #define SPI_0_OLED_FLASH_SPI_SLAVE_CONST        (1u)
S    #define SPI_0_OLED_FLASH_SPI_MASTER_CONST       (1u)
S
S    /* Direction */
S    #define SPI_0_OLED_FLASH_RX_DIRECTION           (1u)
S    #define SPI_0_OLED_FLASH_TX_DIRECTION           (1u)
S    #define SPI_0_OLED_FLASH_UART_RX_DIRECTION      (1u)
S    #define SPI_0_OLED_FLASH_UART_TX_DIRECTION      (1u)
S
S    /* Only external RX and TX buffer for Uncofigured mode */
S    #define SPI_0_OLED_FLASH_INTERNAL_RX_SW_BUFFER   (0u)
S    #define SPI_0_OLED_FLASH_INTERNAL_TX_SW_BUFFER   (0u)
S
S    /* Get RX and TX buffer size */
S    #define SPI_0_OLED_FLASH_INTERNAL_RX_BUFFER_SIZE    (SPI_0_OLED_FLASH_rxBufferSize + 1u)
S    #define SPI_0_OLED_FLASH_RX_BUFFER_SIZE             (SPI_0_OLED_FLASH_rxBufferSize)
S    #define SPI_0_OLED_FLASH_TX_BUFFER_SIZE             (SPI_0_OLED_FLASH_txBufferSize)
S
S    /* Return true if buffer is provided */
S    #define SPI_0_OLED_FLASH_CHECK_RX_SW_BUFFER (NULL != SPI_0_OLED_FLASH_rxBuffer)
S    #define SPI_0_OLED_FLASH_CHECK_TX_SW_BUFFER (NULL != SPI_0_OLED_FLASH_txBuffer)
S
S    /* Always provide global variables to support RX and TX buffers */
S    #define SPI_0_OLED_FLASH_INTERNAL_RX_SW_BUFFER_CONST    (1u)
S    #define SPI_0_OLED_FLASH_INTERNAL_TX_SW_BUFFER_CONST    (1u)
S
S    /* Get wakeup enable option */
S    #define SPI_0_OLED_FLASH_SPI_WAKE_ENABLE_CONST  (1u)
S    #define SPI_0_OLED_FLASH_UART_WAKE_ENABLE_CONST (1u)
S    #define SPI_0_OLED_FLASH_CHECK_SPI_WAKE_ENABLE  ((0u != SPI_0_OLED_FLASH_scbEnableWake) && SPI_0_OLED_FLASH_SCB_MODE_SPI_RUNTM_CFG)
S    #define SPI_0_OLED_FLASH_CHECK_UART_WAKE_ENABLE ((0u != SPI_0_OLED_FLASH_scbEnableWake) && SPI_0_OLED_FLASH_SCB_MODE_UART_RUNTM_CFG)
S
S    /* SPI/UART: TX or RX FIFO size */
S    #if (SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1)
S        #define SPI_0_OLED_FLASH_SPI_UART_FIFO_SIZE             (SPI_0_OLED_FLASH_FIFO_SIZE)
S        #define SPI_0_OLED_FLASH_CHECK_UART_RTS_CONTROL_FLOW    (0u)
S    #else
S        #define SPI_0_OLED_FLASH_SPI_UART_FIFO_SIZE (SPI_0_OLED_FLASH_GET_FIFO_SIZE(SPI_0_OLED_FLASH_CTRL_REG & \
S                                                                                    SPI_0_OLED_FLASH_CTRL_BYTE_MODE))
X        #define SPI_0_OLED_FLASH_SPI_UART_FIFO_SIZE (SPI_0_OLED_FLASH_GET_FIFO_SIZE(SPI_0_OLED_FLASH_CTRL_REG &                                                                                     SPI_0_OLED_FLASH_CTRL_BYTE_MODE))
S
S        #define SPI_0_OLED_FLASH_CHECK_UART_RTS_CONTROL_FLOW \
S                    ((SPI_0_OLED_FLASH_SCB_MODE_UART_RUNTM_CFG) && \
S                     (0u != SPI_0_OLED_FLASH_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(SPI_0_OLED_FLASH_UART_FLOW_CTRL_REG)))
X        #define SPI_0_OLED_FLASH_CHECK_UART_RTS_CONTROL_FLOW                     ((SPI_0_OLED_FLASH_SCB_MODE_UART_RUNTM_CFG) &&                      (0u != SPI_0_OLED_FLASH_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(SPI_0_OLED_FLASH_UART_FLOW_CTRL_REG)))
S    #endif /* (SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1) */
S
N#else
N
N    /* Internal RX and TX buffer: for SPI or UART */
N    #if (SPI_0_OLED_FLASH_SCB_MODE_SPI_CONST_CFG)
X    #if (((0x02u) == (2u)))
N
N        /* SPI Direction */
N        #define SPI_0_OLED_FLASH_SPI_RX_DIRECTION (1u)
N        #define SPI_0_OLED_FLASH_SPI_TX_DIRECTION (1u)
N
N        /* Get FIFO size */
N        #define SPI_0_OLED_FLASH_SPI_UART_FIFO_SIZE SPI_0_OLED_FLASH_GET_FIFO_SIZE(SPI_0_OLED_FLASH_SPI_BYTE_MODE_ENABLE)
N
N        /* SPI internal RX and TX buffers */
N        #define SPI_0_OLED_FLASH_INTERNAL_SPI_RX_SW_BUFFER  (SPI_0_OLED_FLASH_SPI_RX_BUFFER_SIZE > \
N                                                                SPI_0_OLED_FLASH_SPI_UART_FIFO_SIZE)
X        #define SPI_0_OLED_FLASH_INTERNAL_SPI_RX_SW_BUFFER  (SPI_0_OLED_FLASH_SPI_RX_BUFFER_SIZE >                                                                 SPI_0_OLED_FLASH_SPI_UART_FIFO_SIZE)
N        #define SPI_0_OLED_FLASH_INTERNAL_SPI_TX_SW_BUFFER  (SPI_0_OLED_FLASH_SPI_TX_BUFFER_SIZE > \
N                                                                SPI_0_OLED_FLASH_SPI_UART_FIFO_SIZE)
X        #define SPI_0_OLED_FLASH_INTERNAL_SPI_TX_SW_BUFFER  (SPI_0_OLED_FLASH_SPI_TX_BUFFER_SIZE >                                                                 SPI_0_OLED_FLASH_SPI_UART_FIFO_SIZE)
N
N        /* Internal SPI RX and TX buffer */
N        #define SPI_0_OLED_FLASH_INTERNAL_RX_SW_BUFFER  (SPI_0_OLED_FLASH_INTERNAL_SPI_RX_SW_BUFFER)
N        #define SPI_0_OLED_FLASH_INTERNAL_TX_SW_BUFFER  (SPI_0_OLED_FLASH_INTERNAL_SPI_TX_SW_BUFFER)
N
N        /* Internal SPI RX and TX buffer size */
N        #define SPI_0_OLED_FLASH_INTERNAL_RX_BUFFER_SIZE    (SPI_0_OLED_FLASH_SPI_RX_BUFFER_SIZE + 1u)
N        #define SPI_0_OLED_FLASH_RX_BUFFER_SIZE             (SPI_0_OLED_FLASH_SPI_RX_BUFFER_SIZE)
N        #define SPI_0_OLED_FLASH_TX_BUFFER_SIZE             (SPI_0_OLED_FLASH_SPI_TX_BUFFER_SIZE)
N
N        /* Get wakeup enable option */
N        #define SPI_0_OLED_FLASH_SPI_WAKE_ENABLE_CONST  (0u != SPI_0_OLED_FLASH_SPI_WAKE_ENABLE)
N        #define SPI_0_OLED_FLASH_UART_WAKE_ENABLE_CONST (0u)
N
N    #else
S
S        /* UART Direction */
S        #define SPI_0_OLED_FLASH_UART_RX_DIRECTION (0u != (SPI_0_OLED_FLASH_UART_DIRECTION & SPI_0_OLED_FLASH_UART_RX))
S        #define SPI_0_OLED_FLASH_UART_TX_DIRECTION (0u != (SPI_0_OLED_FLASH_UART_DIRECTION & SPI_0_OLED_FLASH_UART_TX))
S
S        /* Get FIFO size */
S        #define SPI_0_OLED_FLASH_SPI_UART_FIFO_SIZE SPI_0_OLED_FLASH_GET_FIFO_SIZE(SPI_0_OLED_FLASH_UART_BYTE_MODE_ENABLE)
S
S        /* UART internal RX and TX buffers */
S        #define SPI_0_OLED_FLASH_INTERNAL_UART_RX_SW_BUFFER  (SPI_0_OLED_FLASH_UART_RX_BUFFER_SIZE > \
S                                                                SPI_0_OLED_FLASH_SPI_UART_FIFO_SIZE)
X        #define SPI_0_OLED_FLASH_INTERNAL_UART_RX_SW_BUFFER  (SPI_0_OLED_FLASH_UART_RX_BUFFER_SIZE >                                                                 SPI_0_OLED_FLASH_SPI_UART_FIFO_SIZE)
S        #define SPI_0_OLED_FLASH_INTERNAL_UART_TX_SW_BUFFER  (SPI_0_OLED_FLASH_UART_TX_BUFFER_SIZE > \
S                                                                    SPI_0_OLED_FLASH_SPI_UART_FIFO_SIZE)
X        #define SPI_0_OLED_FLASH_INTERNAL_UART_TX_SW_BUFFER  (SPI_0_OLED_FLASH_UART_TX_BUFFER_SIZE >                                                                     SPI_0_OLED_FLASH_SPI_UART_FIFO_SIZE)
S
S        /* Internal UART RX and TX buffer */
S        #define SPI_0_OLED_FLASH_INTERNAL_RX_SW_BUFFER  (SPI_0_OLED_FLASH_INTERNAL_UART_RX_SW_BUFFER)
S        #define SPI_0_OLED_FLASH_INTERNAL_TX_SW_BUFFER  (SPI_0_OLED_FLASH_INTERNAL_UART_TX_SW_BUFFER)
S
S        /* Internal UART RX and TX buffer size */
S        #define SPI_0_OLED_FLASH_INTERNAL_RX_BUFFER_SIZE    (SPI_0_OLED_FLASH_UART_RX_BUFFER_SIZE + 1u)
S        #define SPI_0_OLED_FLASH_RX_BUFFER_SIZE             (SPI_0_OLED_FLASH_UART_RX_BUFFER_SIZE)
S        #define SPI_0_OLED_FLASH_TX_BUFFER_SIZE             (SPI_0_OLED_FLASH_UART_TX_BUFFER_SIZE)
S
S        /* Get wakeup enable option */
S        #define SPI_0_OLED_FLASH_SPI_WAKE_ENABLE_CONST  (0u)
S        #define SPI_0_OLED_FLASH_UART_WAKE_ENABLE_CONST (0u != SPI_0_OLED_FLASH_UART_WAKE_ENABLE)
S
N    #endif /* (SPI_0_OLED_FLASH_SCB_MODE_SPI_CONST_CFG) */
N
N    /* Mode */
N    #define SPI_0_OLED_FLASH_SPI_SLAVE_CONST    (SPI_0_OLED_FLASH_SPI_MODE == SPI_0_OLED_FLASH_SPI_SLAVE)
N    #define SPI_0_OLED_FLASH_SPI_MASTER_CONST   (SPI_0_OLED_FLASH_SPI_MODE == SPI_0_OLED_FLASH_SPI_MASTER)
N
N    /* Direction */
N    #define SPI_0_OLED_FLASH_RX_DIRECTION ((SPI_0_OLED_FLASH_SCB_MODE_SPI_CONST_CFG) ? \
N                                            (SPI_0_OLED_FLASH_SPI_RX_DIRECTION) : (SPI_0_OLED_FLASH_UART_RX_DIRECTION))
X    #define SPI_0_OLED_FLASH_RX_DIRECTION ((SPI_0_OLED_FLASH_SCB_MODE_SPI_CONST_CFG) ?                                             (SPI_0_OLED_FLASH_SPI_RX_DIRECTION) : (SPI_0_OLED_FLASH_UART_RX_DIRECTION))
N
N    #define SPI_0_OLED_FLASH_TX_DIRECTION ((SPI_0_OLED_FLASH_SCB_MODE_SPI_CONST_CFG) ? \
N                                            (SPI_0_OLED_FLASH_SPI_TX_DIRECTION) : (SPI_0_OLED_FLASH_UART_TX_DIRECTION))
X    #define SPI_0_OLED_FLASH_TX_DIRECTION ((SPI_0_OLED_FLASH_SCB_MODE_SPI_CONST_CFG) ?                                             (SPI_0_OLED_FLASH_SPI_TX_DIRECTION) : (SPI_0_OLED_FLASH_UART_TX_DIRECTION))
N
N    /* Internal RX and TX buffer: for SPI or UART. Used in conditional compilation check */
N    #define SPI_0_OLED_FLASH_CHECK_RX_SW_BUFFER (SPI_0_OLED_FLASH_INTERNAL_RX_SW_BUFFER)
N    #define SPI_0_OLED_FLASH_CHECK_TX_SW_BUFFER (SPI_0_OLED_FLASH_INTERNAL_TX_SW_BUFFER)
N
N    /* Provide global variables to support RX and TX buffers */
N    #define SPI_0_OLED_FLASH_INTERNAL_RX_SW_BUFFER_CONST    (SPI_0_OLED_FLASH_INTERNAL_RX_SW_BUFFER)
N    #define SPI_0_OLED_FLASH_INTERNAL_TX_SW_BUFFER_CONST    (SPI_0_OLED_FLASH_INTERNAL_TX_SW_BUFFER)
N
N    /* Wake up enable */
N    #define SPI_0_OLED_FLASH_CHECK_SPI_WAKE_ENABLE  (SPI_0_OLED_FLASH_SPI_WAKE_ENABLE_CONST)
N    #define SPI_0_OLED_FLASH_CHECK_UART_WAKE_ENABLE (SPI_0_OLED_FLASH_UART_WAKE_ENABLE_CONST)
N
N    /* UART flow control: not applicable for CY_SCBIP_V0 || CY_SCBIP_V1 */
N    #define SPI_0_OLED_FLASH_CHECK_UART_RTS_CONTROL_FLOW    (SPI_0_OLED_FLASH_SCB_MODE_UART_CONST_CFG && \
N                                                             SPI_0_OLED_FLASH_UART_RTS_ENABLE)
X    #define SPI_0_OLED_FLASH_CHECK_UART_RTS_CONTROL_FLOW    (SPI_0_OLED_FLASH_SCB_MODE_UART_CONST_CFG &&                                                              SPI_0_OLED_FLASH_UART_RTS_ENABLE)
N
N#endif /* End (SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N
N/***************************************
N*       Type Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N
N/* SPI_0_OLED_FLASH_SPI_INIT_STRUCT */
Ntypedef struct
N{
N    /** Mode of operation for SPI. The following defines are available choices:
N     *  - SPI_0_OLED_FLASH_SPI_SLAVE
N     *  - SPI_0_OLED_FLASH_SPI_MASTE
N    */
N    uint32 mode;
N
N    /** Submode of operation for SPI. The following defines are available
N     *  choices:
N     *  - SPI_0_OLED_FLASH_SPI_MODE_MOTOROLA
N     *  - SPI_0_OLED_FLASH_SPI_MODE_TI_COINCIDES
N     *  - SPI_0_OLED_FLASH_SPI_MODE_TI_PRECEDES
N     *  - SPI_0_OLED_FLASH_SPI_MODE_NATIONAL
N    */
N    uint32 submode;
N
N    /** Determines the sclk relationship for Motorola submode. Ignored
N     *  for other submodes. The following defines are available choices:
N     *  - SPI_0_OLED_FLASH_SPI_SCLK_CPHA0_CPOL0
N     *  - SPI_0_OLED_FLASH_SPI_SCLK_CPHA0_CPOL1
N     *  - SPI_0_OLED_FLASH_SPI_SCLK_CPHA1_CPOL0
N     *  - SPI_0_OLED_FLASH_SPI_SCLK_CPHA1_CPOL1
N    */
N    uint32 sclkMode;
N
N    /** Oversampling factor for the SPI clock. Ignored for Slave mode operation.
N    */
N    uint32 oversample;
N
N    /** Applies median filter on the input lines: 0  not applied, 1  applied.
N    */
N    uint32 enableMedianFilter;
N
N    /** Applies late sampling of MISO line: 0  not applied, 1  applied.
N     *  Ignored for slave mode.
N    */
N    uint32 enableLateSampling;
N
N    /** Enables wakeup from low power mode: 0  disable, 1  enable.
N     *  Ignored for master mode.
N    */
N    uint32 enableWake;
N
N    /** Number of data bits for RX direction.
N     *  Different dataBitsRx and dataBitsTx are only allowed for National
N     *  submode.
N    */
N    uint32 rxDataBits;
N
N    /** Number of data bits for TX direction.
N     *  Different dataBitsRx and dataBitsTx are only allowed for National
N     *  submode.
N    */
N    uint32 txDataBits;
N
N    /** Determines the bit ordering. The following defines are available
N     *  choices:
N     *  - SPI_0_OLED_FLASH_BITS_ORDER_LSB_FIRST
N     *  - SPI_0_OLED_FLASH_BITS_ORDER_MSB_FIRST
N    */
N    uint32 bitOrder;
N
N    /** Determines whether transfers are back to back or have SS disabled
N     *  between words. Ignored for slave mode. The following defines are
N     *  available choices:
N     *  - SPI_0_OLED_FLASH_SPI_TRANSFER_CONTINUOUS
N     *  - SPI_0_OLED_FLASH_SPI_TRANSFER_SEPARATED
N    */
N    uint32 transferSeperation;
N
N    /** Size of the RX buffer in bytes/words (depends on rxDataBits parameter).
N     *  A value equal to the RX FIFO depth implies the usage of buffering in
N     *  hardware. A value greater than the RX FIFO depth results in a software
N     *  buffer.
N     *  The SPI_0_OLED_FLASH_INTR _RX_NOT_EMPTY interrupt has to be enabled to
N     *  transfer data into the software buffer.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words for PSoC 4100 /
N     *    PSoC 4200 devices.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words or 16
N     *    bytes (Byte mode is enabled) for PSoC 4100 BLE / PSoC 4200 BLE /
N     *    PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *    PSoC Analog Coprocessor devices.
N    */
N    uint32 rxBufferSize;
N
N    /** Buffer space provided for a RX software buffer:
N     *  - A NULL pointer must be provided to use hardware buffering.
N     *  - A pointer to an allocated buffer must be provided to use software
N     *    buffering. The buffer size must equal (rxBufferSize + 1) in bytes if
N     *    dataBitsRx is less or equal to 8, otherwise (2 * (rxBufferSize + 1))
N     *    in bytes. The software RX buffer always keeps one element empty.
N     *    For correct operation the allocated RX buffer has to be one element
N     *    greater than maximum packet size expected to be received.
N    */
N    uint8* rxBuffer;
N
N    /** Size of the TX buffer in bytes/words(depends on txDataBits parameter).
N     *  A value equal to the TX FIFO depth implies the usage of buffering in
N     *  hardware. A value greater than the TX FIFO depth results in a software
N     *  buffer.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words for PSoC 4100 /
N     *    PSoC 4200 devices.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words or 16
N     *    bytes (Byte mode is enabled) for PSoC 4100 BLE / PSoC 4200 BLE /
N     *    PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *    PSoC Analog Coprocessor devices.
N    */
N    uint32 txBufferSize;
N
N    /** Buffer space provided for a TX software buffer:
N     *  - A NULL pointer must be provided to use hardware buffering.
N     *  - A pointer to an allocated buffer must be provided to use software
N     *    buffering. The buffer size must equal txBufferSize if dataBitsTx is
N     *    less or equal to 8, otherwise (2* txBufferSize).
N    */
N    uint8* txBuffer;
N
N    /** Enables component interrupt: 0  disable, 1  enable.
N     *  The interrupt has to be enabled if software buffer is used.
N    */
N    uint32 enableInterrupt;
N
N    /** Mask of enabled interrupt sources for the RX direction. This mask is
N     *  written regardless of the setting of the enable Interrupt field.
N     *  Multiple sources are enabled by providing a value that is the OR of
N     *  all of the following sources to enable:
N     *  - SPI_0_OLED_FLASH_INTR_RX_FIFO_LEVEL
N     *  - SPI_0_OLED_FLASH_INTR_RX_NOT_EMPTY
N     *  - SPI_0_OLED_FLASH_INTR_RX_FULL
N     *  - SPI_0_OLED_FLASH_INTR_RX_OVERFLOW
N     *  - SPI_0_OLED_FLASH_INTR_RX_UNDERFLOW
N     *  - SPI_0_OLED_FLASH_INTR_SLAVE_SPI_BUS_ERROR
N    */
N    uint32 rxInterruptMask;
N
N    /** FIFO level for an RX FIFO level interrupt. This value is written
N     *  regardless of whether the RX FIFO level interrupt source is enabled.
N    */
N    uint32 rxTriggerLevel;
N
N    /** Mask of enabled interrupt sources for the TX direction. This mask is
N     *  written regardless of the setting of the enable Interrupt field.
N     *  Multiple sources are enabled by providing a value that is the OR of
N     *  all of the following sources to enable:
N     *  - SPI_0_OLED_FLASH_INTR_TX_FIFO_LEVEL
N     *  - SPI_0_OLED_FLASH_INTR_TX_NOT_FULL
N     *  - SPI_0_OLED_FLASH_INTR_TX_EMPTY
N     *  - SPI_0_OLED_FLASH_INTR_TX_OVERFLOW
N     *  - SPI_0_OLED_FLASH_INTR_TX_UNDERFLOW
N     *  - SPI_0_OLED_FLASH_INTR_MASTER_SPI_DONE
N    */
N    uint32 txInterruptMask;
N
N    /** FIFO level for a TX FIFO level interrupt. This value is written
N     * regardless of whether the TX FIFO level interrupt source is enabled.
N    */
N    uint32 txTriggerLevel;
N
N    /** When enabled the TX and RX FIFO depth is doubled and equal to
N     *  16 bytes: 0  disable, 1  enable. This implies that number of
N     *  TX and RX data bits must be less than or equal to 8.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 enableByteMode;
N
N    /** Enables continuous SCLK generation by the SPI master: 0  disable,
N     *  1  enable.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 enableFreeRunSclk;
N
N    /** Active polarity of slave select lines 0-3. This is bit mask where bit
N     *  SPI_0_OLED_FLASH_SPI_SLAVE_SELECT0 corresponds to slave select 0
N     *  polarity, bit SPI_0_OLED_FLASH_SPI_SLAVE_SELECT1  slave select 1
N     *  polarity and so on. Polarity constants are:
N     *  - SPI_0_OLED_FLASH_SPI_SS_ACTIVE_LOW
N     *  - SPI_0_OLED_FLASH_SPI_SS_ACTIVE_HIGH
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 polaritySs;
N} SPI_0_OLED_FLASH_SPI_INIT_STRUCT;
N
N
N/* SPI_0_OLED_FLASH_UART_INIT_STRUCT */
Ntypedef struct
N{
N    /** Mode of operation for the UART. The following defines are available
N     *  choices:
N     *  - SPI_0_OLED_FLASH_UART_MODE_STD
N     *  - SPI_0_OLED_FLASH_UART_MODE_SMARTCARD
N     *  - SPI_0_OLED_FLASH_UART_MODE_IRDA
N    */
N    uint32 mode;
N
N    /** Direction of operation for the UART. The following defines are available
N     *  choices:
N     *  - SPI_0_OLED_FLASH_UART_TX_RX
N     *  - SPI_0_OLED_FLASH_UART_RX
N     *  - SPI_0_OLED_FLASH_UART_TX
N    */
N    uint32 direction;
N
N    /** Number of data bits.
N    */
N    uint32 dataBits;
N
N    /** Determines the parity. The following defines are available choices:
N     *  - SPI_0_OLED_FLASH_UART_PARITY_EVEN
N     *  - SPI_0_OLED_FLASH_UART_PARITY_ODD
N     *  - SPI_0_OLED_FLASH_UART_PARITY_NONE
N    */
N    uint32 parity;
N
N    /** Determines the number of stop bits. The following defines are available
N     *  choices:
N     *  - SPI_0_OLED_FLASH_UART_STOP_BITS_1
N     *  - SPI_0_OLED_FLASH_UART_STOP_BITS_1_5
N     *  - SPI_0_OLED_FLASH_UART_STOP_BITS_2
N    */
N    uint32 stopBits;
N
N    /** Oversampling factor for the UART.
N     *
N     *  Note The oversampling factor values are changed when enableIrdaLowPower
N     *  is enabled:
N     *  - SPI_0_OLED_FLASH_UART_IRDA_LP_OVS16
N     *  - SPI_0_OLED_FLASH_UART_IRDA_LP_OVS32
N     *  - SPI_0_OLED_FLASH_UART_IRDA_LP_OVS48
N     *  - SPI_0_OLED_FLASH_UART_IRDA_LP_OVS96
N     *  - SPI_0_OLED_FLASH_UART_IRDA_LP_OVS192
N     *  - SPI_0_OLED_FLASH_UART_IRDA_LP_OVS768
N     *  - SPI_0_OLED_FLASH_UART_IRDA_LP_OVS1536
N    */
N    uint32 oversample;
N
N    /** Enables IrDA low power RX mode operation: 0  disable, 1  enable.
N     *  The TX functionality does not work when enabled.
N    */
N    uint32 enableIrdaLowPower;
N
N    /** Applies median filter on the input lines:  0  not applied, 1  applied.
N    */
N    uint32 enableMedianFilter;
N
N    /** Enables retry when NACK response was received: 0  disable, 1  enable.
N     *  Only current content of TX FIFO is re-sent.
N     *  Ignored for modes other than SmartCard.
N    */
N    uint32 enableRetryNack;
N
N    /** Inverts polarity of RX line: 0  non-inverting, 1  inverting.
N     *  Ignored for modes other than IrDA.
N    */
N    uint32 enableInvertedRx;
N
N    /** Drop data from RX FIFO if parity error is detected: 0  disable,
N     *  1  enable.
N    */
N    uint32 dropOnParityErr;
N
N    /** Drop data from RX FIFO if a frame error is detected: 0  disable,
N     *  1  enable.
N    */
N    uint32 dropOnFrameErr;
N
N    /** Enables wakeup from low power mode: 0  disable, 1  enable.
N     *  Ignored for modes other than standard UART. The RX functionality
N     *  has to be enabled.
N    */
N    uint32 enableWake;
N
N    /** Size of the RX buffer in bytes/words (depends on rxDataBits parameter).
N     *  A value equal to the RX FIFO depth implies the usage of buffering in
N     *  hardware. A value greater than the RX FIFO depth results in a software
N     *  buffer.
N     *  The SPI_0_OLED_FLASH_INTR _RX_NOT_EMPTY interrupt has to be enabled to
N     *  transfer data into the software buffer.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words for PSoC 4100 /
N     *    PSoC 4200 devices.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words or 16
N     *    bytes (Byte mode is enabled) for PSoC 4100 BLE / PSoC 4200 BLE /
N     *    PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *    PSoC Analog Coprocessor devices.
N    */
N    uint32 rxBufferSize;
N
N    /** Buffer space provided for a RX software buffer:
N     *  - A NULL pointer must be provided to use hardware buffering.
N     *  - A pointer to an allocated buffer must be provided to use software
N     *    buffering. The buffer size must equal (rxBufferSize + 1) in bytes if
N     *    dataBitsRx is less or equal to 8, otherwise (2 * (rxBufferSize + 1))
N     *    in bytes. The software RX buffer always keeps one element empty.
N     *    For correct operation the allocated RX buffer has to be one element
N     *    greater than maximum packet size expected to be received.
N    */
N    uint8* rxBuffer;
N
N    /** Size of the TX buffer in bytes/words(depends on txDataBits parameter).
N     *  A value equal to the TX FIFO depth implies the usage of buffering in
N     *  hardware. A value greater than the TX FIFO depth results in a software
N     *  buffer.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words for PSoC 4100 /
N     *    PSoC 4200 devices.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words or 16
N     *    bytes (Byte mode is enabled) for PSoC 4100 BLE / PSoC 4200 BLE /
N     *    PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *    PSoC Analog Coprocessor devices.
N    */
N    uint32 txBufferSize;
N
N    /** Buffer space provided for a TX software buffer:
N     *  - A NULL pointer must be provided to use hardware buffering.
N     *  - A pointer to an allocated buffer must be provided to use software
N     *    buffering. The buffer size must equal txBufferSize if dataBitsTx is
N     *    less or equal to 8, otherwise (2* txBufferSize).
N    */
N    uint8* txBuffer;
N
N    /** Enables multiprocessor mode: 0  disable, 1  enable.
N    */
N    uint32 enableMultiproc;
N
N    /** Enables matched address to be accepted: 0  disable, 1  enable.
N    */
N    uint32 multiprocAcceptAddr;
N
N    /** 8 bit address to match in Multiprocessor mode. Ignored for other modes.
N    */
N    uint32 multiprocAddr;
N
N    /** 8 bit mask of address bits that are compared for a Multiprocessor
N     *  address match. Ignored for other modes.
N     *  - Bit value 0  excludes bit from address comparison.
N     *  - Bit value 1  the bit needs to match with the corresponding bit
N     *   of the device address.
N    */
N    uint32 multiprocAddrMask;
N
N    /** Enables component interrupt: 0  disable, 1  enable.
N     *  The interrupt has to be enabled if software buffer is used.
N    */
N    uint32 enableInterrupt;
N
N    /** Mask of interrupt sources to enable in the RX direction. This mask is
N     *  written regardless of the setting of the enableInterrupt field.
N     *  Multiple sources are enabled by providing a value that is the OR of
N     *  all of the following sources to enable:
N     *  - SPI_0_OLED_FLASH_INTR_RX_FIFO_LEVEL
N     *  - SPI_0_OLED_FLASH_INTR_RX_NOT_EMPTY
N     *  - SPI_0_OLED_FLASH_INTR_RX_FULL
N     *  - SPI_0_OLED_FLASH_INTR_RX_OVERFLOW
N     *  - SPI_0_OLED_FLASH_INTR_RX_UNDERFLOW
N     *  - SPI_0_OLED_FLASH_INTR_RX_FRAME_ERROR
N     *  - SPI_0_OLED_FLASH_INTR_RX_PARITY_ERROR
N    */
N    uint32 rxInterruptMask;
N
N    /** FIFO level for an RX FIFO level interrupt. This value is written
N     *  regardless of whether the RX FIFO level interrupt source is enabled.
N    */
N    uint32 rxTriggerLevel;
N
N    /** Mask of interrupt sources to enable in the TX direction. This mask is
N     *  written regardless of the setting of the enableInterrupt field.
N     *  Multiple sources are enabled by providing a value that is the OR of
N     *  all of the following sources to enable:
N     *  - SPI_0_OLED_FLASH_INTR_TX_FIFO_LEVEL
N     *  - SPI_0_OLED_FLASH_INTR_TX_NOT_FULL
N     *  - SPI_0_OLED_FLASH_INTR_TX_EMPTY
N     *  - SPI_0_OLED_FLASH_INTR_TX_OVERFLOW
N     *  - SPI_0_OLED_FLASH_INTR_TX_UNDERFLOW
N     *  - SPI_0_OLED_FLASH_INTR_TX_UART_DONE
N     *  - SPI_0_OLED_FLASH_INTR_TX_UART_NACK
N     *  - SPI_0_OLED_FLASH_INTR_TX_UART_ARB_LOST
N    */
N    uint32 txInterruptMask;
N
N    /** FIFO level for a TX FIFO level interrupt. This value is written
N     *  regardless of whether the TX FIFO level interrupt source is enabled.
N    */
N    uint32 txTriggerLevel;
N
N    /** When enabled the TX and RX FIFO depth is doubled and equal to
N     *  16 bytes: 0  disable, 1  enable. This implies that number of
N     *  Data bits must be less than or equal to 8.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 enableByteMode;
N
N    /** Enables usage of CTS input signal by the UART transmitter : 0  disable,
N     *  1  enable.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 enableCts;
N
N    /** Sets active polarity of CTS input signal:
N     *  - SPI_0_OLED_FLASH_UART_CTS_ACTIVE_LOW
N     *  - SPI_0_OLED_FLASH_UART_CTS_ACTIVE_HIGH
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 ctsPolarity;
N
N    /** RX FIFO level for RTS signal activation. While the RX FIFO has fewer
N     *  entries than the RTS FIFO level value the RTS signal remains active,
N     *  otherwise the RTS signal becomes inactive. By setting this field to 0,
N     *  RTS signal activation is disabled.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 rtsRxFifoLevel;
N
N    /** Sets active polarity of RTS output signal:
N     *  - SPI_0_OLED_FLASH_UART_RTS_ ACTIVE_LOW
N     *  - SPI_0_OLED_FLASH_UART_RTS_ACTIVE_HIGH
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 rtsPolarity;
N
N    /** Configures the width of a break signal in that triggers the break
N     *  detection interrupt source. A Break is a low level on the RX line.
N     *  Valid range is 1-16 UART bits times.
N    */
N    uint8 breakWidth;
N} SPI_0_OLED_FLASH_UART_INIT_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
N/**
N* \addtogroup group_spi
N* @{
N*/
N/* SPI specific functions */
N#if(SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (2u)))
S    void SPI_0_OLED_FLASH_SpiInit(const SPI_0_OLED_FLASH_SPI_INIT_STRUCT *config);
N#endif /* (SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N
N#if(SPI_0_OLED_FLASH_SCB_MODE_SPI_INC)
X#if((0u !=((0x02u) & (2u))))
N    /*******************************************************************************
N    * Function Name: SPI_0_OLED_FLASH_SpiIsBusBusy
N    ****************************************************************************//**
N    *
N    *  Returns the current status on the bus. The bus status is determined using
N    *  the slave select signal.
N    *  - Motorola and National Semiconductor sub-modes: The bus is busy after
N    *    the slave select line is activated and lasts until the slave select line
N    *    is deactivated.
N    *  - Texas Instrument sub-modes: The bus is busy at the moment of the initial
N    *    pulse on the slave select line and lasts until the transfer is complete.
N    *    If SPI Master is configured to use "Separated transfers"
N    *    (see Continuous versus Separated Transfer Separation), the bus is busy
N    *    during each element transfer and is free between each element transfer.
N    *    The Master does not activate SS line immediately after data has been
N    *    written into the TX FIFO.
N    *
N    *  \return slaveSelect: Current status on the bus.
N    *   If the returned value is nonzero, the bus is busy.
N    *   If zero is returned, the bus is free. The bus status is determined using
N    *   the slave select signal.
N    *
N    *******************************************************************************/
N    #define SPI_0_OLED_FLASH_SpiIsBusBusy() ((uint32) (0u != (SPI_0_OLED_FLASH_SPI_STATUS_REG & \
N                                                              SPI_0_OLED_FLASH_SPI_STATUS_BUS_BUSY)))
X    #define SPI_0_OLED_FLASH_SpiIsBusBusy() ((uint32) (0u != (SPI_0_OLED_FLASH_SPI_STATUS_REG &                                                               SPI_0_OLED_FLASH_SPI_STATUS_BUS_BUSY)))
N
N    #if (SPI_0_OLED_FLASH_SPI_MASTER_CONST)
X    #if (((1u) == (1u)))
N        void SPI_0_OLED_FLASH_SpiSetActiveSlaveSelect(uint32 slaveSelect);
N    #endif /*(SPI_0_OLED_FLASH_SPI_MASTER_CONST) */
N
N    #if !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1)
X    #if !((2 == 0u) || (2 == 1u))
N        void SPI_0_OLED_FLASH_SpiSetSlaveSelectPolarity(uint32 slaveSelect, uint32 polarity);
N    #endif /* !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N#endif /* (SPI_0_OLED_FLASH_SCB_MODE_SPI_INC) */
N/** @} spi */
N
N/**
N* \addtogroup group_uart
N* @{
N*/
N/* UART specific functions */
N#if(SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (2u)))
S    void SPI_0_OLED_FLASH_UartInit(const SPI_0_OLED_FLASH_UART_INIT_STRUCT *config);
N#endif /* (SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N#if(SPI_0_OLED_FLASH_SCB_MODE_UART_INC)
X#if((0u !=((0x04u) & (2u))))
S    void SPI_0_OLED_FLASH_UartSetRxAddress(uint32 address);
S    void SPI_0_OLED_FLASH_UartSetRxAddressMask(uint32 addressMask);
S
S
S    /* UART RX direction APIs */
S    #if(SPI_0_OLED_FLASH_UART_RX_DIRECTION)
S        uint32 SPI_0_OLED_FLASH_UartGetChar(void);
S        uint32 SPI_0_OLED_FLASH_UartGetByte(void);
S
S        #if !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1)
S            /* UART APIs for Flow Control */
S            void SPI_0_OLED_FLASH_UartSetRtsPolarity(uint32 polarity);
S            void SPI_0_OLED_FLASH_UartSetRtsFifoLevel(uint32 level);
S        #endif /* !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1) */
S    #endif /* (SPI_0_OLED_FLASH_UART_RX_DIRECTION) */
S
S    /* UART TX direction APIs */
S    #if(SPI_0_OLED_FLASH_UART_TX_DIRECTION)
S        /*******************************************************************************
S        * Function Name: SPI_0_OLED_FLASH_UartPutChar
S        ****************************************************************************//**
S        *
S        *  Places a byte of data in the transmit buffer to be sent at the next available
S        *  bus time. This function is blocking and waits until there is a space
S        *  available to put requested data in the transmit buffer.
S        *  For UART Multi Processor mode this function can send 9-bits data as well.
S        *  Use SPI_0_OLED_FLASH_UART_MP_MARK to add a mark to create an address byte.
S        *
S        *  \param txDataByte: the data to be transmitted.
S        *
S        *******************************************************************************/
S        #define SPI_0_OLED_FLASH_UartPutChar(ch)    SPI_0_OLED_FLASH_SpiUartWriteTxData((uint32)(ch))
S
S        void SPI_0_OLED_FLASH_UartPutString(const char8 string[]);
S        void SPI_0_OLED_FLASH_UartPutCRLF(uint32 txDataByte);
S        void SPI_0_OLED_FLASH_UartSendBreakBlocking(uint32 breakWidth);
S
S        #if !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1)
S            /* UART APIs for Flow Control */
S            void SPI_0_OLED_FLASH_UartEnableCts(void);
S            void SPI_0_OLED_FLASH_UartDisableCts(void);
S            void SPI_0_OLED_FLASH_UartSetCtsPolarity(uint32 polarity);
S        #endif /* !(SPI_0_OLED_FLASH_CY_SCBIP_V0 || SPI_0_OLED_FLASH_CY_SCBIP_V1) */
S    #endif /* (SPI_0_OLED_FLASH_UART_TX_DIRECTION) */
N#endif /* (SPI_0_OLED_FLASH_SCB_MODE_UART_INC) */
N/** @} uart */
N
N/**
N* \addtogroup group_spi_uart
N* @{
N*/
N#if(SPI_0_OLED_FLASH_RX_DIRECTION)
X#if(((((0x02u) == (2u))) ? ((1u)) : (SPI_0_OLED_FLASH_UART_RX_DIRECTION)))
N    uint32 SPI_0_OLED_FLASH_SpiUartReadRxData(void);
N    uint32 SPI_0_OLED_FLASH_SpiUartGetRxBufferSize(void);
N    void   SPI_0_OLED_FLASH_SpiUartClearRxBuffer(void);
N#endif /* (SPI_0_OLED_FLASH_RX_DIRECTION) */
N
N/* Common APIs TX direction */
N#if(SPI_0_OLED_FLASH_TX_DIRECTION)
X#if(((((0x02u) == (2u))) ? ((1u)) : (SPI_0_OLED_FLASH_UART_TX_DIRECTION)))
N    void   SPI_0_OLED_FLASH_SpiUartWriteTxData(uint32 txData);
N    void   SPI_0_OLED_FLASH_SpiUartPutArray(const uint8 wrBuf[], uint32 count);
N    uint32 SPI_0_OLED_FLASH_SpiUartGetTxBufferSize(void);
N    void   SPI_0_OLED_FLASH_SpiUartClearTxBuffer(void);
N#endif /* (SPI_0_OLED_FLASH_TX_DIRECTION) */
N/** @} spi_uart */
N
NCY_ISR_PROTO(SPI_0_OLED_FLASH_SPI_UART_ISR);
Xvoid SPI_0_OLED_FLASH_SPI_UART_ISR (void);
N
N#if(SPI_0_OLED_FLASH_UART_RX_WAKEUP_IRQ)
X#if((0u == (1u)))
S    CY_ISR_PROTO(SPI_0_OLED_FLASH_UART_WAKEUP_ISR);
N#endif /* (SPI_0_OLED_FLASH_UART_RX_WAKEUP_IRQ) */
N
N
N/***************************************
N*     Buffer Access Macro Definitions
N***************************************/
N
N#if(SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (2u)))
S    /* RX direction */
S    void   SPI_0_OLED_FLASH_PutWordInRxBuffer  (uint32 idx, uint32 rxDataByte);
S    uint32 SPI_0_OLED_FLASH_GetWordFromRxBuffer(uint32 idx);
S
S    /* TX direction */
S    void   SPI_0_OLED_FLASH_PutWordInTxBuffer  (uint32 idx, uint32 txDataByte);
S    uint32 SPI_0_OLED_FLASH_GetWordFromTxBuffer(uint32 idx);
S
N#else
N    /* RX direction */
N    #if(SPI_0_OLED_FLASH_INTERNAL_RX_SW_BUFFER_CONST)
X    #if(((((16u) > ((0u != ((1u))) ? (2u * (8u)) : ((8u)))))))
S        #define SPI_0_OLED_FLASH_PutWordInRxBuffer(idx, rxDataByte) \
S                do{                                                 \
S                    SPI_0_OLED_FLASH_rxBufferInternal[(idx)] = ((uint8) (rxDataByte)); \
S                }while(0)
X        #define SPI_0_OLED_FLASH_PutWordInRxBuffer(idx, rxDataByte)                 do{                                                                     SPI_0_OLED_FLASH_rxBufferInternal[(idx)] = ((uint8) (rxDataByte));                 }while(0)
S
S        #define SPI_0_OLED_FLASH_GetWordFromRxBuffer(idx) SPI_0_OLED_FLASH_rxBufferInternal[(idx)]
S
N    #endif /* (SPI_0_OLED_FLASH_INTERNAL_RX_SW_BUFFER_CONST) */
N
N    /* TX direction */
N    #if(SPI_0_OLED_FLASH_INTERNAL_TX_SW_BUFFER_CONST)
X    #if(((((16u) > ((0u != ((1u))) ? (2u * (8u)) : ((8u)))))))
S        #define SPI_0_OLED_FLASH_PutWordInTxBuffer(idx, txDataByte) \
S                    do{                                             \
S                        SPI_0_OLED_FLASH_txBufferInternal[(idx)] = ((uint8) (txDataByte)); \
S                    }while(0)
X        #define SPI_0_OLED_FLASH_PutWordInTxBuffer(idx, txDataByte)                     do{                                                                     SPI_0_OLED_FLASH_txBufferInternal[(idx)] = ((uint8) (txDataByte));                     }while(0)
S
S        #define SPI_0_OLED_FLASH_GetWordFromTxBuffer(idx) SPI_0_OLED_FLASH_txBufferInternal[(idx)]
S
N    #endif /* (SPI_0_OLED_FLASH_INTERNAL_TX_SW_BUFFER_CONST) */
N
N#endif /* (SPI_0_OLED_FLASH_TX_SW_BUFFER_ENABLE) */
N
N
N/***************************************
N*         SPI API Constants
N***************************************/
N
N/* SPI sub mode enum */
N#define SPI_0_OLED_FLASH_SPI_MODE_MOTOROLA      (0x00u)
N#define SPI_0_OLED_FLASH_SPI_MODE_TI_COINCIDES  (0x01u)
N#define SPI_0_OLED_FLASH_SPI_MODE_TI_PRECEDES   (0x11u)
N#define SPI_0_OLED_FLASH_SPI_MODE_NATIONAL      (0x02u)
N#define SPI_0_OLED_FLASH_SPI_MODE_MASK          (0x03u)
N#define SPI_0_OLED_FLASH_SPI_MODE_TI_PRECEDES_MASK  (0x10u)
N#define SPI_0_OLED_FLASH_SPI_MODE_NS_MICROWIRE  (SPI_0_OLED_FLASH_SPI_MODE_NATIONAL)
N
N/* SPI phase and polarity mode enum */
N#define SPI_0_OLED_FLASH_SPI_SCLK_CPHA0_CPOL0   (0x00u)
N#define SPI_0_OLED_FLASH_SPI_SCLK_CPHA0_CPOL1   (0x02u)
N#define SPI_0_OLED_FLASH_SPI_SCLK_CPHA1_CPOL0   (0x01u)
N#define SPI_0_OLED_FLASH_SPI_SCLK_CPHA1_CPOL1   (0x03u)
N
N/* SPI bits order enum */
N#define SPI_0_OLED_FLASH_BITS_ORDER_LSB_FIRST   (0u)
N#define SPI_0_OLED_FLASH_BITS_ORDER_MSB_FIRST   (1u)
N
N/* SPI transfer separation enum */
N#define SPI_0_OLED_FLASH_SPI_TRANSFER_SEPARATED     (0u)
N#define SPI_0_OLED_FLASH_SPI_TRANSFER_CONTINUOUS    (1u)
N
N/* SPI slave select constants */
N#define SPI_0_OLED_FLASH_SPI_SLAVE_SELECT0    (SPI_0_OLED_FLASH_SCB__SS0_POSISTION)
N#define SPI_0_OLED_FLASH_SPI_SLAVE_SELECT1    (SPI_0_OLED_FLASH_SCB__SS1_POSISTION)
N#define SPI_0_OLED_FLASH_SPI_SLAVE_SELECT2    (SPI_0_OLED_FLASH_SCB__SS2_POSISTION)
N#define SPI_0_OLED_FLASH_SPI_SLAVE_SELECT3    (SPI_0_OLED_FLASH_SCB__SS3_POSISTION)
N
N/* SPI slave select polarity settings */
N#define SPI_0_OLED_FLASH_SPI_SS_ACTIVE_LOW  (0u)
N#define SPI_0_OLED_FLASH_SPI_SS_ACTIVE_HIGH (1u)
N
N#define SPI_0_OLED_FLASH_INTR_SPIM_TX_RESTORE   (SPI_0_OLED_FLASH_INTR_TX_OVERFLOW)
N
N#define SPI_0_OLED_FLASH_INTR_SPIS_TX_RESTORE     (SPI_0_OLED_FLASH_INTR_TX_OVERFLOW | \
N                                                 SPI_0_OLED_FLASH_INTR_TX_UNDERFLOW)
X#define SPI_0_OLED_FLASH_INTR_SPIS_TX_RESTORE     (SPI_0_OLED_FLASH_INTR_TX_OVERFLOW |                                                  SPI_0_OLED_FLASH_INTR_TX_UNDERFLOW)
N
N/***************************************
N*         UART API Constants
N***************************************/
N
N/* UART sub-modes enum */
N#define SPI_0_OLED_FLASH_UART_MODE_STD          (0u)
N#define SPI_0_OLED_FLASH_UART_MODE_SMARTCARD    (1u)
N#define SPI_0_OLED_FLASH_UART_MODE_IRDA         (2u)
N
N/* UART direction enum */
N#define SPI_0_OLED_FLASH_UART_RX    (1u)
N#define SPI_0_OLED_FLASH_UART_TX    (2u)
N#define SPI_0_OLED_FLASH_UART_TX_RX (3u)
N
N/* UART parity enum */
N#define SPI_0_OLED_FLASH_UART_PARITY_EVEN   (0u)
N#define SPI_0_OLED_FLASH_UART_PARITY_ODD    (1u)
N#define SPI_0_OLED_FLASH_UART_PARITY_NONE   (2u)
N
N/* UART stop bits enum */
N#define SPI_0_OLED_FLASH_UART_STOP_BITS_1   (2u)
N#define SPI_0_OLED_FLASH_UART_STOP_BITS_1_5 (3u)
N#define SPI_0_OLED_FLASH_UART_STOP_BITS_2   (4u)
N
N/* UART IrDA low power OVS enum */
N#define SPI_0_OLED_FLASH_UART_IRDA_LP_OVS16     (16u)
N#define SPI_0_OLED_FLASH_UART_IRDA_LP_OVS32     (32u)
N#define SPI_0_OLED_FLASH_UART_IRDA_LP_OVS48     (48u)
N#define SPI_0_OLED_FLASH_UART_IRDA_LP_OVS96     (96u)
N#define SPI_0_OLED_FLASH_UART_IRDA_LP_OVS192    (192u)
N#define SPI_0_OLED_FLASH_UART_IRDA_LP_OVS768    (768u)
N#define SPI_0_OLED_FLASH_UART_IRDA_LP_OVS1536   (1536u)
N
N/* Uart MP: mark (address) and space (data) bit definitions */
N#define SPI_0_OLED_FLASH_UART_MP_MARK       (0x100u)
N#define SPI_0_OLED_FLASH_UART_MP_SPACE      (0x000u)
N
N/* UART CTS/RTS polarity settings */
N#define SPI_0_OLED_FLASH_UART_CTS_ACTIVE_LOW    (0u)
N#define SPI_0_OLED_FLASH_UART_CTS_ACTIVE_HIGH   (1u)
N#define SPI_0_OLED_FLASH_UART_RTS_ACTIVE_LOW    (0u)
N#define SPI_0_OLED_FLASH_UART_RTS_ACTIVE_HIGH   (1u)
N
N/* Sources of RX errors */
N#define SPI_0_OLED_FLASH_INTR_RX_ERR        (SPI_0_OLED_FLASH_INTR_RX_OVERFLOW    | \
N                                             SPI_0_OLED_FLASH_INTR_RX_UNDERFLOW   | \
N                                             SPI_0_OLED_FLASH_INTR_RX_FRAME_ERROR | \
N                                             SPI_0_OLED_FLASH_INTR_RX_PARITY_ERROR)
X#define SPI_0_OLED_FLASH_INTR_RX_ERR        (SPI_0_OLED_FLASH_INTR_RX_OVERFLOW    |                                              SPI_0_OLED_FLASH_INTR_RX_UNDERFLOW   |                                              SPI_0_OLED_FLASH_INTR_RX_FRAME_ERROR |                                              SPI_0_OLED_FLASH_INTR_RX_PARITY_ERROR)
N
N/* Shifted INTR_RX_ERR defines ONLY for SPI_0_OLED_FLASH_UartGetByte() */
N#define SPI_0_OLED_FLASH_UART_RX_OVERFLOW       (SPI_0_OLED_FLASH_INTR_RX_OVERFLOW << 8u)
N#define SPI_0_OLED_FLASH_UART_RX_UNDERFLOW      (SPI_0_OLED_FLASH_INTR_RX_UNDERFLOW << 8u)
N#define SPI_0_OLED_FLASH_UART_RX_FRAME_ERROR    (SPI_0_OLED_FLASH_INTR_RX_FRAME_ERROR << 8u)
N#define SPI_0_OLED_FLASH_UART_RX_PARITY_ERROR   (SPI_0_OLED_FLASH_INTR_RX_PARITY_ERROR << 8u)
N#define SPI_0_OLED_FLASH_UART_RX_ERROR_MASK     (SPI_0_OLED_FLASH_UART_RX_OVERFLOW    | \
N                                                 SPI_0_OLED_FLASH_UART_RX_UNDERFLOW   | \
N                                                 SPI_0_OLED_FLASH_UART_RX_FRAME_ERROR | \
N                                                 SPI_0_OLED_FLASH_UART_RX_PARITY_ERROR)
X#define SPI_0_OLED_FLASH_UART_RX_ERROR_MASK     (SPI_0_OLED_FLASH_UART_RX_OVERFLOW    |                                                  SPI_0_OLED_FLASH_UART_RX_UNDERFLOW   |                                                  SPI_0_OLED_FLASH_UART_RX_FRAME_ERROR |                                                  SPI_0_OLED_FLASH_UART_RX_PARITY_ERROR)
N
N#define SPI_0_OLED_FLASH_INTR_UART_TX_RESTORE   (SPI_0_OLED_FLASH_INTR_TX_OVERFLOW  | \
N                                                 SPI_0_OLED_FLASH_INTR_TX_UART_NACK | \
N                                                 SPI_0_OLED_FLASH_INTR_TX_UART_DONE | \
N                                                 SPI_0_OLED_FLASH_INTR_TX_UART_ARB_LOST)
X#define SPI_0_OLED_FLASH_INTR_UART_TX_RESTORE   (SPI_0_OLED_FLASH_INTR_TX_OVERFLOW  |                                                  SPI_0_OLED_FLASH_INTR_TX_UART_NACK |                                                  SPI_0_OLED_FLASH_INTR_TX_UART_DONE |                                                  SPI_0_OLED_FLASH_INTR_TX_UART_ARB_LOST)
N
N
N/***************************************
N*     Vars with External Linkage
N***************************************/
N
N#if(SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (2u)))
S    extern const SPI_0_OLED_FLASH_SPI_INIT_STRUCT  SPI_0_OLED_FLASH_configSpi;
S    extern const SPI_0_OLED_FLASH_UART_INIT_STRUCT SPI_0_OLED_FLASH_configUart;
N#endif /* (SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N#if (SPI_0_OLED_FLASH_UART_WAKE_ENABLE_CONST && SPI_0_OLED_FLASH_UART_RX_WAKEUP_IRQ)
X#if ((0u) && (0u == (1u)))
S    extern uint8 SPI_0_OLED_FLASH_skipStart;
N#endif /* (SPI_0_OLED_FLASH_UART_WAKE_ENABLE_CONST && SPI_0_OLED_FLASH_UART_RX_WAKEUP_IRQ) */
N
N
N/***************************************
N*    Specific SPI Macro Definitions
N***************************************/
N
N#define SPI_0_OLED_FLASH_GET_SPI_INTR_SLAVE_MASK(sourceMask)  ((sourceMask) & SPI_0_OLED_FLASH_INTR_SLAVE_SPI_BUS_ERROR)
N#define SPI_0_OLED_FLASH_GET_SPI_INTR_MASTER_MASK(sourceMask) ((sourceMask) & SPI_0_OLED_FLASH_INTR_MASTER_SPI_DONE)
N#define SPI_0_OLED_FLASH_GET_SPI_INTR_RX_MASK(sourceMask) \
N                                             ((sourceMask) & (uint32) ~SPI_0_OLED_FLASH_INTR_SLAVE_SPI_BUS_ERROR)
X#define SPI_0_OLED_FLASH_GET_SPI_INTR_RX_MASK(sourceMask)                                              ((sourceMask) & (uint32) ~SPI_0_OLED_FLASH_INTR_SLAVE_SPI_BUS_ERROR)
N
N#define SPI_0_OLED_FLASH_GET_SPI_INTR_TX_MASK(sourceMask) \
N                                             ((sourceMask) & (uint32) ~SPI_0_OLED_FLASH_INTR_MASTER_SPI_DONE)
X#define SPI_0_OLED_FLASH_GET_SPI_INTR_TX_MASK(sourceMask)                                              ((sourceMask) & (uint32) ~SPI_0_OLED_FLASH_INTR_MASTER_SPI_DONE)
N
N
N/***************************************
N*    Specific UART Macro Definitions
N***************************************/
N
N#define SPI_0_OLED_FLASH_UART_GET_CTRL_OVS_IRDA_LP(oversample) \
N        ((SPI_0_OLED_FLASH_UART_IRDA_LP_OVS16   == (oversample)) ? SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS16 : \
N         ((SPI_0_OLED_FLASH_UART_IRDA_LP_OVS32   == (oversample)) ? SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS32 : \
N          ((SPI_0_OLED_FLASH_UART_IRDA_LP_OVS48   == (oversample)) ? SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS48 : \
N           ((SPI_0_OLED_FLASH_UART_IRDA_LP_OVS96   == (oversample)) ? SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS96 : \
N            ((SPI_0_OLED_FLASH_UART_IRDA_LP_OVS192  == (oversample)) ? SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS192 : \
N             ((SPI_0_OLED_FLASH_UART_IRDA_LP_OVS768  == (oversample)) ? SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS768 : \
N              ((SPI_0_OLED_FLASH_UART_IRDA_LP_OVS1536 == (oversample)) ? SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS1536 : \
N                                                                          SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS16)))))))
X#define SPI_0_OLED_FLASH_UART_GET_CTRL_OVS_IRDA_LP(oversample)         ((SPI_0_OLED_FLASH_UART_IRDA_LP_OVS16   == (oversample)) ? SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS16 :          ((SPI_0_OLED_FLASH_UART_IRDA_LP_OVS32   == (oversample)) ? SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS32 :           ((SPI_0_OLED_FLASH_UART_IRDA_LP_OVS48   == (oversample)) ? SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS48 :            ((SPI_0_OLED_FLASH_UART_IRDA_LP_OVS96   == (oversample)) ? SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS96 :             ((SPI_0_OLED_FLASH_UART_IRDA_LP_OVS192  == (oversample)) ? SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS192 :              ((SPI_0_OLED_FLASH_UART_IRDA_LP_OVS768  == (oversample)) ? SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS768 :               ((SPI_0_OLED_FLASH_UART_IRDA_LP_OVS1536 == (oversample)) ? SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS1536 :                                                                           SPI_0_OLED_FLASH_CTRL_OVS_IRDA_LP_OVS16)))))))
N
N#define SPI_0_OLED_FLASH_GET_UART_RX_CTRL_ENABLED(direction) ((0u != (SPI_0_OLED_FLASH_UART_RX & (direction))) ? \
N                                                                     (SPI_0_OLED_FLASH_RX_CTRL_ENABLED) : (0u))
X#define SPI_0_OLED_FLASH_GET_UART_RX_CTRL_ENABLED(direction) ((0u != (SPI_0_OLED_FLASH_UART_RX & (direction))) ?                                                                      (SPI_0_OLED_FLASH_RX_CTRL_ENABLED) : (0u))
N
N#define SPI_0_OLED_FLASH_GET_UART_TX_CTRL_ENABLED(direction) ((0u != (SPI_0_OLED_FLASH_UART_TX & (direction))) ? \
N                                                                     (SPI_0_OLED_FLASH_TX_CTRL_ENABLED) : (0u))
X#define SPI_0_OLED_FLASH_GET_UART_TX_CTRL_ENABLED(direction) ((0u != (SPI_0_OLED_FLASH_UART_TX & (direction))) ?                                                                      (SPI_0_OLED_FLASH_TX_CTRL_ENABLED) : (0u))
N
N
N/***************************************
N*        SPI Register Settings
N***************************************/
N
N#define SPI_0_OLED_FLASH_CTRL_SPI      (SPI_0_OLED_FLASH_CTRL_MODE_SPI)
N#define SPI_0_OLED_FLASH_SPI_RX_CTRL   (SPI_0_OLED_FLASH_RX_CTRL_ENABLED)
N#define SPI_0_OLED_FLASH_SPI_TX_CTRL   (SPI_0_OLED_FLASH_TX_CTRL_ENABLED)
N
N
N/***************************************
N*       SPI Init Register Settings
N***************************************/
N
N#define SPI_0_OLED_FLASH_SPI_SS_POLARITY \
N             (((uint32) SPI_0_OLED_FLASH_SPI_SS0_POLARITY << SPI_0_OLED_FLASH_SPI_SLAVE_SELECT0) | \
N              ((uint32) SPI_0_OLED_FLASH_SPI_SS1_POLARITY << SPI_0_OLED_FLASH_SPI_SLAVE_SELECT1) | \
N              ((uint32) SPI_0_OLED_FLASH_SPI_SS2_POLARITY << SPI_0_OLED_FLASH_SPI_SLAVE_SELECT2) | \
N              ((uint32) SPI_0_OLED_FLASH_SPI_SS3_POLARITY << SPI_0_OLED_FLASH_SPI_SLAVE_SELECT3))
X#define SPI_0_OLED_FLASH_SPI_SS_POLARITY              (((uint32) SPI_0_OLED_FLASH_SPI_SS0_POLARITY << SPI_0_OLED_FLASH_SPI_SLAVE_SELECT0) |               ((uint32) SPI_0_OLED_FLASH_SPI_SS1_POLARITY << SPI_0_OLED_FLASH_SPI_SLAVE_SELECT1) |               ((uint32) SPI_0_OLED_FLASH_SPI_SS2_POLARITY << SPI_0_OLED_FLASH_SPI_SLAVE_SELECT2) |               ((uint32) SPI_0_OLED_FLASH_SPI_SS3_POLARITY << SPI_0_OLED_FLASH_SPI_SLAVE_SELECT3))
N
N#if(SPI_0_OLED_FLASH_SCB_MODE_SPI_CONST_CFG)
X#if(((0x02u) == (2u)))
N
N    /* SPI Configuration */
N    #define SPI_0_OLED_FLASH_SPI_DEFAULT_CTRL \
N                    (SPI_0_OLED_FLASH_GET_CTRL_OVS(SPI_0_OLED_FLASH_SPI_OVS_FACTOR) | \
N                     SPI_0_OLED_FLASH_GET_CTRL_BYTE_MODE (SPI_0_OLED_FLASH_SPI_BYTE_MODE_ENABLE) | \
N                     SPI_0_OLED_FLASH_GET_CTRL_EC_AM_MODE(SPI_0_OLED_FLASH_SPI_WAKE_ENABLE)      | \
N                     SPI_0_OLED_FLASH_CTRL_SPI)
X    #define SPI_0_OLED_FLASH_SPI_DEFAULT_CTRL                     (SPI_0_OLED_FLASH_GET_CTRL_OVS(SPI_0_OLED_FLASH_SPI_OVS_FACTOR) |                      SPI_0_OLED_FLASH_GET_CTRL_BYTE_MODE (SPI_0_OLED_FLASH_SPI_BYTE_MODE_ENABLE) |                      SPI_0_OLED_FLASH_GET_CTRL_EC_AM_MODE(SPI_0_OLED_FLASH_SPI_WAKE_ENABLE)      |                      SPI_0_OLED_FLASH_CTRL_SPI)
N
N    #define SPI_0_OLED_FLASH_SPI_DEFAULT_SPI_CTRL \
N                    (SPI_0_OLED_FLASH_GET_SPI_CTRL_CONTINUOUS    (SPI_0_OLED_FLASH_SPI_TRANSFER_SEPARATION)       | \
N                     SPI_0_OLED_FLASH_GET_SPI_CTRL_SELECT_PRECEDE(SPI_0_OLED_FLASH_SPI_SUB_MODE &                   \
N                                                                  SPI_0_OLED_FLASH_SPI_MODE_TI_PRECEDES_MASK)     | \
N                     SPI_0_OLED_FLASH_GET_SPI_CTRL_SCLK_MODE     (SPI_0_OLED_FLASH_SPI_CLOCK_MODE)                | \
N                     SPI_0_OLED_FLASH_GET_SPI_CTRL_LATE_MISO_SAMPLE(SPI_0_OLED_FLASH_SPI_LATE_MISO_SAMPLE_ENABLE) | \
N                     SPI_0_OLED_FLASH_GET_SPI_CTRL_SCLK_CONTINUOUS(SPI_0_OLED_FLASH_SPI_FREE_RUN_SCLK_ENABLE)     | \
N                     SPI_0_OLED_FLASH_GET_SPI_CTRL_SSEL_POLARITY (SPI_0_OLED_FLASH_SPI_SS_POLARITY)               | \
N                     SPI_0_OLED_FLASH_GET_SPI_CTRL_SUB_MODE      (SPI_0_OLED_FLASH_SPI_SUB_MODE)                  | \
N                     SPI_0_OLED_FLASH_GET_SPI_CTRL_MASTER_MODE   (SPI_0_OLED_FLASH_SPI_MODE))
X    #define SPI_0_OLED_FLASH_SPI_DEFAULT_SPI_CTRL                     (SPI_0_OLED_FLASH_GET_SPI_CTRL_CONTINUOUS    (SPI_0_OLED_FLASH_SPI_TRANSFER_SEPARATION)       |                      SPI_0_OLED_FLASH_GET_SPI_CTRL_SELECT_PRECEDE(SPI_0_OLED_FLASH_SPI_SUB_MODE &                                                                                     SPI_0_OLED_FLASH_SPI_MODE_TI_PRECEDES_MASK)     |                      SPI_0_OLED_FLASH_GET_SPI_CTRL_SCLK_MODE     (SPI_0_OLED_FLASH_SPI_CLOCK_MODE)                |                      SPI_0_OLED_FLASH_GET_SPI_CTRL_LATE_MISO_SAMPLE(SPI_0_OLED_FLASH_SPI_LATE_MISO_SAMPLE_ENABLE) |                      SPI_0_OLED_FLASH_GET_SPI_CTRL_SCLK_CONTINUOUS(SPI_0_OLED_FLASH_SPI_FREE_RUN_SCLK_ENABLE)     |                      SPI_0_OLED_FLASH_GET_SPI_CTRL_SSEL_POLARITY (SPI_0_OLED_FLASH_SPI_SS_POLARITY)               |                      SPI_0_OLED_FLASH_GET_SPI_CTRL_SUB_MODE      (SPI_0_OLED_FLASH_SPI_SUB_MODE)                  |                      SPI_0_OLED_FLASH_GET_SPI_CTRL_MASTER_MODE   (SPI_0_OLED_FLASH_SPI_MODE))
N
N    /* RX direction */
N    #define SPI_0_OLED_FLASH_SPI_DEFAULT_RX_CTRL \
N                    (SPI_0_OLED_FLASH_GET_RX_CTRL_DATA_WIDTH(SPI_0_OLED_FLASH_SPI_RX_DATA_BITS_NUM)     | \
N                     SPI_0_OLED_FLASH_GET_RX_CTRL_BIT_ORDER (SPI_0_OLED_FLASH_SPI_BITS_ORDER)           | \
N                     SPI_0_OLED_FLASH_GET_RX_CTRL_MEDIAN    (SPI_0_OLED_FLASH_SPI_MEDIAN_FILTER_ENABLE) | \
N                     SPI_0_OLED_FLASH_SPI_RX_CTRL)
X    #define SPI_0_OLED_FLASH_SPI_DEFAULT_RX_CTRL                     (SPI_0_OLED_FLASH_GET_RX_CTRL_DATA_WIDTH(SPI_0_OLED_FLASH_SPI_RX_DATA_BITS_NUM)     |                      SPI_0_OLED_FLASH_GET_RX_CTRL_BIT_ORDER (SPI_0_OLED_FLASH_SPI_BITS_ORDER)           |                      SPI_0_OLED_FLASH_GET_RX_CTRL_MEDIAN    (SPI_0_OLED_FLASH_SPI_MEDIAN_FILTER_ENABLE) |                      SPI_0_OLED_FLASH_SPI_RX_CTRL)
N
N    #define SPI_0_OLED_FLASH_SPI_DEFAULT_RX_FIFO_CTRL \
N                    SPI_0_OLED_FLASH_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(SPI_0_OLED_FLASH_SPI_RX_TRIGGER_LEVEL)
X    #define SPI_0_OLED_FLASH_SPI_DEFAULT_RX_FIFO_CTRL                     SPI_0_OLED_FLASH_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(SPI_0_OLED_FLASH_SPI_RX_TRIGGER_LEVEL)
N
N    /* TX direction */
N    #define SPI_0_OLED_FLASH_SPI_DEFAULT_TX_CTRL \
N                    (SPI_0_OLED_FLASH_GET_TX_CTRL_DATA_WIDTH(SPI_0_OLED_FLASH_SPI_TX_DATA_BITS_NUM) | \
N                     SPI_0_OLED_FLASH_GET_TX_CTRL_BIT_ORDER (SPI_0_OLED_FLASH_SPI_BITS_ORDER)       | \
N                     SPI_0_OLED_FLASH_SPI_TX_CTRL)
X    #define SPI_0_OLED_FLASH_SPI_DEFAULT_TX_CTRL                     (SPI_0_OLED_FLASH_GET_TX_CTRL_DATA_WIDTH(SPI_0_OLED_FLASH_SPI_TX_DATA_BITS_NUM) |                      SPI_0_OLED_FLASH_GET_TX_CTRL_BIT_ORDER (SPI_0_OLED_FLASH_SPI_BITS_ORDER)       |                      SPI_0_OLED_FLASH_SPI_TX_CTRL)
N
N    #define SPI_0_OLED_FLASH_SPI_DEFAULT_TX_FIFO_CTRL \
N                    SPI_0_OLED_FLASH_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(SPI_0_OLED_FLASH_SPI_TX_TRIGGER_LEVEL)
X    #define SPI_0_OLED_FLASH_SPI_DEFAULT_TX_FIFO_CTRL                     SPI_0_OLED_FLASH_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(SPI_0_OLED_FLASH_SPI_TX_TRIGGER_LEVEL)
N
N    /* Interrupt sources */
N    #define SPI_0_OLED_FLASH_SPI_DEFAULT_INTR_SPI_EC_MASK   (SPI_0_OLED_FLASH_NO_INTR_SOURCES)
N
N    #define SPI_0_OLED_FLASH_SPI_DEFAULT_INTR_I2C_EC_MASK   (SPI_0_OLED_FLASH_NO_INTR_SOURCES)
N    #define SPI_0_OLED_FLASH_SPI_DEFAULT_INTR_SLAVE_MASK \
N                    (SPI_0_OLED_FLASH_SPI_INTR_RX_MASK & SPI_0_OLED_FLASH_INTR_SLAVE_SPI_BUS_ERROR)
X    #define SPI_0_OLED_FLASH_SPI_DEFAULT_INTR_SLAVE_MASK                     (SPI_0_OLED_FLASH_SPI_INTR_RX_MASK & SPI_0_OLED_FLASH_INTR_SLAVE_SPI_BUS_ERROR)
N
N    #define SPI_0_OLED_FLASH_SPI_DEFAULT_INTR_MASTER_MASK \
N                    (SPI_0_OLED_FLASH_SPI_INTR_TX_MASK & SPI_0_OLED_FLASH_INTR_MASTER_SPI_DONE)
X    #define SPI_0_OLED_FLASH_SPI_DEFAULT_INTR_MASTER_MASK                     (SPI_0_OLED_FLASH_SPI_INTR_TX_MASK & SPI_0_OLED_FLASH_INTR_MASTER_SPI_DONE)
N
N    #define SPI_0_OLED_FLASH_SPI_DEFAULT_INTR_RX_MASK \
N                    (SPI_0_OLED_FLASH_SPI_INTR_RX_MASK & (uint32) ~SPI_0_OLED_FLASH_INTR_SLAVE_SPI_BUS_ERROR)
X    #define SPI_0_OLED_FLASH_SPI_DEFAULT_INTR_RX_MASK                     (SPI_0_OLED_FLASH_SPI_INTR_RX_MASK & (uint32) ~SPI_0_OLED_FLASH_INTR_SLAVE_SPI_BUS_ERROR)
N
N    #define SPI_0_OLED_FLASH_SPI_DEFAULT_INTR_TX_MASK \
N                    (SPI_0_OLED_FLASH_SPI_INTR_TX_MASK & (uint32) ~SPI_0_OLED_FLASH_INTR_MASTER_SPI_DONE)
X    #define SPI_0_OLED_FLASH_SPI_DEFAULT_INTR_TX_MASK                     (SPI_0_OLED_FLASH_SPI_INTR_TX_MASK & (uint32) ~SPI_0_OLED_FLASH_INTR_MASTER_SPI_DONE)
N
N#endif /* (SPI_0_OLED_FLASH_SCB_MODE_SPI_CONST_CFG) */
N
N
N/***************************************
N*        UART Register Settings
N***************************************/
N
N#define SPI_0_OLED_FLASH_CTRL_UART      (SPI_0_OLED_FLASH_CTRL_MODE_UART)
N#define SPI_0_OLED_FLASH_UART_RX_CTRL   (SPI_0_OLED_FLASH_RX_CTRL_LSB_FIRST) /* LSB for UART goes first */
N#define SPI_0_OLED_FLASH_UART_TX_CTRL   (SPI_0_OLED_FLASH_TX_CTRL_LSB_FIRST) /* LSB for UART goes first */
N
N
N/***************************************
N*      UART Init Register Settings
N***************************************/
N
N#if(SPI_0_OLED_FLASH_SCB_MODE_UART_CONST_CFG)
X#if(((0x04u) == (2u)))
S
S    /* UART configuration */
S    #if(SPI_0_OLED_FLASH_UART_MODE_IRDA == SPI_0_OLED_FLASH_UART_SUB_MODE)
S
S        #define SPI_0_OLED_FLASH_DEFAULT_CTRL_OVS   ((0u != SPI_0_OLED_FLASH_UART_IRDA_LOW_POWER) ?              \
S                                (SPI_0_OLED_FLASH_UART_GET_CTRL_OVS_IRDA_LP(SPI_0_OLED_FLASH_UART_OVS_FACTOR)) : \
S                                (SPI_0_OLED_FLASH_CTRL_OVS_IRDA_OVS16))
X        #define SPI_0_OLED_FLASH_DEFAULT_CTRL_OVS   ((0u != SPI_0_OLED_FLASH_UART_IRDA_LOW_POWER) ?                                              (SPI_0_OLED_FLASH_UART_GET_CTRL_OVS_IRDA_LP(SPI_0_OLED_FLASH_UART_OVS_FACTOR)) :                                 (SPI_0_OLED_FLASH_CTRL_OVS_IRDA_OVS16))
S
S    #else
S
S        #define SPI_0_OLED_FLASH_DEFAULT_CTRL_OVS   SPI_0_OLED_FLASH_GET_CTRL_OVS(SPI_0_OLED_FLASH_UART_OVS_FACTOR)
S
S    #endif /* (SPI_0_OLED_FLASH_UART_MODE_IRDA == SPI_0_OLED_FLASH_UART_SUB_MODE) */
S
S    #define SPI_0_OLED_FLASH_UART_DEFAULT_CTRL \
S                                (SPI_0_OLED_FLASH_GET_CTRL_BYTE_MODE  (SPI_0_OLED_FLASH_UART_BYTE_MODE_ENABLE)  | \
S                                 SPI_0_OLED_FLASH_GET_CTRL_ADDR_ACCEPT(SPI_0_OLED_FLASH_UART_MP_ACCEPT_ADDRESS) | \
S                                 SPI_0_OLED_FLASH_DEFAULT_CTRL_OVS                                              | \
S                                 SPI_0_OLED_FLASH_CTRL_UART)
X    #define SPI_0_OLED_FLASH_UART_DEFAULT_CTRL                                 (SPI_0_OLED_FLASH_GET_CTRL_BYTE_MODE  (SPI_0_OLED_FLASH_UART_BYTE_MODE_ENABLE)  |                                  SPI_0_OLED_FLASH_GET_CTRL_ADDR_ACCEPT(SPI_0_OLED_FLASH_UART_MP_ACCEPT_ADDRESS) |                                  SPI_0_OLED_FLASH_DEFAULT_CTRL_OVS                                              |                                  SPI_0_OLED_FLASH_CTRL_UART)
S
S    #define SPI_0_OLED_FLASH_UART_DEFAULT_UART_CTRL \
S                                    (SPI_0_OLED_FLASH_GET_UART_CTRL_MODE(SPI_0_OLED_FLASH_UART_SUB_MODE))
X    #define SPI_0_OLED_FLASH_UART_DEFAULT_UART_CTRL                                     (SPI_0_OLED_FLASH_GET_UART_CTRL_MODE(SPI_0_OLED_FLASH_UART_SUB_MODE))
S
S    /* RX direction */
S    #define SPI_0_OLED_FLASH_UART_DEFAULT_RX_CTRL_PARITY \
S                                ((SPI_0_OLED_FLASH_UART_PARITY_NONE != SPI_0_OLED_FLASH_UART_PARITY_TYPE) ?      \
S                                  (SPI_0_OLED_FLASH_GET_UART_RX_CTRL_PARITY(SPI_0_OLED_FLASH_UART_PARITY_TYPE) | \
S                                   SPI_0_OLED_FLASH_UART_RX_CTRL_PARITY_ENABLED) : (0u))
X    #define SPI_0_OLED_FLASH_UART_DEFAULT_RX_CTRL_PARITY                                 ((SPI_0_OLED_FLASH_UART_PARITY_NONE != SPI_0_OLED_FLASH_UART_PARITY_TYPE) ?                                        (SPI_0_OLED_FLASH_GET_UART_RX_CTRL_PARITY(SPI_0_OLED_FLASH_UART_PARITY_TYPE) |                                    SPI_0_OLED_FLASH_UART_RX_CTRL_PARITY_ENABLED) : (0u))
S
S    #define SPI_0_OLED_FLASH_UART_DEFAULT_UART_RX_CTRL \
S                    (SPI_0_OLED_FLASH_GET_UART_RX_CTRL_MODE(SPI_0_OLED_FLASH_UART_STOP_BITS_NUM)                    | \
S                     SPI_0_OLED_FLASH_GET_UART_RX_CTRL_POLARITY(SPI_0_OLED_FLASH_UART_IRDA_POLARITY)                | \
S                     SPI_0_OLED_FLASH_GET_UART_RX_CTRL_MP_MODE(SPI_0_OLED_FLASH_UART_MP_MODE_ENABLE)                | \
S                     SPI_0_OLED_FLASH_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(SPI_0_OLED_FLASH_UART_DROP_ON_PARITY_ERR) | \
S                     SPI_0_OLED_FLASH_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(SPI_0_OLED_FLASH_UART_DROP_ON_FRAME_ERR)   | \
S                     SPI_0_OLED_FLASH_GET_UART_RX_CTRL_BREAK_WIDTH(SPI_0_OLED_FLASH_UART_RX_BREAK_WIDTH)            | \
S                     SPI_0_OLED_FLASH_UART_DEFAULT_RX_CTRL_PARITY)
X    #define SPI_0_OLED_FLASH_UART_DEFAULT_UART_RX_CTRL                     (SPI_0_OLED_FLASH_GET_UART_RX_CTRL_MODE(SPI_0_OLED_FLASH_UART_STOP_BITS_NUM)                    |                      SPI_0_OLED_FLASH_GET_UART_RX_CTRL_POLARITY(SPI_0_OLED_FLASH_UART_IRDA_POLARITY)                |                      SPI_0_OLED_FLASH_GET_UART_RX_CTRL_MP_MODE(SPI_0_OLED_FLASH_UART_MP_MODE_ENABLE)                |                      SPI_0_OLED_FLASH_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(SPI_0_OLED_FLASH_UART_DROP_ON_PARITY_ERR) |                      SPI_0_OLED_FLASH_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(SPI_0_OLED_FLASH_UART_DROP_ON_FRAME_ERR)   |                      SPI_0_OLED_FLASH_GET_UART_RX_CTRL_BREAK_WIDTH(SPI_0_OLED_FLASH_UART_RX_BREAK_WIDTH)            |                      SPI_0_OLED_FLASH_UART_DEFAULT_RX_CTRL_PARITY)
S
S
S    #define SPI_0_OLED_FLASH_UART_DEFAULT_RX_CTRL \
S                                (SPI_0_OLED_FLASH_GET_RX_CTRL_DATA_WIDTH(SPI_0_OLED_FLASH_UART_DATA_BITS_NUM)        | \
S                                 SPI_0_OLED_FLASH_GET_RX_CTRL_MEDIAN    (SPI_0_OLED_FLASH_UART_MEDIAN_FILTER_ENABLE) | \
S                                 SPI_0_OLED_FLASH_GET_UART_RX_CTRL_ENABLED(SPI_0_OLED_FLASH_UART_DIRECTION))
X    #define SPI_0_OLED_FLASH_UART_DEFAULT_RX_CTRL                                 (SPI_0_OLED_FLASH_GET_RX_CTRL_DATA_WIDTH(SPI_0_OLED_FLASH_UART_DATA_BITS_NUM)        |                                  SPI_0_OLED_FLASH_GET_RX_CTRL_MEDIAN    (SPI_0_OLED_FLASH_UART_MEDIAN_FILTER_ENABLE) |                                  SPI_0_OLED_FLASH_GET_UART_RX_CTRL_ENABLED(SPI_0_OLED_FLASH_UART_DIRECTION))
S
S    #define SPI_0_OLED_FLASH_UART_DEFAULT_RX_FIFO_CTRL \
S                                SPI_0_OLED_FLASH_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(SPI_0_OLED_FLASH_UART_RX_TRIGGER_LEVEL)
X    #define SPI_0_OLED_FLASH_UART_DEFAULT_RX_FIFO_CTRL                                 SPI_0_OLED_FLASH_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(SPI_0_OLED_FLASH_UART_RX_TRIGGER_LEVEL)
S
S    #define SPI_0_OLED_FLASH_UART_DEFAULT_RX_MATCH_REG  ((0u != SPI_0_OLED_FLASH_UART_MP_MODE_ENABLE) ?          \
S                                (SPI_0_OLED_FLASH_GET_RX_MATCH_ADDR(SPI_0_OLED_FLASH_UART_MP_RX_ADDRESS) | \
S                                 SPI_0_OLED_FLASH_GET_RX_MATCH_MASK(SPI_0_OLED_FLASH_UART_MP_RX_ADDRESS_MASK)) : (0u))
X    #define SPI_0_OLED_FLASH_UART_DEFAULT_RX_MATCH_REG  ((0u != SPI_0_OLED_FLASH_UART_MP_MODE_ENABLE) ?                                          (SPI_0_OLED_FLASH_GET_RX_MATCH_ADDR(SPI_0_OLED_FLASH_UART_MP_RX_ADDRESS) |                                  SPI_0_OLED_FLASH_GET_RX_MATCH_MASK(SPI_0_OLED_FLASH_UART_MP_RX_ADDRESS_MASK)) : (0u))
S
S    /* TX direction */
S    #define SPI_0_OLED_FLASH_UART_DEFAULT_TX_CTRL_PARITY (SPI_0_OLED_FLASH_UART_DEFAULT_RX_CTRL_PARITY)
S
S    #define SPI_0_OLED_FLASH_UART_DEFAULT_UART_TX_CTRL \
S                                (SPI_0_OLED_FLASH_GET_UART_TX_CTRL_MODE(SPI_0_OLED_FLASH_UART_STOP_BITS_NUM)       | \
S                                 SPI_0_OLED_FLASH_GET_UART_TX_CTRL_RETRY_NACK(SPI_0_OLED_FLASH_UART_RETRY_ON_NACK) | \
S                                 SPI_0_OLED_FLASH_UART_DEFAULT_TX_CTRL_PARITY)
X    #define SPI_0_OLED_FLASH_UART_DEFAULT_UART_TX_CTRL                                 (SPI_0_OLED_FLASH_GET_UART_TX_CTRL_MODE(SPI_0_OLED_FLASH_UART_STOP_BITS_NUM)       |                                  SPI_0_OLED_FLASH_GET_UART_TX_CTRL_RETRY_NACK(SPI_0_OLED_FLASH_UART_RETRY_ON_NACK) |                                  SPI_0_OLED_FLASH_UART_DEFAULT_TX_CTRL_PARITY)
S
S    #define SPI_0_OLED_FLASH_UART_DEFAULT_TX_CTRL \
S                                (SPI_0_OLED_FLASH_GET_TX_CTRL_DATA_WIDTH(SPI_0_OLED_FLASH_UART_DATA_BITS_NUM) | \
S                                 SPI_0_OLED_FLASH_GET_UART_TX_CTRL_ENABLED(SPI_0_OLED_FLASH_UART_DIRECTION))
X    #define SPI_0_OLED_FLASH_UART_DEFAULT_TX_CTRL                                 (SPI_0_OLED_FLASH_GET_TX_CTRL_DATA_WIDTH(SPI_0_OLED_FLASH_UART_DATA_BITS_NUM) |                                  SPI_0_OLED_FLASH_GET_UART_TX_CTRL_ENABLED(SPI_0_OLED_FLASH_UART_DIRECTION))
S
S    #define SPI_0_OLED_FLASH_UART_DEFAULT_TX_FIFO_CTRL \
S                                SPI_0_OLED_FLASH_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(SPI_0_OLED_FLASH_UART_TX_TRIGGER_LEVEL)
X    #define SPI_0_OLED_FLASH_UART_DEFAULT_TX_FIFO_CTRL                                 SPI_0_OLED_FLASH_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(SPI_0_OLED_FLASH_UART_TX_TRIGGER_LEVEL)
S
S    #define SPI_0_OLED_FLASH_UART_DEFAULT_FLOW_CTRL \
S                        (SPI_0_OLED_FLASH_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(SPI_0_OLED_FLASH_UART_RTS_FIFO_LEVEL) | \
S                         SPI_0_OLED_FLASH_GET_UART_FLOW_CTRL_RTS_POLARITY (SPI_0_OLED_FLASH_UART_RTS_POLARITY)   | \
S                         SPI_0_OLED_FLASH_GET_UART_FLOW_CTRL_CTS_POLARITY (SPI_0_OLED_FLASH_UART_CTS_POLARITY)   | \
S                         SPI_0_OLED_FLASH_GET_UART_FLOW_CTRL_CTS_ENABLE   (SPI_0_OLED_FLASH_UART_CTS_ENABLE))
X    #define SPI_0_OLED_FLASH_UART_DEFAULT_FLOW_CTRL                         (SPI_0_OLED_FLASH_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(SPI_0_OLED_FLASH_UART_RTS_FIFO_LEVEL) |                          SPI_0_OLED_FLASH_GET_UART_FLOW_CTRL_RTS_POLARITY (SPI_0_OLED_FLASH_UART_RTS_POLARITY)   |                          SPI_0_OLED_FLASH_GET_UART_FLOW_CTRL_CTS_POLARITY (SPI_0_OLED_FLASH_UART_CTS_POLARITY)   |                          SPI_0_OLED_FLASH_GET_UART_FLOW_CTRL_CTS_ENABLE   (SPI_0_OLED_FLASH_UART_CTS_ENABLE))
S
S    /* Interrupt sources */
S    #define SPI_0_OLED_FLASH_UART_DEFAULT_INTR_I2C_EC_MASK  (SPI_0_OLED_FLASH_NO_INTR_SOURCES)
S    #define SPI_0_OLED_FLASH_UART_DEFAULT_INTR_SPI_EC_MASK  (SPI_0_OLED_FLASH_NO_INTR_SOURCES)
S    #define SPI_0_OLED_FLASH_UART_DEFAULT_INTR_SLAVE_MASK   (SPI_0_OLED_FLASH_NO_INTR_SOURCES)
S    #define SPI_0_OLED_FLASH_UART_DEFAULT_INTR_MASTER_MASK  (SPI_0_OLED_FLASH_NO_INTR_SOURCES)
S    #define SPI_0_OLED_FLASH_UART_DEFAULT_INTR_RX_MASK      (SPI_0_OLED_FLASH_UART_INTR_RX_MASK)
S    #define SPI_0_OLED_FLASH_UART_DEFAULT_INTR_TX_MASK      (SPI_0_OLED_FLASH_UART_INTR_TX_MASK)
S
N#endif /* (SPI_0_OLED_FLASH_SCB_MODE_UART_CONST_CFG) */
N
N
N/***************************************
N* The following code is DEPRECATED and
N* must not be used.
N***************************************/
N
N#define SPI_0_OLED_FLASH_SPIM_ACTIVE_SS0    (SPI_0_OLED_FLASH_SPI_SLAVE_SELECT0)
N#define SPI_0_OLED_FLASH_SPIM_ACTIVE_SS1    (SPI_0_OLED_FLASH_SPI_SLAVE_SELECT1)
N#define SPI_0_OLED_FLASH_SPIM_ACTIVE_SS2    (SPI_0_OLED_FLASH_SPI_SLAVE_SELECT2)
N#define SPI_0_OLED_FLASH_SPIM_ACTIVE_SS3    (SPI_0_OLED_FLASH_SPI_SLAVE_SELECT3)
N
N#endif /* CY_SCB_SPI_UART_SPI_0_OLED_FLASH_H */
N
N
N/* [] END OF FILE */
L 41 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_PINS.h"
N#include "SPI_0_OLED_FLASH_SPI_UART_PVT.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_SPI_UART_PVT.h" 1
N/***************************************************************************//**
N* \file SPI_0_OLED_FLASH_SPI_UART_PVT.h
N* \version 4.0
N*
N* \brief
N*  This private file provides constants and parameter values for the
N*  SCB Component in SPI and UART modes.
N*  Please do not use this file or its content in your project.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation. All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_SPI_UART_PVT_SPI_0_OLED_FLASH_H)
X#if !0L
N#define CY_SCB_SPI_UART_PVT_SPI_0_OLED_FLASH_H
N
N#include "SPI_0_OLED_FLASH_SPI_UART.h"
N
N
N/***************************************
N*     Internal Global Vars
N***************************************/
N
N#if (SPI_0_OLED_FLASH_INTERNAL_RX_SW_BUFFER_CONST)
X#if (((((16u) > ((0u != ((1u))) ? (2u * (8u)) : ((8u)))))))
S    extern volatile uint32  SPI_0_OLED_FLASH_rxBufferHead;
S    extern volatile uint32  SPI_0_OLED_FLASH_rxBufferTail;
S    
S    /**
S    * \addtogroup group_globals
S    * @{
S    */
S    
S    /** Sets when internal software receive buffer overflow
S     *  was occurred.
S    */  
S    extern volatile uint8   SPI_0_OLED_FLASH_rxBufferOverflow;
S    /** @} globals */
N#endif /* (SPI_0_OLED_FLASH_INTERNAL_RX_SW_BUFFER_CONST) */
N
N#if (SPI_0_OLED_FLASH_INTERNAL_TX_SW_BUFFER_CONST)
X#if (((((16u) > ((0u != ((1u))) ? (2u * (8u)) : ((8u)))))))
S    extern volatile uint32  SPI_0_OLED_FLASH_txBufferHead;
S    extern volatile uint32  SPI_0_OLED_FLASH_txBufferTail;
N#endif /* (SPI_0_OLED_FLASH_INTERNAL_TX_SW_BUFFER_CONST) */
N
N#if (SPI_0_OLED_FLASH_INTERNAL_RX_SW_BUFFER)
X#if ((((16u) > ((0u != ((1u))) ? (2u * (8u)) : ((8u))))))
S    extern volatile uint8 SPI_0_OLED_FLASH_rxBufferInternal[SPI_0_OLED_FLASH_INTERNAL_RX_BUFFER_SIZE];
N#endif /* (SPI_0_OLED_FLASH_INTERNAL_RX_SW_BUFFER) */
N
N#if (SPI_0_OLED_FLASH_INTERNAL_TX_SW_BUFFER)
X#if ((((16u) > ((0u != ((1u))) ? (2u * (8u)) : ((8u))))))
S    extern volatile uint8 SPI_0_OLED_FLASH_txBufferInternal[SPI_0_OLED_FLASH_TX_BUFFER_SIZE];
N#endif /* (SPI_0_OLED_FLASH_INTERNAL_TX_SW_BUFFER) */
N
N
N/***************************************
N*     Private Function Prototypes
N***************************************/
N
Nvoid SPI_0_OLED_FLASH_SpiPostEnable(void);
Nvoid SPI_0_OLED_FLASH_SpiStop(void);
N
N#if (SPI_0_OLED_FLASH_SCB_MODE_SPI_CONST_CFG)
X#if (((0x02u) == (2u)))
N    void SPI_0_OLED_FLASH_SpiInit(void);
N#endif /* (SPI_0_OLED_FLASH_SCB_MODE_SPI_CONST_CFG) */
N
N#if (SPI_0_OLED_FLASH_SPI_WAKE_ENABLE_CONST)
X#if ((0u != (0u)))
S    void SPI_0_OLED_FLASH_SpiSaveConfig(void);
S    void SPI_0_OLED_FLASH_SpiRestoreConfig(void);
N#endif /* (SPI_0_OLED_FLASH_SPI_WAKE_ENABLE_CONST) */
N
Nvoid SPI_0_OLED_FLASH_UartPostEnable(void);
Nvoid SPI_0_OLED_FLASH_UartStop(void);
N
N#if (SPI_0_OLED_FLASH_SCB_MODE_UART_CONST_CFG)
X#if (((0x04u) == (2u)))
S    void SPI_0_OLED_FLASH_UartInit(void);
N#endif /* (SPI_0_OLED_FLASH_SCB_MODE_UART_CONST_CFG) */
N
N#if (SPI_0_OLED_FLASH_UART_WAKE_ENABLE_CONST)
X#if ((0u))
S    void SPI_0_OLED_FLASH_UartSaveConfig(void);
S    void SPI_0_OLED_FLASH_UartRestoreConfig(void);
N#endif /* (SPI_0_OLED_FLASH_UART_WAKE_ENABLE_CONST) */
N
N
N/***************************************
N*         UART API Constants
N***************************************/
N
N/* UART RX and TX position to be used in SPI_0_OLED_FLASH_SetPins() */
N#define SPI_0_OLED_FLASH_UART_RX_PIN_ENABLE    (SPI_0_OLED_FLASH_UART_RX)
N#define SPI_0_OLED_FLASH_UART_TX_PIN_ENABLE    (SPI_0_OLED_FLASH_UART_TX)
N
N/* UART RTS and CTS position to be used in  SPI_0_OLED_FLASH_SetPins() */
N#define SPI_0_OLED_FLASH_UART_RTS_PIN_ENABLE    (0x10u)
N#define SPI_0_OLED_FLASH_UART_CTS_PIN_ENABLE    (0x20u)
N
N
N/***************************************
N* The following code is DEPRECATED and
N* must not be used.
N***************************************/
N
N/* Interrupt processing */
N#define SPI_0_OLED_FLASH_SpiUartEnableIntRx(intSourceMask)  SPI_0_OLED_FLASH_SetRxInterruptMode(intSourceMask)
N#define SPI_0_OLED_FLASH_SpiUartEnableIntTx(intSourceMask)  SPI_0_OLED_FLASH_SetTxInterruptMode(intSourceMask)
Nuint32  SPI_0_OLED_FLASH_SpiUartDisableIntRx(void);
Nuint32  SPI_0_OLED_FLASH_SpiUartDisableIntTx(void);
N
N
N#endif /* (CY_SCB_SPI_UART_PVT_SPI_0_OLED_FLASH_H) */
N
N
N/* [] END OF FILE */
L 43 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_PVT.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_PVT.h" 1
N/***************************************************************************//**
N* \file .h
N* \version 4.0
N*
N* \brief
N*  This private file provides constants and parameter values for the
N*  SCB Component.
N*  Please do not use this file or its content in your project.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation. All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_PVT_SPI_0_OLED_FLASH_H)
X#if !0L
N#define CY_SCB_PVT_SPI_0_OLED_FLASH_H
N
N#include "SPI_0_OLED_FLASH.h"
N
N
N/***************************************
N*     Private Function Prototypes
N***************************************/
N
N/* APIs to service INTR_I2C_EC register */
N#define SPI_0_OLED_FLASH_SetI2CExtClkInterruptMode(interruptMask) SPI_0_OLED_FLASH_WRITE_INTR_I2C_EC_MASK(interruptMask)
N#define SPI_0_OLED_FLASH_ClearI2CExtClkInterruptSource(interruptMask) SPI_0_OLED_FLASH_CLEAR_INTR_I2C_EC(interruptMask)
N#define SPI_0_OLED_FLASH_GetI2CExtClkInterruptSource()                (SPI_0_OLED_FLASH_INTR_I2C_EC_REG)
N#define SPI_0_OLED_FLASH_GetI2CExtClkInterruptMode()                  (SPI_0_OLED_FLASH_INTR_I2C_EC_MASK_REG)
N#define SPI_0_OLED_FLASH_GetI2CExtClkInterruptSourceMasked()          (SPI_0_OLED_FLASH_INTR_I2C_EC_MASKED_REG)
N
N#if (!SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    /* APIs to service INTR_SPI_EC register */
N    #define SPI_0_OLED_FLASH_SetSpiExtClkInterruptMode(interruptMask) \
N                                                                SPI_0_OLED_FLASH_WRITE_INTR_SPI_EC_MASK(interruptMask)
X    #define SPI_0_OLED_FLASH_SetSpiExtClkInterruptMode(interruptMask)                                                                 SPI_0_OLED_FLASH_WRITE_INTR_SPI_EC_MASK(interruptMask)
N    #define SPI_0_OLED_FLASH_ClearSpiExtClkInterruptSource(interruptMask) \
N                                                                SPI_0_OLED_FLASH_CLEAR_INTR_SPI_EC(interruptMask)
X    #define SPI_0_OLED_FLASH_ClearSpiExtClkInterruptSource(interruptMask)                                                                 SPI_0_OLED_FLASH_CLEAR_INTR_SPI_EC(interruptMask)
N    #define SPI_0_OLED_FLASH_GetExtSpiClkInterruptSource()                 (SPI_0_OLED_FLASH_INTR_SPI_EC_REG)
N    #define SPI_0_OLED_FLASH_GetExtSpiClkInterruptMode()                   (SPI_0_OLED_FLASH_INTR_SPI_EC_MASK_REG)
N    #define SPI_0_OLED_FLASH_GetExtSpiClkInterruptSourceMasked()           (SPI_0_OLED_FLASH_INTR_SPI_EC_MASKED_REG)
N#endif /* (!SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N
N#if(SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (2u)))
S    extern void SPI_0_OLED_FLASH_SetPins(uint32 mode, uint32 subMode, uint32 uartEnableMask);
N#endif /* (SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N
N/***************************************
N*     Vars with External Linkage
N***************************************/
N
N#if (SPI_0_OLED_FLASH_SCB_IRQ_INTERNAL)
X#if ((0u == (1u)))
S#if !defined (CY_REMOVE_SPI_0_OLED_FLASH_CUSTOM_INTR_HANDLER)
S    extern cyisraddress SPI_0_OLED_FLASH_customIntrHandler;
S#endif /* !defined (CY_REMOVE_SPI_0_OLED_FLASH_CUSTOM_INTR_HANDLER) */
N#endif /* (SPI_0_OLED_FLASH_SCB_IRQ_INTERNAL) */
N
Nextern SPI_0_OLED_FLASH_BACKUP_STRUCT SPI_0_OLED_FLASH_backup;
N
N#if(SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (2u)))
S    /* Common configuration variables */
S    extern uint8 SPI_0_OLED_FLASH_scbMode;
S    extern uint8 SPI_0_OLED_FLASH_scbEnableWake;
S    extern uint8 SPI_0_OLED_FLASH_scbEnableIntr;
S
S    /* I2C configuration variables */
S    extern uint8 SPI_0_OLED_FLASH_mode;
S    extern uint8 SPI_0_OLED_FLASH_acceptAddr;
S
S    /* SPI/UART configuration variables */
S    extern volatile uint8 * SPI_0_OLED_FLASH_rxBuffer;
S    extern uint8   SPI_0_OLED_FLASH_rxDataBits;
S    extern uint32  SPI_0_OLED_FLASH_rxBufferSize;
S
S    extern volatile uint8 * SPI_0_OLED_FLASH_txBuffer;
S    extern uint8   SPI_0_OLED_FLASH_txDataBits;
S    extern uint32  SPI_0_OLED_FLASH_txBufferSize;
S
S    /* EZI2C configuration variables */
S    extern uint8 SPI_0_OLED_FLASH_numberOfAddr;
S    extern uint8 SPI_0_OLED_FLASH_subAddrSize;
N#endif /* (SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N#if (! (SPI_0_OLED_FLASH_SCB_MODE_I2C_CONST_CFG || \
N        SPI_0_OLED_FLASH_SCB_MODE_EZI2C_CONST_CFG))
X#if (! (((0x01u) == (2u)) ||         ((0x08u) == (2u))))
N    extern uint16 SPI_0_OLED_FLASH_IntrTxMask;
N#endif /* (! (SPI_0_OLED_FLASH_SCB_MODE_I2C_CONST_CFG || \
N              SPI_0_OLED_FLASH_SCB_MODE_EZI2C_CONST_CFG)) */
X#endif  
N
N
N/***************************************
N*        Conditional Macro
N****************************************/
N
N#if(SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (2u)))
S    /* Defines run time operation mode */
S    #define SPI_0_OLED_FLASH_SCB_MODE_I2C_RUNTM_CFG     (SPI_0_OLED_FLASH_SCB_MODE_I2C      == SPI_0_OLED_FLASH_scbMode)
S    #define SPI_0_OLED_FLASH_SCB_MODE_SPI_RUNTM_CFG     (SPI_0_OLED_FLASH_SCB_MODE_SPI      == SPI_0_OLED_FLASH_scbMode)
S    #define SPI_0_OLED_FLASH_SCB_MODE_UART_RUNTM_CFG    (SPI_0_OLED_FLASH_SCB_MODE_UART     == SPI_0_OLED_FLASH_scbMode)
S    #define SPI_0_OLED_FLASH_SCB_MODE_EZI2C_RUNTM_CFG   (SPI_0_OLED_FLASH_SCB_MODE_EZI2C    == SPI_0_OLED_FLASH_scbMode)
S    #define SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_RUNTM_CFG \
S                                                        (SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG == SPI_0_OLED_FLASH_scbMode)
X    #define SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_RUNTM_CFG                                                         (SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG == SPI_0_OLED_FLASH_scbMode)
S
S    /* Defines wakeup enable */
S    #define SPI_0_OLED_FLASH_SCB_WAKE_ENABLE_CHECK       (0u != SPI_0_OLED_FLASH_scbEnableWake)
N#endif /* (SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N/* Defines maximum number of SCB pins */
N#if (!SPI_0_OLED_FLASH_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_0_OLED_FLASH_SCB_PINS_NUMBER    (7u)
N#else
S    #define SPI_0_OLED_FLASH_SCB_PINS_NUMBER    (2u)
N#endif /* (!SPI_0_OLED_FLASH_CY_SCBIP_V1) */
N
N#endif /* (CY_SCB_PVT_SPI_0_OLED_FLASH_H) */
N
N
N/* [] END OF FILE */
L 44 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_BOOT.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_BOOT.h" 1
N/***************************************************************************//**
N* \file SPI_0_OLED_FLASH_BOOT.h
N* \version 4.0
N*
N* \brief
N*  This file provides constants and parameter values of the bootloader
N*  communication APIs for the SCB Component.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2014-2017, Cypress Semiconductor Corporation. All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_BOOT_SPI_0_OLED_FLASH_H)
X#if !0L
N#define CY_SCB_BOOT_SPI_0_OLED_FLASH_H
N
N#include "SPI_0_OLED_FLASH_PVT.h"
N
N#if (SPI_0_OLED_FLASH_SCB_MODE_I2C_INC)
X#if ((0u !=((0x01u) & (2u))))
S    #include "SPI_0_OLED_FLASH_I2C.h"
N#endif /* (SPI_0_OLED_FLASH_SCB_MODE_I2C_INC) */
N
N#if (SPI_0_OLED_FLASH_SCB_MODE_EZI2C_INC)
X#if ((0u !=((0x08u) & (2u))))
S    #include "SPI_0_OLED_FLASH_EZI2C.h"
N#endif /* (SPI_0_OLED_FLASH_SCB_MODE_EZI2C_INC) */
N
N#if (SPI_0_OLED_FLASH_SCB_MODE_SPI_INC || SPI_0_OLED_FLASH_SCB_MODE_UART_INC)
X#if ((0u !=((0x02u) & (2u))) || (0u !=((0x04u) & (2u))))
N    #include "SPI_0_OLED_FLASH_SPI_UART.h"
N#endif /* (SPI_0_OLED_FLASH_SCB_MODE_SPI_INC || SPI_0_OLED_FLASH_SCB_MODE_UART_INC) */
N
N
N/***************************************
N*  Conditional Compilation Parameters
N****************************************/
N
N/* Bootloader communication interface enable */
N#define SPI_0_OLED_FLASH_BTLDR_COMM_ENABLED ((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_SPI_0_OLED_FLASH) || \
N                                             (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface))
X#define SPI_0_OLED_FLASH_BTLDR_COMM_ENABLED ((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_SPI_0_OLED_FLASH) ||                                              (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface))
N
N/* Enable I2C bootloader communication */
N#if (SPI_0_OLED_FLASH_SCB_MODE_I2C_INC)
X#if ((0u !=((0x01u) & (2u))))
S    #define SPI_0_OLED_FLASH_I2C_BTLDR_COMM_ENABLED     (SPI_0_OLED_FLASH_BTLDR_COMM_ENABLED && \
S                                                            (SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG || \
S                                                             SPI_0_OLED_FLASH_I2C_SLAVE_CONST))
X    #define SPI_0_OLED_FLASH_I2C_BTLDR_COMM_ENABLED     (SPI_0_OLED_FLASH_BTLDR_COMM_ENABLED &&                                                             (SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG ||                                                              SPI_0_OLED_FLASH_I2C_SLAVE_CONST))
N#else
N     #define SPI_0_OLED_FLASH_I2C_BTLDR_COMM_ENABLED    (0u)
N#endif /* (SPI_0_OLED_FLASH_SCB_MODE_I2C_INC) */
N
N/* EZI2C does not support bootloader communication. Provide empty APIs */
N#if (SPI_0_OLED_FLASH_SCB_MODE_EZI2C_INC)
X#if ((0u !=((0x08u) & (2u))))
S    #define SPI_0_OLED_FLASH_EZI2C_BTLDR_COMM_ENABLED   (SPI_0_OLED_FLASH_BTLDR_COMM_ENABLED && \
S                                                         SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG)
X    #define SPI_0_OLED_FLASH_EZI2C_BTLDR_COMM_ENABLED   (SPI_0_OLED_FLASH_BTLDR_COMM_ENABLED &&                                                          SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG)
N#else
N    #define SPI_0_OLED_FLASH_EZI2C_BTLDR_COMM_ENABLED   (0u)
N#endif /* (SPI_0_OLED_FLASH_EZI2C_BTLDR_COMM_ENABLED) */
N
N/* Enable SPI bootloader communication */
N#if (SPI_0_OLED_FLASH_SCB_MODE_SPI_INC)
X#if ((0u !=((0x02u) & (2u))))
N    #define SPI_0_OLED_FLASH_SPI_BTLDR_COMM_ENABLED     (SPI_0_OLED_FLASH_BTLDR_COMM_ENABLED && \
N                                                            (SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG || \
N                                                             SPI_0_OLED_FLASH_SPI_SLAVE_CONST))
X    #define SPI_0_OLED_FLASH_SPI_BTLDR_COMM_ENABLED     (SPI_0_OLED_FLASH_BTLDR_COMM_ENABLED &&                                                             (SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG ||                                                              SPI_0_OLED_FLASH_SPI_SLAVE_CONST))
N#else
S        #define SPI_0_OLED_FLASH_SPI_BTLDR_COMM_ENABLED (0u)
N#endif /* (SPI_0_OLED_FLASH_SPI_BTLDR_COMM_ENABLED) */
N
N/* Enable UART bootloader communication */
N#if (SPI_0_OLED_FLASH_SCB_MODE_UART_INC)
X#if ((0u !=((0x04u) & (2u))))
S       #define SPI_0_OLED_FLASH_UART_BTLDR_COMM_ENABLED    (SPI_0_OLED_FLASH_BTLDR_COMM_ENABLED && \
S                                                            (SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG || \
S                                                             (SPI_0_OLED_FLASH_UART_RX_DIRECTION && \
S                                                              SPI_0_OLED_FLASH_UART_TX_DIRECTION)))
X       #define SPI_0_OLED_FLASH_UART_BTLDR_COMM_ENABLED    (SPI_0_OLED_FLASH_BTLDR_COMM_ENABLED &&                                                             (SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG ||                                                              (SPI_0_OLED_FLASH_UART_RX_DIRECTION &&                                                               SPI_0_OLED_FLASH_UART_TX_DIRECTION)))
N#else
N     #define SPI_0_OLED_FLASH_UART_BTLDR_COMM_ENABLED   (0u)
N#endif /* (SPI_0_OLED_FLASH_UART_BTLDR_COMM_ENABLED) */
N
N/* Enable bootloader communication */
N#define SPI_0_OLED_FLASH_BTLDR_COMM_MODE_ENABLED    (SPI_0_OLED_FLASH_I2C_BTLDR_COMM_ENABLED   || \
N                                                     SPI_0_OLED_FLASH_SPI_BTLDR_COMM_ENABLED   || \
N                                                     SPI_0_OLED_FLASH_EZI2C_BTLDR_COMM_ENABLED || \
N                                                     SPI_0_OLED_FLASH_UART_BTLDR_COMM_ENABLED)
X#define SPI_0_OLED_FLASH_BTLDR_COMM_MODE_ENABLED    (SPI_0_OLED_FLASH_I2C_BTLDR_COMM_ENABLED   ||                                                      SPI_0_OLED_FLASH_SPI_BTLDR_COMM_ENABLED   ||                                                      SPI_0_OLED_FLASH_EZI2C_BTLDR_COMM_ENABLED ||                                                      SPI_0_OLED_FLASH_UART_BTLDR_COMM_ENABLED)
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (SPI_0_OLED_FLASH_I2C_BTLDR_COMM_ENABLED)
X#if 0L && ((0u))
S    /* I2C Bootloader physical layer functions */
S    void SPI_0_OLED_FLASH_I2CCyBtldrCommStart(void);
S    void SPI_0_OLED_FLASH_I2CCyBtldrCommStop (void);
S    void SPI_0_OLED_FLASH_I2CCyBtldrCommReset(void);
S    cystatus SPI_0_OLED_FLASH_I2CCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus SPI_0_OLED_FLASH_I2CCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    /* Map I2C specific bootloader communication APIs to SCB specific APIs */
S    #if (SPI_0_OLED_FLASH_SCB_MODE_I2C_CONST_CFG)
S        #define SPI_0_OLED_FLASH_CyBtldrCommStart   SPI_0_OLED_FLASH_I2CCyBtldrCommStart
S        #define SPI_0_OLED_FLASH_CyBtldrCommStop    SPI_0_OLED_FLASH_I2CCyBtldrCommStop
S        #define SPI_0_OLED_FLASH_CyBtldrCommReset   SPI_0_OLED_FLASH_I2CCyBtldrCommReset
S        #define SPI_0_OLED_FLASH_CyBtldrCommRead    SPI_0_OLED_FLASH_I2CCyBtldrCommRead
S        #define SPI_0_OLED_FLASH_CyBtldrCommWrite   SPI_0_OLED_FLASH_I2CCyBtldrCommWrite
S    #endif /* (SPI_0_OLED_FLASH_SCB_MODE_I2C_CONST_CFG) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (SPI_0_OLED_FLASH_I2C_BTLDR_COMM_ENABLED) */
N
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (SPI_0_OLED_FLASH_EZI2C_BTLDR_COMM_ENABLED)
X#if 0L && ((0u))
S    /* Bootloader physical layer functions */
S    void SPI_0_OLED_FLASH_EzI2CCyBtldrCommStart(void);
S    void SPI_0_OLED_FLASH_EzI2CCyBtldrCommStop (void);
S    void SPI_0_OLED_FLASH_EzI2CCyBtldrCommReset(void);
S    cystatus SPI_0_OLED_FLASH_EzI2CCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus SPI_0_OLED_FLASH_EzI2CCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    /* Map EZI2C specific bootloader communication APIs to SCB specific APIs */
S    #if (SPI_0_OLED_FLASH_SCB_MODE_EZI2C_CONST_CFG)
S        #define SPI_0_OLED_FLASH_CyBtldrCommStart   SPI_0_OLED_FLASH_EzI2CCyBtldrCommStart
S        #define SPI_0_OLED_FLASH_CyBtldrCommStop    SPI_0_OLED_FLASH_EzI2CCyBtldrCommStop
S        #define SPI_0_OLED_FLASH_CyBtldrCommReset   SPI_0_OLED_FLASH_EzI2CCyBtldrCommReset
S        #define SPI_0_OLED_FLASH_CyBtldrCommRead    SPI_0_OLED_FLASH_EzI2CCyBtldrCommRead
S        #define SPI_0_OLED_FLASH_CyBtldrCommWrite   SPI_0_OLED_FLASH_EzI2CCyBtldrCommWrite
S    #endif /* (SPI_0_OLED_FLASH_SCB_MODE_EZI2C_CONST_CFG) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (SPI_0_OLED_FLASH_EZI2C_BTLDR_COMM_ENABLED) */
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (SPI_0_OLED_FLASH_SPI_BTLDR_COMM_ENABLED)
X#if 0L && ((((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_SPI_0_OLED_FLASH) || (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface)) && (((0xFFu) == (2u)) || ((1u) == (0u)))))
S    /* SPI Bootloader physical layer functions */
S    void SPI_0_OLED_FLASH_SpiCyBtldrCommStart(void);
S    void SPI_0_OLED_FLASH_SpiCyBtldrCommStop (void);
S    void SPI_0_OLED_FLASH_SpiCyBtldrCommReset(void);
S    cystatus SPI_0_OLED_FLASH_SpiCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus SPI_0_OLED_FLASH_SpiCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    /* Map SPI specific bootloader communication APIs to SCB specific APIs */
S    #if (SPI_0_OLED_FLASH_SCB_MODE_SPI_CONST_CFG)
S        #define SPI_0_OLED_FLASH_CyBtldrCommStart   SPI_0_OLED_FLASH_SpiCyBtldrCommStart
S        #define SPI_0_OLED_FLASH_CyBtldrCommStop    SPI_0_OLED_FLASH_SpiCyBtldrCommStop
S        #define SPI_0_OLED_FLASH_CyBtldrCommReset   SPI_0_OLED_FLASH_SpiCyBtldrCommReset
S        #define SPI_0_OLED_FLASH_CyBtldrCommRead    SPI_0_OLED_FLASH_SpiCyBtldrCommRead
S        #define SPI_0_OLED_FLASH_CyBtldrCommWrite   SPI_0_OLED_FLASH_SpiCyBtldrCommWrite
S    #endif /* (SPI_0_OLED_FLASH_SCB_MODE_SPI_CONST_CFG) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (SPI_0_OLED_FLASH_SPI_BTLDR_COMM_ENABLED) */
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (SPI_0_OLED_FLASH_UART_BTLDR_COMM_ENABLED)
X#if 0L && ((0u))
S    /* UART Bootloader physical layer functions */
S    void SPI_0_OLED_FLASH_UartCyBtldrCommStart(void);
S    void SPI_0_OLED_FLASH_UartCyBtldrCommStop (void);
S    void SPI_0_OLED_FLASH_UartCyBtldrCommReset(void);
S    cystatus SPI_0_OLED_FLASH_UartCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus SPI_0_OLED_FLASH_UartCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    /* Map UART specific bootloader communication APIs to SCB specific APIs */
S    #if (SPI_0_OLED_FLASH_SCB_MODE_UART_CONST_CFG)
S        #define SPI_0_OLED_FLASH_CyBtldrCommStart   SPI_0_OLED_FLASH_UartCyBtldrCommStart
S        #define SPI_0_OLED_FLASH_CyBtldrCommStop    SPI_0_OLED_FLASH_UartCyBtldrCommStop
S        #define SPI_0_OLED_FLASH_CyBtldrCommReset   SPI_0_OLED_FLASH_UartCyBtldrCommReset
S        #define SPI_0_OLED_FLASH_CyBtldrCommRead    SPI_0_OLED_FLASH_UartCyBtldrCommRead
S        #define SPI_0_OLED_FLASH_CyBtldrCommWrite   SPI_0_OLED_FLASH_UartCyBtldrCommWrite
S    #endif /* (SPI_0_OLED_FLASH_SCB_MODE_UART_CONST_CFG) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (SPI_0_OLED_FLASH_UART_BTLDR_COMM_ENABLED) */
N
N/**
N* \addtogroup group_bootloader
N* @{
N*/
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (SPI_0_OLED_FLASH_BTLDR_COMM_ENABLED)
X#if 0L && (((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_SPI_0_OLED_FLASH) || (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface)))
S    #if (SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG)
S        /* Bootloader physical layer functions */
S        void SPI_0_OLED_FLASH_CyBtldrCommStart(void);
S        void SPI_0_OLED_FLASH_CyBtldrCommStop (void);
S        void SPI_0_OLED_FLASH_CyBtldrCommReset(void);
S        cystatus SPI_0_OLED_FLASH_CyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S        cystatus SPI_0_OLED_FLASH_CyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    #endif /* (SPI_0_OLED_FLASH_SCB_MODE_UNCONFIG_CONST_CFG) */
S
S    /* Map SCB specific bootloader communication APIs to common APIs */
S    #if (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_SPI_0_OLED_FLASH)
S        #define CyBtldrCommStart    SPI_0_OLED_FLASH_CyBtldrCommStart
S        #define CyBtldrCommStop     SPI_0_OLED_FLASH_CyBtldrCommStop
S        #define CyBtldrCommReset    SPI_0_OLED_FLASH_CyBtldrCommReset
S        #define CyBtldrCommWrite    SPI_0_OLED_FLASH_CyBtldrCommWrite
S        #define CyBtldrCommRead     SPI_0_OLED_FLASH_CyBtldrCommRead
S    #endif /* (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_SPI_0_OLED_FLASH) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (SPI_0_OLED_FLASH_BTLDR_COMM_ENABLED) */
N
N/** @} group_bootloader */
N
N/***************************************
N*           API Constants
N***************************************/
N
N/* Timeout unit in milliseconds */
N#define SPI_0_OLED_FLASH_WAIT_1_MS  (1u)
N
N/* Return number of bytes to copy into bootloader buffer */
N#define SPI_0_OLED_FLASH_BYTES_TO_COPY(actBufSize, bufSize) \
N                            ( ((uint32)(actBufSize) < (uint32)(bufSize)) ? \
N                                ((uint32) (actBufSize)) : ((uint32) (bufSize)) )
X#define SPI_0_OLED_FLASH_BYTES_TO_COPY(actBufSize, bufSize)                             ( ((uint32)(actBufSize) < (uint32)(bufSize)) ?                                 ((uint32) (actBufSize)) : ((uint32) (bufSize)) )
N
N/* Size of Read/Write buffers for I2C bootloader  */
N#define SPI_0_OLED_FLASH_I2C_BTLDR_SIZEOF_READ_BUFFER   (64u)
N#define SPI_0_OLED_FLASH_I2C_BTLDR_SIZEOF_WRITE_BUFFER  (64u)
N
N/* Byte to byte time interval: calculated basing on current component
N* data rate configuration, can be defined in project if required.
N*/
N#ifndef SPI_0_OLED_FLASH_SPI_BYTE_TO_BYTE
N    #define SPI_0_OLED_FLASH_SPI_BYTE_TO_BYTE   (2u)
N#endif
N
N/* Byte to byte time interval: calculated basing on current component
N* baud rate configuration, can be defined in the project if required.
N*/
N#ifndef SPI_0_OLED_FLASH_UART_BYTE_TO_BYTE
N    #define SPI_0_OLED_FLASH_UART_BYTE_TO_BYTE  (2500u)
N#endif /* SPI_0_OLED_FLASH_UART_BYTE_TO_BYTE */
N
N#endif /* (CY_SCB_BOOT_SPI_0_OLED_FLASH_H) */
N
N
N/* [] END OF FILE */
L 45 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD.h" 1
N/***************************************************************************//**
N* \file SPI_1_CARD.h
N* \version 4.0
N*
N* \brief
N*  This file provides constants and parameter values for the SCB Component.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_SPI_1_CARD_H)
X#if !0L
N#define CY_SCB_SPI_1_CARD_H
N
N#include <cydevice_trm.h>
N#include <cyfitter.h>
N#include <cytypes.h>
N#include <CyLib.h>
N
N/* SCB IP block v0 is available in PSoC 4100/PSoC 4200 */
N#define SPI_1_CARD_CY_SCBIP_V0    (CYIPBLOCK_m0s8scb_VERSION == 0u)
N/* SCB IP block v1 is available in PSoC 4000 */
N#define SPI_1_CARD_CY_SCBIP_V1    (CYIPBLOCK_m0s8scb_VERSION == 1u)
N/* SCB IP block v2 is available in all other devices */
N#define SPI_1_CARD_CY_SCBIP_V2    (CYIPBLOCK_m0s8scb_VERSION >= 2u)
N
N/** Component version major.minor */
N#define SPI_1_CARD_COMP_VERSION_MAJOR    (4)
N#define SPI_1_CARD_COMP_VERSION_MINOR    (0)
N    
N#define SPI_1_CARD_SCB_MODE           (2u)
N
N/* SCB modes enum */
N#define SPI_1_CARD_SCB_MODE_I2C       (0x01u)
N#define SPI_1_CARD_SCB_MODE_SPI       (0x02u)
N#define SPI_1_CARD_SCB_MODE_UART      (0x04u)
N#define SPI_1_CARD_SCB_MODE_EZI2C     (0x08u)
N#define SPI_1_CARD_SCB_MODE_UNCONFIG  (0xFFu)
N
N/* Condition compilation depends on operation mode: Unconfigured implies apply to all modes */
N#define SPI_1_CARD_SCB_MODE_I2C_CONST_CFG       (SPI_1_CARD_SCB_MODE_I2C       == SPI_1_CARD_SCB_MODE)
N#define SPI_1_CARD_SCB_MODE_SPI_CONST_CFG       (SPI_1_CARD_SCB_MODE_SPI       == SPI_1_CARD_SCB_MODE)
N#define SPI_1_CARD_SCB_MODE_UART_CONST_CFG      (SPI_1_CARD_SCB_MODE_UART      == SPI_1_CARD_SCB_MODE)
N#define SPI_1_CARD_SCB_MODE_EZI2C_CONST_CFG     (SPI_1_CARD_SCB_MODE_EZI2C     == SPI_1_CARD_SCB_MODE)
N#define SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG  (SPI_1_CARD_SCB_MODE_UNCONFIG  == SPI_1_CARD_SCB_MODE)
N
N/* Condition compilation for includes */
N#define SPI_1_CARD_SCB_MODE_I2C_INC      (0u !=(SPI_1_CARD_SCB_MODE_I2C   & SPI_1_CARD_SCB_MODE))
N#define SPI_1_CARD_SCB_MODE_EZI2C_INC    (0u !=(SPI_1_CARD_SCB_MODE_EZI2C & SPI_1_CARD_SCB_MODE))
N#if (!SPI_1_CARD_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_1_CARD_SCB_MODE_SPI_INC  (0u !=(SPI_1_CARD_SCB_MODE_SPI   & SPI_1_CARD_SCB_MODE))
N    #define SPI_1_CARD_SCB_MODE_UART_INC (0u !=(SPI_1_CARD_SCB_MODE_UART  & SPI_1_CARD_SCB_MODE))
N#else
S    #define SPI_1_CARD_SCB_MODE_SPI_INC  (0u)
S    #define SPI_1_CARD_SCB_MODE_UART_INC (0u)
N#endif /* (!SPI_1_CARD_CY_SCBIP_V1) */
N
N/* Interrupts remove options */
N#define SPI_1_CARD_REMOVE_SCB_IRQ             (1u)
N#define SPI_1_CARD_SCB_IRQ_INTERNAL           (0u == SPI_1_CARD_REMOVE_SCB_IRQ)
N
N#define SPI_1_CARD_REMOVE_UART_RX_WAKEUP_IRQ  (1u)
N#define SPI_1_CARD_UART_RX_WAKEUP_IRQ         (0u == SPI_1_CARD_REMOVE_UART_RX_WAKEUP_IRQ)
N
N/* SCB interrupt enum */
N#define SPI_1_CARD_SCB_INTR_MODE_NONE     (0u)
N#define SPI_1_CARD_SCB_INTR_MODE_INTERNAL (1u)
N#define SPI_1_CARD_SCB_INTR_MODE_EXTERNAL (2u)
N
N/* Internal clock remove option */
N#define SPI_1_CARD_REMOVE_SCB_CLK     (0u)
N#define SPI_1_CARD_SCB_CLK_INTERNAL   (0u == SPI_1_CARD_REMOVE_SCB_CLK)
N
N
N/***************************************
N*       Includes
N****************************************/
N
N#include "SPI_1_CARD_PINS.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_PINS.h" 1
N/***************************************************************************//**
N* \file SPI_1_CARD_PINS.h
N* \version 4.0
N*
N* \brief
N*  This file provides constants and parameter values for the pin components
N*  buried into SCB Component.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_PINS_SPI_1_CARD_H)
X#if !0L
N#define CY_SCB_PINS_SPI_1_CARD_H
N
N#include "cydevice_trm.h"
N#include "cyfitter.h"
N#include "cytypes.h"
N
N
N/***************************************
N*   Conditional Compilation Parameters
N****************************************/
N
N/* Unconfigured pins */
N#define SPI_1_CARD_REMOVE_RX_WAKE_SCL_MOSI_PIN  (1u)
N#define SPI_1_CARD_REMOVE_RX_SCL_MOSI_PIN      (1u)
N#define SPI_1_CARD_REMOVE_TX_SDA_MISO_PIN      (1u)
N#define SPI_1_CARD_REMOVE_CTS_SCLK_PIN      (1u)
N#define SPI_1_CARD_REMOVE_RTS_SS0_PIN      (1u)
N#define SPI_1_CARD_REMOVE_SS1_PIN                 (1u)
N#define SPI_1_CARD_REMOVE_SS2_PIN                 (1u)
N#define SPI_1_CARD_REMOVE_SS3_PIN                 (1u)
N
N/* Mode defined pins */
N#define SPI_1_CARD_REMOVE_I2C_PINS                (1u)
N#define SPI_1_CARD_REMOVE_SPI_MASTER_PINS         (0u)
N#define SPI_1_CARD_REMOVE_SPI_MASTER_SCLK_PIN     (0u)
N#define SPI_1_CARD_REMOVE_SPI_MASTER_MOSI_PIN     (0u)
N#define SPI_1_CARD_REMOVE_SPI_MASTER_MISO_PIN     (0u)
N#define SPI_1_CARD_REMOVE_SPI_MASTER_SS0_PIN      (0u)
N#define SPI_1_CARD_REMOVE_SPI_MASTER_SS1_PIN      (1u)
N#define SPI_1_CARD_REMOVE_SPI_MASTER_SS2_PIN      (1u)
N#define SPI_1_CARD_REMOVE_SPI_MASTER_SS3_PIN      (1u)
N#define SPI_1_CARD_REMOVE_SPI_SLAVE_PINS          (1u)
N#define SPI_1_CARD_REMOVE_SPI_SLAVE_MOSI_PIN      (1u)
N#define SPI_1_CARD_REMOVE_SPI_SLAVE_MISO_PIN      (1u)
N#define SPI_1_CARD_REMOVE_UART_TX_PIN             (1u)
N#define SPI_1_CARD_REMOVE_UART_RX_TX_PIN          (1u)
N#define SPI_1_CARD_REMOVE_UART_RX_PIN             (1u)
N#define SPI_1_CARD_REMOVE_UART_RX_WAKE_PIN        (1u)
N#define SPI_1_CARD_REMOVE_UART_RTS_PIN            (1u)
N#define SPI_1_CARD_REMOVE_UART_CTS_PIN            (1u)
N
N/* Unconfigured pins */
N#define SPI_1_CARD_RX_WAKE_SCL_MOSI_PIN (0u == SPI_1_CARD_REMOVE_RX_WAKE_SCL_MOSI_PIN)
N#define SPI_1_CARD_RX_SCL_MOSI_PIN     (0u == SPI_1_CARD_REMOVE_RX_SCL_MOSI_PIN)
N#define SPI_1_CARD_TX_SDA_MISO_PIN     (0u == SPI_1_CARD_REMOVE_TX_SDA_MISO_PIN)
N#define SPI_1_CARD_CTS_SCLK_PIN     (0u == SPI_1_CARD_REMOVE_CTS_SCLK_PIN)
N#define SPI_1_CARD_RTS_SS0_PIN     (0u == SPI_1_CARD_REMOVE_RTS_SS0_PIN)
N#define SPI_1_CARD_SS1_PIN                (0u == SPI_1_CARD_REMOVE_SS1_PIN)
N#define SPI_1_CARD_SS2_PIN                (0u == SPI_1_CARD_REMOVE_SS2_PIN)
N#define SPI_1_CARD_SS3_PIN                (0u == SPI_1_CARD_REMOVE_SS3_PIN)
N
N/* Mode defined pins */
N#define SPI_1_CARD_I2C_PINS               (0u == SPI_1_CARD_REMOVE_I2C_PINS)
N#define SPI_1_CARD_SPI_MASTER_PINS        (0u == SPI_1_CARD_REMOVE_SPI_MASTER_PINS)
N#define SPI_1_CARD_SPI_MASTER_SCLK_PIN    (0u == SPI_1_CARD_REMOVE_SPI_MASTER_SCLK_PIN)
N#define SPI_1_CARD_SPI_MASTER_MOSI_PIN    (0u == SPI_1_CARD_REMOVE_SPI_MASTER_MOSI_PIN)
N#define SPI_1_CARD_SPI_MASTER_MISO_PIN    (0u == SPI_1_CARD_REMOVE_SPI_MASTER_MISO_PIN)
N#define SPI_1_CARD_SPI_MASTER_SS0_PIN     (0u == SPI_1_CARD_REMOVE_SPI_MASTER_SS0_PIN)
N#define SPI_1_CARD_SPI_MASTER_SS1_PIN     (0u == SPI_1_CARD_REMOVE_SPI_MASTER_SS1_PIN)
N#define SPI_1_CARD_SPI_MASTER_SS2_PIN     (0u == SPI_1_CARD_REMOVE_SPI_MASTER_SS2_PIN)
N#define SPI_1_CARD_SPI_MASTER_SS3_PIN     (0u == SPI_1_CARD_REMOVE_SPI_MASTER_SS3_PIN)
N#define SPI_1_CARD_SPI_SLAVE_PINS         (0u == SPI_1_CARD_REMOVE_SPI_SLAVE_PINS)
N#define SPI_1_CARD_SPI_SLAVE_MOSI_PIN     (0u == SPI_1_CARD_REMOVE_SPI_SLAVE_MOSI_PIN)
N#define SPI_1_CARD_SPI_SLAVE_MISO_PIN     (0u == SPI_1_CARD_REMOVE_SPI_SLAVE_MISO_PIN)
N#define SPI_1_CARD_UART_TX_PIN            (0u == SPI_1_CARD_REMOVE_UART_TX_PIN)
N#define SPI_1_CARD_UART_RX_TX_PIN         (0u == SPI_1_CARD_REMOVE_UART_RX_TX_PIN)
N#define SPI_1_CARD_UART_RX_PIN            (0u == SPI_1_CARD_REMOVE_UART_RX_PIN)
N#define SPI_1_CARD_UART_RX_WAKE_PIN       (0u == SPI_1_CARD_REMOVE_UART_RX_WAKE_PIN)
N#define SPI_1_CARD_UART_RTS_PIN           (0u == SPI_1_CARD_REMOVE_UART_RTS_PIN)
N#define SPI_1_CARD_UART_CTS_PIN           (0u == SPI_1_CARD_REMOVE_UART_CTS_PIN)
N
N
N/***************************************
N*             Includes
N****************************************/
N
N#if (SPI_1_CARD_RX_WAKE_SCL_MOSI_PIN)
X#if ((0u == (1u)))
S    #include "SPI_1_CARD_uart_rx_wake_i2c_scl_spi_mosi.h"
N#endif /* (SPI_1_CARD_RX_SCL_MOSI) */
N
N#if (SPI_1_CARD_RX_SCL_MOSI_PIN)
X#if ((0u == (1u)))
S    #include "SPI_1_CARD_uart_rx_i2c_scl_spi_mosi.h"
N#endif /* (SPI_1_CARD_RX_SCL_MOSI) */
N
N#if (SPI_1_CARD_TX_SDA_MISO_PIN)
X#if ((0u == (1u)))
S    #include "SPI_1_CARD_uart_tx_i2c_sda_spi_miso.h"
N#endif /* (SPI_1_CARD_TX_SDA_MISO) */
N
N#if (SPI_1_CARD_CTS_SCLK_PIN)
X#if ((0u == (1u)))
S    #include "SPI_1_CARD_uart_cts_spi_sclk.h"
N#endif /* (SPI_1_CARD_CTS_SCLK) */
N
N#if (SPI_1_CARD_RTS_SS0_PIN)
X#if ((0u == (1u)))
S    #include "SPI_1_CARD_uart_rts_spi_ss0.h"
N#endif /* (SPI_1_CARD_RTS_SS0_PIN) */
N
N#if (SPI_1_CARD_SS1_PIN)
X#if ((0u == (1u)))
S    #include "SPI_1_CARD_spi_ss1.h"
N#endif /* (SPI_1_CARD_SS1_PIN) */
N
N#if (SPI_1_CARD_SS2_PIN)
X#if ((0u == (1u)))
S    #include "SPI_1_CARD_spi_ss2.h"
N#endif /* (SPI_1_CARD_SS2_PIN) */
N
N#if (SPI_1_CARD_SS3_PIN)
X#if ((0u == (1u)))
S    #include "SPI_1_CARD_spi_ss3.h"
N#endif /* (SPI_1_CARD_SS3_PIN) */
N
N#if (SPI_1_CARD_I2C_PINS)
X#if ((0u == (1u)))
S    #include "SPI_1_CARD_scl.h"
S    #include "SPI_1_CARD_sda.h"
N#endif /* (SPI_1_CARD_I2C_PINS) */
N
N#if (SPI_1_CARD_SPI_MASTER_PINS)
X#if ((0u == (0u)))
N#if (SPI_1_CARD_SPI_MASTER_SCLK_PIN)
X#if ((0u == (0u)))
N    #include "SPI_1_CARD_sclk_m.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_sclk_m.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_sclk_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_sclk_m_H) /* Pins SPI_1_CARD_sclk_m_H */
X#if !0L  
N#define CY_PINS_SPI_1_CARD_sclk_m_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "SPI_1_CARD_sclk_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_sclk_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_sclk_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_sclk_m_ALIASES_H) /* Pins SPI_1_CARD_sclk_m_ALIASES_H */
X#if !0L  
N#define CY_PINS_SPI_1_CARD_sclk_m_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define SPI_1_CARD_sclk_m_0			(SPI_1_CARD_sclk_m__0__PC)
N#define SPI_1_CARD_sclk_m_0_PS		(SPI_1_CARD_sclk_m__0__PS)
N#define SPI_1_CARD_sclk_m_0_PC		(SPI_1_CARD_sclk_m__0__PC)
N#define SPI_1_CARD_sclk_m_0_DR		(SPI_1_CARD_sclk_m__0__DR)
N#define SPI_1_CARD_sclk_m_0_SHIFT	(SPI_1_CARD_sclk_m__0__SHIFT)
N#define SPI_1_CARD_sclk_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_1_CARD_sclk_m__0__SHIFT*2u)))
N
N#define SPI_1_CARD_sclk_m_INTR_ALL	 ((uint16)(SPI_1_CARD_sclk_m_0_INTR))
N
N
N#endif /* End Pins SPI_1_CARD_sclk_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\SPI_1_CARD_sclk_m.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} SPI_1_CARD_sclk_m_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   SPI_1_CARD_sclk_m_Read(void);
Nvoid    SPI_1_CARD_sclk_m_Write(uint8 value);
Nuint8   SPI_1_CARD_sclk_m_ReadDataReg(void);
N#if defined(SPI_1_CARD_sclk_m__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    SPI_1_CARD_sclk_m_SetDriveMode(uint8 mode);
N#endif
Nvoid    SPI_1_CARD_sclk_m_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   SPI_1_CARD_sclk_m_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid SPI_1_CARD_sclk_m_Sleep(void); 
Nvoid SPI_1_CARD_sclk_m_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(SPI_1_CARD_sclk_m__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define SPI_1_CARD_sclk_m_DRIVE_MODE_BITS        (3)
N    #define SPI_1_CARD_sclk_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_1_CARD_sclk_m_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the SPI_1_CARD_sclk_m_SetDriveMode() function.
N         *  @{
N         */
N        #define SPI_1_CARD_sclk_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define SPI_1_CARD_sclk_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define SPI_1_CARD_sclk_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define SPI_1_CARD_sclk_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define SPI_1_CARD_sclk_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define SPI_1_CARD_sclk_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define SPI_1_CARD_sclk_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define SPI_1_CARD_sclk_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define SPI_1_CARD_sclk_m_MASK               SPI_1_CARD_sclk_m__MASK
N#define SPI_1_CARD_sclk_m_SHIFT              SPI_1_CARD_sclk_m__SHIFT
N#define SPI_1_CARD_sclk_m_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in SPI_1_CARD_sclk_m_SetInterruptMode() function.
N     *  @{
N     */
N        #define SPI_1_CARD_sclk_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define SPI_1_CARD_sclk_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define SPI_1_CARD_sclk_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define SPI_1_CARD_sclk_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(SPI_1_CARD_sclk_m__SIO)
X#if 0L
S    #define SPI_1_CARD_sclk_m_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(SPI_1_CARD_sclk_m__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define SPI_1_CARD_sclk_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_1_CARD_sclk_m_USBIO_DISABLE              ((uint32)(~SPI_1_CARD_sclk_m_USBIO_ENABLE))
S    #define SPI_1_CARD_sclk_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_1_CARD_sclk_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_1_CARD_sclk_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_sclk_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_1_CARD_sclk_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_1_CARD_sclk_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_sclk_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_1_CARD_sclk_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_sclk_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_1_CARD_sclk_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_1_CARD_sclk_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_1_CARD_sclk_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_sclk_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(SPI_1_CARD_sclk_m__PC)
X#if 1L
N    /* Port Configuration */
N    #define SPI_1_CARD_sclk_m_PC                 (* (reg32 *) SPI_1_CARD_sclk_m__PC)
N#endif
N/* Pin State */
N#define SPI_1_CARD_sclk_m_PS                     (* (reg32 *) SPI_1_CARD_sclk_m__PS)
N/* Data Register */
N#define SPI_1_CARD_sclk_m_DR                     (* (reg32 *) SPI_1_CARD_sclk_m__DR)
N/* Input Buffer Disable Override */
N#define SPI_1_CARD_sclk_m_INP_DIS                (* (reg32 *) SPI_1_CARD_sclk_m__PC2)
N
N/* Interrupt configuration Registers */
N#define SPI_1_CARD_sclk_m_INTCFG                 (* (reg32 *) SPI_1_CARD_sclk_m__INTCFG)
N#define SPI_1_CARD_sclk_m_INTSTAT                (* (reg32 *) SPI_1_CARD_sclk_m__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define SPI_1_CARD_sclk_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(SPI_1_CARD_sclk_m__SIO)
X#if 0L
S    #define SPI_1_CARD_sclk_m_SIO_REG            (* (reg32 *) SPI_1_CARD_sclk_m__SIO)
N#endif /* (SPI_1_CARD_sclk_m__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(SPI_1_CARD_sclk_m__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define SPI_1_CARD_sclk_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_1_CARD_sclk_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_1_CARD_sclk_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define SPI_1_CARD_sclk_m_DRIVE_MODE_SHIFT       (0x00u)
N#define SPI_1_CARD_sclk_m_DRIVE_MODE_MASK        (0x07u << SPI_1_CARD_sclk_m_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins SPI_1_CARD_sclk_m_H */
N
N
N/* [] END OF FILE */
L 136 "Generated_Source\PSoC4\SPI_1_CARD_PINS.h" 2
N#endif /* (SPI_1_CARD_SPI_MASTER_SCLK_PIN) */
N
N#if (SPI_1_CARD_SPI_MASTER_MOSI_PIN)
X#if ((0u == (0u)))
N    #include "SPI_1_CARD_mosi_m.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_mosi_m.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_mosi_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_mosi_m_H) /* Pins SPI_1_CARD_mosi_m_H */
X#if !0L  
N#define CY_PINS_SPI_1_CARD_mosi_m_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "SPI_1_CARD_mosi_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_mosi_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_mosi_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_mosi_m_ALIASES_H) /* Pins SPI_1_CARD_mosi_m_ALIASES_H */
X#if !0L  
N#define CY_PINS_SPI_1_CARD_mosi_m_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define SPI_1_CARD_mosi_m_0			(SPI_1_CARD_mosi_m__0__PC)
N#define SPI_1_CARD_mosi_m_0_PS		(SPI_1_CARD_mosi_m__0__PS)
N#define SPI_1_CARD_mosi_m_0_PC		(SPI_1_CARD_mosi_m__0__PC)
N#define SPI_1_CARD_mosi_m_0_DR		(SPI_1_CARD_mosi_m__0__DR)
N#define SPI_1_CARD_mosi_m_0_SHIFT	(SPI_1_CARD_mosi_m__0__SHIFT)
N#define SPI_1_CARD_mosi_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_1_CARD_mosi_m__0__SHIFT*2u)))
N
N#define SPI_1_CARD_mosi_m_INTR_ALL	 ((uint16)(SPI_1_CARD_mosi_m_0_INTR))
N
N
N#endif /* End Pins SPI_1_CARD_mosi_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\SPI_1_CARD_mosi_m.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} SPI_1_CARD_mosi_m_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   SPI_1_CARD_mosi_m_Read(void);
Nvoid    SPI_1_CARD_mosi_m_Write(uint8 value);
Nuint8   SPI_1_CARD_mosi_m_ReadDataReg(void);
N#if defined(SPI_1_CARD_mosi_m__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    SPI_1_CARD_mosi_m_SetDriveMode(uint8 mode);
N#endif
Nvoid    SPI_1_CARD_mosi_m_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   SPI_1_CARD_mosi_m_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid SPI_1_CARD_mosi_m_Sleep(void); 
Nvoid SPI_1_CARD_mosi_m_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(SPI_1_CARD_mosi_m__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define SPI_1_CARD_mosi_m_DRIVE_MODE_BITS        (3)
N    #define SPI_1_CARD_mosi_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_1_CARD_mosi_m_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the SPI_1_CARD_mosi_m_SetDriveMode() function.
N         *  @{
N         */
N        #define SPI_1_CARD_mosi_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define SPI_1_CARD_mosi_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define SPI_1_CARD_mosi_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define SPI_1_CARD_mosi_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define SPI_1_CARD_mosi_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define SPI_1_CARD_mosi_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define SPI_1_CARD_mosi_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define SPI_1_CARD_mosi_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define SPI_1_CARD_mosi_m_MASK               SPI_1_CARD_mosi_m__MASK
N#define SPI_1_CARD_mosi_m_SHIFT              SPI_1_CARD_mosi_m__SHIFT
N#define SPI_1_CARD_mosi_m_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in SPI_1_CARD_mosi_m_SetInterruptMode() function.
N     *  @{
N     */
N        #define SPI_1_CARD_mosi_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define SPI_1_CARD_mosi_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define SPI_1_CARD_mosi_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define SPI_1_CARD_mosi_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(SPI_1_CARD_mosi_m__SIO)
X#if 0L
S    #define SPI_1_CARD_mosi_m_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(SPI_1_CARD_mosi_m__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define SPI_1_CARD_mosi_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_1_CARD_mosi_m_USBIO_DISABLE              ((uint32)(~SPI_1_CARD_mosi_m_USBIO_ENABLE))
S    #define SPI_1_CARD_mosi_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_1_CARD_mosi_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_1_CARD_mosi_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_mosi_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_1_CARD_mosi_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_1_CARD_mosi_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_mosi_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_1_CARD_mosi_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_mosi_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_1_CARD_mosi_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_1_CARD_mosi_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_1_CARD_mosi_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_mosi_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(SPI_1_CARD_mosi_m__PC)
X#if 1L
N    /* Port Configuration */
N    #define SPI_1_CARD_mosi_m_PC                 (* (reg32 *) SPI_1_CARD_mosi_m__PC)
N#endif
N/* Pin State */
N#define SPI_1_CARD_mosi_m_PS                     (* (reg32 *) SPI_1_CARD_mosi_m__PS)
N/* Data Register */
N#define SPI_1_CARD_mosi_m_DR                     (* (reg32 *) SPI_1_CARD_mosi_m__DR)
N/* Input Buffer Disable Override */
N#define SPI_1_CARD_mosi_m_INP_DIS                (* (reg32 *) SPI_1_CARD_mosi_m__PC2)
N
N/* Interrupt configuration Registers */
N#define SPI_1_CARD_mosi_m_INTCFG                 (* (reg32 *) SPI_1_CARD_mosi_m__INTCFG)
N#define SPI_1_CARD_mosi_m_INTSTAT                (* (reg32 *) SPI_1_CARD_mosi_m__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define SPI_1_CARD_mosi_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(SPI_1_CARD_mosi_m__SIO)
X#if 0L
S    #define SPI_1_CARD_mosi_m_SIO_REG            (* (reg32 *) SPI_1_CARD_mosi_m__SIO)
N#endif /* (SPI_1_CARD_mosi_m__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(SPI_1_CARD_mosi_m__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define SPI_1_CARD_mosi_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_1_CARD_mosi_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_1_CARD_mosi_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define SPI_1_CARD_mosi_m_DRIVE_MODE_SHIFT       (0x00u)
N#define SPI_1_CARD_mosi_m_DRIVE_MODE_MASK        (0x07u << SPI_1_CARD_mosi_m_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins SPI_1_CARD_mosi_m_H */
N
N
N/* [] END OF FILE */
L 140 "Generated_Source\PSoC4\SPI_1_CARD_PINS.h" 2
N#endif /* (SPI_1_CARD_SPI_MASTER_MOSI_PIN) */
N
N#if (SPI_1_CARD_SPI_MASTER_MISO_PIN)
X#if ((0u == (0u)))
N    #include "SPI_1_CARD_miso_m.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_miso_m.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_miso_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_miso_m_H) /* Pins SPI_1_CARD_miso_m_H */
X#if !0L  
N#define CY_PINS_SPI_1_CARD_miso_m_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "SPI_1_CARD_miso_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_miso_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_miso_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_miso_m_ALIASES_H) /* Pins SPI_1_CARD_miso_m_ALIASES_H */
X#if !0L  
N#define CY_PINS_SPI_1_CARD_miso_m_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define SPI_1_CARD_miso_m_0			(SPI_1_CARD_miso_m__0__PC)
N#define SPI_1_CARD_miso_m_0_PS		(SPI_1_CARD_miso_m__0__PS)
N#define SPI_1_CARD_miso_m_0_PC		(SPI_1_CARD_miso_m__0__PC)
N#define SPI_1_CARD_miso_m_0_DR		(SPI_1_CARD_miso_m__0__DR)
N#define SPI_1_CARD_miso_m_0_SHIFT	(SPI_1_CARD_miso_m__0__SHIFT)
N#define SPI_1_CARD_miso_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_1_CARD_miso_m__0__SHIFT*2u)))
N
N#define SPI_1_CARD_miso_m_INTR_ALL	 ((uint16)(SPI_1_CARD_miso_m_0_INTR))
N
N
N#endif /* End Pins SPI_1_CARD_miso_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\SPI_1_CARD_miso_m.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} SPI_1_CARD_miso_m_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   SPI_1_CARD_miso_m_Read(void);
Nvoid    SPI_1_CARD_miso_m_Write(uint8 value);
Nuint8   SPI_1_CARD_miso_m_ReadDataReg(void);
N#if defined(SPI_1_CARD_miso_m__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    SPI_1_CARD_miso_m_SetDriveMode(uint8 mode);
N#endif
Nvoid    SPI_1_CARD_miso_m_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   SPI_1_CARD_miso_m_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid SPI_1_CARD_miso_m_Sleep(void); 
Nvoid SPI_1_CARD_miso_m_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(SPI_1_CARD_miso_m__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define SPI_1_CARD_miso_m_DRIVE_MODE_BITS        (3)
N    #define SPI_1_CARD_miso_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_1_CARD_miso_m_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the SPI_1_CARD_miso_m_SetDriveMode() function.
N         *  @{
N         */
N        #define SPI_1_CARD_miso_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define SPI_1_CARD_miso_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define SPI_1_CARD_miso_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define SPI_1_CARD_miso_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define SPI_1_CARD_miso_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define SPI_1_CARD_miso_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define SPI_1_CARD_miso_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define SPI_1_CARD_miso_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define SPI_1_CARD_miso_m_MASK               SPI_1_CARD_miso_m__MASK
N#define SPI_1_CARD_miso_m_SHIFT              SPI_1_CARD_miso_m__SHIFT
N#define SPI_1_CARD_miso_m_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in SPI_1_CARD_miso_m_SetInterruptMode() function.
N     *  @{
N     */
N        #define SPI_1_CARD_miso_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define SPI_1_CARD_miso_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define SPI_1_CARD_miso_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define SPI_1_CARD_miso_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(SPI_1_CARD_miso_m__SIO)
X#if 0L
S    #define SPI_1_CARD_miso_m_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(SPI_1_CARD_miso_m__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define SPI_1_CARD_miso_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_1_CARD_miso_m_USBIO_DISABLE              ((uint32)(~SPI_1_CARD_miso_m_USBIO_ENABLE))
S    #define SPI_1_CARD_miso_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_1_CARD_miso_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_1_CARD_miso_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_miso_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_1_CARD_miso_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_1_CARD_miso_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_miso_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_1_CARD_miso_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_miso_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_1_CARD_miso_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_1_CARD_miso_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_1_CARD_miso_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_miso_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(SPI_1_CARD_miso_m__PC)
X#if 1L
N    /* Port Configuration */
N    #define SPI_1_CARD_miso_m_PC                 (* (reg32 *) SPI_1_CARD_miso_m__PC)
N#endif
N/* Pin State */
N#define SPI_1_CARD_miso_m_PS                     (* (reg32 *) SPI_1_CARD_miso_m__PS)
N/* Data Register */
N#define SPI_1_CARD_miso_m_DR                     (* (reg32 *) SPI_1_CARD_miso_m__DR)
N/* Input Buffer Disable Override */
N#define SPI_1_CARD_miso_m_INP_DIS                (* (reg32 *) SPI_1_CARD_miso_m__PC2)
N
N/* Interrupt configuration Registers */
N#define SPI_1_CARD_miso_m_INTCFG                 (* (reg32 *) SPI_1_CARD_miso_m__INTCFG)
N#define SPI_1_CARD_miso_m_INTSTAT                (* (reg32 *) SPI_1_CARD_miso_m__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define SPI_1_CARD_miso_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(SPI_1_CARD_miso_m__SIO)
X#if 0L
S    #define SPI_1_CARD_miso_m_SIO_REG            (* (reg32 *) SPI_1_CARD_miso_m__SIO)
N#endif /* (SPI_1_CARD_miso_m__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(SPI_1_CARD_miso_m__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define SPI_1_CARD_miso_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_1_CARD_miso_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_1_CARD_miso_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define SPI_1_CARD_miso_m_DRIVE_MODE_SHIFT       (0x00u)
N#define SPI_1_CARD_miso_m_DRIVE_MODE_MASK        (0x07u << SPI_1_CARD_miso_m_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins SPI_1_CARD_miso_m_H */
N
N
N/* [] END OF FILE */
L 144 "Generated_Source\PSoC4\SPI_1_CARD_PINS.h" 2
N#endif /*(SPI_1_CARD_SPI_MASTER_MISO_PIN) */
N#endif /* (SPI_1_CARD_SPI_MASTER_PINS) */
N
N#if (SPI_1_CARD_SPI_SLAVE_PINS)
X#if ((0u == (1u)))
S    #include "SPI_1_CARD_sclk_s.h"
S    #include "SPI_1_CARD_ss_s.h"
S
S#if (SPI_1_CARD_SPI_SLAVE_MOSI_PIN)
S    #include "SPI_1_CARD_mosi_s.h"
S#endif /* (SPI_1_CARD_SPI_SLAVE_MOSI_PIN) */
S
S#if (SPI_1_CARD_SPI_SLAVE_MISO_PIN)
S    #include "SPI_1_CARD_miso_s.h"
S#endif /*(SPI_1_CARD_SPI_SLAVE_MISO_PIN) */
N#endif /* (SPI_1_CARD_SPI_SLAVE_PINS) */
N
N#if (SPI_1_CARD_SPI_MASTER_SS0_PIN)
X#if ((0u == (0u)))
N    #include "SPI_1_CARD_ss0_m.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_ss0_m.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_ss0_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_ss0_m_H) /* Pins SPI_1_CARD_ss0_m_H */
X#if !0L  
N#define CY_PINS_SPI_1_CARD_ss0_m_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "SPI_1_CARD_ss0_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_ss0_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_ss0_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_ss0_m_ALIASES_H) /* Pins SPI_1_CARD_ss0_m_ALIASES_H */
X#if !0L  
N#define CY_PINS_SPI_1_CARD_ss0_m_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define SPI_1_CARD_ss0_m_0			(SPI_1_CARD_ss0_m__0__PC)
N#define SPI_1_CARD_ss0_m_0_PS		(SPI_1_CARD_ss0_m__0__PS)
N#define SPI_1_CARD_ss0_m_0_PC		(SPI_1_CARD_ss0_m__0__PC)
N#define SPI_1_CARD_ss0_m_0_DR		(SPI_1_CARD_ss0_m__0__DR)
N#define SPI_1_CARD_ss0_m_0_SHIFT	(SPI_1_CARD_ss0_m__0__SHIFT)
N#define SPI_1_CARD_ss0_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_1_CARD_ss0_m__0__SHIFT*2u)))
N
N#define SPI_1_CARD_ss0_m_INTR_ALL	 ((uint16)(SPI_1_CARD_ss0_m_0_INTR))
N
N
N#endif /* End Pins SPI_1_CARD_ss0_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\SPI_1_CARD_ss0_m.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} SPI_1_CARD_ss0_m_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   SPI_1_CARD_ss0_m_Read(void);
Nvoid    SPI_1_CARD_ss0_m_Write(uint8 value);
Nuint8   SPI_1_CARD_ss0_m_ReadDataReg(void);
N#if defined(SPI_1_CARD_ss0_m__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    SPI_1_CARD_ss0_m_SetDriveMode(uint8 mode);
N#endif
Nvoid    SPI_1_CARD_ss0_m_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   SPI_1_CARD_ss0_m_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid SPI_1_CARD_ss0_m_Sleep(void); 
Nvoid SPI_1_CARD_ss0_m_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(SPI_1_CARD_ss0_m__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define SPI_1_CARD_ss0_m_DRIVE_MODE_BITS        (3)
N    #define SPI_1_CARD_ss0_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_1_CARD_ss0_m_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the SPI_1_CARD_ss0_m_SetDriveMode() function.
N         *  @{
N         */
N        #define SPI_1_CARD_ss0_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define SPI_1_CARD_ss0_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define SPI_1_CARD_ss0_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define SPI_1_CARD_ss0_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define SPI_1_CARD_ss0_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define SPI_1_CARD_ss0_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define SPI_1_CARD_ss0_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define SPI_1_CARD_ss0_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define SPI_1_CARD_ss0_m_MASK               SPI_1_CARD_ss0_m__MASK
N#define SPI_1_CARD_ss0_m_SHIFT              SPI_1_CARD_ss0_m__SHIFT
N#define SPI_1_CARD_ss0_m_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in SPI_1_CARD_ss0_m_SetInterruptMode() function.
N     *  @{
N     */
N        #define SPI_1_CARD_ss0_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define SPI_1_CARD_ss0_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define SPI_1_CARD_ss0_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define SPI_1_CARD_ss0_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(SPI_1_CARD_ss0_m__SIO)
X#if 0L
S    #define SPI_1_CARD_ss0_m_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(SPI_1_CARD_ss0_m__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define SPI_1_CARD_ss0_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_1_CARD_ss0_m_USBIO_DISABLE              ((uint32)(~SPI_1_CARD_ss0_m_USBIO_ENABLE))
S    #define SPI_1_CARD_ss0_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_1_CARD_ss0_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_1_CARD_ss0_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_ss0_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_1_CARD_ss0_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_1_CARD_ss0_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_ss0_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_1_CARD_ss0_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_ss0_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_1_CARD_ss0_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_1_CARD_ss0_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_1_CARD_ss0_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_ss0_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(SPI_1_CARD_ss0_m__PC)
X#if 1L
N    /* Port Configuration */
N    #define SPI_1_CARD_ss0_m_PC                 (* (reg32 *) SPI_1_CARD_ss0_m__PC)
N#endif
N/* Pin State */
N#define SPI_1_CARD_ss0_m_PS                     (* (reg32 *) SPI_1_CARD_ss0_m__PS)
N/* Data Register */
N#define SPI_1_CARD_ss0_m_DR                     (* (reg32 *) SPI_1_CARD_ss0_m__DR)
N/* Input Buffer Disable Override */
N#define SPI_1_CARD_ss0_m_INP_DIS                (* (reg32 *) SPI_1_CARD_ss0_m__PC2)
N
N/* Interrupt configuration Registers */
N#define SPI_1_CARD_ss0_m_INTCFG                 (* (reg32 *) SPI_1_CARD_ss0_m__INTCFG)
N#define SPI_1_CARD_ss0_m_INTSTAT                (* (reg32 *) SPI_1_CARD_ss0_m__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define SPI_1_CARD_ss0_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(SPI_1_CARD_ss0_m__SIO)
X#if 0L
S    #define SPI_1_CARD_ss0_m_SIO_REG            (* (reg32 *) SPI_1_CARD_ss0_m__SIO)
N#endif /* (SPI_1_CARD_ss0_m__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(SPI_1_CARD_ss0_m__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define SPI_1_CARD_ss0_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_1_CARD_ss0_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_1_CARD_ss0_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define SPI_1_CARD_ss0_m_DRIVE_MODE_SHIFT       (0x00u)
N#define SPI_1_CARD_ss0_m_DRIVE_MODE_MASK        (0x07u << SPI_1_CARD_ss0_m_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins SPI_1_CARD_ss0_m_H */
N
N
N/* [] END OF FILE */
L 162 "Generated_Source\PSoC4\SPI_1_CARD_PINS.h" 2
N#endif /* (SPI_1_CARD_SPI_MASTER_SS0_PIN) */
N
N#if (SPI_1_CARD_SPI_MASTER_SS1_PIN)
X#if ((0u == (1u)))
S    #include "SPI_1_CARD_ss1_m.h"
N#endif /* (SPI_1_CARD_SPI_MASTER_SS1_PIN) */
N
N#if (SPI_1_CARD_SPI_MASTER_SS2_PIN)
X#if ((0u == (1u)))
S    #include "SPI_1_CARD_ss2_m.h"
N#endif /* (SPI_1_CARD_SPI_MASTER_SS2_PIN) */
N
N#if (SPI_1_CARD_SPI_MASTER_SS3_PIN)
X#if ((0u == (1u)))
S    #include "SPI_1_CARD_ss3_m.h"
N#endif /* (SPI_1_CARD_SPI_MASTER_SS3_PIN) */
N
N#if (SPI_1_CARD_UART_TX_PIN)
X#if ((0u == (1u)))
S    #include "SPI_1_CARD_tx.h"
N#endif /* (SPI_1_CARD_UART_TX_PIN) */
N
N#if (SPI_1_CARD_UART_RX_TX_PIN)
X#if ((0u == (1u)))
S    #include "SPI_1_CARD_rx_tx.h"
N#endif /* (SPI_1_CARD_UART_RX_TX_PIN) */
N
N#if (SPI_1_CARD_UART_RX_PIN)
X#if ((0u == (1u)))
S    #include "SPI_1_CARD_rx.h"
N#endif /* (SPI_1_CARD_UART_RX_PIN) */
N
N#if (SPI_1_CARD_UART_RX_WAKE_PIN)
X#if ((0u == (1u)))
S    #include "SPI_1_CARD_rx_wake.h"
N#endif /* (SPI_1_CARD_UART_RX_WAKE_PIN) */
N
N#if (SPI_1_CARD_UART_RTS_PIN)
X#if ((0u == (1u)))
S    #include "SPI_1_CARD_rts.h"
N#endif /* (SPI_1_CARD_UART_RTS_PIN) */
N
N#if (SPI_1_CARD_UART_CTS_PIN)
X#if ((0u == (1u)))
S    #include "SPI_1_CARD_cts.h"
N#endif /* (SPI_1_CARD_UART_CTS_PIN) */
N
N
N/***************************************
N*              Registers
N***************************************/
N
N#if (SPI_1_CARD_RX_SCL_MOSI_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_RX_SCL_MOSI_HSIOM_REG   (*(reg32 *) SPI_1_CARD_uart_rx_i2c_scl_spi_mosi__0__HSIOM)
S    #define SPI_1_CARD_RX_SCL_MOSI_HSIOM_PTR   ( (reg32 *) SPI_1_CARD_uart_rx_i2c_scl_spi_mosi__0__HSIOM)
S    
S    #define SPI_1_CARD_RX_SCL_MOSI_HSIOM_MASK      (SPI_1_CARD_uart_rx_i2c_scl_spi_mosi__0__HSIOM_MASK)
S    #define SPI_1_CARD_RX_SCL_MOSI_HSIOM_POS       (SPI_1_CARD_uart_rx_i2c_scl_spi_mosi__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_RX_SCL_MOSI_HSIOM_SEL_GPIO  (SPI_1_CARD_uart_rx_i2c_scl_spi_mosi__0__HSIOM_GPIO)
S    #define SPI_1_CARD_RX_SCL_MOSI_HSIOM_SEL_I2C   (SPI_1_CARD_uart_rx_i2c_scl_spi_mosi__0__HSIOM_I2C)
S    #define SPI_1_CARD_RX_SCL_MOSI_HSIOM_SEL_SPI   (SPI_1_CARD_uart_rx_i2c_scl_spi_mosi__0__HSIOM_SPI)
S    #define SPI_1_CARD_RX_SCL_MOSI_HSIOM_SEL_UART  (SPI_1_CARD_uart_rx_i2c_scl_spi_mosi__0__HSIOM_UART)
S    
S#elif (SPI_1_CARD_RX_WAKE_SCL_MOSI_PIN)
X#elif ((0u == (1u)))
S    #define SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_REG   (*(reg32 *) SPI_1_CARD_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM)
S    #define SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_PTR   ( (reg32 *) SPI_1_CARD_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM)
S    
S    #define SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_MASK      (SPI_1_CARD_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_MASK)
S    #define SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_POS       (SPI_1_CARD_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_SEL_GPIO  (SPI_1_CARD_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_GPIO)
S    #define SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_SEL_I2C   (SPI_1_CARD_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_I2C)
S    #define SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_SEL_SPI   (SPI_1_CARD_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_SPI)
S    #define SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_SEL_UART  (SPI_1_CARD_uart_rx_wake_i2c_scl_spi_mosi__0__HSIOM_UART)    
S   
S    #define SPI_1_CARD_RX_WAKE_SCL_MOSI_INTCFG_REG (*(reg32 *) SPI_1_CARD_uart_rx_wake_i2c_scl_spi_mosi__0__INTCFG)
S    #define SPI_1_CARD_RX_WAKE_SCL_MOSI_INTCFG_PTR ( (reg32 *) SPI_1_CARD_uart_rx_wake_i2c_scl_spi_mosi__0__INTCFG)
S    #define SPI_1_CARD_RX_WAKE_SCL_MOSI_INTCFG_TYPE_POS  (SPI_1_CARD_uart_rx_wake_i2c_scl_spi_mosi__SHIFT)
S    #define SPI_1_CARD_RX_WAKE_SCL_MOSI_INTCFG_TYPE_MASK ((uint32) SPI_1_CARD_INTCFG_TYPE_MASK << \
S                                                                           SPI_1_CARD_RX_WAKE_SCL_MOSI_INTCFG_TYPE_POS)
X    #define SPI_1_CARD_RX_WAKE_SCL_MOSI_INTCFG_TYPE_MASK ((uint32) SPI_1_CARD_INTCFG_TYPE_MASK <<                                                                            SPI_1_CARD_RX_WAKE_SCL_MOSI_INTCFG_TYPE_POS)
N#else
N    /* None of pins SPI_1_CARD_RX_SCL_MOSI_PIN or SPI_1_CARD_RX_WAKE_SCL_MOSI_PIN present.*/
N#endif /* (SPI_1_CARD_RX_SCL_MOSI_PIN) */
N
N#if (SPI_1_CARD_TX_SDA_MISO_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_TX_SDA_MISO_HSIOM_REG   (*(reg32 *) SPI_1_CARD_uart_tx_i2c_sda_spi_miso__0__HSIOM)
S    #define SPI_1_CARD_TX_SDA_MISO_HSIOM_PTR   ( (reg32 *) SPI_1_CARD_uart_tx_i2c_sda_spi_miso__0__HSIOM)
S    
S    #define SPI_1_CARD_TX_SDA_MISO_HSIOM_MASK      (SPI_1_CARD_uart_tx_i2c_sda_spi_miso__0__HSIOM_MASK)
S    #define SPI_1_CARD_TX_SDA_MISO_HSIOM_POS       (SPI_1_CARD_uart_tx_i2c_sda_spi_miso__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_TX_SDA_MISO_HSIOM_SEL_GPIO  (SPI_1_CARD_uart_tx_i2c_sda_spi_miso__0__HSIOM_GPIO)
S    #define SPI_1_CARD_TX_SDA_MISO_HSIOM_SEL_I2C   (SPI_1_CARD_uart_tx_i2c_sda_spi_miso__0__HSIOM_I2C)
S    #define SPI_1_CARD_TX_SDA_MISO_HSIOM_SEL_SPI   (SPI_1_CARD_uart_tx_i2c_sda_spi_miso__0__HSIOM_SPI)
S    #define SPI_1_CARD_TX_SDA_MISO_HSIOM_SEL_UART  (SPI_1_CARD_uart_tx_i2c_sda_spi_miso__0__HSIOM_UART)
N#endif /* (SPI_1_CARD_TX_SDA_MISO_PIN) */
N
N#if (SPI_1_CARD_CTS_SCLK_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_CTS_SCLK_HSIOM_REG   (*(reg32 *) SPI_1_CARD_uart_cts_spi_sclk__0__HSIOM)
S    #define SPI_1_CARD_CTS_SCLK_HSIOM_PTR   ( (reg32 *) SPI_1_CARD_uart_cts_spi_sclk__0__HSIOM)
S    
S    #define SPI_1_CARD_CTS_SCLK_HSIOM_MASK      (SPI_1_CARD_uart_cts_spi_sclk__0__HSIOM_MASK)
S    #define SPI_1_CARD_CTS_SCLK_HSIOM_POS       (SPI_1_CARD_uart_cts_spi_sclk__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_CTS_SCLK_HSIOM_SEL_GPIO  (SPI_1_CARD_uart_cts_spi_sclk__0__HSIOM_GPIO)
S    #define SPI_1_CARD_CTS_SCLK_HSIOM_SEL_I2C   (SPI_1_CARD_uart_cts_spi_sclk__0__HSIOM_I2C)
S    #define SPI_1_CARD_CTS_SCLK_HSIOM_SEL_SPI   (SPI_1_CARD_uart_cts_spi_sclk__0__HSIOM_SPI)
S    #define SPI_1_CARD_CTS_SCLK_HSIOM_SEL_UART  (SPI_1_CARD_uart_cts_spi_sclk__0__HSIOM_UART)
N#endif /* (SPI_1_CARD_CTS_SCLK_PIN) */
N
N#if (SPI_1_CARD_RTS_SS0_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_RTS_SS0_HSIOM_REG   (*(reg32 *) SPI_1_CARD_uart_rts_spi_ss0__0__HSIOM)
S    #define SPI_1_CARD_RTS_SS0_HSIOM_PTR   ( (reg32 *) SPI_1_CARD_uart_rts_spi_ss0__0__HSIOM)
S    
S    #define SPI_1_CARD_RTS_SS0_HSIOM_MASK      (SPI_1_CARD_uart_rts_spi_ss0__0__HSIOM_MASK)
S    #define SPI_1_CARD_RTS_SS0_HSIOM_POS       (SPI_1_CARD_uart_rts_spi_ss0__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_RTS_SS0_HSIOM_SEL_GPIO  (SPI_1_CARD_uart_rts_spi_ss0__0__HSIOM_GPIO)
S    #define SPI_1_CARD_RTS_SS0_HSIOM_SEL_I2C   (SPI_1_CARD_uart_rts_spi_ss0__0__HSIOM_I2C)
S    #define SPI_1_CARD_RTS_SS0_HSIOM_SEL_SPI   (SPI_1_CARD_uart_rts_spi_ss0__0__HSIOM_SPI)
S#if !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1)
S    #define SPI_1_CARD_RTS_SS0_HSIOM_SEL_UART  (SPI_1_CARD_uart_rts_spi_ss0__0__HSIOM_UART)
S#endif /* !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1) */
N#endif /* (SPI_1_CARD_RTS_SS0_PIN) */
N
N#if (SPI_1_CARD_SS1_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_SS1_HSIOM_REG  (*(reg32 *) SPI_1_CARD_spi_ss1__0__HSIOM)
S    #define SPI_1_CARD_SS1_HSIOM_PTR  ( (reg32 *) SPI_1_CARD_spi_ss1__0__HSIOM)
S    
S    #define SPI_1_CARD_SS1_HSIOM_MASK     (SPI_1_CARD_spi_ss1__0__HSIOM_MASK)
S    #define SPI_1_CARD_SS1_HSIOM_POS      (SPI_1_CARD_spi_ss1__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_SS1_HSIOM_SEL_GPIO (SPI_1_CARD_spi_ss1__0__HSIOM_GPIO)
S    #define SPI_1_CARD_SS1_HSIOM_SEL_I2C  (SPI_1_CARD_spi_ss1__0__HSIOM_I2C)
S    #define SPI_1_CARD_SS1_HSIOM_SEL_SPI  (SPI_1_CARD_spi_ss1__0__HSIOM_SPI)
N#endif /* (SPI_1_CARD_SS1_PIN) */
N
N#if (SPI_1_CARD_SS2_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_SS2_HSIOM_REG     (*(reg32 *) SPI_1_CARD_spi_ss2__0__HSIOM)
S    #define SPI_1_CARD_SS2_HSIOM_PTR     ( (reg32 *) SPI_1_CARD_spi_ss2__0__HSIOM)
S    
S    #define SPI_1_CARD_SS2_HSIOM_MASK     (SPI_1_CARD_spi_ss2__0__HSIOM_MASK)
S    #define SPI_1_CARD_SS2_HSIOM_POS      (SPI_1_CARD_spi_ss2__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_SS2_HSIOM_SEL_GPIO (SPI_1_CARD_spi_ss2__0__HSIOM_GPIO)
S    #define SPI_1_CARD_SS2_HSIOM_SEL_I2C  (SPI_1_CARD_spi_ss2__0__HSIOM_I2C)
S    #define SPI_1_CARD_SS2_HSIOM_SEL_SPI  (SPI_1_CARD_spi_ss2__0__HSIOM_SPI)
N#endif /* (SPI_1_CARD_SS2_PIN) */
N
N#if (SPI_1_CARD_SS3_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_SS3_HSIOM_REG     (*(reg32 *) SPI_1_CARD_spi_ss3__0__HSIOM)
S    #define SPI_1_CARD_SS3_HSIOM_PTR     ( (reg32 *) SPI_1_CARD_spi_ss3__0__HSIOM)
S    
S    #define SPI_1_CARD_SS3_HSIOM_MASK     (SPI_1_CARD_spi_ss3__0__HSIOM_MASK)
S    #define SPI_1_CARD_SS3_HSIOM_POS      (SPI_1_CARD_spi_ss3__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_SS3_HSIOM_SEL_GPIO (SPI_1_CARD_spi_ss3__0__HSIOM_GPIO)
S    #define SPI_1_CARD_SS3_HSIOM_SEL_I2C  (SPI_1_CARD_spi_ss3__0__HSIOM_I2C)
S    #define SPI_1_CARD_SS3_HSIOM_SEL_SPI  (SPI_1_CARD_spi_ss3__0__HSIOM_SPI)
N#endif /* (SPI_1_CARD_SS3_PIN) */
N
N#if (SPI_1_CARD_I2C_PINS)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_SCL_HSIOM_REG  (*(reg32 *) SPI_1_CARD_scl__0__HSIOM)
S    #define SPI_1_CARD_SCL_HSIOM_PTR  ( (reg32 *) SPI_1_CARD_scl__0__HSIOM)
S    
S    #define SPI_1_CARD_SCL_HSIOM_MASK     (SPI_1_CARD_scl__0__HSIOM_MASK)
S    #define SPI_1_CARD_SCL_HSIOM_POS      (SPI_1_CARD_scl__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_SCL_HSIOM_SEL_GPIO (SPI_1_CARD_sda__0__HSIOM_GPIO)
S    #define SPI_1_CARD_SCL_HSIOM_SEL_I2C  (SPI_1_CARD_sda__0__HSIOM_I2C)
S    
S    #define SPI_1_CARD_SDA_HSIOM_REG  (*(reg32 *) SPI_1_CARD_sda__0__HSIOM)
S    #define SPI_1_CARD_SDA_HSIOM_PTR  ( (reg32 *) SPI_1_CARD_sda__0__HSIOM)
S    
S    #define SPI_1_CARD_SDA_HSIOM_MASK     (SPI_1_CARD_sda__0__HSIOM_MASK)
S    #define SPI_1_CARD_SDA_HSIOM_POS      (SPI_1_CARD_sda__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_SDA_HSIOM_SEL_GPIO (SPI_1_CARD_sda__0__HSIOM_GPIO)
S    #define SPI_1_CARD_SDA_HSIOM_SEL_I2C  (SPI_1_CARD_sda__0__HSIOM_I2C)
N#endif /* (SPI_1_CARD_I2C_PINS) */
N
N#if (SPI_1_CARD_SPI_SLAVE_PINS)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_SCLK_S_HSIOM_REG   (*(reg32 *) SPI_1_CARD_sclk_s__0__HSIOM)
S    #define SPI_1_CARD_SCLK_S_HSIOM_PTR   ( (reg32 *) SPI_1_CARD_sclk_s__0__HSIOM)
S    
S    #define SPI_1_CARD_SCLK_S_HSIOM_MASK      (SPI_1_CARD_sclk_s__0__HSIOM_MASK)
S    #define SPI_1_CARD_SCLK_S_HSIOM_POS       (SPI_1_CARD_sclk_s__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_SCLK_S_HSIOM_SEL_GPIO  (SPI_1_CARD_sclk_s__0__HSIOM_GPIO)
S    #define SPI_1_CARD_SCLK_S_HSIOM_SEL_SPI   (SPI_1_CARD_sclk_s__0__HSIOM_SPI)
S    
S    #define SPI_1_CARD_SS0_S_HSIOM_REG    (*(reg32 *) SPI_1_CARD_ss0_s__0__HSIOM)
S    #define SPI_1_CARD_SS0_S_HSIOM_PTR    ( (reg32 *) SPI_1_CARD_ss0_s__0__HSIOM)
S    
S    #define SPI_1_CARD_SS0_S_HSIOM_MASK       (SPI_1_CARD_ss0_s__0__HSIOM_MASK)
S    #define SPI_1_CARD_SS0_S_HSIOM_POS        (SPI_1_CARD_ss0_s__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_SS0_S_HSIOM_SEL_GPIO   (SPI_1_CARD_ss0_s__0__HSIOM_GPIO)  
S    #define SPI_1_CARD_SS0_S_HSIOM_SEL_SPI    (SPI_1_CARD_ss0_s__0__HSIOM_SPI)
N#endif /* (SPI_1_CARD_SPI_SLAVE_PINS) */
N
N#if (SPI_1_CARD_SPI_SLAVE_MOSI_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_MOSI_S_HSIOM_REG   (*(reg32 *) SPI_1_CARD_mosi_s__0__HSIOM)
S    #define SPI_1_CARD_MOSI_S_HSIOM_PTR   ( (reg32 *) SPI_1_CARD_mosi_s__0__HSIOM)
S    
S    #define SPI_1_CARD_MOSI_S_HSIOM_MASK      (SPI_1_CARD_mosi_s__0__HSIOM_MASK)
S    #define SPI_1_CARD_MOSI_S_HSIOM_POS       (SPI_1_CARD_mosi_s__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_MOSI_S_HSIOM_SEL_GPIO  (SPI_1_CARD_mosi_s__0__HSIOM_GPIO)
S    #define SPI_1_CARD_MOSI_S_HSIOM_SEL_SPI   (SPI_1_CARD_mosi_s__0__HSIOM_SPI)
N#endif /* (SPI_1_CARD_SPI_SLAVE_MOSI_PIN) */
N
N#if (SPI_1_CARD_SPI_SLAVE_MISO_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_MISO_S_HSIOM_REG   (*(reg32 *) SPI_1_CARD_miso_s__0__HSIOM)
S    #define SPI_1_CARD_MISO_S_HSIOM_PTR   ( (reg32 *) SPI_1_CARD_miso_s__0__HSIOM)
S    
S    #define SPI_1_CARD_MISO_S_HSIOM_MASK      (SPI_1_CARD_miso_s__0__HSIOM_MASK)
S    #define SPI_1_CARD_MISO_S_HSIOM_POS       (SPI_1_CARD_miso_s__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_MISO_S_HSIOM_SEL_GPIO  (SPI_1_CARD_miso_s__0__HSIOM_GPIO)
S    #define SPI_1_CARD_MISO_S_HSIOM_SEL_SPI   (SPI_1_CARD_miso_s__0__HSIOM_SPI)
N#endif /* (SPI_1_CARD_SPI_SLAVE_MISO_PIN) */
N
N#if (SPI_1_CARD_SPI_MASTER_MISO_PIN)
X#if ((0u == (0u)))
N    #define SPI_1_CARD_MISO_M_HSIOM_REG   (*(reg32 *) SPI_1_CARD_miso_m__0__HSIOM)
N    #define SPI_1_CARD_MISO_M_HSIOM_PTR   ( (reg32 *) SPI_1_CARD_miso_m__0__HSIOM)
N    
N    #define SPI_1_CARD_MISO_M_HSIOM_MASK      (SPI_1_CARD_miso_m__0__HSIOM_MASK)
N    #define SPI_1_CARD_MISO_M_HSIOM_POS       (SPI_1_CARD_miso_m__0__HSIOM_SHIFT)
N    #define SPI_1_CARD_MISO_M_HSIOM_SEL_GPIO  (SPI_1_CARD_miso_m__0__HSIOM_GPIO)
N    #define SPI_1_CARD_MISO_M_HSIOM_SEL_SPI   (SPI_1_CARD_miso_m__0__HSIOM_SPI)
N#endif /* (SPI_1_CARD_SPI_MASTER_MISO_PIN) */
N
N#if (SPI_1_CARD_SPI_MASTER_MOSI_PIN)
X#if ((0u == (0u)))
N    #define SPI_1_CARD_MOSI_M_HSIOM_REG   (*(reg32 *) SPI_1_CARD_mosi_m__0__HSIOM)
N    #define SPI_1_CARD_MOSI_M_HSIOM_PTR   ( (reg32 *) SPI_1_CARD_mosi_m__0__HSIOM)
N    
N    #define SPI_1_CARD_MOSI_M_HSIOM_MASK      (SPI_1_CARD_mosi_m__0__HSIOM_MASK)
N    #define SPI_1_CARD_MOSI_M_HSIOM_POS       (SPI_1_CARD_mosi_m__0__HSIOM_SHIFT)
N    #define SPI_1_CARD_MOSI_M_HSIOM_SEL_GPIO  (SPI_1_CARD_mosi_m__0__HSIOM_GPIO)
N    #define SPI_1_CARD_MOSI_M_HSIOM_SEL_SPI   (SPI_1_CARD_mosi_m__0__HSIOM_SPI)
N#endif /* (SPI_1_CARD_SPI_MASTER_MOSI_PIN) */
N
N#if (SPI_1_CARD_SPI_MASTER_SCLK_PIN)
X#if ((0u == (0u)))
N    #define SPI_1_CARD_SCLK_M_HSIOM_REG   (*(reg32 *) SPI_1_CARD_sclk_m__0__HSIOM)
N    #define SPI_1_CARD_SCLK_M_HSIOM_PTR   ( (reg32 *) SPI_1_CARD_sclk_m__0__HSIOM)
N    
N    #define SPI_1_CARD_SCLK_M_HSIOM_MASK      (SPI_1_CARD_sclk_m__0__HSIOM_MASK)
N    #define SPI_1_CARD_SCLK_M_HSIOM_POS       (SPI_1_CARD_sclk_m__0__HSIOM_SHIFT)
N    #define SPI_1_CARD_SCLK_M_HSIOM_SEL_GPIO  (SPI_1_CARD_sclk_m__0__HSIOM_GPIO)
N    #define SPI_1_CARD_SCLK_M_HSIOM_SEL_SPI   (SPI_1_CARD_sclk_m__0__HSIOM_SPI)
N#endif /* (SPI_1_CARD_SPI_MASTER_SCLK_PIN) */
N
N#if (SPI_1_CARD_SPI_MASTER_SS0_PIN)
X#if ((0u == (0u)))
N    #define SPI_1_CARD_SS0_M_HSIOM_REG    (*(reg32 *) SPI_1_CARD_ss0_m__0__HSIOM)
N    #define SPI_1_CARD_SS0_M_HSIOM_PTR    ( (reg32 *) SPI_1_CARD_ss0_m__0__HSIOM)
N    
N    #define SPI_1_CARD_SS0_M_HSIOM_MASK       (SPI_1_CARD_ss0_m__0__HSIOM_MASK)
N    #define SPI_1_CARD_SS0_M_HSIOM_POS        (SPI_1_CARD_ss0_m__0__HSIOM_SHIFT)
N    #define SPI_1_CARD_SS0_M_HSIOM_SEL_GPIO   (SPI_1_CARD_ss0_m__0__HSIOM_GPIO)
N    #define SPI_1_CARD_SS0_M_HSIOM_SEL_SPI    (SPI_1_CARD_ss0_m__0__HSIOM_SPI)
N#endif /* (SPI_1_CARD_SPI_MASTER_SS0_PIN) */
N
N#if (SPI_1_CARD_SPI_MASTER_SS1_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_SS1_M_HSIOM_REG    (*(reg32 *) SPI_1_CARD_ss1_m__0__HSIOM)
S    #define SPI_1_CARD_SS1_M_HSIOM_PTR    ( (reg32 *) SPI_1_CARD_ss1_m__0__HSIOM)
S    
S    #define SPI_1_CARD_SS1_M_HSIOM_MASK       (SPI_1_CARD_ss1_m__0__HSIOM_MASK)
S    #define SPI_1_CARD_SS1_M_HSIOM_POS        (SPI_1_CARD_ss1_m__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_SS1_M_HSIOM_SEL_GPIO   (SPI_1_CARD_ss1_m__0__HSIOM_GPIO)
S    #define SPI_1_CARD_SS1_M_HSIOM_SEL_SPI    (SPI_1_CARD_ss1_m__0__HSIOM_SPI)
N#endif /* (SPI_1_CARD_SPI_MASTER_SS1_PIN) */
N
N#if (SPI_1_CARD_SPI_MASTER_SS2_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_SS2_M_HSIOM_REG    (*(reg32 *) SPI_1_CARD_ss2_m__0__HSIOM)
S    #define SPI_1_CARD_SS2_M_HSIOM_PTR    ( (reg32 *) SPI_1_CARD_ss2_m__0__HSIOM)
S    
S    #define SPI_1_CARD_SS2_M_HSIOM_MASK       (SPI_1_CARD_ss2_m__0__HSIOM_MASK)
S    #define SPI_1_CARD_SS2_M_HSIOM_POS        (SPI_1_CARD_ss2_m__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_SS2_M_HSIOM_SEL_GPIO   (SPI_1_CARD_ss2_m__0__HSIOM_GPIO)
S    #define SPI_1_CARD_SS2_M_HSIOM_SEL_SPI    (SPI_1_CARD_ss2_m__0__HSIOM_SPI)
N#endif /* (SPI_1_CARD_SPI_MASTER_SS2_PIN) */
N
N#if (SPI_1_CARD_SPI_MASTER_SS3_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_SS3_M_HSIOM_REG    (*(reg32 *) SPI_1_CARD_ss3_m__0__HSIOM)
S    #define SPI_1_CARD_SS3_M_HSIOM_PTR    ( (reg32 *) SPI_1_CARD_ss3_m__0__HSIOM)
S    
S    #define SPI_1_CARD_SS3_M_HSIOM_MASK      (SPI_1_CARD_ss3_m__0__HSIOM_MASK)
S    #define SPI_1_CARD_SS3_M_HSIOM_POS       (SPI_1_CARD_ss3_m__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_SS3_M_HSIOM_SEL_GPIO  (SPI_1_CARD_ss3_m__0__HSIOM_GPIO)
S    #define SPI_1_CARD_SS3_M_HSIOM_SEL_SPI   (SPI_1_CARD_ss3_m__0__HSIOM_SPI)
N#endif /* (SPI_1_CARD_SPI_MASTER_SS3_PIN) */
N
N#if (SPI_1_CARD_UART_RX_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_RX_HSIOM_REG   (*(reg32 *) SPI_1_CARD_rx__0__HSIOM)
S    #define SPI_1_CARD_RX_HSIOM_PTR   ( (reg32 *) SPI_1_CARD_rx__0__HSIOM)
S    
S    #define SPI_1_CARD_RX_HSIOM_MASK      (SPI_1_CARD_rx__0__HSIOM_MASK)
S    #define SPI_1_CARD_RX_HSIOM_POS       (SPI_1_CARD_rx__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_RX_HSIOM_SEL_GPIO  (SPI_1_CARD_rx__0__HSIOM_GPIO)
S    #define SPI_1_CARD_RX_HSIOM_SEL_UART  (SPI_1_CARD_rx__0__HSIOM_UART)
N#endif /* (SPI_1_CARD_UART_RX_PIN) */
N
N#if (SPI_1_CARD_UART_RX_WAKE_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_RX_WAKE_HSIOM_REG   (*(reg32 *) SPI_1_CARD_rx_wake__0__HSIOM)
S    #define SPI_1_CARD_RX_WAKE_HSIOM_PTR   ( (reg32 *) SPI_1_CARD_rx_wake__0__HSIOM)
S    
S    #define SPI_1_CARD_RX_WAKE_HSIOM_MASK      (SPI_1_CARD_rx_wake__0__HSIOM_MASK)
S    #define SPI_1_CARD_RX_WAKE_HSIOM_POS       (SPI_1_CARD_rx_wake__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_RX_WAKE_HSIOM_SEL_GPIO  (SPI_1_CARD_rx_wake__0__HSIOM_GPIO)
S    #define SPI_1_CARD_RX_WAKE_HSIOM_SEL_UART  (SPI_1_CARD_rx_wake__0__HSIOM_UART)
N#endif /* (SPI_1_CARD_UART_WAKE_RX_PIN) */
N
N#if (SPI_1_CARD_UART_CTS_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_CTS_HSIOM_REG   (*(reg32 *) SPI_1_CARD_cts__0__HSIOM)
S    #define SPI_1_CARD_CTS_HSIOM_PTR   ( (reg32 *) SPI_1_CARD_cts__0__HSIOM)
S    
S    #define SPI_1_CARD_CTS_HSIOM_MASK      (SPI_1_CARD_cts__0__HSIOM_MASK)
S    #define SPI_1_CARD_CTS_HSIOM_POS       (SPI_1_CARD_cts__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_CTS_HSIOM_SEL_GPIO  (SPI_1_CARD_cts__0__HSIOM_GPIO)
S    #define SPI_1_CARD_CTS_HSIOM_SEL_UART  (SPI_1_CARD_cts__0__HSIOM_UART)
N#endif /* (SPI_1_CARD_UART_CTS_PIN) */
N
N#if (SPI_1_CARD_UART_TX_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_TX_HSIOM_REG   (*(reg32 *) SPI_1_CARD_tx__0__HSIOM)
S    #define SPI_1_CARD_TX_HSIOM_PTR   ( (reg32 *) SPI_1_CARD_tx__0__HSIOM)
S    
S    #define SPI_1_CARD_TX_HSIOM_MASK      (SPI_1_CARD_tx__0__HSIOM_MASK)
S    #define SPI_1_CARD_TX_HSIOM_POS       (SPI_1_CARD_tx__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_TX_HSIOM_SEL_GPIO  (SPI_1_CARD_tx__0__HSIOM_GPIO)
S    #define SPI_1_CARD_TX_HSIOM_SEL_UART  (SPI_1_CARD_tx__0__HSIOM_UART)
N#endif /* (SPI_1_CARD_UART_TX_PIN) */
N
N#if (SPI_1_CARD_UART_RX_TX_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_RX_TX_HSIOM_REG   (*(reg32 *) SPI_1_CARD_rx_tx__0__HSIOM)
S    #define SPI_1_CARD_RX_TX_HSIOM_PTR   ( (reg32 *) SPI_1_CARD_rx_tx__0__HSIOM)
S    
S    #define SPI_1_CARD_RX_TX_HSIOM_MASK      (SPI_1_CARD_rx_tx__0__HSIOM_MASK)
S    #define SPI_1_CARD_RX_TX_HSIOM_POS       (SPI_1_CARD_rx_tx__0__HSIOM_SHIFT)
S    #define SPI_1_CARD_RX_TX_HSIOM_SEL_GPIO  (SPI_1_CARD_rx_tx__0__HSIOM_GPIO)
S    #define SPI_1_CARD_RX_TX_HSIOM_SEL_UART  (SPI_1_CARD_rx_tx__0__HSIOM_UART)
N#endif /* (SPI_1_CARD_UART_RX_TX_PIN) */
N
N#if (SPI_1_CARD_UART_RTS_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_RTS_HSIOM_REG      (*(reg32 *) SPI_1_CARD_rts__0__HSIOM)
S    #define SPI_1_CARD_RTS_HSIOM_PTR      ( (reg32 *) SPI_1_CARD_rts__0__HSIOM)
S    
S    #define SPI_1_CARD_RTS_HSIOM_MASK     (SPI_1_CARD_rts__0__HSIOM_MASK)
S    #define SPI_1_CARD_RTS_HSIOM_POS      (SPI_1_CARD_rts__0__HSIOM_SHIFT)    
S    #define SPI_1_CARD_RTS_HSIOM_SEL_GPIO (SPI_1_CARD_rts__0__HSIOM_GPIO)
S    #define SPI_1_CARD_RTS_HSIOM_SEL_UART (SPI_1_CARD_rts__0__HSIOM_UART)    
N#endif /* (SPI_1_CARD_UART_RTS_PIN) */
N
N
N/***************************************
N*        Registers Constants
N***************************************/
N
N/* HSIOM switch values. */ 
N#define SPI_1_CARD_HSIOM_DEF_SEL      (0x00u)
N#define SPI_1_CARD_HSIOM_GPIO_SEL     (0x00u)
N/* The HSIOM values provided below are valid only for SPI_1_CARD_CY_SCBIP_V0 
N* and SPI_1_CARD_CY_SCBIP_V1. It is not recommended to use them for 
N* SPI_1_CARD_CY_SCBIP_V2. Use pin name specific HSIOM constants provided 
N* above instead for any SCB IP block version.
N*/
N#define SPI_1_CARD_HSIOM_UART_SEL     (0x09u)
N#define SPI_1_CARD_HSIOM_I2C_SEL      (0x0Eu)
N#define SPI_1_CARD_HSIOM_SPI_SEL      (0x0Fu)
N
N/* Pins settings index. */
N#define SPI_1_CARD_RX_WAKE_SCL_MOSI_PIN_INDEX   (0u)
N#define SPI_1_CARD_RX_SCL_MOSI_PIN_INDEX       (0u)
N#define SPI_1_CARD_TX_SDA_MISO_PIN_INDEX       (1u)
N#define SPI_1_CARD_CTS_SCLK_PIN_INDEX       (2u)
N#define SPI_1_CARD_RTS_SS0_PIN_INDEX       (3u)
N#define SPI_1_CARD_SS1_PIN_INDEX                  (4u)
N#define SPI_1_CARD_SS2_PIN_INDEX                  (5u)
N#define SPI_1_CARD_SS3_PIN_INDEX                  (6u)
N
N/* Pins settings mask. */
N#define SPI_1_CARD_RX_WAKE_SCL_MOSI_PIN_MASK ((uint32) 0x01u << SPI_1_CARD_RX_WAKE_SCL_MOSI_PIN_INDEX)
N#define SPI_1_CARD_RX_SCL_MOSI_PIN_MASK     ((uint32) 0x01u << SPI_1_CARD_RX_SCL_MOSI_PIN_INDEX)
N#define SPI_1_CARD_TX_SDA_MISO_PIN_MASK     ((uint32) 0x01u << SPI_1_CARD_TX_SDA_MISO_PIN_INDEX)
N#define SPI_1_CARD_CTS_SCLK_PIN_MASK     ((uint32) 0x01u << SPI_1_CARD_CTS_SCLK_PIN_INDEX)
N#define SPI_1_CARD_RTS_SS0_PIN_MASK     ((uint32) 0x01u << SPI_1_CARD_RTS_SS0_PIN_INDEX)
N#define SPI_1_CARD_SS1_PIN_MASK                ((uint32) 0x01u << SPI_1_CARD_SS1_PIN_INDEX)
N#define SPI_1_CARD_SS2_PIN_MASK                ((uint32) 0x01u << SPI_1_CARD_SS2_PIN_INDEX)
N#define SPI_1_CARD_SS3_PIN_MASK                ((uint32) 0x01u << SPI_1_CARD_SS3_PIN_INDEX)
N
N/* Pin interrupt constants. */
N#define SPI_1_CARD_INTCFG_TYPE_MASK           (0x03u)
N#define SPI_1_CARD_INTCFG_TYPE_FALLING_EDGE   (0x02u)
N
N/* Pin Drive Mode constants. */
N#define SPI_1_CARD_PIN_DM_ALG_HIZ  (0u)
N#define SPI_1_CARD_PIN_DM_DIG_HIZ  (1u)
N#define SPI_1_CARD_PIN_DM_OD_LO    (4u)
N#define SPI_1_CARD_PIN_DM_STRONG   (6u)
N
N
N/***************************************
N*          Macro Definitions
N***************************************/
N
N/* Return drive mode of the pin */
N#define SPI_1_CARD_DM_MASK    (0x7u)
N#define SPI_1_CARD_DM_SIZE    (3u)
N#define SPI_1_CARD_GET_P4_PIN_DM(reg, pos) \
N    ( ((reg) & (uint32) ((uint32) SPI_1_CARD_DM_MASK << (SPI_1_CARD_DM_SIZE * (pos)))) >> \
N                                                              (SPI_1_CARD_DM_SIZE * (pos)) )
X#define SPI_1_CARD_GET_P4_PIN_DM(reg, pos)     ( ((reg) & (uint32) ((uint32) SPI_1_CARD_DM_MASK << (SPI_1_CARD_DM_SIZE * (pos)))) >>                                                               (SPI_1_CARD_DM_SIZE * (pos)) )
N
N#if (SPI_1_CARD_TX_SDA_MISO_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_CHECK_TX_SDA_MISO_PIN_USED \
S                (SPI_1_CARD_PIN_DM_ALG_HIZ != \
S                    SPI_1_CARD_GET_P4_PIN_DM(SPI_1_CARD_uart_tx_i2c_sda_spi_miso_PC, \
S                                                   SPI_1_CARD_uart_tx_i2c_sda_spi_miso_SHIFT))
X    #define SPI_1_CARD_CHECK_TX_SDA_MISO_PIN_USED                 (SPI_1_CARD_PIN_DM_ALG_HIZ !=                     SPI_1_CARD_GET_P4_PIN_DM(SPI_1_CARD_uart_tx_i2c_sda_spi_miso_PC,                                                    SPI_1_CARD_uart_tx_i2c_sda_spi_miso_SHIFT))
N#endif /* (SPI_1_CARD_TX_SDA_MISO_PIN) */
N
N#if (SPI_1_CARD_RTS_SS0_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_CHECK_RTS_SS0_PIN_USED \
S                (SPI_1_CARD_PIN_DM_ALG_HIZ != \
S                    SPI_1_CARD_GET_P4_PIN_DM(SPI_1_CARD_uart_rts_spi_ss0_PC, \
S                                                   SPI_1_CARD_uart_rts_spi_ss0_SHIFT))
X    #define SPI_1_CARD_CHECK_RTS_SS0_PIN_USED                 (SPI_1_CARD_PIN_DM_ALG_HIZ !=                     SPI_1_CARD_GET_P4_PIN_DM(SPI_1_CARD_uart_rts_spi_ss0_PC,                                                    SPI_1_CARD_uart_rts_spi_ss0_SHIFT))
N#endif /* (SPI_1_CARD_RTS_SS0_PIN) */
N
N/* Set bits-mask in register */
N#define SPI_1_CARD_SET_REGISTER_BITS(reg, mask, pos, mode) \
N                    do                                           \
N                    {                                            \
N                        (reg) = (((reg) & ((uint32) ~(uint32) (mask))) | ((uint32) ((uint32) (mode) << (pos)))); \
N                    }while(0)
X#define SPI_1_CARD_SET_REGISTER_BITS(reg, mask, pos, mode)                     do                                                               {                                                                    (reg) = (((reg) & ((uint32) ~(uint32) (mask))) | ((uint32) ((uint32) (mode) << (pos))));                     }while(0)
N
N/* Set bit in the register */
N#define SPI_1_CARD_SET_REGISTER_BIT(reg, mask, val) \
N                    ((val) ? ((reg) |= (mask)) : ((reg) &= ((uint32) ~((uint32) (mask)))))
X#define SPI_1_CARD_SET_REGISTER_BIT(reg, mask, val)                     ((val) ? ((reg) |= (mask)) : ((reg) &= ((uint32) ~((uint32) (mask)))))
N
N#define SPI_1_CARD_SET_HSIOM_SEL(reg, mask, pos, sel) SPI_1_CARD_SET_REGISTER_BITS(reg, mask, pos, sel)
N#define SPI_1_CARD_SET_INCFG_TYPE(reg, mask, pos, intType) \
N                                                        SPI_1_CARD_SET_REGISTER_BITS(reg, mask, pos, intType)
X#define SPI_1_CARD_SET_INCFG_TYPE(reg, mask, pos, intType)                                                         SPI_1_CARD_SET_REGISTER_BITS(reg, mask, pos, intType)
N#define SPI_1_CARD_SET_INP_DIS(reg, mask, val) SPI_1_CARD_SET_REGISTER_BIT(reg, mask, val)
N
N/* SPI_1_CARD_SET_I2C_SCL_DR(val) - Sets I2C SCL DR register.
N*  SPI_1_CARD_SET_I2C_SCL_HSIOM_SEL(sel) - Sets I2C SCL HSIOM settings.
N*/
N/* SCB I2C: scl signal */
N#if (SPI_1_CARD_CY_SCBIP_V0)
X#if ((2 == 0u))
S#if (SPI_1_CARD_I2C_PINS)
S    #define SPI_1_CARD_SET_I2C_SCL_DR(val) SPI_1_CARD_scl_Write(val)
S
S    #define SPI_1_CARD_SET_I2C_SCL_HSIOM_SEL(sel) \
S                          SPI_1_CARD_SET_HSIOM_SEL(SPI_1_CARD_SCL_HSIOM_REG,  \
S                                                         SPI_1_CARD_SCL_HSIOM_MASK, \
S                                                         SPI_1_CARD_SCL_HSIOM_POS,  \
S                                                         (sel))
X    #define SPI_1_CARD_SET_I2C_SCL_HSIOM_SEL(sel)                           SPI_1_CARD_SET_HSIOM_SEL(SPI_1_CARD_SCL_HSIOM_REG,                                                           SPI_1_CARD_SCL_HSIOM_MASK,                                                          SPI_1_CARD_SCL_HSIOM_POS,                                                           (sel))
S    #define SPI_1_CARD_WAIT_SCL_SET_HIGH  (0u == SPI_1_CARD_scl_Read())
S
S/* Unconfigured SCB: scl signal */
S#elif (SPI_1_CARD_RX_WAKE_SCL_MOSI_PIN)
S    #define SPI_1_CARD_SET_I2C_SCL_DR(val) \
S                            SPI_1_CARD_uart_rx_wake_i2c_scl_spi_mosi_Write(val)
X    #define SPI_1_CARD_SET_I2C_SCL_DR(val)                             SPI_1_CARD_uart_rx_wake_i2c_scl_spi_mosi_Write(val)
S
S    #define SPI_1_CARD_SET_I2C_SCL_HSIOM_SEL(sel) \
S                    SPI_1_CARD_SET_HSIOM_SEL(SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_REG,  \
S                                                   SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_MASK, \
S                                                   SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_POS,  \
S                                                   (sel))
X    #define SPI_1_CARD_SET_I2C_SCL_HSIOM_SEL(sel)                     SPI_1_CARD_SET_HSIOM_SEL(SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_REG,                                                     SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_MASK,                                                    SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_POS,                                                     (sel))
S
S    #define SPI_1_CARD_WAIT_SCL_SET_HIGH  (0u == SPI_1_CARD_uart_rx_wake_i2c_scl_spi_mosi_Read())
S
S#elif (SPI_1_CARD_RX_SCL_MOSI_PIN)
S    #define SPI_1_CARD_SET_I2C_SCL_DR(val) \
S                            SPI_1_CARD_uart_rx_i2c_scl_spi_mosi_Write(val)
X    #define SPI_1_CARD_SET_I2C_SCL_DR(val)                             SPI_1_CARD_uart_rx_i2c_scl_spi_mosi_Write(val)
S
S
S    #define SPI_1_CARD_SET_I2C_SCL_HSIOM_SEL(sel) \
S                            SPI_1_CARD_SET_HSIOM_SEL(SPI_1_CARD_RX_SCL_MOSI_HSIOM_REG,  \
S                                                           SPI_1_CARD_RX_SCL_MOSI_HSIOM_MASK, \
S                                                           SPI_1_CARD_RX_SCL_MOSI_HSIOM_POS,  \
S                                                           (sel))
X    #define SPI_1_CARD_SET_I2C_SCL_HSIOM_SEL(sel)                             SPI_1_CARD_SET_HSIOM_SEL(SPI_1_CARD_RX_SCL_MOSI_HSIOM_REG,                                                             SPI_1_CARD_RX_SCL_MOSI_HSIOM_MASK,                                                            SPI_1_CARD_RX_SCL_MOSI_HSIOM_POS,                                                             (sel))
S
S    #define SPI_1_CARD_WAIT_SCL_SET_HIGH  (0u == SPI_1_CARD_uart_rx_i2c_scl_spi_mosi_Read())
S
S#else
S    #define SPI_1_CARD_SET_I2C_SCL_DR(val)        do{ /* Does nothing */ }while(0)
S    #define SPI_1_CARD_SET_I2C_SCL_HSIOM_SEL(sel) do{ /* Does nothing */ }while(0)
S
S    #define SPI_1_CARD_WAIT_SCL_SET_HIGH  (0u)
S#endif /* (SPI_1_CARD_I2C_PINS) */
S
S/* SCB I2C: sda signal */
S#if (SPI_1_CARD_I2C_PINS)
S    #define SPI_1_CARD_WAIT_SDA_SET_HIGH  (0u == SPI_1_CARD_sda_Read())
S/* Unconfigured SCB: sda signal */
S#elif (SPI_1_CARD_TX_SDA_MISO_PIN)
S    #define SPI_1_CARD_WAIT_SDA_SET_HIGH  (0u == SPI_1_CARD_uart_tx_i2c_sda_spi_miso_Read())
S#else
S    #define SPI_1_CARD_WAIT_SDA_SET_HIGH  (0u)
S#endif /* (SPI_1_CARD_MOSI_SCL_RX_PIN) */
N#endif /* (SPI_1_CARD_CY_SCBIP_V0) */
N
N/* Clear UART wakeup source */
N#if (SPI_1_CARD_RX_SCL_MOSI_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_CLEAR_UART_RX_WAKE_INTR        do{ /* Does nothing */ }while(0)
S    
S#elif (SPI_1_CARD_RX_WAKE_SCL_MOSI_PIN)
X#elif ((0u == (1u)))
S    #define SPI_1_CARD_CLEAR_UART_RX_WAKE_INTR \
S            do{                                      \
S                (void) SPI_1_CARD_uart_rx_wake_i2c_scl_spi_mosi_ClearInterrupt(); \
S            }while(0)
X    #define SPI_1_CARD_CLEAR_UART_RX_WAKE_INTR             do{                                                      (void) SPI_1_CARD_uart_rx_wake_i2c_scl_spi_mosi_ClearInterrupt();             }while(0)
S
S#elif(SPI_1_CARD_UART_RX_WAKE_PIN)
X#elif((0u == (1u)))
S    #define SPI_1_CARD_CLEAR_UART_RX_WAKE_INTR \
S            do{                                      \
S                (void) SPI_1_CARD_rx_wake_ClearInterrupt(); \
S            }while(0)
X    #define SPI_1_CARD_CLEAR_UART_RX_WAKE_INTR             do{                                                      (void) SPI_1_CARD_rx_wake_ClearInterrupt();             }while(0)
N#else
N#endif /* (SPI_1_CARD_RX_SCL_MOSI_PIN) */
N
N
N/***************************************
N* The following code is DEPRECATED and
N* must not be used.
N***************************************/
N
N/* Unconfigured pins */
N#define SPI_1_CARD_REMOVE_MOSI_SCL_RX_WAKE_PIN    SPI_1_CARD_REMOVE_RX_WAKE_SCL_MOSI_PIN
N#define SPI_1_CARD_REMOVE_MOSI_SCL_RX_PIN         SPI_1_CARD_REMOVE_RX_SCL_MOSI_PIN
N#define SPI_1_CARD_REMOVE_MISO_SDA_TX_PIN         SPI_1_CARD_REMOVE_TX_SDA_MISO_PIN
N#ifndef SPI_1_CARD_REMOVE_SCLK_PIN
N#define SPI_1_CARD_REMOVE_SCLK_PIN                SPI_1_CARD_REMOVE_CTS_SCLK_PIN
N#endif /* SPI_1_CARD_REMOVE_SCLK_PIN */
N#ifndef SPI_1_CARD_REMOVE_SS0_PIN
N#define SPI_1_CARD_REMOVE_SS0_PIN                 SPI_1_CARD_REMOVE_RTS_SS0_PIN
N#endif /* SPI_1_CARD_REMOVE_SS0_PIN */
N
N/* Unconfigured pins */
N#define SPI_1_CARD_MOSI_SCL_RX_WAKE_PIN   SPI_1_CARD_RX_WAKE_SCL_MOSI_PIN
N#define SPI_1_CARD_MOSI_SCL_RX_PIN        SPI_1_CARD_RX_SCL_MOSI_PIN
N#define SPI_1_CARD_MISO_SDA_TX_PIN        SPI_1_CARD_TX_SDA_MISO_PIN
N#ifndef SPI_1_CARD_SCLK_PIN
N#define SPI_1_CARD_SCLK_PIN               SPI_1_CARD_CTS_SCLK_PIN
N#endif /* SPI_1_CARD_SCLK_PIN */
N#ifndef SPI_1_CARD_SS0_PIN
N#define SPI_1_CARD_SS0_PIN                SPI_1_CARD_RTS_SS0_PIN
N#endif /* SPI_1_CARD_SS0_PIN */
N
N#if (SPI_1_CARD_MOSI_SCL_RX_WAKE_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_MOSI_SCL_RX_WAKE_HSIOM_REG     SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define SPI_1_CARD_MOSI_SCL_RX_WAKE_HSIOM_PTR     SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define SPI_1_CARD_MOSI_SCL_RX_WAKE_HSIOM_MASK    SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define SPI_1_CARD_MOSI_SCL_RX_WAKE_HSIOM_POS     SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_REG
S
S    #define SPI_1_CARD_MOSI_SCL_RX_WAKE_INTCFG_REG    SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define SPI_1_CARD_MOSI_SCL_RX_WAKE_INTCFG_PTR    SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_REG
S
S    #define SPI_1_CARD_MOSI_SCL_RX_WAKE_INTCFG_TYPE_POS   SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_REG
S    #define SPI_1_CARD_MOSI_SCL_RX_WAKE_INTCFG_TYPE_MASK  SPI_1_CARD_RX_WAKE_SCL_MOSI_HSIOM_REG
N#endif /* (SPI_1_CARD_RX_WAKE_SCL_MOSI_PIN) */
N
N#if (SPI_1_CARD_MOSI_SCL_RX_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_MOSI_SCL_RX_HSIOM_REG      SPI_1_CARD_RX_SCL_MOSI_HSIOM_REG
S    #define SPI_1_CARD_MOSI_SCL_RX_HSIOM_PTR      SPI_1_CARD_RX_SCL_MOSI_HSIOM_PTR
S    #define SPI_1_CARD_MOSI_SCL_RX_HSIOM_MASK     SPI_1_CARD_RX_SCL_MOSI_HSIOM_MASK
S    #define SPI_1_CARD_MOSI_SCL_RX_HSIOM_POS      SPI_1_CARD_RX_SCL_MOSI_HSIOM_POS
N#endif /* (SPI_1_CARD_MOSI_SCL_RX_PIN) */
N
N#if (SPI_1_CARD_MISO_SDA_TX_PIN)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_MISO_SDA_TX_HSIOM_REG      SPI_1_CARD_TX_SDA_MISO_HSIOM_REG
S    #define SPI_1_CARD_MISO_SDA_TX_HSIOM_PTR      SPI_1_CARD_TX_SDA_MISO_HSIOM_REG
S    #define SPI_1_CARD_MISO_SDA_TX_HSIOM_MASK     SPI_1_CARD_TX_SDA_MISO_HSIOM_REG
S    #define SPI_1_CARD_MISO_SDA_TX_HSIOM_POS      SPI_1_CARD_TX_SDA_MISO_HSIOM_REG
N#endif /* (SPI_1_CARD_MISO_SDA_TX_PIN_PIN) */
N
N#if (SPI_1_CARD_SCLK_PIN)
X#if ((0u == (1u)))
S    #ifndef SPI_1_CARD_SCLK_HSIOM_REG
S    #define SPI_1_CARD_SCLK_HSIOM_REG     SPI_1_CARD_CTS_SCLK_HSIOM_REG
S    #define SPI_1_CARD_SCLK_HSIOM_PTR     SPI_1_CARD_CTS_SCLK_HSIOM_PTR
S    #define SPI_1_CARD_SCLK_HSIOM_MASK    SPI_1_CARD_CTS_SCLK_HSIOM_MASK
S    #define SPI_1_CARD_SCLK_HSIOM_POS     SPI_1_CARD_CTS_SCLK_HSIOM_POS
S    #endif /* SPI_1_CARD_SCLK_HSIOM_REG */
N#endif /* (SPI_1_CARD_SCLK_PIN) */
N
N#if (SPI_1_CARD_SS0_PIN)
X#if ((0u == (1u)))
S    #ifndef SPI_1_CARD_SS0_HSIOM_REG
S    #define SPI_1_CARD_SS0_HSIOM_REG      SPI_1_CARD_RTS_SS0_HSIOM_REG
S    #define SPI_1_CARD_SS0_HSIOM_PTR      SPI_1_CARD_RTS_SS0_HSIOM_PTR
S    #define SPI_1_CARD_SS0_HSIOM_MASK     SPI_1_CARD_RTS_SS0_HSIOM_MASK
S    #define SPI_1_CARD_SS0_HSIOM_POS      SPI_1_CARD_RTS_SS0_HSIOM_POS
S    #endif /* SPI_1_CARD_SS0_HSIOM_REG */
N#endif /* (SPI_1_CARD_SS0_PIN) */
N
N#define SPI_1_CARD_MOSI_SCL_RX_WAKE_PIN_INDEX SPI_1_CARD_RX_WAKE_SCL_MOSI_PIN_INDEX
N#define SPI_1_CARD_MOSI_SCL_RX_PIN_INDEX      SPI_1_CARD_RX_SCL_MOSI_PIN_INDEX
N#define SPI_1_CARD_MISO_SDA_TX_PIN_INDEX      SPI_1_CARD_TX_SDA_MISO_PIN_INDEX
N#ifndef SPI_1_CARD_SCLK_PIN_INDEX
N#define SPI_1_CARD_SCLK_PIN_INDEX             SPI_1_CARD_CTS_SCLK_PIN_INDEX
N#endif /* SPI_1_CARD_SCLK_PIN_INDEX */
N#ifndef SPI_1_CARD_SS0_PIN_INDEX
N#define SPI_1_CARD_SS0_PIN_INDEX              SPI_1_CARD_RTS_SS0_PIN_INDEX
N#endif /* SPI_1_CARD_SS0_PIN_INDEX */
N
N#define SPI_1_CARD_MOSI_SCL_RX_WAKE_PIN_MASK SPI_1_CARD_RX_WAKE_SCL_MOSI_PIN_MASK
N#define SPI_1_CARD_MOSI_SCL_RX_PIN_MASK      SPI_1_CARD_RX_SCL_MOSI_PIN_MASK
N#define SPI_1_CARD_MISO_SDA_TX_PIN_MASK      SPI_1_CARD_TX_SDA_MISO_PIN_MASK
N#ifndef SPI_1_CARD_SCLK_PIN_MASK
N#define SPI_1_CARD_SCLK_PIN_MASK             SPI_1_CARD_CTS_SCLK_PIN_MASK
N#endif /* SPI_1_CARD_SCLK_PIN_MASK */
N#ifndef SPI_1_CARD_SS0_PIN_MASK
N#define SPI_1_CARD_SS0_PIN_MASK              SPI_1_CARD_RTS_SS0_PIN_MASK
N#endif /* SPI_1_CARD_SS0_PIN_MASK */
N
N#endif /* (CY_SCB_PINS_SPI_1_CARD_H) */
N
N
N/* [] END OF FILE */
L 86 "Generated_Source\PSoC4\SPI_1_CARD.h" 2
N
N#if (SPI_1_CARD_SCB_CLK_INTERNAL)
X#if ((0u == (0u)))
N    #include "SPI_1_CARD_SCBCLK.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_SCBCLK.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_SCBCLK.h
N* Version 2.20
N*
N*  Description:
N*   Provides the function and constant definitions for the clock component.
N*
N*  Note:
N*
N********************************************************************************
N* Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_CLOCK_SPI_1_CARD_SCBCLK_H)
X#if !0L
N#define CY_CLOCK_SPI_1_CARD_SCBCLK_H
N
N#include <cytypes.h>
N#include <cyfitter.h>
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N#if defined CYREG_PERI_DIV_CMD
X#if 1L
N
Nvoid SPI_1_CARD_SCBCLK_StartEx(uint32 alignClkDiv);
N#define SPI_1_CARD_SCBCLK_Start() \
N    SPI_1_CARD_SCBCLK_StartEx(SPI_1_CARD_SCBCLK__PA_DIV_ID)
X#define SPI_1_CARD_SCBCLK_Start()     SPI_1_CARD_SCBCLK_StartEx(SPI_1_CARD_SCBCLK__PA_DIV_ID)
N
N#else
S
Svoid SPI_1_CARD_SCBCLK_Start(void);
S
N#endif/* CYREG_PERI_DIV_CMD */
N
Nvoid SPI_1_CARD_SCBCLK_Stop(void);
N
Nvoid SPI_1_CARD_SCBCLK_SetFractionalDividerRegister(uint16 clkDivider, uint8 clkFractional);
N
Nuint16 SPI_1_CARD_SCBCLK_GetDividerRegister(void);
Nuint8  SPI_1_CARD_SCBCLK_GetFractionalDividerRegister(void);
N
N#define SPI_1_CARD_SCBCLK_Enable()                         SPI_1_CARD_SCBCLK_Start()
N#define SPI_1_CARD_SCBCLK_Disable()                        SPI_1_CARD_SCBCLK_Stop()
N#define SPI_1_CARD_SCBCLK_SetDividerRegister(clkDivider, reset)  \
N    SPI_1_CARD_SCBCLK_SetFractionalDividerRegister((clkDivider), 0u)
X#define SPI_1_CARD_SCBCLK_SetDividerRegister(clkDivider, reset)      SPI_1_CARD_SCBCLK_SetFractionalDividerRegister((clkDivider), 0u)
N#define SPI_1_CARD_SCBCLK_SetDivider(clkDivider)           SPI_1_CARD_SCBCLK_SetDividerRegister((clkDivider), 1u)
N#define SPI_1_CARD_SCBCLK_SetDividerValue(clkDivider)      SPI_1_CARD_SCBCLK_SetDividerRegister((clkDivider) - 1u, 1u)
N
N
N/***************************************
N*             Registers
N***************************************/
N#if defined CYREG_PERI_DIV_CMD
X#if 1L
N
N#define SPI_1_CARD_SCBCLK_DIV_ID     SPI_1_CARD_SCBCLK__DIV_ID
N
N#define SPI_1_CARD_SCBCLK_CMD_REG    (*(reg32 *)CYREG_PERI_DIV_CMD)
N#define SPI_1_CARD_SCBCLK_CTRL_REG   (*(reg32 *)SPI_1_CARD_SCBCLK__CTRL_REGISTER)
N#define SPI_1_CARD_SCBCLK_DIV_REG    (*(reg32 *)SPI_1_CARD_SCBCLK__DIV_REGISTER)
N
N#define SPI_1_CARD_SCBCLK_CMD_DIV_SHIFT          (0u)
N#define SPI_1_CARD_SCBCLK_CMD_PA_DIV_SHIFT       (8u)
N#define SPI_1_CARD_SCBCLK_CMD_DISABLE_SHIFT      (30u)
N#define SPI_1_CARD_SCBCLK_CMD_ENABLE_SHIFT       (31u)
N
N#define SPI_1_CARD_SCBCLK_CMD_DISABLE_MASK       ((uint32)((uint32)1u << SPI_1_CARD_SCBCLK_CMD_DISABLE_SHIFT))
N#define SPI_1_CARD_SCBCLK_CMD_ENABLE_MASK        ((uint32)((uint32)1u << SPI_1_CARD_SCBCLK_CMD_ENABLE_SHIFT))
N
N#define SPI_1_CARD_SCBCLK_DIV_FRAC_MASK  (0x000000F8u)
N#define SPI_1_CARD_SCBCLK_DIV_FRAC_SHIFT (3u)
N#define SPI_1_CARD_SCBCLK_DIV_INT_MASK   (0xFFFFFF00u)
N#define SPI_1_CARD_SCBCLK_DIV_INT_SHIFT  (8u)
N
N#else 
S
S#define SPI_1_CARD_SCBCLK_DIV_REG        (*(reg32 *)SPI_1_CARD_SCBCLK__REGISTER)
S#define SPI_1_CARD_SCBCLK_ENABLE_REG     SPI_1_CARD_SCBCLK_DIV_REG
S#define SPI_1_CARD_SCBCLK_DIV_FRAC_MASK  SPI_1_CARD_SCBCLK__FRAC_MASK
S#define SPI_1_CARD_SCBCLK_DIV_FRAC_SHIFT (16u)
S#define SPI_1_CARD_SCBCLK_DIV_INT_MASK   SPI_1_CARD_SCBCLK__DIVIDER_MASK
S#define SPI_1_CARD_SCBCLK_DIV_INT_SHIFT  (0u)
S
N#endif/* CYREG_PERI_DIV_CMD */
N
N#endif /* !defined(CY_CLOCK_SPI_1_CARD_SCBCLK_H) */
N
N/* [] END OF FILE */
L 89 "Generated_Source\PSoC4\SPI_1_CARD.h" 2
N#endif /* (SPI_1_CARD_SCB_CLK_INTERNAL) */
N
N
N/***************************************
N*       Type Definitions
N***************************************/
N
Ntypedef struct
N{
N    uint8 enableState;
N} SPI_1_CARD_BACKUP_STRUCT;
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
N/**
N* \addtogroup group_general
N* @{
N*/
N
N/* Start and Stop APIs */
Nvoid SPI_1_CARD_Init(void);
Nvoid SPI_1_CARD_Enable(void);
Nvoid SPI_1_CARD_Start(void);
Nvoid SPI_1_CARD_Stop(void);
N
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
N/* Sleep and Wakeup APis */
Nvoid SPI_1_CARD_Sleep(void);
Nvoid SPI_1_CARD_Wakeup(void);
N/** @} power */ 
N
N/**
N* \addtogroup group_interrupt
N* @{
N*/
N#if (SPI_1_CARD_SCB_IRQ_INTERNAL)
X#if ((0u == (1u)))
S    /* Custom interrupt handler */
S    void SPI_1_CARD_SetCustomInterruptHandler(void (*func)(void));
N#endif /* (SPI_1_CARD_SCB_IRQ_INTERNAL) */
N/** @} interrupt */
N
N/* Interface to internal interrupt component */
N#if (SPI_1_CARD_SCB_IRQ_INTERNAL)
X#if ((0u == (1u)))
S    /**
S    * \addtogroup group_interrupt
S    * @{
S    */    
S    /*******************************************************************************
S    * Function Name: SPI_1_CARD_EnableInt
S    ****************************************************************************//**
S    *
S    *  When using an Internal interrupt, this enables the interrupt in the NVIC. 
S    *  When using an external interrupt the API for the interrupt component must 
S    *  be used to enable the interrupt.
S    *
S    *******************************************************************************/
S    #define SPI_1_CARD_EnableInt()    CyIntEnable(SPI_1_CARD_ISR_NUMBER)
S    
S    
S    /*******************************************************************************
S    * Function Name: SPI_1_CARD_DisableInt
S    ****************************************************************************//**
S    *
S    *  When using an Internal interrupt, this disables the interrupt in the NVIC. 
S    *  When using an external interrupt the API for the interrupt component must 
S    *  be used to disable the interrupt.
S    *
S    *******************************************************************************/    
S    #define SPI_1_CARD_DisableInt()   CyIntDisable(SPI_1_CARD_ISR_NUMBER)
S    /** @} interrupt */
S
S    /*******************************************************************************
S    * Function Name: SPI_1_CARD_ClearPendingInt
S    ****************************************************************************//**
S    *
S    *  This function clears the interrupt pending status in the NVIC. 
S    *
S    *******************************************************************************/
S    #define SPI_1_CARD_ClearPendingInt()  CyIntClearPending(SPI_1_CARD_ISR_NUMBER)
N#endif /* (SPI_1_CARD_SCB_IRQ_INTERNAL) */
N
N#if (SPI_1_CARD_UART_RX_WAKEUP_IRQ)
X#if ((0u == (1u)))
S    /*******************************************************************************
S    * Function Name: SPI_1_CARD_RxWakeEnableInt
S    ****************************************************************************//**
S    *
S    *  This function enables the interrupt (RX_WAKE) pending status in the NVIC. 
S    *
S    *******************************************************************************/    
S    #define SPI_1_CARD_RxWakeEnableInt()  CyIntEnable(SPI_1_CARD_RX_WAKE_ISR_NUMBER)
S    
S
S    /*******************************************************************************
S    * Function Name: SPI_1_CARD_RxWakeDisableInt
S    ****************************************************************************//**
S    *
S    *  This function disables the interrupt (RX_WAKE) pending status in the NVIC.  
S    *
S    *******************************************************************************/
S    #define SPI_1_CARD_RxWakeDisableInt() CyIntDisable(SPI_1_CARD_RX_WAKE_ISR_NUMBER)
S    
S    
S    /*******************************************************************************
S    * Function Name: SPI_1_CARD_RxWakeClearPendingInt
S    ****************************************************************************//**
S    *
S    *  This function clears the interrupt (RX_WAKE) pending status in the NVIC. 
S    *
S    *******************************************************************************/    
S    #define SPI_1_CARD_RxWakeClearPendingInt()  CyIntClearPending(SPI_1_CARD_RX_WAKE_ISR_NUMBER)
N#endif /* (SPI_1_CARD_UART_RX_WAKEUP_IRQ) */
N
N/**
N* \addtogroup group_interrupt
N* @{
N*/
N/* Get interrupt cause */
N/*******************************************************************************
N* Function Name: SPI_1_CARD_GetInterruptCause
N****************************************************************************//**
N*
N*  Returns a mask of bits showing the source of the current triggered interrupt. 
N*  This is useful for modes of operation where an interrupt can be generated by 
N*  conditions in multiple interrupt source registers.
N*
N*  \return
N*   Mask with the OR of the following conditions that have been triggered.
N*    - SPI_1_CARD_INTR_CAUSE_MASTER - Interrupt from Master
N*    - SPI_1_CARD_INTR_CAUSE_SLAVE - Interrupt from Slave
N*    - SPI_1_CARD_INTR_CAUSE_TX - Interrupt from TX
N*    - SPI_1_CARD_INTR_CAUSE_RX - Interrupt from RX
N*
N*******************************************************************************/
N#define SPI_1_CARD_GetInterruptCause()    (SPI_1_CARD_INTR_CAUSE_REG)
N
N
N/* APIs to service INTR_RX register */
N/*******************************************************************************
N* Function Name: SPI_1_CARD_GetRxInterruptSource
N****************************************************************************//**
N*
N*  Returns RX interrupt request register. This register contains current status 
N*  of RX interrupt sources.
N*
N*  \return
N*   Current status of RX interrupt sources.
N*   Each constant is a bit field value. The value returned may have multiple 
N*   bits set to indicate the current status.
N*   - SPI_1_CARD_INTR_RX_FIFO_LEVEL - The number of data elements in the 
N      RX FIFO is greater than the value of RX FIFO level.
N*   - SPI_1_CARD_INTR_RX_NOT_EMPTY - Receiver FIFO is not empty.
N*   - SPI_1_CARD_INTR_RX_FULL - Receiver FIFO is full.
N*   - SPI_1_CARD_INTR_RX_OVERFLOW - Attempt to write to a full 
N*     receiver FIFO.
N*   - SPI_1_CARD_INTR_RX_UNDERFLOW - Attempt to read from an empty 
N*     receiver FIFO.
N*   - SPI_1_CARD_INTR_RX_FRAME_ERROR - UART framing error detected.
N*   - SPI_1_CARD_INTR_RX_PARITY_ERROR - UART parity error detected.
N*
N*******************************************************************************/
N#define SPI_1_CARD_GetRxInterruptSource() (SPI_1_CARD_INTR_RX_REG)
N
N
N/*******************************************************************************
N* Function Name: SPI_1_CARD_SetRxInterruptMode
N****************************************************************************//**
N*
N*  Writes RX interrupt mask register. This register configures which bits from 
N*  RX interrupt request register will trigger an interrupt event.
N*
N*  \param interruptMask: RX interrupt sources to be enabled (refer to 
N*   SPI_1_CARD_GetRxInterruptSource() function for bit fields values).
N*
N*******************************************************************************/
N#define SPI_1_CARD_SetRxInterruptMode(interruptMask)     SPI_1_CARD_WRITE_INTR_RX_MASK(interruptMask)
N
N
N/*******************************************************************************
N* Function Name: SPI_1_CARD_GetRxInterruptMode
N****************************************************************************//**
N*
N*  Returns RX interrupt mask register This register specifies which bits from 
N*  RX interrupt request register will trigger an interrupt event.
N*
N*  \return 
N*   RX interrupt sources to be enabled (refer to 
N*   SPI_1_CARD_GetRxInterruptSource() function for bit fields values).
N*
N*******************************************************************************/
N#define SPI_1_CARD_GetRxInterruptMode()   (SPI_1_CARD_INTR_RX_MASK_REG)
N
N
N/*******************************************************************************
N* Function Name: SPI_1_CARD_GetRxInterruptSourceMasked
N****************************************************************************//**
N*
N*  Returns RX interrupt masked request register. This register contains logical
N*  AND of corresponding bits from RX interrupt request and mask registers.
N*  This function is intended to be used in the interrupt service routine to 
N*  identify which of enabled RX interrupt sources cause interrupt event.
N*
N*  \return 
N*   Current status of enabled RX interrupt sources (refer to 
N*   SPI_1_CARD_GetRxInterruptSource() function for bit fields values).
N*
N*******************************************************************************/
N#define SPI_1_CARD_GetRxInterruptSourceMasked()   (SPI_1_CARD_INTR_RX_MASKED_REG)
N
N
N/*******************************************************************************
N* Function Name: SPI_1_CARD_ClearRxInterruptSource
N****************************************************************************//**
N*
N*  Clears RX interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: RX interrupt sources to be cleared (refer to 
N*   SPI_1_CARD_GetRxInterruptSource() function for bit fields values).
N*
N*  \sideeffects 
N*   The side effects are listed in the table below for each 
N*   affected interrupt source. Refer to section RX FIFO interrupt sources for 
N*   detailed description.
N*   - SPI_1_CARD_INTR_RX_FIFO_LEVEL Interrupt source is not cleared when 
N*     the receiver FIFO has more entries than level.
N*   - SPI_1_CARD_INTR_RX_NOT_EMPTY Interrupt source is not cleared when
N*     receiver FIFO is not empty.
N*   - SPI_1_CARD_INTR_RX_FULL Interrupt source is not cleared when 
N*      receiver FIFO is full.
N*
N*******************************************************************************/
N#define SPI_1_CARD_ClearRxInterruptSource(interruptMask)  SPI_1_CARD_CLEAR_INTR_RX(interruptMask)
N
N
N/*******************************************************************************
N* Function Name: SPI_1_CARD_SetRxInterrupt
N****************************************************************************//**
N*
N*  Sets RX interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: RX interrupt sources to set in the RX interrupt request 
N*   register (refer to SPI_1_CARD_GetRxInterruptSource() function for bit 
N*   fields values).
N*
N*******************************************************************************/
N#define SPI_1_CARD_SetRxInterrupt(interruptMask)  SPI_1_CARD_SET_INTR_RX(interruptMask)
N
Nvoid SPI_1_CARD_SetRxFifoLevel(uint32 level);
N
N
N/* APIs to service INTR_TX register */
N/*******************************************************************************
N* Function Name: SPI_1_CARD_GetTxInterruptSource
N****************************************************************************//**
N*
N*  Returns TX interrupt request register. This register contains current status 
N*  of TX interrupt sources.
N* 
N*  \return 
N*   Current status of TX interrupt sources.
N*   Each constant is a bit field value. The value returned may have multiple 
N*   bits set to indicate the current status.
N*   - SPI_1_CARD_INTR_TX_FIFO_LEVEL - The number of data elements in the 
N*     TX FIFO is less than the value of TX FIFO level.
N*   - SPI_1_CARD_INTR_TX_NOT_FULL - Transmitter FIFO is not full.
N*   - SPI_1_CARD_INTR_TX_EMPTY - Transmitter FIFO is empty.
N*   - SPI_1_CARD_INTR_TX_OVERFLOW - Attempt to write to a full 
N*     transmitter FIFO.
N*   - SPI_1_CARD_INTR_TX_UNDERFLOW - Attempt to read from an empty 
N*     transmitter FIFO.
N*   - SPI_1_CARD_INTR_TX_UART_NACK - UART received a NACK in SmartCard 
N*   mode.
N*   - SPI_1_CARD_INTR_TX_UART_DONE - UART transfer is complete. 
N*     All data elements from the TX FIFO are sent.
N*   - SPI_1_CARD_INTR_TX_UART_ARB_LOST - Value on the TX line of the UART
N*     does not match the value on the RX line.
N*
N*******************************************************************************/
N#define SPI_1_CARD_GetTxInterruptSource() (SPI_1_CARD_INTR_TX_REG)
N
N
N/*******************************************************************************
N* Function Name: SPI_1_CARD_SetTxInterruptMode
N****************************************************************************//**
N*
N*  Writes TX interrupt mask register. This register configures which bits from 
N*  TX interrupt request register will trigger an interrupt event.
N*
N*  \param interruptMask: TX interrupt sources to be enabled (refer to 
N*   SPI_1_CARD_GetTxInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define SPI_1_CARD_SetTxInterruptMode(interruptMask)  SPI_1_CARD_WRITE_INTR_TX_MASK(interruptMask)
N
N
N/*******************************************************************************
N* Function Name: SPI_1_CARD_GetTxInterruptMode
N****************************************************************************//**
N*
N*  Returns TX interrupt mask register This register specifies which bits from 
N*  TX interrupt request register will trigger an interrupt event.
N*
N*  \return 
N*   Enabled TX interrupt sources (refer to 
N*   SPI_1_CARD_GetTxInterruptSource() function for bit field values).
N*   
N*******************************************************************************/
N#define SPI_1_CARD_GetTxInterruptMode()   (SPI_1_CARD_INTR_TX_MASK_REG)
N
N
N/*******************************************************************************
N* Function Name: SPI_1_CARD_GetTxInterruptSourceMasked
N****************************************************************************//**
N*
N*  Returns TX interrupt masked request register. This register contains logical
N*  AND of corresponding bits from TX interrupt request and mask registers.
N*  This function is intended to be used in the interrupt service routine to identify 
N*  which of enabled TX interrupt sources cause interrupt event.
N*
N*  \return 
N*   Current status of enabled TX interrupt sources (refer to 
N*   SPI_1_CARD_GetTxInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define SPI_1_CARD_GetTxInterruptSourceMasked()   (SPI_1_CARD_INTR_TX_MASKED_REG)
N
N
N/*******************************************************************************
N* Function Name: SPI_1_CARD_ClearTxInterruptSource
N****************************************************************************//**
N*
N*  Clears TX interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: TX interrupt sources to be cleared (refer to 
N*   SPI_1_CARD_GetTxInterruptSource() function for bit field values).
N*
N*  \sideeffects 
N*   The side effects are listed in the table below for each affected interrupt 
N*   source. Refer to section TX FIFO interrupt sources for detailed description.
N*   - SPI_1_CARD_INTR_TX_FIFO_LEVEL - Interrupt source is not cleared when 
N*     transmitter FIFO has less entries than level.
N*   - SPI_1_CARD_INTR_TX_NOT_FULL - Interrupt source is not cleared when
N*     transmitter FIFO has empty entries.
N*   - SPI_1_CARD_INTR_TX_EMPTY - Interrupt source is not cleared when 
N*     transmitter FIFO is empty.
N*   - SPI_1_CARD_INTR_TX_UNDERFLOW - Interrupt source is not cleared when 
N*     transmitter FIFO is empty and I2C mode with clock stretching is selected. 
N*     Put data into the transmitter FIFO before clearing it. This behavior only 
N*     applicable for PSoC 4100/PSoC 4200 devices.
N*
N*******************************************************************************/
N#define SPI_1_CARD_ClearTxInterruptSource(interruptMask)  SPI_1_CARD_CLEAR_INTR_TX(interruptMask)
N
N
N/*******************************************************************************
N* Function Name: SPI_1_CARD_SetTxInterrupt
N****************************************************************************//**
N*
N*  Sets RX interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: RX interrupt sources to set in the RX interrupt request 
N*   register (refer to SPI_1_CARD_GetRxInterruptSource() function for bit 
N*   fields values).
N*
N*******************************************************************************/
N#define SPI_1_CARD_SetTxInterrupt(interruptMask)  SPI_1_CARD_SET_INTR_TX(interruptMask)
N
Nvoid SPI_1_CARD_SetTxFifoLevel(uint32 level);
N
N
N/* APIs to service INTR_MASTER register */
N/*******************************************************************************
N* Function Name: SPI_1_CARD_GetMasterInterruptSource
N****************************************************************************//**
N*
N*  Returns Master interrupt request register. This register contains current 
N*  status of Master interrupt sources.
N*
N*  \return 
N*   Current status of Master interrupt sources. 
N*   Each constant is a bit field value. The value returned may have multiple 
N*   bits set to indicate the current status.
N*   - SPI_1_CARD_INTR_MASTER_SPI_DONE - SPI master transfer is complete.
N*     Refer to Interrupt sources section for detailed description.
N*   - SPI_1_CARD_INTR_MASTER_I2C_ARB_LOST - I2C master lost arbitration.
N*   - SPI_1_CARD_INTR_MASTER_I2C_NACK - I2C master received negative 
N*    acknowledgement (NAK).
N*   - SPI_1_CARD_INTR_MASTER_I2C_ACK - I2C master received acknowledgement.
N*   - SPI_1_CARD_INTR_MASTER_I2C_STOP - I2C master generated STOP.
N*   - SPI_1_CARD_INTR_MASTER_I2C_BUS_ERROR - I2C master bus error 
N*     (detection of unexpected START or STOP condition).
N*
N*******************************************************************************/
N#define SPI_1_CARD_GetMasterInterruptSource() (SPI_1_CARD_INTR_MASTER_REG)
N
N/*******************************************************************************
N* Function Name: SPI_1_CARD_SetMasterInterruptMode
N****************************************************************************//**
N*
N*  Writes Master interrupt mask register. This register configures which bits 
N*  from Master interrupt request register will trigger an interrupt event.
N*
N*  \param interruptMask: Master interrupt sources to be enabled (refer to 
N*   SPI_1_CARD_GetMasterInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define SPI_1_CARD_SetMasterInterruptMode(interruptMask)  SPI_1_CARD_WRITE_INTR_MASTER_MASK(interruptMask)
N
N/*******************************************************************************
N* Function Name: SPI_1_CARD_GetMasterInterruptMode
N****************************************************************************//**
N*
N*  Returns Master interrupt mask register This register specifies which bits 
N*  from Master interrupt request register will trigger an interrupt event.
N*
N*  \return 
N*   Enabled Master interrupt sources (refer to 
N*   SPI_1_CARD_GetMasterInterruptSource() function for return values).
N*
N*******************************************************************************/
N#define SPI_1_CARD_GetMasterInterruptMode()   (SPI_1_CARD_INTR_MASTER_MASK_REG)
N
N/*******************************************************************************
N* Function Name: SPI_1_CARD_GetMasterInterruptSourceMasked
N****************************************************************************//**
N*
N*  Returns Master interrupt masked request register. This register contains 
N*  logical AND of corresponding bits from Master interrupt request and mask 
N*  registers.
N*  This function is intended to be used in the interrupt service routine to 
N*  identify which of enabled Master interrupt sources cause interrupt event.
N*
N*  \return 
N*   Current status of enabled Master interrupt sources (refer to 
N*   SPI_1_CARD_GetMasterInterruptSource() function for return values).
N*
N*******************************************************************************/
N#define SPI_1_CARD_GetMasterInterruptSourceMasked()   (SPI_1_CARD_INTR_MASTER_MASKED_REG)
N
N/*******************************************************************************
N* Function Name: SPI_1_CARD_ClearMasterInterruptSource
N****************************************************************************//**
N*
N*  Clears Master interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: Master interrupt sources to be cleared (refer to 
N*   SPI_1_CARD_GetMasterInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define SPI_1_CARD_ClearMasterInterruptSource(interruptMask)  SPI_1_CARD_CLEAR_INTR_MASTER(interruptMask)
N
N/*******************************************************************************
N* Function Name: SPI_1_CARD_SetMasterInterrupt
N****************************************************************************//**
N*
N*  Sets Master interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: Master interrupt sources to set in the Master interrupt
N*   request register (refer to SPI_1_CARD_GetMasterInterruptSource() 
N*   function for bit field values).
N*
N*******************************************************************************/
N#define SPI_1_CARD_SetMasterInterrupt(interruptMask)  SPI_1_CARD_SET_INTR_MASTER(interruptMask)
N
N
N/* APIs to service INTR_SLAVE register */
N/*******************************************************************************
N* Function Name: SPI_1_CARD_GetSlaveInterruptSource
N****************************************************************************//**
N*
N*  Returns Slave interrupt request register. This register contains current 
N*  status of Slave interrupt sources.
N*
N*  \return 
N*   Current status of Slave interrupt sources.
N*   Each constant is a bit field value. The value returned may have multiple 
N*   bits set to indicate the current status.
N*   - SPI_1_CARD_INTR_SLAVE_I2C_ARB_LOST - I2C slave lost arbitration: 
N*     the value driven on the SDA line is not the same as the value observed 
N*     on the SDA line.
N*   - SPI_1_CARD_INTR_SLAVE_I2C_NACK - I2C slave received negative 
N*     acknowledgement (NAK).
N*   - SPI_1_CARD_INTR_SLAVE_I2C_ACK - I2C slave received 
N*     acknowledgement (ACK).
N*   - SPI_1_CARD_INTR_SLAVE_I2C_WRITE_STOP - Stop or Repeated Start 
N*     event for write transfer intended for this slave (address matching 
N*     is performed).
N*   - SPI_1_CARD_INTR_SLAVE_I2C_STOP - Stop or Repeated Start event 
N*     for (read or write) transfer intended for this slave (address matching 
N*     is performed).
N*   - SPI_1_CARD_INTR_SLAVE_I2C_START - I2C slave received Start 
N*     condition.
N*   - SPI_1_CARD_INTR_SLAVE_I2C_ADDR_MATCH - I2C slave received matching 
N*     address.
N*   - SPI_1_CARD_INTR_SLAVE_I2C_GENERAL - I2C Slave received general 
N*     call address.
N*   - SPI_1_CARD_INTR_SLAVE_I2C_BUS_ERROR - I2C slave bus error (detection 
N*      of unexpected Start or Stop condition).
N*   - SPI_1_CARD_INTR_SLAVE_SPI_BUS_ERROR - SPI slave select line is 
N*      deselected at an expected time while the SPI transfer.
N*
N*******************************************************************************/
N#define SPI_1_CARD_GetSlaveInterruptSource()  (SPI_1_CARD_INTR_SLAVE_REG)
N
N/*******************************************************************************
N* Function Name: SPI_1_CARD_SetSlaveInterruptMode
N****************************************************************************//**
N*
N*  Writes Slave interrupt mask register. 
N*  This register configures which bits from Slave interrupt request register 
N*  will trigger an interrupt event.
N*
N*  \param interruptMask: Slave interrupt sources to be enabled (refer to 
N*   SPI_1_CARD_GetSlaveInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define SPI_1_CARD_SetSlaveInterruptMode(interruptMask)   SPI_1_CARD_WRITE_INTR_SLAVE_MASK(interruptMask)
N
N/*******************************************************************************
N* Function Name: SPI_1_CARD_GetSlaveInterruptMode
N****************************************************************************//**
N*
N*  Returns Slave interrupt mask register.
N*  This register specifies which bits from Slave interrupt request register 
N*  will trigger an interrupt event.
N*
N*  \return 
N*   Enabled Slave interrupt sources(refer to 
N*   SPI_1_CARD_GetSlaveInterruptSource() function for bit field values).
N*
N*******************************************************************************/
N#define SPI_1_CARD_GetSlaveInterruptMode()    (SPI_1_CARD_INTR_SLAVE_MASK_REG)
N
N/*******************************************************************************
N* Function Name: SPI_1_CARD_GetSlaveInterruptSourceMasked
N****************************************************************************//**
N*
N*  Returns Slave interrupt masked request register. This register contains 
N*  logical AND of corresponding bits from Slave interrupt request and mask 
N*  registers.
N*  This function is intended to be used in the interrupt service routine to 
N*  identify which of enabled Slave interrupt sources cause interrupt event.
N*
N*  \return 
N*   Current status of enabled Slave interrupt sources (refer to 
N*   SPI_1_CARD_GetSlaveInterruptSource() function for return values).
N*
N*******************************************************************************/
N#define SPI_1_CARD_GetSlaveInterruptSourceMasked()    (SPI_1_CARD_INTR_SLAVE_MASKED_REG)
N
N/*******************************************************************************
N* Function Name: SPI_1_CARD_ClearSlaveInterruptSource
N****************************************************************************//**
N*
N*  Clears Slave interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: Slave interrupt sources to be cleared (refer to 
N*   SPI_1_CARD_GetSlaveInterruptSource() function for return values).
N*
N*******************************************************************************/
N#define SPI_1_CARD_ClearSlaveInterruptSource(interruptMask)   SPI_1_CARD_CLEAR_INTR_SLAVE(interruptMask)
N
N/*******************************************************************************
N* Function Name: SPI_1_CARD_SetSlaveInterrupt
N****************************************************************************//**
N*
N*  Sets Slave interrupt sources in the interrupt request register.
N*
N*  \param interruptMask: Slave interrupt sources to set in the Slave interrupt 
N*   request register (refer to SPI_1_CARD_GetSlaveInterruptSource() 
N*   function for return values).
N*
N*******************************************************************************/
N#define SPI_1_CARD_SetSlaveInterrupt(interruptMask)   SPI_1_CARD_SET_INTR_SLAVE(interruptMask)
N
N/** @} interrupt */ 
N
N
N/***************************************
N*     Vars with External Linkage
N***************************************/
N
N/**
N* \addtogroup group_globals
N* @{
N*/
N
N/** SPI_1_CARD_initVar indicates whether the SPI_1_CARD 
N*  component has been initialized. The variable is initialized to 0 
N*  and set to 1 the first time SCB_Start() is called. This allows 
N*  the component to restart without reinitialization after the first 
N*  call to the SPI_1_CARD_Start() routine.
N*
N*  If re-initialization of the component is required, then the 
N*  SPI_1_CARD_Init() function can be called before the 
N*  SPI_1_CARD_Start() or SPI_1_CARD_Enable() function.
N*/
Nextern uint8 SPI_1_CARD_initVar;
N/** @} globals */
N
N/***************************************
N*              Registers
N***************************************/
N
N#define SPI_1_CARD_CTRL_REG               (*(reg32 *) SPI_1_CARD_SCB__CTRL)
N#define SPI_1_CARD_CTRL_PTR               ( (reg32 *) SPI_1_CARD_SCB__CTRL)
N
N#define SPI_1_CARD_STATUS_REG             (*(reg32 *) SPI_1_CARD_SCB__STATUS)
N#define SPI_1_CARD_STATUS_PTR             ( (reg32 *) SPI_1_CARD_SCB__STATUS)
N
N#if (!SPI_1_CARD_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_1_CARD_SPI_CTRL_REG           (*(reg32 *) SPI_1_CARD_SCB__SPI_CTRL)
N    #define SPI_1_CARD_SPI_CTRL_PTR           ( (reg32 *) SPI_1_CARD_SCB__SPI_CTRL)
N
N    #define SPI_1_CARD_SPI_STATUS_REG         (*(reg32 *) SPI_1_CARD_SCB__SPI_STATUS)
N    #define SPI_1_CARD_SPI_STATUS_PTR         ( (reg32 *) SPI_1_CARD_SCB__SPI_STATUS)
N
N    #define SPI_1_CARD_UART_CTRL_REG          (*(reg32 *) SPI_1_CARD_SCB__UART_CTRL)
N    #define SPI_1_CARD_UART_CTRL_PTR          ( (reg32 *) SPI_1_CARD_SCB__UART_CTRL)
N
N    #define SPI_1_CARD_UART_TX_CTRL_REG       (*(reg32 *) SPI_1_CARD_SCB__UART_TX_CTRL)
N    #define SPI_1_CARD_UART_TX_CTRL_PTR       ( (reg32 *) SPI_1_CARD_SCB__UART_TX_CTRL)
N
N    #define SPI_1_CARD_UART_RX_CTRL_REG       (*(reg32 *) SPI_1_CARD_SCB__UART_RX_CTRL)
N    #define SPI_1_CARD_UART_RX_CTRL_PTR       ( (reg32 *) SPI_1_CARD_SCB__UART_RX_CTRL)
N
N    #define SPI_1_CARD_UART_RX_STATUS_REG     (*(reg32 *) SPI_1_CARD_SCB__UART_RX_STATUS)
N    #define SPI_1_CARD_UART_RX_STATUS_PTR     ( (reg32 *) SPI_1_CARD_SCB__UART_RX_STATUS)
N#endif /* (!SPI_1_CARD_CY_SCBIP_V1) */
N
N#if !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define SPI_1_CARD_UART_FLOW_CTRL_REG     (*(reg32 *) SPI_1_CARD_SCB__UART_FLOW_CTRL)
N    #define SPI_1_CARD_UART_FLOW_CTRL_PTR     ( (reg32 *) SPI_1_CARD_SCB__UART_FLOW_CTRL)
N#endif /* !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1) */
N
N#define SPI_1_CARD_I2C_CTRL_REG           (*(reg32 *) SPI_1_CARD_SCB__I2C_CTRL)
N#define SPI_1_CARD_I2C_CTRL_PTR           ( (reg32 *) SPI_1_CARD_SCB__I2C_CTRL)
N
N#define SPI_1_CARD_I2C_STATUS_REG         (*(reg32 *) SPI_1_CARD_SCB__I2C_STATUS)
N#define SPI_1_CARD_I2C_STATUS_PTR         ( (reg32 *) SPI_1_CARD_SCB__I2C_STATUS)
N
N#define SPI_1_CARD_I2C_MASTER_CMD_REG     (*(reg32 *) SPI_1_CARD_SCB__I2C_M_CMD)
N#define SPI_1_CARD_I2C_MASTER_CMD_PTR     ( (reg32 *) SPI_1_CARD_SCB__I2C_M_CMD)
N
N#define SPI_1_CARD_I2C_SLAVE_CMD_REG      (*(reg32 *) SPI_1_CARD_SCB__I2C_S_CMD)
N#define SPI_1_CARD_I2C_SLAVE_CMD_PTR      ( (reg32 *) SPI_1_CARD_SCB__I2C_S_CMD)
N
N#define SPI_1_CARD_I2C_CFG_REG            (*(reg32 *) SPI_1_CARD_SCB__I2C_CFG)
N#define SPI_1_CARD_I2C_CFG_PTR            ( (reg32 *) SPI_1_CARD_SCB__I2C_CFG)
N
N#define SPI_1_CARD_TX_CTRL_REG            (*(reg32 *) SPI_1_CARD_SCB__TX_CTRL)
N#define SPI_1_CARD_TX_CTRL_PTR            ( (reg32 *) SPI_1_CARD_SCB__TX_CTRL)
N
N#define SPI_1_CARD_TX_FIFO_CTRL_REG       (*(reg32 *) SPI_1_CARD_SCB__TX_FIFO_CTRL)
N#define SPI_1_CARD_TX_FIFO_CTRL_PTR       ( (reg32 *) SPI_1_CARD_SCB__TX_FIFO_CTRL)
N
N#define SPI_1_CARD_TX_FIFO_STATUS_REG     (*(reg32 *) SPI_1_CARD_SCB__TX_FIFO_STATUS)
N#define SPI_1_CARD_TX_FIFO_STATUS_PTR     ( (reg32 *) SPI_1_CARD_SCB__TX_FIFO_STATUS)
N
N#define SPI_1_CARD_TX_FIFO_WR_REG         (*(reg32 *) SPI_1_CARD_SCB__TX_FIFO_WR)
N#define SPI_1_CARD_TX_FIFO_WR_PTR         ( (reg32 *) SPI_1_CARD_SCB__TX_FIFO_WR)
N
N#define SPI_1_CARD_RX_CTRL_REG            (*(reg32 *) SPI_1_CARD_SCB__RX_CTRL)
N#define SPI_1_CARD_RX_CTRL_PTR            ( (reg32 *) SPI_1_CARD_SCB__RX_CTRL)
N
N#define SPI_1_CARD_RX_FIFO_CTRL_REG       (*(reg32 *) SPI_1_CARD_SCB__RX_FIFO_CTRL)
N#define SPI_1_CARD_RX_FIFO_CTRL_PTR       ( (reg32 *) SPI_1_CARD_SCB__RX_FIFO_CTRL)
N
N#define SPI_1_CARD_RX_FIFO_STATUS_REG     (*(reg32 *) SPI_1_CARD_SCB__RX_FIFO_STATUS)
N#define SPI_1_CARD_RX_FIFO_STATUS_PTR     ( (reg32 *) SPI_1_CARD_SCB__RX_FIFO_STATUS)
N
N#define SPI_1_CARD_RX_MATCH_REG           (*(reg32 *) SPI_1_CARD_SCB__RX_MATCH)
N#define SPI_1_CARD_RX_MATCH_PTR           ( (reg32 *) SPI_1_CARD_SCB__RX_MATCH)
N
N#define SPI_1_CARD_RX_FIFO_RD_REG         (*(reg32 *) SPI_1_CARD_SCB__RX_FIFO_RD)
N#define SPI_1_CARD_RX_FIFO_RD_PTR         ( (reg32 *) SPI_1_CARD_SCB__RX_FIFO_RD)
N
N#define SPI_1_CARD_RX_FIFO_RD_SILENT_REG  (*(reg32 *) SPI_1_CARD_SCB__RX_FIFO_RD_SILENT)
N#define SPI_1_CARD_RX_FIFO_RD_SILENT_PTR  ( (reg32 *) SPI_1_CARD_SCB__RX_FIFO_RD_SILENT)
N
N#ifdef SPI_1_CARD_SCB__EZ_DATA0
N    #define SPI_1_CARD_EZBUF_DATA0_REG    (*(reg32 *) SPI_1_CARD_SCB__EZ_DATA0)
N    #define SPI_1_CARD_EZBUF_DATA0_PTR    ( (reg32 *) SPI_1_CARD_SCB__EZ_DATA0)
N#else
S    #define SPI_1_CARD_EZBUF_DATA0_REG    (*(reg32 *) SPI_1_CARD_SCB__EZ_DATA00)
S    #define SPI_1_CARD_EZBUF_DATA0_PTR    ( (reg32 *) SPI_1_CARD_SCB__EZ_DATA00)
N#endif /* SPI_1_CARD_SCB__EZ_DATA00 */
N
N#define SPI_1_CARD_INTR_CAUSE_REG         (*(reg32 *) SPI_1_CARD_SCB__INTR_CAUSE)
N#define SPI_1_CARD_INTR_CAUSE_PTR         ( (reg32 *) SPI_1_CARD_SCB__INTR_CAUSE)
N
N#define SPI_1_CARD_INTR_I2C_EC_REG        (*(reg32 *) SPI_1_CARD_SCB__INTR_I2C_EC)
N#define SPI_1_CARD_INTR_I2C_EC_PTR        ( (reg32 *) SPI_1_CARD_SCB__INTR_I2C_EC)
N
N#define SPI_1_CARD_INTR_I2C_EC_MASK_REG   (*(reg32 *) SPI_1_CARD_SCB__INTR_I2C_EC_MASK)
N#define SPI_1_CARD_INTR_I2C_EC_MASK_PTR   ( (reg32 *) SPI_1_CARD_SCB__INTR_I2C_EC_MASK)
N
N#define SPI_1_CARD_INTR_I2C_EC_MASKED_REG (*(reg32 *) SPI_1_CARD_SCB__INTR_I2C_EC_MASKED)
N#define SPI_1_CARD_INTR_I2C_EC_MASKED_PTR ( (reg32 *) SPI_1_CARD_SCB__INTR_I2C_EC_MASKED)
N
N#if (!SPI_1_CARD_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_1_CARD_INTR_SPI_EC_REG        (*(reg32 *) SPI_1_CARD_SCB__INTR_SPI_EC)
N    #define SPI_1_CARD_INTR_SPI_EC_PTR        ( (reg32 *) SPI_1_CARD_SCB__INTR_SPI_EC)
N
N    #define SPI_1_CARD_INTR_SPI_EC_MASK_REG   (*(reg32 *) SPI_1_CARD_SCB__INTR_SPI_EC_MASK)
N    #define SPI_1_CARD_INTR_SPI_EC_MASK_PTR   ( (reg32 *) SPI_1_CARD_SCB__INTR_SPI_EC_MASK)
N
N    #define SPI_1_CARD_INTR_SPI_EC_MASKED_REG (*(reg32 *) SPI_1_CARD_SCB__INTR_SPI_EC_MASKED)
N    #define SPI_1_CARD_INTR_SPI_EC_MASKED_PTR ( (reg32 *) SPI_1_CARD_SCB__INTR_SPI_EC_MASKED)
N#endif /* (!SPI_1_CARD_CY_SCBIP_V1) */
N
N#define SPI_1_CARD_INTR_MASTER_REG        (*(reg32 *) SPI_1_CARD_SCB__INTR_M)
N#define SPI_1_CARD_INTR_MASTER_PTR        ( (reg32 *) SPI_1_CARD_SCB__INTR_M)
N
N#define SPI_1_CARD_INTR_MASTER_SET_REG    (*(reg32 *) SPI_1_CARD_SCB__INTR_M_SET)
N#define SPI_1_CARD_INTR_MASTER_SET_PTR    ( (reg32 *) SPI_1_CARD_SCB__INTR_M_SET)
N
N#define SPI_1_CARD_INTR_MASTER_MASK_REG   (*(reg32 *) SPI_1_CARD_SCB__INTR_M_MASK)
N#define SPI_1_CARD_INTR_MASTER_MASK_PTR   ( (reg32 *) SPI_1_CARD_SCB__INTR_M_MASK)
N
N#define SPI_1_CARD_INTR_MASTER_MASKED_REG (*(reg32 *) SPI_1_CARD_SCB__INTR_M_MASKED)
N#define SPI_1_CARD_INTR_MASTER_MASKED_PTR ( (reg32 *) SPI_1_CARD_SCB__INTR_M_MASKED)
N
N#define SPI_1_CARD_INTR_SLAVE_REG         (*(reg32 *) SPI_1_CARD_SCB__INTR_S)
N#define SPI_1_CARD_INTR_SLAVE_PTR         ( (reg32 *) SPI_1_CARD_SCB__INTR_S)
N
N#define SPI_1_CARD_INTR_SLAVE_SET_REG     (*(reg32 *) SPI_1_CARD_SCB__INTR_S_SET)
N#define SPI_1_CARD_INTR_SLAVE_SET_PTR     ( (reg32 *) SPI_1_CARD_SCB__INTR_S_SET)
N
N#define SPI_1_CARD_INTR_SLAVE_MASK_REG    (*(reg32 *) SPI_1_CARD_SCB__INTR_S_MASK)
N#define SPI_1_CARD_INTR_SLAVE_MASK_PTR    ( (reg32 *) SPI_1_CARD_SCB__INTR_S_MASK)
N
N#define SPI_1_CARD_INTR_SLAVE_MASKED_REG  (*(reg32 *) SPI_1_CARD_SCB__INTR_S_MASKED)
N#define SPI_1_CARD_INTR_SLAVE_MASKED_PTR  ( (reg32 *) SPI_1_CARD_SCB__INTR_S_MASKED)
N
N#define SPI_1_CARD_INTR_TX_REG            (*(reg32 *) SPI_1_CARD_SCB__INTR_TX)
N#define SPI_1_CARD_INTR_TX_PTR            ( (reg32 *) SPI_1_CARD_SCB__INTR_TX)
N
N#define SPI_1_CARD_INTR_TX_SET_REG        (*(reg32 *) SPI_1_CARD_SCB__INTR_TX_SET)
N#define SPI_1_CARD_INTR_TX_SET_PTR        ( (reg32 *) SPI_1_CARD_SCB__INTR_TX_SET)
N
N#define SPI_1_CARD_INTR_TX_MASK_REG       (*(reg32 *) SPI_1_CARD_SCB__INTR_TX_MASK)
N#define SPI_1_CARD_INTR_TX_MASK_PTR       ( (reg32 *) SPI_1_CARD_SCB__INTR_TX_MASK)
N
N#define SPI_1_CARD_INTR_TX_MASKED_REG     (*(reg32 *) SPI_1_CARD_SCB__INTR_TX_MASKED)
N#define SPI_1_CARD_INTR_TX_MASKED_PTR     ( (reg32 *) SPI_1_CARD_SCB__INTR_TX_MASKED)
N
N#define SPI_1_CARD_INTR_RX_REG            (*(reg32 *) SPI_1_CARD_SCB__INTR_RX)
N#define SPI_1_CARD_INTR_RX_PTR            ( (reg32 *) SPI_1_CARD_SCB__INTR_RX)
N
N#define SPI_1_CARD_INTR_RX_SET_REG        (*(reg32 *) SPI_1_CARD_SCB__INTR_RX_SET)
N#define SPI_1_CARD_INTR_RX_SET_PTR        ( (reg32 *) SPI_1_CARD_SCB__INTR_RX_SET)
N
N#define SPI_1_CARD_INTR_RX_MASK_REG       (*(reg32 *) SPI_1_CARD_SCB__INTR_RX_MASK)
N#define SPI_1_CARD_INTR_RX_MASK_PTR       ( (reg32 *) SPI_1_CARD_SCB__INTR_RX_MASK)
N
N#define SPI_1_CARD_INTR_RX_MASKED_REG     (*(reg32 *) SPI_1_CARD_SCB__INTR_RX_MASKED)
N#define SPI_1_CARD_INTR_RX_MASKED_PTR     ( (reg32 *) SPI_1_CARD_SCB__INTR_RX_MASKED)
N
N/* Defines get from SCB IP parameters. */
N#define SPI_1_CARD_FIFO_SIZE      (8u)  /* TX or RX FIFO size. */
N#define SPI_1_CARD_EZ_DATA_NR     (32u)  /* Number of words in EZ memory. */ 
N#define SPI_1_CARD_ONE_BYTE_WIDTH (8u)            /* Number of bits in one byte. */
N#define SPI_1_CARD_FF_DATA_NR_LOG2_MASK       (0x0Fu)      /* Number of bits to represent a FIFO address. */
N#define SPI_1_CARD_FF_DATA_NR_LOG2_PLUS1_MASK (0x1Fu) /* Number of bits to represent #bytes in FIFO. */
N
N
N/***************************************
N*        Registers Constants
N***************************************/
N
N#if (SPI_1_CARD_SCB_IRQ_INTERNAL)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_ISR_NUMBER     ((uint8) SPI_1_CARD_SCB_IRQ__INTC_NUMBER)
S    #define SPI_1_CARD_ISR_PRIORITY   ((uint8) SPI_1_CARD_SCB_IRQ__INTC_PRIOR_NUM)
N#endif /* (SPI_1_CARD_SCB_IRQ_INTERNAL) */
N
N#if (SPI_1_CARD_UART_RX_WAKEUP_IRQ)
X#if ((0u == (1u)))
S    #define SPI_1_CARD_RX_WAKE_ISR_NUMBER     ((uint8) SPI_1_CARD_RX_WAKEUP_IRQ__INTC_NUMBER)
S    #define SPI_1_CARD_RX_WAKE_ISR_PRIORITY   ((uint8) SPI_1_CARD_RX_WAKEUP_IRQ__INTC_PRIOR_NUM)
N#endif /* (SPI_1_CARD_UART_RX_WAKEUP_IRQ) */
N
N/* SPI_1_CARD_CTRL_REG */
N#define SPI_1_CARD_CTRL_OVS_POS           (0u)  /* [3:0]   Oversampling factor                 */
N#define SPI_1_CARD_CTRL_EC_AM_MODE_POS    (8u)  /* [8]     Externally clocked address match    */
N#define SPI_1_CARD_CTRL_EC_OP_MODE_POS    (9u)  /* [9]     Externally clocked operation mode   */
N#define SPI_1_CARD_CTRL_EZBUF_MODE_POS    (10u) /* [10]    EZ buffer is enabled                */
N#if !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define SPI_1_CARD_CTRL_BYTE_MODE_POS (11u) /* [11]    Determines the number of bits per FIFO data element */
N#endif /* !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1) */
N#define SPI_1_CARD_CTRL_ADDR_ACCEPT_POS   (16u) /* [16]    Put matched address in RX FIFO       */
N#define SPI_1_CARD_CTRL_BLOCK_POS         (17u) /* [17]    Ext and Int logic to resolve collide */
N#define SPI_1_CARD_CTRL_MODE_POS          (24u) /* [25:24] Operation mode                       */
N#define SPI_1_CARD_CTRL_ENABLED_POS       (31u) /* [31]    Enable SCB block                     */
N#define SPI_1_CARD_CTRL_OVS_MASK          ((uint32) 0x0Fu)
N#define SPI_1_CARD_CTRL_EC_AM_MODE        ((uint32) 0x01u << SPI_1_CARD_CTRL_EC_AM_MODE_POS)
N#define SPI_1_CARD_CTRL_EC_OP_MODE        ((uint32) 0x01u << SPI_1_CARD_CTRL_EC_OP_MODE_POS)
N#define SPI_1_CARD_CTRL_EZBUF_MODE        ((uint32) 0x01u << SPI_1_CARD_CTRL_EZBUF_MODE_POS)
N#if !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define SPI_1_CARD_CTRL_BYTE_MODE ((uint32) 0x01u << SPI_1_CARD_CTRL_BYTE_MODE_POS)
N#endif /* !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1) */
N#define SPI_1_CARD_CTRL_ADDR_ACCEPT       ((uint32) 0x01u << SPI_1_CARD_CTRL_ADDR_ACCEPT_POS)
N#define SPI_1_CARD_CTRL_BLOCK             ((uint32) 0x01u << SPI_1_CARD_CTRL_BLOCK_POS)
N#define SPI_1_CARD_CTRL_MODE_MASK         ((uint32) 0x03u << SPI_1_CARD_CTRL_MODE_POS)
N#define SPI_1_CARD_CTRL_MODE_I2C          ((uint32) 0x00u)
N#define SPI_1_CARD_CTRL_MODE_SPI          ((uint32) 0x01u << SPI_1_CARD_CTRL_MODE_POS)
N#define SPI_1_CARD_CTRL_MODE_UART         ((uint32) 0x02u << SPI_1_CARD_CTRL_MODE_POS)
N#define SPI_1_CARD_CTRL_ENABLED           ((uint32) 0x01u << SPI_1_CARD_CTRL_ENABLED_POS)
N
N/* SPI_1_CARD_STATUS_REG */
N#define SPI_1_CARD_STATUS_EC_BUSY_POS     (0u)  /* [0] Bus busy. Externally clocked logic access to EZ memory */
N#define SPI_1_CARD_STATUS_EC_BUSY         ((uint32) 0x0Fu)
N
N/* SPI_1_CARD_SPI_CTRL_REG  */
N#define SPI_1_CARD_SPI_CTRL_CONTINUOUS_POS        (0u)  /* [0]     Continuous or Separated SPI data transfers */
N#define SPI_1_CARD_SPI_CTRL_SELECT_PRECEDE_POS    (1u)  /* [1]     Precedes or coincides start of data frame  */
N#define SPI_1_CARD_SPI_CTRL_CPHA_POS              (2u)  /* [2]     SCLK phase                                 */
N#define SPI_1_CARD_SPI_CTRL_CPOL_POS              (3u)  /* [3]     SCLK polarity                              */
N#define SPI_1_CARD_SPI_CTRL_LATE_MISO_SAMPLE_POS  (4u)  /* [4]     Late MISO sample enabled                   */
N#if !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define SPI_1_CARD_SPI_CTRL_SCLK_CONTINUOUS_POS   (5u)  /* [5]     Enable continuous SCLK generation */
N    #define SPI_1_CARD_SPI_CTRL_SSEL0_POLARITY_POS    (8u)  /* [8]     SS0 polarity                      */
N    #define SPI_1_CARD_SPI_CTRL_SSEL1_POLARITY_POS    (9u)  /* [9]     SS1 polarity                      */
N    #define SPI_1_CARD_SPI_CTRL_SSEL2_POLARITY_POS    (10u) /* [10]    SS2 polarity                      */
N    #define SPI_1_CARD_SPI_CTRL_SSEL3_POLARITY_POS    (11u) /* [11]    SS3 polarity                      */
N#endif /* !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1) */
N#define SPI_1_CARD_SPI_CTRL_LOOPBACK_POS          (16u) /* [16]    Local loop-back control enabled            */
N#define SPI_1_CARD_SPI_CTRL_MODE_POS              (24u) /* [25:24] Submode of SPI operation                   */
N#define SPI_1_CARD_SPI_CTRL_SLAVE_SELECT_POS      (26u) /* [27:26] Selects SPI SS signal                      */
N#define SPI_1_CARD_SPI_CTRL_MASTER_MODE_POS       (31u) /* [31]    Master mode enabled                        */
N#define SPI_1_CARD_SPI_CTRL_CONTINUOUS            ((uint32) 0x01u)
N#define SPI_1_CARD_SPI_CTRL_SELECT_PRECEDE        ((uint32) 0x01u << SPI_1_CARD_SPI_CTRL_SELECT_PRECEDE_POS)
N#define SPI_1_CARD_SPI_CTRL_SCLK_MODE_MASK        ((uint32) 0x03u << SPI_1_CARD_SPI_CTRL_CPHA_POS)
N#define SPI_1_CARD_SPI_CTRL_CPHA                  ((uint32) 0x01u << SPI_1_CARD_SPI_CTRL_CPHA_POS)
N#define SPI_1_CARD_SPI_CTRL_CPOL                  ((uint32) 0x01u << SPI_1_CARD_SPI_CTRL_CPOL_POS)
N#define SPI_1_CARD_SPI_CTRL_LATE_MISO_SAMPLE      ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_SPI_CTRL_LATE_MISO_SAMPLE_POS)
X#define SPI_1_CARD_SPI_CTRL_LATE_MISO_SAMPLE      ((uint32) 0x01u <<                                                                     SPI_1_CARD_SPI_CTRL_LATE_MISO_SAMPLE_POS)
N#if !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define SPI_1_CARD_SPI_CTRL_SCLK_CONTINUOUS  ((uint32) 0x01u << SPI_1_CARD_SPI_CTRL_SCLK_CONTINUOUS_POS)
N    #define SPI_1_CARD_SPI_CTRL_SSEL0_POLARITY   ((uint32) 0x01u << SPI_1_CARD_SPI_CTRL_SSEL0_POLARITY_POS)
N    #define SPI_1_CARD_SPI_CTRL_SSEL1_POLARITY   ((uint32) 0x01u << SPI_1_CARD_SPI_CTRL_SSEL1_POLARITY_POS)
N    #define SPI_1_CARD_SPI_CTRL_SSEL2_POLARITY   ((uint32) 0x01u << SPI_1_CARD_SPI_CTRL_SSEL2_POLARITY_POS)
N    #define SPI_1_CARD_SPI_CTRL_SSEL3_POLARITY   ((uint32) 0x01u << SPI_1_CARD_SPI_CTRL_SSEL3_POLARITY_POS)
N    #define SPI_1_CARD_SPI_CTRL_SSEL_POLARITY_MASK ((uint32)0x0Fu << SPI_1_CARD_SPI_CTRL_SSEL0_POLARITY_POS)
N#endif /* !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1) */
N
N#define SPI_1_CARD_SPI_CTRL_LOOPBACK              ((uint32) 0x01u << SPI_1_CARD_SPI_CTRL_LOOPBACK_POS)
N#define SPI_1_CARD_SPI_CTRL_MODE_MASK             ((uint32) 0x03u << SPI_1_CARD_SPI_CTRL_MODE_POS)
N#define SPI_1_CARD_SPI_CTRL_MODE_MOTOROLA         ((uint32) 0x00u)
N#define SPI_1_CARD_SPI_CTRL_MODE_TI               ((uint32) 0x01u << SPI_1_CARD_CTRL_MODE_POS)
N#define SPI_1_CARD_SPI_CTRL_MODE_NS               ((uint32) 0x02u << SPI_1_CARD_CTRL_MODE_POS)
N#define SPI_1_CARD_SPI_CTRL_SLAVE_SELECT_MASK     ((uint32) 0x03u << SPI_1_CARD_SPI_CTRL_SLAVE_SELECT_POS)
N#define SPI_1_CARD_SPI_CTRL_SLAVE_SELECT0         ((uint32) 0x00u)
N#define SPI_1_CARD_SPI_CTRL_SLAVE_SELECT1         ((uint32) 0x01u << SPI_1_CARD_SPI_CTRL_SLAVE_SELECT_POS)
N#define SPI_1_CARD_SPI_CTRL_SLAVE_SELECT2         ((uint32) 0x02u << SPI_1_CARD_SPI_CTRL_SLAVE_SELECT_POS)
N#define SPI_1_CARD_SPI_CTRL_SLAVE_SELECT3         ((uint32) 0x03u << SPI_1_CARD_SPI_CTRL_SLAVE_SELECT_POS)
N#define SPI_1_CARD_SPI_CTRL_MASTER                ((uint32) 0x01u << SPI_1_CARD_SPI_CTRL_MASTER_MODE_POS)
N#define SPI_1_CARD_SPI_CTRL_SLAVE                 ((uint32) 0x00u)
N
N/* SPI_1_CARD_SPI_STATUS_REG  */
N#define SPI_1_CARD_SPI_STATUS_BUS_BUSY_POS    (0u)  /* [0]    Bus busy - slave selected */
N#define SPI_1_CARD_SPI_STATUS_EZBUF_ADDR_POS  (8u)  /* [15:8] EzAddress                 */
N#define SPI_1_CARD_SPI_STATUS_BUS_BUSY        ((uint32) 0x01u)
N#define SPI_1_CARD_SPI_STATUS_EZBUF_ADDR_MASK ((uint32) 0xFFu << SPI_1_CARD_I2C_STATUS_EZBUF_ADDR_POS)
N
N/* SPI_1_CARD_UART_CTRL */
N#define SPI_1_CARD_UART_CTRL_LOOPBACK_POS         (16u) /* [16] Loop-back    */
N#define SPI_1_CARD_UART_CTRL_MODE_POS             (24u) /* [24] UART subMode */
N#define SPI_1_CARD_UART_CTRL_LOOPBACK             ((uint32) 0x01u << SPI_1_CARD_UART_CTRL_LOOPBACK_POS)
N#define SPI_1_CARD_UART_CTRL_MODE_UART_STD        ((uint32) 0x00u)
N#define SPI_1_CARD_UART_CTRL_MODE_UART_SMARTCARD  ((uint32) 0x01u << SPI_1_CARD_UART_CTRL_MODE_POS)
N#define SPI_1_CARD_UART_CTRL_MODE_UART_IRDA       ((uint32) 0x02u << SPI_1_CARD_UART_CTRL_MODE_POS)
N#define SPI_1_CARD_UART_CTRL_MODE_MASK            ((uint32) 0x03u << SPI_1_CARD_UART_CTRL_MODE_POS)
N
N/* SPI_1_CARD_UART_TX_CTRL */
N#define SPI_1_CARD_UART_TX_CTRL_STOP_BITS_POS         (0u)  /* [2:0] Stop bits: (Stop bits + 1) * 0.5 period */
N#define SPI_1_CARD_UART_TX_CTRL_PARITY_POS            (4u)  /* [4]   Parity bit                              */
N#define SPI_1_CARD_UART_TX_CTRL_PARITY_ENABLED_POS    (5u)  /* [5]   Parity enable                           */
N#define SPI_1_CARD_UART_TX_CTRL_RETRY_ON_NACK_POS     (8u)  /* [8]   Smart Card: re-send frame on NACK       */
N#define SPI_1_CARD_UART_TX_CTRL_ONE_STOP_BIT          ((uint32) 0x01u)
N#define SPI_1_CARD_UART_TX_CTRL_ONE_HALF_STOP_BITS    ((uint32) 0x02u)
N#define SPI_1_CARD_UART_TX_CTRL_TWO_STOP_BITS         ((uint32) 0x03u)
N#define SPI_1_CARD_UART_TX_CTRL_STOP_BITS_MASK        ((uint32) 0x07u)
N#define SPI_1_CARD_UART_TX_CTRL_PARITY                ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_UART_TX_CTRL_PARITY_POS)
X#define SPI_1_CARD_UART_TX_CTRL_PARITY                ((uint32) 0x01u <<                                                                     SPI_1_CARD_UART_TX_CTRL_PARITY_POS)
N#define SPI_1_CARD_UART_TX_CTRL_PARITY_ENABLED        ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_UART_TX_CTRL_PARITY_ENABLED_POS)
X#define SPI_1_CARD_UART_TX_CTRL_PARITY_ENABLED        ((uint32) 0x01u <<                                                                     SPI_1_CARD_UART_TX_CTRL_PARITY_ENABLED_POS)
N#define SPI_1_CARD_UART_TX_CTRL_RETRY_ON_NACK         ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_UART_TX_CTRL_RETRY_ON_NACK_POS)
X#define SPI_1_CARD_UART_TX_CTRL_RETRY_ON_NACK         ((uint32) 0x01u <<                                                                     SPI_1_CARD_UART_TX_CTRL_RETRY_ON_NACK_POS)
N
N/* SPI_1_CARD_UART_RX_CTRL */
N#define SPI_1_CARD_UART_RX_CTRL_STOP_BITS_POS             (0u)  /* [2:0] Stop bits: (Stop bits + 1) * 0.5 period*/
N#define SPI_1_CARD_UART_RX_CTRL_PARITY_POS                (4u)  /* [4]   Parity bit                             */
N#define SPI_1_CARD_UART_RX_CTRL_PARITY_ENABLED_POS        (5u)  /* [5]   Parity enable                          */
N#define SPI_1_CARD_UART_RX_CTRL_POLARITY_POS              (6u)  /* [6]   IrDA: inverts polarity of RX signal    */
N#define SPI_1_CARD_UART_RX_CTRL_DROP_ON_PARITY_ERR_POS    (8u)  /* [8]   Drop and lost RX FIFO on parity error  */
N#define SPI_1_CARD_UART_RX_CTRL_DROP_ON_FRAME_ERR_POS     (9u)  /* [9]   Drop and lost RX FIFO on frame error   */
N#define SPI_1_CARD_UART_RX_CTRL_MP_MODE_POS               (10u) /* [10]  Multi-processor mode                   */
N#define SPI_1_CARD_UART_RX_CTRL_LIN_MODE_POS              (12u) /* [12]  Lin mode: applicable for UART Standard */
N#define SPI_1_CARD_UART_RX_CTRL_SKIP_START_POS            (13u) /* [13]  Skip start not: only for UART Standard */
N#define SPI_1_CARD_UART_RX_CTRL_BREAK_WIDTH_POS           (16u) /* [19:16]  Break width: (Break width + 1)      */
N#define SPI_1_CARD_UART_TX_CTRL_ONE_STOP_BIT              ((uint32) 0x01u)
N#define SPI_1_CARD_UART_TX_CTRL_ONE_HALF_STOP_BITS        ((uint32) 0x02u)
N#define SPI_1_CARD_UART_TX_CTRL_TWO_STOP_BITS             ((uint32) 0x03u)
N#define SPI_1_CARD_UART_RX_CTRL_STOP_BITS_MASK            ((uint32) 0x07u)
N#define SPI_1_CARD_UART_RX_CTRL_PARITY                    ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_UART_RX_CTRL_PARITY_POS)
X#define SPI_1_CARD_UART_RX_CTRL_PARITY                    ((uint32) 0x01u <<                                                                     SPI_1_CARD_UART_RX_CTRL_PARITY_POS)
N#define SPI_1_CARD_UART_RX_CTRL_PARITY_ENABLED            ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_UART_RX_CTRL_PARITY_ENABLED_POS)
X#define SPI_1_CARD_UART_RX_CTRL_PARITY_ENABLED            ((uint32) 0x01u <<                                                                     SPI_1_CARD_UART_RX_CTRL_PARITY_ENABLED_POS)
N#define SPI_1_CARD_UART_RX_CTRL_POLARITY                  ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_UART_RX_CTRL_POLARITY_POS)
X#define SPI_1_CARD_UART_RX_CTRL_POLARITY                  ((uint32) 0x01u <<                                                                     SPI_1_CARD_UART_RX_CTRL_POLARITY_POS)
N#define SPI_1_CARD_UART_RX_CTRL_DROP_ON_PARITY_ERR        ((uint32) 0x01u << \
N                                                                   SPI_1_CARD_UART_RX_CTRL_DROP_ON_PARITY_ERR_POS)
X#define SPI_1_CARD_UART_RX_CTRL_DROP_ON_PARITY_ERR        ((uint32) 0x01u <<                                                                    SPI_1_CARD_UART_RX_CTRL_DROP_ON_PARITY_ERR_POS)
N#define SPI_1_CARD_UART_RX_CTRL_DROP_ON_FRAME_ERR         ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_UART_RX_CTRL_DROP_ON_FRAME_ERR_POS)
X#define SPI_1_CARD_UART_RX_CTRL_DROP_ON_FRAME_ERR         ((uint32) 0x01u <<                                                                     SPI_1_CARD_UART_RX_CTRL_DROP_ON_FRAME_ERR_POS)
N#define SPI_1_CARD_UART_RX_CTRL_MP_MODE                   ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_UART_RX_CTRL_MP_MODE_POS)
X#define SPI_1_CARD_UART_RX_CTRL_MP_MODE                   ((uint32) 0x01u <<                                                                     SPI_1_CARD_UART_RX_CTRL_MP_MODE_POS)
N#define SPI_1_CARD_UART_RX_CTRL_LIN_MODE                  ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_UART_RX_CTRL_LIN_MODE_POS)
X#define SPI_1_CARD_UART_RX_CTRL_LIN_MODE                  ((uint32) 0x01u <<                                                                     SPI_1_CARD_UART_RX_CTRL_LIN_MODE_POS)
N#define SPI_1_CARD_UART_RX_CTRL_SKIP_START                ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_UART_RX_CTRL_SKIP_START_POS)
X#define SPI_1_CARD_UART_RX_CTRL_SKIP_START                ((uint32) 0x01u <<                                                                     SPI_1_CARD_UART_RX_CTRL_SKIP_START_POS)
N#define SPI_1_CARD_UART_RX_CTRL_BREAK_WIDTH_MASK          ((uint32) 0x0Fu << \
N                                                                    SPI_1_CARD_UART_RX_CTRL_BREAK_WIDTH_POS)
X#define SPI_1_CARD_UART_RX_CTRL_BREAK_WIDTH_MASK          ((uint32) 0x0Fu <<                                                                     SPI_1_CARD_UART_RX_CTRL_BREAK_WIDTH_POS)
N/* SPI_1_CARD_UART_RX_STATUS_REG */
N#define SPI_1_CARD_UART_RX_STATUS_BR_COUNTER_POS     (0u)  /* [11:0] Baud Rate counter */
N#define SPI_1_CARD_UART_RX_STATUS_BR_COUNTER_MASK    ((uint32) 0xFFFu)
N
N#if !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    /* SPI_1_CARD_UART_FLOW_CTRL_REG */
N    #define SPI_1_CARD_UART_FLOW_CTRL_TRIGGER_LEVEL_POS    (0u)  /* [7:0] RTS RX FIFO trigger level         */
N    #define SPI_1_CARD_UART_FLOW_CTRL_RTS_POLARITY_POS     (16u) /* [16]  Polarity of the RTS output signal */
N    #define SPI_1_CARD_UART_FLOW_CTRL_CTS_POLARITY_POS     (24u) /* [24]  Polarity of the CTS input signal  */
N    #define SPI_1_CARD_UART_FLOW_CTRL_CTS_ENABLED_POS      (25u) /* [25]  Enable CTS signal                 */
N    #define SPI_1_CARD_UART_FLOW_CTRL_TRIGGER_LEVEL_MASK   ((uint32) SPI_1_CARD_FF_DATA_NR_LOG2_MASK)
N    #define SPI_1_CARD_UART_FLOW_CTRL_RTS_POLARITY         ((uint32) 0x01u << \
N                                                                       SPI_1_CARD_UART_FLOW_CTRL_RTS_POLARITY_POS)
X    #define SPI_1_CARD_UART_FLOW_CTRL_RTS_POLARITY         ((uint32) 0x01u <<                                                                        SPI_1_CARD_UART_FLOW_CTRL_RTS_POLARITY_POS)
N    #define SPI_1_CARD_UART_FLOW_CTRL_CTS_POLARITY         ((uint32) 0x01u << \
N                                                                       SPI_1_CARD_UART_FLOW_CTRL_CTS_POLARITY_POS)
X    #define SPI_1_CARD_UART_FLOW_CTRL_CTS_POLARITY         ((uint32) 0x01u <<                                                                        SPI_1_CARD_UART_FLOW_CTRL_CTS_POLARITY_POS)
N    #define SPI_1_CARD_UART_FLOW_CTRL_CTS_ENABLE           ((uint32) 0x01u << \
N                                                                       SPI_1_CARD_UART_FLOW_CTRL_CTS_ENABLED_POS)
X    #define SPI_1_CARD_UART_FLOW_CTRL_CTS_ENABLE           ((uint32) 0x01u <<                                                                        SPI_1_CARD_UART_FLOW_CTRL_CTS_ENABLED_POS)
N#endif /* !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1) */
N
N/* SPI_1_CARD_I2C_CTRL */
N#define SPI_1_CARD_I2C_CTRL_HIGH_PHASE_OVS_POS           (0u)   /* [3:0] Oversampling factor high: master only */
N#define SPI_1_CARD_I2C_CTRL_LOW_PHASE_OVS_POS            (4u)   /* [7:4] Oversampling factor low:  master only */
N#define SPI_1_CARD_I2C_CTRL_M_READY_DATA_ACK_POS         (8u)   /* [8]   Master ACKs data while RX FIFO != FULL*/
N#define SPI_1_CARD_I2C_CTRL_M_NOT_READY_DATA_NACK_POS    (9u)   /* [9]   Master NACKs data if RX FIFO ==  FULL */
N#define SPI_1_CARD_I2C_CTRL_S_GENERAL_IGNORE_POS         (11u)  /* [11]  Slave ignores General call            */
N#define SPI_1_CARD_I2C_CTRL_S_READY_ADDR_ACK_POS         (12u)  /* [12]  Slave ACKs Address if RX FIFO != FULL */
N#define SPI_1_CARD_I2C_CTRL_S_READY_DATA_ACK_POS         (13u)  /* [13]  Slave ACKs data while RX FIFO == FULL */
N#define SPI_1_CARD_I2C_CTRL_S_NOT_READY_ADDR_NACK_POS    (14u)  /* [14]  Slave NACKs address if RX FIFO == FULL*/
N#define SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK_POS    (15u)  /* [15]  Slave NACKs data if RX FIFO is  FULL  */
N#define SPI_1_CARD_I2C_CTRL_LOOPBACK_POS                 (16u)  /* [16]  Loop-back                             */
N#define SPI_1_CARD_I2C_CTRL_SLAVE_MODE_POS               (30u)  /* [30]  Slave mode enabled                    */
N#define SPI_1_CARD_I2C_CTRL_MASTER_MODE_POS              (31u)  /* [31]  Master mode enabled                   */
N#define SPI_1_CARD_I2C_CTRL_HIGH_PHASE_OVS_MASK  ((uint32) 0x0Fu)
N#define SPI_1_CARD_I2C_CTRL_LOW_PHASE_OVS_MASK   ((uint32) 0x0Fu << \
N                                                                SPI_1_CARD_I2C_CTRL_LOW_PHASE_OVS_POS)
X#define SPI_1_CARD_I2C_CTRL_LOW_PHASE_OVS_MASK   ((uint32) 0x0Fu <<                                                                 SPI_1_CARD_I2C_CTRL_LOW_PHASE_OVS_POS)
N#define SPI_1_CARD_I2C_CTRL_M_READY_DATA_ACK      ((uint32) 0x01u << \
N                                                                SPI_1_CARD_I2C_CTRL_M_READY_DATA_ACK_POS)
X#define SPI_1_CARD_I2C_CTRL_M_READY_DATA_ACK      ((uint32) 0x01u <<                                                                 SPI_1_CARD_I2C_CTRL_M_READY_DATA_ACK_POS)
N#define SPI_1_CARD_I2C_CTRL_M_NOT_READY_DATA_NACK ((uint32) 0x01u << \
N                                                                SPI_1_CARD_I2C_CTRL_M_NOT_READY_DATA_NACK_POS)
X#define SPI_1_CARD_I2C_CTRL_M_NOT_READY_DATA_NACK ((uint32) 0x01u <<                                                                 SPI_1_CARD_I2C_CTRL_M_NOT_READY_DATA_NACK_POS)
N#define SPI_1_CARD_I2C_CTRL_S_GENERAL_IGNORE      ((uint32) 0x01u << \
N                                                                SPI_1_CARD_I2C_CTRL_S_GENERAL_IGNORE_POS)
X#define SPI_1_CARD_I2C_CTRL_S_GENERAL_IGNORE      ((uint32) 0x01u <<                                                                 SPI_1_CARD_I2C_CTRL_S_GENERAL_IGNORE_POS)
N#define SPI_1_CARD_I2C_CTRL_S_READY_ADDR_ACK      ((uint32) 0x01u << \
N                                                                SPI_1_CARD_I2C_CTRL_S_READY_ADDR_ACK_POS)
X#define SPI_1_CARD_I2C_CTRL_S_READY_ADDR_ACK      ((uint32) 0x01u <<                                                                 SPI_1_CARD_I2C_CTRL_S_READY_ADDR_ACK_POS)
N#define SPI_1_CARD_I2C_CTRL_S_READY_DATA_ACK      ((uint32) 0x01u << \
N                                                                SPI_1_CARD_I2C_CTRL_S_READY_DATA_ACK_POS)
X#define SPI_1_CARD_I2C_CTRL_S_READY_DATA_ACK      ((uint32) 0x01u <<                                                                 SPI_1_CARD_I2C_CTRL_S_READY_DATA_ACK_POS)
N#define SPI_1_CARD_I2C_CTRL_S_NOT_READY_ADDR_NACK ((uint32) 0x01u << \
N                                                                SPI_1_CARD_I2C_CTRL_S_NOT_READY_ADDR_NACK_POS)
X#define SPI_1_CARD_I2C_CTRL_S_NOT_READY_ADDR_NACK ((uint32) 0x01u <<                                                                 SPI_1_CARD_I2C_CTRL_S_NOT_READY_ADDR_NACK_POS)
N#define SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK ((uint32) 0x01u << \
N                                                                SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK_POS)
X#define SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK ((uint32) 0x01u <<                                                                 SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK_POS)
N#define SPI_1_CARD_I2C_CTRL_LOOPBACK              ((uint32) 0x01u << \
N                                                                SPI_1_CARD_I2C_CTRL_LOOPBACK_POS)
X#define SPI_1_CARD_I2C_CTRL_LOOPBACK              ((uint32) 0x01u <<                                                                 SPI_1_CARD_I2C_CTRL_LOOPBACK_POS)
N#define SPI_1_CARD_I2C_CTRL_SLAVE_MODE            ((uint32) 0x01u << \
N                                                                SPI_1_CARD_I2C_CTRL_SLAVE_MODE_POS)
X#define SPI_1_CARD_I2C_CTRL_SLAVE_MODE            ((uint32) 0x01u <<                                                                 SPI_1_CARD_I2C_CTRL_SLAVE_MODE_POS)
N#define SPI_1_CARD_I2C_CTRL_MASTER_MODE           ((uint32) 0x01u << \
N                                                                SPI_1_CARD_I2C_CTRL_MASTER_MODE_POS)
X#define SPI_1_CARD_I2C_CTRL_MASTER_MODE           ((uint32) 0x01u <<                                                                 SPI_1_CARD_I2C_CTRL_MASTER_MODE_POS)
N#define SPI_1_CARD_I2C_CTRL_SLAVE_MASTER_MODE_MASK    ((uint32) 0x03u << \
N                                                                SPI_1_CARD_I2C_CTRL_SLAVE_MODE_POS)
X#define SPI_1_CARD_I2C_CTRL_SLAVE_MASTER_MODE_MASK    ((uint32) 0x03u <<                                                                 SPI_1_CARD_I2C_CTRL_SLAVE_MODE_POS)
N
N/* SPI_1_CARD_I2C_STATUS_REG  */
N#define SPI_1_CARD_I2C_STATUS_BUS_BUSY_POS    (0u)  /* [0]    Bus busy: internally clocked */
N#define SPI_1_CARD_I2C_STATUS_S_READ_POS      (4u)  /* [4]    Slave is read by master      */
N#define SPI_1_CARD_I2C_STATUS_M_READ_POS      (5u)  /* [5]    Master reads Slave           */
N#define SPI_1_CARD_I2C_STATUS_EZBUF_ADDR_POS  (8u)  /* [15:8] EZAddress                    */
N#define SPI_1_CARD_I2C_STATUS_BUS_BUSY        ((uint32) 0x01u)
N#define SPI_1_CARD_I2C_STATUS_S_READ          ((uint32) 0x01u << SPI_1_CARD_I2C_STATUS_S_READ_POS)
N#define SPI_1_CARD_I2C_STATUS_M_READ          ((uint32) 0x01u << SPI_1_CARD_I2C_STATUS_M_READ_POS)
N#define SPI_1_CARD_I2C_STATUS_EZBUF_ADDR_MASK ((uint32) 0xFFu << SPI_1_CARD_I2C_STATUS_EZBUF_ADDR_POS)
N
N/* SPI_1_CARD_I2C_MASTER_CMD_REG */
N#define SPI_1_CARD_I2C_MASTER_CMD_M_START_POS             (0u)  /* [0] Master generate Start                */
N#define SPI_1_CARD_I2C_MASTER_CMD_M_START_ON_IDLE_POS     (1u)  /* [1] Master generate Start if bus is free */
N#define SPI_1_CARD_I2C_MASTER_CMD_M_ACK_POS               (2u)  /* [2] Master generate ACK                  */
N#define SPI_1_CARD_I2C_MASTER_CMD_M_NACK_POS              (3u)  /* [3] Master generate NACK                 */
N#define SPI_1_CARD_I2C_MASTER_CMD_M_STOP_POS              (4u)  /* [4] Master generate Stop                 */
N#define SPI_1_CARD_I2C_MASTER_CMD_M_START         ((uint32) 0x01u)
N#define SPI_1_CARD_I2C_MASTER_CMD_M_START_ON_IDLE ((uint32) 0x01u << \
N                                                                   SPI_1_CARD_I2C_MASTER_CMD_M_START_ON_IDLE_POS)
X#define SPI_1_CARD_I2C_MASTER_CMD_M_START_ON_IDLE ((uint32) 0x01u <<                                                                    SPI_1_CARD_I2C_MASTER_CMD_M_START_ON_IDLE_POS)
N#define SPI_1_CARD_I2C_MASTER_CMD_M_ACK           ((uint32) 0x01u << \
N                                                                   SPI_1_CARD_I2C_MASTER_CMD_M_ACK_POS)
X#define SPI_1_CARD_I2C_MASTER_CMD_M_ACK           ((uint32) 0x01u <<                                                                    SPI_1_CARD_I2C_MASTER_CMD_M_ACK_POS)
N#define SPI_1_CARD_I2C_MASTER_CMD_M_NACK          ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_I2C_MASTER_CMD_M_NACK_POS)
X#define SPI_1_CARD_I2C_MASTER_CMD_M_NACK          ((uint32) 0x01u <<                                                                     SPI_1_CARD_I2C_MASTER_CMD_M_NACK_POS)
N#define SPI_1_CARD_I2C_MASTER_CMD_M_STOP          ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_I2C_MASTER_CMD_M_STOP_POS)
X#define SPI_1_CARD_I2C_MASTER_CMD_M_STOP          ((uint32) 0x01u <<                                                                     SPI_1_CARD_I2C_MASTER_CMD_M_STOP_POS)
N
N/* SPI_1_CARD_I2C_SLAVE_CMD_REG  */
N#define SPI_1_CARD_I2C_SLAVE_CMD_S_ACK_POS    (0u)  /* [0] Slave generate ACK  */
N#define SPI_1_CARD_I2C_SLAVE_CMD_S_NACK_POS   (1u)  /* [1] Slave generate NACK */
N#define SPI_1_CARD_I2C_SLAVE_CMD_S_ACK        ((uint32) 0x01u)
N#define SPI_1_CARD_I2C_SLAVE_CMD_S_NACK       ((uint32) 0x01u << SPI_1_CARD_I2C_SLAVE_CMD_S_NACK_POS)
N
N#define SPI_1_CARD_I2C_SLAVE_CMD_S_ACK_POS    (0u)  /* [0] Slave generate ACK  */
N#define SPI_1_CARD_I2C_SLAVE_CMD_S_NACK_POS   (1u)  /* [1] Slave generate NACK */
N#define SPI_1_CARD_I2C_SLAVE_CMD_S_ACK        ((uint32) 0x01u)
N#define SPI_1_CARD_I2C_SLAVE_CMD_S_NACK       ((uint32) 0x01u << SPI_1_CARD_I2C_SLAVE_CMD_S_NACK_POS)
N
N/* SPI_1_CARD_I2C_CFG_REG */
N#if (SPI_1_CARD_CY_SCBIP_V0)
X#if ((2 == 0u))
S#define SPI_1_CARD_I2C_CFG_SDA_FILT_HYS_POS           (0u)  /* [1:0]   Trim bits for the I2C SDA filter         */
S#define SPI_1_CARD_I2C_CFG_SDA_FILT_TRIM_POS          (2u)  /* [3:2]   Trim bits for the I2C SDA filter         */
S#define SPI_1_CARD_I2C_CFG_SCL_FILT_HYS_POS           (4u)  /* [5:4]   Trim bits for the I2C SCL filter         */
S#define SPI_1_CARD_I2C_CFG_SCL_FILT_TRIM_POS          (6u)  /* [7:6]   Trim bits for the I2C SCL filter         */
S#define SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_HYS_POS       (8u)  /* [9:8]   Trim bits for I2C SDA filter output path */
S#define SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_TRIM_POS      (10u) /* [11:10] Trim bits for I2C SDA filter output path */
S#define SPI_1_CARD_I2C_CFG_SDA_FILT_HS_POS            (16u) /* [16]    '0': 50 ns filter, '1': 10 ns filter     */
S#define SPI_1_CARD_I2C_CFG_SDA_FILT_ENABLED_POS       (17u) /* [17]    I2C SDA filter enabled                   */
S#define SPI_1_CARD_I2C_CFG_SCL_FILT_HS_POS            (24u) /* [24]    '0': 50 ns filter, '1': 10 ns filter     */
S#define SPI_1_CARD_I2C_CFG_SCL_FILT_ENABLED_POS       (25u) /* [25]    I2C SCL filter enabled                   */
S#define SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_HS_POS        (26u) /* [26]    '0': 50 ns filter, '1': 10 ns filter     */
S#define SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_ENABLED_POS   (27u) /* [27]    I2C SDA output delay filter enabled      */
S#define SPI_1_CARD_I2C_CFG_SDA_FILT_HYS_MASK          ((uint32) 0x03u)
S#define SPI_1_CARD_I2C_CFG_SDA_FILT_TRIM_MASK         ((uint32) 0x03u << \
S                                                                SPI_1_CARD_I2C_CFG_SDA_FILT_TRIM_POS)
X#define SPI_1_CARD_I2C_CFG_SDA_FILT_TRIM_MASK         ((uint32) 0x03u <<                                                                 SPI_1_CARD_I2C_CFG_SDA_FILT_TRIM_POS)
S#define SPI_1_CARD_I2C_CFG_SCL_FILT_HYS_MASK          ((uint32) 0x03u << \
S                                                                SPI_1_CARD_I2C_CFG_SCL_FILT_HYS_POS)
X#define SPI_1_CARD_I2C_CFG_SCL_FILT_HYS_MASK          ((uint32) 0x03u <<                                                                 SPI_1_CARD_I2C_CFG_SCL_FILT_HYS_POS)
S#define SPI_1_CARD_I2C_CFG_SCL_FILT_TRIM_MASK         ((uint32) 0x03u << \
S                                                                SPI_1_CARD_I2C_CFG_SCL_FILT_TRIM_POS)
X#define SPI_1_CARD_I2C_CFG_SCL_FILT_TRIM_MASK         ((uint32) 0x03u <<                                                                 SPI_1_CARD_I2C_CFG_SCL_FILT_TRIM_POS)
S#define SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_HYS_MASK      ((uint32) 0x03u << \
S                                                                SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_HYS_POS)
X#define SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_HYS_MASK      ((uint32) 0x03u <<                                                                 SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_HYS_POS)
S#define SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_TRIM_MASK     ((uint32) 0x03u << \
S                                                                SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_TRIM_POS)
X#define SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_TRIM_MASK     ((uint32) 0x03u <<                                                                 SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_TRIM_POS)
S#define SPI_1_CARD_I2C_CFG_SDA_FILT_HS                ((uint32) 0x01u << \
S                                                                SPI_1_CARD_I2C_CFG_SDA_FILT_HS_POS)
X#define SPI_1_CARD_I2C_CFG_SDA_FILT_HS                ((uint32) 0x01u <<                                                                 SPI_1_CARD_I2C_CFG_SDA_FILT_HS_POS)
S#define SPI_1_CARD_I2C_CFG_SDA_FILT_ENABLED           ((uint32) 0x01u << \
S                                                                SPI_1_CARD_I2C_CFG_SDA_FILT_ENABLED_POS)
X#define SPI_1_CARD_I2C_CFG_SDA_FILT_ENABLED           ((uint32) 0x01u <<                                                                 SPI_1_CARD_I2C_CFG_SDA_FILT_ENABLED_POS)
S#define SPI_1_CARD_I2C_CFG_SCL_FILT_HS                ((uint32) 0x01u << \
S                                                                SPI_1_CARD_I2C_CFG_SCL_FILT_HS_POS)
X#define SPI_1_CARD_I2C_CFG_SCL_FILT_HS                ((uint32) 0x01u <<                                                                 SPI_1_CARD_I2C_CFG_SCL_FILT_HS_POS)
S#define SPI_1_CARD_I2C_CFG_SCL_FILT_ENABLED           ((uint32) 0x01u << \
S                                                                SPI_1_CARD_I2C_CFG_SCL_FILT_ENABLED_POS)
X#define SPI_1_CARD_I2C_CFG_SCL_FILT_ENABLED           ((uint32) 0x01u <<                                                                 SPI_1_CARD_I2C_CFG_SCL_FILT_ENABLED_POS)
S#define SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_HS            ((uint32) 0x01u << \
S                                                                SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_HS_POS)
X#define SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_HS            ((uint32) 0x01u <<                                                                 SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_HS_POS)
S#define SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_ENABLED       ((uint32) 0x01u << \
S                                                                SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_ENABLED_POS)
X#define SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_ENABLED       ((uint32) 0x01u <<                                                                 SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_ENABLED_POS)
N#else
N#define SPI_1_CARD_I2C_CFG_SDA_IN_FILT_TRIM_POS   (0u)  /* [1:0] Trim bits for "i2c_sda_in" 50 ns filter */
N#define SPI_1_CARD_I2C_CFG_SDA_IN_FILT_SEL_POS    (4u)  /* [4]   "i2c_sda_in" filter delay: 0 ns and 50 ns */
N#define SPI_1_CARD_I2C_CFG_SCL_IN_FILT_TRIM_POS   (8u)  /* [9:8] Trim bits for "i2c_scl_in" 50 ns filter */
N#define SPI_1_CARD_I2C_CFG_SCL_IN_FILT_SEL_POS    (12u) /* [12]  "i2c_scl_in" filter delay: 0 ns and 50 ns */
N#define SPI_1_CARD_I2C_CFG_SDA_OUT_FILT0_TRIM_POS (16u) /* [17:16] Trim bits for "i2c_sda_out" 50 ns filter 0 */
N#define SPI_1_CARD_I2C_CFG_SDA_OUT_FILT1_TRIM_POS (18u) /* [19:18] Trim bits for "i2c_sda_out" 50 ns filter 1 */
N#define SPI_1_CARD_I2C_CFG_SDA_OUT_FILT2_TRIM_POS (20u) /* [21:20] Trim bits for "i2c_sda_out" 50 ns filter 2 */
N#define SPI_1_CARD_I2C_CFG_SDA_OUT_FILT_SEL_POS   (28u) /* [29:28] Cumulative "i2c_sda_out" filter delay: */
N
N#define SPI_1_CARD_I2C_CFG_SDA_IN_FILT_TRIM_MASK  ((uint32) 0x03u)
N#define SPI_1_CARD_I2C_CFG_SDA_IN_FILT_SEL        ((uint32) 0x01u << SPI_1_CARD_I2C_CFG_SDA_IN_FILT_SEL_POS)
N#define SPI_1_CARD_I2C_CFG_SCL_IN_FILT_TRIM_MASK  ((uint32) 0x03u << \
N                                                            SPI_1_CARD_I2C_CFG_SCL_IN_FILT_TRIM_POS)
X#define SPI_1_CARD_I2C_CFG_SCL_IN_FILT_TRIM_MASK  ((uint32) 0x03u <<                                                             SPI_1_CARD_I2C_CFG_SCL_IN_FILT_TRIM_POS)
N#define SPI_1_CARD_I2C_CFG_SCL_IN_FILT_SEL        ((uint32) 0x01u << SPI_1_CARD_I2C_CFG_SCL_IN_FILT_SEL_POS)
N#define SPI_1_CARD_I2C_CFG_SDA_OUT_FILT0_TRIM_MASK ((uint32) 0x03u << \
N                                                            SPI_1_CARD_I2C_CFG_SDA_OUT_FILT0_TRIM_POS)
X#define SPI_1_CARD_I2C_CFG_SDA_OUT_FILT0_TRIM_MASK ((uint32) 0x03u <<                                                             SPI_1_CARD_I2C_CFG_SDA_OUT_FILT0_TRIM_POS)
N#define SPI_1_CARD_I2C_CFG_SDA_OUT_FILT1_TRIM_MASK ((uint32) 0x03u << \
N                                                            SPI_1_CARD_I2C_CFG_SDA_OUT_FILT1_TRIM_POS)
X#define SPI_1_CARD_I2C_CFG_SDA_OUT_FILT1_TRIM_MASK ((uint32) 0x03u <<                                                             SPI_1_CARD_I2C_CFG_SDA_OUT_FILT1_TRIM_POS)
N#define SPI_1_CARD_I2C_CFG_SDA_OUT_FILT2_TRIM_MASK ((uint32) 0x03u << \
N                                                            SPI_1_CARD_I2C_CFG_SDA_OUT_FILT2_TRIM_POS)
X#define SPI_1_CARD_I2C_CFG_SDA_OUT_FILT2_TRIM_MASK ((uint32) 0x03u <<                                                             SPI_1_CARD_I2C_CFG_SDA_OUT_FILT2_TRIM_POS)
N#define SPI_1_CARD_I2C_CFG_SDA_OUT_FILT_SEL_MASK   ((uint32) 0x03u << \
N                                                            SPI_1_CARD_I2C_CFG_SDA_OUT_FILT_SEL_POS)
X#define SPI_1_CARD_I2C_CFG_SDA_OUT_FILT_SEL_MASK   ((uint32) 0x03u <<                                                             SPI_1_CARD_I2C_CFG_SDA_OUT_FILT_SEL_POS)
N#endif /* (SPI_1_CARD_CY_SCBIP_V0) */
N
N
N/* SPI_1_CARD_TX_CTRL_REG */
N#define SPI_1_CARD_TX_CTRL_DATA_WIDTH_POS     (0u)  /* [3:0] Data frame width: (Data width - 1) */
N#define SPI_1_CARD_TX_CTRL_MSB_FIRST_POS      (8u)  /* [8]   MSB first shifter-out             */
N#define SPI_1_CARD_TX_CTRL_ENABLED_POS        (31u) /* [31]  Transmitter enabled               */
N#define SPI_1_CARD_TX_CTRL_DATA_WIDTH_MASK    ((uint32) 0x0Fu)
N#define SPI_1_CARD_TX_CTRL_MSB_FIRST          ((uint32) 0x01u << SPI_1_CARD_TX_CTRL_MSB_FIRST_POS)
N#define SPI_1_CARD_TX_CTRL_LSB_FIRST          ((uint32) 0x00u)
N#define SPI_1_CARD_TX_CTRL_ENABLED            ((uint32) 0x01u << SPI_1_CARD_TX_CTRL_ENABLED_POS)
N
N/* SPI_1_CARD_TX_CTRL_FIFO_REG */
N#define SPI_1_CARD_TX_FIFO_CTRL_TRIGGER_LEVEL_POS     (0u)  /* [2:0] Trigger level                              */
N#define SPI_1_CARD_TX_FIFO_CTRL_CLEAR_POS             (16u) /* [16]  Clear TX FIFO: cleared after set           */
N#define SPI_1_CARD_TX_FIFO_CTRL_FREEZE_POS            (17u) /* [17]  Freeze TX FIFO: HW do not inc read pointer */
N#define SPI_1_CARD_TX_FIFO_CTRL_TRIGGER_LEVEL_MASK    ((uint32) SPI_1_CARD_FF_DATA_NR_LOG2_MASK)
N#define SPI_1_CARD_TX_FIFO_CTRL_CLEAR                 ((uint32) 0x01u << SPI_1_CARD_TX_FIFO_CTRL_CLEAR_POS)
N#define SPI_1_CARD_TX_FIFO_CTRL_FREEZE                ((uint32) 0x01u << SPI_1_CARD_TX_FIFO_CTRL_FREEZE_POS)
N
N/* SPI_1_CARD_TX_FIFO_STATUS_REG */
N#define SPI_1_CARD_TX_FIFO_STATUS_USED_POS    (0u)  /* [3:0]   Amount of entries in TX FIFO */
N#define SPI_1_CARD_TX_FIFO_SR_VALID_POS       (15u) /* [15]    Shifter status of TX FIFO    */
N#define SPI_1_CARD_TX_FIFO_STATUS_RD_PTR_POS  (16u) /* [18:16] TX FIFO read pointer         */
N#define SPI_1_CARD_TX_FIFO_STATUS_WR_PTR_POS  (24u) /* [26:24] TX FIFO write pointer        */
N#define SPI_1_CARD_TX_FIFO_STATUS_USED_MASK   ((uint32) SPI_1_CARD_FF_DATA_NR_LOG2_PLUS1_MASK)
N#define SPI_1_CARD_TX_FIFO_SR_VALID           ((uint32) 0x01u << SPI_1_CARD_TX_FIFO_SR_VALID_POS)
N#define SPI_1_CARD_TX_FIFO_STATUS_RD_PTR_MASK ((uint32) SPI_1_CARD_FF_DATA_NR_LOG2_MASK << \
N                                                                    SPI_1_CARD_TX_FIFO_STATUS_RD_PTR_POS)
X#define SPI_1_CARD_TX_FIFO_STATUS_RD_PTR_MASK ((uint32) SPI_1_CARD_FF_DATA_NR_LOG2_MASK <<                                                                     SPI_1_CARD_TX_FIFO_STATUS_RD_PTR_POS)
N#define SPI_1_CARD_TX_FIFO_STATUS_WR_PTR_MASK ((uint32) SPI_1_CARD_FF_DATA_NR_LOG2_MASK << \
N                                                                    SPI_1_CARD_TX_FIFO_STATUS_WR_PTR_POS)
X#define SPI_1_CARD_TX_FIFO_STATUS_WR_PTR_MASK ((uint32) SPI_1_CARD_FF_DATA_NR_LOG2_MASK <<                                                                     SPI_1_CARD_TX_FIFO_STATUS_WR_PTR_POS)
N
N/* SPI_1_CARD_TX_FIFO_WR_REG */
N#define SPI_1_CARD_TX_FIFO_WR_POS    (0u)  /* [15:0] Data written into TX FIFO */
N#define SPI_1_CARD_TX_FIFO_WR_MASK   ((uint32) 0xFFu)
N
N/* SPI_1_CARD_RX_CTRL_REG */
N#define SPI_1_CARD_RX_CTRL_DATA_WIDTH_POS     (0u)  /* [3:0] Data frame width: (Data width - 1) */
N#define SPI_1_CARD_RX_CTRL_MSB_FIRST_POS      (8u)  /* [8]   MSB first shifter-out             */
N#define SPI_1_CARD_RX_CTRL_MEDIAN_POS         (9u)  /* [9]   Median filter                     */
N#define SPI_1_CARD_RX_CTRL_ENABLED_POS        (31u) /* [31]  Receiver enabled                  */
N#define SPI_1_CARD_RX_CTRL_DATA_WIDTH_MASK    ((uint32) 0x0Fu)
N#define SPI_1_CARD_RX_CTRL_MSB_FIRST          ((uint32) 0x01u << SPI_1_CARD_RX_CTRL_MSB_FIRST_POS)
N#define SPI_1_CARD_RX_CTRL_LSB_FIRST          ((uint32) 0x00u)
N#define SPI_1_CARD_RX_CTRL_MEDIAN             ((uint32) 0x01u << SPI_1_CARD_RX_CTRL_MEDIAN_POS)
N#define SPI_1_CARD_RX_CTRL_ENABLED            ((uint32) 0x01u << SPI_1_CARD_RX_CTRL_ENABLED_POS)
N
N
N/* SPI_1_CARD_RX_FIFO_CTRL_REG */
N#define SPI_1_CARD_RX_FIFO_CTRL_TRIGGER_LEVEL_POS     (0u)   /* [2:0] Trigger level                            */
N#define SPI_1_CARD_RX_FIFO_CTRL_CLEAR_POS             (16u)  /* [16]  Clear RX FIFO: clear after set           */
N#define SPI_1_CARD_RX_FIFO_CTRL_FREEZE_POS            (17u)  /* [17]  Freeze RX FIFO: HW writes has not effect */
N#define SPI_1_CARD_RX_FIFO_CTRL_TRIGGER_LEVEL_MASK    ((uint32) SPI_1_CARD_FF_DATA_NR_LOG2_MASK)
N#define SPI_1_CARD_RX_FIFO_CTRL_CLEAR                 ((uint32) 0x01u << SPI_1_CARD_RX_FIFO_CTRL_CLEAR_POS)
N#define SPI_1_CARD_RX_FIFO_CTRL_FREEZE                ((uint32) 0x01u << SPI_1_CARD_RX_FIFO_CTRL_FREEZE_POS)
N
N/* SPI_1_CARD_RX_FIFO_STATUS_REG */
N#define SPI_1_CARD_RX_FIFO_STATUS_USED_POS    (0u)   /* [3:0]   Amount of entries in RX FIFO */
N#define SPI_1_CARD_RX_FIFO_SR_VALID_POS       (15u)  /* [15]    Shifter status of RX FIFO    */
N#define SPI_1_CARD_RX_FIFO_STATUS_RD_PTR_POS  (16u)  /* [18:16] RX FIFO read pointer         */
N#define SPI_1_CARD_RX_FIFO_STATUS_WR_PTR_POS  (24u)  /* [26:24] RX FIFO write pointer        */
N#define SPI_1_CARD_RX_FIFO_STATUS_USED_MASK   ((uint32) SPI_1_CARD_FF_DATA_NR_LOG2_PLUS1_MASK)
N#define SPI_1_CARD_RX_FIFO_SR_VALID           ((uint32) 0x01u << SPI_1_CARD_RX_FIFO_SR_VALID_POS)
N#define SPI_1_CARD_RX_FIFO_STATUS_RD_PTR_MASK ((uint32) SPI_1_CARD_FF_DATA_NR_LOG2_MASK << \
N                                                                    SPI_1_CARD_RX_FIFO_STATUS_RD_PTR_POS)
X#define SPI_1_CARD_RX_FIFO_STATUS_RD_PTR_MASK ((uint32) SPI_1_CARD_FF_DATA_NR_LOG2_MASK <<                                                                     SPI_1_CARD_RX_FIFO_STATUS_RD_PTR_POS)
N#define SPI_1_CARD_RX_FIFO_STATUS_WR_PTR_MASK ((uint32) SPI_1_CARD_FF_DATA_NR_LOG2_MASK << \
N                                                                    SPI_1_CARD_RX_FIFO_STATUS_WR_PTR_POS)
X#define SPI_1_CARD_RX_FIFO_STATUS_WR_PTR_MASK ((uint32) SPI_1_CARD_FF_DATA_NR_LOG2_MASK <<                                                                     SPI_1_CARD_RX_FIFO_STATUS_WR_PTR_POS)
N
N/* SPI_1_CARD_RX_MATCH_REG */
N#define SPI_1_CARD_RX_MATCH_ADDR_POS     (0u)  /* [7:0]   Slave address                        */
N#define SPI_1_CARD_RX_MATCH_MASK_POS     (16u) /* [23:16] Slave address mask: 0 - doesn't care */
N#define SPI_1_CARD_RX_MATCH_ADDR_MASK    ((uint32) 0xFFu)
N#define SPI_1_CARD_RX_MATCH_MASK_MASK    ((uint32) 0xFFu << SPI_1_CARD_RX_MATCH_MASK_POS)
N
N/* SPI_1_CARD_RX_FIFO_WR_REG */
N#define SPI_1_CARD_RX_FIFO_RD_POS    (0u)  /* [15:0] Data read from RX FIFO */
N#define SPI_1_CARD_RX_FIFO_RD_MASK   ((uint32) 0xFFu)
N
N/* SPI_1_CARD_RX_FIFO_RD_SILENT_REG */
N#define SPI_1_CARD_RX_FIFO_RD_SILENT_POS     (0u)  /* [15:0] Data read from RX FIFO: not remove data from FIFO */
N#define SPI_1_CARD_RX_FIFO_RD_SILENT_MASK    ((uint32) 0xFFu)
N
N/* SPI_1_CARD_RX_FIFO_RD_SILENT_REG */
N#define SPI_1_CARD_RX_FIFO_RD_SILENT_POS     (0u)  /* [15:0] Data read from RX FIFO: not remove data from FIFO */
N#define SPI_1_CARD_RX_FIFO_RD_SILENT_MASK    ((uint32) 0xFFu)
N
N/* SPI_1_CARD_EZBUF_DATA_REG */
N#define SPI_1_CARD_EZBUF_DATA_POS   (0u)  /* [7:0] Data from EZ Memory */
N#define SPI_1_CARD_EZBUF_DATA_MASK  ((uint32) 0xFFu)
N
N/*  SPI_1_CARD_INTR_CAUSE_REG */
N#define SPI_1_CARD_INTR_CAUSE_MASTER_POS  (0u)  /* [0] Master interrupt active                 */
N#define SPI_1_CARD_INTR_CAUSE_SLAVE_POS   (1u)  /* [1] Slave interrupt active                  */
N#define SPI_1_CARD_INTR_CAUSE_TX_POS      (2u)  /* [2] Transmitter interrupt active            */
N#define SPI_1_CARD_INTR_CAUSE_RX_POS      (3u)  /* [3] Receiver interrupt active               */
N#define SPI_1_CARD_INTR_CAUSE_I2C_EC_POS  (4u)  /* [4] Externally clock I2C interrupt active   */
N#define SPI_1_CARD_INTR_CAUSE_SPI_EC_POS  (5u)  /* [5] Externally clocked SPI interrupt active */
N#define SPI_1_CARD_INTR_CAUSE_MASTER      ((uint32) 0x01u)
N#define SPI_1_CARD_INTR_CAUSE_SLAVE       ((uint32) 0x01u << SPI_1_CARD_INTR_CAUSE_SLAVE_POS)
N#define SPI_1_CARD_INTR_CAUSE_TX          ((uint32) 0x01u << SPI_1_CARD_INTR_CAUSE_TX_POS)
N#define SPI_1_CARD_INTR_CAUSE_RX          ((uint32) 0x01u << SPI_1_CARD_INTR_CAUSE_RX_POS)
N#define SPI_1_CARD_INTR_CAUSE_I2C_EC      ((uint32) 0x01u << SPI_1_CARD_INTR_CAUSE_I2C_EC_POS)
N#define SPI_1_CARD_INTR_CAUSE_SPI_EC      ((uint32) 0x01u << SPI_1_CARD_INTR_CAUSE_SPI_EC_POS)
N
N/* SPI_1_CARD_INTR_SPI_EC_REG, SPI_1_CARD_INTR_SPI_EC_MASK_REG, SPI_1_CARD_INTR_SPI_EC_MASKED_REG */
N#define SPI_1_CARD_INTR_SPI_EC_WAKE_UP_POS          (0u)  /* [0] Address match: triggers wakeup of chip */
N#define SPI_1_CARD_INTR_SPI_EC_EZBUF_STOP_POS       (1u)  /* [1] Externally clocked Stop detected       */
N#define SPI_1_CARD_INTR_SPI_EC_EZBUF_WRITE_STOP_POS (2u)  /* [2] Externally clocked Write Stop detected */
N#define SPI_1_CARD_INTR_SPI_EC_WAKE_UP              ((uint32) 0x01u)
N#define SPI_1_CARD_INTR_SPI_EC_EZBUF_STOP           ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_INTR_SPI_EC_EZBUF_STOP_POS)
X#define SPI_1_CARD_INTR_SPI_EC_EZBUF_STOP           ((uint32) 0x01u <<                                                                     SPI_1_CARD_INTR_SPI_EC_EZBUF_STOP_POS)
N#define SPI_1_CARD_INTR_SPI_EC_EZBUF_WRITE_STOP     ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_INTR_SPI_EC_EZBUF_WRITE_STOP_POS)
X#define SPI_1_CARD_INTR_SPI_EC_EZBUF_WRITE_STOP     ((uint32) 0x01u <<                                                                     SPI_1_CARD_INTR_SPI_EC_EZBUF_WRITE_STOP_POS)
N
N/* SPI_1_CARD_INTR_I2C_EC, SPI_1_CARD_INTR_I2C_EC_MASK, SPI_1_CARD_INTR_I2C_EC_MASKED */
N#define SPI_1_CARD_INTR_I2C_EC_WAKE_UP_POS          (0u)  /* [0] Address match: triggers wakeup of chip */
N#define SPI_1_CARD_INTR_I2C_EC_EZBUF_STOP_POS       (1u)  /* [1] Externally clocked Stop detected       */
N#define SPI_1_CARD_INTR_I2C_EC_EZBUF_WRITE_STOP_POS (2u)  /* [2] Externally clocked Write Stop detected */
N#define SPI_1_CARD_INTR_I2C_EC_WAKE_UP              ((uint32) 0x01u)
N#define SPI_1_CARD_INTR_I2C_EC_EZBUF_STOP           ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_INTR_I2C_EC_EZBUF_STOP_POS)
X#define SPI_1_CARD_INTR_I2C_EC_EZBUF_STOP           ((uint32) 0x01u <<                                                                     SPI_1_CARD_INTR_I2C_EC_EZBUF_STOP_POS)
N#define SPI_1_CARD_INTR_I2C_EC_EZBUF_WRITE_STOP     ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_INTR_I2C_EC_EZBUF_WRITE_STOP_POS)
X#define SPI_1_CARD_INTR_I2C_EC_EZBUF_WRITE_STOP     ((uint32) 0x01u <<                                                                     SPI_1_CARD_INTR_I2C_EC_EZBUF_WRITE_STOP_POS)
N
N/* SPI_1_CARD_INTR_MASTER, SPI_1_CARD_INTR_MASTER_SET,
N   SPI_1_CARD_INTR_MASTER_MASK, SPI_1_CARD_INTR_MASTER_MASKED */
N#define SPI_1_CARD_INTR_MASTER_I2C_ARB_LOST_POS   (0u)  /* [0] Master lost arbitration                          */
N#define SPI_1_CARD_INTR_MASTER_I2C_NACK_POS       (1u)  /* [1] Master receives NACK: address or write to slave  */
N#define SPI_1_CARD_INTR_MASTER_I2C_ACK_POS        (2u)  /* [2] Master receives NACK: address or write to slave  */
N#define SPI_1_CARD_INTR_MASTER_I2C_STOP_POS       (4u)  /* [4] Master detects the Stop: only self generated Stop*/
N#define SPI_1_CARD_INTR_MASTER_I2C_BUS_ERROR_POS  (8u)  /* [8] Master detects bus error: misplaced Start or Stop*/
N#define SPI_1_CARD_INTR_MASTER_SPI_DONE_POS       (9u)  /* [9] Master complete transfer: Only for SPI           */
N#define SPI_1_CARD_INTR_MASTER_I2C_ARB_LOST       ((uint32) 0x01u)
N#define SPI_1_CARD_INTR_MASTER_I2C_NACK           ((uint32) 0x01u << SPI_1_CARD_INTR_MASTER_I2C_NACK_POS)
N#define SPI_1_CARD_INTR_MASTER_I2C_ACK            ((uint32) 0x01u << SPI_1_CARD_INTR_MASTER_I2C_ACK_POS)
N#define SPI_1_CARD_INTR_MASTER_I2C_STOP           ((uint32) 0x01u << SPI_1_CARD_INTR_MASTER_I2C_STOP_POS)
N#define SPI_1_CARD_INTR_MASTER_I2C_BUS_ERROR      ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_INTR_MASTER_I2C_BUS_ERROR_POS)
X#define SPI_1_CARD_INTR_MASTER_I2C_BUS_ERROR      ((uint32) 0x01u <<                                                                     SPI_1_CARD_INTR_MASTER_I2C_BUS_ERROR_POS)
N#define SPI_1_CARD_INTR_MASTER_SPI_DONE           ((uint32) 0x01u << SPI_1_CARD_INTR_MASTER_SPI_DONE_POS)
N
N/*
N* SPI_1_CARD_INTR_SLAVE, SPI_1_CARD_INTR_SLAVE_SET,
N* SPI_1_CARD_INTR_SLAVE_MASK, SPI_1_CARD_INTR_SLAVE_MASKED
N*/
N#define SPI_1_CARD_INTR_SLAVE_I2C_ARB_LOST_POS         (0u)  /* [0]  Slave lost arbitration                   */
N#define SPI_1_CARD_INTR_SLAVE_I2C_NACK_POS             (1u)  /* [1]  Slave receives NACK: master reads data   */
N#define SPI_1_CARD_INTR_SLAVE_I2C_ACK_POS              (2u)  /* [2]  Slave receives ACK: master reads data    */
N#define SPI_1_CARD_INTR_SLAVE_I2C_WRITE_STOP_POS       (3u)  /* [3]  Slave detects end of write transaction   */
N#define SPI_1_CARD_INTR_SLAVE_I2C_STOP_POS             (4u)  /* [4]  Slave detects end of transaction intended */
N#define SPI_1_CARD_INTR_SLAVE_I2C_START_POS            (5u)  /* [5]  Slave detects Start                      */
N#define SPI_1_CARD_INTR_SLAVE_I2C_ADDR_MATCH_POS       (6u)  /* [6]  Slave address matches                    */
N#define SPI_1_CARD_INTR_SLAVE_I2C_GENERAL_POS          (7u)  /* [7]  General call received                    */
N#define SPI_1_CARD_INTR_SLAVE_I2C_BUS_ERROR_POS        (8u)  /* [8]  Slave detects bus error                  */
N#define SPI_1_CARD_INTR_SLAVE_SPI_EZBUF_WRITE_STOP_POS (9u)  /* [9]  Slave write complete: Only for SPI       */
N#define SPI_1_CARD_INTR_SLAVE_SPI_EZBUF_STOP_POS       (10u) /* [10] Slave end of transaction: Only for SPI   */
N#define SPI_1_CARD_INTR_SLAVE_SPI_BUS_ERROR_POS        (11u) /* [11] Slave detects bus error: Only for SPI    */
N#define SPI_1_CARD_INTR_SLAVE_I2C_ARB_LOST             ((uint32) 0x01u)
N#define SPI_1_CARD_INTR_SLAVE_I2C_NACK                 ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_INTR_SLAVE_I2C_NACK_POS)
X#define SPI_1_CARD_INTR_SLAVE_I2C_NACK                 ((uint32) 0x01u <<                                                                     SPI_1_CARD_INTR_SLAVE_I2C_NACK_POS)
N#define SPI_1_CARD_INTR_SLAVE_I2C_ACK                  ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_INTR_SLAVE_I2C_ACK_POS)
X#define SPI_1_CARD_INTR_SLAVE_I2C_ACK                  ((uint32) 0x01u <<                                                                     SPI_1_CARD_INTR_SLAVE_I2C_ACK_POS)
N#define SPI_1_CARD_INTR_SLAVE_I2C_WRITE_STOP           ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_INTR_SLAVE_I2C_WRITE_STOP_POS)
X#define SPI_1_CARD_INTR_SLAVE_I2C_WRITE_STOP           ((uint32) 0x01u <<                                                                     SPI_1_CARD_INTR_SLAVE_I2C_WRITE_STOP_POS)
N#define SPI_1_CARD_INTR_SLAVE_I2C_STOP                 ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_INTR_SLAVE_I2C_STOP_POS)
X#define SPI_1_CARD_INTR_SLAVE_I2C_STOP                 ((uint32) 0x01u <<                                                                     SPI_1_CARD_INTR_SLAVE_I2C_STOP_POS)
N#define SPI_1_CARD_INTR_SLAVE_I2C_START                ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_INTR_SLAVE_I2C_START_POS)
X#define SPI_1_CARD_INTR_SLAVE_I2C_START                ((uint32) 0x01u <<                                                                     SPI_1_CARD_INTR_SLAVE_I2C_START_POS)
N#define SPI_1_CARD_INTR_SLAVE_I2C_ADDR_MATCH           ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_INTR_SLAVE_I2C_ADDR_MATCH_POS)
X#define SPI_1_CARD_INTR_SLAVE_I2C_ADDR_MATCH           ((uint32) 0x01u <<                                                                     SPI_1_CARD_INTR_SLAVE_I2C_ADDR_MATCH_POS)
N#define SPI_1_CARD_INTR_SLAVE_I2C_GENERAL              ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_INTR_SLAVE_I2C_GENERAL_POS)
X#define SPI_1_CARD_INTR_SLAVE_I2C_GENERAL              ((uint32) 0x01u <<                                                                     SPI_1_CARD_INTR_SLAVE_I2C_GENERAL_POS)
N#define SPI_1_CARD_INTR_SLAVE_I2C_BUS_ERROR            ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_INTR_SLAVE_I2C_BUS_ERROR_POS)
X#define SPI_1_CARD_INTR_SLAVE_I2C_BUS_ERROR            ((uint32) 0x01u <<                                                                     SPI_1_CARD_INTR_SLAVE_I2C_BUS_ERROR_POS)
N#define SPI_1_CARD_INTR_SLAVE_SPI_EZBUF_WRITE_STOP     ((uint32) 0x01u << \
N                                                                   SPI_1_CARD_INTR_SLAVE_SPI_EZBUF_WRITE_STOP_POS)
X#define SPI_1_CARD_INTR_SLAVE_SPI_EZBUF_WRITE_STOP     ((uint32) 0x01u <<                                                                    SPI_1_CARD_INTR_SLAVE_SPI_EZBUF_WRITE_STOP_POS)
N#define SPI_1_CARD_INTR_SLAVE_SPI_EZBUF_STOP           ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_INTR_SLAVE_SPI_EZBUF_STOP_POS)
X#define SPI_1_CARD_INTR_SLAVE_SPI_EZBUF_STOP           ((uint32) 0x01u <<                                                                     SPI_1_CARD_INTR_SLAVE_SPI_EZBUF_STOP_POS)
N#define SPI_1_CARD_INTR_SLAVE_SPI_BUS_ERROR           ((uint32) 0x01u << \
N                                                                    SPI_1_CARD_INTR_SLAVE_SPI_BUS_ERROR_POS)
X#define SPI_1_CARD_INTR_SLAVE_SPI_BUS_ERROR           ((uint32) 0x01u <<                                                                     SPI_1_CARD_INTR_SLAVE_SPI_BUS_ERROR_POS)
N
N/*
N* SPI_1_CARD_INTR_TX, SPI_1_CARD_INTR_TX_SET,
N* SPI_1_CARD_INTR_TX_MASK, SPI_1_CARD_INTR_TX_MASKED
N*/
N#define SPI_1_CARD_INTR_TX_TRIGGER_POS        (0u)  /* [0]  Trigger on TX FIFO entires                       */
N#define SPI_1_CARD_INTR_TX_NOT_FULL_POS       (1u)  /* [1]  TX FIFO is not full                              */
N#define SPI_1_CARD_INTR_TX_EMPTY_POS          (4u)  /* [4]  TX FIFO is empty                                 */
N#define SPI_1_CARD_INTR_TX_OVERFLOW_POS       (5u)  /* [5]  Attempt to write to a full TX FIFO               */
N#define SPI_1_CARD_INTR_TX_UNDERFLOW_POS      (6u)  /* [6]  Attempt to read from an empty TX FIFO            */
N#define SPI_1_CARD_INTR_TX_BLOCKED_POS        (7u)  /* [7]  No access to the EZ memory                       */
N#define SPI_1_CARD_INTR_TX_UART_NACK_POS      (8u)  /* [8]  UART transmitter received a NACK: SmartCard mode */
N#define SPI_1_CARD_INTR_TX_UART_DONE_POS      (9u)  /* [9]  UART transmitter done even                       */
N#define SPI_1_CARD_INTR_TX_UART_ARB_LOST_POS  (10u) /* [10] UART lost arbitration: LIN or SmartCard          */
N#define SPI_1_CARD_INTR_TX_TRIGGER            ((uint32) 0x01u)
N#define SPI_1_CARD_INTR_TX_FIFO_LEVEL         (SPI_1_CARD_INTR_TX_TRIGGER)
N#define SPI_1_CARD_INTR_TX_NOT_FULL           ((uint32) 0x01u << SPI_1_CARD_INTR_TX_NOT_FULL_POS)
N#define SPI_1_CARD_INTR_TX_EMPTY              ((uint32) 0x01u << SPI_1_CARD_INTR_TX_EMPTY_POS)
N#define SPI_1_CARD_INTR_TX_OVERFLOW           ((uint32) 0x01u << SPI_1_CARD_INTR_TX_OVERFLOW_POS)
N#define SPI_1_CARD_INTR_TX_UNDERFLOW          ((uint32) 0x01u << SPI_1_CARD_INTR_TX_UNDERFLOW_POS)
N#define SPI_1_CARD_INTR_TX_BLOCKED            ((uint32) 0x01u << SPI_1_CARD_INTR_TX_BLOCKED_POS)
N#define SPI_1_CARD_INTR_TX_UART_NACK          ((uint32) 0x01u << SPI_1_CARD_INTR_TX_UART_NACK_POS)
N#define SPI_1_CARD_INTR_TX_UART_DONE          ((uint32) 0x01u << SPI_1_CARD_INTR_TX_UART_DONE_POS)
N#define SPI_1_CARD_INTR_TX_UART_ARB_LOST      ((uint32) 0x01u << SPI_1_CARD_INTR_TX_UART_ARB_LOST_POS)
N
N/*
N* SPI_1_CARD_INTR_RX, SPI_1_CARD_INTR_RX_SET,
N* SPI_1_CARD_INTR_RX_MASK, SPI_1_CARD_INTR_RX_MASKED
N*/
N#define SPI_1_CARD_INTR_RX_TRIGGER_POS        (0u)   /* [0]  Trigger on RX FIFO entires            */
N#define SPI_1_CARD_INTR_RX_NOT_EMPTY_POS      (2u)   /* [2]  RX FIFO is not empty                  */
N#define SPI_1_CARD_INTR_RX_FULL_POS           (3u)   /* [3]  RX FIFO is full                       */
N#define SPI_1_CARD_INTR_RX_OVERFLOW_POS       (5u)   /* [5]  Attempt to write to a full RX FIFO    */
N#define SPI_1_CARD_INTR_RX_UNDERFLOW_POS      (6u)   /* [6]  Attempt to read from an empty RX FIFO */
N#define SPI_1_CARD_INTR_RX_BLOCKED_POS        (7u)   /* [7]  No access to the EZ memory            */
N#define SPI_1_CARD_INTR_RX_FRAME_ERROR_POS    (8u)   /* [8]  Frame error in received data frame    */
N#define SPI_1_CARD_INTR_RX_PARITY_ERROR_POS   (9u)   /* [9]  Parity error in received data frame   */
N#define SPI_1_CARD_INTR_RX_BAUD_DETECT_POS    (10u)  /* [10] LIN baud rate detection is completed   */
N#define SPI_1_CARD_INTR_RX_BREAK_DETECT_POS   (11u)  /* [11] Break detection is successful         */
N#define SPI_1_CARD_INTR_RX_TRIGGER            ((uint32) 0x01u)
N#define SPI_1_CARD_INTR_RX_FIFO_LEVEL         (SPI_1_CARD_INTR_RX_TRIGGER)
N#define SPI_1_CARD_INTR_RX_NOT_EMPTY          ((uint32) 0x01u << SPI_1_CARD_INTR_RX_NOT_EMPTY_POS)
N#define SPI_1_CARD_INTR_RX_FULL               ((uint32) 0x01u << SPI_1_CARD_INTR_RX_FULL_POS)
N#define SPI_1_CARD_INTR_RX_OVERFLOW           ((uint32) 0x01u << SPI_1_CARD_INTR_RX_OVERFLOW_POS)
N#define SPI_1_CARD_INTR_RX_UNDERFLOW          ((uint32) 0x01u << SPI_1_CARD_INTR_RX_UNDERFLOW_POS)
N#define SPI_1_CARD_INTR_RX_BLOCKED            ((uint32) 0x01u << SPI_1_CARD_INTR_RX_BLOCKED_POS)
N#define SPI_1_CARD_INTR_RX_FRAME_ERROR        ((uint32) 0x01u << SPI_1_CARD_INTR_RX_FRAME_ERROR_POS)
N#define SPI_1_CARD_INTR_RX_PARITY_ERROR       ((uint32) 0x01u << SPI_1_CARD_INTR_RX_PARITY_ERROR_POS)
N#define SPI_1_CARD_INTR_RX_BAUD_DETECT        ((uint32) 0x01u << SPI_1_CARD_INTR_RX_BAUD_DETECT_POS)
N#define SPI_1_CARD_INTR_RX_BREAK_DETECT       ((uint32) 0x01u << SPI_1_CARD_INTR_RX_BREAK_DETECT_POS)
N
N/* Define all interrupt sources */
N#define SPI_1_CARD_INTR_I2C_EC_ALL    (SPI_1_CARD_INTR_I2C_EC_WAKE_UP    | \
N                                             SPI_1_CARD_INTR_I2C_EC_EZBUF_STOP | \
N                                             SPI_1_CARD_INTR_I2C_EC_EZBUF_WRITE_STOP)
X#define SPI_1_CARD_INTR_I2C_EC_ALL    (SPI_1_CARD_INTR_I2C_EC_WAKE_UP    |                                              SPI_1_CARD_INTR_I2C_EC_EZBUF_STOP |                                              SPI_1_CARD_INTR_I2C_EC_EZBUF_WRITE_STOP)
N
N#define SPI_1_CARD_INTR_SPI_EC_ALL    (SPI_1_CARD_INTR_SPI_EC_WAKE_UP    | \
N                                             SPI_1_CARD_INTR_SPI_EC_EZBUF_STOP | \
N                                             SPI_1_CARD_INTR_SPI_EC_EZBUF_WRITE_STOP)
X#define SPI_1_CARD_INTR_SPI_EC_ALL    (SPI_1_CARD_INTR_SPI_EC_WAKE_UP    |                                              SPI_1_CARD_INTR_SPI_EC_EZBUF_STOP |                                              SPI_1_CARD_INTR_SPI_EC_EZBUF_WRITE_STOP)
N
N#define SPI_1_CARD_INTR_MASTER_ALL    (SPI_1_CARD_INTR_MASTER_I2C_ARB_LOST  | \
N                                             SPI_1_CARD_INTR_MASTER_I2C_NACK      | \
N                                             SPI_1_CARD_INTR_MASTER_I2C_ACK       | \
N                                             SPI_1_CARD_INTR_MASTER_I2C_STOP      | \
N                                             SPI_1_CARD_INTR_MASTER_I2C_BUS_ERROR | \
N                                             SPI_1_CARD_INTR_MASTER_SPI_DONE)
X#define SPI_1_CARD_INTR_MASTER_ALL    (SPI_1_CARD_INTR_MASTER_I2C_ARB_LOST  |                                              SPI_1_CARD_INTR_MASTER_I2C_NACK      |                                              SPI_1_CARD_INTR_MASTER_I2C_ACK       |                                              SPI_1_CARD_INTR_MASTER_I2C_STOP      |                                              SPI_1_CARD_INTR_MASTER_I2C_BUS_ERROR |                                              SPI_1_CARD_INTR_MASTER_SPI_DONE)
N
N#define SPI_1_CARD_INTR_SLAVE_ALL     (SPI_1_CARD_INTR_SLAVE_I2C_ARB_LOST      | \
N                                             SPI_1_CARD_INTR_SLAVE_I2C_NACK          | \
N                                             SPI_1_CARD_INTR_SLAVE_I2C_ACK           | \
N                                             SPI_1_CARD_INTR_SLAVE_I2C_WRITE_STOP    | \
N                                             SPI_1_CARD_INTR_SLAVE_I2C_STOP          | \
N                                             SPI_1_CARD_INTR_SLAVE_I2C_START         | \
N                                             SPI_1_CARD_INTR_SLAVE_I2C_ADDR_MATCH    | \
N                                             SPI_1_CARD_INTR_SLAVE_I2C_GENERAL       | \
N                                             SPI_1_CARD_INTR_SLAVE_I2C_BUS_ERROR     | \
N                                             SPI_1_CARD_INTR_SLAVE_SPI_EZBUF_WRITE_STOP | \
N                                             SPI_1_CARD_INTR_SLAVE_SPI_EZBUF_STOP       | \
N                                             SPI_1_CARD_INTR_SLAVE_SPI_BUS_ERROR)
X#define SPI_1_CARD_INTR_SLAVE_ALL     (SPI_1_CARD_INTR_SLAVE_I2C_ARB_LOST      |                                              SPI_1_CARD_INTR_SLAVE_I2C_NACK          |                                              SPI_1_CARD_INTR_SLAVE_I2C_ACK           |                                              SPI_1_CARD_INTR_SLAVE_I2C_WRITE_STOP    |                                              SPI_1_CARD_INTR_SLAVE_I2C_STOP          |                                              SPI_1_CARD_INTR_SLAVE_I2C_START         |                                              SPI_1_CARD_INTR_SLAVE_I2C_ADDR_MATCH    |                                              SPI_1_CARD_INTR_SLAVE_I2C_GENERAL       |                                              SPI_1_CARD_INTR_SLAVE_I2C_BUS_ERROR     |                                              SPI_1_CARD_INTR_SLAVE_SPI_EZBUF_WRITE_STOP |                                              SPI_1_CARD_INTR_SLAVE_SPI_EZBUF_STOP       |                                              SPI_1_CARD_INTR_SLAVE_SPI_BUS_ERROR)
N
N#define SPI_1_CARD_INTR_TX_ALL        (SPI_1_CARD_INTR_TX_TRIGGER   | \
N                                             SPI_1_CARD_INTR_TX_NOT_FULL  | \
N                                             SPI_1_CARD_INTR_TX_EMPTY     | \
N                                             SPI_1_CARD_INTR_TX_OVERFLOW  | \
N                                             SPI_1_CARD_INTR_TX_UNDERFLOW | \
N                                             SPI_1_CARD_INTR_TX_BLOCKED   | \
N                                             SPI_1_CARD_INTR_TX_UART_NACK | \
N                                             SPI_1_CARD_INTR_TX_UART_DONE | \
N                                             SPI_1_CARD_INTR_TX_UART_ARB_LOST)
X#define SPI_1_CARD_INTR_TX_ALL        (SPI_1_CARD_INTR_TX_TRIGGER   |                                              SPI_1_CARD_INTR_TX_NOT_FULL  |                                              SPI_1_CARD_INTR_TX_EMPTY     |                                              SPI_1_CARD_INTR_TX_OVERFLOW  |                                              SPI_1_CARD_INTR_TX_UNDERFLOW |                                              SPI_1_CARD_INTR_TX_BLOCKED   |                                              SPI_1_CARD_INTR_TX_UART_NACK |                                              SPI_1_CARD_INTR_TX_UART_DONE |                                              SPI_1_CARD_INTR_TX_UART_ARB_LOST)
N
N#define SPI_1_CARD_INTR_RX_ALL        (SPI_1_CARD_INTR_RX_TRIGGER      | \
N                                             SPI_1_CARD_INTR_RX_NOT_EMPTY    | \
N                                             SPI_1_CARD_INTR_RX_FULL         | \
N                                             SPI_1_CARD_INTR_RX_OVERFLOW     | \
N                                             SPI_1_CARD_INTR_RX_UNDERFLOW    | \
N                                             SPI_1_CARD_INTR_RX_BLOCKED      | \
N                                             SPI_1_CARD_INTR_RX_FRAME_ERROR  | \
N                                             SPI_1_CARD_INTR_RX_PARITY_ERROR | \
N                                             SPI_1_CARD_INTR_RX_BAUD_DETECT  | \
N                                             SPI_1_CARD_INTR_RX_BREAK_DETECT)
X#define SPI_1_CARD_INTR_RX_ALL        (SPI_1_CARD_INTR_RX_TRIGGER      |                                              SPI_1_CARD_INTR_RX_NOT_EMPTY    |                                              SPI_1_CARD_INTR_RX_FULL         |                                              SPI_1_CARD_INTR_RX_OVERFLOW     |                                              SPI_1_CARD_INTR_RX_UNDERFLOW    |                                              SPI_1_CARD_INTR_RX_BLOCKED      |                                              SPI_1_CARD_INTR_RX_FRAME_ERROR  |                                              SPI_1_CARD_INTR_RX_PARITY_ERROR |                                              SPI_1_CARD_INTR_RX_BAUD_DETECT  |                                              SPI_1_CARD_INTR_RX_BREAK_DETECT)
N
N/* I2C and EZI2C slave address defines */
N#define SPI_1_CARD_I2C_SLAVE_ADDR_POS    (0x01u)    /* 7-bit address shift */
N#define SPI_1_CARD_I2C_SLAVE_ADDR_MASK   (0xFEu)    /* 8-bit address mask */
N
N/* OVS constants for IrDA Low Power operation */
N#define SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS16     (0x00u)
N#define SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS32     (0x01u)
N#define SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS48     (0x02u)
N#define SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS96     (0x03u)
N#define SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS192    (0x04u)
N#define SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS768    (0x05u)
N#define SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS1536   (0x06u)
N
N/* OVS constant for IrDA */
N#define SPI_1_CARD_CTRL_OVS_IRDA_OVS16        (SPI_1_CARD_UART_IRDA_LP_OVS16)
N
N
N/***************************************
N*    Common Macro Definitions
N***************************************/
N
N/* Re-enables the SCB IP. A clear enable bit has a different effect
N* on the scb IP depending on the version:
N*  CY_SCBIP_V0: resets state, status, TX and RX FIFOs.
N*  CY_SCBIP_V1 or later: resets state, status, TX and RX FIFOs and interrupt sources.
N* Clear I2C command registers are because they are not impacted by re-enable.
N*/
N#define SPI_1_CARD_SCB_SW_RESET   SPI_1_CARD_I2CFwBlockReset()
N
N/* TX FIFO macro */
N#define SPI_1_CARD_CLEAR_TX_FIFO \
N                            do{        \
N                                SPI_1_CARD_TX_FIFO_CTRL_REG |= ((uint32)  SPI_1_CARD_TX_FIFO_CTRL_CLEAR); \
N                                SPI_1_CARD_TX_FIFO_CTRL_REG &= ((uint32) ~SPI_1_CARD_TX_FIFO_CTRL_CLEAR); \
N                            }while(0)
X#define SPI_1_CARD_CLEAR_TX_FIFO                             do{                                        SPI_1_CARD_TX_FIFO_CTRL_REG |= ((uint32)  SPI_1_CARD_TX_FIFO_CTRL_CLEAR);                                 SPI_1_CARD_TX_FIFO_CTRL_REG &= ((uint32) ~SPI_1_CARD_TX_FIFO_CTRL_CLEAR);                             }while(0)
N
N#define SPI_1_CARD_GET_TX_FIFO_ENTRIES    (SPI_1_CARD_TX_FIFO_STATUS_REG & \
N                                                 SPI_1_CARD_TX_FIFO_STATUS_USED_MASK)
X#define SPI_1_CARD_GET_TX_FIFO_ENTRIES    (SPI_1_CARD_TX_FIFO_STATUS_REG &                                                  SPI_1_CARD_TX_FIFO_STATUS_USED_MASK)
N
N#define SPI_1_CARD_GET_TX_FIFO_SR_VALID   ((0u != (SPI_1_CARD_TX_FIFO_STATUS_REG & \
N                                                         SPI_1_CARD_TX_FIFO_SR_VALID)) ? (1u) : (0u))
X#define SPI_1_CARD_GET_TX_FIFO_SR_VALID   ((0u != (SPI_1_CARD_TX_FIFO_STATUS_REG &                                                          SPI_1_CARD_TX_FIFO_SR_VALID)) ? (1u) : (0u))
N
N/* RX FIFO macro */
N#define SPI_1_CARD_CLEAR_RX_FIFO \
N                            do{        \
N                                SPI_1_CARD_RX_FIFO_CTRL_REG |= ((uint32)  SPI_1_CARD_RX_FIFO_CTRL_CLEAR); \
N                                SPI_1_CARD_RX_FIFO_CTRL_REG &= ((uint32) ~SPI_1_CARD_RX_FIFO_CTRL_CLEAR); \
N                            }while(0)
X#define SPI_1_CARD_CLEAR_RX_FIFO                             do{                                        SPI_1_CARD_RX_FIFO_CTRL_REG |= ((uint32)  SPI_1_CARD_RX_FIFO_CTRL_CLEAR);                                 SPI_1_CARD_RX_FIFO_CTRL_REG &= ((uint32) ~SPI_1_CARD_RX_FIFO_CTRL_CLEAR);                             }while(0)
N
N#define SPI_1_CARD_GET_RX_FIFO_ENTRIES    (SPI_1_CARD_RX_FIFO_STATUS_REG & \
N                                                    SPI_1_CARD_RX_FIFO_STATUS_USED_MASK)
X#define SPI_1_CARD_GET_RX_FIFO_ENTRIES    (SPI_1_CARD_RX_FIFO_STATUS_REG &                                                     SPI_1_CARD_RX_FIFO_STATUS_USED_MASK)
N
N#define SPI_1_CARD_GET_RX_FIFO_SR_VALID   ((0u != (SPI_1_CARD_RX_FIFO_STATUS_REG & \
N                                                         SPI_1_CARD_RX_FIFO_SR_VALID)) ? (1u) : (0u))
X#define SPI_1_CARD_GET_RX_FIFO_SR_VALID   ((0u != (SPI_1_CARD_RX_FIFO_STATUS_REG &                                                          SPI_1_CARD_RX_FIFO_SR_VALID)) ? (1u) : (0u))
N
N/* Write interrupt source: set sourceMask bits in SPI_1_CARD_INTR_X_MASK_REG */
N#define SPI_1_CARD_WRITE_INTR_I2C_EC_MASK(sourceMask) \
N                                                do{         \
N                                                    SPI_1_CARD_INTR_I2C_EC_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_1_CARD_WRITE_INTR_I2C_EC_MASK(sourceMask)                                                 do{                                                             SPI_1_CARD_INTR_I2C_EC_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#if (!SPI_1_CARD_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_1_CARD_WRITE_INTR_SPI_EC_MASK(sourceMask) \
N                                                do{         \
N                                                    SPI_1_CARD_INTR_SPI_EC_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X    #define SPI_1_CARD_WRITE_INTR_SPI_EC_MASK(sourceMask)                                                 do{                                                             SPI_1_CARD_INTR_SPI_EC_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N#endif /* (!SPI_1_CARD_CY_SCBIP_V1) */
N
N#define SPI_1_CARD_WRITE_INTR_MASTER_MASK(sourceMask) \
N                                                do{         \
N                                                    SPI_1_CARD_INTR_MASTER_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_1_CARD_WRITE_INTR_MASTER_MASK(sourceMask)                                                 do{                                                             SPI_1_CARD_INTR_MASTER_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_1_CARD_WRITE_INTR_SLAVE_MASK(sourceMask)  \
N                                                do{         \
N                                                    SPI_1_CARD_INTR_SLAVE_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_1_CARD_WRITE_INTR_SLAVE_MASK(sourceMask)                                                  do{                                                             SPI_1_CARD_INTR_SLAVE_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_1_CARD_WRITE_INTR_TX_MASK(sourceMask)     \
N                                                do{         \
N                                                    SPI_1_CARD_INTR_TX_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_1_CARD_WRITE_INTR_TX_MASK(sourceMask)                                                     do{                                                             SPI_1_CARD_INTR_TX_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_1_CARD_WRITE_INTR_RX_MASK(sourceMask)     \
N                                                do{         \
N                                                    SPI_1_CARD_INTR_RX_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_1_CARD_WRITE_INTR_RX_MASK(sourceMask)                                                     do{                                                             SPI_1_CARD_INTR_RX_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N/* Enable interrupt source: set sourceMask bits in SPI_1_CARD_INTR_X_MASK_REG */
N#define SPI_1_CARD_ENABLE_INTR_I2C_EC(sourceMask) \
N                                                do{     \
N                                                    SPI_1_CARD_INTR_I2C_EC_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_1_CARD_ENABLE_INTR_I2C_EC(sourceMask)                                                 do{                                                         SPI_1_CARD_INTR_I2C_EC_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N#if (!SPI_1_CARD_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_1_CARD_ENABLE_INTR_SPI_EC(sourceMask) \
N                                                do{     \
N                                                    SPI_1_CARD_INTR_SPI_EC_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X    #define SPI_1_CARD_ENABLE_INTR_SPI_EC(sourceMask)                                                 do{                                                         SPI_1_CARD_INTR_SPI_EC_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N#endif /* (!SPI_1_CARD_CY_SCBIP_V1) */
N
N#define SPI_1_CARD_ENABLE_INTR_MASTER(sourceMask) \
N                                                do{     \
N                                                    SPI_1_CARD_INTR_MASTER_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_1_CARD_ENABLE_INTR_MASTER(sourceMask)                                                 do{                                                         SPI_1_CARD_INTR_MASTER_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_1_CARD_ENABLE_INTR_SLAVE(sourceMask)  \
N                                                do{     \
N                                                    SPI_1_CARD_INTR_SLAVE_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_1_CARD_ENABLE_INTR_SLAVE(sourceMask)                                                  do{                                                         SPI_1_CARD_INTR_SLAVE_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_1_CARD_ENABLE_INTR_TX(sourceMask)     \
N                                                do{     \
N                                                    SPI_1_CARD_INTR_TX_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_1_CARD_ENABLE_INTR_TX(sourceMask)                                                     do{                                                         SPI_1_CARD_INTR_TX_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_1_CARD_ENABLE_INTR_RX(sourceMask)     \
N                                                do{     \
N                                                    SPI_1_CARD_INTR_RX_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_1_CARD_ENABLE_INTR_RX(sourceMask)                                                     do{                                                         SPI_1_CARD_INTR_RX_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N/* Disable interrupt source: clear sourceMask bits in SPI_1_CARD_INTR_X_MASK_REG */
N#define SPI_1_CARD_DISABLE_INTR_I2C_EC(sourceMask) \
N                                do{                      \
N                                    SPI_1_CARD_INTR_I2C_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define SPI_1_CARD_DISABLE_INTR_I2C_EC(sourceMask)                                 do{                                                          SPI_1_CARD_INTR_I2C_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N#if (!SPI_1_CARD_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_1_CARD_DISABLE_INTR_SPI_EC(sourceMask) \
N                                do{                      \
N                                    SPI_1_CARD_INTR_SPI_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                 }while(0)
X    #define SPI_1_CARD_DISABLE_INTR_SPI_EC(sourceMask)                                 do{                                                          SPI_1_CARD_INTR_SPI_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                  }while(0)
N#endif /* (!SPI_1_CARD_CY_SCBIP_V1) */
N
N#define SPI_1_CARD_DISABLE_INTR_MASTER(sourceMask) \
N                                do{                      \
N                                SPI_1_CARD_INTR_MASTER_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define SPI_1_CARD_DISABLE_INTR_MASTER(sourceMask)                                 do{                                                      SPI_1_CARD_INTR_MASTER_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N#define SPI_1_CARD_DISABLE_INTR_SLAVE(sourceMask) \
N                                do{                     \
N                                    SPI_1_CARD_INTR_SLAVE_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define SPI_1_CARD_DISABLE_INTR_SLAVE(sourceMask)                                 do{                                                         SPI_1_CARD_INTR_SLAVE_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N#define SPI_1_CARD_DISABLE_INTR_TX(sourceMask)    \
N                                do{                     \
N                                    SPI_1_CARD_INTR_TX_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                 }while(0)
X#define SPI_1_CARD_DISABLE_INTR_TX(sourceMask)                                    do{                                                         SPI_1_CARD_INTR_TX_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                  }while(0)
N
N#define SPI_1_CARD_DISABLE_INTR_RX(sourceMask)    \
N                                do{                     \
N                                    SPI_1_CARD_INTR_RX_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define SPI_1_CARD_DISABLE_INTR_RX(sourceMask)                                    do{                                                         SPI_1_CARD_INTR_RX_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N/* Set interrupt sources: write sourceMask bits in SPI_1_CARD_INTR_X_SET_REG */
N#define SPI_1_CARD_SET_INTR_MASTER(sourceMask)    \
N                                                do{     \
N                                                    SPI_1_CARD_INTR_MASTER_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_1_CARD_SET_INTR_MASTER(sourceMask)                                                    do{                                                         SPI_1_CARD_INTR_MASTER_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_1_CARD_SET_INTR_SLAVE(sourceMask) \
N                                                do{ \
N                                                    SPI_1_CARD_INTR_SLAVE_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_1_CARD_SET_INTR_SLAVE(sourceMask)                                                 do{                                                     SPI_1_CARD_INTR_SLAVE_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_1_CARD_SET_INTR_TX(sourceMask)    \
N                                                do{ \
N                                                    SPI_1_CARD_INTR_TX_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_1_CARD_SET_INTR_TX(sourceMask)                                                    do{                                                     SPI_1_CARD_INTR_TX_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_1_CARD_SET_INTR_RX(sourceMask)    \
N                                                do{ \
N                                                    SPI_1_CARD_INTR_RX_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_1_CARD_SET_INTR_RX(sourceMask)                                                    do{                                                     SPI_1_CARD_INTR_RX_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N/* Clear interrupt sources: write sourceMask bits in SPI_1_CARD_INTR_X_REG */
N#define SPI_1_CARD_CLEAR_INTR_I2C_EC(sourceMask)  \
N                                                do{     \
N                                                    SPI_1_CARD_INTR_I2C_EC_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_1_CARD_CLEAR_INTR_I2C_EC(sourceMask)                                                  do{                                                         SPI_1_CARD_INTR_I2C_EC_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#if (!SPI_1_CARD_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_1_CARD_CLEAR_INTR_SPI_EC(sourceMask)  \
N                                                do{     \
N                                                    SPI_1_CARD_INTR_SPI_EC_REG = (uint32) (sourceMask); \
N                                                }while(0)
X    #define SPI_1_CARD_CLEAR_INTR_SPI_EC(sourceMask)                                                  do{                                                         SPI_1_CARD_INTR_SPI_EC_REG = (uint32) (sourceMask);                                                 }while(0)
N#endif /* (!SPI_1_CARD_CY_SCBIP_V1) */
N
N#define SPI_1_CARD_CLEAR_INTR_MASTER(sourceMask)  \
N                                                do{     \
N                                                    SPI_1_CARD_INTR_MASTER_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_1_CARD_CLEAR_INTR_MASTER(sourceMask)                                                  do{                                                         SPI_1_CARD_INTR_MASTER_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_1_CARD_CLEAR_INTR_SLAVE(sourceMask)   \
N                                                do{     \
N                                                    SPI_1_CARD_INTR_SLAVE_REG  = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_1_CARD_CLEAR_INTR_SLAVE(sourceMask)                                                   do{                                                         SPI_1_CARD_INTR_SLAVE_REG  = (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_1_CARD_CLEAR_INTR_TX(sourceMask)      \
N                                                do{     \
N                                                    SPI_1_CARD_INTR_TX_REG     = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_1_CARD_CLEAR_INTR_TX(sourceMask)                                                      do{                                                         SPI_1_CARD_INTR_TX_REG     = (uint32) (sourceMask);                                                 }while(0)
N
N#define SPI_1_CARD_CLEAR_INTR_RX(sourceMask)      \
N                                                do{     \
N                                                    SPI_1_CARD_INTR_RX_REG     = (uint32) (sourceMask); \
N                                                }while(0)
X#define SPI_1_CARD_CLEAR_INTR_RX(sourceMask)                                                      do{                                                         SPI_1_CARD_INTR_RX_REG     = (uint32) (sourceMask);                                                 }while(0)
N
N/* Return true if sourceMask is set in SPI_1_CARD_INTR_CAUSE_REG */
N#define SPI_1_CARD_CHECK_CAUSE_INTR(sourceMask)    (0u != (SPI_1_CARD_INTR_CAUSE_REG & (sourceMask)))
N
N/* Return true if sourceMask is set in INTR_X_MASKED_REG */
N#define SPI_1_CARD_CHECK_INTR_I2C_EC(sourceMask)  (0u != (SPI_1_CARD_INTR_I2C_EC_REG & (sourceMask)))
N#if (!SPI_1_CARD_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_1_CARD_CHECK_INTR_SPI_EC(sourceMask)  (0u != (SPI_1_CARD_INTR_SPI_EC_REG & (sourceMask)))
N#endif /* (!SPI_1_CARD_CY_SCBIP_V1) */
N#define SPI_1_CARD_CHECK_INTR_MASTER(sourceMask)  (0u != (SPI_1_CARD_INTR_MASTER_REG & (sourceMask)))
N#define SPI_1_CARD_CHECK_INTR_SLAVE(sourceMask)   (0u != (SPI_1_CARD_INTR_SLAVE_REG  & (sourceMask)))
N#define SPI_1_CARD_CHECK_INTR_TX(sourceMask)      (0u != (SPI_1_CARD_INTR_TX_REG     & (sourceMask)))
N#define SPI_1_CARD_CHECK_INTR_RX(sourceMask)      (0u != (SPI_1_CARD_INTR_RX_REG     & (sourceMask)))
N
N/* Return true if sourceMask is set in SPI_1_CARD_INTR_X_MASKED_REG */
N#define SPI_1_CARD_CHECK_INTR_I2C_EC_MASKED(sourceMask)   (0u != (SPI_1_CARD_INTR_I2C_EC_MASKED_REG & \
N                                                                       (sourceMask)))
X#define SPI_1_CARD_CHECK_INTR_I2C_EC_MASKED(sourceMask)   (0u != (SPI_1_CARD_INTR_I2C_EC_MASKED_REG &                                                                        (sourceMask)))
N#if (!SPI_1_CARD_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_1_CARD_CHECK_INTR_SPI_EC_MASKED(sourceMask)   (0u != (SPI_1_CARD_INTR_SPI_EC_MASKED_REG & \
N                                                                       (sourceMask)))
X    #define SPI_1_CARD_CHECK_INTR_SPI_EC_MASKED(sourceMask)   (0u != (SPI_1_CARD_INTR_SPI_EC_MASKED_REG &                                                                        (sourceMask)))
N#endif /* (!SPI_1_CARD_CY_SCBIP_V1) */
N#define SPI_1_CARD_CHECK_INTR_MASTER_MASKED(sourceMask)   (0u != (SPI_1_CARD_INTR_MASTER_MASKED_REG & \
N                                                                       (sourceMask)))
X#define SPI_1_CARD_CHECK_INTR_MASTER_MASKED(sourceMask)   (0u != (SPI_1_CARD_INTR_MASTER_MASKED_REG &                                                                        (sourceMask)))
N#define SPI_1_CARD_CHECK_INTR_SLAVE_MASKED(sourceMask)    (0u != (SPI_1_CARD_INTR_SLAVE_MASKED_REG  & \
N                                                                       (sourceMask)))
X#define SPI_1_CARD_CHECK_INTR_SLAVE_MASKED(sourceMask)    (0u != (SPI_1_CARD_INTR_SLAVE_MASKED_REG  &                                                                        (sourceMask)))
N#define SPI_1_CARD_CHECK_INTR_TX_MASKED(sourceMask)       (0u != (SPI_1_CARD_INTR_TX_MASKED_REG     & \
N                                                                       (sourceMask)))
X#define SPI_1_CARD_CHECK_INTR_TX_MASKED(sourceMask)       (0u != (SPI_1_CARD_INTR_TX_MASKED_REG     &                                                                        (sourceMask)))
N#define SPI_1_CARD_CHECK_INTR_RX_MASKED(sourceMask)       (0u != (SPI_1_CARD_INTR_RX_MASKED_REG     & \
N                                                                       (sourceMask)))
X#define SPI_1_CARD_CHECK_INTR_RX_MASKED(sourceMask)       (0u != (SPI_1_CARD_INTR_RX_MASKED_REG     &                                                                        (sourceMask)))
N
N/* Return true if sourceMask is set in SPI_1_CARD_CTRL_REG: generally is used to check enable bit */
N#define SPI_1_CARD_GET_CTRL_ENABLED    (0u != (SPI_1_CARD_CTRL_REG & SPI_1_CARD_CTRL_ENABLED))
N
N#define SPI_1_CARD_CHECK_SLAVE_AUTO_ADDR_NACK     (0u != (SPI_1_CARD_I2C_CTRL_REG & \
N                                                                SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK))
X#define SPI_1_CARD_CHECK_SLAVE_AUTO_ADDR_NACK     (0u != (SPI_1_CARD_I2C_CTRL_REG &                                                                 SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK))
N
N
N/***************************************
N*      I2C Macro Definitions
N***************************************/
N
N/* Enable auto ACK/NACK */
N#define SPI_1_CARD_ENABLE_SLAVE_AUTO_ADDR_NACK \
N                            do{                      \
N                                SPI_1_CARD_I2C_CTRL_REG |= SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define SPI_1_CARD_ENABLE_SLAVE_AUTO_ADDR_NACK                             do{                                                      SPI_1_CARD_I2C_CTRL_REG |= SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define SPI_1_CARD_ENABLE_SLAVE_AUTO_DATA_ACK \
N                            do{                     \
N                                SPI_1_CARD_I2C_CTRL_REG |= SPI_1_CARD_I2C_CTRL_S_READY_DATA_ACK; \
N                            }while(0)
X#define SPI_1_CARD_ENABLE_SLAVE_AUTO_DATA_ACK                             do{                                                     SPI_1_CARD_I2C_CTRL_REG |= SPI_1_CARD_I2C_CTRL_S_READY_DATA_ACK;                             }while(0)
N
N#define SPI_1_CARD_ENABLE_SLAVE_AUTO_DATA_NACK \
N                            do{                      \
N                                SPI_1_CARD_I2C_CTRL_REG |= SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define SPI_1_CARD_ENABLE_SLAVE_AUTO_DATA_NACK                             do{                                                      SPI_1_CARD_I2C_CTRL_REG |= SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define SPI_1_CARD_ENABLE_MASTER_AUTO_DATA_ACK \
N                            do{                      \
N                                SPI_1_CARD_I2C_CTRL_REG |= SPI_1_CARD_I2C_CTRL_M_READY_DATA_ACK; \
N                            }while(0)
X#define SPI_1_CARD_ENABLE_MASTER_AUTO_DATA_ACK                             do{                                                      SPI_1_CARD_I2C_CTRL_REG |= SPI_1_CARD_I2C_CTRL_M_READY_DATA_ACK;                             }while(0)
N
N#define SPI_1_CARD_ENABLE_MASTER_AUTO_DATA_NACK \
N                            do{                       \
N                                SPI_1_CARD_I2C_CTRL_REG |= SPI_1_CARD_I2C_CTRL_M_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define SPI_1_CARD_ENABLE_MASTER_AUTO_DATA_NACK                             do{                                                       SPI_1_CARD_I2C_CTRL_REG |= SPI_1_CARD_I2C_CTRL_M_NOT_READY_DATA_NACK;                             }while(0)
N
N/* Disable auto ACK/NACK */
N#define SPI_1_CARD_DISABLE_SLAVE_AUTO_ADDR_NACK \
N                            do{                       \
N                                SPI_1_CARD_I2C_CTRL_REG &= ~SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define SPI_1_CARD_DISABLE_SLAVE_AUTO_ADDR_NACK                             do{                                                       SPI_1_CARD_I2C_CTRL_REG &= ~SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define SPI_1_CARD_DISABLE_SLAVE_AUTO_DATA_ACK \
N                            do{                      \
N                                SPI_1_CARD_I2C_CTRL_REG &= ~SPI_1_CARD_I2C_CTRL_S_READY_DATA_ACK; \
N                            }while(0)
X#define SPI_1_CARD_DISABLE_SLAVE_AUTO_DATA_ACK                             do{                                                      SPI_1_CARD_I2C_CTRL_REG &= ~SPI_1_CARD_I2C_CTRL_S_READY_DATA_ACK;                             }while(0)
N
N#define SPI_1_CARD_DISABLE_SLAVE_AUTO_DATA_NACK \
N                            do{                       \
N                                SPI_1_CARD_I2C_CTRL_REG &= ~SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define SPI_1_CARD_DISABLE_SLAVE_AUTO_DATA_NACK                             do{                                                       SPI_1_CARD_I2C_CTRL_REG &= ~SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define SPI_1_CARD_DISABLE_MASTER_AUTO_DATA_ACK \
N                            do{                       \
N                                SPI_1_CARD_I2C_CTRL_REG &= ~SPI_1_CARD_I2C_CTRL_M_READY_DATA_ACK; \
N                            }while(0)
X#define SPI_1_CARD_DISABLE_MASTER_AUTO_DATA_ACK                             do{                                                       SPI_1_CARD_I2C_CTRL_REG &= ~SPI_1_CARD_I2C_CTRL_M_READY_DATA_ACK;                             }while(0)
N
N#define SPI_1_CARD_DISABLE_MASTER_AUTO_DATA_NACK \
N                            do{                        \
N                                SPI_1_CARD_I2C_CTRL_REG &= ~SPI_1_CARD_I2C_CTRL_M_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define SPI_1_CARD_DISABLE_MASTER_AUTO_DATA_NACK                             do{                                                        SPI_1_CARD_I2C_CTRL_REG &= ~SPI_1_CARD_I2C_CTRL_M_NOT_READY_DATA_NACK;                             }while(0)
N
N/* Enable Slave autoACK/NACK Data */
N#define SPI_1_CARD_ENABLE_SLAVE_AUTO_DATA \
N                            do{                 \
N                                SPI_1_CARD_I2C_CTRL_REG |= (SPI_1_CARD_I2C_CTRL_S_READY_DATA_ACK |      \
N                                                                  SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK); \
N                            }while(0)
X#define SPI_1_CARD_ENABLE_SLAVE_AUTO_DATA                             do{                                                 SPI_1_CARD_I2C_CTRL_REG |= (SPI_1_CARD_I2C_CTRL_S_READY_DATA_ACK |                                                                        SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK);                             }while(0)
N
N/* Disable Slave autoACK/NACK Data */
N#define SPI_1_CARD_DISABLE_SLAVE_AUTO_DATA \
N                            do{                  \
N                                SPI_1_CARD_I2C_CTRL_REG &= ((uint32) \
N                                                                  ~(SPI_1_CARD_I2C_CTRL_S_READY_DATA_ACK |       \
N                                                                    SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK)); \
N                            }while(0)
X#define SPI_1_CARD_DISABLE_SLAVE_AUTO_DATA                             do{                                                  SPI_1_CARD_I2C_CTRL_REG &= ((uint32)                                                                   ~(SPI_1_CARD_I2C_CTRL_S_READY_DATA_ACK |                                                                           SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK));                             }while(0)
N
N/* Disable Master autoACK/NACK Data */
N#define SPI_1_CARD_DISABLE_MASTER_AUTO_DATA \
N                            do{                   \
N                                SPI_1_CARD_I2C_CTRL_REG &= ((uint32) \
N                                                                  ~(SPI_1_CARD_I2C_CTRL_M_READY_DATA_ACK |       \
N                                                                    SPI_1_CARD_I2C_CTRL_M_NOT_READY_DATA_NACK)); \
N                            }while(0)
X#define SPI_1_CARD_DISABLE_MASTER_AUTO_DATA                             do{                                                   SPI_1_CARD_I2C_CTRL_REG &= ((uint32)                                                                   ~(SPI_1_CARD_I2C_CTRL_M_READY_DATA_ACK |                                                                           SPI_1_CARD_I2C_CTRL_M_NOT_READY_DATA_NACK));                             }while(0)
N/* Disables auto data ACK/NACK bits */
N#define SPI_1_CARD_DISABLE_AUTO_DATA \
N                do{                        \
N                    SPI_1_CARD_I2C_CTRL_REG &= ((uint32) ~(SPI_1_CARD_I2C_CTRL_M_READY_DATA_ACK      |  \
N                                                                 SPI_1_CARD_I2C_CTRL_M_NOT_READY_DATA_NACK |  \
N                                                                 SPI_1_CARD_I2C_CTRL_S_READY_DATA_ACK      |  \
N                                                                 SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK)); \
N                }while(0)
X#define SPI_1_CARD_DISABLE_AUTO_DATA                 do{                                            SPI_1_CARD_I2C_CTRL_REG &= ((uint32) ~(SPI_1_CARD_I2C_CTRL_M_READY_DATA_ACK      |                                                                   SPI_1_CARD_I2C_CTRL_M_NOT_READY_DATA_NACK |                                                                   SPI_1_CARD_I2C_CTRL_S_READY_DATA_ACK      |                                                                   SPI_1_CARD_I2C_CTRL_S_NOT_READY_DATA_NACK));                 }while(0)
N
N/* Master commands */
N#define SPI_1_CARD_I2C_MASTER_GENERATE_START \
N                            do{                    \
N                                SPI_1_CARD_I2C_MASTER_CMD_REG = SPI_1_CARD_I2C_MASTER_CMD_M_START_ON_IDLE; \
N                            }while(0)
X#define SPI_1_CARD_I2C_MASTER_GENERATE_START                             do{                                                    SPI_1_CARD_I2C_MASTER_CMD_REG = SPI_1_CARD_I2C_MASTER_CMD_M_START_ON_IDLE;                             }while(0)
N
N#define SPI_1_CARD_I2C_MASTER_CLEAR_START \
N                            do{                 \
N                                SPI_1_CARD_I2C_MASTER_CMD_REG =  ((uint32) 0u); \
N                            }while(0)
X#define SPI_1_CARD_I2C_MASTER_CLEAR_START                             do{                                                 SPI_1_CARD_I2C_MASTER_CMD_REG =  ((uint32) 0u);                             }while(0)
N
N#define SPI_1_CARD_I2C_MASTER_GENERATE_RESTART SPI_1_CARD_I2CReStartGeneration()
N
N#define SPI_1_CARD_I2C_MASTER_GENERATE_STOP \
N                            do{                   \
N                                SPI_1_CARD_I2C_MASTER_CMD_REG =                                            \
N                                    (SPI_1_CARD_I2C_MASTER_CMD_M_STOP |                                    \
N                                        (SPI_1_CARD_CHECK_I2C_STATUS(SPI_1_CARD_I2C_STATUS_M_READ) ? \
N                                            (SPI_1_CARD_I2C_MASTER_CMD_M_NACK) : (0u)));                   \
N                            }while(0)
X#define SPI_1_CARD_I2C_MASTER_GENERATE_STOP                             do{                                                   SPI_1_CARD_I2C_MASTER_CMD_REG =                                                                                (SPI_1_CARD_I2C_MASTER_CMD_M_STOP |                                                                            (SPI_1_CARD_CHECK_I2C_STATUS(SPI_1_CARD_I2C_STATUS_M_READ) ?                                             (SPI_1_CARD_I2C_MASTER_CMD_M_NACK) : (0u)));                                               }while(0)
N
N#define SPI_1_CARD_I2C_MASTER_GENERATE_ACK \
N                            do{                  \
N                                SPI_1_CARD_I2C_MASTER_CMD_REG = SPI_1_CARD_I2C_MASTER_CMD_M_ACK; \
N                            }while(0)
X#define SPI_1_CARD_I2C_MASTER_GENERATE_ACK                             do{                                                  SPI_1_CARD_I2C_MASTER_CMD_REG = SPI_1_CARD_I2C_MASTER_CMD_M_ACK;                             }while(0)
N
N#define SPI_1_CARD_I2C_MASTER_GENERATE_NACK \
N                            do{                   \
N                                SPI_1_CARD_I2C_MASTER_CMD_REG = SPI_1_CARD_I2C_MASTER_CMD_M_NACK; \
N                            }while(0)
X#define SPI_1_CARD_I2C_MASTER_GENERATE_NACK                             do{                                                   SPI_1_CARD_I2C_MASTER_CMD_REG = SPI_1_CARD_I2C_MASTER_CMD_M_NACK;                             }while(0)
N
N/* Slave commands */
N#define SPI_1_CARD_I2C_SLAVE_GENERATE_ACK \
N                            do{                 \
N                                SPI_1_CARD_I2C_SLAVE_CMD_REG = SPI_1_CARD_I2C_SLAVE_CMD_S_ACK; \
N                            }while(0)
X#define SPI_1_CARD_I2C_SLAVE_GENERATE_ACK                             do{                                                 SPI_1_CARD_I2C_SLAVE_CMD_REG = SPI_1_CARD_I2C_SLAVE_CMD_S_ACK;                             }while(0)
N
N#if (SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1)
X#if ((2 == 0u) || (2 == 1u))
S    /* Slave NACK generation for EC_AM logic on address phase. Ticket ID #183902 */
S    void SPI_1_CARD_I2CSlaveNackGeneration(void);
S    #define SPI_1_CARD_I2C_SLAVE_GENERATE_NACK SPI_1_CARD_I2CSlaveNackGeneration()
S
N#else
N    #define SPI_1_CARD_I2C_SLAVE_GENERATE_NACK \
N                            do{                      \
N                                SPI_1_CARD_I2C_SLAVE_CMD_REG = SPI_1_CARD_I2C_SLAVE_CMD_S_NACK; \
N                            }while(0)
X    #define SPI_1_CARD_I2C_SLAVE_GENERATE_NACK                             do{                                                      SPI_1_CARD_I2C_SLAVE_CMD_REG = SPI_1_CARD_I2C_SLAVE_CMD_S_NACK;                             }while(0)
N#endif /* (SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1) */
N
N#define SPI_1_CARD_I2C_SLAVE_CLEAR_NACK \
N                            do{               \
N                                SPI_1_CARD_I2C_SLAVE_CMD_REG = 0u; \
N                            }while(0)
X#define SPI_1_CARD_I2C_SLAVE_CLEAR_NACK                             do{                                               SPI_1_CARD_I2C_SLAVE_CMD_REG = 0u;                             }while(0)
N
N/* Return 8-bit address. The input address should be 7-bits */
N#define SPI_1_CARD_GET_I2C_8BIT_ADDRESS(addr) (((uint32) ((uint32) (addr) << \
N                                                                    SPI_1_CARD_I2C_SLAVE_ADDR_POS)) & \
N                                                                        SPI_1_CARD_I2C_SLAVE_ADDR_MASK)
X#define SPI_1_CARD_GET_I2C_8BIT_ADDRESS(addr) (((uint32) ((uint32) (addr) <<                                                                     SPI_1_CARD_I2C_SLAVE_ADDR_POS)) &                                                                         SPI_1_CARD_I2C_SLAVE_ADDR_MASK)
N
N#define SPI_1_CARD_GET_I2C_7BIT_ADDRESS(addr) ((uint32) (addr) >> SPI_1_CARD_I2C_SLAVE_ADDR_POS)
N
N/* Adjust SDA filter Trim settings */
N#define SPI_1_CARD_DEFAULT_I2C_CFG_SDA_FILT_TRIM  (0x02u)
N#define SPI_1_CARD_EC_AM_I2C_CFG_SDA_FILT_TRIM    (0x03u)
N
N#if (SPI_1_CARD_CY_SCBIP_V0)
X#if ((2 == 0u))
S    #define SPI_1_CARD_SET_I2C_CFG_SDA_FILT_TRIM(sdaTrim) \
S        do{                                                 \
S            SPI_1_CARD_I2C_CFG_REG =                  \
S                            ((SPI_1_CARD_I2C_CFG_REG & (uint32) ~SPI_1_CARD_I2C_CFG_SDA_FILT_TRIM_MASK) | \
S                             ((uint32) ((uint32) (sdaTrim) <<SPI_1_CARD_I2C_CFG_SDA_FILT_TRIM_POS)));           \
S        }while(0)
X    #define SPI_1_CARD_SET_I2C_CFG_SDA_FILT_TRIM(sdaTrim)         do{                                                             SPI_1_CARD_I2C_CFG_REG =                                              ((SPI_1_CARD_I2C_CFG_REG & (uint32) ~SPI_1_CARD_I2C_CFG_SDA_FILT_TRIM_MASK) |                              ((uint32) ((uint32) (sdaTrim) <<SPI_1_CARD_I2C_CFG_SDA_FILT_TRIM_POS)));                   }while(0)
N#endif /* (SPI_1_CARD_CY_SCBIP_V0) */
N
N/* Enable/Disable analog and digital filter */
N#define SPI_1_CARD_DIGITAL_FILTER_DISABLE    (0u)
N#define SPI_1_CARD_DIGITAL_FILTER_ENABLE     (1u)
N#define SPI_1_CARD_I2C_DATA_RATE_FS_MODE_MAX (400u)
N#if (SPI_1_CARD_CY_SCBIP_V0)
X#if ((2 == 0u))
S    /* SPI_1_CARD_I2C_CFG_SDA_FILT_OUT_ENABLED is disabled by default */
S    #define SPI_1_CARD_I2C_CFG_FILT_MASK  (SPI_1_CARD_I2C_CFG_SDA_FILT_ENABLED | \
S                                                 SPI_1_CARD_I2C_CFG_SCL_FILT_ENABLED)
X    #define SPI_1_CARD_I2C_CFG_FILT_MASK  (SPI_1_CARD_I2C_CFG_SDA_FILT_ENABLED |                                                  SPI_1_CARD_I2C_CFG_SCL_FILT_ENABLED)
N#else
N    /* SPI_1_CARD_I2C_CFG_SDA_OUT_FILT_SEL_MASK is disabled by default */
N    #define SPI_1_CARD_I2C_CFG_FILT_MASK  (SPI_1_CARD_I2C_CFG_SDA_IN_FILT_SEL | \
N                                                 SPI_1_CARD_I2C_CFG_SCL_IN_FILT_SEL)
X    #define SPI_1_CARD_I2C_CFG_FILT_MASK  (SPI_1_CARD_I2C_CFG_SDA_IN_FILT_SEL |                                                  SPI_1_CARD_I2C_CFG_SCL_IN_FILT_SEL)
N#endif /* (SPI_1_CARD_CY_SCBIP_V0) */
N
N#define SPI_1_CARD_I2C_CFG_ANALOG_FITER_DISABLE \
N        do{                                           \
N            SPI_1_CARD_I2C_CFG_REG &= (uint32) ~SPI_1_CARD_I2C_CFG_FILT_MASK; \
N        }while(0)
X#define SPI_1_CARD_I2C_CFG_ANALOG_FITER_DISABLE         do{                                                       SPI_1_CARD_I2C_CFG_REG &= (uint32) ~SPI_1_CARD_I2C_CFG_FILT_MASK;         }while(0)
N
N#define SPI_1_CARD_I2C_CFG_ANALOG_FITER_ENABLE \
N        do{                                          \
N            SPI_1_CARD_I2C_CFG_REG |= (uint32)  SPI_1_CARD_I2C_CFG_FILT_MASK; \
N        }while(0)
X#define SPI_1_CARD_I2C_CFG_ANALOG_FITER_ENABLE         do{                                                      SPI_1_CARD_I2C_CFG_REG |= (uint32)  SPI_1_CARD_I2C_CFG_FILT_MASK;         }while(0)
N
N/* Return slave select number from SPI_CTRL register */
N#define SPI_1_CARD_GET_SPI_CTRL_SS(activeSelect) (((uint32) ((uint32) (activeSelect) << \
N                                                                    SPI_1_CARD_SPI_CTRL_SLAVE_SELECT_POS)) & \
N                                                                        SPI_1_CARD_SPI_CTRL_SLAVE_SELECT_MASK)
X#define SPI_1_CARD_GET_SPI_CTRL_SS(activeSelect) (((uint32) ((uint32) (activeSelect) <<                                                                     SPI_1_CARD_SPI_CTRL_SLAVE_SELECT_POS)) &                                                                         SPI_1_CARD_SPI_CTRL_SLAVE_SELECT_MASK)
N
N/* Return true if bit is set in SPI_1_CARD_I2C_STATUS_REG */
N#define SPI_1_CARD_CHECK_I2C_STATUS(sourceMask)   (0u != (SPI_1_CARD_I2C_STATUS_REG & (sourceMask)))
N
N/* Return true if bit is set in SPI_1_CARD_SPI_STATUS_REG */
N#define SPI_1_CARD_CHECK_SPI_STATUS(sourceMask)   (0u != (SPI_1_CARD_SPI_STATUS_REG & (sourceMask)))
N
N/* Return FIFO size depends on SPI_1_CARD_CTRL_BYTE_MODE bit */
N#define SPI_1_CARD_GET_FIFO_SIZE(condition) ((0u != (condition)) ? \
N                                                    (2u * SPI_1_CARD_FIFO_SIZE) : (SPI_1_CARD_FIFO_SIZE))
X#define SPI_1_CARD_GET_FIFO_SIZE(condition) ((0u != (condition)) ?                                                     (2u * SPI_1_CARD_FIFO_SIZE) : (SPI_1_CARD_FIFO_SIZE))
N
N
N/***************************************
N*       Get Macros Definitions
N***************************************/
N
N/* SPI_1_CARD_CTRL */
N#define SPI_1_CARD_GET_CTRL_OVS(oversample)       (((uint32) (oversample) - 1u) & SPI_1_CARD_CTRL_OVS_MASK)
N
N#define SPI_1_CARD_GET_CTRL_EC_OP_MODE(opMode)        ((0u != (opMode)) ? \
N                                                                (SPI_1_CARD_CTRL_EC_OP_MODE)  : (0u))
X#define SPI_1_CARD_GET_CTRL_EC_OP_MODE(opMode)        ((0u != (opMode)) ?                                                                 (SPI_1_CARD_CTRL_EC_OP_MODE)  : (0u))
N
N#define SPI_1_CARD_GET_CTRL_EC_AM_MODE(amMode)        ((0u != (amMode)) ? \
N                                                                (SPI_1_CARD_CTRL_EC_AM_MODE)  : (0u))
X#define SPI_1_CARD_GET_CTRL_EC_AM_MODE(amMode)        ((0u != (amMode)) ?                                                                 (SPI_1_CARD_CTRL_EC_AM_MODE)  : (0u))
N
N#define SPI_1_CARD_GET_CTRL_BLOCK(block)              ((0u != (block))  ? \
N                                                                (SPI_1_CARD_CTRL_BLOCK)       : (0u))
X#define SPI_1_CARD_GET_CTRL_BLOCK(block)              ((0u != (block))  ?                                                                 (SPI_1_CARD_CTRL_BLOCK)       : (0u))
N
N#define SPI_1_CARD_GET_CTRL_ADDR_ACCEPT(acceptAddr)   ((0u != (acceptAddr)) ? \
N                                                                (SPI_1_CARD_CTRL_ADDR_ACCEPT) : (0u))
X#define SPI_1_CARD_GET_CTRL_ADDR_ACCEPT(acceptAddr)   ((0u != (acceptAddr)) ?                                                                 (SPI_1_CARD_CTRL_ADDR_ACCEPT) : (0u))
N
N#if (SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1)
X#if ((2 == 0u) || (2 == 1u))
S    #define SPI_1_CARD_GET_CTRL_BYTE_MODE(mode)   (0u)
N#else
N    #define SPI_1_CARD_GET_CTRL_BYTE_MODE(mode)   ((0u != (mode)) ? \
N                                                            (SPI_1_CARD_CTRL_BYTE_MODE) : (0u))
X    #define SPI_1_CARD_GET_CTRL_BYTE_MODE(mode)   ((0u != (mode)) ?                                                             (SPI_1_CARD_CTRL_BYTE_MODE) : (0u))
N#endif /* (SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1) */
N
N/* SPI_1_CARD_I2C_CTRL */
N#define SPI_1_CARD_GET_I2C_CTRL_HIGH_PHASE_OVS(oversampleHigh) (((uint32) (oversampleHigh) - 1u) & \
N                                                                        SPI_1_CARD_I2C_CTRL_HIGH_PHASE_OVS_MASK)
X#define SPI_1_CARD_GET_I2C_CTRL_HIGH_PHASE_OVS(oversampleHigh) (((uint32) (oversampleHigh) - 1u) &                                                                         SPI_1_CARD_I2C_CTRL_HIGH_PHASE_OVS_MASK)
N
N#define SPI_1_CARD_GET_I2C_CTRL_LOW_PHASE_OVS(oversampleLow)  ((((uint32) (oversampleLow) - 1u) << \
N                                                                    SPI_1_CARD_I2C_CTRL_LOW_PHASE_OVS_POS) &  \
N                                                                    SPI_1_CARD_I2C_CTRL_LOW_PHASE_OVS_MASK)
X#define SPI_1_CARD_GET_I2C_CTRL_LOW_PHASE_OVS(oversampleLow)  ((((uint32) (oversampleLow) - 1u) <<                                                                     SPI_1_CARD_I2C_CTRL_LOW_PHASE_OVS_POS) &                                                                      SPI_1_CARD_I2C_CTRL_LOW_PHASE_OVS_MASK)
N
N#define SPI_1_CARD_GET_I2C_CTRL_S_NOT_READY_ADDR_NACK(wakeNack) ((0u != (wakeNack)) ? \
N                                                            (SPI_1_CARD_I2C_CTRL_S_NOT_READY_ADDR_NACK) : (0u))
X#define SPI_1_CARD_GET_I2C_CTRL_S_NOT_READY_ADDR_NACK(wakeNack) ((0u != (wakeNack)) ?                                                             (SPI_1_CARD_I2C_CTRL_S_NOT_READY_ADDR_NACK) : (0u))
N
N#define SPI_1_CARD_GET_I2C_CTRL_S_GENERAL_IGNORE(genCall) ((0u != (genCall)) ? \
N                                                                    (SPI_1_CARD_I2C_CTRL_S_GENERAL_IGNORE) : (0u))
X#define SPI_1_CARD_GET_I2C_CTRL_S_GENERAL_IGNORE(genCall) ((0u != (genCall)) ?                                                                     (SPI_1_CARD_I2C_CTRL_S_GENERAL_IGNORE) : (0u))
N
N#define SPI_1_CARD_GET_I2C_CTRL_SL_MSTR_MODE(mode)    ((uint32)(mode) << SPI_1_CARD_I2C_CTRL_SLAVE_MODE_POS)
N
N/* SPI_1_CARD_SPI_CTRL */
N#define SPI_1_CARD_GET_SPI_CTRL_CONTINUOUS(separate)  ((0u != (separate)) ? \
N                                                                (SPI_1_CARD_SPI_CTRL_CONTINUOUS) : (0u))
X#define SPI_1_CARD_GET_SPI_CTRL_CONTINUOUS(separate)  ((0u != (separate)) ?                                                                 (SPI_1_CARD_SPI_CTRL_CONTINUOUS) : (0u))
N
N#define SPI_1_CARD_GET_SPI_CTRL_SELECT_PRECEDE(mode)  ((0u != (mode)) ? \
N                                                                      (SPI_1_CARD_SPI_CTRL_SELECT_PRECEDE) : (0u))
X#define SPI_1_CARD_GET_SPI_CTRL_SELECT_PRECEDE(mode)  ((0u != (mode)) ?                                                                       (SPI_1_CARD_SPI_CTRL_SELECT_PRECEDE) : (0u))
N
N#define SPI_1_CARD_GET_SPI_CTRL_SCLK_MODE(mode)       (((uint32) (mode) << \
N                                                                        SPI_1_CARD_SPI_CTRL_CPHA_POS) & \
N                                                                        SPI_1_CARD_SPI_CTRL_SCLK_MODE_MASK)
X#define SPI_1_CARD_GET_SPI_CTRL_SCLK_MODE(mode)       (((uint32) (mode) <<                                                                         SPI_1_CARD_SPI_CTRL_CPHA_POS) &                                                                         SPI_1_CARD_SPI_CTRL_SCLK_MODE_MASK)
N
N#define SPI_1_CARD_GET_SPI_CTRL_LATE_MISO_SAMPLE(lateMiso) ((0u != (lateMiso)) ? \
N                                                                    (SPI_1_CARD_SPI_CTRL_LATE_MISO_SAMPLE) : (0u))
X#define SPI_1_CARD_GET_SPI_CTRL_LATE_MISO_SAMPLE(lateMiso) ((0u != (lateMiso)) ?                                                                     (SPI_1_CARD_SPI_CTRL_LATE_MISO_SAMPLE) : (0u))
N
N#if (SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1)
X#if ((2 == 0u) || (2 == 1u))
S    #define SPI_1_CARD_GET_SPI_CTRL_SCLK_CONTINUOUS(sclkType) (0u)
S    #define SPI_1_CARD_GET_SPI_CTRL_SSEL_POLARITY(polarity)   (0u)
N#else
N    #define SPI_1_CARD_GET_SPI_CTRL_SCLK_CONTINUOUS(sclkType) ((0u != (sclkType)) ? \
N                                                                    (SPI_1_CARD_SPI_CTRL_SCLK_CONTINUOUS) : (0u))
X    #define SPI_1_CARD_GET_SPI_CTRL_SCLK_CONTINUOUS(sclkType) ((0u != (sclkType)) ?                                                                     (SPI_1_CARD_SPI_CTRL_SCLK_CONTINUOUS) : (0u))
N
N    #define SPI_1_CARD_GET_SPI_CTRL_SSEL_POLARITY(polarity)   (((uint32) (polarity) << \
N                                                                     SPI_1_CARD_SPI_CTRL_SSEL0_POLARITY_POS) & \
N                                                                     SPI_1_CARD_SPI_CTRL_SSEL_POLARITY_MASK)
X    #define SPI_1_CARD_GET_SPI_CTRL_SSEL_POLARITY(polarity)   (((uint32) (polarity) <<                                                                      SPI_1_CARD_SPI_CTRL_SSEL0_POLARITY_POS) &                                                                      SPI_1_CARD_SPI_CTRL_SSEL_POLARITY_MASK)
N#endif /* ((SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1) */
N
N#define SPI_1_CARD_GET_SPI_CTRL_SUB_MODE(mode)        (((uint32) (mode) << SPI_1_CARD_SPI_CTRL_MODE_POS) & \
N                                                                                 SPI_1_CARD_SPI_CTRL_MODE_MASK)
X#define SPI_1_CARD_GET_SPI_CTRL_SUB_MODE(mode)        (((uint32) (mode) << SPI_1_CARD_SPI_CTRL_MODE_POS) &                                                                                  SPI_1_CARD_SPI_CTRL_MODE_MASK)
N
N#define SPI_1_CARD_GET_SPI_CTRL_SLAVE_SELECT(select)  (((uint32) (select) << \
N                                                                      SPI_1_CARD_SPI_CTRL_SLAVE_SELECT_POS) & \
N                                                                      SPI_1_CARD_SPI_CTRL_SLAVE_SELECT_MASK)
X#define SPI_1_CARD_GET_SPI_CTRL_SLAVE_SELECT(select)  (((uint32) (select) <<                                                                       SPI_1_CARD_SPI_CTRL_SLAVE_SELECT_POS) &                                                                       SPI_1_CARD_SPI_CTRL_SLAVE_SELECT_MASK)
N
N#define SPI_1_CARD_GET_SPI_CTRL_MASTER_MODE(mode)     ((0u != (mode)) ? \
N                                                                (SPI_1_CARD_SPI_CTRL_MASTER) : (0u))
X#define SPI_1_CARD_GET_SPI_CTRL_MASTER_MODE(mode)     ((0u != (mode)) ?                                                                 (SPI_1_CARD_SPI_CTRL_MASTER) : (0u))
N
N/* SPI_1_CARD_UART_CTRL */
N#define SPI_1_CARD_GET_UART_CTRL_MODE(mode)           (((uint32) (mode) << \
N                                                                            SPI_1_CARD_UART_CTRL_MODE_POS) & \
N                                                                            SPI_1_CARD_UART_CTRL_MODE_MASK)
X#define SPI_1_CARD_GET_UART_CTRL_MODE(mode)           (((uint32) (mode) <<                                                                             SPI_1_CARD_UART_CTRL_MODE_POS) &                                                                             SPI_1_CARD_UART_CTRL_MODE_MASK)
N
N/* SPI_1_CARD_UART_RX_CTRL */
N#define SPI_1_CARD_GET_UART_RX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) & \
N                                                                        SPI_1_CARD_UART_RX_CTRL_STOP_BITS_MASK)
X#define SPI_1_CARD_GET_UART_RX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) &                                                                         SPI_1_CARD_UART_RX_CTRL_STOP_BITS_MASK)
N
N#define SPI_1_CARD_GET_UART_RX_CTRL_PARITY(parity)    ((0u != (parity)) ? \
N                                                                    (SPI_1_CARD_UART_RX_CTRL_PARITY) : (0u))
X#define SPI_1_CARD_GET_UART_RX_CTRL_PARITY(parity)    ((0u != (parity)) ?                                                                     (SPI_1_CARD_UART_RX_CTRL_PARITY) : (0u))
N
N#define SPI_1_CARD_GET_UART_RX_CTRL_POLARITY(polarity)    ((0u != (polarity)) ? \
N                                                                    (SPI_1_CARD_UART_RX_CTRL_POLARITY) : (0u))
X#define SPI_1_CARD_GET_UART_RX_CTRL_POLARITY(polarity)    ((0u != (polarity)) ?                                                                     (SPI_1_CARD_UART_RX_CTRL_POLARITY) : (0u))
N
N#define SPI_1_CARD_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(dropErr) ((0u != (dropErr)) ? \
N                                                        (SPI_1_CARD_UART_RX_CTRL_DROP_ON_PARITY_ERR) : (0u))
X#define SPI_1_CARD_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(dropErr) ((0u != (dropErr)) ?                                                         (SPI_1_CARD_UART_RX_CTRL_DROP_ON_PARITY_ERR) : (0u))
N
N#define SPI_1_CARD_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(dropErr) ((0u != (dropErr)) ? \
N                                                        (SPI_1_CARD_UART_RX_CTRL_DROP_ON_FRAME_ERR) : (0u))
X#define SPI_1_CARD_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(dropErr) ((0u != (dropErr)) ?                                                         (SPI_1_CARD_UART_RX_CTRL_DROP_ON_FRAME_ERR) : (0u))
N
N#define SPI_1_CARD_GET_UART_RX_CTRL_MP_MODE(mpMode)   ((0u != (mpMode)) ? \
N                                                        (SPI_1_CARD_UART_RX_CTRL_MP_MODE) : (0u))
X#define SPI_1_CARD_GET_UART_RX_CTRL_MP_MODE(mpMode)   ((0u != (mpMode)) ?                                                         (SPI_1_CARD_UART_RX_CTRL_MP_MODE) : (0u))
N
N#define SPI_1_CARD_GET_UART_RX_CTRL_BREAK_WIDTH(width)    (((uint32) ((uint32) (width) - 1u) << \
N                                                                    SPI_1_CARD_UART_RX_CTRL_BREAK_WIDTH_POS) & \
N                                                                    SPI_1_CARD_UART_RX_CTRL_BREAK_WIDTH_MASK)
X#define SPI_1_CARD_GET_UART_RX_CTRL_BREAK_WIDTH(width)    (((uint32) ((uint32) (width) - 1u) <<                                                                     SPI_1_CARD_UART_RX_CTRL_BREAK_WIDTH_POS) &                                                                     SPI_1_CARD_UART_RX_CTRL_BREAK_WIDTH_MASK)
N
N/* SPI_1_CARD_UART_TX_CTRL */
N#define SPI_1_CARD_GET_UART_TX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) & \
N                                                                SPI_1_CARD_UART_RX_CTRL_STOP_BITS_MASK)
X#define SPI_1_CARD_GET_UART_TX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) &                                                                 SPI_1_CARD_UART_RX_CTRL_STOP_BITS_MASK)
N
N#define SPI_1_CARD_GET_UART_TX_CTRL_PARITY(parity)    ((0u != (parity)) ? \
N                                                               (SPI_1_CARD_UART_TX_CTRL_PARITY) : (0u))
X#define SPI_1_CARD_GET_UART_TX_CTRL_PARITY(parity)    ((0u != (parity)) ?                                                                (SPI_1_CARD_UART_TX_CTRL_PARITY) : (0u))
N
N#define SPI_1_CARD_GET_UART_TX_CTRL_RETRY_NACK(nack)  ((0u != (nack)) ? \
N                                                               (SPI_1_CARD_UART_TX_CTRL_RETRY_ON_NACK) : (0u))
X#define SPI_1_CARD_GET_UART_TX_CTRL_RETRY_NACK(nack)  ((0u != (nack)) ?                                                                (SPI_1_CARD_UART_TX_CTRL_RETRY_ON_NACK) : (0u))
N
N/* SPI_1_CARD_UART_FLOW_CTRL */
N#if !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1)
X#if !((2 == 0u) || (2 == 1u))
N    #define SPI_1_CARD_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(level)   ( (uint32) (level) & \
N                                                                 SPI_1_CARD_UART_FLOW_CTRL_TRIGGER_LEVEL_MASK)
X    #define SPI_1_CARD_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(level)   ( (uint32) (level) &                                                                  SPI_1_CARD_UART_FLOW_CTRL_TRIGGER_LEVEL_MASK)
N
N    #define SPI_1_CARD_GET_UART_FLOW_CTRL_RTS_POLARITY(polarity) ((0u != (polarity)) ? \
N                                                                (SPI_1_CARD_UART_FLOW_CTRL_RTS_POLARITY) : (0u))
X    #define SPI_1_CARD_GET_UART_FLOW_CTRL_RTS_POLARITY(polarity) ((0u != (polarity)) ?                                                                 (SPI_1_CARD_UART_FLOW_CTRL_RTS_POLARITY) : (0u))
N
N    #define SPI_1_CARD_GET_UART_FLOW_CTRL_CTS_POLARITY(polarity) ((0u != (polarity)) ? \
N                                                                (SPI_1_CARD_UART_FLOW_CTRL_CTS_POLARITY) : (0u))
X    #define SPI_1_CARD_GET_UART_FLOW_CTRL_CTS_POLARITY(polarity) ((0u != (polarity)) ?                                                                 (SPI_1_CARD_UART_FLOW_CTRL_CTS_POLARITY) : (0u))
N
N    #define SPI_1_CARD_GET_UART_FLOW_CTRL_CTS_ENABLE(ctsEn)      ((0u != (ctsEn)) ? \
N                                                                (SPI_1_CARD_UART_FLOW_CTRL_CTS_ENABLE) : (0u))
X    #define SPI_1_CARD_GET_UART_FLOW_CTRL_CTS_ENABLE(ctsEn)      ((0u != (ctsEn)) ?                                                                 (SPI_1_CARD_UART_FLOW_CTRL_CTS_ENABLE) : (0u))
N#endif /* !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1) */
N
N/* SPI_1_CARD_RX_CTRL */
N#define SPI_1_CARD_GET_RX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) & \
N                                                                SPI_1_CARD_RX_CTRL_DATA_WIDTH_MASK)
X#define SPI_1_CARD_GET_RX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) &                                                                 SPI_1_CARD_RX_CTRL_DATA_WIDTH_MASK)
N
N#define SPI_1_CARD_GET_RX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ? \
N                                                                (SPI_1_CARD_RX_CTRL_MSB_FIRST) : (0u))
X#define SPI_1_CARD_GET_RX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ?                                                                 (SPI_1_CARD_RX_CTRL_MSB_FIRST) : (0u))
N
N#define SPI_1_CARD_GET_RX_CTRL_MEDIAN(filterEn)       ((0u != (filterEn)) ? \
N                                                                (SPI_1_CARD_RX_CTRL_MEDIAN) : (0u))
X#define SPI_1_CARD_GET_RX_CTRL_MEDIAN(filterEn)       ((0u != (filterEn)) ?                                                                 (SPI_1_CARD_RX_CTRL_MEDIAN) : (0u))
N
N/* SPI_1_CARD_RX_MATCH */
N#define SPI_1_CARD_GET_RX_MATCH_ADDR(addr)    ((uint32) (addr) & SPI_1_CARD_RX_MATCH_ADDR_MASK)
N#define SPI_1_CARD_GET_RX_MATCH_MASK(mask)    (((uint32) (mask) << \
N                                                            SPI_1_CARD_RX_MATCH_MASK_POS) & \
N                                                            SPI_1_CARD_RX_MATCH_MASK_MASK)
X#define SPI_1_CARD_GET_RX_MATCH_MASK(mask)    (((uint32) (mask) <<                                                             SPI_1_CARD_RX_MATCH_MASK_POS) &                                                             SPI_1_CARD_RX_MATCH_MASK_MASK)
N
N/* SPI_1_CARD_RX_FIFO_CTRL */
N#define SPI_1_CARD_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) & \
N                                                                    SPI_1_CARD_RX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
X#define SPI_1_CARD_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) &                                                                     SPI_1_CARD_RX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
N
N/* SPI_1_CARD_TX_CTRL */
N#define SPI_1_CARD_GET_TX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) & \
N                                                                SPI_1_CARD_TX_CTRL_DATA_WIDTH_MASK)
X#define SPI_1_CARD_GET_TX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) &                                                                 SPI_1_CARD_TX_CTRL_DATA_WIDTH_MASK)
N
N#define SPI_1_CARD_GET_TX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ? \
N                                                                (SPI_1_CARD_TX_CTRL_MSB_FIRST) : (0u))
X#define SPI_1_CARD_GET_TX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ?                                                                 (SPI_1_CARD_TX_CTRL_MSB_FIRST) : (0u))
N
N/* SPI_1_CARD_TX_FIFO_CTRL */
N#define SPI_1_CARD_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) & \
N                                                                    SPI_1_CARD_TX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
X#define SPI_1_CARD_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) &                                                                     SPI_1_CARD_TX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
N
N/* SPI_1_CARD_INTR_SLAVE_I2C_GENERAL */
N#define SPI_1_CARD_GET_INTR_SLAVE_I2C_GENERAL(genCall)  ((0u != (genCall)) ? \
N                                                                (SPI_1_CARD_INTR_SLAVE_I2C_GENERAL) : (0u))
X#define SPI_1_CARD_GET_INTR_SLAVE_I2C_GENERAL(genCall)  ((0u != (genCall)) ?                                                                 (SPI_1_CARD_INTR_SLAVE_I2C_GENERAL) : (0u))
N
N/* Return true if master mode is enabled SPI_1_CARD_SPI_CTRL_REG */
N#define SPI_1_CARD_CHECK_SPI_MASTER   (0u != (SPI_1_CARD_SPI_CTRL_REG & SPI_1_CARD_SPI_CTRL_MASTER))
N
N/* Return inactive state of SPI SCLK line depends on CPOL */
N#define SPI_1_CARD_GET_SPI_SCLK_INACTIVE \
N            ((0u == (SPI_1_CARD_SPI_CTRL_REG & SPI_1_CARD_SPI_CTRL_CPOL)) ? (0u) : (1u))
X#define SPI_1_CARD_GET_SPI_SCLK_INACTIVE             ((0u == (SPI_1_CARD_SPI_CTRL_REG & SPI_1_CARD_SPI_CTRL_CPOL)) ? (0u) : (1u))
N
N/* Get output pin inactive state */
N#if (SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1)
X#if ((2 == 0u) || (2 == 1u))
S#define SPI_1_CARD_GET_SPI_SS0_INACTIVE       (1u)
S#define SPI_1_CARD_GET_SPI_SS1_INACTIVE       (1u)
S#define SPI_1_CARD_GET_SPI_SS2_INACTIVE       (1u)
S#define SPI_1_CARD_GET_SPI_SS3_INACTIVE       (1u)
S#define SPI_1_CARD_GET_UART_RTS_INACTIVE      (1u)
S
N#else
N#define SPI_1_CARD_GET_SPI_SS0_INACTIVE  \
N        ((0u != (SPI_1_CARD_SPI_CTRL_REG & SPI_1_CARD_SPI_CTRL_SSEL0_POLARITY)) ? (0u) : (1u))
X#define SPI_1_CARD_GET_SPI_SS0_INACTIVE          ((0u != (SPI_1_CARD_SPI_CTRL_REG & SPI_1_CARD_SPI_CTRL_SSEL0_POLARITY)) ? (0u) : (1u))
N
N#define SPI_1_CARD_GET_SPI_SS1_INACTIVE  \
N        ((0u != (SPI_1_CARD_SPI_CTRL_REG & SPI_1_CARD_SPI_CTRL_SSEL1_POLARITY)) ? (0u) : (1u))
X#define SPI_1_CARD_GET_SPI_SS1_INACTIVE          ((0u != (SPI_1_CARD_SPI_CTRL_REG & SPI_1_CARD_SPI_CTRL_SSEL1_POLARITY)) ? (0u) : (1u))
N
N#define SPI_1_CARD_GET_SPI_SS2_INACTIVE  \
N        ((0u != (SPI_1_CARD_SPI_CTRL_REG & SPI_1_CARD_SPI_CTRL_SSEL2_POLARITY)) ? (0u) : (1u))
X#define SPI_1_CARD_GET_SPI_SS2_INACTIVE          ((0u != (SPI_1_CARD_SPI_CTRL_REG & SPI_1_CARD_SPI_CTRL_SSEL2_POLARITY)) ? (0u) : (1u))
N
N#define SPI_1_CARD_GET_SPI_SS3_INACTIVE  \
N        ((0u != (SPI_1_CARD_SPI_CTRL_REG & SPI_1_CARD_SPI_CTRL_SSEL3_POLARITY)) ? (0u) : (1u))
X#define SPI_1_CARD_GET_SPI_SS3_INACTIVE          ((0u != (SPI_1_CARD_SPI_CTRL_REG & SPI_1_CARD_SPI_CTRL_SSEL3_POLARITY)) ? (0u) : (1u))
N
N#define SPI_1_CARD_GET_UART_RTS_INACTIVE \
N        ((0u == (SPI_1_CARD_UART_FLOW_CTRL_REG & SPI_1_CARD_UART_FLOW_CTRL_RTS_POLARITY)) ? (0u) : (1u))
X#define SPI_1_CARD_GET_UART_RTS_INACTIVE         ((0u == (SPI_1_CARD_UART_FLOW_CTRL_REG & SPI_1_CARD_UART_FLOW_CTRL_RTS_POLARITY)) ? (0u) : (1u))
N
N#endif /*(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1) */
N
N/* Clear register constants for configuration and interrupt mask */
N#define SPI_1_CARD_CLEAR_REG          ((uint32) (0u))
N#define SPI_1_CARD_NO_INTR_SOURCES    ((uint32) (0u))
N#define SPI_1_CARD_DUMMY_PARAM        ((uint32) (0u))
N#define SPI_1_CARD_SUBMODE_SPI_SLAVE  ((uint32) (0u))
N
N/* Return in case of I2C read error */
N#define SPI_1_CARD_I2C_INVALID_BYTE   ((uint32) 0xFFFFFFFFu)
N#define SPI_1_CARD_CHECK_VALID_BYTE   ((uint32) 0x80000000u)
N
N
N/***************************************
N* The following code is DEPRECATED and
N* must not be used.
N***************************************/
N
N#define SPI_1_CARD_CHECK_INTR_EC_I2C(sourceMask)  SPI_1_CARD_CHECK_INTR_I2C_EC(sourceMask)
N#if (!SPI_1_CARD_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_1_CARD_CHECK_INTR_EC_SPI(sourceMask)  SPI_1_CARD_CHECK_INTR_SPI_EC(sourceMask)
N#endif /* (!SPI_1_CARD_CY_SCBIP_V1) */
N
N#define SPI_1_CARD_CY_SCBIP_V1_I2C_ONLY   (SPI_1_CARD_CY_SCBIP_V1)
N#define SPI_1_CARD_EZBUFFER_SIZE          (SPI_1_CARD_EZ_DATA_NR)
N
N#define SPI_1_CARD_EZBUF_DATA00_REG   SPI_1_CARD_EZBUF_DATA0_REG
N#define SPI_1_CARD_EZBUF_DATA00_PTR   SPI_1_CARD_EZBUF_DATA0_PTR
N
N#endif /* (CY_SCB_SPI_1_CARD_H) */
N
N
N/* [] END OF FILE */
L 46 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD_SPI_UART.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_SPI_UART.h" 1
N/***************************************************************************//**
N* \file SPI_1_CARD_SPI_UART.h
N* \version 4.0
N*
N* \brief
N*  This file provides constants and parameter values for the SCB Component in
N*  SPI and UART modes.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_SPI_UART_SPI_1_CARD_H)
X#if !0L
N#define CY_SCB_SPI_UART_SPI_1_CARD_H
N
N#include "SPI_1_CARD.h"
N
N
N/***************************************
N*   SPI Initial Parameter Constants
N****************************************/
N
N#define SPI_1_CARD_SPI_MODE                   (1u)
N#define SPI_1_CARD_SPI_SUB_MODE               (0u)
N#define SPI_1_CARD_SPI_CLOCK_MODE             (0u)
N#define SPI_1_CARD_SPI_OVS_FACTOR             (6u)
N#define SPI_1_CARD_SPI_MEDIAN_FILTER_ENABLE   (0u)
N#define SPI_1_CARD_SPI_LATE_MISO_SAMPLE_ENABLE (0u)
N#define SPI_1_CARD_SPI_RX_DATA_BITS_NUM       (8u)
N#define SPI_1_CARD_SPI_TX_DATA_BITS_NUM       (8u)
N#define SPI_1_CARD_SPI_WAKE_ENABLE            (0u)
N#define SPI_1_CARD_SPI_BITS_ORDER             (1u)
N#define SPI_1_CARD_SPI_TRANSFER_SEPARATION    (1u)
N#define SPI_1_CARD_SPI_NUMBER_OF_SS_LINES     (1u)
N#define SPI_1_CARD_SPI_RX_BUFFER_SIZE         (8u)
N#define SPI_1_CARD_SPI_TX_BUFFER_SIZE         (8u)
N
N#define SPI_1_CARD_SPI_INTERRUPT_MODE         (0u)
N
N#define SPI_1_CARD_SPI_INTR_RX_MASK           (0x0u)
N#define SPI_1_CARD_SPI_INTR_TX_MASK           (0x0u)
N
N#define SPI_1_CARD_SPI_RX_TRIGGER_LEVEL       (7u)
N#define SPI_1_CARD_SPI_TX_TRIGGER_LEVEL       (0u)
N
N#define SPI_1_CARD_SPI_BYTE_MODE_ENABLE       (0u)
N#define SPI_1_CARD_SPI_FREE_RUN_SCLK_ENABLE   (0u)
N#define SPI_1_CARD_SPI_SS0_POLARITY           (0u)
N#define SPI_1_CARD_SPI_SS1_POLARITY           (0u)
N#define SPI_1_CARD_SPI_SS2_POLARITY           (0u)
N#define SPI_1_CARD_SPI_SS3_POLARITY           (0u)
N
N
N/***************************************
N*   UART Initial Parameter Constants
N****************************************/
N
N#define SPI_1_CARD_UART_SUB_MODE              (0u)
N#define SPI_1_CARD_UART_DIRECTION             (3u)
N#define SPI_1_CARD_UART_DATA_BITS_NUM         (8u)
N#define SPI_1_CARD_UART_PARITY_TYPE           (2u)
N#define SPI_1_CARD_UART_STOP_BITS_NUM         (2u)
N#define SPI_1_CARD_UART_OVS_FACTOR            (12u)
N#define SPI_1_CARD_UART_IRDA_LOW_POWER        (0u)
N#define SPI_1_CARD_UART_MEDIAN_FILTER_ENABLE  (0u)
N#define SPI_1_CARD_UART_RETRY_ON_NACK         (0u)
N#define SPI_1_CARD_UART_IRDA_POLARITY         (0u)
N#define SPI_1_CARD_UART_DROP_ON_FRAME_ERR     (0u)
N#define SPI_1_CARD_UART_DROP_ON_PARITY_ERR    (0u)
N#define SPI_1_CARD_UART_WAKE_ENABLE           (0u)
N#define SPI_1_CARD_UART_RX_BUFFER_SIZE        (8u)
N#define SPI_1_CARD_UART_TX_BUFFER_SIZE        (8u)
N#define SPI_1_CARD_UART_MP_MODE_ENABLE        (0u)
N#define SPI_1_CARD_UART_MP_ACCEPT_ADDRESS     (0u)
N#define SPI_1_CARD_UART_MP_RX_ADDRESS         (0x2u)
N#define SPI_1_CARD_UART_MP_RX_ADDRESS_MASK    (0xFFu)
N
N#define SPI_1_CARD_UART_INTERRUPT_MODE        (0u)
N
N#define SPI_1_CARD_UART_INTR_RX_MASK          (0x0u)
N#define SPI_1_CARD_UART_INTR_TX_MASK          (0x0u)
N
N#define SPI_1_CARD_UART_RX_TRIGGER_LEVEL      (7u)
N#define SPI_1_CARD_UART_TX_TRIGGER_LEVEL      (0u)
N
N#define SPI_1_CARD_UART_BYTE_MODE_ENABLE      (0u)
N#define SPI_1_CARD_UART_CTS_ENABLE            (0u)
N#define SPI_1_CARD_UART_CTS_POLARITY          (0u)
N#define SPI_1_CARD_UART_RTS_ENABLE            (0u)
N#define SPI_1_CARD_UART_RTS_POLARITY          (0u)
N#define SPI_1_CARD_UART_RTS_FIFO_LEVEL        (4u)
N
N#define SPI_1_CARD_UART_RX_BREAK_WIDTH        (11u)
N
N/* SPI mode enum */
N#define SPI_1_CARD_SPI_SLAVE  (0u)
N#define SPI_1_CARD_SPI_MASTER (1u)
N
N/* UART direction enum */
N#define SPI_1_CARD_UART_RX    (1u)
N#define SPI_1_CARD_UART_TX    (2u)
N#define SPI_1_CARD_UART_TX_RX (3u)
N
N
N/***************************************
N*   Conditional Compilation Parameters
N****************************************/
N
N#if(SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (2u)))
S
S    /* Mode */
S    #define SPI_1_CARD_SPI_SLAVE_CONST        (1u)
S    #define SPI_1_CARD_SPI_MASTER_CONST       (1u)
S
S    /* Direction */
S    #define SPI_1_CARD_RX_DIRECTION           (1u)
S    #define SPI_1_CARD_TX_DIRECTION           (1u)
S    #define SPI_1_CARD_UART_RX_DIRECTION      (1u)
S    #define SPI_1_CARD_UART_TX_DIRECTION      (1u)
S
S    /* Only external RX and TX buffer for Uncofigured mode */
S    #define SPI_1_CARD_INTERNAL_RX_SW_BUFFER   (0u)
S    #define SPI_1_CARD_INTERNAL_TX_SW_BUFFER   (0u)
S
S    /* Get RX and TX buffer size */
S    #define SPI_1_CARD_INTERNAL_RX_BUFFER_SIZE    (SPI_1_CARD_rxBufferSize + 1u)
S    #define SPI_1_CARD_RX_BUFFER_SIZE             (SPI_1_CARD_rxBufferSize)
S    #define SPI_1_CARD_TX_BUFFER_SIZE             (SPI_1_CARD_txBufferSize)
S
S    /* Return true if buffer is provided */
S    #define SPI_1_CARD_CHECK_RX_SW_BUFFER (NULL != SPI_1_CARD_rxBuffer)
S    #define SPI_1_CARD_CHECK_TX_SW_BUFFER (NULL != SPI_1_CARD_txBuffer)
S
S    /* Always provide global variables to support RX and TX buffers */
S    #define SPI_1_CARD_INTERNAL_RX_SW_BUFFER_CONST    (1u)
S    #define SPI_1_CARD_INTERNAL_TX_SW_BUFFER_CONST    (1u)
S
S    /* Get wakeup enable option */
S    #define SPI_1_CARD_SPI_WAKE_ENABLE_CONST  (1u)
S    #define SPI_1_CARD_UART_WAKE_ENABLE_CONST (1u)
S    #define SPI_1_CARD_CHECK_SPI_WAKE_ENABLE  ((0u != SPI_1_CARD_scbEnableWake) && SPI_1_CARD_SCB_MODE_SPI_RUNTM_CFG)
S    #define SPI_1_CARD_CHECK_UART_WAKE_ENABLE ((0u != SPI_1_CARD_scbEnableWake) && SPI_1_CARD_SCB_MODE_UART_RUNTM_CFG)
S
S    /* SPI/UART: TX or RX FIFO size */
S    #if (SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1)
S        #define SPI_1_CARD_SPI_UART_FIFO_SIZE             (SPI_1_CARD_FIFO_SIZE)
S        #define SPI_1_CARD_CHECK_UART_RTS_CONTROL_FLOW    (0u)
S    #else
S        #define SPI_1_CARD_SPI_UART_FIFO_SIZE (SPI_1_CARD_GET_FIFO_SIZE(SPI_1_CARD_CTRL_REG & \
S                                                                                    SPI_1_CARD_CTRL_BYTE_MODE))
X        #define SPI_1_CARD_SPI_UART_FIFO_SIZE (SPI_1_CARD_GET_FIFO_SIZE(SPI_1_CARD_CTRL_REG &                                                                                     SPI_1_CARD_CTRL_BYTE_MODE))
S
S        #define SPI_1_CARD_CHECK_UART_RTS_CONTROL_FLOW \
S                    ((SPI_1_CARD_SCB_MODE_UART_RUNTM_CFG) && \
S                     (0u != SPI_1_CARD_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(SPI_1_CARD_UART_FLOW_CTRL_REG)))
X        #define SPI_1_CARD_CHECK_UART_RTS_CONTROL_FLOW                     ((SPI_1_CARD_SCB_MODE_UART_RUNTM_CFG) &&                      (0u != SPI_1_CARD_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(SPI_1_CARD_UART_FLOW_CTRL_REG)))
S    #endif /* (SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1) */
S
N#else
N
N    /* Internal RX and TX buffer: for SPI or UART */
N    #if (SPI_1_CARD_SCB_MODE_SPI_CONST_CFG)
X    #if (((0x02u) == (2u)))
N
N        /* SPI Direction */
N        #define SPI_1_CARD_SPI_RX_DIRECTION (1u)
N        #define SPI_1_CARD_SPI_TX_DIRECTION (1u)
N
N        /* Get FIFO size */
N        #define SPI_1_CARD_SPI_UART_FIFO_SIZE SPI_1_CARD_GET_FIFO_SIZE(SPI_1_CARD_SPI_BYTE_MODE_ENABLE)
N
N        /* SPI internal RX and TX buffers */
N        #define SPI_1_CARD_INTERNAL_SPI_RX_SW_BUFFER  (SPI_1_CARD_SPI_RX_BUFFER_SIZE > \
N                                                                SPI_1_CARD_SPI_UART_FIFO_SIZE)
X        #define SPI_1_CARD_INTERNAL_SPI_RX_SW_BUFFER  (SPI_1_CARD_SPI_RX_BUFFER_SIZE >                                                                 SPI_1_CARD_SPI_UART_FIFO_SIZE)
N        #define SPI_1_CARD_INTERNAL_SPI_TX_SW_BUFFER  (SPI_1_CARD_SPI_TX_BUFFER_SIZE > \
N                                                                SPI_1_CARD_SPI_UART_FIFO_SIZE)
X        #define SPI_1_CARD_INTERNAL_SPI_TX_SW_BUFFER  (SPI_1_CARD_SPI_TX_BUFFER_SIZE >                                                                 SPI_1_CARD_SPI_UART_FIFO_SIZE)
N
N        /* Internal SPI RX and TX buffer */
N        #define SPI_1_CARD_INTERNAL_RX_SW_BUFFER  (SPI_1_CARD_INTERNAL_SPI_RX_SW_BUFFER)
N        #define SPI_1_CARD_INTERNAL_TX_SW_BUFFER  (SPI_1_CARD_INTERNAL_SPI_TX_SW_BUFFER)
N
N        /* Internal SPI RX and TX buffer size */
N        #define SPI_1_CARD_INTERNAL_RX_BUFFER_SIZE    (SPI_1_CARD_SPI_RX_BUFFER_SIZE + 1u)
N        #define SPI_1_CARD_RX_BUFFER_SIZE             (SPI_1_CARD_SPI_RX_BUFFER_SIZE)
N        #define SPI_1_CARD_TX_BUFFER_SIZE             (SPI_1_CARD_SPI_TX_BUFFER_SIZE)
N
N        /* Get wakeup enable option */
N        #define SPI_1_CARD_SPI_WAKE_ENABLE_CONST  (0u != SPI_1_CARD_SPI_WAKE_ENABLE)
N        #define SPI_1_CARD_UART_WAKE_ENABLE_CONST (0u)
N
N    #else
S
S        /* UART Direction */
S        #define SPI_1_CARD_UART_RX_DIRECTION (0u != (SPI_1_CARD_UART_DIRECTION & SPI_1_CARD_UART_RX))
S        #define SPI_1_CARD_UART_TX_DIRECTION (0u != (SPI_1_CARD_UART_DIRECTION & SPI_1_CARD_UART_TX))
S
S        /* Get FIFO size */
S        #define SPI_1_CARD_SPI_UART_FIFO_SIZE SPI_1_CARD_GET_FIFO_SIZE(SPI_1_CARD_UART_BYTE_MODE_ENABLE)
S
S        /* UART internal RX and TX buffers */
S        #define SPI_1_CARD_INTERNAL_UART_RX_SW_BUFFER  (SPI_1_CARD_UART_RX_BUFFER_SIZE > \
S                                                                SPI_1_CARD_SPI_UART_FIFO_SIZE)
X        #define SPI_1_CARD_INTERNAL_UART_RX_SW_BUFFER  (SPI_1_CARD_UART_RX_BUFFER_SIZE >                                                                 SPI_1_CARD_SPI_UART_FIFO_SIZE)
S        #define SPI_1_CARD_INTERNAL_UART_TX_SW_BUFFER  (SPI_1_CARD_UART_TX_BUFFER_SIZE > \
S                                                                    SPI_1_CARD_SPI_UART_FIFO_SIZE)
X        #define SPI_1_CARD_INTERNAL_UART_TX_SW_BUFFER  (SPI_1_CARD_UART_TX_BUFFER_SIZE >                                                                     SPI_1_CARD_SPI_UART_FIFO_SIZE)
S
S        /* Internal UART RX and TX buffer */
S        #define SPI_1_CARD_INTERNAL_RX_SW_BUFFER  (SPI_1_CARD_INTERNAL_UART_RX_SW_BUFFER)
S        #define SPI_1_CARD_INTERNAL_TX_SW_BUFFER  (SPI_1_CARD_INTERNAL_UART_TX_SW_BUFFER)
S
S        /* Internal UART RX and TX buffer size */
S        #define SPI_1_CARD_INTERNAL_RX_BUFFER_SIZE    (SPI_1_CARD_UART_RX_BUFFER_SIZE + 1u)
S        #define SPI_1_CARD_RX_BUFFER_SIZE             (SPI_1_CARD_UART_RX_BUFFER_SIZE)
S        #define SPI_1_CARD_TX_BUFFER_SIZE             (SPI_1_CARD_UART_TX_BUFFER_SIZE)
S
S        /* Get wakeup enable option */
S        #define SPI_1_CARD_SPI_WAKE_ENABLE_CONST  (0u)
S        #define SPI_1_CARD_UART_WAKE_ENABLE_CONST (0u != SPI_1_CARD_UART_WAKE_ENABLE)
S
N    #endif /* (SPI_1_CARD_SCB_MODE_SPI_CONST_CFG) */
N
N    /* Mode */
N    #define SPI_1_CARD_SPI_SLAVE_CONST    (SPI_1_CARD_SPI_MODE == SPI_1_CARD_SPI_SLAVE)
N    #define SPI_1_CARD_SPI_MASTER_CONST   (SPI_1_CARD_SPI_MODE == SPI_1_CARD_SPI_MASTER)
N
N    /* Direction */
N    #define SPI_1_CARD_RX_DIRECTION ((SPI_1_CARD_SCB_MODE_SPI_CONST_CFG) ? \
N                                            (SPI_1_CARD_SPI_RX_DIRECTION) : (SPI_1_CARD_UART_RX_DIRECTION))
X    #define SPI_1_CARD_RX_DIRECTION ((SPI_1_CARD_SCB_MODE_SPI_CONST_CFG) ?                                             (SPI_1_CARD_SPI_RX_DIRECTION) : (SPI_1_CARD_UART_RX_DIRECTION))
N
N    #define SPI_1_CARD_TX_DIRECTION ((SPI_1_CARD_SCB_MODE_SPI_CONST_CFG) ? \
N                                            (SPI_1_CARD_SPI_TX_DIRECTION) : (SPI_1_CARD_UART_TX_DIRECTION))
X    #define SPI_1_CARD_TX_DIRECTION ((SPI_1_CARD_SCB_MODE_SPI_CONST_CFG) ?                                             (SPI_1_CARD_SPI_TX_DIRECTION) : (SPI_1_CARD_UART_TX_DIRECTION))
N
N    /* Internal RX and TX buffer: for SPI or UART. Used in conditional compilation check */
N    #define SPI_1_CARD_CHECK_RX_SW_BUFFER (SPI_1_CARD_INTERNAL_RX_SW_BUFFER)
N    #define SPI_1_CARD_CHECK_TX_SW_BUFFER (SPI_1_CARD_INTERNAL_TX_SW_BUFFER)
N
N    /* Provide global variables to support RX and TX buffers */
N    #define SPI_1_CARD_INTERNAL_RX_SW_BUFFER_CONST    (SPI_1_CARD_INTERNAL_RX_SW_BUFFER)
N    #define SPI_1_CARD_INTERNAL_TX_SW_BUFFER_CONST    (SPI_1_CARD_INTERNAL_TX_SW_BUFFER)
N
N    /* Wake up enable */
N    #define SPI_1_CARD_CHECK_SPI_WAKE_ENABLE  (SPI_1_CARD_SPI_WAKE_ENABLE_CONST)
N    #define SPI_1_CARD_CHECK_UART_WAKE_ENABLE (SPI_1_CARD_UART_WAKE_ENABLE_CONST)
N
N    /* UART flow control: not applicable for CY_SCBIP_V0 || CY_SCBIP_V1 */
N    #define SPI_1_CARD_CHECK_UART_RTS_CONTROL_FLOW    (SPI_1_CARD_SCB_MODE_UART_CONST_CFG && \
N                                                             SPI_1_CARD_UART_RTS_ENABLE)
X    #define SPI_1_CARD_CHECK_UART_RTS_CONTROL_FLOW    (SPI_1_CARD_SCB_MODE_UART_CONST_CFG &&                                                              SPI_1_CARD_UART_RTS_ENABLE)
N
N#endif /* End (SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N
N/***************************************
N*       Type Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N
N/* SPI_1_CARD_SPI_INIT_STRUCT */
Ntypedef struct
N{
N    /** Mode of operation for SPI. The following defines are available choices:
N     *  - SPI_1_CARD_SPI_SLAVE
N     *  - SPI_1_CARD_SPI_MASTE
N    */
N    uint32 mode;
N
N    /** Submode of operation for SPI. The following defines are available
N     *  choices:
N     *  - SPI_1_CARD_SPI_MODE_MOTOROLA
N     *  - SPI_1_CARD_SPI_MODE_TI_COINCIDES
N     *  - SPI_1_CARD_SPI_MODE_TI_PRECEDES
N     *  - SPI_1_CARD_SPI_MODE_NATIONAL
N    */
N    uint32 submode;
N
N    /** Determines the sclk relationship for Motorola submode. Ignored
N     *  for other submodes. The following defines are available choices:
N     *  - SPI_1_CARD_SPI_SCLK_CPHA0_CPOL0
N     *  - SPI_1_CARD_SPI_SCLK_CPHA0_CPOL1
N     *  - SPI_1_CARD_SPI_SCLK_CPHA1_CPOL0
N     *  - SPI_1_CARD_SPI_SCLK_CPHA1_CPOL1
N    */
N    uint32 sclkMode;
N
N    /** Oversampling factor for the SPI clock. Ignored for Slave mode operation.
N    */
N    uint32 oversample;
N
N    /** Applies median filter on the input lines: 0  not applied, 1  applied.
N    */
N    uint32 enableMedianFilter;
N
N    /** Applies late sampling of MISO line: 0  not applied, 1  applied.
N     *  Ignored for slave mode.
N    */
N    uint32 enableLateSampling;
N
N    /** Enables wakeup from low power mode: 0  disable, 1  enable.
N     *  Ignored for master mode.
N    */
N    uint32 enableWake;
N
N    /** Number of data bits for RX direction.
N     *  Different dataBitsRx and dataBitsTx are only allowed for National
N     *  submode.
N    */
N    uint32 rxDataBits;
N
N    /** Number of data bits for TX direction.
N     *  Different dataBitsRx and dataBitsTx are only allowed for National
N     *  submode.
N    */
N    uint32 txDataBits;
N
N    /** Determines the bit ordering. The following defines are available
N     *  choices:
N     *  - SPI_1_CARD_BITS_ORDER_LSB_FIRST
N     *  - SPI_1_CARD_BITS_ORDER_MSB_FIRST
N    */
N    uint32 bitOrder;
N
N    /** Determines whether transfers are back to back or have SS disabled
N     *  between words. Ignored for slave mode. The following defines are
N     *  available choices:
N     *  - SPI_1_CARD_SPI_TRANSFER_CONTINUOUS
N     *  - SPI_1_CARD_SPI_TRANSFER_SEPARATED
N    */
N    uint32 transferSeperation;
N
N    /** Size of the RX buffer in bytes/words (depends on rxDataBits parameter).
N     *  A value equal to the RX FIFO depth implies the usage of buffering in
N     *  hardware. A value greater than the RX FIFO depth results in a software
N     *  buffer.
N     *  The SPI_1_CARD_INTR _RX_NOT_EMPTY interrupt has to be enabled to
N     *  transfer data into the software buffer.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words for PSoC 4100 /
N     *    PSoC 4200 devices.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words or 16
N     *    bytes (Byte mode is enabled) for PSoC 4100 BLE / PSoC 4200 BLE /
N     *    PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *    PSoC Analog Coprocessor devices.
N    */
N    uint32 rxBufferSize;
N
N    /** Buffer space provided for a RX software buffer:
N     *  - A NULL pointer must be provided to use hardware buffering.
N     *  - A pointer to an allocated buffer must be provided to use software
N     *    buffering. The buffer size must equal (rxBufferSize + 1) in bytes if
N     *    dataBitsRx is less or equal to 8, otherwise (2 * (rxBufferSize + 1))
N     *    in bytes. The software RX buffer always keeps one element empty.
N     *    For correct operation the allocated RX buffer has to be one element
N     *    greater than maximum packet size expected to be received.
N    */
N    uint8* rxBuffer;
N
N    /** Size of the TX buffer in bytes/words(depends on txDataBits parameter).
N     *  A value equal to the TX FIFO depth implies the usage of buffering in
N     *  hardware. A value greater than the TX FIFO depth results in a software
N     *  buffer.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words for PSoC 4100 /
N     *    PSoC 4200 devices.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words or 16
N     *    bytes (Byte mode is enabled) for PSoC 4100 BLE / PSoC 4200 BLE /
N     *    PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *    PSoC Analog Coprocessor devices.
N    */
N    uint32 txBufferSize;
N
N    /** Buffer space provided for a TX software buffer:
N     *  - A NULL pointer must be provided to use hardware buffering.
N     *  - A pointer to an allocated buffer must be provided to use software
N     *    buffering. The buffer size must equal txBufferSize if dataBitsTx is
N     *    less or equal to 8, otherwise (2* txBufferSize).
N    */
N    uint8* txBuffer;
N
N    /** Enables component interrupt: 0  disable, 1  enable.
N     *  The interrupt has to be enabled if software buffer is used.
N    */
N    uint32 enableInterrupt;
N
N    /** Mask of enabled interrupt sources for the RX direction. This mask is
N     *  written regardless of the setting of the enable Interrupt field.
N     *  Multiple sources are enabled by providing a value that is the OR of
N     *  all of the following sources to enable:
N     *  - SPI_1_CARD_INTR_RX_FIFO_LEVEL
N     *  - SPI_1_CARD_INTR_RX_NOT_EMPTY
N     *  - SPI_1_CARD_INTR_RX_FULL
N     *  - SPI_1_CARD_INTR_RX_OVERFLOW
N     *  - SPI_1_CARD_INTR_RX_UNDERFLOW
N     *  - SPI_1_CARD_INTR_SLAVE_SPI_BUS_ERROR
N    */
N    uint32 rxInterruptMask;
N
N    /** FIFO level for an RX FIFO level interrupt. This value is written
N     *  regardless of whether the RX FIFO level interrupt source is enabled.
N    */
N    uint32 rxTriggerLevel;
N
N    /** Mask of enabled interrupt sources for the TX direction. This mask is
N     *  written regardless of the setting of the enable Interrupt field.
N     *  Multiple sources are enabled by providing a value that is the OR of
N     *  all of the following sources to enable:
N     *  - SPI_1_CARD_INTR_TX_FIFO_LEVEL
N     *  - SPI_1_CARD_INTR_TX_NOT_FULL
N     *  - SPI_1_CARD_INTR_TX_EMPTY
N     *  - SPI_1_CARD_INTR_TX_OVERFLOW
N     *  - SPI_1_CARD_INTR_TX_UNDERFLOW
N     *  - SPI_1_CARD_INTR_MASTER_SPI_DONE
N    */
N    uint32 txInterruptMask;
N
N    /** FIFO level for a TX FIFO level interrupt. This value is written
N     * regardless of whether the TX FIFO level interrupt source is enabled.
N    */
N    uint32 txTriggerLevel;
N
N    /** When enabled the TX and RX FIFO depth is doubled and equal to
N     *  16 bytes: 0  disable, 1  enable. This implies that number of
N     *  TX and RX data bits must be less than or equal to 8.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 enableByteMode;
N
N    /** Enables continuous SCLK generation by the SPI master: 0  disable,
N     *  1  enable.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 enableFreeRunSclk;
N
N    /** Active polarity of slave select lines 0-3. This is bit mask where bit
N     *  SPI_1_CARD_SPI_SLAVE_SELECT0 corresponds to slave select 0
N     *  polarity, bit SPI_1_CARD_SPI_SLAVE_SELECT1  slave select 1
N     *  polarity and so on. Polarity constants are:
N     *  - SPI_1_CARD_SPI_SS_ACTIVE_LOW
N     *  - SPI_1_CARD_SPI_SS_ACTIVE_HIGH
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 polaritySs;
N} SPI_1_CARD_SPI_INIT_STRUCT;
N
N
N/* SPI_1_CARD_UART_INIT_STRUCT */
Ntypedef struct
N{
N    /** Mode of operation for the UART. The following defines are available
N     *  choices:
N     *  - SPI_1_CARD_UART_MODE_STD
N     *  - SPI_1_CARD_UART_MODE_SMARTCARD
N     *  - SPI_1_CARD_UART_MODE_IRDA
N    */
N    uint32 mode;
N
N    /** Direction of operation for the UART. The following defines are available
N     *  choices:
N     *  - SPI_1_CARD_UART_TX_RX
N     *  - SPI_1_CARD_UART_RX
N     *  - SPI_1_CARD_UART_TX
N    */
N    uint32 direction;
N
N    /** Number of data bits.
N    */
N    uint32 dataBits;
N
N    /** Determines the parity. The following defines are available choices:
N     *  - SPI_1_CARD_UART_PARITY_EVEN
N     *  - SPI_1_CARD_UART_PARITY_ODD
N     *  - SPI_1_CARD_UART_PARITY_NONE
N    */
N    uint32 parity;
N
N    /** Determines the number of stop bits. The following defines are available
N     *  choices:
N     *  - SPI_1_CARD_UART_STOP_BITS_1
N     *  - SPI_1_CARD_UART_STOP_BITS_1_5
N     *  - SPI_1_CARD_UART_STOP_BITS_2
N    */
N    uint32 stopBits;
N
N    /** Oversampling factor for the UART.
N     *
N     *  Note The oversampling factor values are changed when enableIrdaLowPower
N     *  is enabled:
N     *  - SPI_1_CARD_UART_IRDA_LP_OVS16
N     *  - SPI_1_CARD_UART_IRDA_LP_OVS32
N     *  - SPI_1_CARD_UART_IRDA_LP_OVS48
N     *  - SPI_1_CARD_UART_IRDA_LP_OVS96
N     *  - SPI_1_CARD_UART_IRDA_LP_OVS192
N     *  - SPI_1_CARD_UART_IRDA_LP_OVS768
N     *  - SPI_1_CARD_UART_IRDA_LP_OVS1536
N    */
N    uint32 oversample;
N
N    /** Enables IrDA low power RX mode operation: 0  disable, 1  enable.
N     *  The TX functionality does not work when enabled.
N    */
N    uint32 enableIrdaLowPower;
N
N    /** Applies median filter on the input lines:  0  not applied, 1  applied.
N    */
N    uint32 enableMedianFilter;
N
N    /** Enables retry when NACK response was received: 0  disable, 1  enable.
N     *  Only current content of TX FIFO is re-sent.
N     *  Ignored for modes other than SmartCard.
N    */
N    uint32 enableRetryNack;
N
N    /** Inverts polarity of RX line: 0  non-inverting, 1  inverting.
N     *  Ignored for modes other than IrDA.
N    */
N    uint32 enableInvertedRx;
N
N    /** Drop data from RX FIFO if parity error is detected: 0  disable,
N     *  1  enable.
N    */
N    uint32 dropOnParityErr;
N
N    /** Drop data from RX FIFO if a frame error is detected: 0  disable,
N     *  1  enable.
N    */
N    uint32 dropOnFrameErr;
N
N    /** Enables wakeup from low power mode: 0  disable, 1  enable.
N     *  Ignored for modes other than standard UART. The RX functionality
N     *  has to be enabled.
N    */
N    uint32 enableWake;
N
N    /** Size of the RX buffer in bytes/words (depends on rxDataBits parameter).
N     *  A value equal to the RX FIFO depth implies the usage of buffering in
N     *  hardware. A value greater than the RX FIFO depth results in a software
N     *  buffer.
N     *  The SPI_1_CARD_INTR _RX_NOT_EMPTY interrupt has to be enabled to
N     *  transfer data into the software buffer.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words for PSoC 4100 /
N     *    PSoC 4200 devices.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words or 16
N     *    bytes (Byte mode is enabled) for PSoC 4100 BLE / PSoC 4200 BLE /
N     *    PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *    PSoC Analog Coprocessor devices.
N    */
N    uint32 rxBufferSize;
N
N    /** Buffer space provided for a RX software buffer:
N     *  - A NULL pointer must be provided to use hardware buffering.
N     *  - A pointer to an allocated buffer must be provided to use software
N     *    buffering. The buffer size must equal (rxBufferSize + 1) in bytes if
N     *    dataBitsRx is less or equal to 8, otherwise (2 * (rxBufferSize + 1))
N     *    in bytes. The software RX buffer always keeps one element empty.
N     *    For correct operation the allocated RX buffer has to be one element
N     *    greater than maximum packet size expected to be received.
N    */
N    uint8* rxBuffer;
N
N    /** Size of the TX buffer in bytes/words(depends on txDataBits parameter).
N     *  A value equal to the TX FIFO depth implies the usage of buffering in
N     *  hardware. A value greater than the TX FIFO depth results in a software
N     *  buffer.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words for PSoC 4100 /
N     *    PSoC 4200 devices.
N     *  - The RX and TX FIFO depth is equal to 8 bytes/words or 16
N     *    bytes (Byte mode is enabled) for PSoC 4100 BLE / PSoC 4200 BLE /
N     *    PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *    PSoC Analog Coprocessor devices.
N    */
N    uint32 txBufferSize;
N
N    /** Buffer space provided for a TX software buffer:
N     *  - A NULL pointer must be provided to use hardware buffering.
N     *  - A pointer to an allocated buffer must be provided to use software
N     *    buffering. The buffer size must equal txBufferSize if dataBitsTx is
N     *    less or equal to 8, otherwise (2* txBufferSize).
N    */
N    uint8* txBuffer;
N
N    /** Enables multiprocessor mode: 0  disable, 1  enable.
N    */
N    uint32 enableMultiproc;
N
N    /** Enables matched address to be accepted: 0  disable, 1  enable.
N    */
N    uint32 multiprocAcceptAddr;
N
N    /** 8 bit address to match in Multiprocessor mode. Ignored for other modes.
N    */
N    uint32 multiprocAddr;
N
N    /** 8 bit mask of address bits that are compared for a Multiprocessor
N     *  address match. Ignored for other modes.
N     *  - Bit value 0  excludes bit from address comparison.
N     *  - Bit value 1  the bit needs to match with the corresponding bit
N     *   of the device address.
N    */
N    uint32 multiprocAddrMask;
N
N    /** Enables component interrupt: 0  disable, 1  enable.
N     *  The interrupt has to be enabled if software buffer is used.
N    */
N    uint32 enableInterrupt;
N
N    /** Mask of interrupt sources to enable in the RX direction. This mask is
N     *  written regardless of the setting of the enableInterrupt field.
N     *  Multiple sources are enabled by providing a value that is the OR of
N     *  all of the following sources to enable:
N     *  - SPI_1_CARD_INTR_RX_FIFO_LEVEL
N     *  - SPI_1_CARD_INTR_RX_NOT_EMPTY
N     *  - SPI_1_CARD_INTR_RX_FULL
N     *  - SPI_1_CARD_INTR_RX_OVERFLOW
N     *  - SPI_1_CARD_INTR_RX_UNDERFLOW
N     *  - SPI_1_CARD_INTR_RX_FRAME_ERROR
N     *  - SPI_1_CARD_INTR_RX_PARITY_ERROR
N    */
N    uint32 rxInterruptMask;
N
N    /** FIFO level for an RX FIFO level interrupt. This value is written
N     *  regardless of whether the RX FIFO level interrupt source is enabled.
N    */
N    uint32 rxTriggerLevel;
N
N    /** Mask of interrupt sources to enable in the TX direction. This mask is
N     *  written regardless of the setting of the enableInterrupt field.
N     *  Multiple sources are enabled by providing a value that is the OR of
N     *  all of the following sources to enable:
N     *  - SPI_1_CARD_INTR_TX_FIFO_LEVEL
N     *  - SPI_1_CARD_INTR_TX_NOT_FULL
N     *  - SPI_1_CARD_INTR_TX_EMPTY
N     *  - SPI_1_CARD_INTR_TX_OVERFLOW
N     *  - SPI_1_CARD_INTR_TX_UNDERFLOW
N     *  - SPI_1_CARD_INTR_TX_UART_DONE
N     *  - SPI_1_CARD_INTR_TX_UART_NACK
N     *  - SPI_1_CARD_INTR_TX_UART_ARB_LOST
N    */
N    uint32 txInterruptMask;
N
N    /** FIFO level for a TX FIFO level interrupt. This value is written
N     *  regardless of whether the TX FIFO level interrupt source is enabled.
N    */
N    uint32 txTriggerLevel;
N
N    /** When enabled the TX and RX FIFO depth is doubled and equal to
N     *  16 bytes: 0  disable, 1  enable. This implies that number of
N     *  Data bits must be less than or equal to 8.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 enableByteMode;
N
N    /** Enables usage of CTS input signal by the UART transmitter : 0  disable,
N     *  1  enable.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 enableCts;
N
N    /** Sets active polarity of CTS input signal:
N     *  - SPI_1_CARD_UART_CTS_ACTIVE_LOW
N     *  - SPI_1_CARD_UART_CTS_ACTIVE_HIGH
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 ctsPolarity;
N
N    /** RX FIFO level for RTS signal activation. While the RX FIFO has fewer
N     *  entries than the RTS FIFO level value the RTS signal remains active,
N     *  otherwise the RTS signal becomes inactive. By setting this field to 0,
N     *  RTS signal activation is disabled.
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 rtsRxFifoLevel;
N
N    /** Sets active polarity of RTS output signal:
N     *  - SPI_1_CARD_UART_RTS_ ACTIVE_LOW
N     *  - SPI_1_CARD_UART_RTS_ACTIVE_HIGH
N     *
N     *  Ignored for all devices other than PSoC 4100 BLE / PSoC 4200 BLE /
N     *  PSoC 4100M / PSoC 4200M / PSoC 4200L / PSoC 4000S / PSoC 4100S /
N     *  PSoC Analog Coprocessor.
N    */
N    uint8 rtsPolarity;
N
N    /** Configures the width of a break signal in that triggers the break
N     *  detection interrupt source. A Break is a low level on the RX line.
N     *  Valid range is 1-16 UART bits times.
N    */
N    uint8 breakWidth;
N} SPI_1_CARD_UART_INIT_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
N/**
N* \addtogroup group_spi
N* @{
N*/
N/* SPI specific functions */
N#if(SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (2u)))
S    void SPI_1_CARD_SpiInit(const SPI_1_CARD_SPI_INIT_STRUCT *config);
N#endif /* (SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N
N#if(SPI_1_CARD_SCB_MODE_SPI_INC)
X#if((0u !=((0x02u) & (2u))))
N    /*******************************************************************************
N    * Function Name: SPI_1_CARD_SpiIsBusBusy
N    ****************************************************************************//**
N    *
N    *  Returns the current status on the bus. The bus status is determined using
N    *  the slave select signal.
N    *  - Motorola and National Semiconductor sub-modes: The bus is busy after
N    *    the slave select line is activated and lasts until the slave select line
N    *    is deactivated.
N    *  - Texas Instrument sub-modes: The bus is busy at the moment of the initial
N    *    pulse on the slave select line and lasts until the transfer is complete.
N    *    If SPI Master is configured to use "Separated transfers"
N    *    (see Continuous versus Separated Transfer Separation), the bus is busy
N    *    during each element transfer and is free between each element transfer.
N    *    The Master does not activate SS line immediately after data has been
N    *    written into the TX FIFO.
N    *
N    *  \return slaveSelect: Current status on the bus.
N    *   If the returned value is nonzero, the bus is busy.
N    *   If zero is returned, the bus is free. The bus status is determined using
N    *   the slave select signal.
N    *
N    *******************************************************************************/
N    #define SPI_1_CARD_SpiIsBusBusy() ((uint32) (0u != (SPI_1_CARD_SPI_STATUS_REG & \
N                                                              SPI_1_CARD_SPI_STATUS_BUS_BUSY)))
X    #define SPI_1_CARD_SpiIsBusBusy() ((uint32) (0u != (SPI_1_CARD_SPI_STATUS_REG &                                                               SPI_1_CARD_SPI_STATUS_BUS_BUSY)))
N
N    #if (SPI_1_CARD_SPI_MASTER_CONST)
X    #if (((1u) == (1u)))
N        void SPI_1_CARD_SpiSetActiveSlaveSelect(uint32 slaveSelect);
N    #endif /*(SPI_1_CARD_SPI_MASTER_CONST) */
N
N    #if !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1)
X    #if !((2 == 0u) || (2 == 1u))
N        void SPI_1_CARD_SpiSetSlaveSelectPolarity(uint32 slaveSelect, uint32 polarity);
N    #endif /* !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1) */
N#endif /* (SPI_1_CARD_SCB_MODE_SPI_INC) */
N/** @} spi */
N
N/**
N* \addtogroup group_uart
N* @{
N*/
N/* UART specific functions */
N#if(SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (2u)))
S    void SPI_1_CARD_UartInit(const SPI_1_CARD_UART_INIT_STRUCT *config);
N#endif /* (SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N#if(SPI_1_CARD_SCB_MODE_UART_INC)
X#if((0u !=((0x04u) & (2u))))
S    void SPI_1_CARD_UartSetRxAddress(uint32 address);
S    void SPI_1_CARD_UartSetRxAddressMask(uint32 addressMask);
S
S
S    /* UART RX direction APIs */
S    #if(SPI_1_CARD_UART_RX_DIRECTION)
S        uint32 SPI_1_CARD_UartGetChar(void);
S        uint32 SPI_1_CARD_UartGetByte(void);
S
S        #if !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1)
S            /* UART APIs for Flow Control */
S            void SPI_1_CARD_UartSetRtsPolarity(uint32 polarity);
S            void SPI_1_CARD_UartSetRtsFifoLevel(uint32 level);
S        #endif /* !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1) */
S    #endif /* (SPI_1_CARD_UART_RX_DIRECTION) */
S
S    /* UART TX direction APIs */
S    #if(SPI_1_CARD_UART_TX_DIRECTION)
S        /*******************************************************************************
S        * Function Name: SPI_1_CARD_UartPutChar
S        ****************************************************************************//**
S        *
S        *  Places a byte of data in the transmit buffer to be sent at the next available
S        *  bus time. This function is blocking and waits until there is a space
S        *  available to put requested data in the transmit buffer.
S        *  For UART Multi Processor mode this function can send 9-bits data as well.
S        *  Use SPI_1_CARD_UART_MP_MARK to add a mark to create an address byte.
S        *
S        *  \param txDataByte: the data to be transmitted.
S        *
S        *******************************************************************************/
S        #define SPI_1_CARD_UartPutChar(ch)    SPI_1_CARD_SpiUartWriteTxData((uint32)(ch))
S
S        void SPI_1_CARD_UartPutString(const char8 string[]);
S        void SPI_1_CARD_UartPutCRLF(uint32 txDataByte);
S        void SPI_1_CARD_UartSendBreakBlocking(uint32 breakWidth);
S
S        #if !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1)
S            /* UART APIs for Flow Control */
S            void SPI_1_CARD_UartEnableCts(void);
S            void SPI_1_CARD_UartDisableCts(void);
S            void SPI_1_CARD_UartSetCtsPolarity(uint32 polarity);
S        #endif /* !(SPI_1_CARD_CY_SCBIP_V0 || SPI_1_CARD_CY_SCBIP_V1) */
S    #endif /* (SPI_1_CARD_UART_TX_DIRECTION) */
N#endif /* (SPI_1_CARD_SCB_MODE_UART_INC) */
N/** @} uart */
N
N/**
N* \addtogroup group_spi_uart
N* @{
N*/
N#if(SPI_1_CARD_RX_DIRECTION)
X#if(((((0x02u) == (2u))) ? ((1u)) : (SPI_1_CARD_UART_RX_DIRECTION)))
N    uint32 SPI_1_CARD_SpiUartReadRxData(void);
N    uint32 SPI_1_CARD_SpiUartGetRxBufferSize(void);
N    void   SPI_1_CARD_SpiUartClearRxBuffer(void);
N#endif /* (SPI_1_CARD_RX_DIRECTION) */
N
N/* Common APIs TX direction */
N#if(SPI_1_CARD_TX_DIRECTION)
X#if(((((0x02u) == (2u))) ? ((1u)) : (SPI_1_CARD_UART_TX_DIRECTION)))
N    void   SPI_1_CARD_SpiUartWriteTxData(uint32 txData);
N    void   SPI_1_CARD_SpiUartPutArray(const uint8 wrBuf[], uint32 count);
N    uint32 SPI_1_CARD_SpiUartGetTxBufferSize(void);
N    void   SPI_1_CARD_SpiUartClearTxBuffer(void);
N#endif /* (SPI_1_CARD_TX_DIRECTION) */
N/** @} spi_uart */
N
NCY_ISR_PROTO(SPI_1_CARD_SPI_UART_ISR);
Xvoid SPI_1_CARD_SPI_UART_ISR (void);
N
N#if(SPI_1_CARD_UART_RX_WAKEUP_IRQ)
X#if((0u == (1u)))
S    CY_ISR_PROTO(SPI_1_CARD_UART_WAKEUP_ISR);
N#endif /* (SPI_1_CARD_UART_RX_WAKEUP_IRQ) */
N
N
N/***************************************
N*     Buffer Access Macro Definitions
N***************************************/
N
N#if(SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (2u)))
S    /* RX direction */
S    void   SPI_1_CARD_PutWordInRxBuffer  (uint32 idx, uint32 rxDataByte);
S    uint32 SPI_1_CARD_GetWordFromRxBuffer(uint32 idx);
S
S    /* TX direction */
S    void   SPI_1_CARD_PutWordInTxBuffer  (uint32 idx, uint32 txDataByte);
S    uint32 SPI_1_CARD_GetWordFromTxBuffer(uint32 idx);
S
N#else
N    /* RX direction */
N    #if(SPI_1_CARD_INTERNAL_RX_SW_BUFFER_CONST)
X    #if(((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u)))))))
S        #define SPI_1_CARD_PutWordInRxBuffer(idx, rxDataByte) \
S                do{                                                 \
S                    SPI_1_CARD_rxBufferInternal[(idx)] = ((uint8) (rxDataByte)); \
S                }while(0)
X        #define SPI_1_CARD_PutWordInRxBuffer(idx, rxDataByte)                 do{                                                                     SPI_1_CARD_rxBufferInternal[(idx)] = ((uint8) (rxDataByte));                 }while(0)
S
S        #define SPI_1_CARD_GetWordFromRxBuffer(idx) SPI_1_CARD_rxBufferInternal[(idx)]
S
N    #endif /* (SPI_1_CARD_INTERNAL_RX_SW_BUFFER_CONST) */
N
N    /* TX direction */
N    #if(SPI_1_CARD_INTERNAL_TX_SW_BUFFER_CONST)
X    #if(((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u)))))))
S        #define SPI_1_CARD_PutWordInTxBuffer(idx, txDataByte) \
S                    do{                                             \
S                        SPI_1_CARD_txBufferInternal[(idx)] = ((uint8) (txDataByte)); \
S                    }while(0)
X        #define SPI_1_CARD_PutWordInTxBuffer(idx, txDataByte)                     do{                                                                     SPI_1_CARD_txBufferInternal[(idx)] = ((uint8) (txDataByte));                     }while(0)
S
S        #define SPI_1_CARD_GetWordFromTxBuffer(idx) SPI_1_CARD_txBufferInternal[(idx)]
S
N    #endif /* (SPI_1_CARD_INTERNAL_TX_SW_BUFFER_CONST) */
N
N#endif /* (SPI_1_CARD_TX_SW_BUFFER_ENABLE) */
N
N
N/***************************************
N*         SPI API Constants
N***************************************/
N
N/* SPI sub mode enum */
N#define SPI_1_CARD_SPI_MODE_MOTOROLA      (0x00u)
N#define SPI_1_CARD_SPI_MODE_TI_COINCIDES  (0x01u)
N#define SPI_1_CARD_SPI_MODE_TI_PRECEDES   (0x11u)
N#define SPI_1_CARD_SPI_MODE_NATIONAL      (0x02u)
N#define SPI_1_CARD_SPI_MODE_MASK          (0x03u)
N#define SPI_1_CARD_SPI_MODE_TI_PRECEDES_MASK  (0x10u)
N#define SPI_1_CARD_SPI_MODE_NS_MICROWIRE  (SPI_1_CARD_SPI_MODE_NATIONAL)
N
N/* SPI phase and polarity mode enum */
N#define SPI_1_CARD_SPI_SCLK_CPHA0_CPOL0   (0x00u)
N#define SPI_1_CARD_SPI_SCLK_CPHA0_CPOL1   (0x02u)
N#define SPI_1_CARD_SPI_SCLK_CPHA1_CPOL0   (0x01u)
N#define SPI_1_CARD_SPI_SCLK_CPHA1_CPOL1   (0x03u)
N
N/* SPI bits order enum */
N#define SPI_1_CARD_BITS_ORDER_LSB_FIRST   (0u)
N#define SPI_1_CARD_BITS_ORDER_MSB_FIRST   (1u)
N
N/* SPI transfer separation enum */
N#define SPI_1_CARD_SPI_TRANSFER_SEPARATED     (0u)
N#define SPI_1_CARD_SPI_TRANSFER_CONTINUOUS    (1u)
N
N/* SPI slave select constants */
N#define SPI_1_CARD_SPI_SLAVE_SELECT0    (SPI_1_CARD_SCB__SS0_POSISTION)
N#define SPI_1_CARD_SPI_SLAVE_SELECT1    (SPI_1_CARD_SCB__SS1_POSISTION)
N#define SPI_1_CARD_SPI_SLAVE_SELECT2    (SPI_1_CARD_SCB__SS2_POSISTION)
N#define SPI_1_CARD_SPI_SLAVE_SELECT3    (SPI_1_CARD_SCB__SS3_POSISTION)
N
N/* SPI slave select polarity settings */
N#define SPI_1_CARD_SPI_SS_ACTIVE_LOW  (0u)
N#define SPI_1_CARD_SPI_SS_ACTIVE_HIGH (1u)
N
N#define SPI_1_CARD_INTR_SPIM_TX_RESTORE   (SPI_1_CARD_INTR_TX_OVERFLOW)
N
N#define SPI_1_CARD_INTR_SPIS_TX_RESTORE     (SPI_1_CARD_INTR_TX_OVERFLOW | \
N                                                 SPI_1_CARD_INTR_TX_UNDERFLOW)
X#define SPI_1_CARD_INTR_SPIS_TX_RESTORE     (SPI_1_CARD_INTR_TX_OVERFLOW |                                                  SPI_1_CARD_INTR_TX_UNDERFLOW)
N
N/***************************************
N*         UART API Constants
N***************************************/
N
N/* UART sub-modes enum */
N#define SPI_1_CARD_UART_MODE_STD          (0u)
N#define SPI_1_CARD_UART_MODE_SMARTCARD    (1u)
N#define SPI_1_CARD_UART_MODE_IRDA         (2u)
N
N/* UART direction enum */
N#define SPI_1_CARD_UART_RX    (1u)
N#define SPI_1_CARD_UART_TX    (2u)
N#define SPI_1_CARD_UART_TX_RX (3u)
N
N/* UART parity enum */
N#define SPI_1_CARD_UART_PARITY_EVEN   (0u)
N#define SPI_1_CARD_UART_PARITY_ODD    (1u)
N#define SPI_1_CARD_UART_PARITY_NONE   (2u)
N
N/* UART stop bits enum */
N#define SPI_1_CARD_UART_STOP_BITS_1   (2u)
N#define SPI_1_CARD_UART_STOP_BITS_1_5 (3u)
N#define SPI_1_CARD_UART_STOP_BITS_2   (4u)
N
N/* UART IrDA low power OVS enum */
N#define SPI_1_CARD_UART_IRDA_LP_OVS16     (16u)
N#define SPI_1_CARD_UART_IRDA_LP_OVS32     (32u)
N#define SPI_1_CARD_UART_IRDA_LP_OVS48     (48u)
N#define SPI_1_CARD_UART_IRDA_LP_OVS96     (96u)
N#define SPI_1_CARD_UART_IRDA_LP_OVS192    (192u)
N#define SPI_1_CARD_UART_IRDA_LP_OVS768    (768u)
N#define SPI_1_CARD_UART_IRDA_LP_OVS1536   (1536u)
N
N/* Uart MP: mark (address) and space (data) bit definitions */
N#define SPI_1_CARD_UART_MP_MARK       (0x100u)
N#define SPI_1_CARD_UART_MP_SPACE      (0x000u)
N
N/* UART CTS/RTS polarity settings */
N#define SPI_1_CARD_UART_CTS_ACTIVE_LOW    (0u)
N#define SPI_1_CARD_UART_CTS_ACTIVE_HIGH   (1u)
N#define SPI_1_CARD_UART_RTS_ACTIVE_LOW    (0u)
N#define SPI_1_CARD_UART_RTS_ACTIVE_HIGH   (1u)
N
N/* Sources of RX errors */
N#define SPI_1_CARD_INTR_RX_ERR        (SPI_1_CARD_INTR_RX_OVERFLOW    | \
N                                             SPI_1_CARD_INTR_RX_UNDERFLOW   | \
N                                             SPI_1_CARD_INTR_RX_FRAME_ERROR | \
N                                             SPI_1_CARD_INTR_RX_PARITY_ERROR)
X#define SPI_1_CARD_INTR_RX_ERR        (SPI_1_CARD_INTR_RX_OVERFLOW    |                                              SPI_1_CARD_INTR_RX_UNDERFLOW   |                                              SPI_1_CARD_INTR_RX_FRAME_ERROR |                                              SPI_1_CARD_INTR_RX_PARITY_ERROR)
N
N/* Shifted INTR_RX_ERR defines ONLY for SPI_1_CARD_UartGetByte() */
N#define SPI_1_CARD_UART_RX_OVERFLOW       (SPI_1_CARD_INTR_RX_OVERFLOW << 8u)
N#define SPI_1_CARD_UART_RX_UNDERFLOW      (SPI_1_CARD_INTR_RX_UNDERFLOW << 8u)
N#define SPI_1_CARD_UART_RX_FRAME_ERROR    (SPI_1_CARD_INTR_RX_FRAME_ERROR << 8u)
N#define SPI_1_CARD_UART_RX_PARITY_ERROR   (SPI_1_CARD_INTR_RX_PARITY_ERROR << 8u)
N#define SPI_1_CARD_UART_RX_ERROR_MASK     (SPI_1_CARD_UART_RX_OVERFLOW    | \
N                                                 SPI_1_CARD_UART_RX_UNDERFLOW   | \
N                                                 SPI_1_CARD_UART_RX_FRAME_ERROR | \
N                                                 SPI_1_CARD_UART_RX_PARITY_ERROR)
X#define SPI_1_CARD_UART_RX_ERROR_MASK     (SPI_1_CARD_UART_RX_OVERFLOW    |                                                  SPI_1_CARD_UART_RX_UNDERFLOW   |                                                  SPI_1_CARD_UART_RX_FRAME_ERROR |                                                  SPI_1_CARD_UART_RX_PARITY_ERROR)
N
N#define SPI_1_CARD_INTR_UART_TX_RESTORE   (SPI_1_CARD_INTR_TX_OVERFLOW  | \
N                                                 SPI_1_CARD_INTR_TX_UART_NACK | \
N                                                 SPI_1_CARD_INTR_TX_UART_DONE | \
N                                                 SPI_1_CARD_INTR_TX_UART_ARB_LOST)
X#define SPI_1_CARD_INTR_UART_TX_RESTORE   (SPI_1_CARD_INTR_TX_OVERFLOW  |                                                  SPI_1_CARD_INTR_TX_UART_NACK |                                                  SPI_1_CARD_INTR_TX_UART_DONE |                                                  SPI_1_CARD_INTR_TX_UART_ARB_LOST)
N
N
N/***************************************
N*     Vars with External Linkage
N***************************************/
N
N#if(SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (2u)))
S    extern const SPI_1_CARD_SPI_INIT_STRUCT  SPI_1_CARD_configSpi;
S    extern const SPI_1_CARD_UART_INIT_STRUCT SPI_1_CARD_configUart;
N#endif /* (SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N#if (SPI_1_CARD_UART_WAKE_ENABLE_CONST && SPI_1_CARD_UART_RX_WAKEUP_IRQ)
X#if ((0u) && (0u == (1u)))
S    extern uint8 SPI_1_CARD_skipStart;
N#endif /* (SPI_1_CARD_UART_WAKE_ENABLE_CONST && SPI_1_CARD_UART_RX_WAKEUP_IRQ) */
N
N
N/***************************************
N*    Specific SPI Macro Definitions
N***************************************/
N
N#define SPI_1_CARD_GET_SPI_INTR_SLAVE_MASK(sourceMask)  ((sourceMask) & SPI_1_CARD_INTR_SLAVE_SPI_BUS_ERROR)
N#define SPI_1_CARD_GET_SPI_INTR_MASTER_MASK(sourceMask) ((sourceMask) & SPI_1_CARD_INTR_MASTER_SPI_DONE)
N#define SPI_1_CARD_GET_SPI_INTR_RX_MASK(sourceMask) \
N                                             ((sourceMask) & (uint32) ~SPI_1_CARD_INTR_SLAVE_SPI_BUS_ERROR)
X#define SPI_1_CARD_GET_SPI_INTR_RX_MASK(sourceMask)                                              ((sourceMask) & (uint32) ~SPI_1_CARD_INTR_SLAVE_SPI_BUS_ERROR)
N
N#define SPI_1_CARD_GET_SPI_INTR_TX_MASK(sourceMask) \
N                                             ((sourceMask) & (uint32) ~SPI_1_CARD_INTR_MASTER_SPI_DONE)
X#define SPI_1_CARD_GET_SPI_INTR_TX_MASK(sourceMask)                                              ((sourceMask) & (uint32) ~SPI_1_CARD_INTR_MASTER_SPI_DONE)
N
N
N/***************************************
N*    Specific UART Macro Definitions
N***************************************/
N
N#define SPI_1_CARD_UART_GET_CTRL_OVS_IRDA_LP(oversample) \
N        ((SPI_1_CARD_UART_IRDA_LP_OVS16   == (oversample)) ? SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS16 : \
N         ((SPI_1_CARD_UART_IRDA_LP_OVS32   == (oversample)) ? SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS32 : \
N          ((SPI_1_CARD_UART_IRDA_LP_OVS48   == (oversample)) ? SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS48 : \
N           ((SPI_1_CARD_UART_IRDA_LP_OVS96   == (oversample)) ? SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS96 : \
N            ((SPI_1_CARD_UART_IRDA_LP_OVS192  == (oversample)) ? SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS192 : \
N             ((SPI_1_CARD_UART_IRDA_LP_OVS768  == (oversample)) ? SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS768 : \
N              ((SPI_1_CARD_UART_IRDA_LP_OVS1536 == (oversample)) ? SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS1536 : \
N                                                                          SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS16)))))))
X#define SPI_1_CARD_UART_GET_CTRL_OVS_IRDA_LP(oversample)         ((SPI_1_CARD_UART_IRDA_LP_OVS16   == (oversample)) ? SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS16 :          ((SPI_1_CARD_UART_IRDA_LP_OVS32   == (oversample)) ? SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS32 :           ((SPI_1_CARD_UART_IRDA_LP_OVS48   == (oversample)) ? SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS48 :            ((SPI_1_CARD_UART_IRDA_LP_OVS96   == (oversample)) ? SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS96 :             ((SPI_1_CARD_UART_IRDA_LP_OVS192  == (oversample)) ? SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS192 :              ((SPI_1_CARD_UART_IRDA_LP_OVS768  == (oversample)) ? SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS768 :               ((SPI_1_CARD_UART_IRDA_LP_OVS1536 == (oversample)) ? SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS1536 :                                                                           SPI_1_CARD_CTRL_OVS_IRDA_LP_OVS16)))))))
N
N#define SPI_1_CARD_GET_UART_RX_CTRL_ENABLED(direction) ((0u != (SPI_1_CARD_UART_RX & (direction))) ? \
N                                                                     (SPI_1_CARD_RX_CTRL_ENABLED) : (0u))
X#define SPI_1_CARD_GET_UART_RX_CTRL_ENABLED(direction) ((0u != (SPI_1_CARD_UART_RX & (direction))) ?                                                                      (SPI_1_CARD_RX_CTRL_ENABLED) : (0u))
N
N#define SPI_1_CARD_GET_UART_TX_CTRL_ENABLED(direction) ((0u != (SPI_1_CARD_UART_TX & (direction))) ? \
N                                                                     (SPI_1_CARD_TX_CTRL_ENABLED) : (0u))
X#define SPI_1_CARD_GET_UART_TX_CTRL_ENABLED(direction) ((0u != (SPI_1_CARD_UART_TX & (direction))) ?                                                                      (SPI_1_CARD_TX_CTRL_ENABLED) : (0u))
N
N
N/***************************************
N*        SPI Register Settings
N***************************************/
N
N#define SPI_1_CARD_CTRL_SPI      (SPI_1_CARD_CTRL_MODE_SPI)
N#define SPI_1_CARD_SPI_RX_CTRL   (SPI_1_CARD_RX_CTRL_ENABLED)
N#define SPI_1_CARD_SPI_TX_CTRL   (SPI_1_CARD_TX_CTRL_ENABLED)
N
N
N/***************************************
N*       SPI Init Register Settings
N***************************************/
N
N#define SPI_1_CARD_SPI_SS_POLARITY \
N             (((uint32) SPI_1_CARD_SPI_SS0_POLARITY << SPI_1_CARD_SPI_SLAVE_SELECT0) | \
N              ((uint32) SPI_1_CARD_SPI_SS1_POLARITY << SPI_1_CARD_SPI_SLAVE_SELECT1) | \
N              ((uint32) SPI_1_CARD_SPI_SS2_POLARITY << SPI_1_CARD_SPI_SLAVE_SELECT2) | \
N              ((uint32) SPI_1_CARD_SPI_SS3_POLARITY << SPI_1_CARD_SPI_SLAVE_SELECT3))
X#define SPI_1_CARD_SPI_SS_POLARITY              (((uint32) SPI_1_CARD_SPI_SS0_POLARITY << SPI_1_CARD_SPI_SLAVE_SELECT0) |               ((uint32) SPI_1_CARD_SPI_SS1_POLARITY << SPI_1_CARD_SPI_SLAVE_SELECT1) |               ((uint32) SPI_1_CARD_SPI_SS2_POLARITY << SPI_1_CARD_SPI_SLAVE_SELECT2) |               ((uint32) SPI_1_CARD_SPI_SS3_POLARITY << SPI_1_CARD_SPI_SLAVE_SELECT3))
N
N#if(SPI_1_CARD_SCB_MODE_SPI_CONST_CFG)
X#if(((0x02u) == (2u)))
N
N    /* SPI Configuration */
N    #define SPI_1_CARD_SPI_DEFAULT_CTRL \
N                    (SPI_1_CARD_GET_CTRL_OVS(SPI_1_CARD_SPI_OVS_FACTOR) | \
N                     SPI_1_CARD_GET_CTRL_BYTE_MODE (SPI_1_CARD_SPI_BYTE_MODE_ENABLE) | \
N                     SPI_1_CARD_GET_CTRL_EC_AM_MODE(SPI_1_CARD_SPI_WAKE_ENABLE)      | \
N                     SPI_1_CARD_CTRL_SPI)
X    #define SPI_1_CARD_SPI_DEFAULT_CTRL                     (SPI_1_CARD_GET_CTRL_OVS(SPI_1_CARD_SPI_OVS_FACTOR) |                      SPI_1_CARD_GET_CTRL_BYTE_MODE (SPI_1_CARD_SPI_BYTE_MODE_ENABLE) |                      SPI_1_CARD_GET_CTRL_EC_AM_MODE(SPI_1_CARD_SPI_WAKE_ENABLE)      |                      SPI_1_CARD_CTRL_SPI)
N
N    #define SPI_1_CARD_SPI_DEFAULT_SPI_CTRL \
N                    (SPI_1_CARD_GET_SPI_CTRL_CONTINUOUS    (SPI_1_CARD_SPI_TRANSFER_SEPARATION)       | \
N                     SPI_1_CARD_GET_SPI_CTRL_SELECT_PRECEDE(SPI_1_CARD_SPI_SUB_MODE &                   \
N                                                                  SPI_1_CARD_SPI_MODE_TI_PRECEDES_MASK)     | \
N                     SPI_1_CARD_GET_SPI_CTRL_SCLK_MODE     (SPI_1_CARD_SPI_CLOCK_MODE)                | \
N                     SPI_1_CARD_GET_SPI_CTRL_LATE_MISO_SAMPLE(SPI_1_CARD_SPI_LATE_MISO_SAMPLE_ENABLE) | \
N                     SPI_1_CARD_GET_SPI_CTRL_SCLK_CONTINUOUS(SPI_1_CARD_SPI_FREE_RUN_SCLK_ENABLE)     | \
N                     SPI_1_CARD_GET_SPI_CTRL_SSEL_POLARITY (SPI_1_CARD_SPI_SS_POLARITY)               | \
N                     SPI_1_CARD_GET_SPI_CTRL_SUB_MODE      (SPI_1_CARD_SPI_SUB_MODE)                  | \
N                     SPI_1_CARD_GET_SPI_CTRL_MASTER_MODE   (SPI_1_CARD_SPI_MODE))
X    #define SPI_1_CARD_SPI_DEFAULT_SPI_CTRL                     (SPI_1_CARD_GET_SPI_CTRL_CONTINUOUS    (SPI_1_CARD_SPI_TRANSFER_SEPARATION)       |                      SPI_1_CARD_GET_SPI_CTRL_SELECT_PRECEDE(SPI_1_CARD_SPI_SUB_MODE &                                                                                     SPI_1_CARD_SPI_MODE_TI_PRECEDES_MASK)     |                      SPI_1_CARD_GET_SPI_CTRL_SCLK_MODE     (SPI_1_CARD_SPI_CLOCK_MODE)                |                      SPI_1_CARD_GET_SPI_CTRL_LATE_MISO_SAMPLE(SPI_1_CARD_SPI_LATE_MISO_SAMPLE_ENABLE) |                      SPI_1_CARD_GET_SPI_CTRL_SCLK_CONTINUOUS(SPI_1_CARD_SPI_FREE_RUN_SCLK_ENABLE)     |                      SPI_1_CARD_GET_SPI_CTRL_SSEL_POLARITY (SPI_1_CARD_SPI_SS_POLARITY)               |                      SPI_1_CARD_GET_SPI_CTRL_SUB_MODE      (SPI_1_CARD_SPI_SUB_MODE)                  |                      SPI_1_CARD_GET_SPI_CTRL_MASTER_MODE   (SPI_1_CARD_SPI_MODE))
N
N    /* RX direction */
N    #define SPI_1_CARD_SPI_DEFAULT_RX_CTRL \
N                    (SPI_1_CARD_GET_RX_CTRL_DATA_WIDTH(SPI_1_CARD_SPI_RX_DATA_BITS_NUM)     | \
N                     SPI_1_CARD_GET_RX_CTRL_BIT_ORDER (SPI_1_CARD_SPI_BITS_ORDER)           | \
N                     SPI_1_CARD_GET_RX_CTRL_MEDIAN    (SPI_1_CARD_SPI_MEDIAN_FILTER_ENABLE) | \
N                     SPI_1_CARD_SPI_RX_CTRL)
X    #define SPI_1_CARD_SPI_DEFAULT_RX_CTRL                     (SPI_1_CARD_GET_RX_CTRL_DATA_WIDTH(SPI_1_CARD_SPI_RX_DATA_BITS_NUM)     |                      SPI_1_CARD_GET_RX_CTRL_BIT_ORDER (SPI_1_CARD_SPI_BITS_ORDER)           |                      SPI_1_CARD_GET_RX_CTRL_MEDIAN    (SPI_1_CARD_SPI_MEDIAN_FILTER_ENABLE) |                      SPI_1_CARD_SPI_RX_CTRL)
N
N    #define SPI_1_CARD_SPI_DEFAULT_RX_FIFO_CTRL \
N                    SPI_1_CARD_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(SPI_1_CARD_SPI_RX_TRIGGER_LEVEL)
X    #define SPI_1_CARD_SPI_DEFAULT_RX_FIFO_CTRL                     SPI_1_CARD_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(SPI_1_CARD_SPI_RX_TRIGGER_LEVEL)
N
N    /* TX direction */
N    #define SPI_1_CARD_SPI_DEFAULT_TX_CTRL \
N                    (SPI_1_CARD_GET_TX_CTRL_DATA_WIDTH(SPI_1_CARD_SPI_TX_DATA_BITS_NUM) | \
N                     SPI_1_CARD_GET_TX_CTRL_BIT_ORDER (SPI_1_CARD_SPI_BITS_ORDER)       | \
N                     SPI_1_CARD_SPI_TX_CTRL)
X    #define SPI_1_CARD_SPI_DEFAULT_TX_CTRL                     (SPI_1_CARD_GET_TX_CTRL_DATA_WIDTH(SPI_1_CARD_SPI_TX_DATA_BITS_NUM) |                      SPI_1_CARD_GET_TX_CTRL_BIT_ORDER (SPI_1_CARD_SPI_BITS_ORDER)       |                      SPI_1_CARD_SPI_TX_CTRL)
N
N    #define SPI_1_CARD_SPI_DEFAULT_TX_FIFO_CTRL \
N                    SPI_1_CARD_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(SPI_1_CARD_SPI_TX_TRIGGER_LEVEL)
X    #define SPI_1_CARD_SPI_DEFAULT_TX_FIFO_CTRL                     SPI_1_CARD_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(SPI_1_CARD_SPI_TX_TRIGGER_LEVEL)
N
N    /* Interrupt sources */
N    #define SPI_1_CARD_SPI_DEFAULT_INTR_SPI_EC_MASK   (SPI_1_CARD_NO_INTR_SOURCES)
N
N    #define SPI_1_CARD_SPI_DEFAULT_INTR_I2C_EC_MASK   (SPI_1_CARD_NO_INTR_SOURCES)
N    #define SPI_1_CARD_SPI_DEFAULT_INTR_SLAVE_MASK \
N                    (SPI_1_CARD_SPI_INTR_RX_MASK & SPI_1_CARD_INTR_SLAVE_SPI_BUS_ERROR)
X    #define SPI_1_CARD_SPI_DEFAULT_INTR_SLAVE_MASK                     (SPI_1_CARD_SPI_INTR_RX_MASK & SPI_1_CARD_INTR_SLAVE_SPI_BUS_ERROR)
N
N    #define SPI_1_CARD_SPI_DEFAULT_INTR_MASTER_MASK \
N                    (SPI_1_CARD_SPI_INTR_TX_MASK & SPI_1_CARD_INTR_MASTER_SPI_DONE)
X    #define SPI_1_CARD_SPI_DEFAULT_INTR_MASTER_MASK                     (SPI_1_CARD_SPI_INTR_TX_MASK & SPI_1_CARD_INTR_MASTER_SPI_DONE)
N
N    #define SPI_1_CARD_SPI_DEFAULT_INTR_RX_MASK \
N                    (SPI_1_CARD_SPI_INTR_RX_MASK & (uint32) ~SPI_1_CARD_INTR_SLAVE_SPI_BUS_ERROR)
X    #define SPI_1_CARD_SPI_DEFAULT_INTR_RX_MASK                     (SPI_1_CARD_SPI_INTR_RX_MASK & (uint32) ~SPI_1_CARD_INTR_SLAVE_SPI_BUS_ERROR)
N
N    #define SPI_1_CARD_SPI_DEFAULT_INTR_TX_MASK \
N                    (SPI_1_CARD_SPI_INTR_TX_MASK & (uint32) ~SPI_1_CARD_INTR_MASTER_SPI_DONE)
X    #define SPI_1_CARD_SPI_DEFAULT_INTR_TX_MASK                     (SPI_1_CARD_SPI_INTR_TX_MASK & (uint32) ~SPI_1_CARD_INTR_MASTER_SPI_DONE)
N
N#endif /* (SPI_1_CARD_SCB_MODE_SPI_CONST_CFG) */
N
N
N/***************************************
N*        UART Register Settings
N***************************************/
N
N#define SPI_1_CARD_CTRL_UART      (SPI_1_CARD_CTRL_MODE_UART)
N#define SPI_1_CARD_UART_RX_CTRL   (SPI_1_CARD_RX_CTRL_LSB_FIRST) /* LSB for UART goes first */
N#define SPI_1_CARD_UART_TX_CTRL   (SPI_1_CARD_TX_CTRL_LSB_FIRST) /* LSB for UART goes first */
N
N
N/***************************************
N*      UART Init Register Settings
N***************************************/
N
N#if(SPI_1_CARD_SCB_MODE_UART_CONST_CFG)
X#if(((0x04u) == (2u)))
S
S    /* UART configuration */
S    #if(SPI_1_CARD_UART_MODE_IRDA == SPI_1_CARD_UART_SUB_MODE)
S
S        #define SPI_1_CARD_DEFAULT_CTRL_OVS   ((0u != SPI_1_CARD_UART_IRDA_LOW_POWER) ?              \
S                                (SPI_1_CARD_UART_GET_CTRL_OVS_IRDA_LP(SPI_1_CARD_UART_OVS_FACTOR)) : \
S                                (SPI_1_CARD_CTRL_OVS_IRDA_OVS16))
X        #define SPI_1_CARD_DEFAULT_CTRL_OVS   ((0u != SPI_1_CARD_UART_IRDA_LOW_POWER) ?                                              (SPI_1_CARD_UART_GET_CTRL_OVS_IRDA_LP(SPI_1_CARD_UART_OVS_FACTOR)) :                                 (SPI_1_CARD_CTRL_OVS_IRDA_OVS16))
S
S    #else
S
S        #define SPI_1_CARD_DEFAULT_CTRL_OVS   SPI_1_CARD_GET_CTRL_OVS(SPI_1_CARD_UART_OVS_FACTOR)
S
S    #endif /* (SPI_1_CARD_UART_MODE_IRDA == SPI_1_CARD_UART_SUB_MODE) */
S
S    #define SPI_1_CARD_UART_DEFAULT_CTRL \
S                                (SPI_1_CARD_GET_CTRL_BYTE_MODE  (SPI_1_CARD_UART_BYTE_MODE_ENABLE)  | \
S                                 SPI_1_CARD_GET_CTRL_ADDR_ACCEPT(SPI_1_CARD_UART_MP_ACCEPT_ADDRESS) | \
S                                 SPI_1_CARD_DEFAULT_CTRL_OVS                                              | \
S                                 SPI_1_CARD_CTRL_UART)
X    #define SPI_1_CARD_UART_DEFAULT_CTRL                                 (SPI_1_CARD_GET_CTRL_BYTE_MODE  (SPI_1_CARD_UART_BYTE_MODE_ENABLE)  |                                  SPI_1_CARD_GET_CTRL_ADDR_ACCEPT(SPI_1_CARD_UART_MP_ACCEPT_ADDRESS) |                                  SPI_1_CARD_DEFAULT_CTRL_OVS                                              |                                  SPI_1_CARD_CTRL_UART)
S
S    #define SPI_1_CARD_UART_DEFAULT_UART_CTRL \
S                                    (SPI_1_CARD_GET_UART_CTRL_MODE(SPI_1_CARD_UART_SUB_MODE))
X    #define SPI_1_CARD_UART_DEFAULT_UART_CTRL                                     (SPI_1_CARD_GET_UART_CTRL_MODE(SPI_1_CARD_UART_SUB_MODE))
S
S    /* RX direction */
S    #define SPI_1_CARD_UART_DEFAULT_RX_CTRL_PARITY \
S                                ((SPI_1_CARD_UART_PARITY_NONE != SPI_1_CARD_UART_PARITY_TYPE) ?      \
S                                  (SPI_1_CARD_GET_UART_RX_CTRL_PARITY(SPI_1_CARD_UART_PARITY_TYPE) | \
S                                   SPI_1_CARD_UART_RX_CTRL_PARITY_ENABLED) : (0u))
X    #define SPI_1_CARD_UART_DEFAULT_RX_CTRL_PARITY                                 ((SPI_1_CARD_UART_PARITY_NONE != SPI_1_CARD_UART_PARITY_TYPE) ?                                        (SPI_1_CARD_GET_UART_RX_CTRL_PARITY(SPI_1_CARD_UART_PARITY_TYPE) |                                    SPI_1_CARD_UART_RX_CTRL_PARITY_ENABLED) : (0u))
S
S    #define SPI_1_CARD_UART_DEFAULT_UART_RX_CTRL \
S                    (SPI_1_CARD_GET_UART_RX_CTRL_MODE(SPI_1_CARD_UART_STOP_BITS_NUM)                    | \
S                     SPI_1_CARD_GET_UART_RX_CTRL_POLARITY(SPI_1_CARD_UART_IRDA_POLARITY)                | \
S                     SPI_1_CARD_GET_UART_RX_CTRL_MP_MODE(SPI_1_CARD_UART_MP_MODE_ENABLE)                | \
S                     SPI_1_CARD_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(SPI_1_CARD_UART_DROP_ON_PARITY_ERR) | \
S                     SPI_1_CARD_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(SPI_1_CARD_UART_DROP_ON_FRAME_ERR)   | \
S                     SPI_1_CARD_GET_UART_RX_CTRL_BREAK_WIDTH(SPI_1_CARD_UART_RX_BREAK_WIDTH)            | \
S                     SPI_1_CARD_UART_DEFAULT_RX_CTRL_PARITY)
X    #define SPI_1_CARD_UART_DEFAULT_UART_RX_CTRL                     (SPI_1_CARD_GET_UART_RX_CTRL_MODE(SPI_1_CARD_UART_STOP_BITS_NUM)                    |                      SPI_1_CARD_GET_UART_RX_CTRL_POLARITY(SPI_1_CARD_UART_IRDA_POLARITY)                |                      SPI_1_CARD_GET_UART_RX_CTRL_MP_MODE(SPI_1_CARD_UART_MP_MODE_ENABLE)                |                      SPI_1_CARD_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(SPI_1_CARD_UART_DROP_ON_PARITY_ERR) |                      SPI_1_CARD_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(SPI_1_CARD_UART_DROP_ON_FRAME_ERR)   |                      SPI_1_CARD_GET_UART_RX_CTRL_BREAK_WIDTH(SPI_1_CARD_UART_RX_BREAK_WIDTH)            |                      SPI_1_CARD_UART_DEFAULT_RX_CTRL_PARITY)
S
S
S    #define SPI_1_CARD_UART_DEFAULT_RX_CTRL \
S                                (SPI_1_CARD_GET_RX_CTRL_DATA_WIDTH(SPI_1_CARD_UART_DATA_BITS_NUM)        | \
S                                 SPI_1_CARD_GET_RX_CTRL_MEDIAN    (SPI_1_CARD_UART_MEDIAN_FILTER_ENABLE) | \
S                                 SPI_1_CARD_GET_UART_RX_CTRL_ENABLED(SPI_1_CARD_UART_DIRECTION))
X    #define SPI_1_CARD_UART_DEFAULT_RX_CTRL                                 (SPI_1_CARD_GET_RX_CTRL_DATA_WIDTH(SPI_1_CARD_UART_DATA_BITS_NUM)        |                                  SPI_1_CARD_GET_RX_CTRL_MEDIAN    (SPI_1_CARD_UART_MEDIAN_FILTER_ENABLE) |                                  SPI_1_CARD_GET_UART_RX_CTRL_ENABLED(SPI_1_CARD_UART_DIRECTION))
S
S    #define SPI_1_CARD_UART_DEFAULT_RX_FIFO_CTRL \
S                                SPI_1_CARD_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(SPI_1_CARD_UART_RX_TRIGGER_LEVEL)
X    #define SPI_1_CARD_UART_DEFAULT_RX_FIFO_CTRL                                 SPI_1_CARD_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(SPI_1_CARD_UART_RX_TRIGGER_LEVEL)
S
S    #define SPI_1_CARD_UART_DEFAULT_RX_MATCH_REG  ((0u != SPI_1_CARD_UART_MP_MODE_ENABLE) ?          \
S                                (SPI_1_CARD_GET_RX_MATCH_ADDR(SPI_1_CARD_UART_MP_RX_ADDRESS) | \
S                                 SPI_1_CARD_GET_RX_MATCH_MASK(SPI_1_CARD_UART_MP_RX_ADDRESS_MASK)) : (0u))
X    #define SPI_1_CARD_UART_DEFAULT_RX_MATCH_REG  ((0u != SPI_1_CARD_UART_MP_MODE_ENABLE) ?                                          (SPI_1_CARD_GET_RX_MATCH_ADDR(SPI_1_CARD_UART_MP_RX_ADDRESS) |                                  SPI_1_CARD_GET_RX_MATCH_MASK(SPI_1_CARD_UART_MP_RX_ADDRESS_MASK)) : (0u))
S
S    /* TX direction */
S    #define SPI_1_CARD_UART_DEFAULT_TX_CTRL_PARITY (SPI_1_CARD_UART_DEFAULT_RX_CTRL_PARITY)
S
S    #define SPI_1_CARD_UART_DEFAULT_UART_TX_CTRL \
S                                (SPI_1_CARD_GET_UART_TX_CTRL_MODE(SPI_1_CARD_UART_STOP_BITS_NUM)       | \
S                                 SPI_1_CARD_GET_UART_TX_CTRL_RETRY_NACK(SPI_1_CARD_UART_RETRY_ON_NACK) | \
S                                 SPI_1_CARD_UART_DEFAULT_TX_CTRL_PARITY)
X    #define SPI_1_CARD_UART_DEFAULT_UART_TX_CTRL                                 (SPI_1_CARD_GET_UART_TX_CTRL_MODE(SPI_1_CARD_UART_STOP_BITS_NUM)       |                                  SPI_1_CARD_GET_UART_TX_CTRL_RETRY_NACK(SPI_1_CARD_UART_RETRY_ON_NACK) |                                  SPI_1_CARD_UART_DEFAULT_TX_CTRL_PARITY)
S
S    #define SPI_1_CARD_UART_DEFAULT_TX_CTRL \
S                                (SPI_1_CARD_GET_TX_CTRL_DATA_WIDTH(SPI_1_CARD_UART_DATA_BITS_NUM) | \
S                                 SPI_1_CARD_GET_UART_TX_CTRL_ENABLED(SPI_1_CARD_UART_DIRECTION))
X    #define SPI_1_CARD_UART_DEFAULT_TX_CTRL                                 (SPI_1_CARD_GET_TX_CTRL_DATA_WIDTH(SPI_1_CARD_UART_DATA_BITS_NUM) |                                  SPI_1_CARD_GET_UART_TX_CTRL_ENABLED(SPI_1_CARD_UART_DIRECTION))
S
S    #define SPI_1_CARD_UART_DEFAULT_TX_FIFO_CTRL \
S                                SPI_1_CARD_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(SPI_1_CARD_UART_TX_TRIGGER_LEVEL)
X    #define SPI_1_CARD_UART_DEFAULT_TX_FIFO_CTRL                                 SPI_1_CARD_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(SPI_1_CARD_UART_TX_TRIGGER_LEVEL)
S
S    #define SPI_1_CARD_UART_DEFAULT_FLOW_CTRL \
S                        (SPI_1_CARD_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(SPI_1_CARD_UART_RTS_FIFO_LEVEL) | \
S                         SPI_1_CARD_GET_UART_FLOW_CTRL_RTS_POLARITY (SPI_1_CARD_UART_RTS_POLARITY)   | \
S                         SPI_1_CARD_GET_UART_FLOW_CTRL_CTS_POLARITY (SPI_1_CARD_UART_CTS_POLARITY)   | \
S                         SPI_1_CARD_GET_UART_FLOW_CTRL_CTS_ENABLE   (SPI_1_CARD_UART_CTS_ENABLE))
X    #define SPI_1_CARD_UART_DEFAULT_FLOW_CTRL                         (SPI_1_CARD_GET_UART_FLOW_CTRL_TRIGGER_LEVEL(SPI_1_CARD_UART_RTS_FIFO_LEVEL) |                          SPI_1_CARD_GET_UART_FLOW_CTRL_RTS_POLARITY (SPI_1_CARD_UART_RTS_POLARITY)   |                          SPI_1_CARD_GET_UART_FLOW_CTRL_CTS_POLARITY (SPI_1_CARD_UART_CTS_POLARITY)   |                          SPI_1_CARD_GET_UART_FLOW_CTRL_CTS_ENABLE   (SPI_1_CARD_UART_CTS_ENABLE))
S
S    /* Interrupt sources */
S    #define SPI_1_CARD_UART_DEFAULT_INTR_I2C_EC_MASK  (SPI_1_CARD_NO_INTR_SOURCES)
S    #define SPI_1_CARD_UART_DEFAULT_INTR_SPI_EC_MASK  (SPI_1_CARD_NO_INTR_SOURCES)
S    #define SPI_1_CARD_UART_DEFAULT_INTR_SLAVE_MASK   (SPI_1_CARD_NO_INTR_SOURCES)
S    #define SPI_1_CARD_UART_DEFAULT_INTR_MASTER_MASK  (SPI_1_CARD_NO_INTR_SOURCES)
S    #define SPI_1_CARD_UART_DEFAULT_INTR_RX_MASK      (SPI_1_CARD_UART_INTR_RX_MASK)
S    #define SPI_1_CARD_UART_DEFAULT_INTR_TX_MASK      (SPI_1_CARD_UART_INTR_TX_MASK)
S
N#endif /* (SPI_1_CARD_SCB_MODE_UART_CONST_CFG) */
N
N
N/***************************************
N* The following code is DEPRECATED and
N* must not be used.
N***************************************/
N
N#define SPI_1_CARD_SPIM_ACTIVE_SS0    (SPI_1_CARD_SPI_SLAVE_SELECT0)
N#define SPI_1_CARD_SPIM_ACTIVE_SS1    (SPI_1_CARD_SPI_SLAVE_SELECT1)
N#define SPI_1_CARD_SPIM_ACTIVE_SS2    (SPI_1_CARD_SPI_SLAVE_SELECT2)
N#define SPI_1_CARD_SPIM_ACTIVE_SS3    (SPI_1_CARD_SPI_SLAVE_SELECT3)
N
N#endif /* CY_SCB_SPI_UART_SPI_1_CARD_H */
N
N
N/* [] END OF FILE */
L 47 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD_PINS.h"
N#include "SPI_1_CARD_SPI_UART_PVT.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_SPI_UART_PVT.h" 1
N/***************************************************************************//**
N* \file SPI_1_CARD_SPI_UART_PVT.h
N* \version 4.0
N*
N* \brief
N*  This private file provides constants and parameter values for the
N*  SCB Component in SPI and UART modes.
N*  Please do not use this file or its content in your project.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation. All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_SPI_UART_PVT_SPI_1_CARD_H)
X#if !0L
N#define CY_SCB_SPI_UART_PVT_SPI_1_CARD_H
N
N#include "SPI_1_CARD_SPI_UART.h"
N
N
N/***************************************
N*     Internal Global Vars
N***************************************/
N
N#if (SPI_1_CARD_INTERNAL_RX_SW_BUFFER_CONST)
X#if (((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u)))))))
S    extern volatile uint32  SPI_1_CARD_rxBufferHead;
S    extern volatile uint32  SPI_1_CARD_rxBufferTail;
S    
S    /**
S    * \addtogroup group_globals
S    * @{
S    */
S    
S    /** Sets when internal software receive buffer overflow
S     *  was occurred.
S    */  
S    extern volatile uint8   SPI_1_CARD_rxBufferOverflow;
S    /** @} globals */
N#endif /* (SPI_1_CARD_INTERNAL_RX_SW_BUFFER_CONST) */
N
N#if (SPI_1_CARD_INTERNAL_TX_SW_BUFFER_CONST)
X#if (((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u)))))))
S    extern volatile uint32  SPI_1_CARD_txBufferHead;
S    extern volatile uint32  SPI_1_CARD_txBufferTail;
N#endif /* (SPI_1_CARD_INTERNAL_TX_SW_BUFFER_CONST) */
N
N#if (SPI_1_CARD_INTERNAL_RX_SW_BUFFER)
X#if ((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u))))))
S    extern volatile uint8 SPI_1_CARD_rxBufferInternal[SPI_1_CARD_INTERNAL_RX_BUFFER_SIZE];
N#endif /* (SPI_1_CARD_INTERNAL_RX_SW_BUFFER) */
N
N#if (SPI_1_CARD_INTERNAL_TX_SW_BUFFER)
X#if ((((8u) > ((0u != ((0u))) ? (2u * (8u)) : ((8u))))))
S    extern volatile uint8 SPI_1_CARD_txBufferInternal[SPI_1_CARD_TX_BUFFER_SIZE];
N#endif /* (SPI_1_CARD_INTERNAL_TX_SW_BUFFER) */
N
N
N/***************************************
N*     Private Function Prototypes
N***************************************/
N
Nvoid SPI_1_CARD_SpiPostEnable(void);
Nvoid SPI_1_CARD_SpiStop(void);
N
N#if (SPI_1_CARD_SCB_MODE_SPI_CONST_CFG)
X#if (((0x02u) == (2u)))
N    void SPI_1_CARD_SpiInit(void);
N#endif /* (SPI_1_CARD_SCB_MODE_SPI_CONST_CFG) */
N
N#if (SPI_1_CARD_SPI_WAKE_ENABLE_CONST)
X#if ((0u != (0u)))
S    void SPI_1_CARD_SpiSaveConfig(void);
S    void SPI_1_CARD_SpiRestoreConfig(void);
N#endif /* (SPI_1_CARD_SPI_WAKE_ENABLE_CONST) */
N
Nvoid SPI_1_CARD_UartPostEnable(void);
Nvoid SPI_1_CARD_UartStop(void);
N
N#if (SPI_1_CARD_SCB_MODE_UART_CONST_CFG)
X#if (((0x04u) == (2u)))
S    void SPI_1_CARD_UartInit(void);
N#endif /* (SPI_1_CARD_SCB_MODE_UART_CONST_CFG) */
N
N#if (SPI_1_CARD_UART_WAKE_ENABLE_CONST)
X#if ((0u))
S    void SPI_1_CARD_UartSaveConfig(void);
S    void SPI_1_CARD_UartRestoreConfig(void);
N#endif /* (SPI_1_CARD_UART_WAKE_ENABLE_CONST) */
N
N
N/***************************************
N*         UART API Constants
N***************************************/
N
N/* UART RX and TX position to be used in SPI_1_CARD_SetPins() */
N#define SPI_1_CARD_UART_RX_PIN_ENABLE    (SPI_1_CARD_UART_RX)
N#define SPI_1_CARD_UART_TX_PIN_ENABLE    (SPI_1_CARD_UART_TX)
N
N/* UART RTS and CTS position to be used in  SPI_1_CARD_SetPins() */
N#define SPI_1_CARD_UART_RTS_PIN_ENABLE    (0x10u)
N#define SPI_1_CARD_UART_CTS_PIN_ENABLE    (0x20u)
N
N
N/***************************************
N* The following code is DEPRECATED and
N* must not be used.
N***************************************/
N
N/* Interrupt processing */
N#define SPI_1_CARD_SpiUartEnableIntRx(intSourceMask)  SPI_1_CARD_SetRxInterruptMode(intSourceMask)
N#define SPI_1_CARD_SpiUartEnableIntTx(intSourceMask)  SPI_1_CARD_SetTxInterruptMode(intSourceMask)
Nuint32  SPI_1_CARD_SpiUartDisableIntRx(void);
Nuint32  SPI_1_CARD_SpiUartDisableIntTx(void);
N
N
N#endif /* (CY_SCB_SPI_UART_PVT_SPI_1_CARD_H) */
N
N
N/* [] END OF FILE */
L 49 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD_PVT.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_PVT.h" 1
N/***************************************************************************//**
N* \file .h
N* \version 4.0
N*
N* \brief
N*  This private file provides constants and parameter values for the
N*  SCB Component.
N*  Please do not use this file or its content in your project.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2013-2017, Cypress Semiconductor Corporation. All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_PVT_SPI_1_CARD_H)
X#if !0L
N#define CY_SCB_PVT_SPI_1_CARD_H
N
N#include "SPI_1_CARD.h"
N
N
N/***************************************
N*     Private Function Prototypes
N***************************************/
N
N/* APIs to service INTR_I2C_EC register */
N#define SPI_1_CARD_SetI2CExtClkInterruptMode(interruptMask) SPI_1_CARD_WRITE_INTR_I2C_EC_MASK(interruptMask)
N#define SPI_1_CARD_ClearI2CExtClkInterruptSource(interruptMask) SPI_1_CARD_CLEAR_INTR_I2C_EC(interruptMask)
N#define SPI_1_CARD_GetI2CExtClkInterruptSource()                (SPI_1_CARD_INTR_I2C_EC_REG)
N#define SPI_1_CARD_GetI2CExtClkInterruptMode()                  (SPI_1_CARD_INTR_I2C_EC_MASK_REG)
N#define SPI_1_CARD_GetI2CExtClkInterruptSourceMasked()          (SPI_1_CARD_INTR_I2C_EC_MASKED_REG)
N
N#if (!SPI_1_CARD_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    /* APIs to service INTR_SPI_EC register */
N    #define SPI_1_CARD_SetSpiExtClkInterruptMode(interruptMask) \
N                                                                SPI_1_CARD_WRITE_INTR_SPI_EC_MASK(interruptMask)
X    #define SPI_1_CARD_SetSpiExtClkInterruptMode(interruptMask)                                                                 SPI_1_CARD_WRITE_INTR_SPI_EC_MASK(interruptMask)
N    #define SPI_1_CARD_ClearSpiExtClkInterruptSource(interruptMask) \
N                                                                SPI_1_CARD_CLEAR_INTR_SPI_EC(interruptMask)
X    #define SPI_1_CARD_ClearSpiExtClkInterruptSource(interruptMask)                                                                 SPI_1_CARD_CLEAR_INTR_SPI_EC(interruptMask)
N    #define SPI_1_CARD_GetExtSpiClkInterruptSource()                 (SPI_1_CARD_INTR_SPI_EC_REG)
N    #define SPI_1_CARD_GetExtSpiClkInterruptMode()                   (SPI_1_CARD_INTR_SPI_EC_MASK_REG)
N    #define SPI_1_CARD_GetExtSpiClkInterruptSourceMasked()           (SPI_1_CARD_INTR_SPI_EC_MASKED_REG)
N#endif /* (!SPI_1_CARD_CY_SCBIP_V1) */
N
N#if(SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (2u)))
S    extern void SPI_1_CARD_SetPins(uint32 mode, uint32 subMode, uint32 uartEnableMask);
N#endif /* (SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N
N/***************************************
N*     Vars with External Linkage
N***************************************/
N
N#if (SPI_1_CARD_SCB_IRQ_INTERNAL)
X#if ((0u == (1u)))
S#if !defined (CY_REMOVE_SPI_1_CARD_CUSTOM_INTR_HANDLER)
S    extern cyisraddress SPI_1_CARD_customIntrHandler;
S#endif /* !defined (CY_REMOVE_SPI_1_CARD_CUSTOM_INTR_HANDLER) */
N#endif /* (SPI_1_CARD_SCB_IRQ_INTERNAL) */
N
Nextern SPI_1_CARD_BACKUP_STRUCT SPI_1_CARD_backup;
N
N#if(SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (2u)))
S    /* Common configuration variables */
S    extern uint8 SPI_1_CARD_scbMode;
S    extern uint8 SPI_1_CARD_scbEnableWake;
S    extern uint8 SPI_1_CARD_scbEnableIntr;
S
S    /* I2C configuration variables */
S    extern uint8 SPI_1_CARD_mode;
S    extern uint8 SPI_1_CARD_acceptAddr;
S
S    /* SPI/UART configuration variables */
S    extern volatile uint8 * SPI_1_CARD_rxBuffer;
S    extern uint8   SPI_1_CARD_rxDataBits;
S    extern uint32  SPI_1_CARD_rxBufferSize;
S
S    extern volatile uint8 * SPI_1_CARD_txBuffer;
S    extern uint8   SPI_1_CARD_txDataBits;
S    extern uint32  SPI_1_CARD_txBufferSize;
S
S    /* EZI2C configuration variables */
S    extern uint8 SPI_1_CARD_numberOfAddr;
S    extern uint8 SPI_1_CARD_subAddrSize;
N#endif /* (SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N#if (! (SPI_1_CARD_SCB_MODE_I2C_CONST_CFG || \
N        SPI_1_CARD_SCB_MODE_EZI2C_CONST_CFG))
X#if (! (((0x01u) == (2u)) ||         ((0x08u) == (2u))))
N    extern uint16 SPI_1_CARD_IntrTxMask;
N#endif /* (! (SPI_1_CARD_SCB_MODE_I2C_CONST_CFG || \
N              SPI_1_CARD_SCB_MODE_EZI2C_CONST_CFG)) */
X#endif  
N
N
N/***************************************
N*        Conditional Macro
N****************************************/
N
N#if(SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (2u)))
S    /* Defines run time operation mode */
S    #define SPI_1_CARD_SCB_MODE_I2C_RUNTM_CFG     (SPI_1_CARD_SCB_MODE_I2C      == SPI_1_CARD_scbMode)
S    #define SPI_1_CARD_SCB_MODE_SPI_RUNTM_CFG     (SPI_1_CARD_SCB_MODE_SPI      == SPI_1_CARD_scbMode)
S    #define SPI_1_CARD_SCB_MODE_UART_RUNTM_CFG    (SPI_1_CARD_SCB_MODE_UART     == SPI_1_CARD_scbMode)
S    #define SPI_1_CARD_SCB_MODE_EZI2C_RUNTM_CFG   (SPI_1_CARD_SCB_MODE_EZI2C    == SPI_1_CARD_scbMode)
S    #define SPI_1_CARD_SCB_MODE_UNCONFIG_RUNTM_CFG \
S                                                        (SPI_1_CARD_SCB_MODE_UNCONFIG == SPI_1_CARD_scbMode)
X    #define SPI_1_CARD_SCB_MODE_UNCONFIG_RUNTM_CFG                                                         (SPI_1_CARD_SCB_MODE_UNCONFIG == SPI_1_CARD_scbMode)
S
S    /* Defines wakeup enable */
S    #define SPI_1_CARD_SCB_WAKE_ENABLE_CHECK       (0u != SPI_1_CARD_scbEnableWake)
N#endif /* (SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N/* Defines maximum number of SCB pins */
N#if (!SPI_1_CARD_CY_SCBIP_V1)
X#if (!(2 == 1u))
N    #define SPI_1_CARD_SCB_PINS_NUMBER    (7u)
N#else
S    #define SPI_1_CARD_SCB_PINS_NUMBER    (2u)
N#endif /* (!SPI_1_CARD_CY_SCBIP_V1) */
N
N#endif /* (CY_SCB_PVT_SPI_1_CARD_H) */
N
N
N/* [] END OF FILE */
L 50 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD_BOOT.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_BOOT.h" 1
N/***************************************************************************//**
N* \file SPI_1_CARD_BOOT.h
N* \version 4.0
N*
N* \brief
N*  This file provides constants and parameter values of the bootloader
N*  communication APIs for the SCB Component.
N*
N* Note:
N*
N********************************************************************************
N* \copyright
N* Copyright 2014-2017, Cypress Semiconductor Corporation. All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_BOOT_SPI_1_CARD_H)
X#if !0L
N#define CY_SCB_BOOT_SPI_1_CARD_H
N
N#include "SPI_1_CARD_PVT.h"
N
N#if (SPI_1_CARD_SCB_MODE_I2C_INC)
X#if ((0u !=((0x01u) & (2u))))
S    #include "SPI_1_CARD_I2C.h"
N#endif /* (SPI_1_CARD_SCB_MODE_I2C_INC) */
N
N#if (SPI_1_CARD_SCB_MODE_EZI2C_INC)
X#if ((0u !=((0x08u) & (2u))))
S    #include "SPI_1_CARD_EZI2C.h"
N#endif /* (SPI_1_CARD_SCB_MODE_EZI2C_INC) */
N
N#if (SPI_1_CARD_SCB_MODE_SPI_INC || SPI_1_CARD_SCB_MODE_UART_INC)
X#if ((0u !=((0x02u) & (2u))) || (0u !=((0x04u) & (2u))))
N    #include "SPI_1_CARD_SPI_UART.h"
N#endif /* (SPI_1_CARD_SCB_MODE_SPI_INC || SPI_1_CARD_SCB_MODE_UART_INC) */
N
N
N/***************************************
N*  Conditional Compilation Parameters
N****************************************/
N
N/* Bootloader communication interface enable */
N#define SPI_1_CARD_BTLDR_COMM_ENABLED ((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_SPI_1_CARD) || \
N                                             (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface))
X#define SPI_1_CARD_BTLDR_COMM_ENABLED ((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_SPI_1_CARD) ||                                              (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface))
N
N/* Enable I2C bootloader communication */
N#if (SPI_1_CARD_SCB_MODE_I2C_INC)
X#if ((0u !=((0x01u) & (2u))))
S    #define SPI_1_CARD_I2C_BTLDR_COMM_ENABLED     (SPI_1_CARD_BTLDR_COMM_ENABLED && \
S                                                            (SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG || \
S                                                             SPI_1_CARD_I2C_SLAVE_CONST))
X    #define SPI_1_CARD_I2C_BTLDR_COMM_ENABLED     (SPI_1_CARD_BTLDR_COMM_ENABLED &&                                                             (SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG ||                                                              SPI_1_CARD_I2C_SLAVE_CONST))
N#else
N     #define SPI_1_CARD_I2C_BTLDR_COMM_ENABLED    (0u)
N#endif /* (SPI_1_CARD_SCB_MODE_I2C_INC) */
N
N/* EZI2C does not support bootloader communication. Provide empty APIs */
N#if (SPI_1_CARD_SCB_MODE_EZI2C_INC)
X#if ((0u !=((0x08u) & (2u))))
S    #define SPI_1_CARD_EZI2C_BTLDR_COMM_ENABLED   (SPI_1_CARD_BTLDR_COMM_ENABLED && \
S                                                         SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG)
X    #define SPI_1_CARD_EZI2C_BTLDR_COMM_ENABLED   (SPI_1_CARD_BTLDR_COMM_ENABLED &&                                                          SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG)
N#else
N    #define SPI_1_CARD_EZI2C_BTLDR_COMM_ENABLED   (0u)
N#endif /* (SPI_1_CARD_EZI2C_BTLDR_COMM_ENABLED) */
N
N/* Enable SPI bootloader communication */
N#if (SPI_1_CARD_SCB_MODE_SPI_INC)
X#if ((0u !=((0x02u) & (2u))))
N    #define SPI_1_CARD_SPI_BTLDR_COMM_ENABLED     (SPI_1_CARD_BTLDR_COMM_ENABLED && \
N                                                            (SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG || \
N                                                             SPI_1_CARD_SPI_SLAVE_CONST))
X    #define SPI_1_CARD_SPI_BTLDR_COMM_ENABLED     (SPI_1_CARD_BTLDR_COMM_ENABLED &&                                                             (SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG ||                                                              SPI_1_CARD_SPI_SLAVE_CONST))
N#else
S        #define SPI_1_CARD_SPI_BTLDR_COMM_ENABLED (0u)
N#endif /* (SPI_1_CARD_SPI_BTLDR_COMM_ENABLED) */
N
N/* Enable UART bootloader communication */
N#if (SPI_1_CARD_SCB_MODE_UART_INC)
X#if ((0u !=((0x04u) & (2u))))
S       #define SPI_1_CARD_UART_BTLDR_COMM_ENABLED    (SPI_1_CARD_BTLDR_COMM_ENABLED && \
S                                                            (SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG || \
S                                                             (SPI_1_CARD_UART_RX_DIRECTION && \
S                                                              SPI_1_CARD_UART_TX_DIRECTION)))
X       #define SPI_1_CARD_UART_BTLDR_COMM_ENABLED    (SPI_1_CARD_BTLDR_COMM_ENABLED &&                                                             (SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG ||                                                              (SPI_1_CARD_UART_RX_DIRECTION &&                                                               SPI_1_CARD_UART_TX_DIRECTION)))
N#else
N     #define SPI_1_CARD_UART_BTLDR_COMM_ENABLED   (0u)
N#endif /* (SPI_1_CARD_UART_BTLDR_COMM_ENABLED) */
N
N/* Enable bootloader communication */
N#define SPI_1_CARD_BTLDR_COMM_MODE_ENABLED    (SPI_1_CARD_I2C_BTLDR_COMM_ENABLED   || \
N                                                     SPI_1_CARD_SPI_BTLDR_COMM_ENABLED   || \
N                                                     SPI_1_CARD_EZI2C_BTLDR_COMM_ENABLED || \
N                                                     SPI_1_CARD_UART_BTLDR_COMM_ENABLED)
X#define SPI_1_CARD_BTLDR_COMM_MODE_ENABLED    (SPI_1_CARD_I2C_BTLDR_COMM_ENABLED   ||                                                      SPI_1_CARD_SPI_BTLDR_COMM_ENABLED   ||                                                      SPI_1_CARD_EZI2C_BTLDR_COMM_ENABLED ||                                                      SPI_1_CARD_UART_BTLDR_COMM_ENABLED)
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (SPI_1_CARD_I2C_BTLDR_COMM_ENABLED)
X#if 0L && ((0u))
S    /* I2C Bootloader physical layer functions */
S    void SPI_1_CARD_I2CCyBtldrCommStart(void);
S    void SPI_1_CARD_I2CCyBtldrCommStop (void);
S    void SPI_1_CARD_I2CCyBtldrCommReset(void);
S    cystatus SPI_1_CARD_I2CCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus SPI_1_CARD_I2CCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    /* Map I2C specific bootloader communication APIs to SCB specific APIs */
S    #if (SPI_1_CARD_SCB_MODE_I2C_CONST_CFG)
S        #define SPI_1_CARD_CyBtldrCommStart   SPI_1_CARD_I2CCyBtldrCommStart
S        #define SPI_1_CARD_CyBtldrCommStop    SPI_1_CARD_I2CCyBtldrCommStop
S        #define SPI_1_CARD_CyBtldrCommReset   SPI_1_CARD_I2CCyBtldrCommReset
S        #define SPI_1_CARD_CyBtldrCommRead    SPI_1_CARD_I2CCyBtldrCommRead
S        #define SPI_1_CARD_CyBtldrCommWrite   SPI_1_CARD_I2CCyBtldrCommWrite
S    #endif /* (SPI_1_CARD_SCB_MODE_I2C_CONST_CFG) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (SPI_1_CARD_I2C_BTLDR_COMM_ENABLED) */
N
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (SPI_1_CARD_EZI2C_BTLDR_COMM_ENABLED)
X#if 0L && ((0u))
S    /* Bootloader physical layer functions */
S    void SPI_1_CARD_EzI2CCyBtldrCommStart(void);
S    void SPI_1_CARD_EzI2CCyBtldrCommStop (void);
S    void SPI_1_CARD_EzI2CCyBtldrCommReset(void);
S    cystatus SPI_1_CARD_EzI2CCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus SPI_1_CARD_EzI2CCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    /* Map EZI2C specific bootloader communication APIs to SCB specific APIs */
S    #if (SPI_1_CARD_SCB_MODE_EZI2C_CONST_CFG)
S        #define SPI_1_CARD_CyBtldrCommStart   SPI_1_CARD_EzI2CCyBtldrCommStart
S        #define SPI_1_CARD_CyBtldrCommStop    SPI_1_CARD_EzI2CCyBtldrCommStop
S        #define SPI_1_CARD_CyBtldrCommReset   SPI_1_CARD_EzI2CCyBtldrCommReset
S        #define SPI_1_CARD_CyBtldrCommRead    SPI_1_CARD_EzI2CCyBtldrCommRead
S        #define SPI_1_CARD_CyBtldrCommWrite   SPI_1_CARD_EzI2CCyBtldrCommWrite
S    #endif /* (SPI_1_CARD_SCB_MODE_EZI2C_CONST_CFG) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (SPI_1_CARD_EZI2C_BTLDR_COMM_ENABLED) */
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (SPI_1_CARD_SPI_BTLDR_COMM_ENABLED)
X#if 0L && ((((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_SPI_1_CARD) || (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface)) && (((0xFFu) == (2u)) || ((1u) == (0u)))))
S    /* SPI Bootloader physical layer functions */
S    void SPI_1_CARD_SpiCyBtldrCommStart(void);
S    void SPI_1_CARD_SpiCyBtldrCommStop (void);
S    void SPI_1_CARD_SpiCyBtldrCommReset(void);
S    cystatus SPI_1_CARD_SpiCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus SPI_1_CARD_SpiCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    /* Map SPI specific bootloader communication APIs to SCB specific APIs */
S    #if (SPI_1_CARD_SCB_MODE_SPI_CONST_CFG)
S        #define SPI_1_CARD_CyBtldrCommStart   SPI_1_CARD_SpiCyBtldrCommStart
S        #define SPI_1_CARD_CyBtldrCommStop    SPI_1_CARD_SpiCyBtldrCommStop
S        #define SPI_1_CARD_CyBtldrCommReset   SPI_1_CARD_SpiCyBtldrCommReset
S        #define SPI_1_CARD_CyBtldrCommRead    SPI_1_CARD_SpiCyBtldrCommRead
S        #define SPI_1_CARD_CyBtldrCommWrite   SPI_1_CARD_SpiCyBtldrCommWrite
S    #endif /* (SPI_1_CARD_SCB_MODE_SPI_CONST_CFG) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (SPI_1_CARD_SPI_BTLDR_COMM_ENABLED) */
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (SPI_1_CARD_UART_BTLDR_COMM_ENABLED)
X#if 0L && ((0u))
S    /* UART Bootloader physical layer functions */
S    void SPI_1_CARD_UartCyBtldrCommStart(void);
S    void SPI_1_CARD_UartCyBtldrCommStop (void);
S    void SPI_1_CARD_UartCyBtldrCommReset(void);
S    cystatus SPI_1_CARD_UartCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus SPI_1_CARD_UartCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    /* Map UART specific bootloader communication APIs to SCB specific APIs */
S    #if (SPI_1_CARD_SCB_MODE_UART_CONST_CFG)
S        #define SPI_1_CARD_CyBtldrCommStart   SPI_1_CARD_UartCyBtldrCommStart
S        #define SPI_1_CARD_CyBtldrCommStop    SPI_1_CARD_UartCyBtldrCommStop
S        #define SPI_1_CARD_CyBtldrCommReset   SPI_1_CARD_UartCyBtldrCommReset
S        #define SPI_1_CARD_CyBtldrCommRead    SPI_1_CARD_UartCyBtldrCommRead
S        #define SPI_1_CARD_CyBtldrCommWrite   SPI_1_CARD_UartCyBtldrCommWrite
S    #endif /* (SPI_1_CARD_SCB_MODE_UART_CONST_CFG) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (SPI_1_CARD_UART_BTLDR_COMM_ENABLED) */
N
N/**
N* \addtogroup group_bootloader
N* @{
N*/
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (SPI_1_CARD_BTLDR_COMM_ENABLED)
X#if 0L && (((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_SPI_1_CARD) || (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface)))
S    #if (SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG)
S        /* Bootloader physical layer functions */
S        void SPI_1_CARD_CyBtldrCommStart(void);
S        void SPI_1_CARD_CyBtldrCommStop (void);
S        void SPI_1_CARD_CyBtldrCommReset(void);
S        cystatus SPI_1_CARD_CyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S        cystatus SPI_1_CARD_CyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    #endif /* (SPI_1_CARD_SCB_MODE_UNCONFIG_CONST_CFG) */
S
S    /* Map SCB specific bootloader communication APIs to common APIs */
S    #if (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_SPI_1_CARD)
S        #define CyBtldrCommStart    SPI_1_CARD_CyBtldrCommStart
S        #define CyBtldrCommStop     SPI_1_CARD_CyBtldrCommStop
S        #define CyBtldrCommReset    SPI_1_CARD_CyBtldrCommReset
S        #define CyBtldrCommWrite    SPI_1_CARD_CyBtldrCommWrite
S        #define CyBtldrCommRead     SPI_1_CARD_CyBtldrCommRead
S    #endif /* (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_SPI_1_CARD) */
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (SPI_1_CARD_BTLDR_COMM_ENABLED) */
N
N/** @} group_bootloader */
N
N/***************************************
N*           API Constants
N***************************************/
N
N/* Timeout unit in milliseconds */
N#define SPI_1_CARD_WAIT_1_MS  (1u)
N
N/* Return number of bytes to copy into bootloader buffer */
N#define SPI_1_CARD_BYTES_TO_COPY(actBufSize, bufSize) \
N                            ( ((uint32)(actBufSize) < (uint32)(bufSize)) ? \
N                                ((uint32) (actBufSize)) : ((uint32) (bufSize)) )
X#define SPI_1_CARD_BYTES_TO_COPY(actBufSize, bufSize)                             ( ((uint32)(actBufSize) < (uint32)(bufSize)) ?                                 ((uint32) (actBufSize)) : ((uint32) (bufSize)) )
N
N/* Size of Read/Write buffers for I2C bootloader  */
N#define SPI_1_CARD_I2C_BTLDR_SIZEOF_READ_BUFFER   (64u)
N#define SPI_1_CARD_I2C_BTLDR_SIZEOF_WRITE_BUFFER  (64u)
N
N/* Byte to byte time interval: calculated basing on current component
N* data rate configuration, can be defined in project if required.
N*/
N#ifndef SPI_1_CARD_SPI_BYTE_TO_BYTE
N    #define SPI_1_CARD_SPI_BYTE_TO_BYTE   (2u)
N#endif
N
N/* Byte to byte time interval: calculated basing on current component
N* baud rate configuration, can be defined in the project if required.
N*/
N#ifndef SPI_1_CARD_UART_BYTE_TO_BYTE
N    #define SPI_1_CARD_UART_BYTE_TO_BYTE  (2500u)
N#endif /* SPI_1_CARD_UART_BYTE_TO_BYTE */
N
N#endif /* (CY_SCB_BOOT_SPI_1_CARD_H) */
N
N
N/* [] END OF FILE */
L 51 "Generated_Source\PSoC4\project.h" 2
N#include "CARD_RESET.h"
L 1 "Generated_Source\PSoC4\CARD_RESET.h" 1
N/*******************************************************************************
N* File Name: CARD_RESET.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_CARD_RESET_H) /* Pins CARD_RESET_H */
X#if !0L  
N#define CY_PINS_CARD_RESET_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "CARD_RESET_aliases.h"
L 1 "Generated_Source\PSoC4\CARD_RESET_aliases.h" 1
N/*******************************************************************************
N* File Name: CARD_RESET.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_CARD_RESET_ALIASES_H) /* Pins CARD_RESET_ALIASES_H */
X#if !0L  
N#define CY_PINS_CARD_RESET_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define CARD_RESET_0			(CARD_RESET__0__PC)
N#define CARD_RESET_0_PS		(CARD_RESET__0__PS)
N#define CARD_RESET_0_PC		(CARD_RESET__0__PC)
N#define CARD_RESET_0_DR		(CARD_RESET__0__DR)
N#define CARD_RESET_0_SHIFT	(CARD_RESET__0__SHIFT)
N#define CARD_RESET_0_INTR	((uint16)((uint16)0x0003u << (CARD_RESET__0__SHIFT*2u)))
N
N#define CARD_RESET_INTR_ALL	 ((uint16)(CARD_RESET_0_INTR))
N
N
N#endif /* End Pins CARD_RESET_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\CARD_RESET.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} CARD_RESET_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   CARD_RESET_Read(void);
Nvoid    CARD_RESET_Write(uint8 value);
Nuint8   CARD_RESET_ReadDataReg(void);
N#if defined(CARD_RESET__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    CARD_RESET_SetDriveMode(uint8 mode);
N#endif
Nvoid    CARD_RESET_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   CARD_RESET_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid CARD_RESET_Sleep(void); 
Nvoid CARD_RESET_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(CARD_RESET__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define CARD_RESET_DRIVE_MODE_BITS        (3)
N    #define CARD_RESET_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - CARD_RESET_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the CARD_RESET_SetDriveMode() function.
N         *  @{
N         */
N        #define CARD_RESET_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define CARD_RESET_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define CARD_RESET_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define CARD_RESET_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define CARD_RESET_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define CARD_RESET_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define CARD_RESET_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define CARD_RESET_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define CARD_RESET_MASK               CARD_RESET__MASK
N#define CARD_RESET_SHIFT              CARD_RESET__SHIFT
N#define CARD_RESET_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in CARD_RESET_SetInterruptMode() function.
N     *  @{
N     */
N        #define CARD_RESET_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define CARD_RESET_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define CARD_RESET_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define CARD_RESET_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(CARD_RESET__SIO)
X#if 0L
S    #define CARD_RESET_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(CARD_RESET__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define CARD_RESET_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define CARD_RESET_USBIO_DISABLE              ((uint32)(~CARD_RESET_USBIO_ENABLE))
S    #define CARD_RESET_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define CARD_RESET_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define CARD_RESET_USBIO_ENTER_SLEEP          ((uint32)((1u << CARD_RESET_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << CARD_RESET_USBIO_SUSPEND_DEL_SHIFT)))
X    #define CARD_RESET_USBIO_ENTER_SLEEP          ((uint32)((1u << CARD_RESET_USBIO_SUSPEND_SHIFT)                                                         | (1u << CARD_RESET_USBIO_SUSPEND_DEL_SHIFT)))
S    #define CARD_RESET_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << CARD_RESET_USBIO_SUSPEND_SHIFT)))
S    #define CARD_RESET_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << CARD_RESET_USBIO_SUSPEND_DEL_SHIFT)))
S    #define CARD_RESET_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(CARD_RESET__PC)
X#if 1L
N    /* Port Configuration */
N    #define CARD_RESET_PC                 (* (reg32 *) CARD_RESET__PC)
N#endif
N/* Pin State */
N#define CARD_RESET_PS                     (* (reg32 *) CARD_RESET__PS)
N/* Data Register */
N#define CARD_RESET_DR                     (* (reg32 *) CARD_RESET__DR)
N/* Input Buffer Disable Override */
N#define CARD_RESET_INP_DIS                (* (reg32 *) CARD_RESET__PC2)
N
N/* Interrupt configuration Registers */
N#define CARD_RESET_INTCFG                 (* (reg32 *) CARD_RESET__INTCFG)
N#define CARD_RESET_INTSTAT                (* (reg32 *) CARD_RESET__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define CARD_RESET_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(CARD_RESET__SIO)
X#if 0L
S    #define CARD_RESET_SIO_REG            (* (reg32 *) CARD_RESET__SIO)
N#endif /* (CARD_RESET__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(CARD_RESET__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define CARD_RESET_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define CARD_RESET_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define CARD_RESET_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define CARD_RESET_DRIVE_MODE_SHIFT       (0x00u)
N#define CARD_RESET_DRIVE_MODE_MASK        (0x07u << CARD_RESET_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins CARD_RESET_H */
N
N
N/* [] END OF FILE */
L 52 "Generated_Source\PSoC4\project.h" 2
N#include "CARD_RESET_aliases.h"
L 1 "Generated_Source\PSoC4\CARD_RESET_aliases.h" 1
N/*******************************************************************************
N* File Name: CARD_RESET.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_CARD_RESET_ALIASES_H) /* Pins CARD_RESET_ALIASES_H */
X#if !1L  
S#define CY_PINS_CARD_RESET_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define CARD_RESET_0			(CARD_RESET__0__PC)
S#define CARD_RESET_0_PS		(CARD_RESET__0__PS)
S#define CARD_RESET_0_PC		(CARD_RESET__0__PC)
S#define CARD_RESET_0_DR		(CARD_RESET__0__DR)
S#define CARD_RESET_0_SHIFT	(CARD_RESET__0__SHIFT)
S#define CARD_RESET_0_INTR	((uint16)((uint16)0x0003u << (CARD_RESET__0__SHIFT*2u)))
S
S#define CARD_RESET_INTR_ALL	 ((uint16)(CARD_RESET_0_INTR))
S
S
N#endif /* End Pins CARD_RESET_ALIASES_H */
N
N
N/* [] END OF FILE */
L 53 "Generated_Source\PSoC4\project.h" 2
N#include "OLED_DC.h"
L 1 "Generated_Source\PSoC4\OLED_DC.h" 1
N/*******************************************************************************
N* File Name: OLED_DC.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_OLED_DC_H) /* Pins OLED_DC_H */
X#if !0L  
N#define CY_PINS_OLED_DC_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "OLED_DC_aliases.h"
L 1 "Generated_Source\PSoC4\OLED_DC_aliases.h" 1
N/*******************************************************************************
N* File Name: OLED_DC.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_OLED_DC_ALIASES_H) /* Pins OLED_DC_ALIASES_H */
X#if !0L  
N#define CY_PINS_OLED_DC_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define OLED_DC_0			(OLED_DC__0__PC)
N#define OLED_DC_0_PS		(OLED_DC__0__PS)
N#define OLED_DC_0_PC		(OLED_DC__0__PC)
N#define OLED_DC_0_DR		(OLED_DC__0__DR)
N#define OLED_DC_0_SHIFT	(OLED_DC__0__SHIFT)
N#define OLED_DC_0_INTR	((uint16)((uint16)0x0003u << (OLED_DC__0__SHIFT*2u)))
N
N#define OLED_DC_INTR_ALL	 ((uint16)(OLED_DC_0_INTR))
N
N
N#endif /* End Pins OLED_DC_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\OLED_DC.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} OLED_DC_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   OLED_DC_Read(void);
Nvoid    OLED_DC_Write(uint8 value);
Nuint8   OLED_DC_ReadDataReg(void);
N#if defined(OLED_DC__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    OLED_DC_SetDriveMode(uint8 mode);
N#endif
Nvoid    OLED_DC_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   OLED_DC_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid OLED_DC_Sleep(void); 
Nvoid OLED_DC_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(OLED_DC__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define OLED_DC_DRIVE_MODE_BITS        (3)
N    #define OLED_DC_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - OLED_DC_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the OLED_DC_SetDriveMode() function.
N         *  @{
N         */
N        #define OLED_DC_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define OLED_DC_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define OLED_DC_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define OLED_DC_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define OLED_DC_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define OLED_DC_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define OLED_DC_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define OLED_DC_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define OLED_DC_MASK               OLED_DC__MASK
N#define OLED_DC_SHIFT              OLED_DC__SHIFT
N#define OLED_DC_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in OLED_DC_SetInterruptMode() function.
N     *  @{
N     */
N        #define OLED_DC_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define OLED_DC_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define OLED_DC_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define OLED_DC_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(OLED_DC__SIO)
X#if 0L
S    #define OLED_DC_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(OLED_DC__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define OLED_DC_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define OLED_DC_USBIO_DISABLE              ((uint32)(~OLED_DC_USBIO_ENABLE))
S    #define OLED_DC_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define OLED_DC_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define OLED_DC_USBIO_ENTER_SLEEP          ((uint32)((1u << OLED_DC_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << OLED_DC_USBIO_SUSPEND_DEL_SHIFT)))
X    #define OLED_DC_USBIO_ENTER_SLEEP          ((uint32)((1u << OLED_DC_USBIO_SUSPEND_SHIFT)                                                         | (1u << OLED_DC_USBIO_SUSPEND_DEL_SHIFT)))
S    #define OLED_DC_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << OLED_DC_USBIO_SUSPEND_SHIFT)))
S    #define OLED_DC_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << OLED_DC_USBIO_SUSPEND_DEL_SHIFT)))
S    #define OLED_DC_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(OLED_DC__PC)
X#if 1L
N    /* Port Configuration */
N    #define OLED_DC_PC                 (* (reg32 *) OLED_DC__PC)
N#endif
N/* Pin State */
N#define OLED_DC_PS                     (* (reg32 *) OLED_DC__PS)
N/* Data Register */
N#define OLED_DC_DR                     (* (reg32 *) OLED_DC__DR)
N/* Input Buffer Disable Override */
N#define OLED_DC_INP_DIS                (* (reg32 *) OLED_DC__PC2)
N
N/* Interrupt configuration Registers */
N#define OLED_DC_INTCFG                 (* (reg32 *) OLED_DC__INTCFG)
N#define OLED_DC_INTSTAT                (* (reg32 *) OLED_DC__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define OLED_DC_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(OLED_DC__SIO)
X#if 0L
S    #define OLED_DC_SIO_REG            (* (reg32 *) OLED_DC__SIO)
N#endif /* (OLED_DC__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(OLED_DC__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define OLED_DC_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define OLED_DC_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define OLED_DC_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define OLED_DC_DRIVE_MODE_SHIFT       (0x00u)
N#define OLED_DC_DRIVE_MODE_MASK        (0x07u << OLED_DC_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins OLED_DC_H */
N
N
N/* [] END OF FILE */
L 54 "Generated_Source\PSoC4\project.h" 2
N#include "OLED_DC_aliases.h"
L 1 "Generated_Source\PSoC4\OLED_DC_aliases.h" 1
N/*******************************************************************************
N* File Name: OLED_DC.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_OLED_DC_ALIASES_H) /* Pins OLED_DC_ALIASES_H */
X#if !1L  
S#define CY_PINS_OLED_DC_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define OLED_DC_0			(OLED_DC__0__PC)
S#define OLED_DC_0_PS		(OLED_DC__0__PS)
S#define OLED_DC_0_PC		(OLED_DC__0__PC)
S#define OLED_DC_0_DR		(OLED_DC__0__DR)
S#define OLED_DC_0_SHIFT	(OLED_DC__0__SHIFT)
S#define OLED_DC_0_INTR	((uint16)((uint16)0x0003u << (OLED_DC__0__SHIFT*2u)))
S
S#define OLED_DC_INTR_ALL	 ((uint16)(OLED_DC_0_INTR))
S
S
N#endif /* End Pins OLED_DC_ALIASES_H */
N
N
N/* [] END OF FILE */
L 55 "Generated_Source\PSoC4\project.h" 2
N#include "I2C_SCL.h"
L 1 "Generated_Source\PSoC4\I2C_SCL.h" 1
N/*******************************************************************************
N* File Name: I2C_SCL.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_I2C_SCL_H) /* Pins I2C_SCL_H */
X#if !0L  
N#define CY_PINS_I2C_SCL_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "I2C_SCL_aliases.h"
L 1 "Generated_Source\PSoC4\I2C_SCL_aliases.h" 1
N/*******************************************************************************
N* File Name: I2C_SCL.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_I2C_SCL_ALIASES_H) /* Pins I2C_SCL_ALIASES_H */
X#if !0L  
N#define CY_PINS_I2C_SCL_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define I2C_SCL_0			(I2C_SCL__0__PC)
N#define I2C_SCL_0_PS		(I2C_SCL__0__PS)
N#define I2C_SCL_0_PC		(I2C_SCL__0__PC)
N#define I2C_SCL_0_DR		(I2C_SCL__0__DR)
N#define I2C_SCL_0_SHIFT	(I2C_SCL__0__SHIFT)
N#define I2C_SCL_0_INTR	((uint16)((uint16)0x0003u << (I2C_SCL__0__SHIFT*2u)))
N
N#define I2C_SCL_INTR_ALL	 ((uint16)(I2C_SCL_0_INTR))
N
N
N#endif /* End Pins I2C_SCL_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\I2C_SCL.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} I2C_SCL_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   I2C_SCL_Read(void);
Nvoid    I2C_SCL_Write(uint8 value);
Nuint8   I2C_SCL_ReadDataReg(void);
N#if defined(I2C_SCL__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    I2C_SCL_SetDriveMode(uint8 mode);
N#endif
Nvoid    I2C_SCL_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   I2C_SCL_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid I2C_SCL_Sleep(void); 
Nvoid I2C_SCL_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(I2C_SCL__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define I2C_SCL_DRIVE_MODE_BITS        (3)
N    #define I2C_SCL_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - I2C_SCL_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the I2C_SCL_SetDriveMode() function.
N         *  @{
N         */
N        #define I2C_SCL_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define I2C_SCL_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define I2C_SCL_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define I2C_SCL_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define I2C_SCL_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define I2C_SCL_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define I2C_SCL_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define I2C_SCL_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define I2C_SCL_MASK               I2C_SCL__MASK
N#define I2C_SCL_SHIFT              I2C_SCL__SHIFT
N#define I2C_SCL_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in I2C_SCL_SetInterruptMode() function.
N     *  @{
N     */
N        #define I2C_SCL_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define I2C_SCL_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define I2C_SCL_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define I2C_SCL_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(I2C_SCL__SIO)
X#if 0L
S    #define I2C_SCL_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(I2C_SCL__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define I2C_SCL_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define I2C_SCL_USBIO_DISABLE              ((uint32)(~I2C_SCL_USBIO_ENABLE))
S    #define I2C_SCL_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define I2C_SCL_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define I2C_SCL_USBIO_ENTER_SLEEP          ((uint32)((1u << I2C_SCL_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << I2C_SCL_USBIO_SUSPEND_DEL_SHIFT)))
X    #define I2C_SCL_USBIO_ENTER_SLEEP          ((uint32)((1u << I2C_SCL_USBIO_SUSPEND_SHIFT)                                                         | (1u << I2C_SCL_USBIO_SUSPEND_DEL_SHIFT)))
S    #define I2C_SCL_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << I2C_SCL_USBIO_SUSPEND_SHIFT)))
S    #define I2C_SCL_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << I2C_SCL_USBIO_SUSPEND_DEL_SHIFT)))
S    #define I2C_SCL_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(I2C_SCL__PC)
X#if 1L
N    /* Port Configuration */
N    #define I2C_SCL_PC                 (* (reg32 *) I2C_SCL__PC)
N#endif
N/* Pin State */
N#define I2C_SCL_PS                     (* (reg32 *) I2C_SCL__PS)
N/* Data Register */
N#define I2C_SCL_DR                     (* (reg32 *) I2C_SCL__DR)
N/* Input Buffer Disable Override */
N#define I2C_SCL_INP_DIS                (* (reg32 *) I2C_SCL__PC2)
N
N/* Interrupt configuration Registers */
N#define I2C_SCL_INTCFG                 (* (reg32 *) I2C_SCL__INTCFG)
N#define I2C_SCL_INTSTAT                (* (reg32 *) I2C_SCL__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define I2C_SCL_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(I2C_SCL__SIO)
X#if 0L
S    #define I2C_SCL_SIO_REG            (* (reg32 *) I2C_SCL__SIO)
N#endif /* (I2C_SCL__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(I2C_SCL__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define I2C_SCL_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define I2C_SCL_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define I2C_SCL_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define I2C_SCL_DRIVE_MODE_SHIFT       (0x00u)
N#define I2C_SCL_DRIVE_MODE_MASK        (0x07u << I2C_SCL_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins I2C_SCL_H */
N
N
N/* [] END OF FILE */
L 56 "Generated_Source\PSoC4\project.h" 2
N#include "I2C_SCL_aliases.h"
L 1 "Generated_Source\PSoC4\I2C_SCL_aliases.h" 1
N/*******************************************************************************
N* File Name: I2C_SCL.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_I2C_SCL_ALIASES_H) /* Pins I2C_SCL_ALIASES_H */
X#if !1L  
S#define CY_PINS_I2C_SCL_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define I2C_SCL_0			(I2C_SCL__0__PC)
S#define I2C_SCL_0_PS		(I2C_SCL__0__PS)
S#define I2C_SCL_0_PC		(I2C_SCL__0__PC)
S#define I2C_SCL_0_DR		(I2C_SCL__0__DR)
S#define I2C_SCL_0_SHIFT	(I2C_SCL__0__SHIFT)
S#define I2C_SCL_0_INTR	((uint16)((uint16)0x0003u << (I2C_SCL__0__SHIFT*2u)))
S
S#define I2C_SCL_INTR_ALL	 ((uint16)(I2C_SCL_0_INTR))
S
S
N#endif /* End Pins I2C_SCL_ALIASES_H */
N
N
N/* [] END OF FILE */
L 57 "Generated_Source\PSoC4\project.h" 2
N#include "I2C_SDA.h"
L 1 "Generated_Source\PSoC4\I2C_SDA.h" 1
N/*******************************************************************************
N* File Name: I2C_SDA.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_I2C_SDA_H) /* Pins I2C_SDA_H */
X#if !0L  
N#define CY_PINS_I2C_SDA_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "I2C_SDA_aliases.h"
L 1 "Generated_Source\PSoC4\I2C_SDA_aliases.h" 1
N/*******************************************************************************
N* File Name: I2C_SDA.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_I2C_SDA_ALIASES_H) /* Pins I2C_SDA_ALIASES_H */
X#if !0L  
N#define CY_PINS_I2C_SDA_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define I2C_SDA_0			(I2C_SDA__0__PC)
N#define I2C_SDA_0_PS		(I2C_SDA__0__PS)
N#define I2C_SDA_0_PC		(I2C_SDA__0__PC)
N#define I2C_SDA_0_DR		(I2C_SDA__0__DR)
N#define I2C_SDA_0_SHIFT	(I2C_SDA__0__SHIFT)
N#define I2C_SDA_0_INTR	((uint16)((uint16)0x0003u << (I2C_SDA__0__SHIFT*2u)))
N
N#define I2C_SDA_INTR_ALL	 ((uint16)(I2C_SDA_0_INTR))
N
N
N#endif /* End Pins I2C_SDA_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\I2C_SDA.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} I2C_SDA_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   I2C_SDA_Read(void);
Nvoid    I2C_SDA_Write(uint8 value);
Nuint8   I2C_SDA_ReadDataReg(void);
N#if defined(I2C_SDA__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    I2C_SDA_SetDriveMode(uint8 mode);
N#endif
Nvoid    I2C_SDA_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   I2C_SDA_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid I2C_SDA_Sleep(void); 
Nvoid I2C_SDA_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(I2C_SDA__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define I2C_SDA_DRIVE_MODE_BITS        (3)
N    #define I2C_SDA_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - I2C_SDA_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the I2C_SDA_SetDriveMode() function.
N         *  @{
N         */
N        #define I2C_SDA_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define I2C_SDA_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define I2C_SDA_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define I2C_SDA_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define I2C_SDA_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define I2C_SDA_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define I2C_SDA_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define I2C_SDA_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define I2C_SDA_MASK               I2C_SDA__MASK
N#define I2C_SDA_SHIFT              I2C_SDA__SHIFT
N#define I2C_SDA_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in I2C_SDA_SetInterruptMode() function.
N     *  @{
N     */
N        #define I2C_SDA_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define I2C_SDA_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define I2C_SDA_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define I2C_SDA_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(I2C_SDA__SIO)
X#if 0L
S    #define I2C_SDA_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(I2C_SDA__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define I2C_SDA_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define I2C_SDA_USBIO_DISABLE              ((uint32)(~I2C_SDA_USBIO_ENABLE))
S    #define I2C_SDA_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define I2C_SDA_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define I2C_SDA_USBIO_ENTER_SLEEP          ((uint32)((1u << I2C_SDA_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << I2C_SDA_USBIO_SUSPEND_DEL_SHIFT)))
X    #define I2C_SDA_USBIO_ENTER_SLEEP          ((uint32)((1u << I2C_SDA_USBIO_SUSPEND_SHIFT)                                                         | (1u << I2C_SDA_USBIO_SUSPEND_DEL_SHIFT)))
S    #define I2C_SDA_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << I2C_SDA_USBIO_SUSPEND_SHIFT)))
S    #define I2C_SDA_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << I2C_SDA_USBIO_SUSPEND_DEL_SHIFT)))
S    #define I2C_SDA_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(I2C_SDA__PC)
X#if 1L
N    /* Port Configuration */
N    #define I2C_SDA_PC                 (* (reg32 *) I2C_SDA__PC)
N#endif
N/* Pin State */
N#define I2C_SDA_PS                     (* (reg32 *) I2C_SDA__PS)
N/* Data Register */
N#define I2C_SDA_DR                     (* (reg32 *) I2C_SDA__DR)
N/* Input Buffer Disable Override */
N#define I2C_SDA_INP_DIS                (* (reg32 *) I2C_SDA__PC2)
N
N/* Interrupt configuration Registers */
N#define I2C_SDA_INTCFG                 (* (reg32 *) I2C_SDA__INTCFG)
N#define I2C_SDA_INTSTAT                (* (reg32 *) I2C_SDA__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define I2C_SDA_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(I2C_SDA__SIO)
X#if 0L
S    #define I2C_SDA_SIO_REG            (* (reg32 *) I2C_SDA__SIO)
N#endif /* (I2C_SDA__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(I2C_SDA__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define I2C_SDA_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define I2C_SDA_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define I2C_SDA_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define I2C_SDA_DRIVE_MODE_SHIFT       (0x00u)
N#define I2C_SDA_DRIVE_MODE_MASK        (0x07u << I2C_SDA_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins I2C_SDA_H */
N
N
N/* [] END OF FILE */
L 58 "Generated_Source\PSoC4\project.h" 2
N#include "I2C_SDA_aliases.h"
L 1 "Generated_Source\PSoC4\I2C_SDA_aliases.h" 1
N/*******************************************************************************
N* File Name: I2C_SDA.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_I2C_SDA_ALIASES_H) /* Pins I2C_SDA_ALIASES_H */
X#if !1L  
S#define CY_PINS_I2C_SDA_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define I2C_SDA_0			(I2C_SDA__0__PC)
S#define I2C_SDA_0_PS		(I2C_SDA__0__PS)
S#define I2C_SDA_0_PC		(I2C_SDA__0__PC)
S#define I2C_SDA_0_DR		(I2C_SDA__0__DR)
S#define I2C_SDA_0_SHIFT	(I2C_SDA__0__SHIFT)
S#define I2C_SDA_0_INTR	((uint16)((uint16)0x0003u << (I2C_SDA__0__SHIFT*2u)))
S
S#define I2C_SDA_INTR_ALL	 ((uint16)(I2C_SDA_0_INTR))
S
S
N#endif /* End Pins I2C_SDA_ALIASES_H */
N
N
N/* [] END OF FILE */
L 59 "Generated_Source\PSoC4\project.h" 2
N#include "I2C_ST.h"
L 1 "Generated_Source\PSoC4\I2C_ST.h" 1
N/*******************************************************************************
N* File Name: I2C_ST.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_I2C_ST_H) /* Pins I2C_ST_H */
X#if !0L  
N#define CY_PINS_I2C_ST_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "I2C_ST_aliases.h"
L 1 "Generated_Source\PSoC4\I2C_ST_aliases.h" 1
N/*******************************************************************************
N* File Name: I2C_ST.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_I2C_ST_ALIASES_H) /* Pins I2C_ST_ALIASES_H */
X#if !0L  
N#define CY_PINS_I2C_ST_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define I2C_ST_0			(I2C_ST__0__PC)
N#define I2C_ST_0_PS		(I2C_ST__0__PS)
N#define I2C_ST_0_PC		(I2C_ST__0__PC)
N#define I2C_ST_0_DR		(I2C_ST__0__DR)
N#define I2C_ST_0_SHIFT	(I2C_ST__0__SHIFT)
N#define I2C_ST_0_INTR	((uint16)((uint16)0x0003u << (I2C_ST__0__SHIFT*2u)))
N
N#define I2C_ST_INTR_ALL	 ((uint16)(I2C_ST_0_INTR))
N
N
N#endif /* End Pins I2C_ST_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\I2C_ST.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} I2C_ST_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   I2C_ST_Read(void);
Nvoid    I2C_ST_Write(uint8 value);
Nuint8   I2C_ST_ReadDataReg(void);
N#if defined(I2C_ST__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    I2C_ST_SetDriveMode(uint8 mode);
N#endif
Nvoid    I2C_ST_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   I2C_ST_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid I2C_ST_Sleep(void); 
Nvoid I2C_ST_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(I2C_ST__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define I2C_ST_DRIVE_MODE_BITS        (3)
N    #define I2C_ST_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - I2C_ST_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the I2C_ST_SetDriveMode() function.
N         *  @{
N         */
N        #define I2C_ST_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define I2C_ST_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define I2C_ST_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define I2C_ST_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define I2C_ST_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define I2C_ST_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define I2C_ST_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define I2C_ST_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define I2C_ST_MASK               I2C_ST__MASK
N#define I2C_ST_SHIFT              I2C_ST__SHIFT
N#define I2C_ST_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in I2C_ST_SetInterruptMode() function.
N     *  @{
N     */
N        #define I2C_ST_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define I2C_ST_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define I2C_ST_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define I2C_ST_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(I2C_ST__SIO)
X#if 0L
S    #define I2C_ST_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(I2C_ST__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define I2C_ST_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define I2C_ST_USBIO_DISABLE              ((uint32)(~I2C_ST_USBIO_ENABLE))
S    #define I2C_ST_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define I2C_ST_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define I2C_ST_USBIO_ENTER_SLEEP          ((uint32)((1u << I2C_ST_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << I2C_ST_USBIO_SUSPEND_DEL_SHIFT)))
X    #define I2C_ST_USBIO_ENTER_SLEEP          ((uint32)((1u << I2C_ST_USBIO_SUSPEND_SHIFT)                                                         | (1u << I2C_ST_USBIO_SUSPEND_DEL_SHIFT)))
S    #define I2C_ST_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << I2C_ST_USBIO_SUSPEND_SHIFT)))
S    #define I2C_ST_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << I2C_ST_USBIO_SUSPEND_DEL_SHIFT)))
S    #define I2C_ST_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(I2C_ST__PC)
X#if 1L
N    /* Port Configuration */
N    #define I2C_ST_PC                 (* (reg32 *) I2C_ST__PC)
N#endif
N/* Pin State */
N#define I2C_ST_PS                     (* (reg32 *) I2C_ST__PS)
N/* Data Register */
N#define I2C_ST_DR                     (* (reg32 *) I2C_ST__DR)
N/* Input Buffer Disable Override */
N#define I2C_ST_INP_DIS                (* (reg32 *) I2C_ST__PC2)
N
N/* Interrupt configuration Registers */
N#define I2C_ST_INTCFG                 (* (reg32 *) I2C_ST__INTCFG)
N#define I2C_ST_INTSTAT                (* (reg32 *) I2C_ST__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define I2C_ST_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(I2C_ST__SIO)
X#if 0L
S    #define I2C_ST_SIO_REG            (* (reg32 *) I2C_ST__SIO)
N#endif /* (I2C_ST__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(I2C_ST__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define I2C_ST_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define I2C_ST_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define I2C_ST_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define I2C_ST_DRIVE_MODE_SHIFT       (0x00u)
N#define I2C_ST_DRIVE_MODE_MASK        (0x07u << I2C_ST_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins I2C_ST_H */
N
N
N/* [] END OF FILE */
L 60 "Generated_Source\PSoC4\project.h" 2
N#include "I2C_ST_aliases.h"
L 1 "Generated_Source\PSoC4\I2C_ST_aliases.h" 1
N/*******************************************************************************
N* File Name: I2C_ST.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_I2C_ST_ALIASES_H) /* Pins I2C_ST_ALIASES_H */
X#if !1L  
S#define CY_PINS_I2C_ST_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define I2C_ST_0			(I2C_ST__0__PC)
S#define I2C_ST_0_PS		(I2C_ST__0__PS)
S#define I2C_ST_0_PC		(I2C_ST__0__PC)
S#define I2C_ST_0_DR		(I2C_ST__0__DR)
S#define I2C_ST_0_SHIFT	(I2C_ST__0__SHIFT)
S#define I2C_ST_0_INTR	((uint16)((uint16)0x0003u << (I2C_ST__0__SHIFT*2u)))
S
S#define I2C_ST_INTR_ALL	 ((uint16)(I2C_ST_0_INTR))
S
S
N#endif /* End Pins I2C_ST_ALIASES_H */
N
N
N/* [] END OF FILE */
L 61 "Generated_Source\PSoC4\project.h" 2
N#include "CapSense.h"
L 1 "Generated_Source\PSoC4\CapSense.h" 1
N/***************************************************************************//**
N* \file CapSense.h
N* \version 5.0
N*
N* \brief
N*   This file includes all header files of the CapSense Component modules.
N*
N* \see CapSense v5.0 Datasheet
N*
N*//*****************************************************************************
N* Copyright (2016-2017), Cypress Semiconductor Corporation.
N********************************************************************************
N* This software is owned by Cypress Semiconductor Corporation (Cypress) and is
N* protected by and subject to worldwide patent protection (United States and
N* foreign), United States copyright laws and international treaty provisions.
N* Cypress hereby grants to licensee a personal, non-exclusive, non-transferable
N* license to copy, use, modify, create derivative works of, and compile the
N* Cypress Source Code and derivative works for the sole purpose of creating
N* custom software in support of licensee product to be used only in conjunction
N* with a Cypress integrated circuit as specified in the applicable agreement.
N* Any reproduction, modification, translation, compilation, or representation of
N* this software except as specified above is prohibited without the express
N* written permission of Cypress.
N*
N* Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH
N* REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
N* Cypress reserves the right to make changes without further notice to the
N* materials described herein. Cypress does not assume any liability arising out
N* of the application or use of any product or circuit described herein. Cypress
N* does not authorize its products for use as critical components in life-support
N* systems where a malfunction or failure may reasonably be expected to result in
N* significant injury to the user. The inclusion of Cypress' product in a life-
N* support systems application implies that the manufacturer assumes all risk of
N* such use and in doing so indemnifies Cypress against all charges. Use may be
N* limited by and subject to the applicable Cypress software license agreement.
N*******************************************************************************/
N
N#if !defined(CY_SENSE_CapSense_H)
X#if !0L
N
N#define CY_SENSE_CapSense_H
N
N#include "CapSense_Configuration.h"
L 1 "Generated_Source\PSoC4\CapSense_Configuration.h" 1
N/*******************************************************************************
N* \file CapSense_Configuration.h
N* \version 5.0
N*
N* \brief
N*   This file provides the customizer parameters definitions.
N*
N* \see CapSense v5.0 Datasheet
N*
N*//*****************************************************************************
N* Copyright (2016-2017), Cypress Semiconductor Corporation.
N********************************************************************************
N* This software is owned by Cypress Semiconductor Corporation (Cypress) and is
N* protected by and subject to worldwide patent protection (United States and
N* foreign), United States copyright laws and international treaty provisions.
N* Cypress hereby grants to licensee a personal, non-exclusive, non-transferable
N* license to copy, use, modify, create derivative works of, and compile the
N* Cypress Source Code and derivative works for the sole purpose of creating
N* custom software in support of licensee product to be used only in conjunction
N* with a Cypress integrated circuit as specified in the applicable agreement.
N* Any reproduction, modification, translation, compilation, or representation of
N* this software except as specified above is prohibited without the express
N* written permission of Cypress.
N*
N* Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH
N* REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
N* Cypress reserves the right to make changes without further notice to the
N* materials described herein. Cypress does not assume any liability arising out
N* of the application or use of any product or circuit described herein. Cypress
N* does not authorize its products for use as critical components in life-support
N* systems where a malfunction or failure may reasonably be expected to result in
N* significant injury to the user. The inclusion of Cypress' product in a life-
N* support systems application implies that the manufacturer assumes all risk of
N* such use and in doing so indemnifies Cypress against all charges. Use may be
N* limited by and subject to the applicable Cypress software license agreement.
N*******************************************************************************/
N
N#if !defined(CY_SENSE_CapSense_CONFIGURATION_H)
X#if !0L
N#define CY_SENSE_CapSense_CONFIGURATION_H
N
N#include <cytypes.h>
N
N/*******************************************************************************
N* Customizer-generated defines
N*******************************************************************************/
N#define CapSense_ENABLE                             (1u)
N#define CapSense_DISABLE                            (0u)
N
N#define CapSense_THIRD_GENERATION_BLOCK             (1u)
N#define CapSense_FOURTH_GENERATION_BLOCK            (2u)
N
N#define CapSense_GENERATION_BLOCK_VERSION           (2u)
N
N/*******************************************************************************
N* Creator-global defines
N*******************************************************************************/
N
N#if (CapSense_GENERATION_BLOCK_VERSION == CapSense_THIRD_GENERATION_BLOCK)
X#if ((2u) == (1u))
S    #define CapSense_CSDV1                          (1u)
N#else
N    #define CapSense_CSDV1                          (0u)
N#endif
N
N#if (CapSense_GENERATION_BLOCK_VERSION == CapSense_FOURTH_GENERATION_BLOCK)
X#if ((2u) == (2u))
N    #define CapSense_CSDV2                          (1u)
N#else
S    #define CapSense_CSDV2                          (0u)
N#endif
N
N#if (CapSense_CSDV1 == 1u)
X#if ((0u) == 1u)
S    #if (0u != CYIPBLOCK_m0s8csd_VERSION)
S        #define CapSense_CSDV1_VER2                 (1u)
S    #else
S        #define CapSense_CSDV1_VER2                 (0u)
S    #endif  /* (0u != CYIPBLOCK_m0s8csd_VERSION) */
N#endif  /* CYIPBLOCK_m0s8csdv2_VERSION */
N
N
N#define CapSense_2000_MV                            (2000u)
N
N#ifdef CYDEV_VDDA_MV
N    #define CapSense_CYDEV_VDDA_MV                  (CYDEV_VDDA_MV)
N#else
S    #ifdef CYDEV_VDD_MV
S        #define CapSense_CYDEV_VDDA_MV              (CYDEV_VDD_MV)
S    #endif
N#endif
N
N#define CapSense_BAD_CONVERSIONS_NUM                (1u)
N#define CapSense_RESAMPLING_CYCLES_MAX_NUMBER       (1u)
N
N/*******************************************************************************
N* Enabled Scan Methods
N*******************************************************************************/
N#define CapSense_CSD_EN                   (1u)
N#define CapSense_CSX_EN                   (0u)
N#define CapSense_ISX_EN                   (0u)
N#define CapSense_CSD_CSX_EN               (CapSense_CSD_EN && CapSense_CSX_EN)
N#define CapSense_CSD_ISX_EN               (CapSense_CSD_EN && CapSense_ISX_EN)
N#define CapSense_CSX_ISX_EN               (CapSense_CSX_EN && CapSense_ISX_EN)
N#define CapSense_CSD_CSX_ISX_EN           (CapSense_CSD_EN && CapSense_CSX_EN & CapSense_ISX_EN)
N#define CapSense_USES_MANY_SENSE_MODES    ((CapSense_TOTAL_CSD_WIDGETS && \
N                                                   (CapSense_TOTAL_CSX_WIDGETS || CapSense_TOTAL_ISX_WIDGETS)) || \
N                                                   (CapSense_TOTAL_CSX_WIDGETS && CapSense_TOTAL_ISX_WIDGETS))
X#define CapSense_USES_MANY_SENSE_MODES    ((CapSense_TOTAL_CSD_WIDGETS &&                                                    (CapSense_TOTAL_CSX_WIDGETS || CapSense_TOTAL_ISX_WIDGETS)) ||                                                    (CapSense_TOTAL_CSX_WIDGETS && CapSense_TOTAL_ISX_WIDGETS))
N#define CapSense_CSD2X_EN                 (0u)
N#define CapSense_CSX2X_EN                 (0u)
N
N/*******************************************************************************
N* Definitions for number of widgets and sensors
N*******************************************************************************/
N#define CapSense_TOTAL_WIDGETS            (13u)
N#define CapSense_TOTAL_CSD_WIDGETS        (13u)
N#define CapSense_TOTAL_CSD_SENSORS        (13u)
N#define CapSense_TOTAL_CSX_WIDGETS        (0u)
N#define CapSense_TOTAL_ISX_WIDGETS        (0u)
N#define CapSense_TOTAL_CSX_NODES          (0u)
N#define CapSense_TOTAL_ISX_NODES          (0u)
N
N/*******************************************************************************
N* Total number of CSD sensors + CSX nodes
N*******************************************************************************/
N#define CapSense_TOTAL_SENSORS            (CapSense_TOTAL_CSD_SENSORS + \
N                                                   CapSense_TOTAL_CSX_NODES+ \
N                                                   CapSense_TOTAL_ISX_NODES)
X#define CapSense_TOTAL_SENSORS            (CapSense_TOTAL_CSD_SENSORS +                                                    CapSense_TOTAL_CSX_NODES+                                                    CapSense_TOTAL_ISX_NODES)
N
N/*******************************************************************************
N* Total number of scan slots (used only when dual-channel scan is enabled)
N*******************************************************************************/
N#define CapSense_TOTAL_SCAN_SLOTS         (13u)
N
N/*******************************************************************************
N* Defines widget IDs
N*******************************************************************************/
N#define CapSense_BUTTON0_WDGT_ID                (0u)
N#define CapSense_BUTTON1_WDGT_ID                (1u)
N#define CapSense_BUTTON2_WDGT_ID                (2u)
N#define CapSense_BUTTON3_WDGT_ID                (3u)
N#define CapSense_BUTTON4_WDGT_ID                (4u)
N#define CapSense_BUTTON5_WDGT_ID                (5u)
N#define CapSense_BUTTON6_WDGT_ID                (6u)
N#define CapSense_BUTTON7_WDGT_ID                (7u)
N#define CapSense_BUTTON8_WDGT_ID                (8u)
N#define CapSense_BUTTON9_WDGT_ID                (9u)
N#define CapSense_BUTTON10_WDGT_ID               (10u)
N#define CapSense_BUTTON11_WDGT_ID               (11u)
N#define CapSense_PROXIMITY0_WDGT_ID             (12u)
N
N/*******************************************************************************
N* Defines sensor IDs
N*******************************************************************************/
N
N/* Button0 sensor names */
N#define CapSense_BUTTON0_SNS0_ID                (0u)
N
N/* Button1 sensor names */
N#define CapSense_BUTTON1_SNS0_ID                (0u)
N
N/* Button2 sensor names */
N#define CapSense_BUTTON2_SNS0_ID                (0u)
N
N/* Button3 sensor names */
N#define CapSense_BUTTON3_SNS0_ID                (0u)
N
N/* Button4 sensor names */
N#define CapSense_BUTTON4_SNS0_ID                (0u)
N
N/* Button5 sensor names */
N#define CapSense_BUTTON5_SNS0_ID                (0u)
N
N/* Button6 sensor names */
N#define CapSense_BUTTON6_SNS0_ID                (0u)
N
N/* Button7 sensor names */
N#define CapSense_BUTTON7_SNS0_ID                (0u)
N
N/* Button8 sensor names */
N#define CapSense_BUTTON8_SNS0_ID                (0u)
N
N/* Button9 sensor names */
N#define CapSense_BUTTON9_SNS0_ID                (0u)
N
N/* Button10 sensor names */
N#define CapSense_BUTTON10_SNS0_ID               (0u)
N
N/* Button11 sensor names */
N#define CapSense_BUTTON11_SNS0_ID               (0u)
N
N/* Proximity0 sensor names */
N#define CapSense_PROXIMITY0_SNS0_ID             (0u)
N
N
N
N/*******************************************************************************
N* Enabled widget types
N*******************************************************************************/
N#define CapSense_BUTTON_WIDGET_EN         (1u)
N#define CapSense_SLIDER_WIDGET_EN         (0u)
N#define CapSense_MATRIX_WIDGET_EN         (0u)
N#define CapSense_PROXIMITY_WIDGET_EN      (1u)
N#define CapSense_TOUCHPAD_WIDGET_EN       (0u)
N
N#define CapSense_CSD_MATRIX_WIDGET_EN     (0u)
N#define CapSense_CSD_TOUCHPAD_WIDGET_EN   (0u)
N
N#define CapSense_CSX_MATRIX_WIDGET_EN     (0u)
N#define CapSense_CSX_TOUCHPAD_WIDGET_EN   (0u)
N
N/*******************************************************************************
N* Centroid APIs
N*******************************************************************************/
N#define CapSense_CENTROID_EN              (0u)
N#define CapSense_TOTAL_DIPLEXED_SLIDERS   (0u)
N#define CapSense_TOTAL_LINEAR_SLIDERS     (0u)
N#define CapSense_TOTAL_RADIAL_SLIDERS     (0u)
N#define CapSense_TOTAL_TOUCHPADS          (0u)
N#define CapSense_MAX_CENTROID_LENGTH      (0u)
N#define CapSense_SLIDER_MULT_METHOD       (0u)
N#define CapSense_TOUCHPAD_MULT_METHOD     (0u)
N
N/*******************************************************************************
N* Enabled sensor types
N*******************************************************************************/
N#define CapSense_REGULAR_SENSOR_EN        (1u)
N#define CapSense_PROXIMITY_SENSOR_EN      (1u)
N
N/*******************************************************************************
N* Sensor ganging
N*******************************************************************************/
N#define CapSense_GANGED_SNS_EN            (1u)
N#define CapSense_CSD_GANGED_SNS_EN        (1u)
N#define CapSense_CSX_GANGED_SNS_EN        (0u)
N
N/*******************************************************************************
N* Max number of sensors used among all the widgets
N*******************************************************************************/
N#define CapSense_MAX_SENSORS_PER_WIDGET   (2u)
N#define CapSense_MAX_SENSORS_PER_5X5_TOUCHPAD (1u)
N
N/*******************************************************************************
N* Total number of all used electrodes (NOT unique)
N*******************************************************************************/
N#define CapSense_TOTAL_ELECTRODES         (24u)
N/* Obsolete */
N#define CapSense_TOTAL_SENSOR_IOS         CapSense_TOTAL_ELECTRODES
N
N/*******************************************************************************
N* Total number of used physical IOs (unique)
N*******************************************************************************/
N#define CapSense_TOTAL_IO_CNT             (12u)
N
N/*******************************************************************************
N* Array length for widget status registers
N*******************************************************************************/
N#define CapSense_WDGT_STATUS_WORDS        \
N                        (((uint8)((CapSense_TOTAL_WIDGETS - 1u) / 32u)) + 1u)
X#define CapSense_WDGT_STATUS_WORDS                                (((uint8)((CapSense_TOTAL_WIDGETS - 1u) / 32u)) + 1u)
N
N
N/*******************************************************************************
N* Auto-tuning mode selection
N*******************************************************************************/
N#define CapSense_CSD_SS_DIS         (0x00ul)
N#define CapSense_CSD_SS_HW_EN       (0x01ul)
N#define CapSense_CSD_SS_TH_EN       (0x02ul)
N#define CapSense_CSD_SS_HWTH_EN     (CapSense_CSD_SS_HW_EN | \
N                                             CapSense_CSD_SS_TH_EN)
X#define CapSense_CSD_SS_HWTH_EN     (CapSense_CSD_SS_HW_EN |                                              CapSense_CSD_SS_TH_EN)
N
N#define CapSense_CSD_AUTOTUNE       CapSense_CSD_SS_DIS
N
N
N/*******************************************************************************
N* General settings
N*******************************************************************************/
N
N#define CapSense_AUTO_RESET_METHOD_LEGACY (0u)
N#define CapSense_AUTO_RESET_METHOD_SAMPLE (1u)
N
N#define CapSense_MULTI_FREQ_SCAN_EN       (0u)
N#define CapSense_SENSOR_AUTO_RESET_EN     (0u)
N#define CapSense_SENSOR_AUTO_RESET_METHOD (0u)
N#define CapSense_NUM_CENTROIDS            (1u)
N#define CapSense_4PTS_LOCAL_MAX_EN        (0u)
N#define CapSense_OFF_DEBOUNCE_EN          (0u)
N#define CapSense_CUSTOM_DS_RAM_SIZE       (0u)
N
N/* Defines power status of HW block after scanning */
N#define CapSense_BLOCK_OFF_AFTER_SCAN_EN  (0u)
N
N/* Defines number of scan frequencies */
N#if (CapSense_DISABLE != CapSense_MULTI_FREQ_SCAN_EN)
X#if ((0u) != (0u))
S    #define CapSense_NUM_SCAN_FREQS       (3u)
N#else
N    #define CapSense_NUM_SCAN_FREQS       (1u)
N#endif /* #if (CapSense_DISABLE != CapSense_MULTI_FREQ_SCAN_EN) */
N
N/* Data size for thresholds / low baseline reset */
N#define CapSense_SIZE_8BITS               (8u)
N#define CapSense_SIZE_16BITS              (16u)
N
N#define CapSense_THRESHOLD_SIZE           CapSense_SIZE_16BITS
Ntypedef uint16 CapSense_THRESHOLD_TYPE;
N
N#if (CapSense_AUTO_RESET_METHOD_LEGACY == CapSense_SENSOR_AUTO_RESET_METHOD)
X#if ((0u) == (0u))
N    #define CapSense_LOW_BSLN_RST_SIZE        CapSense_SIZE_8BITS
N    typedef uint8 CapSense_LOW_BSLN_RST_TYPE;
N#else
S    #define CapSense_LOW_BSLN_RST_SIZE    (16u)
S    typedef uint16 CapSense_LOW_BSLN_RST_TYPE;
N#endif /* #if (CapSense_AUTO_RESET_METHOD_LEGACY == CapSense_SENSOR_AUTO_RESET_METHOD) */
N
N/* Coefficient to define touch threshold for proximity sensors */
N#define CapSense_PROX_TOUCH_COEFF         (300u)
N
N/*******************************************************************************
N* General Filter Constants
N*******************************************************************************/
N
N/* Baseline algorithm options */
N#define CapSense_IIR_BASELINE                 (0u)
N#define CapSense_BUCKET_BASELINE              (1u)
N
N#define CapSense_BASELINE_TYPE                CapSense_IIR_BASELINE
N
N/* IIR baseline filter algorithm for regular sensors*/
N#define CapSense_REGULAR_IIR_BL_TYPE          CapSense_IIR_FILTER_PERFORMANCE
N
N/* IIR baseline coefficients for regular sensors */
N#define CapSense_REGULAR_IIR_BL_N             (1u)
N#define CapSense_REGULAR_IIR_BL_SHIFT         (8u)
N
N/* IIR baseline filter algorithm for proximity sensors*/
N#define CapSense_PROX_IIR_BL_TYPE             CapSense_IIR_FILTER_PERFORMANCE
N
N/* IIR baseline coefficients for proximity sensors */
N#define CapSense_PROX_IIR_BL_N                (1u)
N#define CapSense_PROX_IIR_BL_SHIFT            (8u)
N
N
N/* IIR filter constants */
N#define CapSense_IIR_COEFFICIENT_K            (256u)
N
N/* IIR filter type */
N#define CapSense_IIR_FILTER_STANDARD          (1u)
N#define CapSense_IIR_FILTER_PERFORMANCE       (2u)
N#define CapSense_IIR_FILTER_MEMORY            (3u)
N
N/* Regular sensor raw count filters */
N#define CapSense_REGULAR_RC_FILTER_EN         (0u)
N#define CapSense_REGULAR_RC_IIR_FILTER_EN     (0u)
N#define CapSense_REGULAR_RC_MEDIAN_FILTER_EN  (0u)
N#define CapSense_REGULAR_RC_AVERAGE_FILTER_EN (0u)
N#define CapSense_REGULAR_RC_CUSTOM_FILTER_EN  (0u)
N#define CapSense_REGULAR_RC_ALP_FILTER_EN     (0u)
N
N/* Proximity sensor raw count filters */
N#define CapSense_PROX_RC_FILTER_EN            (0u)
N#define CapSense_PROX_RC_IIR_FILTER_EN        (0u)
N#define CapSense_PROX_RC_MEDIAN_FILTER_EN     (0u)
N#define CapSense_PROX_RC_AVERAGE_FILTER_EN    (0u)
N#define CapSense_PROX_RC_CUSTOM_FILTER_EN     (0u)
N#define CapSense_PROX_RC_ALP_FILTER_EN        (0u)
N
N#define CapSense_ALP_FILTER_EN                (0u)
N#define CapSense_REGULAR_RC_ALP_FILTER_COEFF  (2u)
N#define CapSense_PROX_RC_ALP_FILTER_COEFF     (2u)
N
N/* Raw count filters */
N#define CapSense_RC_FILTER_EN                 (CapSense_REGULAR_RC_FILTER_EN || CapSense_PROX_RC_FILTER_EN)
N
N/* IIR raw count filter algorithm for regular sensors */
N#define CapSense_REGULAR_IIR_RC_TYPE          (CapSense_IIR_FILTER_STANDARD)
N
N/* IIR raw count filter coefficients for regular sensors */
N#define CapSense_REGULAR_IIR_RC_N             (128u)
N#define CapSense_REGULAR_IIR_RC_SHIFT         (0u)
N
N/* IIR raw count filter algorithm for proximity sensors*/
N#define CapSense_PROX_IIR_RC_TYPE             (CapSense_IIR_FILTER_STANDARD)
N
N/* IIR raw count filter coefficients for proximity sensors */
N#define CapSense_PROX_IIR_RC_N                (128u)
N#define CapSense_PROX_IIR_RC_SHIFT            (0u)
N
N/* Median filter constants */
N
N/* Order of regular sensor median filter */
N#define CapSense_REGULAR_MEDIAN_LEN           (2u)
N
N/* Order of proximity sensor median filter */
N#define CapSense_PROX_MEDIAN_LEN              (2u)
N
N/* Average filter constants*/
N#define CapSense_AVERAGE_FILTER_LEN_2         (1u)
N#define CapSense_AVERAGE_FILTER_LEN_4         (3u)
N
N/* Order of regular sensor average filter */
N#define CapSense_REGULAR_AVERAGE_LEN          (CapSense_AVERAGE_FILTER_LEN_4)
N
N/* Order of proximity sensor average filter */
N#define CapSense_PROX_AVERAGE_LEN             (CapSense_AVERAGE_FILTER_LEN_4)
N
N/* Widget baseline coefficient enable */
N#define CapSense_WD_BSLN_COEFF_EN             (0u)
N
N/* Centroid position filters */
N#define CapSense_POSITION_FILTER_EN           (0u)
N#define CapSense_POS_MEDIAN_FILTER_EN         (0u)
N#define CapSense_POS_IIR_FILTER_EN            (0u)
N#define CapSense_POS_ADAPTIVE_IIR_FILTER_EN   (0u)
N#define CapSense_POS_AVERAGE_FILTER_EN        (0u)
N#define CapSense_POS_JITTER_FILTER_EN         (0u)
N#define CapSense_BALLISTIC_MULTIPLIER_EN      (0u)
N#define CapSense_CENTROID_3X3_CSD_EN          (0u)
N#define CapSense_CENTROID_5X5_CSD_EN          (0u)
N#define CapSense_CSD_5X5_MAX_FINGERS          (1u)
N
N#define CapSense_POS_IIR_COEFF                (128u)
N#define CapSense_POS_IIR_RESET_RADIAL_SLIDER  (35u)
N
N#define CapSense_CSX_TOUCHPAD_UNDEFINED       (40u)
N
N/* IDAC options */
N
N/* Third-generation HW block IDAC gain */
N#define CapSense_IDAC_GAIN_4X                 (4u)
N#define CapSense_IDAC_GAIN_8X                 (8u)
N
N/* Fourth-generation HW block IDAC gain */
N#define CapSense_IDAC_GAIN_LOW                (0uL)
N#define CapSense_IDAC_GAIN_MEDIUM             (1uL)
N#define CapSense_IDAC_GAIN_HIGH               (2uL)
N
N#define CapSense_IDAC_SOURCING                (0u)
N#define CapSense_IDAC_SINKING                 (1u)
N
N/* Shield tank capacitor precharge source */
N#define CapSense_CSH_PRECHARGE_VREF           (0u)
N#define CapSense_CSH_PRECHARGE_IO_BUF         (1u)
N
N/* Shield electrode delay */
N#define CapSense_NO_DELAY                     (0u)
N
N#if(CapSense_ENABLE == CapSense_CSDV2)
X#if((1u) == (1u))
N    #define CapSense_SH_DELAY_5NS             (1u)
N    #define CapSense_SH_DELAY_10NS            (2u)
N    #define CapSense_SH_DELAY_20NS            (3u)
N#else
S    #if(CapSense_ENABLE == CapSense_CSDV1_VER2)
S        #define CapSense_SH_DELAY_10NS        (3u)
S        #define CapSense_SH_DELAY_50NS        (2u)
S    #else
S        #define CapSense_SH_DELAY_1CYCLES     (1u)
S        #define CapSense_SH_DELAY_2CYCLES     (2u)
S    #endif /* (CapSense_ENABLE == CapSense_CSDV1_VER2) */
N#endif /* (CapSense_ENABLE == CapSense_CSDV2) */
N
N/* Inactive sensor connection options */
N#define CapSense_SNS_CONNECTION_GROUND        (0x00000006Lu)
N#define CapSense_SNS_CONNECTION_HIGHZ         (0x00000000Lu)
N#define CapSense_SNS_CONNECTION_SHIELD        (0x00000002Lu)
N
N/* Sense clock selection options */
N#if defined(CapSense_TAPEOUT_STAR_USED)
X#if 0L
S    #define CapSense_CSDV2_REF9P6UA_EN            (0u)
N#else
N    #define CapSense_CSDV2_REF9P6UA_EN            (1u)
N#endif /* defined(CapSense_TAPEOUT_STAR_USED) */
N
N#define CapSense_CLK_SOURCE_DIRECT            (0x00000000Lu)
N
N#define CapSense_CLK_SOURCE_SSC1              (0x01u)
N#define CapSense_CLK_SOURCE_SSC2              (0x02u)
N#define CapSense_CLK_SOURCE_SSC3              (0x03u)
N#define CapSense_CLK_SOURCE_SSC4              (0x04u)
N
N#define CapSense_CLK_SOURCE_PRS8              (0x05u)
N#define CapSense_CLK_SOURCE_PRS12             (0x06u)
N#define CapSense_CLK_SOURCE_PRSAUTO           (0xFFu)
N
N#define CapSense_MFS_IMO                      (0u)
N#define CapSense_MFS_SNS_CLK                  (1u)
N
N/* Defines scan resolutions */
N#define CapSense_RES6BIT                      (6u)
N#define CapSense_RES7BIT                      (7u)
N#define CapSense_RES8BIT                      (8u)
N#define CapSense_RES9BIT                      (9u)
N#define CapSense_RES10BIT                     (10u)
N#define CapSense_RES11BIT                     (11u)
N#define CapSense_RES12BIT                     (12u)
N#define CapSense_RES13BIT                     (13u)
N#define CapSense_RES14BIT                     (14u)
N#define CapSense_RES15BIT                     (15u)
N#define CapSense_RES16BIT                     (16u)
N
N/* Fourth-generation HW block: Initialization switch resistance */
N#define CapSense_INIT_SW_RES_LOW              (0x00000000Lu)
N#define CapSense_INIT_SW_RES_MEDIUM           (0x00000001Lu)
N#define CapSense_INIT_SW_RES_HIGH             (0x00000002Lu)
N
N/* Fourth-generation HW block: Initialization switch resistance */
N#define CapSense_SCAN_SW_RES_LOW              (0x00000000Lu)
N#define CapSense_SCAN_SW_RES_MEDIUM           (0x00000001Lu)
N#define CapSense_SCAN_SW_RES_HIGH             (0x00000002Lu)
N
N/* Fourth-generation HW block: CSD shield switch resistance */
N#define CapSense_SHIELD_SW_RES_LOW            (0x00000000Lu)
N#define CapSense_SHIELD_SW_RES_MEDIUM         (0x00000001Lu)
N#define CapSense_SHIELD_SW_RES_HIGH           (0x00000002Lu)
N#define CapSense_SHIELD_SW_RES_LOW_EMI        (0x00000003Lu)
N
N/* Fourth-generation HW block: CSD shield switch resistance */
N#define CapSense_INIT_SHIELD_SW_RES_LOW       (0x00000000Lu)
N#define CapSense_INIT_SHIELD_SW_RES_MEDIUM    (0x00000001Lu)
N#define CapSense_INIT_SHIELD_SW_RES_HIGH      (0x00000002Lu)
N#define CapSense_INIT_SHIELD_SW_RES_LOW_EMI   (0x00000003Lu)
N
N/* Fourth-generation HW block: CSD shield switch resistance */
N#define CapSense_SCAN_SHIELD_SW_RES_LOW       (0x00000000Lu)
N#define CapSense_SCAN_SHIELD_SW_RES_MEDIUM    (0x00000001Lu)
N#define CapSense_SCAN_SHIELD_SW_RES_HIGH      (0x00000002Lu)
N#define CapSense_SCAN_SHIELD_SW_RES_LOW_EMI   (0x00000003Lu)
N
N/* Sensing method */
N#define CapSense_SENSING_LEGACY               (0x00000000Lu)
N#define CapSense_SENSING_LOW_EMI              (0x00000001Lu)
N#define CapSense_SENSING_FULL_WAVE            (0x00000002Lu)
N
N
N/*******************************************************************************
N* CSD/CSX Common settings
N*******************************************************************************/
N
N#define CapSense_BLOCK_ANALOG_WAKEUP_DELAY_US (0u)
N
N#define CapSense_MFS_METHOD                   (0u)
N#define CapSense_IMO_FREQUENCY_OFFSET_F1      (20u)
N#define CapSense_IMO_FREQUENCY_OFFSET_F2      (20u)
N
N/*******************************************************************************
N* CSD Specific settings
N*******************************************************************************/
N
N/* CSD scan method settings */
N#define CapSense_CSD_IDAC_AUTOCAL_EN          (1u)
N#define CapSense_CSD_IDAC_GAIN                (CapSense_IDAC_GAIN_HIGH)
N#define CapSense_CSD_SHIELD_EN                (0u)
N#define CapSense_CSD_SHIELD_TANK_EN           (0u)
N#define CapSense_CSD_CSH_PRECHARGE_SRC        (CapSense_CSH_PRECHARGE_VREF)
N#define CapSense_CSD_SHIELD_DELAY             (CapSense_NO_DELAY)
N#define CapSense_CSD_TOTAL_SHIELD_COUNT       (0u)
N#define CapSense_CSD_SCANSPEED_DIVIDER        (2u)
N#define CapSense_CSD_COMMON_SNS_CLK_EN        (0u)
N#define CapSense_CSD_SNS_CLK_SOURCE           (CapSense_CLK_SOURCE_PRSAUTO)
N#define CapSense_CSD_SNS_CLK_DIVIDER          (8u)
N#define CapSense_CSD_INACTIVE_SNS_CONNECTION  (CapSense_SNS_CONNECTION_GROUND)
N#define CapSense_CSD_IDAC_COMP_EN             (1u)
N#define CapSense_CSD_IDAC_CONFIG              (CapSense_IDAC_SOURCING)
N#define CapSense_CSD_RAWCOUNT_CAL_LEVEL       (85u)
N#define CapSense_CSD_DUALIDAC_LEVEL           (50u)
N#define CapSense_CSD_PRESCAN_SETTLING_TIME    (5u)
N#define CapSense_CSD_SNSCLK_R_CONST           (1000u)
N#define CapSense_CSD_VREF_MV                  (2021u)
N
N/* CSD settings - Fourth-generation HW block */
N#define CapSense_CSD_ANALOG_STARTUP_DELAY_US  (10u)
N#define CapSense_CSD_FINE_INIT_TIME           (10u)
N#define CapSense_CSD_DEDICATED_IDAC_COMP_EN   (1u)
N#define CapSense_CSD_AUTO_ZERO_EN             (0u)
N#define CapSense_CSD_AUTO_ZERO_TIME           (15Lu)
N#define CapSense_CSD_NOISE_METRIC_EN          (0u)
N#define CapSense_CSD_NOISE_METRIC_TH          (1Lu)
N#define CapSense_CSD_INIT_SWITCH_RES          (CapSense_INIT_SW_RES_MEDIUM)
N#define CapSense_CSD_SENSING_METHOD           (0)
N#define CapSense_CSD_SHIELD_SWITCH_RES        (CapSense_SHIELD_SW_RES_MEDIUM)
N#define CapSense_CSD_GAIN                     (18Lu)
N
N#define CapSense_CSD_MFS_DIVIDER_OFFSET_F1    (1u)
N#define CapSense_CSD_MFS_DIVIDER_OFFSET_F2    (2u)
N
N
N/*******************************************************************************
N* CSX Specific settings
N*******************************************************************************/
N
N/* CSX scan method settings */
N#define CapSense_CSX_SCANSPEED_DIVIDER        (2u)
N#define CapSense_CSX_COMMON_TX_CLK_EN         (0u)
N#define CapSense_CSX_TX_CLK_SOURCE            (CapSense_CLK_SOURCE_PRSAUTO)
N#define CapSense_CSX_TX_CLK_DIVIDER           (80u)
N#define CapSense_CSX_MAX_FINGERS              (1u)
N#define CapSense_CSX_MAX_LOCAL_PEAKS          (5u)
N#define CapSense_CSX_IDAC_AUTOCAL_EN          (0u)
N#define CapSense_CSX_IDAC_BITS_USED           (7u)
N#define CapSense_CSX_RAWCOUNT_CAL_LEVEL       (40u)
N#define CapSense_CSX_IDAC_GAIN                (CapSense_IDAC_GAIN_MEDIUM)
N#define CapSense_CSX_SKIP_OVSMPL_SPECIFIC_NODES (0u)
N#define CapSense_CSX_MULTIPHASE_TX_EN         (0u)
N#define CapSense_CSX_MAX_TX_PHASE_LENGTH      (0u)
N
N/* CSX settings - Fourth-generation HW block */
N#define CapSense_CSX_ANALOG_STARTUP_DELAY_US  (10u)
N#define CapSense_CSX_AUTO_ZERO_EN             (0u)
N#define CapSense_CSX_AUTO_ZERO_TIME           (15u)
N#define CapSense_CSX_FINE_INIT_TIME           (4u)
N#define CapSense_CSX_NOISE_METRIC_EN          (0u)
N#define CapSense_CSX_NOISE_METRIC_TH          (1u)
N#define CapSense_CSX_INIT_SWITCH_RES          (CapSense_INIT_SW_RES_MEDIUM)
N#define CapSense_CSX_SCAN_SWITCH_RES          (CapSense_SCAN_SW_RES_LOW)
N#define CapSense_CSX_INIT_SHIELD_SWITCH_RES   (CapSense_INIT_SHIELD_SW_RES_HIGH)
N#define CapSense_CSX_SCAN_SHIELD_SWITCH_RES   (CapSense_SCAN_SHIELD_SW_RES_LOW)
N
N#define CapSense_CSX_MFS_DIVIDER_OFFSET_F1    (1u)
N#define CapSense_CSX_MFS_DIVIDER_OFFSET_F2    (2u)
N
N/* Gesture parameters */
N#define CapSense_GES_GLOBAL_EN                (0u)
N
N/*******************************************************************************
N* ISX Specific settings
N*******************************************************************************/
N
N/* ISX scan method settings */
N#define CapSense_ISX_SCANSPEED_DIVIDER        (2u)
N#define CapSense_ISX_LX_CLK_DIVIDER           (80u)
N#define CapSense_ISX_IDAC_AUTOCAL_EN          (0u)
N#define CapSense_ISX_IDAC_BITS_USED           (7u)
N#define CapSense_ISX_RAWCOUNT_CAL_LEVEL       (30u)
N#define CapSense_ISX_IDAC_GAIN                (CapSense_IDAC_GAIN_MEDIUM)
N#define CapSense_ISX_SKIP_OVSMPL_SPECIFIC_NODES (0u)
N#define CapSense_ISX_MAX_TX_PHASE_LENGTH      (0u)
N#define CapSense_ISX_PIN_COUNT_LX             (u)
N/* ISX settings - Fourth-generation HW block */
N#define CapSense_ISX_AUTO_ZERO_EN             (0u)
N#define CapSense_ISX_AUTO_ZERO_TIME           (15u)
N#define CapSense_ISX_FINE_INIT_TIME           (20u)
N#define CapSense_ISX_NOISE_METRIC_EN          (0u)
N#define CapSense_ISX_NOISE_METRIC_TH          (1u)
N#define CapSense_ISX_INIT_SWITCH_RES          (CapSense_INIT_SW_RES_MEDIUM)
N#define CapSense_ISX_SCAN_SWITCH_RES          (CapSense_SCAN_SW_RES_LOW)
N#define CapSense_ISX_INIT_SHIELD_SWITCH_RES   (CapSense_INIT_SHIELD_SW_RES_HIGH)
N#define CapSense_ISX_SCAN_SHIELD_SWITCH_RES   (CapSense_SCAN_SHIELD_SW_RES_LOW)
N
N
N/*******************************************************************************
N* Global Parameter Definitions
N*******************************************************************************/
N
N/* Compound section definitions */
N#define CapSense_ANY_NONSS_AUTOCAL ((0u != CapSense_CSX_IDAC_AUTOCAL_EN) || \
N                                       (0u != CapSense_ISX_IDAC_AUTOCAL_EN) || \
N                                      ((CapSense_CSD_AUTOTUNE == CapSense_CSD_SS_DIS) && (0u != CapSense_CSD_IDAC_AUTOCAL_EN)))
X#define CapSense_ANY_NONSS_AUTOCAL ((0u != CapSense_CSX_IDAC_AUTOCAL_EN) ||                                        (0u != CapSense_ISX_IDAC_AUTOCAL_EN) ||                                       ((CapSense_CSD_AUTOTUNE == CapSense_CSD_SS_DIS) && (0u != CapSense_CSD_IDAC_AUTOCAL_EN)))
N#define CapSense_ANYMODE_AUTOCAL (((0u != CapSense_CSX_IDAC_AUTOCAL_EN) \
N                                       || (0u != CapSense_ISX_IDAC_AUTOCAL_EN)) \
N                                       || (0u != CapSense_CSD_IDAC_AUTOCAL_EN))
X#define CapSense_ANYMODE_AUTOCAL (((0u != CapSense_CSX_IDAC_AUTOCAL_EN)                                        || (0u != CapSense_ISX_IDAC_AUTOCAL_EN))                                        || (0u != CapSense_CSD_IDAC_AUTOCAL_EN))
N/* RAM Global Parameters Definitions */
N#define CapSense_CONFIG_ID                      (0x13E2u)
N#define CapSense_DEVICE_ID                      (0x0100u)
N#define CapSense_HW_CLOCK                       (0x1770u)
N#define CapSense_CSD0_CONFIG                    (0x0008u)
N
N/*******************************************************************************
N* Button0 initialization values for FLASH data structure
N*******************************************************************************/
N#define CapSense_BUTTON0_STATIC_CONFIG          (10249u)
N#define CapSense_BUTTON0_NUM_SENSORS            (1u)
N
N/*******************************************************************************
N* Button0 initialization values for RAM data structure
N*******************************************************************************/
N#define CapSense_BUTTON0_RESOLUTION             (CapSense_RES11BIT)
N#define CapSense_BUTTON0_FINGER_TH              (100u)
N#define CapSense_BUTTON0_NOISE_TH               (20u)
N#define CapSense_BUTTON0_NNOISE_TH              (20u)
N#define CapSense_BUTTON0_HYSTERESIS             (10u)
N#define CapSense_BUTTON0_ON_DEBOUNCE            (3u)
N#define CapSense_BUTTON0_LOW_BSLN_RST           (30u)
N#define CapSense_BUTTON0_IDAC_MOD0              (32u)
N#define CapSense_BUTTON0_SNS_CLK                (8u)
N#define CapSense_BUTTON0_SNS_CLK_SOURCE         (0u)
N
N/*******************************************************************************
N* Button1 initialization values for FLASH data structure
N*******************************************************************************/
N#define CapSense_BUTTON1_STATIC_CONFIG          (10249u)
N#define CapSense_BUTTON1_NUM_SENSORS            (1u)
N
N/*******************************************************************************
N* Button1 initialization values for RAM data structure
N*******************************************************************************/
N#define CapSense_BUTTON1_RESOLUTION             (CapSense_RES11BIT)
N#define CapSense_BUTTON1_FINGER_TH              (100u)
N#define CapSense_BUTTON1_NOISE_TH               (20u)
N#define CapSense_BUTTON1_NNOISE_TH              (20u)
N#define CapSense_BUTTON1_HYSTERESIS             (10u)
N#define CapSense_BUTTON1_ON_DEBOUNCE            (3u)
N#define CapSense_BUTTON1_LOW_BSLN_RST           (30u)
N#define CapSense_BUTTON1_IDAC_MOD0              (32u)
N#define CapSense_BUTTON1_SNS_CLK                (8u)
N#define CapSense_BUTTON1_SNS_CLK_SOURCE         (0u)
N
N/*******************************************************************************
N* Button2 initialization values for FLASH data structure
N*******************************************************************************/
N#define CapSense_BUTTON2_STATIC_CONFIG          (10249u)
N#define CapSense_BUTTON2_NUM_SENSORS            (1u)
N
N/*******************************************************************************
N* Button2 initialization values for RAM data structure
N*******************************************************************************/
N#define CapSense_BUTTON2_RESOLUTION             (CapSense_RES11BIT)
N#define CapSense_BUTTON2_FINGER_TH              (100u)
N#define CapSense_BUTTON2_NOISE_TH               (20u)
N#define CapSense_BUTTON2_NNOISE_TH              (20u)
N#define CapSense_BUTTON2_HYSTERESIS             (10u)
N#define CapSense_BUTTON2_ON_DEBOUNCE            (3u)
N#define CapSense_BUTTON2_LOW_BSLN_RST           (30u)
N#define CapSense_BUTTON2_IDAC_MOD0              (32u)
N#define CapSense_BUTTON2_SNS_CLK                (8u)
N#define CapSense_BUTTON2_SNS_CLK_SOURCE         (0u)
N
N/*******************************************************************************
N* Button3 initialization values for FLASH data structure
N*******************************************************************************/
N#define CapSense_BUTTON3_STATIC_CONFIG          (10249u)
N#define CapSense_BUTTON3_NUM_SENSORS            (1u)
N
N/*******************************************************************************
N* Button3 initialization values for RAM data structure
N*******************************************************************************/
N#define CapSense_BUTTON3_RESOLUTION             (CapSense_RES11BIT)
N#define CapSense_BUTTON3_FINGER_TH              (100u)
N#define CapSense_BUTTON3_NOISE_TH               (20u)
N#define CapSense_BUTTON3_NNOISE_TH              (20u)
N#define CapSense_BUTTON3_HYSTERESIS             (10u)
N#define CapSense_BUTTON3_ON_DEBOUNCE            (3u)
N#define CapSense_BUTTON3_LOW_BSLN_RST           (30u)
N#define CapSense_BUTTON3_IDAC_MOD0              (32u)
N#define CapSense_BUTTON3_SNS_CLK                (8u)
N#define CapSense_BUTTON3_SNS_CLK_SOURCE         (0u)
N
N/*******************************************************************************
N* Button4 initialization values for FLASH data structure
N*******************************************************************************/
N#define CapSense_BUTTON4_STATIC_CONFIG          (10249u)
N#define CapSense_BUTTON4_NUM_SENSORS            (1u)
N
N/*******************************************************************************
N* Button4 initialization values for RAM data structure
N*******************************************************************************/
N#define CapSense_BUTTON4_RESOLUTION             (CapSense_RES11BIT)
N#define CapSense_BUTTON4_FINGER_TH              (100u)
N#define CapSense_BUTTON4_NOISE_TH               (20u)
N#define CapSense_BUTTON4_NNOISE_TH              (20u)
N#define CapSense_BUTTON4_HYSTERESIS             (10u)
N#define CapSense_BUTTON4_ON_DEBOUNCE            (3u)
N#define CapSense_BUTTON4_LOW_BSLN_RST           (30u)
N#define CapSense_BUTTON4_IDAC_MOD0              (32u)
N#define CapSense_BUTTON4_SNS_CLK                (8u)
N#define CapSense_BUTTON4_SNS_CLK_SOURCE         (0u)
N
N/*******************************************************************************
N* Button5 initialization values for FLASH data structure
N*******************************************************************************/
N#define CapSense_BUTTON5_STATIC_CONFIG          (10249u)
N#define CapSense_BUTTON5_NUM_SENSORS            (1u)
N
N/*******************************************************************************
N* Button5 initialization values for RAM data structure
N*******************************************************************************/
N#define CapSense_BUTTON5_RESOLUTION             (CapSense_RES11BIT)
N#define CapSense_BUTTON5_FINGER_TH              (100u)
N#define CapSense_BUTTON5_NOISE_TH               (20u)
N#define CapSense_BUTTON5_NNOISE_TH              (20u)
N#define CapSense_BUTTON5_HYSTERESIS             (10u)
N#define CapSense_BUTTON5_ON_DEBOUNCE            (3u)
N#define CapSense_BUTTON5_LOW_BSLN_RST           (30u)
N#define CapSense_BUTTON5_IDAC_MOD0              (32u)
N#define CapSense_BUTTON5_SNS_CLK                (8u)
N#define CapSense_BUTTON5_SNS_CLK_SOURCE         (0u)
N
N/*******************************************************************************
N* Button6 initialization values for FLASH data structure
N*******************************************************************************/
N#define CapSense_BUTTON6_STATIC_CONFIG          (10249u)
N#define CapSense_BUTTON6_NUM_SENSORS            (1u)
N
N/*******************************************************************************
N* Button6 initialization values for RAM data structure
N*******************************************************************************/
N#define CapSense_BUTTON6_RESOLUTION             (CapSense_RES11BIT)
N#define CapSense_BUTTON6_FINGER_TH              (100u)
N#define CapSense_BUTTON6_NOISE_TH               (20u)
N#define CapSense_BUTTON6_NNOISE_TH              (20u)
N#define CapSense_BUTTON6_HYSTERESIS             (10u)
N#define CapSense_BUTTON6_ON_DEBOUNCE            (3u)
N#define CapSense_BUTTON6_LOW_BSLN_RST           (30u)
N#define CapSense_BUTTON6_IDAC_MOD0              (32u)
N#define CapSense_BUTTON6_SNS_CLK                (8u)
N#define CapSense_BUTTON6_SNS_CLK_SOURCE         (0u)
N
N/*******************************************************************************
N* Button7 initialization values for FLASH data structure
N*******************************************************************************/
N#define CapSense_BUTTON7_STATIC_CONFIG          (10249u)
N#define CapSense_BUTTON7_NUM_SENSORS            (1u)
N
N/*******************************************************************************
N* Button7 initialization values for RAM data structure
N*******************************************************************************/
N#define CapSense_BUTTON7_RESOLUTION             (CapSense_RES11BIT)
N#define CapSense_BUTTON7_FINGER_TH              (100u)
N#define CapSense_BUTTON7_NOISE_TH               (20u)
N#define CapSense_BUTTON7_NNOISE_TH              (20u)
N#define CapSense_BUTTON7_HYSTERESIS             (10u)
N#define CapSense_BUTTON7_ON_DEBOUNCE            (3u)
N#define CapSense_BUTTON7_LOW_BSLN_RST           (30u)
N#define CapSense_BUTTON7_IDAC_MOD0              (32u)
N#define CapSense_BUTTON7_SNS_CLK                (8u)
N#define CapSense_BUTTON7_SNS_CLK_SOURCE         (0u)
N
N/*******************************************************************************
N* Button8 initialization values for FLASH data structure
N*******************************************************************************/
N#define CapSense_BUTTON8_STATIC_CONFIG          (10249u)
N#define CapSense_BUTTON8_NUM_SENSORS            (1u)
N
N/*******************************************************************************
N* Button8 initialization values for RAM data structure
N*******************************************************************************/
N#define CapSense_BUTTON8_RESOLUTION             (CapSense_RES11BIT)
N#define CapSense_BUTTON8_FINGER_TH              (100u)
N#define CapSense_BUTTON8_NOISE_TH               (20u)
N#define CapSense_BUTTON8_NNOISE_TH              (20u)
N#define CapSense_BUTTON8_HYSTERESIS             (10u)
N#define CapSense_BUTTON8_ON_DEBOUNCE            (3u)
N#define CapSense_BUTTON8_LOW_BSLN_RST           (30u)
N#define CapSense_BUTTON8_IDAC_MOD0              (32u)
N#define CapSense_BUTTON8_SNS_CLK                (8u)
N#define CapSense_BUTTON8_SNS_CLK_SOURCE         (0u)
N
N/*******************************************************************************
N* Button9 initialization values for FLASH data structure
N*******************************************************************************/
N#define CapSense_BUTTON9_STATIC_CONFIG          (10249u)
N#define CapSense_BUTTON9_NUM_SENSORS            (1u)
N
N/*******************************************************************************
N* Button9 initialization values for RAM data structure
N*******************************************************************************/
N#define CapSense_BUTTON9_RESOLUTION             (CapSense_RES11BIT)
N#define CapSense_BUTTON9_FINGER_TH              (100u)
N#define CapSense_BUTTON9_NOISE_TH               (20u)
N#define CapSense_BUTTON9_NNOISE_TH              (20u)
N#define CapSense_BUTTON9_HYSTERESIS             (10u)
N#define CapSense_BUTTON9_ON_DEBOUNCE            (3u)
N#define CapSense_BUTTON9_LOW_BSLN_RST           (30u)
N#define CapSense_BUTTON9_IDAC_MOD0              (32u)
N#define CapSense_BUTTON9_SNS_CLK                (8u)
N#define CapSense_BUTTON9_SNS_CLK_SOURCE         (0u)
N
N/*******************************************************************************
N* Button10 initialization values for FLASH data structure
N*******************************************************************************/
N#define CapSense_BUTTON10_STATIC_CONFIG         (10249u)
N#define CapSense_BUTTON10_NUM_SENSORS           (1u)
N
N/*******************************************************************************
N* Button10 initialization values for RAM data structure
N*******************************************************************************/
N#define CapSense_BUTTON10_RESOLUTION            (CapSense_RES11BIT)
N#define CapSense_BUTTON10_FINGER_TH             (100u)
N#define CapSense_BUTTON10_NOISE_TH              (20u)
N#define CapSense_BUTTON10_NNOISE_TH             (20u)
N#define CapSense_BUTTON10_HYSTERESIS            (10u)
N#define CapSense_BUTTON10_ON_DEBOUNCE           (3u)
N#define CapSense_BUTTON10_LOW_BSLN_RST          (30u)
N#define CapSense_BUTTON10_IDAC_MOD0             (32u)
N#define CapSense_BUTTON10_SNS_CLK               (8u)
N#define CapSense_BUTTON10_SNS_CLK_SOURCE        (0u)
N
N/*******************************************************************************
N* Button11 initialization values for FLASH data structure
N*******************************************************************************/
N#define CapSense_BUTTON11_STATIC_CONFIG         (10249u)
N#define CapSense_BUTTON11_NUM_SENSORS           (1u)
N
N/*******************************************************************************
N* Button11 initialization values for RAM data structure
N*******************************************************************************/
N#define CapSense_BUTTON11_RESOLUTION            (CapSense_RES11BIT)
N#define CapSense_BUTTON11_FINGER_TH             (100u)
N#define CapSense_BUTTON11_NOISE_TH              (20u)
N#define CapSense_BUTTON11_NNOISE_TH             (20u)
N#define CapSense_BUTTON11_HYSTERESIS            (10u)
N#define CapSense_BUTTON11_ON_DEBOUNCE           (3u)
N#define CapSense_BUTTON11_LOW_BSLN_RST          (30u)
N#define CapSense_BUTTON11_IDAC_MOD0             (32u)
N#define CapSense_BUTTON11_SNS_CLK               (8u)
N#define CapSense_BUTTON11_SNS_CLK_SOURCE        (0u)
N
N/*******************************************************************************
N* Proximity0 initialization values for FLASH data structure
N*******************************************************************************/
N#define CapSense_PROXIMITY0_STATIC_CONFIG       (10245u)
N#define CapSense_PROXIMITY0_NUM_SENSORS         (1u)
N
N/*******************************************************************************
N* Proximity0 initialization values for RAM data structure
N*******************************************************************************/
N#define CapSense_PROXIMITY0_RESOLUTION          (CapSense_RES12BIT)
N#define CapSense_PROXIMITY0_FINGER_TH           (40u)
N#define CapSense_PROXIMITY0_NOISE_TH            (20u)
N#define CapSense_PROXIMITY0_NNOISE_TH           (20u)
N#define CapSense_PROXIMITY0_HYSTERESIS          (10u)
N#define CapSense_PROXIMITY0_ON_DEBOUNCE         (1u)
N#define CapSense_PROXIMITY0_LOW_BSLN_RST        (30u)
N#define CapSense_PROXIMITY0_IDAC_MOD0           (32u)
N#define CapSense_PROXIMITY0_SNS_CLK             (64u)
N#define CapSense_PROXIMITY0_SNS_CLK_SOURCE      (0u)
N#define CapSense_PROXIMITY0_PROX_TOUCH_TH       (60u)
N
N/* RAM Sensor Parameters Definitions */
N#define CapSense_BUTTON0_SNS0_IDAC_COMP0        (32u)
N#define CapSense_BUTTON1_SNS0_IDAC_COMP0        (32u)
N#define CapSense_BUTTON2_SNS0_IDAC_COMP0        (32u)
N#define CapSense_BUTTON3_SNS0_IDAC_COMP0        (32u)
N#define CapSense_BUTTON4_SNS0_IDAC_COMP0        (32u)
N#define CapSense_BUTTON5_SNS0_IDAC_COMP0        (32u)
N#define CapSense_BUTTON6_SNS0_IDAC_COMP0        (32u)
N#define CapSense_BUTTON7_SNS0_IDAC_COMP0        (32u)
N#define CapSense_BUTTON8_SNS0_IDAC_COMP0        (32u)
N#define CapSense_BUTTON9_SNS0_IDAC_COMP0        (32u)
N#define CapSense_BUTTON10_SNS0_IDAC_COMP0       (32u)
N#define CapSense_BUTTON11_SNS0_IDAC_COMP0       (32u)
N#define CapSense_PROXIMITY0_SNS0_IDAC_COMP0     (32u)
N
N
N
N/*******************************************************************************
N* ADC Specific Macros
N*******************************************************************************/
N#define CapSense_ADC_RES8BIT                  (8u)
N#define CapSense_ADC_RES10BIT                 (10u)
N
N#define CapSense_ADC_FULLRANGE_MODE           (0u)
N#define CapSense_ADC_VREF_MODE                (1u)
N
N#define CapSense_ADC_MIN_CHANNELS             (1u)
N#define CapSense_ADC_EN                       (0u)
N#define CapSense_ADC_STANDALONE_EN            (0u)
N#define CapSense_ADC_TOTAL_CHANNELS           (1u)
N#define CapSense_ADC_RESOLUTION               (CapSense_ADC_RES10BIT)
N#define CapSense_ADC_AMUXB_INPUT_EN           (0u)
N#define CapSense_ADC_SELECT_AMUXB_CH          (0u)
N#define CapSense_ADC_AZ_EN                    (1Lu)
N#define CapSense_ADC_AZ_TIME                  (5u)
N#define CapSense_ADC_VREF_MV                  (2133u)
N#define CapSense_ADC_GAIN                     (17Lu)
N#define CapSense_ADC_IDAC_DEFAULT             (38u)
N#define CapSense_ADC_MODCLK_DIV_DEFAULT       (1u)
N#define CapSense_ADC_MEASURE_MODE             (CapSense_ADC_FULLRANGE_MODE)
N#define CapSense_ADC_ANALOG_STARTUP_DELAY_US  (5u)
N#define CapSense_ADC_ACQUISITION_TIME_US      (13u)
N
N/*******************************************************************************
N* Built-In Self-Test Configuration
N*******************************************************************************/
N#define CapSense_SELF_TEST_EN                   (0Lu)
N#define CapSense_TST_GLOBAL_CRC_EN              (0Lu)
N#define CapSense_TST_WDGT_CRC_EN                (0Lu)
N#define CapSense_TST_BSLN_DUPLICATION_EN        (0Lu)
N#define CapSense_TST_BSLN_RAW_OUT_RANGE_EN      (0Lu)
N#define CapSense_TST_SNS_SHORT_EN               (0Lu)
N#define CapSense_TST_SNS2SNS_SHORT_EN           (0Lu)
N#define CapSense_TST_SNS_CAP_EN                 (0Lu)
N#define CapSense_TST_SH_CAP_EN                  (0Lu)
N#define CapSense_TST_EXTERNAL_CAP_EN            (0Lu)
N#define CapSense_TST_INTERNAL_CAP_EN            (0Lu)
N#define CapSense_TST_VDDA_EN                    (0Lu)
N#define CapSense_TST_FINE_INIT_TIME             (10Lu)
N
N
N#define CapSense_TST_ANALOG_STARTUP_DELAY_US    (23u)
N
N/*******************************************************************************
N* Gesture Configuration
N*******************************************************************************/
N#define CapSense_TIMESTAMP_INTERVAL             (1Lu)
N#define CapSense_GESTURE_EN_WIDGET_ID           (0Lu)
N#define CapSense_BALLISTIC_EN_WIDGET_ID         (0Lu)
N
N
N#endif /* CY_SENSE_CapSense_CONFIGURATION_H */
N
N
N/* [] END OF FILE */
L 44 "Generated_Source\PSoC4\CapSense.h" 2
N#include "CapSense_Control.h"
L 1 "Generated_Source\PSoC4\CapSense_Control.h" 1
N/***************************************************************************//**
N* \file CapSense_Control.h
N* \version 5.0
N*
N* \brief
N*   This file provides the function prototypes of the Control Block.
N*
N* \see CapSense v5.0 Datasheet
N*
N*//*****************************************************************************
N* Copyright (2016-2017), Cypress Semiconductor Corporation.
N********************************************************************************
N* This software is owned by Cypress Semiconductor Corporation (Cypress) and is
N* protected by and subject to worldwide patent protection (United States and
N* foreign), United States copyright laws and international treaty provisions.
N* Cypress hereby grants to licensee a personal, non-exclusive, non-transferable
N* license to copy, use, modify, create derivative works of, and compile the
N* Cypress Source Code and derivative works for the sole purpose of creating
N* custom software in support of licensee product to be used only in conjunction
N* with a Cypress integrated circuit as specified in the applicable agreement.
N* Any reproduction, modification, translation, compilation, or representation of
N* this software except as specified above is prohibited without the express
N* written permission of Cypress.
N*
N* Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH
N* REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
N* Cypress reserves the right to make changes without further notice to the
N* materials described herein. Cypress does not assume any liability arising out
N* of the application or use of any product or circuit described herein. Cypress
N* does not authorize its products for use as critical components in life-support
N* systems where a malfunction or failure may reasonably be expected to result in
N* significant injury to the user. The inclusion of Cypress' product in a life-
N* support systems application implies that the manufacturer assumes all risk of
N* such use and in doing so indemnifies Cypress against all charges. Use may be
N* limited by and subject to the applicable Cypress software license agreement.
N*******************************************************************************/
N
N#if !defined(CY_SENSE_CapSense_CONTROL_H)
X#if !0L
N#define CY_SENSE_CapSense_CONTROL_H
N
N#include "CapSense_Configuration.h"
N
N/*******************************************************************************
N* Function Prototypes
N*******************************************************************************/
N
N/*******************************************************************************
N* HIGH LEVEL API
N*******************************************************************************/
N
N/**
N* \cond ((SECTION_C_HIGH_LEVEL) || (SECTION_I_HIGH_LEVEL))
N*
N* \addtogroup group_c_high_level
N* \{
N*/
N
Ncystatus CapSense_Start(void);
Ncystatus CapSense_Stop(void);
Ncystatus CapSense_Resume(void);
N
Ncystatus CapSense_ProcessAllWidgets(void);
Ncystatus CapSense_ProcessWidget(uint32 widgetId);
N
Nvoid CapSense_Sleep(void);
Nvoid CapSense_Wakeup(void);
N
N/** \}
N* \endcond */
N
N/**
N* \cond (SECTION_C_LOW_LEVEL  || SECTION_I_LOW_LEVEL)
N* \addtogroup group_c_low_level
N* \{
N*/
N
Ncystatus CapSense_ProcessWidgetExt(uint32 widgetId, uint32 mode);
Ncystatus CapSense_ProcessSensorExt(uint32 widgetId, uint32 sensorId, uint32 mode);
N
N/** \}
N* \endcond */
N
N/*******************************************************************************
N* Function Prototypes - internal functions
N*******************************************************************************/
N
N/**
N* \cond SECTION_C_INTERNAL
N* \addtogroup group_c_internal
N* \{
N*/
Ncystatus CapSense_Initialize(void);
N
N/** \}
N* \endcond */
N
N#endif /* End CY_SENSE_CapSense_CONTROL_H */
N
N
N/* [] END OF FILE */
L 45 "Generated_Source\PSoC4\CapSense.h" 2
N#include "CapSense_Filter.h"
L 1 "Generated_Source\PSoC4\CapSense_Filter.h" 1
N/***************************************************************************//**
N* \file CapSense_Filter.h
N* \version 5.0
N*
N* \brief 
N*   This file contains the definitions for all firmware filters
N*   implementation.
N*
N* \see CapSense v5.0 Datasheet
N*
N*//*****************************************************************************
N* Copyright (2016-2017), Cypress Semiconductor Corporation.
N********************************************************************************
N* This software is owned by Cypress Semiconductor Corporation (Cypress) and is
N* protected by and subject to worldwide patent protection (United States and
N* foreign), United States copyright laws and international treaty provisions.
N* Cypress hereby grants to licensee a personal, non-exclusive, non-transferable
N* license to copy, use, modify, create derivative works of, and compile the
N* Cypress Source Code and derivative works for the sole purpose of creating
N* custom software in support of licensee product to be used only in conjunction
N* with a Cypress integrated circuit as specified in the applicable agreement.
N* Any reproduction, modification, translation, compilation, or representation of
N* this software except as specified above is prohibited without the express
N* written permission of Cypress.
N*
N* Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH
N* REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
N* Cypress reserves the right to make changes without further notice to the
N* materials described herein. Cypress does not assume any liability arising out
N* of the application or use of any product or circuit described herein. Cypress
N* does not authorize its products for use as critical components in life-support
N* systems where a malfunction or failure may reasonably be expected to result in
N* significant injury to the user. The inclusion of Cypress' product in a life-
N* support systems application implies that the manufacturer assumes all risk of
N* such use and in doing so indemnifies Cypress against all charges. Use may be
N* limited by and subject to the applicable Cypress software license agreement.
N*******************************************************************************/
N
N#if !defined(CY_SENSE_CapSense_FILTER_H)
X#if !0L
N#define CY_SENSE_CapSense_FILTER_H
N
N#include "cytypes.h"
N#include "CyLib.h"
N#include "cyfitter.h"
N
N#include "CapSense_Structure.h"
L 1 "Generated_Source\PSoC4\CapSense_Structure.h" 1
N/***************************************************************************//**
N* \file CapSense_Structure.h
N* \version 5.0
N*
N* \brief
N*   This file provides the top level declarations of the Component data structure.
N*   Also, the file declares the high-level and low-level APIs for data access.
N*
N* \see CapSense v5.0 Datasheet
N*
N*//*****************************************************************************
N* Copyright (2016-2017), Cypress Semiconductor Corporation.
N********************************************************************************
N* This software is owned by Cypress Semiconductor Corporation (Cypress) and is
N* protected by and subject to worldwide patent protection (United States and
N* foreign), United States copyright laws and international treaty provisions.
N* Cypress hereby grants to licensee a personal, non-exclusive, non-transferable
N* license to copy, use, modify, create derivative works of, and compile the
N* Cypress Source Code and derivative works for the sole purpose of creating
N* custom software in support of licensee product to be used only in conjunction
N* with a Cypress integrated circuit as specified in the applicable agreement.
N* Any reproduction, modification, translation, compilation, or representation of
N* this software except as specified above is prohibited without the express
N* written permission of Cypress.
N*
N* Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH
N* REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
N* Cypress reserves the right to make changes without further notice to the
N* materials described herein. Cypress does not assume any liability arising out
N* of the application or use of any product or circuit described herein. Cypress
N* does not authorize its products for use as critical components in life-support
N* systems where a malfunction or failure may reasonably be expected to result in
N* significant injury to the user. The inclusion of Cypress' product in a life-
N* support systems application implies that the manufacturer assumes all risk of
N* such use and in doing so indemnifies Cypress against all charges. Use may be
N* limited by and subject to the applicable Cypress software license agreement.
N*******************************************************************************/
N
N#if !defined(CY_SENSE_CapSense_STRUCTURE_H)
X#if !0L
N#define CY_SENSE_CapSense_STRUCTURE_H
N
N#include <cytypes.h>
N#include "cyfitter.h"
N#include "CapSense_Configuration.h"
N#if (CapSense_CSD_SS_DIS != CapSense_CSD_AUTOTUNE)
X#if ((0x00ul) != (0x00ul))
S    #include "CapSense_SmartSense_LL.h"
N#endif
N
N#if (CapSense_ENABLE == CapSense_ALP_FILTER_EN)
X#if ((1u) == (0u))
S    #include "CapSense_AlpFilter_LL.h"
N#endif
N
N#if ((CapSense_ENABLE == CapSense_GES_GLOBAL_EN) ||\
N     (CapSense_ENABLE == CapSense_BALLISTIC_MULTIPLIER_EN))
X#if (((1u) == (0u)) ||     ((1u) == (0u)))
S    #include "CapSense_TMG.h"
N#endif
N
N#if (CapSense_ENABLE == CapSense_CENTROID_5X5_CSD_EN)
X#if ((1u) == (0u))
S    #include "CapSense_AdvancedCentroid_LL.h"
N#endif
N
N#if (CapSense_ENABLE == CapSense_POS_ADAPTIVE_IIR_FILTER_EN)
X#if ((1u) == (0u))
S    #include "CapSense_AdaptiveFilter_LL.h"
N#endif
N
N/*******************************************************************************
N* Constant Definitions
N*******************************************************************************/
N
N/* Defines size of Sensor Status Register in Data Structure */
N#define CapSense_SNS_STS_TYPE               uint8
N
N/* No touch condition for slider position report */
N#define CapSense_SLIDER_NO_TOUCH            (0xFFFFu)
N#define CapSense_TOUCHPAD_NO_TOUCH          (0xFFFFFFFFLu)
N
N#define CapSense_SLIDER_POS_NONE            (0xFFFFu)
N#define CapSense_TOUCHPAD_POS_NONE          (0xFFFFu)
N
N#define CapSense_MATRIX_POS_NONE            (0xFFu)
N#define CapSense_MATRIX_POS_MULTI           (0xFEu)
N
N#define CapSense_PROX_STS_MASK              (3Lu)
N#define CapSense_PROX_STS_OFFSET(proxId)    ((proxId) << 1u)
N
N#define CapSense_MATRIX_BUTTONS_TOUCHED     (0x80000000Lu)
N
N/*******************************************************************************
N* Enumeration types definition
N*******************************************************************************/
N
N/***************************************************************************//**
N* \brief Defines widget types
N*******************************************************************************/
Ntypedef enum
N{
N    CapSense_WD_BUTTON_E        = 0x01u,
N    CapSense_WD_LINEAR_SLIDER_E = 0x02u,
N    CapSense_WD_RADIAL_SLIDER_E = 0x03u,
N    CapSense_WD_MATRIX_BUTTON_E = 0x04u,
N    CapSense_WD_TOUCHPAD_E      = 0x05u,
N    CapSense_WD_PROXIMITY_E     = 0x06u
N} CapSense_WD_TYPE_ENUM;
N
N
N/***************************************************************************//**
N* \brief Defines sensing methods types
N*******************************************************************************/
Ntypedef enum
N{
N    CapSense_UNDEFINED_E            = 0x00u,
N    CapSense_SENSE_METHOD_CSD_E     = 0x01u,
N    CapSense_SENSE_METHOD_CSX_E     = 0x02u,
N    CapSense_SENSE_METHOD_BIST_E    = 0x03u,
N    CapSense_SENSE_METHOD_ISX_E     = 0x04u,
N} CapSense_SENSE_METHOD_ENUM;
N
N/***************************************************************************//**
N* \brief Defines electrode types
N*******************************************************************************/
Ntypedef enum
N{
N    CapSense_ELTD_TYPE_SELF_E   = 0x01u,
N    CapSense_ELTD_TYPE_MUT_TX_E = 0x02u,
N    CapSense_ELTD_TYPE_MUT_RX_E = 0x03u
N} CapSense_ELTD_TYPE_ENUM;
N
N/**
N* \cond SECTION_STRUCTURES
N* \addtogroup group_structures
N* \{
N*/
N/*******************************************************************************
N* Declares RAM structures for all used widgets
N*******************************************************************************/
N
N/***************************************************************************//**
N* \brief Declares common widget RAM parameters
N*******************************************************************************/
Ntypedef struct
N{
N    /**
N     *  Provides scan resolution or number of sub-conversions.
N     */
N    uint16 resolution;
N
N    /**
N     *  Widget Finger Threshold.
N     */
N    CapSense_THRESHOLD_TYPE fingerTh;
N
N    /**
N     *  Widget Noise Threshold.
N     */
N    uint8  noiseTh;
N
N    /**
N     *  Widget Negative Noise Threshold.
N     */
N    uint8  nNoiseTh;
N
N    /**
N     *  Widget Hysteresis for the signal crossing finger or touch/proximity 
N     *  threshold.
N     */
N    uint8  hysteresis;
N
N    /**
N     *  Widget Debounce for the signal above the finger or touch/proximity 
N     *  threshold. OFF to ON.
N     */
N    uint8  onDebounce;
N
N    /**
N     *  The widget low baseline reset count. Specifies the number of 
N     *  samples the sensor has to be below the Negative Noise 
N     *  Threshold to trigger a baseline reset.
N     */
N    CapSense_LOW_BSLN_RST_TYPE lowBslnRst;
N
N    /**
N     *  Sets the current of the modulation IDAC for the widgets. 
N     *  For the CSD Touchpad and Matrix Button widgets, sets 
N     *  the current of the modulation IDAC for the column sensors.
N     */
N    uint8  idacMod [CapSense_NUM_SCAN_FREQS];
X    uint8  idacMod [(1u)];
N
N    /**
N     *  Specifies the sense clock divider. Present only if individual 
N     *  clock dividers are enabled. Specifies the sense clock divider 
N     *  for the Column sensors for the Matrix Buttons and Touchpad 
N     *  widgets. Sets Tx clock divider for CSX Widgets.
N     */
N    uint16 snsClk;
N
N    /**
N     *  Register for internal use
N     */
N    uint8  snsClkSource;
N} CapSense_RAM_WD_BASE_STRUCT;
N
N/***************************************************************************//**
N* \brief Declares RAM parameters for the CSD Button
N*******************************************************************************/
Ntypedef struct
N{
N    /**
N     *  Provides scan resolution or number of sub-conversions.
N     */
N    uint16 resolution;
N
N    /**
N     *  Widget Finger Threshold.
N     */
N    CapSense_THRESHOLD_TYPE fingerTh;
N
N    /**
N     *  Widget Noise Threshold.
N     */
N    uint8  noiseTh;
N
N    /**
N     *  Widget Negative Noise Threshold.
N     */
N    uint8  nNoiseTh;
N
N    /**
N     *  Widget Hysteresis for the signal crossing finger or touch/proximity 
N     *  threshold.
N     */
N    uint8  hysteresis;
N
N    /**
N     *  Widget Debounce for the signal above the finger or touch/proximity 
N     *  threshold. OFF to ON.
N     */
N    uint8  onDebounce;
N
N    /**
N     *  The widget low baseline reset count. Specifies the number of 
N     *  samples the sensor has to be below the Negative Noise 
N     *  Threshold to trigger a baseline reset.
N     */
N    CapSense_LOW_BSLN_RST_TYPE lowBslnRst;
N
N    /**
N     *  Sets the current of the modulation IDAC for the widgets. 
N     *  For the CSD Touchpad and Matrix Button widgets, sets 
N     *  the current of the modulation IDAC for the column sensors.
N     */
N    uint8  idacMod [CapSense_NUM_SCAN_FREQS];
X    uint8  idacMod [(1u)];
N
N    /**
N     *  Specifies the sense clock divider. Present only if individual 
N     *  clock dividers are enabled. Specifies the sense clock divider 
N     *  for the Column sensors for the Matrix Buttons and Touchpad 
N     *  widgets. Sets Tx clock divider for CSX Widgets.
N     */
N    uint16 snsClk;
N
N    /**
N     *  Register for internal use
N     */
N    uint8  snsClkSource;
N} CapSense_RAM_WD_BUTTON_STRUCT;
N
N/***************************************************************************//**
N* \brief Declares RAM parameters for the CSD Proximity
N*******************************************************************************/
Ntypedef struct
N{
N    /**
N     *  Provides scan resolution or number of sub-conversions.
N     */
N    uint16 resolution;
N
N    /**
N     *  Widget Finger Threshold.
N     */
N    CapSense_THRESHOLD_TYPE fingerTh;
N
N    /**
N     *  Widget Noise Threshold.
N     */
N    uint8  noiseTh;
N
N    /**
N     *  Widget Negative Noise Threshold.
N     */
N    uint8  nNoiseTh;
N
N    /**
N     *  Widget Hysteresis for the signal crossing finger or touch/proximity 
N     *  threshold.
N     */
N    uint8  hysteresis;
N
N    /**
N     *  Widget Debounce for the signal above the finger or touch/proximity 
N     *  threshold. OFF to ON.
N     */
N    uint8  onDebounce;
N
N    /**
N     *  The widget low baseline reset count. Specifies the number of 
N     *  samples the sensor has to be below the Negative Noise 
N     *  Threshold to trigger a baseline reset.
N     */
N    CapSense_LOW_BSLN_RST_TYPE lowBslnRst;
N
N    /**
N     *  Sets the current of the modulation IDAC for the widgets. 
N     *  For the CSD Touchpad and Matrix Button widgets, sets 
N     *  the current of the modulation IDAC for the column sensors.
N     */
N    uint8  idacMod [CapSense_NUM_SCAN_FREQS];
X    uint8  idacMod [(1u)];
N
N    /**
N     *  Specifies the sense clock divider. Present only if individual 
N     *  clock dividers are enabled. Specifies the sense clock divider 
N     *  for the Column sensors for the Matrix Buttons and Touchpad 
N     *  widgets. Sets Tx clock divider for CSX Widgets.
N     */
N    uint16 snsClk;
N
N    /**
N     *  Register for internal use
N     */
N    uint8  snsClkSource;
N
N    /**
N     *  The proximity touch threshold.
N     */
N    CapSense_THRESHOLD_TYPE proxTouchTh;
N} CapSense_RAM_WD_PROXIMITY_STRUCT;
N
N
N/***************************************************************************//**
N* \brief Declares RAM structure with all defined widgets
N*******************************************************************************/
Ntypedef struct
N{
N    /**
N     *  Button0 widget RAM structure
N     */
N    CapSense_RAM_WD_BUTTON_STRUCT    button0;
N
N    /**
N     *  Button1 widget RAM structure
N     */
N    CapSense_RAM_WD_BUTTON_STRUCT    button1;
N
N    /**
N     *  Button2 widget RAM structure
N     */
N    CapSense_RAM_WD_BUTTON_STRUCT    button2;
N
N    /**
N     *  Button3 widget RAM structure
N     */
N    CapSense_RAM_WD_BUTTON_STRUCT    button3;
N
N    /**
N     *  Button4 widget RAM structure
N     */
N    CapSense_RAM_WD_BUTTON_STRUCT    button4;
N
N    /**
N     *  Button5 widget RAM structure
N     */
N    CapSense_RAM_WD_BUTTON_STRUCT    button5;
N
N    /**
N     *  Button6 widget RAM structure
N     */
N    CapSense_RAM_WD_BUTTON_STRUCT    button6;
N
N    /**
N     *  Button7 widget RAM structure
N     */
N    CapSense_RAM_WD_BUTTON_STRUCT    button7;
N
N    /**
N     *  Button8 widget RAM structure
N     */
N    CapSense_RAM_WD_BUTTON_STRUCT    button8;
N
N    /**
N     *  Button9 widget RAM structure
N     */
N    CapSense_RAM_WD_BUTTON_STRUCT    button9;
N
N    /**
N     *  Button10 widget RAM structure
N     */
N    CapSense_RAM_WD_BUTTON_STRUCT    button10;
N
N    /**
N     *  Button11 widget RAM structure
N     */
N    CapSense_RAM_WD_BUTTON_STRUCT    button11;
N
N    /**
N     *  Proximity0 widget RAM structure
N     */
N    CapSense_RAM_WD_PROXIMITY_STRUCT proximity0;
N} CapSense_RAM_WD_LIST_STRUCT;
N
N
N/***************************************************************************//**
N* \brief Declares RAM structure for sensors
N*******************************************************************************/
Ntypedef struct
N{
N    /**
N     *  The sensor raw counts.
N     */
N    uint16 raw [CapSense_NUM_SCAN_FREQS];
X    uint16 raw [(1u)];
N
N    /**
N     *  The sensor baseline.
N     */
N    uint16 bsln [CapSense_NUM_SCAN_FREQS];
X    uint16 bsln [(1u)];
N
N    /**
N     *  For the bucket baseline algorithm holds the bucket state, 
N     *  For the IIR baseline keeps LSB of the baseline value.
N     */
N    uint8  bslnExt [CapSense_NUM_SCAN_FREQS];
X    uint8  bslnExt [(1u)];
N
N    /**
N     *  Sensor differences.
N     */
N    CapSense_THRESHOLD_TYPE diff;
N
N    /**
N     *  The baseline reset counter for the low baseline reset function.
N     */
N    CapSense_LOW_BSLN_RST_TYPE negBslnRstCnt [CapSense_NUM_SCAN_FREQS];
X    CapSense_LOW_BSLN_RST_TYPE negBslnRstCnt [(1u)];
N
N    /**
N     *  The compensation IDAC value or the balancing IDAC value.
N     */
N    uint8  idacComp [CapSense_NUM_SCAN_FREQS];
X    uint8  idacComp [(1u)];
N} CapSense_RAM_SNS_STRUCT;
N
N
N/***************************************************************************//**
N* \brief Declares RAM structure with all defined sensors
N*******************************************************************************/
Ntypedef struct
N{
N    /**
N     *  Button0 sensors RAM structures array
N     */
N    CapSense_RAM_SNS_STRUCT button0    [CapSense_BUTTON0_NUM_SENSORS];
X    CapSense_RAM_SNS_STRUCT button0    [(1u)];
N
N    /**
N     *  Button1 sensors RAM structures array
N     */
N    CapSense_RAM_SNS_STRUCT button1    [CapSense_BUTTON1_NUM_SENSORS];
X    CapSense_RAM_SNS_STRUCT button1    [(1u)];
N
N    /**
N     *  Button2 sensors RAM structures array
N     */
N    CapSense_RAM_SNS_STRUCT button2    [CapSense_BUTTON2_NUM_SENSORS];
X    CapSense_RAM_SNS_STRUCT button2    [(1u)];
N
N    /**
N     *  Button3 sensors RAM structures array
N     */
N    CapSense_RAM_SNS_STRUCT button3    [CapSense_BUTTON3_NUM_SENSORS];
X    CapSense_RAM_SNS_STRUCT button3    [(1u)];
N
N    /**
N     *  Button4 sensors RAM structures array
N     */
N    CapSense_RAM_SNS_STRUCT button4    [CapSense_BUTTON4_NUM_SENSORS];
X    CapSense_RAM_SNS_STRUCT button4    [(1u)];
N
N    /**
N     *  Button5 sensors RAM structures array
N     */
N    CapSense_RAM_SNS_STRUCT button5    [CapSense_BUTTON5_NUM_SENSORS];
X    CapSense_RAM_SNS_STRUCT button5    [(1u)];
N
N    /**
N     *  Button6 sensors RAM structures array
N     */
N    CapSense_RAM_SNS_STRUCT button6    [CapSense_BUTTON6_NUM_SENSORS];
X    CapSense_RAM_SNS_STRUCT button6    [(1u)];
N
N    /**
N     *  Button7 sensors RAM structures array
N     */
N    CapSense_RAM_SNS_STRUCT button7    [CapSense_BUTTON7_NUM_SENSORS];
X    CapSense_RAM_SNS_STRUCT button7    [(1u)];
N
N    /**
N     *  Button8 sensors RAM structures array
N     */
N    CapSense_RAM_SNS_STRUCT button8    [CapSense_BUTTON8_NUM_SENSORS];
X    CapSense_RAM_SNS_STRUCT button8    [(1u)];
N
N    /**
N     *  Button9 sensors RAM structures array
N     */
N    CapSense_RAM_SNS_STRUCT button9    [CapSense_BUTTON9_NUM_SENSORS];
X    CapSense_RAM_SNS_STRUCT button9    [(1u)];
N
N    /**
N     *  Button10 sensors RAM structures array
N     */
N    CapSense_RAM_SNS_STRUCT button10   [CapSense_BUTTON10_NUM_SENSORS];
X    CapSense_RAM_SNS_STRUCT button10   [(1u)];
N
N    /**
N     *  Button11 sensors RAM structures array
N     */
N    CapSense_RAM_SNS_STRUCT button11   [CapSense_BUTTON11_NUM_SENSORS];
X    CapSense_RAM_SNS_STRUCT button11   [(1u)];
N
N    /**
N     *  Proximity0 sensors RAM structures array
N     */
N    CapSense_RAM_SNS_STRUCT proximity0 [CapSense_PROXIMITY0_NUM_SENSORS];
X    CapSense_RAM_SNS_STRUCT proximity0 [(1u)];
N} CapSense_RAM_SNS_LIST_STRUCT;
N
N
N/***************************************************************************//**
N* \brief Declares the top-level RAM Data Structure
N*******************************************************************************/
Ntypedef struct
N{
N    /**
N     *  16-bit CRC calculated by the customizer for the component 
N     *  configuration. Used by the Tuner application to identify if 
N     *  the FW corresponds to the specific user configuration.
N     */
N    uint16 configId;
N
N    /**
N     *  Used by the Tuner application to identify device-specific configuration.
N     */
N    uint16 deviceId;
N
N    /**
N     *  Used by the Tuner application to identify the system clock frequency.
N     */
N    uint16 hwClock;
N
N    /**
N     *  Tuner Command Register. Used for the communication 
N     *  between the Tuner GUI and the component.
N     */
N    uint16 tunerCmd;
N
N    /**
N     *  This counter gets incremented after each scan.
N     */
N    uint16 scanCounter;
N
N    /**
N     *  Status information: Current Widget, Scan active, Error code.
N     */
N    volatile uint32 status;
N
N    /**
N     *  The bitmask that sets which Widgets are enabled and 
N     *  scanned, each bit corresponds to one widget.
N     */
N    uint32 wdgtEnable [CapSense_WDGT_STATUS_WORDS];
X    uint32 wdgtEnable [(((uint8)(((13u) - 1u) / 32u)) + 1u)];
N
N    /**
N     *  The bitmask that reports activated Widgets (widgets that 
N     *  detect a touch signal above the threshold), each bit 
N     *  corresponds to one widget.
N     */
N    uint32 wdgtStatus [CapSense_WDGT_STATUS_WORDS];
X    uint32 wdgtStatus [(((uint8)(((13u) - 1u) / 32u)) + 1u)];
N
N    /**
N     *  For Buttons, Sliders, Matrix Buttons and CSD Touchpad each bit 
N     *  reports status of the individual sensor of the widget: 1 - active 
N     *  (above the finger threshold); 0 - inactive; For the CSD Touchpad 
N     *  and CSD Matrix Buttons, the column sensors occupy the least 
N     *  significant bits. For the Proximity widget, each sensor uses two 
N     *  bits with the following meaning: 00 - Not active; 01 - Proximity 
N     *  detected (signal above finger threshold); 11 - A finger touch 
N     *  detected (signal above the touch threshold); For the CSX Touchpad 
N     *  Widget, this register provides a number of the detected touches. 
N     *  The array size is equal to the total number of widgets. The size of 
N     *  the array element depends on the max number of sensors per 
N     *  widget used in the current design. It could be 1, 2 or 4 bytes.
N     */
N    CapSense_SNS_STS_TYPE snsStatus [CapSense_TOTAL_WIDGETS];
X    uint8 snsStatus [(13u)];
N
N    /**
N     *  The configuration register for global parameters of the 
N     *  SENSE_HW0 block.
N     */
N    uint16 csd0Config;
N
N    /**
N     *  The modulator clock divider for the CSD widgets.
N     */
N    uint8  modCsdClk;
N
N    /**
N     *  RAM Widget Objects.
N     */
N    CapSense_RAM_WD_LIST_STRUCT wdgtList;
N
N    /**
N     *  RAM Sensor Objects.
N     */
N    CapSense_RAM_SNS_LIST_STRUCT snsList;
N
N    /**
N     *  The selected widget ID.
N     */
N    uint8  snrTestWidgetId;
N
N    /**
N     *  The selected sensor ID.
N     */
N    uint8  snrTestSensorId;
N
N    /**
N     *  The scan counter.
N     */
N    uint16 snrTestScanCounter;
N
N    /**
N     *  The sensor raw counts.
N     */
N    uint16 snrTestRawCount [CapSense_NUM_SCAN_FREQS];
X    uint16 snrTestRawCount [(1u)];
N} CapSense_RAM_STRUCT;
N
N
N/***************************************************************************//**
N* \brief Declares the Flash IO object
N*******************************************************************************/
Ntypedef struct
N{
N    /**
N     *  Pointer to the HSIOM configuration register of the IO.
N     */
N    reg32  * hsiomPtr;
N
N    /**
N     *  Pointer to the port configuration register of the IO.
N     */
N    reg32  * pcPtr;
N
N    /**
N     *  Pointer to the port data register of the IO.
N     */
N    reg32  * drPtr;
N
N    /**
N     *  Pointer to the pin state data register of the IO.
N     */
N    reg32  * psPtr;
N
N    /**
N     *  IO mask in the HSIOM configuration register.
N     */
N    uint32   hsiomMask;
N
N    /**
N     *  IO mask in the DR and PS registers.
N     */
N    uint32   mask;
N
N    /**
N     *  Position of the IO configuration bits in the HSIOM register.
N     */
N    uint8    hsiomShift;
N
N    /**
N     *  Position of the IO configuration bits in the DR and PS registers.
N     */
N    uint8    drShift;
N
N    /**
N     *  Position of the IO configuration bits in the PC register.
N     */
N    uint8    shift;
N} CapSense_FLASH_IO_STRUCT;
N
N
N/***************************************************************************//**
N* \brief Declares the Flash Electrode object
N*******************************************************************************/
Ntypedef struct
N{
N    /**
N     *  Index of the first IO in the Flash IO Object Array.
N     */
N    uint16 firstPinId;
N
N    /**
N     *  Total number of IOs in this sensor.
N     */
N    uint8  numPins;
N
N    /**
N     * Sensor type:
N     * \if SECTION_C_DS
N     * - ELTD_TYPE_SELF_E - CSD sensor;
N     * - ELTD_TYPE_MUT_TX_E - CSX Tx;
N     * - ELTD_TYPE_MUT_RX_E - CSX Rx;
N     * \endif
N     * \if SECTION_I_DS
N     * - ELTD_TYPE_MUT_TX_E - ISX Lx sensor;
N     * - ELTD_TYPE_MUT_RX_E - ISX Rx sensor;
N     * \endif
N     */
N    uint8  type;
N} CapSense_FLASH_SNS_STRUCT;
N
N
N/***************************************************************************//**
N* \brief Declares the structure with all Flash electrode objects
N*******************************************************************************/
Ntypedef struct
N{
N    /**
N     *  Proximity0 FLASH electrodes array
N     */
N    CapSense_FLASH_SNS_STRUCT proximity0    [CapSense_PROXIMITY0_NUM_SENSORS];
X    CapSense_FLASH_SNS_STRUCT proximity0    [(1u)];
N} CapSense_FLASH_SNS_LIST_STRUCT;
N
N
N
N
N/***************************************************************************//**
N* \brief Declares Flash widget object
N*******************************************************************************/
Ntypedef struct
N{
N    /**
N     *  Points to the array of the FLASH Sensor Objects or FLASH IO 
N     *  Objects that belong to this widget. Sensing block uses this 
N     *  pointer to access and configure IOs for the scanning. Bit #2 in 
N     *  WD_STATIC_CONFIG field indicates the type of array: 
N     *  1 - Sensor Object; 0 - IO Object.
N     */
N    void const * ptr2SnsFlash;
N
N    /**
N     *  Points to the Widget Object in RAM. Sensing block uses it to 
N     *  access scan parameters. Processing uses it to access threshold 
N     *  and widget specific data.
N     */
N    void * ptr2WdgtRam;
N
N    /**
N     *  Points to the array of Sensor Objects in RAM. The sensing and 
N     *  processing blocks use it to access the scan data.
N     */
N    CapSense_RAM_SNS_STRUCT * ptr2SnsRam;
N
N    /**
N     *  Points to the array of the Filter History Objects in RAM that 
N     *  belongs to this widget.
N     */
N    void * ptr2FltrHistory;
N
N    /**
N     *  Points to the array of the debounce counters. The size of the 
N     *  debounce counter is 8 bits. These arrays are not part of the 
N     *  data structure.
N     */
N    uint8 * ptr2DebounceArr;
N
N    /**
N     *  Miscellaneous configuration flags.
N     */
N    uint32 staticConfig;
N
N    /**
N     *  The total number of sensors. 
N     *  For CSD widgets: WD_NUM_ROWS + WD_NUM_COLS. 
N     *  For CSX widgets: WD_NUM_ROWS * WD_NUM_COLS.
N     */
N    uint16 totalNumSns;
N
N    /**
N     *  Specifies one of the following widget types: 
N     *  WD_BUTTON_E, WD_LINEAR_SLIDER_E, WD_RADIAL_SLIDER_E, 
N     *  WD_MATRIX_BUTTON_E, WD_TOUCHPAD_E, WD_PROXIMITY_E
N     */
N    uint8  wdgtType;
N
N    /**
N     *  For CSD Button and Proximity Widgets, the number of sensors. 
N     *  For CSD Slider Widget, the number of segments. 
N     *  For CSD Touchpad and Matrix Button, the number of the 
N     *  column sensors. 
N     *  For CSX Button, Touchpad and Matrix Button, the number 
N     *  of the Rx electrodes.
N     */
N    uint8  numCols;
N} CapSense_FLASH_WD_STRUCT;
N
N
N/***************************************************************************//**
N* \brief Declares top-level Flash Data Structure
N*******************************************************************************/
Ntypedef struct
N{
N    /**
N     *  Array of flash widget objects
N     */
N    CapSense_FLASH_WD_STRUCT wdgtArray[CapSense_TOTAL_WIDGETS];
X    CapSense_FLASH_WD_STRUCT wdgtArray[(13u)];
N
N    /**
N     *  Structure with all Ganged Flash electrode objects
N     */
N    CapSense_FLASH_SNS_LIST_STRUCT eltdList;
N} CapSense_FLASH_STRUCT;
N
N
N#if (CapSense_ENABLE == CapSense_TST_BSLN_RAW_OUT_RANGE_EN)
X#if ((1u) == (0Lu))
S    /***************************************************************************//**
S    * \brief Defines the structure for test of baseline and raw count limits which
S    * will be determined by user for every sensor grounding on the
S    * manufacturing specific data
S    *******************************************************************************/
S    typedef struct
S    {
S        /**
S         *  Upper limit of a sensor baseline.
S         */
S        uint16 bslnHiLim;
S        /**
S         *  Lower limit of a sensor baseline.
S         */
S        uint16 bslnLoLim;
S        /**
S         *  Upper limit of a sensor raw count.
S         */
S        uint16 rawHiLim;
S        /**
S         *  Lower limit of a sensor raw count.
S         */
S        uint16 rawLoLim;
S    } CapSense_BSLN_RAW_RANGE_STRUCT;
N#endif /* (CapSense_ENABLE == CapSense_TST_BSLN_RAW_OUT_RANGE_EN) */
N
N/** \}
N* \endcond */
N
N
N/***************************************************************************//**
N* Declares Dual-channel scan structure
N*******************************************************************************/
Ntypedef struct
N{
N    uint8 csd0WidgetId;
N    uint8 csd0SensorId;
N    uint8 csd1WidgetId;
N    uint8 csd1SensorId;
N} CapSense_SCAN_SLOT_STRUCT;
N
N
N/***************************************************************************//**
N* Declares Filter module structures
N*******************************************************************************/
N
N/***************************************************************************//**
N* \brief Declares filter channel structure for regular sensors
N*******************************************************************************/
Ntypedef struct
N{
N    uint16 notUsed;
N} CapSense_REGULAR_FLTR_CHANNEL_STRUCT;
N
N/***************************************************************************//**
N* \brief Declares filter channel structure for proximity sensors
N*******************************************************************************/
Ntypedef struct
N{
N    uint16 notUsed;
N} CapSense_PROX_FLTR_CHANNEL_STRUCT;
N
N/***************************************************************************//**
N* \brief Declares filter structure for regular sensors
N*******************************************************************************/
Ntypedef struct
N{
N    /**
N     *  Array of CapSense_REGULAR_FLTR_CHANNEL_STRUCT for each available scan frequency
N     */
N    CapSense_REGULAR_FLTR_CHANNEL_STRUCT regularChannel[CapSense_NUM_SCAN_FREQS];
X    CapSense_REGULAR_FLTR_CHANNEL_STRUCT regularChannel[(1u)];
N} CapSense_REGULAR_FLTR_STRUCT;
N
N/***************************************************************************//**
N* \brief Declares filter structure for proximity sensors
N*******************************************************************************/
Ntypedef struct
N{
N    /**
N    *  Array of CapSense_PROX_FLTR_CHANNEL_STRUCT for each available scan frequency
N    */
N    CapSense_PROX_FLTR_CHANNEL_STRUCT proxChannel[CapSense_NUM_SCAN_FREQS];
X    CapSense_PROX_FLTR_CHANNEL_STRUCT proxChannel[(1u)];
N} CapSense_PROX_FLTR_STRUCT;
N
N
N/***************************************************************************//**
N* \brief Declares union for filter structure variants
N*******************************************************************************/
Ntypedef union
N{
N    /**
N     *  Pointer to void type
N     */
N    void *ptr;
N
N    /**
N     *  Pointer to CapSense_REGULAR_FLTR_STRUCT type
N     */
N    CapSense_REGULAR_FLTR_STRUCT *ptrRegular;
N
N    /**
N     *  Pointer to CapSense_PROX_FLTR_STRUCT type
N     */
N    CapSense_PROX_FLTR_STRUCT *ptrProx;
N} CapSense_PTR_FILTER_VARIANT;
N
N
N#if (0u != CapSense_POSITION_FILTER_EN)
X#if (0u != (0u))
Stypedef struct
S{
S    #if (0u != CapSense_POS_MEDIAN_FILTER_EN)
S        uint16 posMedianZ1;
S        uint16 posMedianZ2;
S    #endif /* #if (0u != CapSense_POS_MEDIAN_FILTER_EN) */
S
S    #if (0u != CapSense_POS_IIR_FILTER_EN)
S        uint16 posIIR;
S    #endif /* #if (0u != CapSense_POS_IIR_FILTER_EN) */
S
S    #if (0u != CapSense_POS_ADAPTIVE_IIR_FILTER_EN)
S        uint16 posAIIR;
S    #endif /* (0u != CapSense_POS_ADAPTIVE_IIR_FILTER_EN) */
S
S    #if (0u != CapSense_POS_AVERAGE_FILTER_EN)
S        uint16 posAverage;
S    #endif /* #if (0u != CapSense_POS_AVERAGE_FILTER_EN) */
S
S    #if (0u != CapSense_POS_JITTER_FILTER_EN)
S        uint16 posJitter;
S    #endif /* #if (0u != CapSense_POS_JITTER_FILTER_EN) */
S
S    #if (0u != CapSense_POS_ADAPTIVE_IIR_FILTER_EN)
S        uint8 posAIIRCoeff;
S    #endif /* (0u != CapSense_POS_ADAPTIVE_IIR_FILTER_EN) */
S} CapSense_SLIDER_POS_HISTORY_STRUCT;
S
Stypedef struct
S{
S    CapSense_SLIDER_POS_HISTORY_STRUCT xPos;
S    CapSense_SLIDER_POS_HISTORY_STRUCT yPos;
S} CapSense_TOUCHPAD_POS_HISTORY_STRUCT;
N#endif /* (0u != CapSense_POSITION_FILTER_EN) */
N
N/*******************************************************************************
N* API Constants
N*******************************************************************************/
N
N/*******************************************************************************
N* Defines shift/mask values for data structure register bit fields
N*******************************************************************************/
N
N/* CSD0_CONFIG bit fields */
N
N/* Bit 0: The multi-frequency scan enable/disable at runtime. This bit 
N * is functional only if the multi-frequency scan functionality 
N * has been activated in general component configuration. */
N#define CapSense_MULTI_FREQ_EN_SIZE       (0x00000001Lu)
N#define CapSense_MULTI_FREQ_EN_SHIFT      (0u)
N#define CapSense_MULTI_FREQ_EN_MASK       (CapSense_MULTI_FREQ_EN_SIZE << CapSense_MULTI_FREQ_EN_SHIFT)
N
N/* Bit 1: The sensor auto-reset is enabled */
N#define CapSense_SNS_ARST_SIZE            (0x00000001Lu)
N#define CapSense_SNS_ARST_SHIFT           (1u)
N#define CapSense_SNS_ARST_MASK            (CapSense_SNS_ARST_SIZE << CapSense_SNS_ARST_SHIFT)
N
N/* Bits 2-3: The IDAC range setting (4x/8x) */
N#define CapSense_IDAC_RANGE_SIZE          (0x00000003Lu)
N#define CapSense_IDAC_RANGE_SHIFT         (2u)
N#define CapSense_IDAC_RANGE_MASK          (CapSense_IDAC_RANGE_SIZE << CapSense_IDAC_RANGE_SHIFT)
N
N/* Bits 4-7: Reserved */
N
N/* Bit 8: The shield electrode signal Enable/Disable */
N#define CapSense_SHLD_EN_SIZE             (0x00000001Lu)
N#define CapSense_SHLD_EN_SHIFT            (8u)
N#define CapSense_SHLD_EN_MASK             (CapSense_SHLD_EN_SIZE << CapSense_SHLD_EN_SHIFT)
N
N/* Bits 9-10: Selects the delay by which the csd_shield is delayed relative 
N * to csd_sense */
N#define CapSense_SHLD_DLY_SIZE            (0x00000003Lu)
N#define CapSense_SHLD_DLY_SHIFT           (9u)
N#define CapSense_SHLD_DLY_MASK            (CapSense_SHLD_DLY_SIZE << CapSense_SHLD_DLY_SHIFT)
N
N
N/* STATUS bit fields */
N
N/* Bits 0-6: The widget currently selected for SENSE_HW 0 */
N#define CapSense_STATUS_WDGT0_SIZE        (0x0000007FLu)
N#define CapSense_STATUS_WDGT0_SHIFT       (0u)
N#define CapSense_STATUS_WDGT0_MASK        (CapSense_STATUS_WDGT0_SIZE << CapSense_STATUS_WDGT0_SHIFT)
N
N/* Bit 7: The SENSE_HW0 block status */
N#define CapSense_STATUS_CSD0_SIZE         (0x00000001Lu)
N#define CapSense_STATUS_CSD0_SHIFT        (7u)
N#define CapSense_STATUS_CSD0_MASK         (CapSense_STATUS_CSD0_SIZE << CapSense_STATUS_CSD0_SHIFT)
N
N/* Bits 8-14: The widget currently selected for SENSE_HW1 */
N#define CapSense_STATUS_WDGT1_SIZE        (0x0000007FLu)
N#define CapSense_STATUS_WDGT1_SHIFT       (8u)
N#define CapSense_STATUS_WDGT1_MASK        (CapSense_STATUS_WDGT1_SIZE << CapSense_STATUS_WDGT1_SHIFT)
N
N/* Bit 15: The SENSE_HW1 block status */
N#define CapSense_STATUS_CSD1_SIZE         (0x00000001Lu)
N#define CapSense_STATUS_CSD1_SHIFT        (15u)
N#define CapSense_STATUS_CSD1_MASK         (CapSense_STATUS_CSD1_SIZE << CapSense_STATUS_CSD1_SHIFT)
N
N/* Bit 16: The WIDGET BUSY flag status for SENSE_HW0 */
N#define CapSense_STATUS_WDGT0_BUSY_SIZE   (0x00000001Lu)
N#define CapSense_STATUS_WDGT0_BUSY_SHIFT  (16u)
N#define CapSense_STATUS_WDGT0_BUSY_MASK   (CapSense_STATUS_WDGT0_BUSY_SIZE << CapSense_STATUS_WDGT0_BUSY_SHIFT)
N
N/* Bit 17: The WIDGET BUSY flag status for SENSE_HW1 */
N#define CapSense_STATUS_WDGT1_BUSY_SIZE   (0x00000001Lu)
N#define CapSense_STATUS_WDGT1_BUSY_SHIFT  (17u)
N#define CapSense_STATUS_WDGT1_BUSY_MASK   (CapSense_STATUS_WDGT1_BUSY_SIZE << CapSense_STATUS_WDGT1_BUSY_SHIFT)
N
N/* Bits 18-23: Reserved */
N
N/* Bits 24-31: Component error code */
N#define CapSense_STATUS_ERR_SIZE          (0x000000FFLu)
N#define CapSense_STATUS_ERR_SHIFT         (24u)
N#define CapSense_STATUS_ERR_MASK          (CapSense_STATUS_ERR_SIZE << CapSense_STATUS_ERR_SHIFT)
N
N
N/* WD_STATIC_CONFIG bit fields */
N
N/* Bit 0: The sense/Tx frequency selection: 0 - Common, 1 - Individual 
N * (per widget). */
N#define CapSense_SNS_FREQ_SIZE            (0x00000001Lu)
N#define CapSense_SNS_FREQ_SHIFT           (0u)
N#define CapSense_SNS_FREQ_MASK            (CapSense_SNS_FREQ_SIZE << CapSense_SNS_FREQ_SHIFT)
N
N/* Bit 1: Duplexing Enable/Disable for linear sliders. */
N#define CapSense_DIPLEXING_SIZE           (0x00000001Lu)
N#define CapSense_DIPLEXING_SHIFT          (1u)
N#define CapSense_DIPLEXING_MASK           (CapSense_DIPLEXING_SIZE << CapSense_DIPLEXING_SHIFT)
N
N/* Bit 2: The widget contains a sensor ganged to other sensors. */
N#define CapSense_GANGED_SNS_SIZE          (0x00000001Lu)
N#define CapSense_GANGED_SNS_SHIFT         (2u)
N#define CapSense_GANGED_SNS_MASK          (CapSense_GANGED_SNS_SIZE << CapSense_GANGED_SNS_SHIFT)
N
N/* Bit 3: Some pin from this widget is used by other sensors to make 
N * a ganged sensor. */
N#define CapSense_SHARED_IO_SIZE           (0x00000001Lu)
N#define CapSense_SHARED_IO_SHIFT          (3u)
N#define CapSense_SHARED_IO_MASK           (CapSense_SHARED_IO_SIZE << CapSense_SHARED_IO_SHIFT)
N
N/* Bit 4: The centroid position IIR filter Enable/Disable. */
N#define CapSense_POS_IIR_FILTER_SIZE      (0x00000001Lu)
N#define CapSense_POS_IIR_FILTER_SHIFT     (4u)
N#define CapSense_POS_IIR_FILTER_MASK      (CapSense_POS_IIR_FILTER_SIZE << CapSense_POS_IIR_FILTER_SHIFT)
N
N/* Bit 5: The centroid position median filter Enable/Disable. */
N#define CapSense_POS_MEDIAN_FILTER_SIZE   (0x00000001Lu)
N#define CapSense_POS_MEDIAN_FILTER_SHIFT  (5u)
N#define CapSense_POS_MEDIAN_FILTER_MASK   (CapSense_POS_MEDIAN_FILTER_SIZE << CapSense_POS_MEDIAN_FILTER_SHIFT)
N
N/* Bit 6: The centroid position average filter Enable/Disable. */
N#define CapSense_POS_AVERAGE_FILTER_SIZE  (0x00000001Lu)
N#define CapSense_POS_AVERAGE_FILTER_SHIFT (6u)
N#define CapSense_POS_AVERAGE_FILTER_MASK  (CapSense_POS_AVERAGE_FILTER_SIZE << CapSense_POS_AVERAGE_FILTER_SHIFT)
N
N/* Bit 7: The centroid position jitter filter Enable/Disable. */
N#define CapSense_POS_JITTER_FILTER_SIZE   (0x00000001Lu)
N#define CapSense_POS_JITTER_FILTER_SHIFT  (7u)
N#define CapSense_POS_JITTER_FILTER_MASK   (CapSense_POS_JITTER_FILTER_SIZE << CapSense_POS_JITTER_FILTER_SHIFT)
N
N/* Bit 8: The multiphase Tx scan Enable (CSX widgets only). */
N#define CapSense_MULTIPHASE_TX_SIZE       (0x00000001Lu)
N#define CapSense_MULTIPHASE_TX_SHIFT      (8u)
N#define CapSense_MULTIPHASE_TX_MASK       (CapSense_MULTIPHASE_TX_SIZE << CapSense_MULTIPHASE_TX_SHIFT)
N
N/* Bit 9: The centroid position adaptive IIR filter Enable/Disable. */
N#define CapSense_AIIR_FILTER_SIZE         (0x00000001Lu)
N#define CapSense_AIIR_FILTER_SHIFT        (9u)
N#define CapSense_AIIR_FILTER_MASK         (CapSense_AIIR_FILTER_SIZE << CapSense_AIIR_FILTER_SHIFT)
N
N/* Bit 10: Ballistic multiplier Enable/Disable. */
N#define CapSense_BALLISTIC_SIZE           (0x00000001Lu)
N#define CapSense_BALLISTIC_SHIFT          (10u)
N#define CapSense_BALLISTIC_MASK           (CapSense_BALLISTIC_SIZE << CapSense_BALLISTIC_SHIFT)
N
N/* Bit 11: 3x3 centroid Enable/Disable. */
N#define CapSense_CENTROID_3X3_SIZE        (0x00000001Lu)
N#define CapSense_CENTROID_3X3_SHIFT       (11u)
N#define CapSense_CENTROID_3X3_MASK        (CapSense_CENTROID_3X3_SIZE << CapSense_CENTROID_3X3_SHIFT)
N
N/* Bit 12: 5x5 centroid Enable/Disable. */
N#define CapSense_CENTROID_5X5_SIZE        (0x00000001Lu)
N#define CapSense_CENTROID_5X5_SHIFT       (12u)
N#define CapSense_CENTROID_5X5_MASK        (CapSense_CENTROID_5X5_SIZE << CapSense_CENTROID_5X5_SHIFT)
N
N/* Bit 13: Edge correction Enable/Disable. */
N#define CapSense_EDGE_CORRECTION_SIZE     (0x00000001Lu)
N#define CapSense_EDGE_CORRECTION_SHIFT    (13u)
N#define CapSense_EDGE_CORRECTION_MASK     (CapSense_EDGE_CORRECTION_SIZE << CapSense_EDGE_CORRECTION_SHIFT)
N
N/* Bit 14: Two finger detection Enable/Disable. */
N#define CapSense_TWO_FINGER_DETECTION_SIZE (0x00000001Lu)
N#define CapSense_TWO_FINGER_DETECTION_SHIFT (14u)
N#define CapSense_TWO_FINGER_DETECTION_MASK (CapSense_TWO_FINGER_DETECTION_SIZE << CapSense_TWO_FINGER_DETECTION_SHIFT)
N
N
N/*******************************************************************************
N* Defines Data Structure Macro helpers
N*******************************************************************************/
N
N/*******************************************************************************
N* Determines the widget specific word in the wdgtStatus array by widget ID
N*******************************************************************************/
N/* Divide by 32 - size of the wdgtStatus word in bits to find the word index */
N#define CapSense_GET_WDGT_STATUS_INDEX(wdgtId)  ((wdgtId) >> 5u)
N
N/*******************************************************************************
N* Determines the widget bitmask in wdgtStatus word by widget ID
N*******************************************************************************/
N/* Take the least 5 bits of widget id to find the bit number */
N#define CapSense_GET_WDGT_STATUS_MASK(wdgtId)   (1Lu << ((wdgtId) & 0x1FLu))
N
N/*******************************************************************************
N* Determines the sense method of the widget
N*******************************************************************************/
N/* 
N* If there are multiple sensing methods, get senseMethod from flash structure,
N* otherwise, hardcode it for speed. 
N*/
N#if (CapSense_USES_MANY_SENSE_MODES)
X#if ((((13u) && ((0u) || (0u))) || ((0u) && (0u))))
S    #define CapSense_GET_SENSE_METHOD(ptrFlash) ((CapSense_SENSE_METHOD_ENUM)(ptrFlash)->senseMethod)
N#elif (0u != CapSense_TOTAL_CSD_WIDGETS)
X#elif (0u != (13u))
N    #define CapSense_GET_SENSE_METHOD(ptrFlash) CapSense_SENSE_METHOD_CSD_E
N#elif (0u != CapSense_TOTAL_CSX_WIDGETS)
S    #define CapSense_GET_SENSE_METHOD(ptrFlash) CapSense_SENSE_METHOD_CSX_E
S#elif (0u != CapSense_TOTAL_ISX_WIDGETS)
S    #define CapSense_GET_SENSE_METHOD(ptrFlash) CapSense_SENSE_METHOD_ISX_E
N#endif /* (CapSense_USES_MANY_SENSE_MODES) */
N
N/*******************************************************************************
N* Gets the widget type
N*******************************************************************************/
N#define CapSense_GET_WIDGET_TYPE(ptrFlashWdgt)  ((CapSense_WD_TYPE_ENUM)((ptrFlashWdgt)->wdgtType))
N
N/*******************************************************************************
N* Gets the number of the widget's sensors
N*******************************************************************************/
N#define CapSense_GET_SENSOR_COUNT(widgetId)         CapSense_dsFlash.wdgtArray[(widgetId)].totalNumSns
N#define CapSense_GET_SNS_CNT_BY_PTR(ptrFlashWidget) (ptrFlashWidget)->totalNumSns
N
N/*******************************************************************************
N* Increments the pointer to the Regular Filter History Object
N*******************************************************************************/
N#if (0u != CapSense_REGULAR_RC_ALP_FILTER_EN)
X#if (0u != (0u))
S    #define CapSense_INC_REG_FLTR_OBJ(fltrVariant)      \
S        do {                                                    \
S            (fltrVariant).ptrAlp++;                             \
S        } while(0)
X    #define CapSense_INC_REG_FLTR_OBJ(fltrVariant)              do {                                                                (fltrVariant).ptrAlp++;                                     } while(0)
S#elif (0u != CapSense_REGULAR_RC_FILTER_EN)
X#elif (0u != (0u))
S    #define CapSense_INC_REG_FLTR_OBJ(fltrVariant)      \
S        do {                                                    \
S            (fltrVariant).ptrRegular++;                         \
S        } while(0)
X    #define CapSense_INC_REG_FLTR_OBJ(fltrVariant)              do {                                                                (fltrVariant).ptrRegular++;                                 } while(0)
N#else
N    #define CapSense_INC_REG_FLTR_OBJ(fltrVariant)      \
N        do {                                                    \
N        } while(0)
X    #define CapSense_INC_REG_FLTR_OBJ(fltrVariant)              do {                                                            } while(0)
N#endif
N
N/*******************************************************************************
N* Increments the pointer to the Proximity Filter History Object
N*******************************************************************************/
N#if (0u != CapSense_PROX_RC_ALP_FILTER_EN)
X#if (0u != (0u))
S    #define CapSense_INC_PROX_FLTR_OBJ(fltrVariant)     \
S        do {                                                    \
S            (fltrVariant).ptrAlp++;                             \
S        } while(0)
X    #define CapSense_INC_PROX_FLTR_OBJ(fltrVariant)             do {                                                                (fltrVariant).ptrAlp++;                                     } while(0)
S#elif (0u != CapSense_PROX_RC_FILTER_EN)
X#elif (0u != (0u))
S    #define CapSense_INC_PROX_FLTR_OBJ(fltrVariant)     \
S        do {                                                    \
S            (fltrVariant).ptrProx++;                            \
S        } while(0)
X    #define CapSense_INC_PROX_FLTR_OBJ(fltrVariant)             do {                                                                (fltrVariant).ptrProx++;                                    } while(0)
N#else
N    #define CapSense_INC_PROX_FLTR_OBJ(fltrVariant)     \
N        do {                                                    \
N        } while(0)
X    #define CapSense_INC_PROX_FLTR_OBJ(fltrVariant)             do {                                                            } while(0)
N#endif
N
N/*******************************************************************************
N* Increments the pointer to the Filter History Object Variant
N*******************************************************************************/
N#define CapSense_INC_FLTR_OBJ_VARIANT(isProxHistObj, fltrVariant)   \
N    do {                                                                    \
N        if (0u == (isProxHistObj))                                          \
N        {                                                                   \
N            CapSense_INC_REG_FLTR_OBJ(fltrVariant);                 \
N        }                                                                   \
N        else                                                                \
N        {                                                                   \
N            CapSense_INC_PROX_FLTR_OBJ(fltrVariant);                \
N        }                                                                   \
N    } while(0)
X#define CapSense_INC_FLTR_OBJ_VARIANT(isProxHistObj, fltrVariant)       do {                                                                            if (0u == (isProxHistObj))                                                  {                                                                               CapSense_INC_REG_FLTR_OBJ(fltrVariant);                         }                                                                           else                                                                        {                                                                               CapSense_INC_PROX_FLTR_OBJ(fltrVariant);                        }                                                                       } while(0)
N
N/*******************************************************************************
N* Gets a widget status in the global enable register dsRam.wdgtEnable[]
N*******************************************************************************/
N#if (CapSense_ENABLE == CapSense_SELF_TEST_EN)
X#if ((1u) == (0Lu))
S    #define CapSense_GET_WIDGET_EN_STATUS(wdId)                                                     \
S                 (CapSense_GET_WDGT_STATUS_MASK(wdId) &                                             \
S                  CapSense_dsRam.wdgtEnable[CapSense_GET_WDGT_STATUS_INDEX(wdId)] &         \
S                  CapSense_dsRam.wdgtWorking[CapSense_GET_WDGT_STATUS_INDEX(wdId)])
X    #define CapSense_GET_WIDGET_EN_STATUS(wdId)                                                                      (CapSense_GET_WDGT_STATUS_MASK(wdId) &                                                               CapSense_dsRam.wdgtEnable[CapSense_GET_WDGT_STATUS_INDEX(wdId)] &                           CapSense_dsRam.wdgtWorking[CapSense_GET_WDGT_STATUS_INDEX(wdId)])
N#else
N    #define CapSense_GET_WIDGET_EN_STATUS(wdId)                    \
N                (CapSense_GET_WDGT_STATUS_MASK(wdId) &             \
N                 CapSense_dsRam.wdgtEnable[CapSense_GET_WDGT_STATUS_INDEX(wdId)])
X    #define CapSense_GET_WIDGET_EN_STATUS(wdId)                                    (CapSense_GET_WDGT_STATUS_MASK(wdId) &                              CapSense_dsRam.wdgtEnable[CapSense_GET_WDGT_STATUS_INDEX(wdId)])
N#endif /* (CapSense_ENABLE == CapSense_SELF_TEST_EN) */
N
N/*******************************************************************************
N* Gets a widget active status from the dsRam.wdgtStatus[] register
N*******************************************************************************/
N#define CapSense_GET_WIDGET_ACTIVE_STATUS(wdId)                    \
N            (CapSense_GET_WDGT_STATUS_MASK(wdId) &                 \
N             CapSense_dsRam.wdgtStatus[CapSense_GET_WDGT_STATUS_INDEX(wdId)])
X#define CapSense_GET_WIDGET_ACTIVE_STATUS(wdId)                                (CapSense_GET_WDGT_STATUS_MASK(wdId) &                              CapSense_dsRam.wdgtStatus[CapSense_GET_WDGT_STATUS_INDEX(wdId)])
N
N/*******************************************************************************
N* Declares Flash and RAM Data Structure variables
N*******************************************************************************/
Nextern CapSense_RAM_STRUCT            CapSense_dsRam;
Nextern const CapSense_FLASH_STRUCT    CapSense_dsFlash;
Nextern const CapSense_FLASH_IO_STRUCT CapSense_ioList[CapSense_TOTAL_ELECTRODES];
Xextern const CapSense_FLASH_IO_STRUCT CapSense_ioList[(24u)];
Nextern const CapSense_RAM_WD_LIST_STRUCT CapSense_ramWidgetInit;
Nextern const uint8 CapSense_ramIdacInit[CapSense_TOTAL_SENSORS];
Xextern const uint8 CapSense_ramIdacInit[((13u) + (0u)+ (0u))];
N
N
N
N
N
N
N/*******************************************************************************
N* Function Prototypes
N*******************************************************************************/
N
N/*******************************************************************************
N* High-level API
N*******************************************************************************/
N
N/**
N* \cond (SECTION_C_HIGH_LEVEL || SECTION_I_HIGH_LEVEL)
N* \addtogroup group_c_high_level
N* \{
N*/
N
Nuint32 CapSense_IsAnyWidgetActive(void);
Nuint32 CapSense_IsWidgetActive(uint32 widgetId);
Nuint32 CapSense_IsSensorActive(uint32 widgetId, uint32 sensorId);
N
N#if (0u != CapSense_PROXIMITY_WIDGET_EN)
X#if (0u != (1u))
N    uint32 CapSense_IsProximitySensorActive(uint32 widgetId, uint32 proxId);
N#endif /* #if (0u != CapSense_PROXIMITY_WIDGET_EN) */
N
N/** \}
N* \endcond 
N* \cond (SECTION_C_HIGH_LEVEL)
N* \addtogroup group_c_high_level
N* \{
N*/
N#if (0u != CapSense_MATRIX_WIDGET_EN)
X#if (0u != (0u))
S    uint32 CapSense_IsMatrixButtonsActive(uint32 widgetId);
N#endif /* #if (0u != CapSense_MATRIX_WIDGET_EN) */
N
N#if (0u != CapSense_SLIDER_WIDGET_EN)
X#if (0u != (0u))
S    uint32 CapSense_GetCentroidPos(uint32 widgetId);
N#endif /* #if (0u != CapSense_SLIDER_WIDGET_EN) */
N
N#if (0u != CapSense_TOUCHPAD_WIDGET_EN)
X#if (0u != (0u))
S    uint32 CapSense_GetXYCoordinates(uint32 widgetId);
N#endif /* #if (0u != CapSense_TOUCHPAD_WIDGET_EN) */
N
N/** \}
N* \endcond */
N
N/*******************************************************************************
N* Low level API
N*******************************************************************************/
N
N/**
N* \cond (SECTION_C_LOW_LEVEL || SECTION_I_LOW_LEVEL)
N* \addtogroup group_c_low_level
N* \{
N*/
N
Ncystatus CapSense_GetParam(uint32 paramId, uint32 *value);
Ncystatus CapSense_SetParam(uint32 paramId, uint32 value);
N
N/** \}
N* \endcond */
N
N/*******************************************************************************
N* Function Prototypes - internal functions
N*******************************************************************************/
N/**
N* \cond SECTION_C_INTERNAL
N* \addtogroup group_c_internal
N* \{
N*/
N
N
N
Nvoid CapSense_DsInitialize(void);
N#if (0u != CapSense_ADC_EN)
X#if (0u != (0u))
S    void CapSense_AdcDsInitialize(void);
N#endif /* (0u != CapSense_ADC_EN) */
N
N/** \}
N* \endcond */
N
N#endif /* End CY_SENSE_CapSense_STRUCTURE_H */
N
N
N/* [] END OF FILE */
L 48 "Generated_Source\PSoC4\CapSense_Filter.h" 2
N#include "CapSense_Configuration.h"
N
N/***************************************
N* Function Prototypes
N***************************************/
N
N/*******************************************************************************
N* LOW LEVEL API
N*******************************************************************************/
N/**
N* \cond (SECTION_C_LOW_LEVEL || SECTION_I_LOW_LEVEL)
N* \addtogroup group_c_low_level
N* \{
N*/
N
Ncystatus CapSense_UpdateAllBaselines(void);
Ncystatus CapSense_UpdateWidgetBaseline(uint32 widgetId);
Ncystatus CapSense_UpdateSensorBaseline(uint32 widgetId, uint32 sensorId);
N
Nvoid CapSense_InitializeAllBaselines(void);
Nvoid CapSense_InitializeWidgetBaseline(uint32 widgetId);
Nvoid CapSense_InitializeSensorBaseline(uint32 widgetId, uint32 sensorId);
N
N#if ((CapSense_ENABLE == CapSense_RC_FILTER_EN) || \
N     (0u != (CapSense_CSD_AUTOTUNE & CapSense_CSD_SS_TH_EN)))
X#if (((1u) == ((0u) || (0u))) ||      (0u != ((0x00ul) & (0x02ul))))
S    void CapSense_InitializeAllFilters(void);
S    void CapSense_InitializeWidgetFilter(uint32 widgetId);
N#endif /* ((CapSense_ENABLE == CapSense_RC_FILTER_EN) || \
N           (0u != (CapSense_CSD_AUTOTUNE & CapSense_CSD_SS_TH_EN))) */
X#endif  
N
N/** \}
N* \endcond */
N
N
N/*******************************************************************************
N* Function Prototypes - internal functions
N*******************************************************************************/
N/**
N* \cond SECTION_C_INTERNAL
N* \addtogroup group_c_internal
N* \{
N*/
N
Nvoid CapSense_FtInitialize(void);
N
N#if (0u != (CapSense_CSD_AUTOTUNE & CapSense_CSD_SS_TH_EN))
X#if (0u != ((0x00ul) & (0x02ul)))
S    void CapSense_RunNoiseEnvelope(uint32 widgetId, uint32 sensorId);
S    void CapSense_InitializeNoiseEnvelope(uint32 widgetId, uint32 sensorId);
N#endif /* (0u != (CapSense_CSD_AUTOTUNE & CapSense_CSD_SS_TH_EN)) */
N
N#if (CapSense_REGULAR_RC_IIR_FILTER_EN || CapSense_PROX_RC_IIR_FILTER_EN)
X#if ((0u) || (0u))
S    void CapSense_InitializeIIR(uint32 widgetId, uint32 sensorId);
S    void CapSense_RunIIR(uint32 widgetId, uint32 sensorId);
N#endif /* (CapSense_REGULAR_RC_IIR_FILTER_EN || CapSense_PROX_RC_IIR_FILTER_EN) */
N
N#if (CapSense_REGULAR_RC_MEDIAN_FILTER_EN || CapSense_PROX_RC_MEDIAN_FILTER_EN)
X#if ((0u) || (0u))
S    void CapSense_InitializeMedian(uint32 widgetId, uint32 sensorId);
S    void CapSense_RunMedian(uint32 widgetId, uint32 sensorId);
N#endif /* (CapSense_REGULAR_RC_MEDIAN_FILTER_EN || CapSense_PROX_RC_MEDIAN_FILTER_EN) */
N
N#if (CapSense_REGULAR_RC_AVERAGE_FILTER_EN || CapSense_PROX_RC_AVERAGE_FILTER_EN)
X#if ((0u) || (0u))
S    void CapSense_InitializeAverage(uint32 widgetId, uint32 sensorId);
S    void CapSense_RunAverage(uint32 widgetId, uint32 sensorId);
N#endif /* (CapSense_REGULAR_RC_AVERAGE_FILTER_EN || CapSense_PROX_RC_AVERAGE_FILTER_EN) */
N
Nvoid CapSense_FtInitializeBaseline(CapSense_RAM_SNS_STRUCT *ptrSensor, uint32 wdType);
Nuint32 CapSense_FtUpdateBaseline(
N                            CapSense_RAM_WD_BASE_STRUCT *ptrWidgetRam,
N                            CapSense_RAM_SNS_STRUCT *ptrSensor,
N                            uint32 wdType);
N
N#if (CapSense_POS_MEDIAN_FILTER_EN || CapSense_REGULAR_RC_MEDIAN_FILTER_EN || CapSense_PROX_RC_MEDIAN_FILTER_EN)
X#if ((0u) || (0u) || (0u))
Suint32 CapSense_FtMedian(uint32 x1, uint32 x2, uint32 x3);
N#endif /*CapSense_POS_MEDIAN_FILTER_EN || CapSense_REGULAR_RC_MEDIAN_FILTER_EN || CapSense_PROX_RC_MEDIAN_FILTER_EN*/
N
Nuint32 CapSense_FtIIR1stOrder(uint32 input, uint32 prevOutput, uint32 n, uint32 shift);
N
N#if (CapSense_POS_JITTER_FILTER_EN)
X#if ((0u))
S    uint32 CapSense_FtJitter(uint32 input, uint32 prevOutput);
N#endif /* CapSense_POS_JITTER_FILTER_EN */
N
Nvoid CapSense_FtInitializeBaselineChannel(CapSense_RAM_SNS_STRUCT *ptrSensor, uint32 wdType, uint32 channel);
N
N#if (CapSense_ENABLE == CapSense_RC_FILTER_EN)
X#if ((1u) == ((0u) || (0u)))
S    void CapSense_FtRunEnabledFilters(uint32 widgetId, uint32 sensorId);
S    void CapSense_FtRunEnabledFiltersInternal(CapSense_PTR_FILTER_VARIANT ptrFilterHistObj,
S                                                      CapSense_RAM_SNS_STRUCT *ptrSensorObj, uint32 wdType);
N#endif /* (CapSense_ENABLE == CapSense_RC_FILTER_EN) */
N
N
N#if (CapSense_REGULAR_RC_IIR_FILTER_EN || CapSense_PROX_RC_IIR_FILTER_EN)
X#if ((0u) || (0u))
S    void CapSense_InitializeIIRInternal(CapSense_PTR_FILTER_VARIANT ptrFilterHistObj,
S                                                  CapSense_RAM_SNS_STRUCT *ptrSensorObj, uint32 wdType);
S    void CapSense_RunIIRInternal(CapSense_PTR_FILTER_VARIANT ptrFilterHistObj,
S                                           CapSense_RAM_SNS_STRUCT *ptrSensorObj, uint32 wdType);
N#endif /* (CapSense_REGULAR_RC_IIR_FILTER_EN || CapSense_PROX_RC_IIR_FILTER_EN) */
N
N#if (CapSense_REGULAR_RC_MEDIAN_FILTER_EN || CapSense_PROX_RC_MEDIAN_FILTER_EN)
X#if ((0u) || (0u))
S    void CapSense_InitializeMedianInternal(CapSense_PTR_FILTER_VARIANT ptrFilterHistObj,
S                                                     CapSense_RAM_SNS_STRUCT *ptrSensorObj, uint32 wdType);
S    void CapSense_RunMedianInternal(CapSense_PTR_FILTER_VARIANT ptrFilterHistObj,
S                                              CapSense_RAM_SNS_STRUCT *ptrSensorObj, uint32 wdType);
N#endif /* (CapSense_REGULAR_RC_MEDIAN_FILTER_EN || CapSense_PROX_RC_MEDIAN_FILTER_EN) */
N
N#if (CapSense_REGULAR_RC_AVERAGE_FILTER_EN || CapSense_PROX_RC_AVERAGE_FILTER_EN)
X#if ((0u) || (0u))
S    void CapSense_InitializeAverageInternal(CapSense_PTR_FILTER_VARIANT ptrFilterHistObj,
S                                                      CapSense_RAM_SNS_STRUCT *ptrSensorObj, uint32 wdType);
S    void CapSense_RunAverageInternal(CapSense_PTR_FILTER_VARIANT ptrFilterHistObj,
S                                               CapSense_RAM_SNS_STRUCT *ptrSensorObj, uint32 wdType);
N#endif /* (CapSense_REGULAR_RC_AVERAGE_FILTER_EN || CapSense_PROX_RC_AVERAGE_FILTER_EN) */
N
N#if (CapSense_ENABLE == CapSense_ALP_FILTER_EN)
X#if ((1u) == (0u))
S    void CapSense_InitializeALP(uint32 widgetId, uint32 sensorId);
S    void CapSense_RunALP(uint32 widgetId, uint32 sensorId);
S    void CapSense_InitializeALPInternal(CapSense_PTR_FILTER_VARIANT ptrFilterHistObj,
S                                                CapSense_RAM_SNS_STRUCT *ptrSensorObj,
S                                                uint32 wdType);
S    void CapSense_ConfigRunALPInternal(CapSense_PTR_FILTER_VARIANT ptrFilterHistObj,
S                                        CapSense_RAM_WD_BASE_STRUCT *ptrRamWdgt,
S                                        CapSense_RAM_SNS_STRUCT *ptrSensorObj,
S                                        uint32 wdType);
S    void CapSense_RunALPInternal(CapSense_PTR_FILTER_VARIANT ptrFilterHistObj,
S                                        ALP_FLTR_CONFIG_STRUCT *ptrAlpFilterConfig,
S                                        CapSense_RAM_SNS_STRUCT *ptrSensorObj,
S                                        uint32 wdType);
N#endif /* (CapSense_ENABLE == CapSense_ALP_FILTER_EN) */
N
N/** \}
N* \endcond */
N
N/***************************************
N* Initial Parameter Constants
N***************************************/
N#define NOISE_ENVELOPE_SHIFT                        (0x02u)
N#define NOISE_ENVELOPE_RUN_DIFF_SHIFT               (0x03u)
N#define NOISE_ENVELOPE_SIGN_REG                     (0x0Fu)
N#define NOISE_ENVELOPE_SIGN_REG_SHIFT               (0x01u)
N#define NOISE_ENVELOPE_RESET_COUNTER                (0x0Au)
N#define NOISE_ENVELOPE_4_TIMES                      (0x02u)
N
N#endif /* End CY_SENSE_CapSense_FILTER_H */
N
N
N/* [] END OF FILE */
L 46 "Generated_Source\PSoC4\CapSense.h" 2
N#include "CapSense_Processing.h"
L 1 "Generated_Source\PSoC4\CapSense_Processing.h" 1
N/***************************************************************************//**
N* \file CapSense_Processing.h
N* \version 5.0
N*
N* \brief
N*   This file provides the function prototypes for the Data Processing module.
N*   The Data Processing module is responsible for the low level raw counts
N*   processing provided by the sensing module, maintaining baseline and
N*   difference values and performing high-level widget processing like updating
N*   button status or calculating slider position.
N*
N* \see CapSense v5.0 Datasheet
N*
N*//*****************************************************************************
N* Copyright (2016-2017), Cypress Semiconductor Corporation.
N********************************************************************************
N* This software is owned by Cypress Semiconductor Corporation (Cypress) and is
N* protected by and subject to worldwide patent protection (United States and
N* foreign), United States copyright laws and international treaty provisions.
N* Cypress hereby grants to licensee a personal, non-exclusive, non-transferable
N* license to copy, use, modify, create derivative works of, and compile the
N* Cypress Source Code and derivative works for the sole purpose of creating
N* custom software in support of licensee product to be used only in conjunction
N* with a Cypress integrated circuit as specified in the applicable agreement.
N* Any reproduction, modification, translation, compilation, or representation of
N* this software except as specified above is prohibited without the express
N* written permission of Cypress.
N*
N* Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH
N* REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
N* Cypress reserves the right to make changes without further notice to the
N* materials described herein. Cypress does not assume any liability arising out
N* of the application or use of any product or circuit described herein. Cypress
N* does not authorize its products for use as critical components in life-support
N* systems where a malfunction or failure may reasonably be expected to result in
N* significant injury to the user. The inclusion of Cypress' product in a life-
N* support systems application implies that the manufacturer assumes all risk of
N* such use and in doing so indemnifies Cypress against all charges. Use may be
N* limited by and subject to the applicable Cypress software license agreement.
N*******************************************************************************/
N
N#if !defined(CY_SENSE_CapSense_DATA_PROCESS_H)
X#if !0L
N#define CY_SENSE_CapSense_DATA_PROCESS_H
N
N#include "CapSense_Configuration.h"
N#include "CapSense_Structure.h"
N
N#if (0 != (CapSense_CSD_AUTOTUNE & CapSense_CSD_SS_TH_EN))
X#if (0 != ((0x00ul) & (0x02ul)))
S    #include "CapSense_SmartSense_LL.h"
N#endif /* (0 != (CapSense_CSD_AUTOTUNE & CapSense_CSD_SS_TH_EN)) */
N
N/*******************************************************************************
N* Definitions
N*******************************************************************************/
N
N/* Defines the data processing tasks */
N
N/* Applies all enabled filters in the default order to the raw counts */
N#define CapSense_PROCESS_FILTER             (0x01Lu)
N
N/* Updates baselines using current raw count values for the widget/sensor */
N#define CapSense_PROCESS_BASELINE           (0x02Lu)
N
N/* Calculates differences for the widget/sensor */
N#define CapSense_PROCESS_DIFFCOUNTS         (0x04Lu)
N
N/* Runs the noise envelope filter to measure noise magnitude for the widget/sensor */
N#define CapSense_PROCESS_CALC_NOISE         (0x08Lu)
N
N/* Updates widget thresholds based on raw counts noise magnitude */
N#define CapSense_PROCESS_THRESHOLDS         (0x10Lu)
N
N/* Runs the widget-specific processing algorithms and updates it status */
N#define CapSense_PROCESS_STATUS             (0x20Lu)
N
N/* Runs the deconvolution algorithm for the widgets with the multiphase TX scanning */
N#define CapSense_PROCESS_DECONVOLUTION      (0x40Lu)
N
N/* Definition that combines all possible processing tasks */
N#define CapSense_PROCESS_ALL    (CapSense_PROCESS_FILTER        | \
N                                         CapSense_PROCESS_BASELINE      | \
N                                         CapSense_PROCESS_DIFFCOUNTS    | \
N                                         CapSense_PROCESS_CALC_NOISE    | \
N                                         CapSense_PROCESS_THRESHOLDS    | \
N                                         CapSense_PROCESS_DECONVOLUTION | \
N                                         CapSense_PROCESS_STATUS )
X#define CapSense_PROCESS_ALL    (CapSense_PROCESS_FILTER        |                                          CapSense_PROCESS_BASELINE      |                                          CapSense_PROCESS_DIFFCOUNTS    |                                          CapSense_PROCESS_CALC_NOISE    |                                          CapSense_PROCESS_THRESHOLDS    |                                          CapSense_PROCESS_DECONVOLUTION |                                          CapSense_PROCESS_STATUS )
N
N/*******************************************************************************
N* Function Prototypes - internal functions.
N*******************************************************************************/
N/**
N* \cond SECTION_C_INTERNAL
N* \addtogroup group_c_internal
N* \{
N*/
N
Nvoid CapSense_DpInitialize(void);
N
N#if ((0u != CapSense_BUTTON_WIDGET_EN) || (0u != CapSense_CSX_MATRIX_WIDGET_EN))
X#if ((0u != (1u)) || (0u != (0u)))
N    uint32 CapSense_DpProcessButton(uint32 currStatus, CapSense_FLASH_WD_STRUCT const *ptrFlashWdgt);
N#endif /* #if ((0u != CapSense_BUTTON_WIDGET_EN) || (0u != CapSense_CSX_MATRIX_WIDGET_EN)) */
N
N#if (0u != CapSense_CSX_TOUCHPAD_WIDGET_EN)
X#if (0u != (0u))
S    uint32 CapSense_DpProcessCsxTouchpad(
S                uint32 currStatus, CapSense_FLASH_WD_STRUCT const *ptrFlashWdgt);
N#endif /* #if (0u != CapSense_CSX_TOUCHPAD_WIDGET_EN) */
N
N#if (0u != CapSense_PROXIMITY_WIDGET_EN)
X#if (0u != (1u))
N    uint32 CapSense_DpProcessProximity(uint32 currStatus, CapSense_FLASH_WD_STRUCT const *ptrFlashWdgt);
N#endif /* #if (0u != CapSense_PROXIMITY_WIDGET_EN) */
N
N#if (0u != CapSense_SLIDER_WIDGET_EN)
X#if (0u != (0u))
S    uint32 CapSense_DpProcessSlider(uint32 currStatus, CapSense_FLASH_WD_STRUCT const *ptrFlashWdgt);
N#endif /* #if (0u != CapSense_SLIDER_WIDGET_EN) */
N
N#if (0u != CapSense_CSD_MATRIX_WIDGET_EN)
X#if (0u != (0u))
S    uint32 CapSense_DpProcessCsdMatrix(uint32 currStatus, CapSense_FLASH_WD_STRUCT const *ptrFlashWdgt);
N#endif /* #if (0u != CapSense_CSD_MATRIX_WIDGET_EN) */
N
N#if (0u != CapSense_CSD_TOUCHPAD_WIDGET_EN)
X#if (0u != (0u))
S    uint32 CapSense_DpProcessCsdTouchpad(
S                uint32 currStatus, CapSense_FLASH_WD_STRUCT const *ptrFlashWdgt);
N#endif /* #if (0u != CapSense_CSD_TOUCHPAD_WIDGET_EN) */
N
N#if (0u != CapSense_TOTAL_CSD_WIDGETS)
X#if (0u != (13u))
N    uint32 CapSense_DpProcessCsdWidgetRawCounts(
N                    CapSense_FLASH_WD_STRUCT const *ptrFlashWdgt);
N
N    uint32 CapSense_DpProcessCsdSensorRawCountsExt(
N                    CapSense_FLASH_WD_STRUCT const *ptrFlashWdgt,
N                    CapSense_RAM_SNS_STRUCT *curSnsPtr,
N                    CapSense_PTR_FILTER_VARIANT fltrHistV,
N                     uint32 mode);
N
N    void CapSense_DpProcessCsdWidgetStatus(uint32 widgetId, CapSense_FLASH_WD_STRUCT const *ptrFlashWdgt);
N#endif /* #if (0u != CapSense_TOTAL_CSD_WIDGETS) */
N
N#if (0u != CapSense_TOTAL_CSX_WIDGETS)
X#if (0u != (0u))
S    uint32 CapSense_DpProcessCsxWidgetRawCounts(
S            CapSense_FLASH_WD_STRUCT const *ptrFlashWdgt);
S
S    uint32 CapSense_DpProcessCsxSensorRawCountsExt(
S                    CapSense_FLASH_WD_STRUCT const *ptrFlashWdgt,
S                    CapSense_RAM_SNS_STRUCT *curSnsPtr,
S                    CapSense_PTR_FILTER_VARIANT fltrHistV,
S                     uint32 mode);
S
S    void CapSense_DpProcessCsxWidgetStatus(
S                uint32 widgetId, CapSense_FLASH_WD_STRUCT const *ptrFlashWdgt);
N#endif /* #if (0u != CapSense_TOTAL_CSX_WIDGETS) */
N
N#if (0u != CapSense_TOTAL_ISX_WIDGETS)
X#if (0u != (0u))
S    uint32 CapSense_DpProcessIsxWidgetRawCounts(
S            CapSense_FLASH_WD_STRUCT const *ptrFlashWdgt);
S
S    uint32 CapSense_DpProcessIsxSensorRawCountsExt(
S                    CapSense_FLASH_WD_STRUCT const *ptrFlashWdgt, 
S                    CapSense_RAM_SNS_STRUCT *ptrSns,
S                    CapSense_PTR_FILTER_VARIANT fltrHistV, 
S                     uint32 mode);
S    
S    void CapSense_DpProcessIsxWidgetStatus(
S                uint32 wdgtId, CapSense_FLASH_WD_STRUCT const *ptrFlashWdgt);
N#endif /* #if (0u != CapSense_TOTAL_ISX_WIDGETS) */
N
Nvoid CapSense_DpUpdateDifferences(
N        CapSense_RAM_WD_BASE_STRUCT  *ptrRamWdgt, CapSense_RAM_SNS_STRUCT *curSnsPtr);
N
N#if (0u != (CapSense_CSD_AUTOTUNE & CapSense_CSD_SS_TH_EN))
X#if (0u != ((0x00ul) & (0x02ul)))
S    void CapSense_DpUpdateThresholds(
S                    CapSense_RAM_WD_BASE_STRUCT *ptrRamWdgt,
S                    SMARTSENSE_CSD_NOISE_ENVELOPE_STRUCT *ptrNoiseEnvelope,
S                    uint32 startFlag);
N#endif /* #if (0u != (CapSense_CSD_AUTOTUNE & CapSense_CSD_SS_TH_EN)) */
N
N#if (0u != CapSense_CSX_MULTIPHASE_TX_EN)
X#if (0u != (0u))
S    void CapSense_DpDeconvolution(CapSense_FLASH_WD_STRUCT const *ptrFlashWdgt);
N#endif /* #if (0u != CapSense_CSX_MULTIPHASE_TX_EN) */
N
N
N/** \}
N* \endcond */
N
N#endif /* End CY_SENSE_CapSense_DATA_PROCESS_H */
N
N
N/* [] END OF FILE */
L 47 "Generated_Source\PSoC4\CapSense.h" 2
N#include "CapSense_Sensing.h"
L 1 "Generated_Source\PSoC4\CapSense_Sensing.h" 1
N/***************************************************************************//**
N* \file CapSense_Sensing.h
N* \version 5.0
N*
N* \brief
N*   This file provides the headers of APIs specific to implementation of the
N*   sensing FW block.
N*
N* \see CapSense v5.0 Datasheet
N*
N*//*****************************************************************************
N* Copyright (2016-2017), Cypress Semiconductor Corporation.
N********************************************************************************
N* This software is owned by Cypress Semiconductor Corporation (Cypress) and is
N* protected by and subject to worldwide patent protection (United States and
N* foreign), United States copyright laws and international treaty provisions.
N* Cypress hereby grants to licensee a personal, non-exclusive, non-transferable
N* license to copy, use, modify, create derivative works of, and compile the
N* Cypress Source Code and derivative works for the sole purpose of creating
N* custom software in support of licensee product to be used only in conjunction
N* with a Cypress integrated circuit as specified in the applicable agreement.
N* Any reproduction, modification, translation, compilation, or representation of
N* this software except as specified above is prohibited without the express
N* written permission of Cypress.
N*
N* Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH
N* REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
N* Cypress reserves the right to make changes without further notice to the
N* materials described herein. Cypress does not assume any liability arising out
N* of the application or use of any product or circuit described herein. Cypress
N* does not authorize its products for use as critical components in life-support
N* systems where a malfunction or failure may reasonably be expected to result in
N* significant injury to the user. The inclusion of Cypress' product in a life-
N* support systems application implies that the manufacturer assumes all risk of
N* such use and in doing so indemnifies Cypress against all charges. Use may be
N* limited by and subject to the applicable Cypress software license agreement.
N*******************************************************************************/
N
N#if !defined(CY_SENSE_CapSense_SENSING_H)
X#if !0L
N#define CY_SENSE_CapSense_SENSING_H
N
N#include <CyLib.h>
N#include <cyfitter.h>
N#include "cytypes.h"
N#include "CapSense_Configuration.h"
N#include "CapSense_Structure.h"
N#include "CapSense_ISR.h"
L 1 "Generated_Source\PSoC4\CapSense_ISR.h" 1
N/*******************************************************************************
N* File Name: CapSense_ISR.h
N* Version 1.70
N*
N*  Description:
N*   Provides the function definitions for the Interrupt Controller.
N*
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N#if !defined(CY_ISR_CapSense_ISR_H)
X#if !0L
N#define CY_ISR_CapSense_ISR_H
N
N
N#include <cytypes.h>
N#include <cyfitter.h>
N
N/* Interrupt Controller API. */
Nvoid CapSense_ISR_Start(void);
Nvoid CapSense_ISR_StartEx(cyisraddress address);
Nvoid CapSense_ISR_Stop(void);
N
NCY_ISR_PROTO(CapSense_ISR_Interrupt);
Xvoid CapSense_ISR_Interrupt (void);
N
Nvoid CapSense_ISR_SetVector(cyisraddress address);
Ncyisraddress CapSense_ISR_GetVector(void);
N
Nvoid CapSense_ISR_SetPriority(uint8 priority);
Nuint8 CapSense_ISR_GetPriority(void);
N
Nvoid CapSense_ISR_Enable(void);
Nuint8 CapSense_ISR_GetState(void);
Nvoid CapSense_ISR_Disable(void);
N
Nvoid CapSense_ISR_SetPending(void);
Nvoid CapSense_ISR_ClearPending(void);
N
N
N/* Interrupt Controller Constants */
N
N/* Address of the INTC.VECT[x] register that contains the Address of the CapSense_ISR ISR. */
N#define CapSense_ISR_INTC_VECTOR            ((reg32 *) CapSense_ISR__INTC_VECT)
N
N/* Address of the CapSense_ISR ISR priority. */
N#define CapSense_ISR_INTC_PRIOR             ((reg32 *) CapSense_ISR__INTC_PRIOR_REG)
N
N/* Priority of the CapSense_ISR interrupt. */
N#define CapSense_ISR_INTC_PRIOR_NUMBER      CapSense_ISR__INTC_PRIOR_NUM
N
N/* Address of the INTC.SET_EN[x] byte to bit enable CapSense_ISR interrupt. */
N#define CapSense_ISR_INTC_SET_EN            ((reg32 *) CapSense_ISR__INTC_SET_EN_REG)
N
N/* Address of the INTC.CLR_EN[x] register to bit clear the CapSense_ISR interrupt. */
N#define CapSense_ISR_INTC_CLR_EN            ((reg32 *) CapSense_ISR__INTC_CLR_EN_REG)
N
N/* Address of the INTC.SET_PD[x] register to set the CapSense_ISR interrupt state to pending. */
N#define CapSense_ISR_INTC_SET_PD            ((reg32 *) CapSense_ISR__INTC_SET_PD_REG)
N
N/* Address of the INTC.CLR_PD[x] register to clear the CapSense_ISR interrupt. */
N#define CapSense_ISR_INTC_CLR_PD            ((reg32 *) CapSense_ISR__INTC_CLR_PD_REG)
N
N
N
N#endif /* CY_ISR_CapSense_ISR_H */
N
N
N/* [] END OF FILE */
L 49 "Generated_Source\PSoC4\CapSense_Sensing.h" 2
N
N/*******************************************************************************
N* Enumeration types definition
N*******************************************************************************/
N
N/* Pin states */
N#define CapSense_GROUND                                 (0u)
N#define CapSense_HIGHZ                                  (1u)
N#define CapSense_SHIELD                                 (2u)
N#define CapSense_SENSOR                                 (3u)
N#define CapSense_TX_PIN                                 (4u)
N#define CapSense_RX_PIN                                 (5u)
N
N#if (CapSense_ENABLE != CapSense_ADC_STANDALONE_EN)
X#if ((1u) != (0u))
N/*******************************************************************************
N* Function Prototypes
N*******************************************************************************/
N
N/**
N* \cond (SECTION_C_HIGH_LEVEL || SECTION_I_HIGH_LEVEL)
N* \addtogroup group_c_high_level
N* \{
N*/
N
Ncystatus CapSense_SetupWidget(uint32 widgetId);
Ncystatus CapSense_Scan(void);
Ncystatus CapSense_ScanAllWidgets(void);
Nuint32 CapSense_IsBusy(void);
N
N/** \}
N* \endcond */
N
N/**
N* \cond (SECTION_C_LOW_LEVEL || SECTION_I_LOW_LEVEL)
N* \addtogroup group_c_low_level
N* \{
N*/
N
Nvoid CapSense_SetPinState(uint32 widgetId, uint32 sensorElement, uint32 state);
N
N#if (CapSense_ANYMODE_AUTOCAL)
X#if ((((0u != (0u)) || (0u != (0u))) || (0u != (1u))))
N    cystatus CapSense_CalibrateWidget(uint32 widgetId);
N    cystatus CapSense_CalibrateAllWidgets(void);
N#endif /* (CapSense_ANYMODE_AUTOCAL) */
N
N/** \}
N* \endcond */
N
N/**
N* \cond SECTION_C_INTERNAL
N* \addtogroup group_c_internal
N* \{
N*/
N
Ncystatus CapSense_SsInitialize(void);
Nvoid CapSense_SsSetModClkClockDivider(uint32 modClk);
Nvoid CapSense_SsSetSnsClockDivider(uint32 snsClk);
Nvoid CapSense_SsSetClockDividers(uint32 snsClk, uint32 modClk);
Nvoid CapSense_SsIsrInitialize(cyisraddress address);
Nvoid CapSense_SsPostAllWidgetsScan(void);
Nvoid CapSense_SsSetIOsInDefaultState(void);
Nvoid CapSense_SsSwitchSensingMode(CapSense_SENSE_METHOD_ENUM mode);
N
N#if (CapSense_CSD_SS_DIS != CapSense_CSD_AUTOTUNE)
X#if ((0x00ul) != (0x00ul))
S    cystatus CapSense_SsAutoTune(void);
N#endif
N
N#if (CapSense_ENABLE == CapSense_MULTI_FREQ_SCAN_EN)
X#if ((1u) == (0u))
S    void CapSense_SsChangeImoFreq(uint32 value);
S    void CapSense_SsChangeClkFreq(uint32 chId);
N#endif
N
N#if (CapSense_ENABLE == CapSense_ADC_EN)
X#if ((1u) == (0u))
S    cystatus CapSense_SsReleaseResources(void);
N#endif
N
N#if((CapSense_ENABLE == CapSense_CSD_EN) || \
N    (((CapSense_ENABLE == CapSense_CSX_EN) || \
N    (CapSense_ENABLE == CapSense_ISX_EN)) && \
N    (CapSense_ENABLE == CapSense_CSDV2)))
X#if(((1u) == (1u)) ||     ((((1u) == (0u)) ||     ((1u) == (0u))) &&     ((1u) == (1u))))
N    void CapSense_SsInitializeSourceSenseClk(void);
N#endif
N
N#if (CapSense_ENABLE == CapSense_CSD_EN)
X#if ((1u) == (1u))
N    void CapSense_SsClearCSDSensors(void);
N    uint32 CapSense_SsCSDGetColSnsClkDivider(uint32 widgetId);
N
N    #if ((CapSense_ENABLE == CapSense_CSD_MATRIX_WIDGET_EN) || \
N         (CapSense_ENABLE == CapSense_CSD_TOUCHPAD_WIDGET_EN))
X    #if (((1u) == (0u)) ||          ((1u) == (0u)))
S        uint32 CapSense_SsCSDGetRowSnsClkDivider(uint32 widgetId);
N    #endif
N
N    #if (CapSense_CLK_SOURCE_PRSAUTO == CapSense_CSD_SNS_CLK_SOURCE)
X    #if ((0xFFu) == ((0xFFu)))
N        uint8 CapSense_SsCSDCalcPrsSize(uint32 snsClkDivider, uint32 resolution);
N    #endif
N#endif
N
N#if (CapSense_ENABLE == CapSense_CSDV2)
X#if ((1u) == (1u))
N    void CapSense_BistDischargeExtCapacitors(void);
N#endif /* (CapSense_ENABLE == CapSense_CSDV2) */
N
N
N/** \}
N* \endcond */
N
N/***************************************
N* Global software/external variables
N***************************************/
Nextern volatile uint8 CapSense_widgetIndex;
Nextern volatile uint8 CapSense_sensorIndex;
Nextern uint8 CapSense_requestScanAllWidget;
N
Nextern CapSense_RAM_SNS_STRUCT *CapSense_curRamSnsPtr;
Nextern CapSense_SENSE_METHOD_ENUM CapSense_currentSenseMethod;
N
N#if(CapSense_ENABLE == CapSense_MULTI_FREQ_SCAN_EN)
X#if((1u) == (0u))
S    extern uint8 CapSense_scanFreqIndex;
S    extern uint8 CapSense_immunity[CapSense_NUM_SCAN_FREQS];
N#else
N    extern const uint8 CapSense_scanFreqIndex;
N#endif
N
N#if ((CapSense_ENABLE == CapSense_CSD_GANGED_SNS_EN) || \
N     (CapSense_ENABLE == CapSense_CSX_EN) || \
N     (CapSense_ENABLE == CapSense_ISX_EN))
X#if (((1u) == (1u)) ||      ((1u) == (0u)) ||      ((1u) == (0u)))
N    extern CapSense_FLASH_WD_STRUCT const *CapSense_curFlashWdgtPtr;
N#endif
N
N#if (CapSense_ENABLE == CapSense_CSD_GANGED_SNS_EN)
X#if ((1u) == (1u))
N    /* Pointer to Flash structure holding info of sensor to be scanned */
N    extern CapSense_FLASH_SNS_STRUCT const *CapSense_curFlashSnsPtr;
N#endif
N
Nextern CapSense_FLASH_IO_STRUCT const *CapSense_curSnsIOPtr;
N
N#endif /* (CapSense_ENABLE != CapSense_ADC_STANDALONE_EN) */
N
N/****************************************************************************
N* m0s8csd, m0s8peri, hsiom, and IO hardware-related registers address
N****************************************************************************/
N#if (CapSense_ENABLE == CapSense_CSDV2)
X#if ((1u) == (1u))
N
N    /* Fourth-generation HW block registers   */
N    #define CapSense_CONFIG_REG                         (*(reg32 *) CYREG_CSD_CONFIG)
N    #define CapSense_CONFIG_PTR                         ( (reg32 *) CYREG_CSD_CONFIG)
N    #define CapSense_STAT_SEQ_REG                       (*(reg32 *) CYREG_CSD_CONFIG)
N    #define CapSense_STAT_SEQ_PTR                       ( (reg32 *) CYREG_CSD_CONFIG)
N    #define CapSense_IDAC_MOD_REG                       (*(reg32 *) CYREG_CSD_IDACA)
N    #define CapSense_IDAC_MOD_PTR                       ( (reg32 *) CYREG_CSD_IDACA)
N    #define CapSense_IDAC_COMP_REG                      (*(reg32 *) CYREG_CSD_IDACB)
N    #define CapSense_IDAC_COMP_PTR                      ( (reg32 *) CYREG_CSD_IDACB)
N    #define CapSense_IDACB_REG                          (*(reg32 *) CYREG_CSD_IDACB)
N    #define CapSense_IDACB_PTR                          ( (reg32 *) CYREG_CSD_IDACB)
N    #define CapSense_SENSE_PERIOD_REG                   (*(reg32 *) CYREG_CSD_SENSE_PERIOD)
N    #define CapSense_SENSE_PERIOD_PTR                   ( (reg32 *) CYREG_CSD_SENSE_PERIOD)
N    #define CapSense_RESULT_VAL1_REG                    (*(reg32 *) CYREG_CSD_RESULT_VAL1)
N    #define CapSense_RESULT_VAL1_PTR                    ( (reg32 *) CYREG_CSD_RESULT_VAL1)
N    #define CapSense_RESULT_VAL2_REG                    (*(reg32 *) CYREG_CSD_RESULT_VAL2)
N    #define CapSense_RESULT_VAL2_PTR                    ( (reg32 *) CYREG_CSD_RESULT_VAL2)
N    #define CapSense_INTR_REG                           (*(reg32 *) CYREG_CSD_INTR)
N    #define CapSense_INTR_PTR                           ( (reg32 *) CYREG_CSD_INTR)
N    #define CapSense_INTR_SET_REG                       (*(reg32 *) CYREG_CSD_INTR_SET)
N    #define CapSense_INTR_SET_PTR                       ( (reg32 *) CYREG_CSD_INTR_SET)
N    #define CapSense_INTR_MASK_REG                      (*(reg32 *) CYREG_CSD_INTR_MASK)
N    #define CapSense_INTR_MASK_PTR                      ( (reg32 *) CYREG_CSD_INTR_MASK)
N    #define CapSense_COUNTER_REG                        (CapSense_RESULT_VAL1_REG)
N    #define CapSense_COUNTER_PTR                        (CapSense_RESULT_VAL1_PTR)
N    #define CapSense_REFGEN_REG                         (*(reg32 *) CYREG_CSD_REFGEN)
N    #define CapSense_REFGEN_PTR                         ( (reg32 *) CYREG_CSD_REFGEN)
N    #define CapSense_SEQ_TIME_REG                       (*(reg32 *) CYREG_CSD_SEQ_TIME)
N    #define CapSense_SEQ_TIME_PTR                       ( (reg32 *) CYREG_CSD_SEQ_TIME)
N    #define CapSense_SEQ_INIT_CNT_REG                   (*(reg32 *) CYREG_CSD_SEQ_INIT_CNT)
N    #define CapSense_SEQ_INIT_CNT_PTR                   ( (reg32 *) CYREG_CSD_SEQ_INIT_CNT)
N    #define CapSense_SEQ_NORM_CNT_REG                   (*(reg32 *) CYREG_CSD_SEQ_NORM_CNT)
N    #define CapSense_SEQ_NORM_CNT_PTR                   ( (reg32 *) CYREG_CSD_SEQ_NORM_CNT)
N    #define CapSense_SEQ_START_REG                      (*(reg32 *) CYREG_CSD_SEQ_START)
N    #define CapSense_SEQ_START_PTR                      ( (reg32 *) CYREG_CSD_SEQ_START)
N    #define CapSense_CSDCMP_REG                         (*(reg32 *) CYREG_CSD_CSDCMP)
N    #define CapSense_CSDCMP_PTR                         ( (reg32 *) CYREG_CSD_CSDCMP)
N    #define CapSense_HSCMP_REG                          (*(reg32 *) CYREG_CSD_HSCMP)
N    #define CapSense_HSCMP_PTR                          ( (reg32 *) CYREG_CSD_HSCMP)
N    #define CapSense_SENSE_DUTY_REG                     (*(reg32 *) CYREG_CSD_SENSE_DUTY)
N    #define CapSense_SENSE_DUTY_PTR                     ( (reg32 *) CYREG_CSD_SENSE_DUTY)
N    #define CapSense_AMBUF_REG                          (*(reg32 *) CYREG_CSD_AMBUF)
N    #define CapSense_AMBUF_PTR                          ( (reg32 *) CYREG_CSD_AMBUF)
N    #define CapSense_SW_BYP_SEL_REG                     (*(reg32 *) CYREG_CSD_SW_BYP_SEL)
N    #define CapSense_SW_BYP_SEL_PTR                     ( (reg32 *) CYREG_CSD_SW_BYP_SEL)
N    #define CapSense_SW_CMP_P_SEL_REG                   (*(reg32 *) CYREG_CSD_SW_CMP_P_SEL)
N    #define CapSense_SW_CMP_P_SEL_PTR                   ( (reg32 *) CYREG_CSD_SW_CMP_P_SEL)
N    #define CapSense_SW_REFGEN_SEL_REG                  (*(reg32 *) CYREG_CSD_SW_REFGEN_SEL)
N    #define CapSense_SW_REFGEN_SEL_PTR                  ( (reg32 *) CYREG_CSD_SW_REFGEN_SEL)
N    #define CapSense_SW_CMP_N_SEL_REG                   (*(reg32 *) CYREG_CSD_SW_CMP_N_SEL)
N    #define CapSense_SW_CMP_N_SEL_PTR                   ( (reg32 *) CYREG_CSD_SW_CMP_N_SEL)
N    #define CapSense_SW_RES_REG                         (*(reg32 *) CYREG_CSD_SW_RES)
N    #define CapSense_SW_RES_PTR                         ( (reg32 *) CYREG_CSD_SW_RES)
N    #define CapSense_SW_HS_P_SEL_REG                    (*(reg32 *) CYREG_CSD_SW_HS_P_SEL)
N    #define CapSense_SW_HS_P_SEL_PTR                    ( (reg32 *) CYREG_CSD_SW_HS_P_SEL)
N    #define CapSense_SW_SHIELD_SEL_REG                  (*(reg32 *) CYREG_CSD_SW_SHIELD_SEL)
N    #define CapSense_SW_SHIELD_SEL_PTR                  ( (reg32 *) CYREG_CSD_SW_SHIELD_SEL)
N    #define CapSense_SW_AMUXBUF_SEL_REG                 (*(reg32 *) CYREG_CSD_SW_AMUXBUF_SEL)
N    #define CapSense_SW_AMUXBUF_SEL_PTR                 ( (reg32 *) CYREG_CSD_SW_AMUXBUF_SEL)
N    #define CapSense_SW_HS_N_SEL_REG                    (*(reg32 *) CYREG_CSD_SW_HS_N_SEL)
N    #define CapSense_SW_HS_N_SEL_PTR                    ( (reg32 *) CYREG_CSD_SW_HS_N_SEL)
N    #define CapSense_SW_FW_MOD_SEL_REG                  (*(reg32 *) CYREG_CSD_SW_FW_MOD_SEL)
N    #define CapSense_SW_FW_MOD_SEL_PTR                  ( (reg32 *) CYREG_CSD_SW_FW_MOD_SEL)
N    #define CapSense_SW_FW_TANK_SEL_REG                 (*(reg32 *) CYREG_CSD_SW_FW_TANK_SEL)
N    #define CapSense_SW_FW_TANK_SEL_PTR                 ( (reg32 *) CYREG_CSD_SW_FW_TANK_SEL)
N    #define CapSense_SW_DSI_SEL_REG                     (*(reg32 *) CYREG_CSD_SW_DSI_SEL)
N    #define CapSense_SW_DSI_SEL_PTR                     ( (reg32 *) CYREG_CSD_SW_DSI_SEL)
N    #define CapSense_ADC_CTL_REG                        (*(reg32 *) CYREG_CSD_ADC_CTL)
N    #define CapSense_ADC_CTL_PTR                        ( (reg32 *) CYREG_CSD_ADC_CTL)
N    #define CapSense_ADC_RES_REG                        (*(reg32 *) CYREG_CSD_ADC_RES)
N    #define CapSense_ADC_RES_PTR                        ( (reg32 *) CYREG_CSD_ADC_RES)
N
N#else
S
S    /* CSD block registers   */
S    #define CapSense_CONFIG_REG                         (*(reg32 *) CapSense_CSD__CSD_CONFIG)
S    #define CapSense_CONFIG_PTR                         ( (reg32 *) CapSense_CSD__CSD_CONFIG)
S    #define CapSense_IDAC_CONTR_REG                     (*(reg32 *) CapSense_IDACMod_cy_psoc4_idac__CONTROL)
S    #define CapSense_IDAC_CONTR_PTR                     ( (reg32 *) CapSense_IDACMod_cy_psoc4_idac__CONTROL)
S    #define CapSense_IDAC_REG                           (*(reg32 *) CapSense_IDACMod_cy_psoc4_idac__CSD_IDAC)
S    #define CapSense_IDAC_PTR                           ( (reg32 *) CapSense_IDACMod_cy_psoc4_idac__CSD_IDAC)
S    #define CapSense_COUNTER_REG                        (*(reg32 *) CapSense_CSD__CSD_COUNTER)
S    #define CapSense_COUNTER_PTR                        ( (reg32 *) CapSense_CSD__CSD_COUNTER)
S    #define CapSense_STATUS_REG                         (*(reg32 *) CapSense_CSD__CSD_STATUS)
S    #define CapSense_STATUS_PTR                         ( (reg32 *) CapSense_CSD__CSD_STATUS)
S    #define CapSense_INTR_REG                           (*(reg32 *) CapSense_CSD__CSD_INTR)
S    #define CapSense_INTR_PTR                           ( (reg32 *) CapSense_CSD__CSD_INTR)
S    #define CapSense_INTR_SET_REG                       (*(reg32 *) CYREG_CSD_INTR_SET)
S    #define CapSense_INTR_SET_PTR                       ( (reg32 *) CYREG_CSD_INTR_SET)
S    #define CapSense_PWM_REG                            (*(reg32 *) CYREG_CSD_PWM)
S    #define CapSense_PWM_PTR                            ( (reg32 *) CYREG_CSD_PWM)
S    #define CapSense_TRIM1_REG                          (*(reg32 *) CapSense_IDACMod_cy_psoc4_idac__CSD_TRIM1)
S    #define CapSense_TRIM1_PTR                          ( (reg32 *) CapSense_IDACMod_cy_psoc4_idac__CSD_TRIM1)
S    #define CapSense_TRIM2_REG                          (*(reg32 *) CapSense_IDACMod_cy_psoc4_idac__CSD_TRIM2)
S    #define CapSense_TRIM2_PTR                          ( (reg32 *) CapSense_IDACMod_cy_psoc4_idac__CSD_TRIM2)
S
S    #if (CY_PSOC4_4100M || CY_PSOC4_4200M || CY_PSOC4_4200L)
S        #if (1u != CapSense_CSD__CSD_NUMBER)
S            #define CapSense_SFLASH_TRIM1_REG           (*(reg8 *) CYREG_SFLASH_CSD_TRIM1_CSD)
S            #define CapSense_SFLASH_TRIM1_PTR           ( (reg8 *) CYREG_SFLASH_CSD_TRIM1_CSD)
S
S            #define CapSense_SFLASH_TRIM2_REG           (*(reg8 *) CYREG_SFLASH_CSD_TRIM2_CSD)
S            #define CapSense_SFLASH_TRIM2_PTR           ( (reg8 *) CYREG_SFLASH_CSD_TRIM2_CSD)
S        #else
S            #define CapSense_SFLASH_TRIM1_REG           (*(reg8 *) CYREG_SFLASH_CSD1_TRIM1_CSD)
S            #define CapSense_SFLASH_TRIM1_PTR           ( (reg8 *) CYREG_SFLASH_CSD1_TRIM1_CSD)
S
S            #define CapSense_SFLASH_TRIM2_REG           (*(reg8 *) CYREG_SFLASH_CSD1_TRIM2_CSD)
S            #define CapSense_SFLASH_TRIM2_PTR           ( (reg8 *) CYREG_SFLASH_CSD1_TRIM2_CSD)
S        #endif /* (1u != CapSense_CSD__CSD_NUMBER) */
S    #else
S        #define CapSense_SFLASH_TRIM1_REG               (*(reg8 *) CYREG_SFLASH_CSD_TRIM1_CSD)
S        #define CapSense_SFLASH_TRIM1_PTR               ( (reg8 *) CYREG_SFLASH_CSD_TRIM1_CSD)
S
S        #define CapSense_SFLASH_TRIM2_REG               (*(reg8 *) CYREG_SFLASH_CSD_TRIM2_CSD)
S        #define CapSense_SFLASH_TRIM2_PTR               ( (reg8 *) CYREG_SFLASH_CSD_TRIM2_CSD)
S    #endif /* (CY_PSOC4_4100M || CY_PSOC4_4200M || CY_PSOC4_4200L) */
N#endif /* (CapSense_ENABLE == CapSense_CSDV2) */
N
N/* Third-generation and Fourth-generation HW block PERI CLOCK registers */
N#if defined(CYIPBLOCK_m0s8peri_VERSION)
X#if 1L
N    #define CapSense_IS_M0S8PERI_BLOCK                  (1u)
N    #define CapSense_M0S8PERI_BLOCK_VER                 ((CYIPBLOCK_m0s8peri_VERSION))
N#else
S    #define CapSense_IS_M0S8PERI_BLOCK                  (0u)
S    #define CapSense_M0S8PERI_BLOCK_VER                 (0u)
N#endif /* (CYIPBLOCK_m0s8peri_VERSION) */
N
N#if (CapSense_ENABLE == CapSense_IS_M0S8PERI_BLOCK)
X#if ((1u) == (1u))
N    #define CapSense_MODCLK_DIV_REG                     (*(reg32 *)CapSense_ModClk__DIV_REGISTER)
N    #define CapSense_MODCLK_DIV_PTR                     ( (reg32 *)CapSense_ModClk__DIV_REGISTER)
N    #define CapSense_MODCLK_CMD_REG                     (*(reg32 *)CYREG_PERI_DIV_CMD)
N    #define CapSense_MODCLK_CMD_PTR                     ( (reg32 *)CYREG_PERI_DIV_CMD)
N    #if (CapSense_DISABLE == CapSense_CSDV2)
X    #if ((0u) == (1u))
S        #define CapSense_SNSCLK_DIV_REG                 (*(reg32 *)CapSense_SnsClk__DIV_REGISTER)
S        #define CapSense_SNSCLK_DIV_PTR                 ( (reg32 *)CapSense_SnsClk__DIV_REGISTER)
S        #define CapSense_SNSCLK_CMD_REG                 (*(reg32 *)CYREG_PERI_DIV_CMD)
S        #define CapSense_SNSCLK_CMD_PTR                 ( (reg32 *)CYREG_PERI_DIV_CMD)
N    #endif /* (CapSense_DISABLE == CapSense_CSDV2) */
N#else
S    #define CapSense_MODCLK_DIV_REG                     (*(reg32 *)CapSense_ModClk__REGISTER)
S    #define CapSense_MODCLK_DIV_PTR                     ( (reg32 *)CapSense_ModClk__REGISTER)
S    #define CapSense_SNSCLK_DIV_REG                     (*(reg32 *)CapSense_SnsClk__REGISTER)
S    #define CapSense_SNSCLK_DIV_PTR                     ( (reg32 *)CapSense_SnsClk__REGISTER)
S    #define CapSense_MODCLK_CMD_REG                     (CapSense_MODCLK_DIV_REG)
S    #define CapSense_MODCLK_CMD_PTR                     (CapSense_MODCLK_DIV_PTR)
S    #define CapSense_SNSCLK_CMD_REG                     (CapSense_SNSCLK_DIV_REG)
S    #define CapSense_SNSCLK_CMD_PTR                     (CapSense_SNSCLK_DIV_PTR)
N#endif /* (CapSense_ENABLE == CapSense_IS_M0S8PERI_BLOCK) */
N
N/****************************************************************************
N* m0s8csd, m0s8peri, hsiom, and IO hardware-related registers masks
N****************************************************************************/
N#if (CapSense_ENABLE == CapSense_CSDV2)
X#if ((1u) == (1u))
N
N    #if ((CapSense_ENABLE == CapSense_CSD_SHIELD_EN) && \
N         (CapSense_ENABLE == CapSense_CSD_SHIELD_TANK_EN))
X    #if (((1u) == (0u)) &&          ((1u) == (0u)))
S        #define CapSense_CTANK_CONNECTION           (CapSense_CSD__DEDICATED_IO1)
N    #else
N        #define CapSense_CTANK_CONNECTION               (0x00000000uL)
N    #endif /* ((CapSense_ENABLE == CapSense_CSD_SHIELD_EN) && \
N               (CapSense_ENABLE == CapSense_CSD_SHIELD_TANK_EN)) */
X    #endif  
N
N    #if(0u != CapSense_CSX_EN)
X    #if(0u != (0u))
S        #define CapSense_CMOD_CONNECTION                (CapSense_CSD__CSHIELD_PAD)
N    #else
N        #define CapSense_CMOD_CONNECTION                (CapSense_CSD__DEDICATED_IO0)
N    #endif /* (CapSense_CSX_EN == 1u) */
N
N    /* Fourth-generation HW block masks for the resistance or low EMI (slow ramp)  */
N    #define CapSense_RES_LOW                            (0u)
N    #define CapSense_RES_MED                            (1u)
N    #define CapSense_RES_HIGH                           (2u)
N    #define CapSense_RES_LOWEMI                         (3u)
N
N    /* Fourth-generation HW block masks for the waveforms for corresponding switch  */
N    #define CapSense_STATIC_OPEN                        (0x00000000Lu)
N    #define CapSense_STATIC_CLOSE                       (0x00000001Lu)
N    #define CapSense_PHI1                               (0x00000002Lu)
N    #define CapSense_PHI2                               (0x00000003Lu)
N    #define CapSense_PHI1_HSCMP                         (0x00000004Lu)
N    #define CapSense_PHI2_HSCMP                         (0x00000005Lu)
N    #define CapSense_HSCMP                              (0x00000006Lu)
N
N    #define CapSense_SW_DSI_CMOD                        (1uL << 4u)
N    #define CapSense_SW_DSI_CTANK                       (1uL << 0u)
N
N    /* Fourth-generation HW block CSD_CONFIG register masks    */
N    #define CapSense_CONFIG_FILTER_DELAY_MASK           (((0x00000001Lu << CYFLD_CSD_FILTER_DELAY__SIZE) - 1u) << CYFLD_CSD_FILTER_DELAY__OFFSET)
N    #define CapSense_CONFIG_FILTER_DELAY_2_CYCLES       (0x00000002Lu)
N    #define CapSense_CONFIG_FILTER_DELAY_3_CYCLES       (0x00000003Lu)
N    #define CapSense_CONFIG_FILTER_DELAY_4_CYCLES       (0x00000004Lu)
N    #define CapSense_CONFIG_FILTER_DELAY_12MHZ          (CapSense_CONFIG_FILTER_DELAY_2_CYCLES << CYFLD_CSD_FILTER_DELAY__OFFSET)
N    #define CapSense_CONFIG_FILTER_DELAY_24MHZ          (CapSense_CONFIG_FILTER_DELAY_3_CYCLES << CYFLD_CSD_FILTER_DELAY__OFFSET)
N    #define CapSense_CONFIG_FILTER_DELAY_48MHZ          (CapSense_CONFIG_FILTER_DELAY_4_CYCLES << CYFLD_CSD_FILTER_DELAY__OFFSET)
N    #define CapSense_CONFIG_SHIELD_DELAY_MASK           (((0x00000001Lu << CYFLD_CSD_SHIELD_DELAY__SIZE) - 1u) << CYFLD_CSD_SHIELD_DELAY__OFFSET)
N    #define CapSense_CONFIG_SENSE_EN_MASK               (((0x00000001Lu << CYFLD_CSD_SENSE_EN__SIZE) - 1u) << CYFLD_CSD_SENSE_EN__OFFSET)
N    #define CapSense_CONFIG_CHARGE_MODE_MASK            (((0x00000001Lu << CYFLD_CSD_CHARGE_MODE__SIZE) - 1u) << CYFLD_CSD_CHARGE_MODE__OFFSET)
N    #define CapSense_CONFIG_MUTUAL_CAP_MASK             (((0x00000001Lu << CYFLD_CSD_MUTUAL_CAP__SIZE) - 1u) << CYFLD_CSD_MUTUAL_CAP__OFFSET)
N    #define CapSense_CONFIG_CSX_DUAL_CNT_MASK           (((0x00000001Lu << CYFLD_CSD_CSX_DUAL_CNT__SIZE) - 1u) << CYFLD_CSD_CSX_DUAL_CNT__OFFSET)
N    #define CapSense_CONFIG_DSI_COUNT_SEL_MASK          (((0x00000001Lu << CYFLD_CSD_DSI_COUNT_SEL__SIZE) - 1u) << CYFLD_CSD_DSI_COUNT_SEL__OFFSET)
N    #define CapSense_CONFIG_DSI_SAMPLE_EN_MASK          (((0x00000001Lu << CYFLD_CSD_DSI_SAMPLE_EN__SIZE) - 1u) << CYFLD_CSD_DSI_SAMPLE_EN__OFFSET)
N    #define CapSense_CONFIG_SAMPLE_SYNC_MASK            (((0x00000001Lu << CYFLD_CSD_SAMPLE_SYNC__SIZE) - 1u) << CYFLD_CSD_SAMPLE_SYNC__OFFSET)
N    #define CapSense_CONFIG_DSI_SENSE_EN_MASK           (((0x00000001Lu << CYFLD_CSD_DSI_SENSE_EN__SIZE) - 1u) << CYFLD_CSD_DSI_SENSE_EN__OFFSET)
N    #define CapSense_CONFIG_LP_MODE_MASK                (((0x00000001Lu << CYFLD_CSD_LP_MODE__SIZE) - 1u) << CYFLD_CSD_LP_MODE__OFFSET)
N    #define CapSense_CONFIG_ENABLE_MASK                 (((0x00000001Lu << CYFLD_CSD_ENABLE__SIZE) - 1u) << CYFLD_CSD_ENABLE__OFFSET)
N
N    /* Fourth-generation HW block CSD_STATUS register masks    */
N    #define CapSense_STATUS_CSD_CHARGE_MASK             (((0x00000001Lu << CYFLD_CSD_CSD_CHARGE__SIZE) - 1u) << CYFLD_CSD_CSD_CHARGE__OFFSET)
N    #define CapSense_STATUS_CSD_SENSE_MASK              (((0x00000001Lu << CYFLD_CSD_CSD_SENSE__SIZE) - 1u) << CYFLD_CSD_CSD_SENSE__OFFSET)
N    #define CapSense_STATUS_HSCMP_OUT_MASK              (((0x00000001Lu << CYFLD_CSD_HSCMP_OUT__SIZE) - 1u) << CYFLD_CSD_HSCMP_OUT__OFFSET)
N    #define CapSense_STATUS_CSDCMP_OUT_MASK             (((0x00000001Lu << CYFLD_CSD_CSDCMP_OUT__SIZE) - 1u) << CYFLD_CSD_CSDCMP_OUT__OFFSET)
N
N    /* Fourth-generation HW block STAT_SEQ register masks    */
N    #define CapSense_STAT_SEQ_SEQ_STATE_MASK            (((0x00000001Lu << CYFLD_CSD_SEQ_STATE__SIZE) - 1u) << CYFLD_CSD_SEQ_STATE__OFFSET)
N    #define CapSense_STAT_SEQ_ADC_STATE_MASK            (((0x00000001Lu << CYFLD_CSD_ADC_STATE__SIZE) - 1u) << CYFLD_CSD_ADC_STATE__OFFSET)
N
N    /* Fourth-generation HW block sequencer state codes */
N    #define CapSense_STAT_SEQ_IDLE                      (0x00000000Lu << CYFLD_CSD_SEQ_STATE__OFFSET)
N    #define CapSense_STAT_SEQ_INIT_COARSE               (0x00000001Lu << CYFLD_CSD_SEQ_STATE__OFFSET)
N    #define CapSense_STAT_SEQ_AUTO_ZERO_0               (0x00000002Lu << CYFLD_CSD_SEQ_STATE__OFFSET)
N    #define CapSense_STAT_SEQ_SAMPLE_INIT               (0x00000003Lu << CYFLD_CSD_SEQ_STATE__OFFSET)
N    #define CapSense_STAT_SEQ_AUTO_ZERO_1               (0x00000004Lu << CYFLD_CSD_SEQ_STATE__OFFSET)
N    #define CapSense_STAT_SEQ_SAMPLE_NORM               (0x00000005Lu << CYFLD_CSD_SEQ_STATE__OFFSET)
N
N
N    /* Fourth-generation HW block STAT_CNTS register masks    */
N    #define CapSense_STAT_CNTS_NUM_CONV_MASK            (((0x00000001Lu << CYFLD_CSD_NUM_CONV__SIZE) - 1u) << CYFLD_CSD_NUM_CONV__OFFSET)
N
N    /* Fourth-generation HW block RESULT_VAL1 register masks    */
N    #define CapSense_RESULT_VAL1_VALUE_MASK             (((0x00000001Lu << CYFLD_CSD_VALUE__SIZE) - 1u) << CYFLD_CSD_VALUE__OFFSET)
N    #define CapSense_RESULT_VAL1_BAD_CONVS_MASK         (((0x00000001Lu << CYFLD_CSD_BAD_CONVS__SIZE) - 1u) << CYFLD_CSD_BAD_CONVS__OFFSET)
N
N    /* Fourth-generation HW block RESULT_VAL2 register masks    */
N    #define CapSense_RESULT_VAL2_VALUE_MASK             (0x0000FFFFLu)
N
N    /* Fourth-generation HW block INTR register masks    */
N    #define CapSense_INTR_SAMPLE_MASK                   (((0x00000001Lu << CYFLD_CSD_SAMPLE__SIZE) - 1u) << CYFLD_CSD_SAMPLE__OFFSET)
N    #define CapSense_INTR_INIT_MASK                     (((0x00000001Lu << CYFLD_CSD_INIT__SIZE) - 1u) << CYFLD_CSD_INIT__OFFSET)
N    #define CapSense_INTR_ADC_RES_MASK                  (((0x00000001Lu << CYFLD_CSD_ADC_RES__SIZE) - 1u) << CYFLD_CSD_ADC_RES__OFFSET)
N    #define CapSense_CLEAR_MASK                         (0Lu)
N    #define CapSense_INTR_ALL_MASK                      (CapSense_INTR_SAMPLE_MASK | \
N                                                                 CapSense_INTR_INIT_MASK | \
N                                                                 CapSense_INTR_ADC_RES_MASK)
X    #define CapSense_INTR_ALL_MASK                      (CapSense_INTR_SAMPLE_MASK |                                                                  CapSense_INTR_INIT_MASK |                                                                  CapSense_INTR_ADC_RES_MASK)
N
N    /* Fourth-generation HW block INTR_SET register masks    */
N    #define CapSense_INTR_SET_SAMPLE_MASK               (CapSense_INTR_SAMPLE_MASK)
N    #define CapSense_INTR_SET_INIT_MASK                 (CapSense_INTR_INIT_MASK)
N    #define CapSense_INTR_SET_ADC_RES_MASK              (CapSense_INTR_ADC_RES_MASK)
N    #define CapSense_INTR_SET_MASK                      (CapSense_INTR_SET_SAMPLE_MASK | \
N                                                                 CapSense_INTR_SET_INIT_MASK | \
N                                                                 CapSense_INTR_SET_ADC_RES_MASK)
X    #define CapSense_INTR_SET_MASK                      (CapSense_INTR_SET_SAMPLE_MASK |                                                                  CapSense_INTR_SET_INIT_MASK |                                                                  CapSense_INTR_SET_ADC_RES_MASK)
N
N    /* Fourth-generation HW block INTR_MASK register masks    */
N    #define CapSense_INTR_MASK_SAMPLE_MASK              (CapSense_INTR_SAMPLE_MASK)
N    #define CapSense_INTR_MASK_INIT_MASK                (CapSense_INTR_INIT_MASK)
N    #define CapSense_INTR_MASK_ADC_RES_MASK             (CapSense_INTR_ADC_RES_MASK)
N    #define CapSense_INTR_MASK_CLEAR_MASK               (0uL)
N
N
N    /* Fourth-generation HW block HSCMP v2 register masks    */
N    #define CapSense_HSCMP_EN_MASK                      (((0x00000001Lu << CYFLD_CSD_HSCMP_EN__SIZE) - 1u) << CYFLD_CSD_HSCMP_EN__OFFSET)
N    #define CapSense_HSCMP_INVERT_MASK                  (((0x00000001Lu << CYFLD_CSD_HSCMP_INVERT__SIZE) - 1u) << CYFLD_CSD_HSCMP_INVERT__OFFSET)
N    #define CapSense_CSD_AZ_EN_MASK                     (((0x00000001Lu << CYFLD_CSD_AZ_EN__SIZE) - 1u) << CYFLD_CSD_AZ_EN__OFFSET)
N
N    /* Fourth-generation HW block AMBUF v2 register masks    */
N    #define CapSense_AMBUF_AMBUF_EN_MASK                ((0x00000001Lu << CYFLD_CSD_PWR_MODE__SIZE) - 1u)
N    #define CapSense_AMBUF_PWR_MODE_OFF                 (CYVAL_CSD_PWR_MODE_OFF)
N    #define CapSense_AMBUF_PWR_MODE_NORM                (CYVAL_CSD_PWR_MODE_NORM)
N    #define CapSense_AMBUF_PWR_MODE_HI                  (CYVAL_CSD_PWR_MODE_HI)
N
N    /* Fourth-generation HW block REFGEN v2 register masks    */
N    #define CapSense_REFGEN_REFGEN_EN_MASK              ((0x00000001Lu << CYFLD_CSD_REFGEN_EN__SIZE) - 1u)
N    #define CapSense_REFGEN_BYPASS_MASK                 (((0x00000001Lu << CYFLD_CSD_BYPASS__SIZE) - 1u) << CYFLD_CSD_BYPASS__OFFSET)
N    #define CapSense_REFGEN_VDDA_EN_MASK                (((0x00000001Lu << CYFLD_CSD_VDDA_EN__SIZE) - 1u) << CYFLD_CSD_VDDA_EN__OFFSET)
N    #define CapSense_REFGEN_RES_EN_MASK                 (((0x00000001Lu << CYFLD_CSD_RES_EN__SIZE) - 1u) << CYFLD_CSD_RES_EN__OFFSET)
N    #define CapSense_REFGEN_GAIN_MASK                   (((0x00000001Lu << CYFLD_CSD_GAIN__SIZE) - 1u) << CYFLD_CSD_GAIN__OFFSET)
N    #define CapSense_REFGEN_VREFLO_SEL_MASK             (((0x00000001Lu << CYFLD_CSD_VREFLO_SEL__SIZE) - 1u) << CYFLD_CSD_VREFLO_SEL__OFFSET)
N    #define CapSense_REFGEN_VREFLO_INT_MASK             (((0x00000001Lu << CYFLD_CSD_VREFLO_INT__SIZE) - 1u) << CYFLD_CSD_VREFLO_INT__OFFSET)
N
N    /* Fourth-generation HW block IDACA v2 register masks  */
N    #define CapSense_IDAC_MOD_VAL_MASK                  (((0x00000001Lu << CYFLD_CSD_VAL__SIZE) - 1u) << CYFLD_CSD_VAL__OFFSET)
N    #define CapSense_IDAC_MOD_POLARITY_MASK             (((0x00000001Lu << CYFLD_CSD_POLARITY__SIZE) - 1u) << CYFLD_CSD_POLARITY__OFFSET)
N    #define CapSense_IDAC_MOD_POLARITY_VSSA_SRC         ((uint32)CYVAL_CSD_POLARITY_VSSA_SRC)
N    #define CapSense_IDAC_MOD_POLARITY_VDDA_SNK         ((uint32)CYVAL_CSD_POLARITY_VDDA_SNK)
N    #define CapSense_IDAC_MOD_POLARITY_SENSE            ((uint32)CYVAL_CSD_POLARITY_SENSE)
N    #define CapSense_IDAC_MOD_POLARITY_SENSE_INV        ((uint32)CYVAL_CSD_POLARITY_SENSE_INV)
N    #define CapSense_IDAC_MOD_POL_DYN_MASK              (((0x00000001Lu << CYFLD_CSD_POL_DYN__SIZE) - 1u) << CYFLD_CSD_POL_DYN__OFFSET)
N    #define CapSense_IDAC_MOD_BALL_MODE_MASK             (((0x00000001Lu << CYFLD_CSD_BAL_MODE__SIZE) - 1u) << CYFLD_CSD_BAL_MODE__OFFSET)
N    #define CapSense_IDAC_MOD_BALL_MODE_FULL            (CYVAL_CSD_BAL_MODE_FULL)
N    #define CapSense_IDAC_MOD_LEG1_MODE_MASK            (((0x00000001Lu << CYFLD_CSD_LEG1_MODE__SIZE) - 1u) << CYFLD_CSD_LEG1_MODE__OFFSET)
N    #define CapSense_IDAC_MOD_LEG1_MODE_GP_STATIC_MASK  (CYVAL_CSD_LEG1_MODE_GP_STATIC)
N    #define CapSense_IDAC_MOD_LEG1_MODE_GP_MASK         ((uint32)CYVAL_CSD_LEG1_MODE_GP << CYFLD_CSD_LEG1_MODE__OFFSET)
N    #define CapSense_IDAC_MOD_LEG1_MODE_CSD_STATIC      ((uint32)CYVAL_CSD_LEG1_MODE_CSD_STATIC)
N    #define CapSense_IDAC_MOD_LEG1_MODE_CSD_STATIC_MASK ((uint32)CYVAL_CSD_LEG1_MODE_CSD_STATIC << CYFLD_CSD_LEG1_MODE__OFFSET)
N    #define CapSense_IDAC_MOD_LEG1_MODE_CSD             (0x00000003Lu)
N    #define CapSense_IDAC_MOD_LEG1_MODE_CSD_MASK        (0x00000003Lu << CYFLD_CSD_LEG1_MODE__OFFSET)
N    #define CapSense_IDAC_MOD_LEG2_MODE_MASK            (((0x00000001Lu << CYFLD_CSD_LEG2_MODE__SIZE) - 1u) << CYFLD_CSD_LEG2_MODE__OFFSET)
N    #define CapSense_IDAC_MOD_LEG2_MODE_GP_STATIC       (CYVAL_CSD_LEG2_MODE_GP_STATIC)
N    #define CapSense_IDAC_MOD_LEG2_MODE_GP_STATIC_MASK  (CYVAL_CSD_LEG2_MODE_GP_STATIC << CYFLD_CSD_LEG2_MODE__OFFSET)
N    #define CapSense_IDAC_MOD_LEG2_MODE_GP_MASK         ((uint32)CYVAL_CSD_LEG2_MODE_GP << CYFLD_CSD_LEG2_MODE__OFFSET)
N    #define CapSense_IDAC_MOD_LEG2_MODE_CSD_STATIC_MASK (0x00000002Lu << CYFLD_CSD_LEG2_MODE__OFFSET)
N    #define CapSense_IDAC_MOD_LEG2_MODE_CSD_MASK        ((uint32)CYVAL_CSD_LEG2_MODE_CSD << CYFLD_CSD_LEG2_MODE__OFFSET)
N    #define CapSense_IDAC_MOD_BAL_MODE_PHI1             ((uint32)CYVAL_CSD_BAL_MODE_PHI1)
N    #define CapSense_IDAC_MOD_DSI_CTRL_EN_MASK          (0x00200000Lu)
N    #define CapSense_IDAC_MOD_RANGE_MASK                (0x00C00000Lu)
N    #define CapSense_IDAC_MOD_RANGE_IDAC_LO             (CYVAL_CSD_RANGE_IDAC_LO)
N    #define CapSense_IDAC_MOD_RANGE_IDAC_LO_MASK        (0x00000000Lu)
N    #define CapSense_IDAC_MOD_RANGE_IDAC_MED            (CYVAL_CSD_RANGE_IDAC_MED)
N    #define CapSense_IDAC_MOD_RANGE_IDAC_MED_MASK       (0x00400000Lu)
N    #define CapSense_IDAC_MOD_RANGE_IDAC_HI             (CYVAL_CSD_RANGE_IDAC_HI)
N    #define CapSense_IDAC_MOD_RANGE_IDAC_HI_MASK        (0x00800000Lu)
N    #define CapSense_IDAC_MOD_LEG1_EN_MASK              (0x01000000Lu)
N    #define CapSense_IDAC_MOD_LEG2_EN_MASK              (0x02000000Lu)
N
N    /* Fourth-generation HW block IDACB v2 register masks  */
N    #define CapSense_IDAC_COMP_VAL_MASK                  (((0x00000001Lu << CYFLD_CSD_VAL__SIZE) - 1u) << CYFLD_CSD_VAL__OFFSET)
N    #define CapSense_IDAC_COMP_POLARITY_MASK             (((0x00000001Lu << CYFLD_CSD_POLARITY__SIZE) - 1u) << CYFLD_CSD_POLARITY__OFFSET)
N    #define CapSense_IDAC_COMP_POLARITY_VSSA_SRC         ((uint32)CYVAL_CSD_POLARITY_VSSA_SRC)
N    #define CapSense_IDAC_COMP_POLARITY_VDDA_SNK         ((uint32)CYVAL_CSD_POLARITY_VDDA_SNK)
N    #define CapSense_IDAC_COMP_POLARITY_SENSE            ((uint32)CYVAL_CSD_POLARITY_SENSE)
N    #define CapSense_IDAC_COMP_POLARITY_SENSE_INV        ((uint32)CYVAL_CSD_POLARITY_SENSE_INV)
N    #define CapSense_IDAC_COMP_POL_DYN_MASK              (((0x00000001Lu << CYFLD_CSD_POL_DYN__SIZE) - 1u) << CYFLD_CSD_POL_DYN__OFFSET)
N    #define CapSense_IDAC_COMP_POL_DYN_STATIC            (0uL)
N    #define CapSense_IDAC_COMP_POL_DYN_DYNAMIC           (1uL)
N    #define CapSense_IDAC_COMP_BALL_MODE_MASK            (((0x00000001Lu << CYFLD_CSD_BAL_MODE__SIZE) - 1u) << CYFLD_CSD_BAL_MODE__OFFSET)
N    #define CapSense_IDAC_COMP_BALL_MODE_FULL            (CYVAL_CSD_BAL_MODE_FULL)
N    #define CapSense_IDAC_COMP_LEG1_MODE_MASK            (((0x00000001Lu << CYFLD_CSD_LEG1_MODE__SIZE) - 1u) << CYFLD_CSD_LEG1_MODE__OFFSET)
N    #define CapSense_IDAC_COMP_LEG1_MODE_GP_STATIC       (CYVAL_CSD_LEG1_MODE_GP_STATIC)
N    #define CapSense_IDAC_COMP_LEG1_MODE_GP_STATIC_MASK  (CYVAL_CSD_LEG1_MODE_GP_STATIC << CYFLD_CSD_LEG1_MODE__OFFSET)
N    #define CapSense_IDAC_COMP_LEG1_MODE_GP_MASK         ((uint32)CYVAL_CSD_LEG1_MODE_GP << CYFLD_CSD_LEG1_MODE__OFFSET)
N    #define CapSense_IDAC_COMP_LEG1_MODE_CSD_STATIC      ((uint32)CYVAL_CSD_LEG1_MODE_CSD_STATIC)
N    #define CapSense_IDAC_COMP_LEG1_MODE_CSD_STATIC_MASK ((uint32)CYVAL_CSD_LEG1_MODE_CSD_STATIC << CYFLD_CSD_LEG1_MODE__OFFSET)
N    #define CapSense_IDAC_COMP_LEG1_MODE_CSD             (0x00000003Lu)
N    #define CapSense_IDAC_COMP_LEG1_MODE_CSD_MASK        (0x00000003Lu << CYFLD_CSD_LEG1_MODE__OFFSET)
N    #define CapSense_IDAC_COMP_LEG2_MODE_MASK            (((0x00000001Lu << CYFLD_CSD_LEG2_MODE__SIZE) - 1u) << CYFLD_CSD_LEG2_MODE__OFFSET)
N    #define CapSense_IDAC_COMP_LEG2_MODE_GP_STATIC       ((uint32)CYVAL_CSD_LEG2_MODE_GP_STATIC)
N    #define CapSense_IDAC_COMP_LEG2_MODE_GP_STATIC_MASK  (CYVAL_CSD_LEG2_MODE_GP_STATIC)
N    #define CapSense_IDAC_COMP_LEG2_MODE_GP_MASK         ((uint32)CYVAL_CSD_LEG2_MODE_GP << CYFLD_CSD_LEG2_MODE__OFFSET)
N    #define CapSense_IDAC_COMP_LEG2_MODE_CSD_STATIC      (0x00000002Lu)
N    #define CapSense_IDAC_COMP_LEG2_MODE_CSD_STATIC_MASK (0x00000002Lu << CYFLD_CSD_LEG2_MODE__OFFSET)
N    #define CapSense_IDAC_COMP_LEG2_MODE_CSD_MASK        ((uint32)CYVAL_CSD_LEG2_MODE_CSD << CYFLD_CSD_LEG2_MODE__OFFSET)
N    #define CapSense_IDAC_COMP_DSI_CTRL_EN_MASK          (0x00200000Lu)
N    #define CapSense_IDAC_COMP_RANGE_MASK                (0x00C00000Lu)
N    #define CapSense_IDAC_COMP_RANGE_IDAC_LO             (CYVAL_CSD_RANGE_IDAC_LO)
N    #define CapSense_IDAC_COMP_RANGE_IDAC_LO_MASK        (0x00000000Lu)
N    #define CapSense_IDAC_COMP_RANGE_IDAC_MED            (CYVAL_CSD_RANGE_IDAC_MED)
N    #define CapSense_IDAC_COMP_RANGE_IDAC_MED_MASK       (0x00400000Lu)
N    #define CapSense_IDAC_COMP_RANGE_IDAC_HI             (CYVAL_CSD_RANGE_IDAC_HI)
N    #define CapSense_IDAC_COMP_RANGE_IDAC_HI_MASK        (0x00800000Lu)
N    #define CapSense_IDAC_COMP_LEG1_EN_MASK              (0x01000000Lu)
N    #define CapSense_IDAC_COMP_LEG2_EN_MASK              (0x02000000Lu)
N    #define CapSense_IDAC_COMP_LEG3_EN_MASK              (0x04000000Lu)
N
N    /* Fourth-generation HW block SENSE_PERIOD register masks  */
N    #define CapSense_SENSE_PERIOD_SENSE_DIV_MASK        (((0x00000001Lu << CYFLD_CSD_SENSE_DIV__SIZE) - 1u) << CYFLD_CSD_SENSE_DIV__OFFSET)
N    #define CapSense_SENSE_PERIOD_LFSR_SIZE_MASK        (((0x00000001Lu << CYFLD_CSD_LFSR_SIZE__SIZE) - 1u) << CYFLD_CSD_LFSR_SIZE__OFFSET)
N    #define CapSense_SENSE_PERIOD_LFSR_SCALE_MASK       (((0x00000001Lu << CYFLD_CSD_LFSR_SCALE__SIZE) - 1u) << CYFLD_CSD_LFSR_SCALE__OFFSET)
N    #define CapSense_SENSE_PERIOD_LFSR_CLEAR_MASK       (((0x00000001Lu << CYFLD_CSD_LFSR_CLEAR__SIZE) - 1u) << CYFLD_CSD_LFSR_CLEAR__OFFSET)
N    #define CapSense_SENSE_PERIOD_SEL_LFSR_MSB_MASK     (((0x00000001Lu << CYFLD_CSD_SEL_LFSR_MSB__SIZE) - 1u) << CYFLD_CSD_SEL_LFSR_MSB__OFFSET)
N    #define CapSense_SENSE_6MHZ                         (6u)
N    #define CapSense_SENSE_PERIOD_SENSE_DIV_6MHZ        (CYDEV_BCLK__HFCLK__KHZ/CapSense_CSD_SCANSPEED_DIVIDER/CapSense_SENSE_6MHZ)
N
N    /* Fourth-generation HW block SW_BYP_SEL register masks  */
N    #define CapSense_SW_BYP_SEL_SW_BYA_MASK             (((0x00000001Lu << CYFLD_CSD_SW_BYA__SIZE) - 1u) << CYFLD_CSD_SW_BYA__OFFSET)
N    #define CapSense_SW_BYP_SEL_SW_BYB_MASK             (((0x00000001Lu << CYFLD_CSD_SW_BYB__SIZE) - 1u) << CYFLD_CSD_SW_BYB__OFFSET)
N    #define CapSense_SW_BYP_SEL_SW_CBCC_MASK            (((0x00000001Lu << CYFLD_CSD_SW_CBCC__SIZE) - 1u) << CYFLD_CSD_SW_CBCC__OFFSET)
N
N    /* Fourth-generation HW block SW_REFGEN_SEL register masks  */
N    #define CapSense_SW_REFGEN_SEL_SW_IAIB_MASK         (((0x00000001Lu << CYFLD_CSD_SW_IAIB__SIZE) - 1u) << CYFLD_CSD_SW_IAIB__OFFSET)
N    #define CapSense_SW_REFGEN_SEL_SW_IBCB_MASK         (((0x00000001Lu << CYFLD_CSD_SW_IBCB__SIZE) - 1u) << CYFLD_CSD_SW_IBCB__OFFSET)
N    #define CapSense_SW_REFGEN_SEL_SW_SGMB_MASK         (((0x00000001Lu << CYFLD_CSD_SW_SGMB__SIZE) - 1u) << CYFLD_CSD_SW_SGMB__OFFSET)
N    #define CapSense_SW_REFGEN_SEL_SW_SGRE_MASK         (((0x00000001Lu << CYFLD_CSD_SW_SGRE__SIZE) - 1u) << CYFLD_CSD_SW_SGRE__OFFSET)
N    #define CapSense_SW_REFGEN_SEL_SW_SGR_MASK          (((0x00000001Lu << CYFLD_CSD_SW_SGR__SIZE) - 1u) << CYFLD_CSD_SW_SGR__OFFSET)
N    #define CapSense_SW_REFGEN_SEL_SW_MASK              (CapSense_SW_REFGEN_SEL_SW_IAIB_MASK |\
N                                                                 CapSense_SW_REFGEN_SEL_SW_IBCB_MASK |\
N                                                                 CapSense_SW_REFGEN_SEL_SW_SGMB_MASK |\
N                                                                 CapSense_SW_REFGEN_SEL_SW_SGRE_MASK |\
N                                                                 CapSense_SW_REFGEN_SEL_SW_SGR_MASK)
X    #define CapSense_SW_REFGEN_SEL_SW_MASK              (CapSense_SW_REFGEN_SEL_SW_IAIB_MASK |                                                                 CapSense_SW_REFGEN_SEL_SW_IBCB_MASK |                                                                 CapSense_SW_REFGEN_SEL_SW_SGMB_MASK |                                                                 CapSense_SW_REFGEN_SEL_SW_SGRE_MASK |                                                                 CapSense_SW_REFGEN_SEL_SW_SGR_MASK)
N
N    /* Fourth-generation HW block SW_CMP_N_SEL register masks  */
N    #define CapSense_SW_CMP_N_SEL_SW_SCRH_MASK          (((0x00000001Lu << CYFLD_CSD_SW_SCRH__SIZE) - 1u) << CYFLD_CSD_SW_SCRH__OFFSET)
N    #define CapSense_SW_CMP_N_SEL_SW_SCRH_STATIC_OPEN   (CapSense_STATIC_OPEN << CYFLD_CSD_SW_SCRH__OFFSET)
N    #define CapSense_SW_CMP_N_SEL_SW_SCRH_STATIC_CLOSE  (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_SCRH__OFFSET)
N    #define CapSense_SW_CMP_N_SEL_SW_SCRL_MASK          (((0x00000001Lu << CYFLD_CSD_SW_SCRL__SIZE) - 1u) << CYFLD_CSD_SW_SCRL__OFFSET)
N    #define CapSense_SW_CMP_N_SEL_SW_SCRL_STATIC_OPEN   (CapSense_STATIC_OPEN << CYFLD_CSD_SW_SCRL__OFFSET)
N    #define CapSense_SW_CMP_N_SEL_SW_SCRL_STATIC_CLOSE  (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_SCRL__OFFSET)
N
N    /* Fourth-generation HW block SEQ_TIME register masks  */
N    #define CapSense_SEQ_TIME_AZ_TIME_MASK              (((0x00000001Lu << CYFLD_CSD_AZ_TIME__SIZE) - 1u) << CYFLD_CSD_AZ_TIME__OFFSET)
N
N    /* Fourth-generation HW block SEQ_INIT_CNT register masks  */
N    #define CapSense_SEQ_INIT_CNT_CONV_CNT_MASK         (((0x00000001Lu << CYFLD_CSD_CONV_CNT__SIZE) - 1u) << CYFLD_CSD_CONV_CNT__OFFSET)
N
N    /* Fourth-generation HW block SEQ_NORM_CNT register masks  */
N    #define CapSense_SEQ_NORM_CNT_CONV_CNT_MASK         (((0x00000001Lu << CYFLD_CSD_CONV_CNT__SIZE) - 1u) << CYFLD_CSD_CONV_CNT__OFFSET)
N
N    /* Fourth-generation HW block SW_RES register masks  */
N    #define CapSense_SW_RES_RES_HCAV_MASK               (((0x00000001Lu << CYFLD_CSD_RES_HCAV__SIZE) - 1u) << CYFLD_CSD_RES_HCAV__OFFSET)
N    #define CapSense_SW_RES_RES_HCAG_MASK               (((0x00000001Lu << CYFLD_CSD_RES_HCAG__SIZE) - 1u) << CYFLD_CSD_RES_HCAG__OFFSET)
N    #define CapSense_SW_RES_RES_HCBV_MASK               (((0x00000001Lu << CYFLD_CSD_RES_HCBV__SIZE) - 1u) << CYFLD_CSD_RES_HCBV__OFFSET)
N    #define CapSense_SW_RES_RES_HCBG_MASK               (((0x00000001Lu << CYFLD_CSD_RES_HCBG__SIZE) - 1u) << CYFLD_CSD_RES_HCBG__OFFSET)
N    #define CapSense_SW_RES_RES_F1PM_MASK               (((0x00000001Lu << CYFLD_CSD_RES_F1PM__SIZE) - 1u) << CYFLD_CSD_RES_F1PM__OFFSET)
N    #define CapSense_SW_RES_RES_F2PT_MASK               (((0x00000001Lu << CYFLD_CSD_RES_F2PT__SIZE) - 1u) << CYFLD_CSD_RES_F2PT__OFFSET)
N
N    #define CapSense_SW_RES_RES_DEFAULT                 ((CapSense_CSD_INIT_SWITCH_RES << CYFLD_CSD_RES_HCAV__OFFSET) | \
N                                                                 (CapSense_CSD_SHIELD_SWITCH_RES << CYFLD_CSD_RES_HCBV__OFFSET))
X    #define CapSense_SW_RES_RES_DEFAULT                 ((CapSense_CSD_INIT_SWITCH_RES << CYFLD_CSD_RES_HCAV__OFFSET) |                                                                  (CapSense_CSD_SHIELD_SWITCH_RES << CYFLD_CSD_RES_HCBV__OFFSET))
N
N    /* Fourth-generation HW block SW_HS_P_SEL register masks  */
N    #define CapSense_SW_HS_P_SEL_SW_HMPM_MASK           (((0x00000001Lu << CYFLD_CSD_SW_HMPM__SIZE) - 1u) << CYFLD_CSD_SW_HMPM__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMPM_STATIC_OPEN    (CapSense_STATIC_OPEN << CYFLD_CSD_SW_HMPM__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMPM_STATIC_CLOSE   (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_HMPM__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMPT_MASK           (((0x00000001Lu << CYFLD_CSD_SW_HMPT__SIZE) - 1u) << CYFLD_CSD_SW_HMPT__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMPT_STATIC_OPEN    (CapSense_STATIC_OPEN << CYFLD_CSD_SW_HMPT__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMPT_STATIC_CLOSE   (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_HMPT__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMPS_MASK           (((0x00000001Lu << CYFLD_CSD_SW_HMPS__SIZE) - 1u) << CYFLD_CSD_SW_HMPS__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMPS_STATIC_OPEN    (CapSense_STATIC_OPEN << CYFLD_CSD_SW_HMPS__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMPS_STATIC_CLOSE   (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_HMPS__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMMA_MASK           (((0x00000001Lu << CYFLD_CSD_SW_HMMA__SIZE) - 1u) << CYFLD_CSD_SW_HMMA__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMMA_STATIC_OPEN    (CapSense_STATIC_OPEN << CYFLD_CSD_SW_HMMA__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMMA_STATIC_CLOSE   (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_HMMA__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMMB_MASK           (((0x00000001Lu << CYFLD_CSD_SW_HMMB__SIZE) - 1u) << CYFLD_CSD_SW_HMMB__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMMB_STATIC_OPEN    (CapSense_STATIC_OPEN << CYFLD_CSD_SW_HMMB__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMMB_STATIC_CLOSE   (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_HMMB__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMCA_MASK           (((0x00000001Lu << CYFLD_CSD_SW_HMCA__SIZE) - 1u) << CYFLD_CSD_SW_HMCA__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMCA_STATIC_OPEN    (CapSense_STATIC_OPEN << CYFLD_CSD_SW_HMCA__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMCA_STATIC_CLOSE   (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_HMCA__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMCB_MASK           (((0x00000001Lu << CYFLD_CSD_SW_HMCB__SIZE) - 1u) << CYFLD_CSD_SW_HMCB__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMCB_STATIC_OPEN    (CapSense_STATIC_OPEN << CYFLD_CSD_SW_HMCB__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMCB_STATIC_CLOSE   (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_HMCB__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMRH_MASK           (((0x00000001Lu << CYFLD_CSD_SW_HMRH__SIZE) - 1u) << CYFLD_CSD_SW_HMRH__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMRH_STATIC_OPEN    (CapSense_STATIC_OPEN << CYFLD_CSD_SW_HMRH__OFFSET)
N    #define CapSense_SW_HS_P_SEL_SW_HMRH_STATIC_CLOSE   (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_HMRH__OFFSET)
N
N    /* Fourth-generation HW block SW_SHIELD_SEL register masks  */
N    #define CapSense_SW_SHIELD_SEL_SW_HCAV_MASK         (((0x00000001Lu << CYFLD_CSD_SW_HCAV__SIZE) - 1u) << CYFLD_CSD_SW_HCAV__OFFSET)
N    #define CapSense_SW_SHIELD_SEL_SW_HCAV_STATIC_OPEN  (CapSense_STATIC_OPEN)
N    #define CapSense_SW_SHIELD_SEL_SW_HCAV_HSCMP        (CapSense_HSCMP)
N    #define CapSense_SW_SHIELD_SEL_SW_HCAG_MASK         (((0x00000001Lu << CYFLD_CSD_SW_HCAG__SIZE) - 1u) << CYFLD_CSD_SW_HCAG__OFFSET)
N    #define CapSense_SW_SHIELD_SEL_SW_HCBV_MASK         (((0x00000001Lu << CYFLD_CSD_SW_HCBV__SIZE) - 1u) << CYFLD_CSD_SW_HCBV__OFFSET)
N    #define CapSense_SW_SHIELD_SEL_SW_HCBV_HSCMP        (CapSense_HSCMP << CYFLD_CSD_SW_HCBV__OFFSET)
N    #define CapSense_SW_SHIELD_SEL_SW_HCBV_PHI1         (CapSense_PHI1 << CYFLD_CSD_SW_HCBV__OFFSET)
N    #define CapSense_SW_SHIELD_SEL_SW_HCBV_PHI2         (CapSense_PHI2 << CYFLD_CSD_SW_HCBV__OFFSET)
N    #define CapSense_SW_SHIELD_SEL_SW_HCBV_PHI1_HSCMP   (CapSense_PHI1_HSCMP << CYFLD_CSD_SW_HCBV__OFFSET)
N    #define CapSense_SW_SHIELD_SEL_SW_HCBV_PHI2_HSCMP   (CapSense_PHI2_HSCMP << CYFLD_CSD_SW_HCBV__OFFSET)
N    #define CapSense_SW_SHIELD_SEL_SW_HCBV_STATIC_OPEN  (CapSense_STATIC_OPEN << CYFLD_CSD_SW_HCBV__OFFSET)
N    #define CapSense_SW_SHIELD_SEL_SW_HCBV_STATIC_CLOSE (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_HCBV__OFFSET)
N    #define CapSense_SW_SHIELD_SEL_SW_HCBG_MASK         (((0x00000001Lu << CYFLD_CSD_SW_HCBG__SIZE) - 1u) << CYFLD_CSD_SW_HCBG__OFFSET)
N    #define CapSense_SW_SHIELD_SEL_SW_HCBG_HSCMP        (CapSense_HSCMP << CYFLD_CSD_SW_HCBG__OFFSET)
N    #define CapSense_SW_SHIELD_SEL_SW_HCBG_PHI1         (CapSense_PHI1 << CYFLD_CSD_SW_HCBG__OFFSET)
N    #define CapSense_SW_SHIELD_SEL_SW_HCBG_PHI2         (CapSense_PHI2 << CYFLD_CSD_SW_HCBG__OFFSET)
N    #define CapSense_SW_SHIELD_SEL_SW_HCBG_PHI1_HSCMP   (CapSense_PHI1_HSCMP << CYFLD_CSD_SW_HCBG__OFFSET)
N    #define CapSense_SW_SHIELD_SEL_SW_HCBG_PHI2_HSCMP   (CapSense_PHI2_HSCMP << CYFLD_CSD_SW_HCBG__OFFSET)
N    #define CapSense_SW_SHIELD_SEL_SW_HCBG_STATIC_OPEN  (CapSense_STATIC_OPEN << CYFLD_CSD_SW_HCBG__OFFSET)
N    #define CapSense_SW_SHIELD_SEL_SW_HCCV_MASK         (((0x00000001Lu << CYFLD_CSD_SW_HCCV__SIZE) - 1u) << CYFLD_CSD_SW_HCCV__OFFSET)
N    #define CapSense_SW_SHIELD_SEL_SW_HCCG_MASK         (((0x00000001Lu << CYFLD_CSD_SW_HCCG__SIZE) - 1u) << CYFLD_CSD_SW_HCCG__OFFSET)
N
N    /* Fourth-generation HW block SEQ_START register masks  */
N    #define CapSense_SEQ_START_START_MASK               (((0x00000001Lu << CYFLD_CSD_START__SIZE) - 1u) << CYFLD_CSD_START__OFFSET)
N    #define CapSense_SEQ_START_SEQ_MODE_MASK            (((0x00000001Lu << CYFLD_CSD_SEQ_MODE__SIZE) - 1u) << CYFLD_CSD_SEQ_MODE__OFFSET)
N    #define CapSense_SEQ_START_ABORT_MASK               (((0x00000001Lu << CYFLD_CSD_ABORT__SIZE) - 1u) << CYFLD_CSD_ABORT__OFFSET)
N    #define CapSense_SEQ_START_DSI_START_EN_MASK        (((0x00000001Lu << CYFLD_CSD_DSI_START_EN__SIZE) - 1u) << CYFLD_CSD_DSI_START_EN__OFFSET)
N    #define CapSense_SEQ_START_AZ0_SKIP_MASK            (((0x00000001Lu << CYFLD_CSD_AZ0_SKIP__SIZE) - 1u) << CYFLD_CSD_AZ0_SKIP__OFFSET)
N    #define CapSense_SEQ_START_AZ1_SKIP_MASK            (((0x00000001Lu << CYFLD_CSD_AZ1_SKIP__SIZE) - 1u) << CYFLD_CSD_AZ1_SKIP__OFFSET)
N
N    /* Fourth-generation HW block SW_CMP_P_SEL register masks  */
N    #define CapSense_SW_CMP_P_SEL_SW_SFPM_MASK          (((0x00000001Lu << CYFLD_CSD_SW_SFPM__SIZE) - 1u) << CYFLD_CSD_SW_SFPM__OFFSET)
N    #define CapSense_SW_CMP_P_SEL_SW_SFPM_STATIC_OPEN   (CapSense_STATIC_OPEN << CYFLD_CSD_SW_SFPM__OFFSET)
N    #define CapSense_SW_CMP_P_SEL_SW_SFPM_STATIC_CLOSE  (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_SFPM__OFFSET)
N    #define CapSense_SW_CMP_P_SEL_SW_SFPT_MASK          (((0x00000001Lu << CYFLD_CSD_SW_SFPT__SIZE) - 1u) << CYFLD_CSD_SW_SFPT__OFFSET)
N    #define CapSense_SW_CMP_P_SEL_SW_SFPT_STATIC_OPEN   (CapSense_STATIC_OPEN << CYFLD_CSD_SW_SFPT__OFFSET)
N    #define CapSense_SW_CMP_P_SEL_SW_SFPT_STATIC_CLOSE  (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_SFPT__OFFSET)
N    #define CapSense_SW_CMP_P_SEL_SW_SFPS_MASK          (((0x00000001Lu << CYFLD_CSD_SW_SFPS__SIZE) - 1u) << CYFLD_CSD_SW_SFPS__OFFSET)
N    #define CapSense_SW_CMP_P_SEL_SW_SFPS_STATIC_OPEN   (CapSense_STATIC_OPEN << CYFLD_CSD_SW_SFPS__OFFSET)
N    #define CapSense_SW_CMP_P_SEL_SW_SFPS_STATIC_CLOSE  (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_SFPS__OFFSET)
N    #define CapSense_SW_CMP_P_SEL_SW_SFMA_MASK          (((0x00000001Lu << CYFLD_CSD_SW_SFMA__SIZE) - 1u) << CYFLD_CSD_SW_SFMA__OFFSET)
N    #define CapSense_SW_CMP_P_SEL_SW_SFMA_STATIC_OPEN   (CapSense_STATIC_OPEN << CYFLD_CSD_SW_SFMA__OFFSET)
N    #define CapSense_SW_CMP_P_SEL_SW_SFMA_STATIC_CLOSE  (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_SFMA__OFFSET)
N    #define CapSense_SW_CMP_P_SEL_SW_SFMB_MASK          (((0x00000001Lu << CYFLD_CSD_SW_SFMB__SIZE) - 1u) << CYFLD_CSD_SW_SFMB__OFFSET)
N    #define CapSense_SW_CMP_P_SEL_SW_SFCA_MASK          (((0x00000001Lu << CYFLD_CSD_SW_SFCA__SIZE) - 1u) << CYFLD_CSD_SW_SFCA__OFFSET)
N    #define CapSense_SW_CMP_P_SEL_SW_SFCB_MASK          (((0x00000001Lu << CYFLD_CSD_SW_SFCB__SIZE) - 1u) << CYFLD_CSD_SW_SFCB__OFFSET)
N
N    /* Fourth-generation HW block CSDCMP register masks    */
N    #define CapSense_CSDCMP_CSDCMP_DISABLED             (0uL)
N    #define CapSense_CSDCMP_CSDCMP_EN_MASK              (((0x00000001Lu << CYFLD_CSD_CSDCMP_EN__SIZE) - 1u) << CYFLD_CSD_CSDCMP_EN__OFFSET)
N    #define CapSense_CSDCMP_POLARITY_SEL_MASK           (((0x00000001Lu << CYFLD_CSD_POLARITY_SEL__SIZE) - 1u) << CYFLD_CSD_POLARITY_SEL__OFFSET)
N    #define CapSense_CSDCMP_FEEDBACK_MODE_MASK          (((0x00000001Lu << CYFLD_CSD_FEEDBACK_MODE__SIZE) - 1u) << CYFLD_CSD_FEEDBACK_MODE__OFFSET)
N    #define CapSense_CSDCMP_AZ_EN_MASK                  (((0x00000001Lu << CYFLD_CSD_AZ_EN__SIZE) - 1u) << CYFLD_CSD_AZ_EN__OFFSET)
N
N    /* Fourth-generation HW block SENSE_DUTY register masks  */
N    #define CapSense_SENSE_DUTY_SENSE_WIDTH_MASK        (((0x00000001Lu << CYFLD_CSD_SENSE_WIDTH__SIZE) - 1u) << CYFLD_CSD_SENSE_WIDTH__OFFSET)
N    #define CapSense_SENSE_DUTY_SENSE_POL_MASK          (((0x00000001Lu << CYFLD_CSD_SENSE_POL__SIZE) - 1u) << CYFLD_CSD_SENSE_POL__OFFSET)
N    #define CapSense_SENSE_DUTY_SENSE_POL_PHI_LOW       (0uL)
N    #define CapSense_SENSE_DUTY_SENSE_POL_PHI_HIGH      (CapSense_SENSE_DUTY_SENSE_POL_MASK)
N    #define CapSense_SENSE_DUTY_OVERLAP_PHI1_MASK       (((0x00000001Lu << CYFLD_CSD_OVERLAP_PHI1__SIZE) - 1u) << CYFLD_CSD_OVERLAP_PHI1__OFFSET)
N    #define CapSense_SENSE_DUTY_OVERLAP_PHI2_MASK       (((0x00000001Lu << CYFLD_CSD_OVERLAP_PHI2__SIZE) - 1u) << CYFLD_CSD_OVERLAP_PHI2__OFFSET)
N
N    /* Fourth-generation HW block SW_AMUXBUF_SEL register masks  */
N    #define CapSense_SW_AMUXBUF_SEL_SW_IRBY_MASK        (((0x00000001Lu << CYFLD_CSD_SW_IRBY__SIZE) - 1u) << CYFLD_CSD_SW_IRBY__OFFSET)
N    #define CapSense_SW_AMUXBUF_SEL_SW_IRLB_MASK        (((0x00000001Lu << CYFLD_CSD_SW_IRLB__SIZE) - 1u) << CYFLD_CSD_SW_IRLB__OFFSET)
N    #define CapSense_SW_AMUXBUF_SEL_SW_IRLB_STATIC_CLOSE (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_IRLB__OFFSET)
N    #define CapSense_SW_AMUXBUF_SEL_SW_ICA_MASK         (((0x00000001Lu << CYFLD_CSD_SW_ICA__SIZE) - 1u) << CYFLD_CSD_SW_ICA__OFFSET)
N    #define CapSense_SW_AMUXBUF_SEL_SW_ICB_MASK         (((0x00000001Lu << CYFLD_CSD_SW_ICB__SIZE) - 1u) << CYFLD_CSD_SW_ICB__OFFSET)
N    #define CapSense_SW_AMUXBUF_SEL_SW_ICB_PHI2_HSCMP   (CapSense_PHI2_HSCMP << CYFLD_CSD_SW_ICB__OFFSET)
N    #define CapSense_SW_AMUXBUF_SEL_SW_IRLI_MASK        (((0x00000001Lu << CYFLD_CSD_SW_IRLI__SIZE) - 1u) << CYFLD_CSD_SW_IRLI__OFFSET)
N    #define CapSense_SW_AMUXBUF_SEL_SW_IRH_MASK         (((0x00000001Lu << CYFLD_CSD_SW_IRH__SIZE) - 1u) << CYFLD_CSD_SW_IRH__OFFSET)
N    #define CapSense_SW_AMUXBUF_SEL_SW_IRH_STATIC_CLOSE (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_IRH__OFFSET)
N    #define CapSense_SW_AMUXBUF_SEL_SW_IRL_MASK         (((0x00000001Lu << CYFLD_CSD_SW_IRL__SIZE) - 1u) << CYFLD_CSD_SW_IRL__OFFSET)
N    #define CapSense_SW_AMUXBUF_SEL_SW_IRL_MASK         (((0x00000001Lu << CYFLD_CSD_SW_IRL__SIZE) - 1u) << CYFLD_CSD_SW_IRL__OFFSET)
N    #define CapSense_SW_AMUXBUF_SEL_SW_DEFAULT          (0x00000000Lu)
N    #define CapSense_SW_AMUXBUF_SEL_SW_ICB_PHI2         (0x00030000uL)
N    #define CapSense_SW_AMUXBUF_SEL_SW_ICB_PHI1         (CapSense_PHI1 << CYFLD_CSD_SW_ICB__OFFSET)
N
N    /* Fourth-generation HW block SW_FW_TANK_SEL register masks  */
N    #define CapSense_SW_HS_N_SEL_SW_HCCC_MASK           (((0x00000001Lu << CYFLD_CSD_SW_HCCC__SIZE) - 1u) << CYFLD_CSD_SW_HCCC__OFFSET)
N    #define CapSense_SW_HS_N_SEL_SW_HCCC_STATIC_OPEN    (CapSense_STATIC_OPEN << CYFLD_CSD_SW_HCCC__OFFSET)
N    #define CapSense_SW_HS_N_SEL_SW_HCCC_STATIC_CLOSE   (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_HCCC__OFFSET)
N    #define CapSense_SW_HS_N_SEL_SW_HCCD_MASK           (((0x00000001Lu << CYFLD_CSD_SW_HCCD__SIZE) - 1u) << CYFLD_CSD_SW_HCCD__OFFSET)
N    #define CapSense_SW_HS_N_SEL_SW_HCCD_STATIC_OPEN    (CapSense_STATIC_OPEN << CYFLD_CSD_SW_HCCD__OFFSET)
N    #define CapSense_SW_HS_N_SEL_SW_HCCD_STATIC_CLOSE   (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_HCCD__OFFSET)
N    #define CapSense_SW_HS_N_SEL_SW_HCRH_MASK           (((0x00000001Lu << CYFLD_CSD_SW_HCRH__SIZE) - 1u) << CYFLD_CSD_SW_HCRH__OFFSET)
N    #define CapSense_SW_HS_N_SEL_SW_HCRH_STATIC_OPEN    (CapSense_STATIC_OPEN << CYFLD_CSD_SW_HCRH__OFFSET)
N    #define CapSense_SW_HS_N_SEL_SW_HCRH_STATIC_CLOSE   (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_HCRH__OFFSET)
N    #define CapSense_SW_HS_N_SEL_SW_HCRL_MASK           (((0x00000001Lu << CYFLD_CSD_SW_HCRL__SIZE) - 1u) << CYFLD_CSD_SW_HCRL__OFFSET)
N    #define CapSense_SW_HS_N_SEL_SW_HCRL_STATIC_OPEN    (CapSense_STATIC_OPEN << CYFLD_CSD_SW_HCRL__OFFSET)
N    #define CapSense_SW_HS_N_SEL_SW_HCRL_STATIC_CLOSE   (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_HCRL__OFFSET)
N
N    /* Fourth-generation HW block SW_FW_MOD_SEL register masks  */
N    #define CapSense_SW_FW_MOD_SEL_SW_F1PM_MASK         (((0x00000001Lu << CYFLD_CSD_SW_F1PM__SIZE) - 1u) << CYFLD_CSD_SW_F1PM__OFFSET)
N    #define CapSense_SW_FW_MOD_SEL_SW_F1PM_STATIC_CLOSE (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_F1PM__OFFSET)
N    #define CapSense_SW_FW_MOD_SEL_SW_F1MA_MASK         (((0x00000001Lu << CYFLD_CSD_SW_F1MA__SIZE) - 1u) << CYFLD_CSD_SW_F1MA__OFFSET)
N    #define CapSense_SW_FW_MOD_SEL_SW_F1MA_STATIC_CLOSE (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_F1MA__OFFSET)
N    #define CapSense_SW_FW_MOD_SEL_SW_F1CA_MASK         (((0x00000001Lu << CYFLD_CSD_SW_F1CA__SIZE) - 1u) << CYFLD_CSD_SW_F1CA__OFFSET)
N    #define CapSense_SW_FW_MOD_SEL_SW_F1CA_STATIC_CLOSE (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_F1CA__OFFSET)
N    #define CapSense_SW_FW_MOD_SEL_SW_C1CC_MASK         (((0x00000001Lu << CYFLD_CSD_SW_C1CC__SIZE) - 1u) << CYFLD_CSD_SW_C1CC__OFFSET)
N    #define CapSense_SW_FW_MOD_SEL_SW_C1CC_STATIC_CLOSE (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_C1CC__OFFSET)
N    #define CapSense_SW_FW_MOD_SEL_SW_C1CD_MASK         (((0x00000001Lu << CYFLD_CSD_SW_C1CD__SIZE) - 1u) << CYFLD_CSD_SW_C1CD__OFFSET)
N    #define CapSense_SW_FW_MOD_SEL_SW_C1CD_STATIC_CLOSE (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_C1CD__OFFSET)
N
N    /* Fourth-generation HW block SW_FW_TANK_SEL register masks  */
N    #define CapSense_SW_FW_TANK_SEL_SW_F2PT_MASK        (((0x00000001Lu << CYFLD_CSD_SW_F2PT__SIZE) - 1u) << CYFLD_CSD_SW_F2PT__OFFSET)
N    #define CapSense_SW_FW_TANK_SEL_SW_F2PT_STATIC_CLOSE (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_F2PT__OFFSET)
N    #define CapSense_SW_FW_TANK_SEL_SW_F2CB_MASK        (((0x00000001Lu << CYFLD_CSD_SW_F2CB__SIZE) - 1u) << CYFLD_CSD_SW_F2CB__OFFSET)
N    #define CapSense_SW_FW_TANK_SEL_SW_F2CB_STATIC_CLOSE (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_F2CB__OFFSET)
N    #define CapSense_SW_FW_TANK_SEL_SW_F2CB_PHI2        (CapSense_PHI2 << CYFLD_CSD_SW_F2CB__OFFSET)
N    #define CapSense_SW_FW_TANK_SEL_SW_F2MA_MASK        (((0x00000001Lu << CYFLD_CSD_SW_F2MA__SIZE) - 1u) << CYFLD_CSD_SW_F2MA__OFFSET)
N    #define CapSense_SW_FW_TANK_SEL_SW_F2MA_STATIC_CLOSE (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_F2MA__OFFSET)
N    #define CapSense_SW_FW_TANK_SEL_SW_F2CA_MASK        (((0x00000001Lu << CYFLD_CSD_SW_F2CA__SIZE) - 1u) << CYFLD_CSD_SW_F2CA__OFFSET)
N    #define CapSense_SW_FW_TANK_SEL_SW_F2CA_STATIC_CLOSE (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_F2CA__OFFSET)
N    #define CapSense_SW_FW_TANK_SEL_SW_C2CC_MASK        (((0x00000001Lu << CYFLD_CSD_SW_C2CC__SIZE) - 1u) << CYFLD_CSD_SW_C2CC__OFFSET)
N    #define CapSense_SW_FW_TANK_SEL_SW_C2CC_STATIC_CLOSE (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_C2CC__OFFSET)
N    #define CapSense_SW_FW_TANK_SEL_SW_C2CD_MASK        (((0x00000001Lu << CYFLD_CSD_SW_C2CD__SIZE) - 1u) << CYFLD_CSD_SW_C2CD__OFFSET)
N    #define CapSense_SW_FW_TANK_SEL_SW_C2CD_STATIC_CLOSE (CapSense_STATIC_CLOSE << CYFLD_CSD_SW_C2CD__OFFSET)
N
N    /* Fourth-generation HW block CTANK masks    */
N    #define CapSense_CTANK_DR_VDDIO                     (0x0u)
N    #define CapSense_CTANK_DR_VSSIO                     (CapSense_DR_MASK << CapSense_CSH_SHIFT)
N
N    #if (CapSense_ENABLE == CapSense_CSD_IDAC_COMP_EN)
X    #if ((1u) == (1u))
N        #if (CapSense_ENABLE == CapSense_CSD_DEDICATED_IDAC_COMP_EN)
X        #if ((1u) == (1u))
N            #if (0u != CapSense_TOTAL_CSD_WIDGETS)
X            #if (0u != (13u))
N                #define CapSense_IDACB_USED             (1u)
N            #else
S                #define CapSense_IDACB_USED             (0u)
N            #endif /* (0u != CapSense_TOTAL_CSD_WIDGETS) */
N            #define CapSense_DEFAULT_IDAC_MOD_LEG2_MODE (CapSense_IDAC_MOD_LEG2_MODE_GP_STATIC_MASK)
N        #else
S            #define CapSense_IDACB_USED                 (0u)
S            #define CapSense_DEFAULT_IDAC_MOD_LEG2_MODE (CapSense_IDAC_MOD_LEG2_EN_MASK |\
S                                                                CapSense_IDAC_MOD_LEG2_MODE_CSD_STATIC_MASK)
X            #define CapSense_DEFAULT_IDAC_MOD_LEG2_MODE (CapSense_IDAC_MOD_LEG2_EN_MASK |                                                                CapSense_IDAC_MOD_LEG2_MODE_CSD_STATIC_MASK)
N        #endif /* (CapSense_ENABLE == CapSense_CSD_DEDICATED_IDAC_COMP_EN)) */
N    #else
S        #define CapSense_IDACB_USED                     (0u)
S        #define CapSense_DEFAULT_IDAC_MOD_LEG2_MODE     (CapSense_IDAC_MOD_LEG2_MODE_GP_STATIC_MASK)
N    #endif /* (CapSense_ENABLE == CapSense_CSD_IDAC_COMP_EN) */
N
N    #define CapSense_CALIBRATE_SW_REFGEN_SEL            (CapSense_SW_REFGEN_SEL_SW_SGR_MASK)
N
N    #define CapSense_DEFAULT_REFGEN_GAIN                (CapSense_CSD_GAIN << CYFLD_CSD_GAIN__OFFSET)
N    #define CapSense_REFGEN_LV                          (CapSense_REFGEN_REFGEN_EN_MASK |\
N                                                                CapSense_REFGEN_BYPASS_MASK)
X    #define CapSense_REFGEN_LV                          (CapSense_REFGEN_REFGEN_EN_MASK |                                                                CapSense_REFGEN_BYPASS_MASK)
N
N    #define CapSense_REFGEN_HV                          (CapSense_REFGEN_REFGEN_EN_MASK |\
N                                                                CapSense_REFGEN_RES_EN_MASK |\
N                                                                CapSense_DEFAULT_REFGEN_GAIN)
X    #define CapSense_REFGEN_HV                          (CapSense_REFGEN_REFGEN_EN_MASK |                                                                CapSense_REFGEN_RES_EN_MASK |                                                                CapSense_DEFAULT_REFGEN_GAIN)
N
N    #define CapSense_SENSE_PERIOD_LFSR_SIZE_SHIFT       (CYFLD_CSD_LFSR_SIZE__OFFSET)
N
N    /* Initial PRS mode */
N    #define CapSense_PRS_8_CONFIG                       (CapSense_CLK_SOURCE_PRS8)
N    #define CapSense_PRS_12_CONFIG                      (CapSense_CLK_SOURCE_PRS12)
N
N    /* SW_HS_P_SEL switches state for Coarse initialization of CMOD (sense path) */
N    #if ((CapSense_ENABLE == CapSense_CSD_CSX_EN) || \
N         (CapSense_ENABLE == CapSense_CSD_ISX_EN) || \
N         (CapSense_ENABLE == CapSense_CSD_EN))
X    #if (((1u) == ((1u) && (0u))) ||          ((1u) == ((1u) && (0u))) ||          ((1u) == (1u)))
N        #if (CapSense_CSD__CMOD_PAD == CapSense_CMOD_CONNECTION)
X        #if (1u == (1u))
N            #define CapSense_HS_P_SEL_COARSE_CMOD       (CapSense_SW_HS_P_SEL_SW_HMPM_STATIC_CLOSE)
N        #elif (CapSense_CSD__CSHIELD_PAD == CapSense_CMOD_CONNECTION)
S            #define CapSense_HS_P_SEL_COARSE_CMOD       (CapSense_SW_HS_P_SEL_SW_HMPS_STATIC_CLOSE)
S        #else
S            #define CapSense_HS_P_SEL_COARSE_CMOD       (CapSense_SW_HS_P_SEL_SW_HMPT_STATIC_CLOSE)
N        #endif /* (CapSense_CSD__CMOD_PAD == CapSense_CMOD_CONNECTION) */
N    #else
S        #define CapSense_HS_P_SEL_COARSE_CMOD           (0x00000000uL)
N    #endif /* ((CapSense_ENABLE == CapSense_CSD_CSX_EN) && (CapSense_ENABLE == CapSense_CSD_EN)) */
N
N    #if ((0u != CapSense_CSD_SHIELD_TANK_EN) && (CapSense_ENABLE == CapSense_CSD_SHIELD_EN))
X    #if ((0u != (0u)) && ((1u) == (0u)))
S        /* SW_HS_P_SEL switches state for Coarse initialization of CTANK (sense path) */
S        #if (CapSense_CSD__CSH_TANK_PAD == CapSense_CTANK_CONNECTION)
S            #define CapSense_HS_P_SEL_COARSE_TANK       (CapSense_SW_HS_P_SEL_SW_HMPT_STATIC_CLOSE)
S            #define CapSense_HS_P_SEL_SCAN_TANK         (CapSense_SW_HS_P_SEL_SW_HMPT_STATIC_CLOSE)
S        #elif (CapSense_CSD__CSHIELD_PAD == CapSense_CTANK_CONNECTION)
S            #define CapSense_HS_P_SEL_COARSE_TANK       (CapSense_SW_HS_P_SEL_SW_HMPS_STATIC_CLOSE)
S            #define CapSense_HS_P_SEL_SCAN_TANK         (CapSense_SW_HS_P_SEL_SW_HMPS_STATIC_CLOSE)
S        #elif (CapSense_CSD__CMOD_PAD == CapSense_CTANK_CONNECTION)
S            #define CapSense_HS_P_SEL_COARSE_TANK       (CapSense_SW_HS_P_SEL_SW_HMPM_STATIC_CLOSE)
S            #define CapSense_HS_P_SEL_SCAN_TANK         (CapSense_SW_HS_P_SEL_SW_HMPM_STATIC_CLOSE)
S        #else
S            #define CapSense_HS_P_SEL_COARSE_TANK       (CapSense_SW_HS_P_SEL_SW_HMMA_STATIC_CLOSE)
S            #define CapSense_HS_P_SEL_SCAN_TANK         (CapSense_SW_HS_P_SEL_SW_HMMB_STATIC_CLOSE)
S        #endif /* (CapSense_CSD__CSH_TANK_PAD == CapSense_CTANK_CONNECTION) */
S        #define CapSense_SW_HS_P_SEL_SCAN               (CapSense_HS_P_SEL_SCAN_TANK)
N    #else
N        #define CapSense_HS_P_SEL_COARSE_TANK           (0x00000000uL)
N        #define CapSense_SW_HS_P_SEL_SCAN               (CapSense_SW_HS_P_SEL_SW_HMMB_STATIC_CLOSE)
N    #endif /* ((0u != CapSense_CSD__CSD_CSH_TANK_ENABLE) && (CapSense_ENABLE == CapSense_CSD_SHIELD_EN)) */
N
N    #define CapSense_SW_HS_P_SEL_COARSE                 (CapSense_HS_P_SEL_COARSE_CMOD | CapSense_HS_P_SEL_COARSE_TANK)
N
N    /***************************************
N    * Fourth-generation HW block Registers shifts
N    ***************************************/
N    #define CapSense_SHIELD_DELAY_SHIFT                 (CYFLD_CSD_SHIELD_DELAY__OFFSET)
N    #define CapSense_LFSR_SIZE_SHIFT                    (CYFLD_CSD_LFSR_SIZE__OFFSET)
N    #define CapSense_RESULT_VAL1_BAD_CONVS_SHIFT        (CYFLD_CSD_BAD_CONVS__OFFSET)
N    #define CapSense_SW_SHIELD_SEL_SW_HCBV_SHIFT        (CYFLD_CSD_SW_HCBV__OFFSET)
N
N    /***************************************
N    * LFSR Register masks
N    ***************************************/
N    #define CapSense_RESOLUTION_OFFSET                  (0u)
N    #define CapSense_LFSR_TABLE_SIZE                    (4u)
N
N    #define CapSense_PRS_LENGTH_2_BITS                  (0x00000003Lu)
N    #define CapSense_PRS_LENGTH_3_BITS                  (0x00000007Lu)
N    #define CapSense_PRS_LENGTH_4_BITS                  (0x0000000FLu)
N    #define CapSense_PRS_LENGTH_5_BITS                  (0x0000001FLu)
N    #define CapSense_PRS_LENGTH_8_BITS                  (0x000000FFLu)
N    #define CapSense_PRS_LENGTH_12_BITS                 (0x00000FFFLu)
N
N    #if(CapSense_ENABLE != CapSense_CSDV2_REF9P6UA_EN)
X    #if((1u) != (1u))
S        #define CapSense_SNSCLK_SSC1_PERIOD             (3u)
S        #define CapSense_SNSCLK_SSC2_PERIOD             (7u)
S        #define CapSense_SNSCLK_SSC3_PERIOD             (15u)
S        #define CapSense_SNSCLK_SSC4_PERIOD             (31u)
S
S        #define CapSense_SNSCLK_SSC1_RANGE              (1u)
S        #define CapSense_SNSCLK_SSC2_RANGE              (3u)
S        #define CapSense_SNSCLK_SSC3_RANGE              (7u)
S        #define CapSense_SNSCLK_SSC4_RANGE              (15u)
N    #else
N
N        #define CapSense_SNSCLK_SSC1_PERIOD             (63u)
N        #define CapSense_SNSCLK_SSC2_PERIOD             (127u)
N        #define CapSense_SNSCLK_SSC3_PERIOD             (511u)
N        #define CapSense_SNSCLK_SSC4_PERIOD             (1023u)
N
N        #define CapSense_SNSCLK_SSC1_RANGE              (16u)
N        #define CapSense_SNSCLK_SSC2_RANGE              (16u)
N        #define CapSense_SNSCLK_SSC3_RANGE              (16u)
N        #define CapSense_SNSCLK_SSC4_RANGE              (16u)
N    #endif /* (CapSense_ENABLE != CapSense_CSDV2_REF9P6UA_EN) */
N
N    #define CapSense_LFSR_DITHER_PERCENTAGE             (10uL)
N    #define CapSense_SNSCLK_SSC1_THRESHOLD              (CapSense_LFSR_DITHER_PERCENTAGE * CapSense_SNSCLK_SSC1_RANGE)
N    #define CapSense_SNSCLK_SSC2_THRESHOLD              (CapSense_LFSR_DITHER_PERCENTAGE * CapSense_SNSCLK_SSC2_RANGE)
N    #define CapSense_SNSCLK_SSC3_THRESHOLD              (CapSense_LFSR_DITHER_PERCENTAGE * CapSense_SNSCLK_SSC3_RANGE)
N    #define CapSense_SNSCLK_SSC4_THRESHOLD              (CapSense_LFSR_DITHER_PERCENTAGE * CapSense_SNSCLK_SSC4_RANGE)
N
N    #define CapSense_HFCLK_SNSCLK_FACTOR                (160u)
N    #define CapSense_SKIP_INIT_CYCLES                   (4u)
N
N#else
S
S    /* Third-generation HW block CSD_CONFIG register masks    */
S    #define CapSense_CONFIG_BYPASS_SEL_MASK             (0x00000004Lu)
S    #define CapSense_CONFIG_FILTER_EN_MASK              (0x00000008Lu)
S    #define CapSense_CONFIG_DUAL_CAP_EN_MASK            (0x00000010Lu)
S    #define CapSense_CONFIG_PRS_CLEAR_MASK              (0x00000020Lu)
S    #define CapSense_CONFIG_PRS_SELECT_MASK             (0x00000040Lu)
S    #define CapSense_CONFIG_PRS_12_8_MASK               (0x00000080Lu)
S    #define CapSense_CONFIG_SHIELD_DELAY_MASK           (0x00000600Lu)
S    #define CapSense_CONFIG_SENSE_COMP_BW_MASK          (0x00000800Lu)
S    #define CapSense_CONFIG_SENSE_EN_MASK               (0x00001000Lu)
S    #define CapSense_CONFIG_REFBUF_EN_MASK              (0x00002000Lu)
S    #define CapSense_CONFIG_COMP_MODE_MASK              (0x00004000Lu)
S    #define CapSense_CONFIG_COMP_PIN_MASK               (0x00008000Lu)
S    #define CapSense_CONFIG_POLARITY_MASK               (0x00010000Lu)
S    #define CapSense_CONFIG_POLARITY2_MASK              (0x00020000Lu)
S    #define CapSense_CONFIG_MUTUALCAP_EN_MASK           (0x00040000Lu)
S    #define CapSense_CONFIG_SENSE_COMP_EN_MASK          (0x00080000Lu)
S    #define CapSense_CONFIG_REFBUF_OUTSEL_MASK          (0x00200000Lu)
S    #define CapSense_CONFIG_SENSE_INSEL_MASK            (0x00400000Lu)
S    #define CapSense_CONFIG_REFBUF_DRV_MASK             (0x01800000Lu)
S    #define CapSense_CONFIG_DDFTSEL_MASK                (0x1C000000Lu)
S    #define CapSense_CONFIG_ADFTEN_MASK                 (0x20000000Lu)
S    #define CapSense_CONFIG_DDFT_COMP_MASK              (0x40000000Lu)
S    #define CapSense_CONFIG_ENABLE_MASK                 (0x80000000Lu)
S
S    /* Third-generation HW block CSD_IDAC register masks  */
S    #define CapSense_IDAC_MOD_MASK                      (0x000000FFLu)
S    #define CapSense_IDAC_MOD_MODE_MASK                 (0x00000300Lu)
S    #define CapSense_IDAC_MOD_RANGE_MASK                (0x00000400Lu)
S    #define CapSense_IDAC_POLARITY1_MIR_MASK            (0x00001000Lu)
S    #define CapSense_IDAC_COMP_MASK                     (0x007F0000Lu)
S    #define CapSense_IDAC_COMP_MODE_MASK                (0x03000000Lu)
S    #define CapSense_IDAC_COMP_RANGE_MASK               (0x04000000Lu)
S    #define CapSense_IDAC_POLARITY2_MIR_MASK            (0x10000000Lu)
S    #define CapSense_IDAC_FEEDBACK_MODE_MASK            (0x40000000Lu)
S    #define CapSense_IDAC_MOD_MODE_OFF                  (0x00000000Lu)
S    #define CapSense_IDAC_MOD_MODE_FIXED                (0x00000100Lu)
S    #define CapSense_IDAC_MOD_MODE_VARIABLE             (0x00000200Lu)
S    #define CapSense_IDAC_MOD_MODE_DSI                  (0x00000300Lu)
S    #define CapSense_IDAC_COMP_MODE_OFF                 (0x00000000Lu)
S    #define CapSense_IDAC_COMP_MODE_FIXED               (0x01000000Lu)
S    #define CapSense_IDAC_COMP_MODE_VARIABLE            (0x02000000Lu)
S    #define CapSense_IDAC_COMP_MODE_DSI                 (0x03000000Lu)
S    #define CapSense_IDAC_MOD_VALUE_SHIFT               (0u)
S    #define CapSense_IDAC_MOD_CFG_MASK                  (CapSense_IDAC_POLARITY1_MIR_MASK |\
S                                                                 CapSense_IDAC_MOD_RANGE_MASK |\
S                                                                 CapSense_IDAC_MOD_MODE_MASK |\
S                                                                 CapSense_IDAC_MOD_MASK)
X    #define CapSense_IDAC_MOD_CFG_MASK                  (CapSense_IDAC_POLARITY1_MIR_MASK |                                                                 CapSense_IDAC_MOD_RANGE_MASK |                                                                 CapSense_IDAC_MOD_MODE_MASK |                                                                 CapSense_IDAC_MOD_MASK)
S
S    #define CapSense_IDAC_COMP_CFG_MASK                 (CapSense_IDAC_POLARITY2_MIR_MASK |\
S                                                                 CapSense_IDAC_COMP_RANGE_MASK |\
S                                                                 CapSense_IDAC_COMP_MODE_MASK |\
S                                                                 CapSense_IDAC_COMP_MASK)
X    #define CapSense_IDAC_COMP_CFG_MASK                 (CapSense_IDAC_POLARITY2_MIR_MASK |                                                                 CapSense_IDAC_COMP_RANGE_MASK |                                                                 CapSense_IDAC_COMP_MODE_MASK |                                                                 CapSense_IDAC_COMP_MASK)
S
S    /* Third-generation HW block CSD_COUNTER register masks   */
S    #define CapSense_COUNTER_COUNTER_MASK               (0x0000FFFFLu)
S    #define CapSense_COUNTER_PERIOD_MASK                (0xFFFF0000Lu)
S
S    /* Third-generation HW block CSD_STATUS register masks    */
S    #define CapSense_STATUS_CSD_CHARGE_MASK             (0x00000001Lu)
S    #define CapSense_STATUS_CSD_SENSE_MASK              (0x00000002Lu)
S    #define CapSense_STATUS_COMP_OUT_MASK               (0x00000004Lu)
S    #define CapSense_STATUS_SAMPLE                      (0x00000008Lu)
S
S    /* Third-generation HW block CSD_INTR, CSD_INTR_SET register masks  */
S    #define CapSense_INTR_CSD_MASK                      (0x00000001Lu)
S    #define CapSense_INTR_SET_CSD_MASK                  (0x00000001Lu)
S    #define CapSense_INTR_SET_MASK                      (CapSense_INTR_SET_CSD_MASK)
S
S    /* Third-generation HW block CSD_PWM register masks   */
S    #define CapSense_PWM_COUNT_MASK                     (0x0000000FLu)
S    #define CapSense_PWM_SEL_MASK                       (0x00000030Lu)
S
S    /* Third-generation HW block CSD_TRIM1/2 (for IDAC) register masks    */
S    #define CapSense_IDAC_TRIM2_MOD_SNK_MASK            (0x0000000FLu)
S    #define CapSense_IDAC_TRIM2_COMP_SNK_MASK           (0x000000F0Lu)
S    #define CapSense_IDAC_TRIM1_MOD_SRC_MASK            (0x0000000FLu)
S    #define CapSense_IDAC_TRIM1_COMP_SRC_MASK           (0x000000F0Lu)
S
S    /* Third-generation HW block CSD_TRIM FLASH register masks    */
S    #define CapSense_SFLASH_TRIM_IDAC_MOD_MASK          (0x0FLu)
S    #define CapSense_SFLASH_TRIM_IDAC_COMP_MASK         (0xF0Lu)
S
S    /* Third-generation HW block Clock register masks    */
S    #define CapSense_SNSCLK_CMD_DIV_SHIFT               (0u)
S    #define CapSense_SNSCLK_CMD_PA_DIV_SHIFT            (8u)
S    #define CapSense_SNSCLK_CMD_DISABLE_SHIFT           (30u)
S    #define CapSense_SNSCLK_CMD_ENABLE_SHIFT            (31u)
S    #define CapSense_SNSCLK_CMD_DISABLE_MASK            ((uint32)((uint32)1u << CapSense_SNSCLK_CMD_DISABLE_SHIFT))
S    #define CapSense_SNSCLK_CMD_ENABLE_MASK             ((uint32)((uint32)1u << CapSense_SNSCLK_CMD_ENABLE_SHIFT))
S
S    /* Third-generation HW block CTANK masks    */
S    #define CapSense_CTANK_DR_VDDIO                     (0x0u)
S    #define CapSense_CTANK_DR_VSSIO                     (CapSense_DR_MASK << CapSense_CSH_SHIFT)
S
S    #define CapSense_RESOLUTION_OFFSET                  (16u)
S    #define CapSense_PRS_LENGTH_12_BITS                 (0x00000FFFLu)
S    #define CapSense_PRS_LENGTH_8_BITS                  (0x000000FFLu)
S    #define CapSense_CSD_PRS_12_BIT                     (CapSense_CONFIG_PRS_12_8_MASK)
S    #define CapSense_PRS_MODE_MASK                      (CapSense_CONFIG_PRS_12_8_MASK)
S
S    /***************************************
S    * Third-generation HW block Registers shifts
S    ***************************************/
S    #define CapSense_SHIELD_DELAY_SHIFT                 (0x09u)
S    #define CapSense_IDAC_COMP_DATA_OFFSET              (16u)
S
N#endif /* (CapSense_ENABLE == CapSense_CSDV2) */
N
N/* Third-generation and Fourth-generation HW block Clock register masks    */
N#define CapSense_MODCLK_CMD_DIV_SHIFT                   (0u)
N#define CapSense_MODCLK_CMD_PA_DIV_SHIFT                (8u)
N#define CapSense_MODCLK_CMD_DISABLE_SHIFT               (30u)
N#define CapSense_MODCLK_CMD_ENABLE_SHIFT                (31u)
N#define CapSense_MODCLK_CMD_DISABLE_MASK                ((uint32)((uint32)1u << CapSense_MODCLK_CMD_DISABLE_SHIFT))
N#define CapSense_MODCLK_CMD_ENABLE_MASK                 ((uint32)((uint32)1u << CapSense_MODCLK_CMD_ENABLE_SHIFT))
N
N/* CintB and CintA pin registers  */
N#if ((CapSense_ENABLE == CapSense_CSX_EN) \
N    || (CapSense_ENABLE == CapSense_ISX_EN) \
N    || (CapSense_ENABLE == CapSense_CSD_CSX_EN) \
N    || (CapSense_ENABLE == CapSense_CSD_ISX_EN))
X#if (((1u) == (0u))     || ((1u) == (0u))     || ((1u) == ((1u) && (0u)))     || ((1u) == ((1u) && (0u))))
S
S    #define CapSense_CintA_PC_REG                       (* (reg32 *) CapSense_CintA__0__PC)
S    #define CapSense_CintA_DR_REG                       (* (reg32 *) CapSense_CintA__0__DR)
S    #define CapSense_CintA_HSIOM_REG                    (* (reg32 *) CapSense_CintA__0__HSIOM)
S    #define CapSense_CintB_PC_REG                       (* (reg32 *) CapSense_CintB__0__PC)
S    #define CapSense_CintB_DR_REG                       (* (reg32 *) CapSense_CintB__0__DR)
S    #define CapSense_CintB_HSIOM_REG                    (* (reg32 *) CapSense_CintB__0__HSIOM)
S
S    #define CapSense_CintA_PC_PTR                       ((reg32 *) CapSense_CintA__0__PC)
S    #define CapSense_CintA_DR_PTR                       ((reg32 *) CapSense_CintA__0__DR)
S    #define CapSense_CintA_HSIOM_PTR                    ((reg32 *) CapSense_CintA__0__HSIOM)
S    #define CapSense_CintB_PC_PTR                       ((reg32 *) CapSense_CintB__0__PC)
S    #define CapSense_CintB_DR_PTR                       ((reg32 *) CapSense_CintB__0__DR)
S    #define CapSense_CintB_HSIOM_PTR                    ((reg32 *) CapSense_CintB__0__HSIOM)
S
S    /* CintB and CintA pin masks                                                */
S    #define CapSense_CintA_HSIOM_MASK                   ((uint32)CapSense_CintA__0__HSIOM_MASK)
S    #define CapSense_CintA_HSIOM_SHIFT                  ((uint32)CapSense_CintA__0__HSIOM_SHIFT)
S    #define CapSense_CintA_SHIFT                        ((uint32)CapSense_CintA__0__SHIFT)
S
S    #define CapSense_CintB_HSIOM_MASK                   ((uint32)CapSense_CintB__0__HSIOM_MASK)
S    #define CapSense_CintB_HSIOM_SHIFT                  ((uint32)CapSense_CintB__0__HSIOM_SHIFT)
S    #define CapSense_CintB_SHIFT                        ((uint32)CapSense_CintB__0__SHIFT)
S
N#endif
N
N/* CMOD and CSH capacitor port-pins registers */
N#if ((CapSense_ENABLE == CapSense_CSD_EN) || \
N     (CapSense_ENABLE == CapSense_CSD_CSX_EN) || \
N     (CapSense_ENABLE == CapSense_CSD_ISX_EN))
X#if (((1u) == (1u)) ||      ((1u) == ((1u) && (0u))) ||      ((1u) == ((1u) && (0u))))
N
N    #define CapSense_CSH_PC_REG                         (* (reg32 *) CapSense_Csh__PC)
N    #define CapSense_CSH_PC_PTR                         (  (reg32 *) CapSense_Csh__PC)
N    #define CapSense_CSH_DR_REG                         (* (reg32 *) CapSense_Csh__DR)
N    #define CapSense_CSH_DR_PTR                         (  (reg32 *) CapSense_Csh__DR)
N    #define CapSense_CSH_HSIOM_REG                      (* (reg32 *) CapSense_Csh__0__HSIOM)
N    #define CapSense_CSH_HSIOM_PTR                      (  (reg32 *) CapSense_Csh__0__HSIOM)
N
N    #define CapSense_CMOD_PC_REG                        (* (reg32 *) CapSense_Cmod__PC)
N    #define CapSense_CMOD_PC_PTR                        (  (reg32 *) CapSense_Cmod__PC)
N    #define CapSense_CMOD_PC_SHIFT                      (CapSense_Cmod__0__SHIFT * 3u)
N    #define CapSense_CMOD_DR_REG                        (* (reg32 *) CapSense_Cmod__DR)
N    #define CapSense_CMOD_DR_PTR                        (  (reg32 *) CapSense_Cmod__DR)
N    #define CapSense_CMOD_DR_SHIFT                      CapSense_Cmod__0__SHIFT
N    #define CapSense_CMOD_HSIOM_REG                     (* (reg32 *) CapSense_Cmod__0__HSIOM)
N    #define CapSense_CMOD_HSIOM_PTR                     (  (reg32 *) CapSense_Cmod__0__HSIOM)
N
N    /* Cmod and Csh pin masks */
N    #define CapSense_CMOD_HSIOM_MASK                    CapSense_Cmod__0__HSIOM_MASK
N    #define CapSense_CMOD_HSIOM_SHIFT                   CapSense_Cmod__0__HSIOM_SHIFT
N    #define CapSense_CSH_HSIOM_MASK                     CapSense_Csh__0__HSIOM_MASK
N    #define CapSense_CSH_HSIOM_SHIFT                    CapSense_Csh__0__HSIOM_SHIFT
N    #define CapSense_CSH_SHIFT                          CapSense_Csh__0__SHIFT
N    #define CapSense_CSH_PC_SHIFT                       (CapSense_Csh__0__SHIFT * 3u)
N
N#endif
N
N/* GPIO register masks */
N#define CapSense_DR_MASK                                (0x00000001Lu)
N
N#define CapSense_CSH_TO_AMUXBUS_B_MASK                  (0x00000007Lu)
N#define CapSense_CSH_PC_MASK                            (0x00000007Lu)
N#define CapSense_CSH_PC_STRONG_MODE                     (0x00000006Lu)
N
N#define CapSense_HSIOM_SEL_MASK                         (0x0000000FLu)
N#define CapSense_HSIOM_SEL_GPIO                         (0x00000000Lu)
N#define CapSense_HSIOM_SEL_CSD_SENSE                    (0x00000004Lu)
N#define CapSense_HSIOM_SEL_CSD_SHIELD                   (0x00000005Lu)
N#define CapSense_HSIOM_SEL_AMUXA                        (0x00000006Lu)
N#define CapSense_HSIOM_SEL_AMUXB                        (0x00000007Lu)
N#define CapSense_HSIOM_SEL_ACT_0                        (0x00000008Lu)
N
N#define CapSense_GPIO_PC_MASK                           (0x00000007Lu)
N#define CapSense_GPIO_HIGHZ_MASK                        (0x00000007Lu)
N#define CapSense_GPIO_STRGDRV                           (0x00000006Lu)
N
N#define CapSense_SNS_GROUND_CONNECT                     (0x00000006Lu)
N
N#define CapSense_GPIO_PC_BIT_SIZE                       (3u)
N
N#define CapSense_EXT_CAP_DISCHARGE_TIME                 (1u)
N
N#if (CapSense_ENABLE == CapSense_CSD_EN)
X#if ((1u) == (1u))
N    #define CapSense_EXT_CAP_HSIOM_PTR                  ((reg32 *) CapSense_Cmod__0__HSIOM)
N    #define CapSense_EXT_CAP_DR_PTR                     ((reg32 *) CapSense_Cmod__DR)
N    #define CapSense_EXT_CAP_PC_PTR                     ((reg32 *) CapSense_Cmod__PC)
N#else
S    #define CapSense_EXT_CAP_HSIOM_PTR                  ((reg32 *) CapSense_CintA__0__HSIOM)
S    #define CapSense_EXT_CAP_DR_PTR                     ((reg32 *) CapSense_CintA__DR)
S    #define CapSense_EXT_CAP_PC_PTR                     ((reg32 *) CapSense_CintA__PC)
N#endif
N
N#if (CapSense_ENABLE == CapSense_CSD_EN)
X#if ((1u) == (1u))
N    #define CapSense_EXT_CAP_HSIOM_MASK_CMOD                (CapSense_Cmod__0__HSIOM_MASK)
N    #define CapSense_EXT_CAP_DR_MASK_CMOD                   (CapSense_Cmod__0__MASK)
N    #define CapSense_EXT_CAP_PC_MASK_CMOD                   ((uint32)CapSense_GPIO_PC_MASK << CapSense_CMOD_PC_SHIFT)
N    #define CapSense_EXT_CAP_PC_STRONG_CFG_CMOD             ((uint32)CapSense_GPIO_STRGDRV << CapSense_CMOD_PC_SHIFT)
N#else
S    #define CapSense_EXT_CAP_HSIOM_MASK_CMOD                (0u)
S    #define CapSense_EXT_CAP_DR_MASK_CMOD                   (0u)
S    #define CapSense_EXT_CAP_PC_MASK_CMOD                   (0u)
S    #define CapSense_EXT_CAP_PC_STRONG_CFG_CMOD             (0u)
N#endif
N
N#if((CapSense_ENABLE == CapSense_CSD_EN) && \
N    (CapSense_ENABLE == CapSense_CSD_SHIELD_EN) && \
N    (CapSense_ENABLE == CapSense_CSD_SHIELD_TANK_EN))
X#if(((1u) == (1u)) &&     ((1u) == (0u)) &&     ((1u) == (0u)))
S    #define CapSense_EXT_CAP_HSIOM_MASK_CSH                 (CapSense_Csh__0__HSIOM)
S    #define CapSense_EXT_CAP_DR_MASK_CSH                    (CapSense_Csh__0__MASK)
S    #define CapSense_EXT_CAP_PC_MASK_CSH                    ((uint32)CapSense_GPIO_PC_MASK << CapSense_CSH_PC_SHIFT)
S    #define CapSense_EXT_CAP_PC_STRONG_CFG_CSH             ((uint32)CapSense_GPIO_STRGDRV << CapSense_CSH_PC_SHIFT)
N#else
N    #define CapSense_EXT_CAP_HSIOM_MASK_CSH                 (0u)
N    #define CapSense_EXT_CAP_DR_MASK_CSH                    (0u)
N    #define CapSense_EXT_CAP_PC_MASK_CSH                    (0u)
N    #define CapSense_EXT_CAP_PC_STRONG_CFG_CSH              (0u)
N#endif
N
N#if (CapSense_ENABLE == CapSense_CSX_EN)
X#if ((1u) == (0u))
S    #define CapSense_EXT_CAP_HSIOM_MASK_CINTA               (CapSense_CintA__0__HSIOM_MASK)
S    #define CapSense_EXT_CAP_DR_MASK_CINTA                  (CapSense_CintA__0__MASK)
S    #define CapSense_EXT_CAP_PC_MASK_CINTA                  ((uint32)CapSense_GPIO_PC_MASK << (CapSense_CintA_SHIFT * 3u))
S    #define CapSense_EXT_CAP_PC_STRONG_CFG_CINTA            ((uint32)CapSense_GPIO_STRGDRV << (CapSense_CintA_SHIFT * 3u))
S    #define CapSense_EXT_CAP_HSIOM_MASK_CINTB               (CapSense_CintB__0__HSIOM_MASK)
S    #define CapSense_EXT_CAP_DR_MASK_CINTB                  (CapSense_CintB__0__MASK)
S    #define CapSense_EXT_CAP_PC_MASK_CINTB                  ((uint32)CapSense_GPIO_PC_MASK << (CapSense_CintB_SHIFT * 3u))
S    #define CapSense_EXT_CAP_PC_STRONG_CFG_CINTB            ((uint32)CapSense_GPIO_STRGDRV << (CapSense_CintB_SHIFT * 3u))
N#else
N    #define CapSense_EXT_CAP_HSIOM_MASK_CINTA               (0u)
N    #define CapSense_EXT_CAP_DR_MASK_CINTA                  (0u)
N    #define CapSense_EXT_CAP_PC_MASK_CINTA                  (0u)
N    #define CapSense_EXT_CAP_PC_STRONG_CFG_CINTA            (0u)
N    #define CapSense_EXT_CAP_HSIOM_MASK_CINTB               (0u)
N    #define CapSense_EXT_CAP_DR_MASK_CINTB                  (0u)
N    #define CapSense_EXT_CAP_PC_MASK_CINTB                  (0u)
N    #define CapSense_EXT_CAP_PC_STRONG_CFG_CINTB            (0u)
N#endif
N
N
N#define CapSense_EXT_CAP_HSIOM_MASK                         (CapSense_EXT_CAP_HSIOM_MASK_CMOD | \
N                                                                     CapSense_EXT_CAP_HSIOM_MASK_CSH | \
N                                                                     CapSense_EXT_CAP_HSIOM_MASK_CINTA | \
N                                                                     CapSense_EXT_CAP_HSIOM_MASK_CINTB)
X#define CapSense_EXT_CAP_HSIOM_MASK                         (CapSense_EXT_CAP_HSIOM_MASK_CMOD |                                                                      CapSense_EXT_CAP_HSIOM_MASK_CSH |                                                                      CapSense_EXT_CAP_HSIOM_MASK_CINTA |                                                                      CapSense_EXT_CAP_HSIOM_MASK_CINTB)
N
N#define CapSense_EXT_CAP_DR_MASK                            (CapSense_EXT_CAP_DR_MASK_CMOD | \
N                                                                     CapSense_EXT_CAP_DR_MASK_CSH | \
N                                                                     CapSense_EXT_CAP_DR_MASK_CINTA | \
N                                                                     CapSense_EXT_CAP_DR_MASK_CINTB)
X#define CapSense_EXT_CAP_DR_MASK                            (CapSense_EXT_CAP_DR_MASK_CMOD |                                                                      CapSense_EXT_CAP_DR_MASK_CSH |                                                                      CapSense_EXT_CAP_DR_MASK_CINTA |                                                                      CapSense_EXT_CAP_DR_MASK_CINTB)
N
N#define CapSense_EXT_CAP_PC_MASK                            (CapSense_EXT_CAP_PC_MASK_CMOD | \
N                                                                     CapSense_EXT_CAP_PC_MASK_CSH | \
N                                                                     CapSense_EXT_CAP_PC_MASK_CINTA | \
N                                                                     CapSense_EXT_CAP_PC_MASK_CINTB)
X#define CapSense_EXT_CAP_PC_MASK                            (CapSense_EXT_CAP_PC_MASK_CMOD |                                                                      CapSense_EXT_CAP_PC_MASK_CSH |                                                                      CapSense_EXT_CAP_PC_MASK_CINTA |                                                                      CapSense_EXT_CAP_PC_MASK_CINTB)
N
N#define CapSense_EXT_CAP_PC_STRONG_CFG                      (CapSense_EXT_CAP_PC_STRONG_CFG_CMOD | \
N                                                                     CapSense_EXT_CAP_PC_STRONG_CFG_CSH | \
N                                                                     CapSense_EXT_CAP_PC_STRONG_CFG_CINTA | \
N                                                                     CapSense_EXT_CAP_PC_STRONG_CFG_CINTB)
X#define CapSense_EXT_CAP_PC_STRONG_CFG                      (CapSense_EXT_CAP_PC_STRONG_CFG_CMOD |                                                                      CapSense_EXT_CAP_PC_STRONG_CFG_CSH |                                                                      CapSense_EXT_CAP_PC_STRONG_CFG_CINTA |                                                                      CapSense_EXT_CAP_PC_STRONG_CFG_CINTB)
N
N/***************************************
N* API Constants
N***************************************/
N
N#define CapSense_MOD_CSD_CLK_12MHZ                      (12000000uL)
N#define CapSense_MOD_CSD_CLK_24MHZ                      (24000000uL)
N#define CapSense_MOD_CSD_CLK_48MHZ                      (48000000uL)
N
N#if (CapSense_ENABLE == CapSense_CSDV2)
X#if ((1u) == (1u))
N    #define CapSense_MIN_SNS_CLK_DIVIDER                (4u)
N#else
S    #define CapSense_MIN_SNS_CLK_DIVIDER                (1u)
N#endif /* (CapSense_ENABLE == CapSense_CSDV2) */
N
N/* ISR Number to work with CyLib functions */
N#define CapSense_ISR_NUMBER                             (CapSense_ISR__INTC_NUMBER)
N
N/* Multi-frequency scanning constants */
N#define CapSense_FREQ_CHANNEL_0                         (0u)
N#define CapSense_FREQ_CHANNEL_1                         (1u)
N#define CapSense_FREQ_CHANNEL_2                         (2u)
N
N/* Bit-mask which says that scanning is not complete */
N#define CapSense_SW_STS_BUSY                            (CapSense_STATUS_CSD0_MASK)
N#define CapSense_NOT_BUSY                               (0u)
N
N#define CapSense_WDGT_SW_STS_BUSY                       (CapSense_STATUS_WDGT0_BUSY_MASK)
N
N#define CapSense_DELAY_EXTRACYCLES_NUM                  (9u)
N#define CapSense_GLITCH_ELIMINATION_CYCLES_CALC         (CapSense_CSD_PRESCAN_SETTLING_TIME * CYDEV_BCLK__SYSCLK__MHZ)
N#define CapSense_CMOD_DISCHARGE_TIME                    (2u)
N#define CapSense_CMOD_DISCHARGE_CYCLES_CALC             (CapSense_CMOD_DISCHARGE_TIME * CYDEV_BCLK__SYSCLK__MHZ)
N
N#if(CapSense_GLITCH_ELIMINATION_CYCLES_CALC >= CapSense_DELAY_EXTRACYCLES_NUM)
X#if(((5u) * 48U) >= (9u))
N    #define CapSense_GLITCH_ELIMINATION_CYCLES          (CapSense_GLITCH_ELIMINATION_CYCLES_CALC -\
N                                                                CapSense_DELAY_EXTRACYCLES_NUM)
X    #define CapSense_GLITCH_ELIMINATION_CYCLES          (CapSense_GLITCH_ELIMINATION_CYCLES_CALC -                                                                CapSense_DELAY_EXTRACYCLES_NUM)
N#else
S    #define CapSense_GLITCH_ELIMINATION_CYCLES          (CapSense_GLITCH_ELIMINATION_CYCLES_CALC)
N#endif /* (CapSense_GLITCH_ELIMINATION_CYCLES_CALC >= CapSense_DELAY_EXTRACYCLES_NUM) */
N
N#if(CapSense_CMOD_DISCHARGE_CYCLES_CALC >= CapSense_DELAY_EXTRACYCLES_NUM)
X#if(((2u) * 48U) >= (9u))
N    #define CapSense_CMOD_DISCHARGE_CYCLES              (CapSense_CMOD_DISCHARGE_CYCLES_CALC -\
N                                                                CapSense_DELAY_EXTRACYCLES_NUM)
X    #define CapSense_CMOD_DISCHARGE_CYCLES              (CapSense_CMOD_DISCHARGE_CYCLES_CALC -                                                                CapSense_DELAY_EXTRACYCLES_NUM)
N#else
S    #define CapSense_CMOD_DISCHARGE_CYCLES              (CapSense_CMOD_DISCHARGE_CYCLES_CALC)
N#endif /* (CapSense_CMOD_DISCHARGE_CYCLES_CALC >= CapSense_DELAY_EXTRACYCLES_NUM) */
N
N#define CapSense_PRECHARGE_IDAC_MOD_VAL                 (0xF0u)
N#define CapSense_CSD_IDAC_PRECHARGE_CONFIG              (CapSense_IDAC_MOD_MODE_VARIABLE |\
N                                                                 CapSense_IDAC_MOD_RANGE_MASK |\
N                                                                 CapSense_IDAC_FEEDBACK_MODE_MASK |\
N                                                                 CapSense_PRECHARGE_IDAC_MOD_VAL)
X#define CapSense_CSD_IDAC_PRECHARGE_CONFIG              (CapSense_IDAC_MOD_MODE_VARIABLE |                                                                 CapSense_IDAC_MOD_RANGE_MASK |                                                                 CapSense_IDAC_FEEDBACK_MODE_MASK |                                                                 CapSense_PRECHARGE_IDAC_MOD_VAL)
N
N#define CapSense_CNT_RESOLUTION_12_BITS                 (0x0FFF0000Lu)
N#define CapSense_ONE_CYCLE                              (0x00010000Lu)
N#define CapSense_RESOLUTION_16_BITS                     (0xFFFF0000Lu)
N#define CapSense_DISCONNECT_IO_FLAG                     (1u)
N#define CapSense_PRESCALERS_TBL_SIZE                    (16u)
N
N/* Calibration constants */
N#define CapSense_CALIBRATION_LEVEL_85                   (85u)
N#define CapSense_PERCENTAGE_100                         (0x00000064Lu)
N#define CapSense_IDAC_MOD_MAX_CALIB_ERROR_NEG           (10u)
N#define CapSense_IDAC_MOD_MAX_CALIB_ERROR_POS           (10u)
N#define CapSense_IDAC_MOD_MAX_INT_MATH_SHIFT            (16u)
N#define CapSense_IDAC_MOD_MAX_CALIB_ERROR_MULT          ((((CapSense_PERCENTAGE_100 + CapSense_IDAC_MOD_MAX_CALIB_ERROR_POS + 1u) \
N                                                                 << CapSense_IDAC_MOD_MAX_INT_MATH_SHIFT) / CapSense_PERCENTAGE_100))
X#define CapSense_IDAC_MOD_MAX_CALIB_ERROR_MULT          ((((CapSense_PERCENTAGE_100 + CapSense_IDAC_MOD_MAX_CALIB_ERROR_POS + 1u)                                                                  << CapSense_IDAC_MOD_MAX_INT_MATH_SHIFT) / CapSense_PERCENTAGE_100))
N#define CapSense_IDAC_MOD_MIN_CALIB_ERROR_MULT          ((((CapSense_PERCENTAGE_100 - CapSense_IDAC_MOD_MAX_CALIB_ERROR_NEG - 1u) \
N                                                                 << CapSense_IDAC_MOD_MAX_INT_MATH_SHIFT) / CapSense_PERCENTAGE_100))
X#define CapSense_IDAC_MOD_MIN_CALIB_ERROR_MULT          ((((CapSense_PERCENTAGE_100 - CapSense_IDAC_MOD_MAX_CALIB_ERROR_NEG - 1u)                                                                  << CapSense_IDAC_MOD_MAX_INT_MATH_SHIFT) / CapSense_PERCENTAGE_100))
N
N
N#if (CapSense_IDAC_GAIN_8X == CapSense_CSD_IDAC_GAIN)
X#if ((8u) == ((2uL)))
S    #define CapSense_CSD_IDAC_GAIN_VALUE_NA             (2400u)
N#elif (CapSense_IDAC_GAIN_HIGH == CapSense_CSD_IDAC_GAIN)
X#elif ((2uL) == ((2uL)))
N    #define CapSense_CSD_IDAC_GAIN_VALUE_NA             (2400u)
N#elif (CapSense_IDAC_GAIN_4X == CapSense_CSD_IDAC_GAIN)
S    #define CapSense_CSD_IDAC_GAIN_VALUE_NA             (1200u)
S#elif (CapSense_IDAC_GAIN_MEDIUM == CapSense_CSD_IDAC_GAIN)
S    #define CapSense_CSD_IDAC_GAIN_VALUE_NA             (300u)
S#else
S    #define CapSense_CSD_IDAC_GAIN_VALUE_NA             (37u)
N#endif /* (CapSense_IDAC_GAIN_8X == CapSense_CSD_IDAC_GAIN) */
N
N#if (CapSense_ENABLE == CapSense_CSD_IDAC_COMP_EN)
X#if ((1u) == (1u))
N    #define CapSense_CSD_DUAL_IDAC_FACTOR               (2u)
N#else
S    #define CapSense_CSD_DUAL_IDAC_FACTOR               (1u)
N#endif /* (CapSense_ENABLE == CapSense_CSD_IDAC_COMP_EN) */
N
N#define CapSense_EMPTY_SLOT                             (255u)
N
N#endif /* End CY_SENSE_CapSense_SENSING_H */
N
N
N/* [] END OF FILE */
L 48 "Generated_Source\PSoC4\CapSense.h" 2
N#if (CapSense_ENABLE == CapSense_CSD_EN)
X#if ((1u) == (1u))
N    #include "CapSense_SensingCSD_LL.h"
L 1 "Generated_Source\PSoC4\CapSense_SensingCSD_LL.h" 1
N/***************************************************************************//**
N* \file CapSense_SensingCSD_LL.h
N* \version 5.0
N*
N* \brief
N*   This file provides the headers of APIs specific to CSD sensing implementation.
N*
N* \see CapSense v5.0 Datasheet
N*
N*//*****************************************************************************
N* Copyright (2016-2017), Cypress Semiconductor Corporation.
N********************************************************************************
N* This software is owned by Cypress Semiconductor Corporation (Cypress) and is
N* protected by and subject to worldwide patent protection (United States and
N* foreign), United States copyright laws and international treaty provisions.
N* Cypress hereby grants to licensee a personal, non-exclusive, non-transferable
N* license to copy, use, modify, create derivative works of, and compile the
N* Cypress Source Code and derivative works for the sole purpose of creating
N* custom software in support of licensee product to be used only in conjunction
N* with a Cypress integrated circuit as specified in the applicable agreement.
N* Any reproduction, modification, translation, compilation, or representation of
N* this software except as specified above is prohibited without the express
N* written permission of Cypress.
N*
N* Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH
N* REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
N* Cypress reserves the right to make changes without further notice to the
N* materials described herein. Cypress does not assume any liability arising out
N* of the application or use of any product or circuit described herein. Cypress
N* does not authorize its products for use as critical components in life-support
N* systems where a malfunction or failure may reasonably be expected to result in
N* significant injury to the user. The inclusion of Cypress' product in a life-
N* support systems application implies that the manufacturer assumes all risk of
N* such use and in doing so indemnifies Cypress against all charges. Use may be
N* limited by and subject to the applicable Cypress software license agreement.
N*******************************************************************************/
N
N#if !defined(CY_SENSE_CapSense_SENSINGCSD_LL_H)
X#if !0L
N#define CY_SENSE_CapSense_SENSINGCSD_LL_H
N
N#include <CyLib.h>
N#include <cyfitter.h>
N#include <cytypes.h>
N#include <cypins.h>
N#include "CapSense_Structure.h"
N#include "CapSense_Configuration.h"
N#include "CapSense_Sensing.h"
N
N/****************************************************************************
N* Register and mode mask definition
N****************************************************************************/
N
N#if (CapSense_ENABLE == CapSense_CSDV2)
X#if ((1u) == (1u))
N    #define CapSense_CSD_CSDCMP_INIT                                (CapSense_CSDCMP_CSDCMP_DISABLED)
N
N    /* SW_HS_P_SEL switches state for Coarse initialization of CMOD (sense path) */
N    #if (CapSense_ENABLE == CapSense_CSD_EN)
X    #if ((1u) == (1u))
N        #if (CapSense_CSD__CMOD_PAD == CapSense_CMOD_CONNECTION)
X        #if (1u == (1u))
N            #define CapSense_CSD_HS_P_SEL_COARSE_CMOD               (CapSense_SW_HS_P_SEL_SW_HMPM_STATIC_CLOSE)
N        #elif (CapSense_CSD__CSHIELD_PAD == CapSense_CMOD_CONNECTION)
S            #define CapSense_CSD_HS_P_SEL_COARSE_CMOD               (CapSense_SW_HS_P_SEL_SW_HMPS_STATIC_CLOSE)
S        #else
S            #define CapSense_CSD_HS_P_SEL_COARSE_CMOD               (CapSense_SW_HS_P_SEL_SW_HMPT_STATIC_CLOSE)
N        #endif /* (CapSense_CSD__CMOD_PAD == CapSense_CMOD_CONNECTION) */
N    #else
S        #define CapSense_CSD_HS_P_SEL_COARSE_CMOD                   (0x00000000uL)
N    #endif /* ((CapSense_ENABLE == CapSense_CSD_CSX_EN) && (CapSense_ENABLE == CapSense_CSD_EN)) */
N
N    #if ((CapSense_ENABLE == CapSense_CSD_SHIELD_TANK_EN) && \
N        (CapSense_ENABLE == CapSense_CSD_SHIELD_EN))
X    #if (((1u) == (0u)) &&         ((1u) == (0u)))
S        /* SW_HS_P_SEL switches state for Coarse initialization of CTANK (sense path) */
S        #if (CapSense_CSD__CSH_TANK_PAD == CapSense_CTANK_CONNECTION)
S            #define CapSense_CSD_HS_P_SEL_COARSE_TANK               (CapSense_SW_HS_P_SEL_SW_HMPT_STATIC_CLOSE)
S        #elif (CapSense_CSD__CSHIELD_PAD == CapSense_CTANK_CONNECTION)
S            #define CapSense_CSD_HS_P_SEL_COARSE_TANK               (CapSense_SW_HS_P_SEL_SW_HMPS_STATIC_CLOSE)
S        #elif (CapSense_CSD__CMOD_PAD == CapSense_CTANK_CONNECTION)
S            #define CapSense_CSD_HS_P_SEL_COARSE_TANK               (CapSense_SW_HS_P_SEL_SW_HMPM_STATIC_CLOSE)
S        #else
S            #define CapSense_CSD_HS_P_SEL_COARSE_TANK               (CapSense_SW_HS_P_SEL_SW_HMMA_STATIC_CLOSE)
S        #endif /* (CapSense_CSD__CSH_TANK_PAD == CapSense_CTANK_CONNECTION) */
N    #else
N        #define CapSense_CSD_HS_P_SEL_COARSE_TANK                   (0x00000000uL)
N    #endif /* ((CapSense_ENABLE == CapSense_CSD_SHIELD_TANK_EN) && \
N               (CapSense_ENABLE == CapSense_CSD_SHIELD_EN)) */
X    #endif  
N
N    #define CapSense_CSD_SW_HS_P_SEL_COARSE                         (CapSense_HS_P_SEL_COARSE_CMOD | CapSense_CSD_HS_P_SEL_COARSE_TANK)
N
N    /* C_mod config */
N    #if ((CapSense_CSD__CMOD_PAD == CapSense_CMOD_CONNECTION) || (CapSense_CSD__CMOD_PAD == CapSense_CTANK_CONNECTION))
X    #if ((1u == (1u)) || (1u == (0x00000000uL)))
N        #define CapSense_CSD_SW_FW_MOD_SEL_INIT             (CapSense_SW_FW_MOD_SEL_SW_F1PM_STATIC_CLOSE |\
N                                                                     CapSense_SW_FW_MOD_SEL_SW_F1MA_STATIC_CLOSE |\
N                                                                     CapSense_SW_FW_MOD_SEL_SW_F1CA_STATIC_CLOSE)
X        #define CapSense_CSD_SW_FW_MOD_SEL_INIT             (CapSense_SW_FW_MOD_SEL_SW_F1PM_STATIC_CLOSE |                                                                     CapSense_SW_FW_MOD_SEL_SW_F1MA_STATIC_CLOSE |                                                                     CapSense_SW_FW_MOD_SEL_SW_F1CA_STATIC_CLOSE)
N        #define CapSense_SW_DSI_SEL_CMODPAD                 (CapSense_SW_DSI_CMOD)
N    #else
S        #define CapSense_CSD_SW_FW_MOD_SEL_INIT             (0x00000000uL)
S        #define CapSense_SW_DSI_SEL_CMODPAD                 (0x00000000uL)
N    #endif /* (CapSense_CSD__CMOD_PAD == CapSense_CMOD_CONNECTION) */
N
N    /* C_tank config */
N    #if ((CapSense_CSD__CSH_TANK_PAD == CapSense_CMOD_CONNECTION) || (CapSense_CSD__CSH_TANK_PAD == CapSense_CTANK_CONNECTION))
X    #if ((2u == (1u)) || (2u == (0x00000000uL)))
S        #define CapSense_CSD_SW_FW_TANK_SEL_INIT            (CapSense_SW_FW_TANK_SEL_SW_F2PT_STATIC_CLOSE |\
S                                                                     CapSense_SW_FW_TANK_SEL_SW_F2MA_STATIC_CLOSE |\
S                                                                     CapSense_SW_FW_TANK_SEL_SW_F2CA_STATIC_CLOSE)
X        #define CapSense_CSD_SW_FW_TANK_SEL_INIT            (CapSense_SW_FW_TANK_SEL_SW_F2PT_STATIC_CLOSE |                                                                     CapSense_SW_FW_TANK_SEL_SW_F2MA_STATIC_CLOSE |                                                                     CapSense_SW_FW_TANK_SEL_SW_F2CA_STATIC_CLOSE)
S        #define CapSense_SW_DSI_SEL_TANKPAD                 (CapSense_SW_DSI_CTANK)
N    #else
N        #define CapSense_CSD_SW_FW_TANK_SEL_INIT            (0x00000000uL)
N        #define CapSense_SW_DSI_SEL_TANKPAD                 (0x00000000uL)
N    #endif /* (CapSense_CSD__CSH_TANK_PAD == CapSense_CTANK_CONNECTION) */
N
N    #define CapSense_CSD_SW_SHIELD_SEL_INIT                 (CapSense_SW_SHIELD_SEL_SW_HCAV_HSCMP)
N
N    /* Defining default HW configuration according to settings in customizer. */
N    #define CapSense_DEFAULT_CSD_CONFIG                 (CapSense_CONFIG_FILTER_DELAY_12MHZ |\
N                                                                 CapSense_CONFIG_SAMPLE_SYNC_MASK)
X    #define CapSense_DEFAULT_CSD_CONFIG                 (CapSense_CONFIG_FILTER_DELAY_12MHZ |                                                                 CapSense_CONFIG_SAMPLE_SYNC_MASK)
N    #if (CapSense_ENABLE == CapSense_CSD_AUTO_ZERO_EN)
X    #if ((1u) == (0u))
S        /* Enable CSDCMP */
S        #define CapSense_CSD_CSDCMP_SCAN                (CapSense_CSDCMP_CSDCMP_EN_MASK |\
S                                                                 CapSense_CSDCMP_AZ_EN_MASK)
X        #define CapSense_CSD_CSDCMP_SCAN                (CapSense_CSDCMP_CSDCMP_EN_MASK |                                                                 CapSense_CSDCMP_AZ_EN_MASK)
N    #else
N        /* Enable CSDCMP */
N        #define CapSense_CSD_CSDCMP_SCAN                (CapSense_CSDCMP_CSDCMP_EN_MASK)
N    #endif /* (CapSense_ENABLE == CapSense_CSD_AUTO_ZERO_EN) */
N
N    #if ((CapSense_ENABLE == CapSense_CSD_SHIELD_TANK_EN) && \
N        (CapSense_ENABLE == CapSense_CSD_SHIELD_EN))
X    #if (((1u) == (0u)) &&         ((1u) == (0u)))
S        /* SW_HS_P_SEL switches state for Coarse initialization of CTANK (sense path) */
S        #if (CapSense_CSD__CSH_TANK_PAD == CapSense_CTANK_CONNECTION)
S            #define CapSense_CSD_HS_P_SEL_SCAN_TANK                 (CapSense_SW_HS_P_SEL_SW_HMPT_STATIC_CLOSE)
S        #elif (CapSense_CSD__CSHIELD_PAD == CapSense_CTANK_CONNECTION)
S            #define CapSense_CSD_HS_P_SEL_SCAN_TANK                 (CapSense_SW_HS_P_SEL_SW_HMPS_STATIC_CLOSE)
S        #elif (CapSense_CSD__CMOD_PAD == CapSense_CTANK_CONNECTION)
S            #define CapSense_CSD_HS_P_SEL_SCAN_TANK                 (CapSense_SW_HS_P_SEL_SW_HMPM_STATIC_CLOSE)
S        #else
S            #define CapSense_CSD_HS_P_SEL_SCAN_TANK                 (CapSense_SW_HS_P_SEL_SW_HMMB_STATIC_CLOSE)
S        #endif /* (CapSense_CSD__CSH_TANK_PAD == CapSense_CTANK_CONNECTION) */
S        #define CapSense_CSD_SW_HS_P_SEL_SCAN                       (CapSense_HS_P_SEL_SCAN_TANK)
S    #elif(CapSense_ENABLE == CapSense_CSD_SHIELD_EN)
X    #elif((1u) == (0u))
S        #define CapSense_CSD_SW_HS_P_SEL_SCAN                       (CapSense_SW_HS_P_SEL_SW_HMMB_STATIC_CLOSE)
N    #else
N        #define CapSense_CSD_SW_HS_P_SEL_SCAN                       (CapSense_STATIC_OPEN)
N    #endif /* ((CapSense_ENABLE == CapSense_CSD_SHIELD_TANK_EN) && \
N               (CapSense_ENABLE == CapSense_CSD_SHIELD_EN)) */
X    #endif  
N
N    /* SW_FW_MOD_SEL switches state for Coarse initialization of CMOD (sense path) */
N    #define CapSense_CSD_SW_FW_MOD_SEL_SCAN                 (0x00000000uL)
N
N    #if((CapSense_ENABLE == CapSense_CSD_SHIELD_EN) && \
N        (CapSense_ENABLE == CapSense_CSD_SHIELD_TANK_EN) && \
N        (CapSense_CSD__CSH_TANK_PAD == CapSense_CTANK_CONNECTION))
X    #if(((1u) == (0u)) &&         ((1u) == (0u)) &&         (2u == (0x00000000uL)))
S        #define CapSense_CSD_SW_FW_TANK_SEL_SCAN            (CapSense_SW_FW_TANK_SEL_SW_F2PT_STATIC_CLOSE | \
S                                                                 CapSense_SW_FW_TANK_SEL_SW_F2CB_STATIC_CLOSE)
X        #define CapSense_CSD_SW_FW_TANK_SEL_SCAN            (CapSense_SW_FW_TANK_SEL_SW_F2PT_STATIC_CLOSE |                                                                  CapSense_SW_FW_TANK_SEL_SW_F2CB_STATIC_CLOSE)
N    #else
N        #define CapSense_CSD_SW_FW_TANK_SEL_SCAN            (0x00000000uL)
N    #endif /* ((CapSense_ENABLE == CapSense_CSD_SHIELD_EN) && \
N               (CapSense_ENABLE == CapSense_CSD_SHIELD_TANK_EN) && \
N               (CapSense_CSD__CSH_TANK_PAD == CapSense_CTANK_CONNECTION)) */
X    #endif  
N
N    /* Shield switch default config */
N    #if ((CapSense_ENABLE == CapSense_CSD_SHIELD_EN) && \
N         (CapSense_ENABLE == CapSense_CSD_SHIELD_TANK_EN))
X    #if (((1u) == (0u)) &&          ((1u) == (0u)))
S        #if (CapSense_IDAC_SINKING == CapSense_CSD_IDAC_CONFIG)
S            #define CapSense_CSD_SW_SHIELD_SEL_SCAN          (CapSense_SW_SHIELD_SEL_SW_HCBG_HSCMP)
S        #else
S            #define CapSense_CSD_SW_SHIELD_SEL_SCAN          (CapSense_SW_SHIELD_SEL_SW_HCBV_HSCMP)
S        #endif /* (CapSense_IDAC_SINKING == CapSense_CSD_IDAC_CONFIG) */
S    #elif(CapSense_ENABLE == CapSense_CSD_SHIELD_EN)
X    #elif((1u) == (0u))
S        #if (CapSense_IDAC_SINKING == CapSense_CSD_IDAC_CONFIG)
S            #define CapSense_CSD_SW_SHIELD_SEL_SCAN          (CapSense_SW_SHIELD_SEL_SW_HCBV_PHI1 | \
S                                                                     CapSense_SW_SHIELD_SEL_SW_HCBG_PHI2_HSCMP)
X            #define CapSense_CSD_SW_SHIELD_SEL_SCAN          (CapSense_SW_SHIELD_SEL_SW_HCBV_PHI1 |                                                                      CapSense_SW_SHIELD_SEL_SW_HCBG_PHI2_HSCMP)
S        #else
S            #define CapSense_CSD_SW_SHIELD_SEL_SCAN          (CapSense_SW_SHIELD_SEL_SW_HCBG_PHI1 | \
S                                                                     CapSense_SW_SHIELD_SEL_SW_HCBV_PHI2_HSCMP)
X            #define CapSense_CSD_SW_SHIELD_SEL_SCAN          (CapSense_SW_SHIELD_SEL_SW_HCBG_PHI1 |                                                                      CapSense_SW_SHIELD_SEL_SW_HCBV_PHI2_HSCMP)
S        #endif /* (CapSense_IDAC_SINKING == CapSense_CSD_IDAC_CONFIG) */
N    #else
N        #define CapSense_CSD_SW_SHIELD_SEL_SCAN              (0x00000000uL)
N    #endif /* ((CapSense_ENABLE == CapSense_CSD_SHIELD_EN) && \
N               (CapSense_ENABLE == CapSense_CSD_SHIELD_TANK_EN)) */
X    #endif  
N
N    #define CapSense_CSD_SW_RES_INIT                        (CapSense_CSD_INIT_SWITCH_RES << CYFLD_CSD_RES_HCAV__OFFSET)
N    #define CapSense_CSD_SW_RES_SCAN                        ((CapSense_CSD_SHIELD_SWITCH_RES << CYFLD_CSD_RES_HCBV__OFFSET) |\
N                                                                     (CapSense_CSD_SHIELD_SWITCH_RES << CYFLD_CSD_RES_HCBG__OFFSET))
X    #define CapSense_CSD_SW_RES_SCAN                        ((CapSense_CSD_SHIELD_SWITCH_RES << CYFLD_CSD_RES_HCBV__OFFSET) |                                                                     (CapSense_CSD_SHIELD_SWITCH_RES << CYFLD_CSD_RES_HCBG__OFFSET))
N
N    #define CapSense_CSD_SHIELD_GPIO_DM                 (CapSense_GPIO_STRGDRV)
N    #define CapSense_CSD_SENSOR_HSIOM_SEL               (CapSense_HSIOM_SEL_CSD_SENSE)
N    #define CapSense_CSD_SHIELD_HSIOM_SEL               (CapSense_HSIOM_SEL_CSD_SHIELD)
N    #define CapSense_CSD_CMOD_HSIOM_SEL                 (CapSense_HSIOM_SEL_AMUXA)
N
N    #define CapSense_DEFAULT_IDAC_MOD_BALL_MODE         ((uint32)CapSense_IDAC_MOD_BALL_MODE_FULL <<\
N                                                                 CYFLD_CSD_BAL_MODE__OFFSET)
X    #define CapSense_DEFAULT_IDAC_MOD_BALL_MODE         ((uint32)CapSense_IDAC_MOD_BALL_MODE_FULL <<                                                                 CYFLD_CSD_BAL_MODE__OFFSET)
N    #define CapSense_DEFAULT_IDAC_COMP_BALL_MODE        ((uint32)CapSense_IDAC_COMP_BALL_MODE_FULL <<\
N                                                                 CYFLD_CSD_BAL_MODE__OFFSET)
X    #define CapSense_DEFAULT_IDAC_COMP_BALL_MODE        ((uint32)CapSense_IDAC_COMP_BALL_MODE_FULL <<                                                                 CYFLD_CSD_BAL_MODE__OFFSET)
N
N    #define CapSense_DEFAULT_SENSE_DUTY_SEL             (CapSense_SENSE_DUTY_OVERLAP_PHI1_MASK |\
N                                                                 CapSense_SENSE_DUTY_OVERLAP_PHI2_MASK)
X    #define CapSense_DEFAULT_SENSE_DUTY_SEL             (CapSense_SENSE_DUTY_OVERLAP_PHI1_MASK |                                                                 CapSense_SENSE_DUTY_OVERLAP_PHI2_MASK)
N
N    #define CapSense_CSD_IDAC_MOD_BITS_USED                     (7u)
N    #define CapSense_CAL_MIDDLE_BIT                             (1uL << (CapSense_CSD_IDAC_MOD_BITS_USED - 1u))
N
N    #define CapSense_DELAY_EXTRACYCLES_NUM                      (9u)
N
N    #if (CapSense_IDAC_GAIN_HIGH == CapSense_CSD_IDAC_GAIN)
X    #if ((2uL) == ((2uL)))
N        #define CapSense_CSD_IDAC_GAIN_VALUE_NA                 (2400u)
N    #elif (CapSense_IDAC_GAIN_MEDIUM == CapSense_CSD_IDAC_GAIN)
S        #define CapSense_CSD_IDAC_GAIN_VALUE_NA                 (300u)
S    #else
S        #define CapSense_CSD_IDAC_GAIN_VALUE_NA                 (37u)
N    #endif /* (CapSense_IDAC_GAIN_HIGH == CapSense_CSD_IDAC_GAIN) */
N
N    /* Defining the drive mode of pins depending on the Inactive sensor connection setting in the Component customizer. */
N    #if(CapSense_SNS_CONNECTION_GROUND == CapSense_CSD_INACTIVE_SNS_CONNECTION)
X    #if((0x00000006Lu) == ((0x00000006Lu)))
N        #define CapSense_CSD_INACTIVE_SNS_GPIO_DM               (CY_SYS_PINS_DM_STRONG)
N    #elif(CapSense_SNS_CONNECTION_HIGHZ == CapSense_CSD_INACTIVE_SNS_CONNECTION)
S        #define CapSense_CSD_INACTIVE_SNS_GPIO_DM               (CY_SYS_PINS_DM_ALG_HIZ)
S    #elif(CapSense_SNS_CONNECTION_SHIELD == CapSense_CSD_INACTIVE_SNS_CONNECTION)
S        #define CapSense_CSD_INACTIVE_SNS_GPIO_DM               (CY_SYS_PINS_DM_ALG_HIZ)
S    #else
S        #error "Unsupported inactive connection for the inactive sensors."
N    #endif /* (CapSense_SNS_CONNECTION_GROUND == CapSense_CSD_INACTIVE_SNS_CONNECTION) */
N
N
N    /* Clock Source Mode */
N    #if (CapSense_CLK_SOURCE_DIRECT == CapSense_CSD_SNS_CLK_SOURCE)
X    #if ((0x00000000Lu) == ((0xFFu)))
S        #define CapSense_DEFAULT_MODULATION_MODE                (CapSense_CLK_SOURCE_DIRECT)
N    #elif (CapSense_CLK_SOURCE_PRSAUTO == CapSense_CSD_SNS_CLK_SOURCE)
X    #elif ((0xFFu) == ((0xFFu)))
N        #define CapSense_DEFAULT_MODULATION_MODE                (CapSense_CLK_SOURCE_SSC2)
N    #elif ((CapSense_CLK_SOURCE_PRS8) == CapSense_CSD_SNS_CLK_SOURCE)
S        #define CapSense_DEFAULT_MODULATION_MODE                (CapSense_CSD_SNS_CLK_SOURCE)
S    #elif ((CapSense_CLK_SOURCE_PRS12) == CapSense_CSD_SNS_CLK_SOURCE)
S        #define CapSense_DEFAULT_MODULATION_MODE                (CapSense_CSD_SNS_CLK_SOURCE)
S    #else
S        #define CapSense_DEFAULT_MODULATION_MODE                (CapSense_CSD_SNS_CLK_SOURCE)
N    #endif /* (CapSense_CLK_SOURCE_DIRECT != CapSense_CSD_SNS_CLK_SOURCE) */
N
N    /* IDACs Ranges */
N    #if (CapSense_IDAC_GAIN_LOW == CapSense_CSD_IDAC_GAIN)
X    #if ((0uL) == ((2uL)))
S        #define CapSense_DEFAULT_IDAC_MOD_RANGE                 ((uint32)CapSense_IDAC_MOD_RANGE_IDAC_LO << CYFLD_CSD_RANGE__OFFSET)
S        #define CapSense_DEFAULT_IDAC_COMP_RANGE                ((uint32)CapSense_IDAC_COMP_RANGE_IDAC_LO << CYFLD_CSD_RANGE__OFFSET)
S    #elif (CapSense_IDAC_GAIN_MEDIUM == CapSense_CSD_IDAC_GAIN)
X    #elif ((1uL) == ((2uL)))
S        #define CapSense_DEFAULT_IDAC_MOD_RANGE                 ((uint32)CapSense_IDAC_MOD_RANGE_IDAC_MED << CYFLD_CSD_RANGE__OFFSET)
S        #define CapSense_DEFAULT_IDAC_COMP_RANGE                ((uint32)CapSense_IDAC_COMP_RANGE_IDAC_MED << CYFLD_CSD_RANGE__OFFSET)
N    #else
N        #define CapSense_DEFAULT_IDAC_MOD_RANGE                 ((uint32)CapSense_IDAC_MOD_RANGE_IDAC_HI << CYFLD_CSD_RANGE__OFFSET)
N        #define CapSense_DEFAULT_IDAC_COMP_RANGE                ((uint32)CapSense_IDAC_COMP_RANGE_IDAC_HI << CYFLD_CSD_RANGE__OFFSET)
N    #endif
N
N    /* IDACs Polarities */
N    #if (CapSense_IDAC_SINKING == CapSense_CSD_IDAC_CONFIG)
X    #if ((1u) == ((0u)))
S        #define CapSense_DEFAULT_IDAC_MOD_POLARITY              ((uint32)CapSense_IDAC_MOD_POLARITY_VDDA_SNK << CYFLD_CSD_POLARITY__OFFSET)
S        #define CapSense_DEFAULT_IDAC_COMP_POLARITY             ((uint32)CapSense_IDAC_COMP_POLARITY_VDDA_SNK << CYFLD_CSD_POLARITY__OFFSET)
N    #else
N        #define CapSense_DEFAULT_IDAC_MOD_POLARITY              ((uint32)CapSense_IDAC_MOD_POLARITY_VSSA_SRC << CYFLD_CSD_POLARITY__OFFSET)
N        #define CapSense_DEFAULT_IDAC_COMP_POLARITY             ((uint32)CapSense_IDAC_COMP_POLARITY_VSSA_SRC << CYFLD_CSD_POLARITY__OFFSET)
N    #endif /* (CapSense_IDAC_SINKING == CapSense_CSD_IDAC_CONFIG) */
N
N    #define CapSense_SW_REFGEN_VREF_SRC                         (CapSense_SW_REFGEN_SEL_SW_SGR_MASK)
N
N    /* IDAC legs configuration */
N    #if ((CapSense_ENABLE == CapSense_CSD_IDAC_COMP_EN) && \
N         (CapSense_ENABLE == CapSense_CSD_DEDICATED_IDAC_COMP_EN))
X    #if (((1u) == (1u)) &&          ((1u) == (1u)))
N            #define CapSense_DEFAULT_SW_REFGEN_SEL              (CapSense_SW_REFGEN_VREF_SRC | CapSense_SW_REFGEN_SEL_SW_IAIB_MASK)
N            #define CapSense_DEFAULT_IDAC_COMP_LEG1_MODE        (CapSense_IDAC_COMP_LEG1_EN_MASK |\
N                                                                        ((uint32)CapSense_IDAC_COMP_LEG1_MODE_CSD_STATIC << CYFLD_CSD_LEG1_MODE__OFFSET))
X            #define CapSense_DEFAULT_IDAC_COMP_LEG1_MODE        (CapSense_IDAC_COMP_LEG1_EN_MASK |                                                                        ((uint32)CapSense_IDAC_COMP_LEG1_MODE_CSD_STATIC << CYFLD_CSD_LEG1_MODE__OFFSET))
N    #else
S            #define CapSense_DEFAULT_SW_REFGEN_SEL              (CapSense_SW_REFGEN_VREF_SRC)
S            #define CapSense_DEFAULT_IDAC_COMP_LEG1_MODE        ((uint32)CapSense_IDAC_COMP_LEG1_MODE_CSD_STATIC << CYFLD_CSD_LEG1_MODE__OFFSET)
N    #endif /* ((CapSense_ENABLE == CapSense_CSD_IDAC_COMP_EN) && \
N               (CapSense_ENABLE == CapSense_CSD_DEDICATED_IDAC_COMP_EN)) */
X    #endif  
N
N
N    #if ((CapSense_ENABLE == CapSense_CSD_IDAC_COMP_EN) && \
N         (CapSense_DISABLE == CapSense_CSD_DEDICATED_IDAC_COMP_EN))
X    #if (((1u) == (1u)) &&          ((0u) == (1u)))
S            #define CapSense_DEFAULT_IDAC_COMP_LEG2_MODE        (CapSense_IDAC_COMP_LEG2_EN_MASK |\
S                                                                        ((uint32)CapSense_IDAC_COMP_LEG2_MODE_CSD_STATIC << CYFLD_CSD_LEG2_MODE__OFFSET))
X            #define CapSense_DEFAULT_IDAC_COMP_LEG2_MODE        (CapSense_IDAC_COMP_LEG2_EN_MASK |                                                                        ((uint32)CapSense_IDAC_COMP_LEG2_MODE_CSD_STATIC << CYFLD_CSD_LEG2_MODE__OFFSET))
N    #else
N            #define CapSense_DEFAULT_IDAC_COMP_LEG2_MODE        ((uint32)CapSense_IDAC_COMP_LEG2_MODE_GP_STATIC << CYFLD_CSD_LEG2_MODE__OFFSET)
N    #endif /* ((CapSense_ENABLE == CapSense_CSD_IDAC_COMP_EN) && \
N            (CapSense_DISABLE == CapSense_CSD_DEDICATED_IDAC_COMP_EN)) */
X    #endif  
N
N    /* IDACs register configuration is based on the Component configuration */
N    #define CapSense_IDAC_MOD_DEFAULT_CFG                       (CapSense_DEFAULT_IDAC_MOD_RANGE | \
N                                                                         CapSense_DEFAULT_IDAC_MOD_POLARITY | \
N                                                                         CapSense_DEFAULT_IDAC_MOD_BALL_MODE | \
N                                                                        ((uint32)(CapSense_IDAC_MOD_LEG1_MODE_CSD << CYFLD_CSD_LEG1_MODE__OFFSET)) | \
N                                                                         CapSense_IDAC_MOD_LEG1_EN_MASK | \
N                                                                         CapSense_DEFAULT_IDAC_COMP_LEG2_MODE)
X    #define CapSense_IDAC_MOD_DEFAULT_CFG                       (CapSense_DEFAULT_IDAC_MOD_RANGE |                                                                          CapSense_DEFAULT_IDAC_MOD_POLARITY |                                                                          CapSense_DEFAULT_IDAC_MOD_BALL_MODE |                                                                         ((uint32)(CapSense_IDAC_MOD_LEG1_MODE_CSD << CYFLD_CSD_LEG1_MODE__OFFSET)) |                                                                          CapSense_IDAC_MOD_LEG1_EN_MASK |                                                                          CapSense_DEFAULT_IDAC_COMP_LEG2_MODE)
N
N    #define CapSense_IDAC_COMP_DEFAULT_CFG                      (CapSense_DEFAULT_IDAC_COMP_RANGE | \
N                                                                         CapSense_DEFAULT_IDAC_COMP_POLARITY | \
N                                                                         CapSense_DEFAULT_IDAC_COMP_BALL_MODE | \
N                                                                         CapSense_DEFAULT_IDAC_COMP_LEG1_MODE | \
N                                                                        ((uint32)(CapSense_IDAC_COMP_LEG2_MODE_GP_STATIC << CYFLD_CSD_LEG2_MODE__OFFSET)))
X    #define CapSense_IDAC_COMP_DEFAULT_CFG                      (CapSense_DEFAULT_IDAC_COMP_RANGE |                                                                          CapSense_DEFAULT_IDAC_COMP_POLARITY |                                                                          CapSense_DEFAULT_IDAC_COMP_BALL_MODE |                                                                          CapSense_DEFAULT_IDAC_COMP_LEG1_MODE |                                                                         ((uint32)(CapSense_IDAC_COMP_LEG2_MODE_GP_STATIC << CYFLD_CSD_LEG2_MODE__OFFSET)))
N
N    #define CapSense_IDAC_MOD_CALIBRATION_CFG                   ((uint32)(CapSense_DEFAULT_IDAC_MOD_RANGE | \
N                                                                         CapSense_DEFAULT_IDAC_MOD_POLARITY | \
N                                                                         CapSense_DEFAULT_IDAC_MOD_BALL_MODE | \
N                                                                        ((uint32)(CapSense_IDAC_MOD_LEG1_MODE_CSD << CYFLD_CSD_LEG1_MODE__OFFSET)) | \
N                                                                         CapSense_IDAC_MOD_LEG1_EN_MASK | \
N                                                                        ((uint32)((uint32)CapSense_IDAC_MOD_LEG2_MODE_GP_STATIC << CYFLD_CSD_LEG2_MODE__OFFSET))))
X    #define CapSense_IDAC_MOD_CALIBRATION_CFG                   ((uint32)(CapSense_DEFAULT_IDAC_MOD_RANGE |                                                                          CapSense_DEFAULT_IDAC_MOD_POLARITY |                                                                          CapSense_DEFAULT_IDAC_MOD_BALL_MODE |                                                                         ((uint32)(CapSense_IDAC_MOD_LEG1_MODE_CSD << CYFLD_CSD_LEG1_MODE__OFFSET)) |                                                                          CapSense_IDAC_MOD_LEG1_EN_MASK |                                                                         ((uint32)((uint32)CapSense_IDAC_MOD_LEG2_MODE_GP_STATIC << CYFLD_CSD_LEG2_MODE__OFFSET))))
N
N    #define CapSense_IDAC_COMP_CALIBRATION_CFG                  ((uint32)(CapSense_DEFAULT_IDAC_COMP_RANGE | \
N                                                                         CapSense_DEFAULT_IDAC_COMP_POLARITY | \
N                                                                         CapSense_DEFAULT_IDAC_COMP_BALL_MODE | \
N                                                                        ((uint32)((uint32)CapSense_IDAC_COMP_LEG1_MODE_GP_STATIC << CYFLD_CSD_LEG1_MODE__OFFSET)) | \
N                                                                        ((uint32)((uint32)CapSense_IDAC_COMP_LEG2_MODE_GP_STATIC << CYFLD_CSD_LEG2_MODE__OFFSET))))
X    #define CapSense_IDAC_COMP_CALIBRATION_CFG                  ((uint32)(CapSense_DEFAULT_IDAC_COMP_RANGE |                                                                          CapSense_DEFAULT_IDAC_COMP_POLARITY |                                                                          CapSense_DEFAULT_IDAC_COMP_BALL_MODE |                                                                         ((uint32)((uint32)CapSense_IDAC_COMP_LEG1_MODE_GP_STATIC << CYFLD_CSD_LEG1_MODE__OFFSET)) |                                                                         ((uint32)((uint32)CapSense_IDAC_COMP_LEG2_MODE_GP_STATIC << CYFLD_CSD_LEG2_MODE__OFFSET))))
N#else
S    #define CapSense_CSD_IDAC_MOD_BITS_USED                     (8u)
S
S    #define CapSense_IDAC_MOD_CFG_MASK                  (CapSense_IDAC_POLARITY1_MIR_MASK |\
S                                                                CapSense_IDAC_MOD_RANGE_MASK |\
S                                                                CapSense_IDAC_MOD_MODE_MASK |\
S                                                                CapSense_IDAC_MOD_MASK)
X    #define CapSense_IDAC_MOD_CFG_MASK                  (CapSense_IDAC_POLARITY1_MIR_MASK |                                                                CapSense_IDAC_MOD_RANGE_MASK |                                                                CapSense_IDAC_MOD_MODE_MASK |                                                                CapSense_IDAC_MOD_MASK)
S
S    #define CapSense_IDAC_COMP_CFG_MASK                 (CapSense_IDAC_POLARITY2_MIR_MASK |\
S                                                                CapSense_IDAC_COMP_RANGE_MASK |\
S                                                                CapSense_IDAC_COMP_MODE_MASK |\
S                                                                CapSense_IDAC_COMP_MASK)
X    #define CapSense_IDAC_COMP_CFG_MASK                 (CapSense_IDAC_POLARITY2_MIR_MASK |                                                                CapSense_IDAC_COMP_RANGE_MASK |                                                                CapSense_IDAC_COMP_MODE_MASK |                                                                CapSense_IDAC_COMP_MASK)
S
S        #define CapSense_PRS_8_CONFIG                       CapSense_CONFIG_PRS_SELECT_MASK
S    #define CapSense_PRS_12_CONFIG                      (CapSense_CONFIG_PRS_12_8_MASK |\
S                                                                CapSense_CONFIG_PRS_SELECT_MASK)
X    #define CapSense_PRS_12_CONFIG                      (CapSense_CONFIG_PRS_12_8_MASK |                                                                CapSense_CONFIG_PRS_SELECT_MASK)
S
S    /* Third-generation HW block Initial PRS mode */
S    #if (CapSense_CLK_SOURCE_PRS8 == CapSense_CSD_SNS_CLK_SOURCE)
S        #define CapSense_DEFAULT_MODULATION_MODE        CapSense_CONFIG_PRS_SELECT_MASK
S
S    #elif (CapSense_CLK_SOURCE_PRS12 == CapSense_CSD_SNS_CLK_SOURCE)
S        #define CapSense_DEFAULT_MODULATION_MODE        (CapSense_CONFIG_PRS_12_8_MASK |\
S                                                                CapSense_CONFIG_PRS_SELECT_MASK)
X        #define CapSense_DEFAULT_MODULATION_MODE        (CapSense_CONFIG_PRS_12_8_MASK |                                                                CapSense_CONFIG_PRS_SELECT_MASK)
S    #else
S        #define CapSense_DEFAULT_MODULATION_MODE        (0u)
S    #endif /* (CapSense_CSD_SNS_CLK_SOURCE == CapSense_PRS_8BITS) */
S
S    /* Third-generation HW block Set IDAC polarity */
S    #if (CapSense_CSD_IDAC_CONFIG == CapSense_IDAC_SINKING)
S        #define CapSense_DEFAULT_IDAC_POLARITY          CapSense_CONFIG_POLARITY_MASK
S        #define CapSense_CSH_DR_CONFIG                  CapSense_CTANK_DR_VDDIO
S    #else
S        #define CapSense_DEFAULT_IDAC_POLARITY          (0u)
S        #define CapSense_CSH_DR_CONFIG                  CapSense_CTANK_DR_VSSIO
S    #endif /* (CapSense_CSD_IDAC_CONFIG == CapSense_IDAC_SINKING) */
S
S    /* Defining default CSD configuration according to settings in customizer. */
S    #define CapSense_DEFAULT_CSD_CONFIG                 (CapSense_CONFIG_SENSE_COMP_BW_MASK |\
S                                                                CapSense_DEFAULT_IDAC_POLARITY |\
S                                                                CapSense_CONFIG_SENSE_INSEL_MASK |\
S                                                                CapSense_CONFIG_REFBUF_DRV_MASK)
X    #define CapSense_DEFAULT_CSD_CONFIG                 (CapSense_CONFIG_SENSE_COMP_BW_MASK |                                                                CapSense_DEFAULT_IDAC_POLARITY |                                                                CapSense_CONFIG_SENSE_INSEL_MASK |                                                                CapSense_CONFIG_REFBUF_DRV_MASK)
S
S    #define CapSense_CSD_ENABLE_MASK                    (CapSense_CONFIG_ENABLE_MASK |\
S                                                                CapSense_CONFIG_SENSE_EN_MASK |\
S                                                                CapSense_CONFIG_SENSE_COMP_EN_MASK)
X    #define CapSense_CSD_ENABLE_MASK                    (CapSense_CONFIG_ENABLE_MASK |                                                                CapSense_CONFIG_SENSE_EN_MASK |                                                                CapSense_CONFIG_SENSE_COMP_EN_MASK)
S
S    /* Third-generation HW block Defining mask intended for clearing bits related to pre-charging options. */
S    #define CapSense_PRECHARGE_CONFIG_MASK              (CapSense_CONFIG_REFBUF_EN_MASK |\
S                                                                CapSense_CONFIG_COMP_MODE_MASK |\
S                                                                CapSense_CONFIG_COMP_PIN_MASK  |\
S                                                                CapSense_CONFIG_REFBUF_OUTSEL_MASK)
X    #define CapSense_PRECHARGE_CONFIG_MASK              (CapSense_CONFIG_REFBUF_EN_MASK |                                                                CapSense_CONFIG_COMP_MODE_MASK |                                                                CapSense_CONFIG_COMP_PIN_MASK  |                                                                CapSense_CONFIG_REFBUF_OUTSEL_MASK)
S
S    #define CapSense_CMOD_PRECHARGE_CONFIG              (CapSense_DEFAULT_CSD_CONFIG |\
S                                                                CapSense_CONFIG_REFBUF_EN_MASK |\
S                                                                CapSense_CONFIG_COMP_PIN_MASK)
X    #define CapSense_CMOD_PRECHARGE_CONFIG              (CapSense_DEFAULT_CSD_CONFIG |                                                                CapSense_CONFIG_REFBUF_EN_MASK |                                                                CapSense_CONFIG_COMP_PIN_MASK)
S
S    #define CapSense_CMOD_PRECHARGE_CONFIG_CSD_EN       (CapSense_DEFAULT_CSD_CONFIG |\
S                                                                CapSense_CSD_ENABLE_MASK |\
S                                                                CapSense_CONFIG_REFBUF_EN_MASK |\
S                                                                CapSense_CONFIG_COMP_PIN_MASK)
X    #define CapSense_CMOD_PRECHARGE_CONFIG_CSD_EN       (CapSense_DEFAULT_CSD_CONFIG |                                                                CapSense_CSD_ENABLE_MASK |                                                                CapSense_CONFIG_REFBUF_EN_MASK |                                                                CapSense_CONFIG_COMP_PIN_MASK)
S
S
S    /* Third-generation HW block Ctank pre-charge mode configuration */
S    #if(CapSense_CSD_CSH_PRECHARGE_SRC == CapSense_CSH_PRECHARGE_VREF)
S        #if (CapSense_ENABLE == CapSense_CSD_SHIELD_EN)
S            #define  CapSense_CTANK_PRECHARGE_CONFIG    (CapSense_DEFAULT_CSD_CONFIG |\
S                                                                 CapSense_CONFIG_REFBUF_EN_MASK |\
S                                                                 CapSense_CONFIG_PRS_CLEAR_MASK |\
S                                                                 CapSense_CONFIG_REFBUF_OUTSEL_MASK)
X            #define  CapSense_CTANK_PRECHARGE_CONFIG    (CapSense_DEFAULT_CSD_CONFIG |                                                                 CapSense_CONFIG_REFBUF_EN_MASK |                                                                 CapSense_CONFIG_PRS_CLEAR_MASK |                                                                 CapSense_CONFIG_REFBUF_OUTSEL_MASK)
S        #else
S            #define  CapSense_CTANK_PRECHARGE_CONFIG    (CapSense_DEFAULT_CSD_CONFIG |\
S                                                                 CapSense_CONFIG_REFBUF_OUTSEL_MASK |\
S                                                                 CapSense_CONFIG_PRS_CLEAR_MASK)
X            #define  CapSense_CTANK_PRECHARGE_CONFIG    (CapSense_DEFAULT_CSD_CONFIG |                                                                 CapSense_CONFIG_REFBUF_OUTSEL_MASK |                                                                 CapSense_CONFIG_PRS_CLEAR_MASK)
S        #endif /* (CapSense_ENABLE == CapSense_CSD_SHIELD_EN) */
S    #else
S        #define  CapSense_CTANK_PRECHARGE_CONFIG        (CapSense_DEFAULT_CSD_CONFIG |\
S                                                                CapSense_CONFIG_REFBUF_OUTSEL_MASK |\
S                                                                CapSense_CONFIG_REFBUF_EN_MASK |\
S                                                                CapSense_CONFIG_COMP_MODE_MASK |\
S                                                                CapSense_CONFIG_PRS_CLEAR_MASK |\
S                                                                CapSense_CONFIG_COMP_PIN_MASK)
X        #define  CapSense_CTANK_PRECHARGE_CONFIG        (CapSense_DEFAULT_CSD_CONFIG |                                                                CapSense_CONFIG_REFBUF_OUTSEL_MASK |                                                                CapSense_CONFIG_REFBUF_EN_MASK |                                                                CapSense_CONFIG_COMP_MODE_MASK |                                                                CapSense_CONFIG_PRS_CLEAR_MASK |                                                                CapSense_CONFIG_COMP_PIN_MASK)
S    #endif /* (CapSense_CSD_CSH_PRECHARGE_SRC == CapSense__CSH_PRECHARGE_IO_BUF) */
S
S    #define  CapSense_CTANK_PRECHARGE_CONFIG_CSD_EN     (CapSense_CTANK_PRECHARGE_CONFIG |\
S                                                                 CapSense_CONFIG_ENABLE_MASK |\
S                                                                 CapSense_CONFIG_SENSE_COMP_EN_MASK)
X    #define  CapSense_CTANK_PRECHARGE_CONFIG_CSD_EN     (CapSense_CTANK_PRECHARGE_CONFIG |                                                                 CapSense_CONFIG_ENABLE_MASK |                                                                 CapSense_CONFIG_SENSE_COMP_EN_MASK)
S
N#endif /* (CapSense_ENABLE == CapSense_CSDV2) */
N
N/* Calibration constants */
N#define CapSense_IDAC_MOD_MAX_CALIB_ERROR                       (10u)
N#define CapSense_CAL_MIDDLE_BIT                                 (1uL << (CapSense_CSD_IDAC_MOD_BITS_USED - 1u))
N
N#define CapSense_CSD_AVG_CYCLES_PER_LOOP                   (5u)
N#define CapSense_CSD_MEASURE_MAX_TIME_US                   (6000u)
N#define CapSense_CSD_PRECHARGE_MAX_TIME_US                 (250u)
N
N#define CapSense_CSD_CALIBR_WATCHDOG_CYCLES_NUM            (((CYDEV_BCLK__SYSCLK__MHZ) * (CapSense_CSD_MEASURE_MAX_TIME_US)) /\
N                                                                    (CapSense_CSD_AVG_CYCLES_PER_LOOP))
X#define CapSense_CSD_CALIBR_WATCHDOG_CYCLES_NUM            (((CYDEV_BCLK__SYSCLK__MHZ) * (CapSense_CSD_MEASURE_MAX_TIME_US)) /                                                                    (CapSense_CSD_AVG_CYCLES_PER_LOOP))
N#define CapSense_CSD_PRECHARGE_WATCHDOG_CYCLES_NUM         (((CYDEV_BCLK__SYSCLK__MHZ) * (CapSense_CSD_MEASURE_MAX_TIME_US)) /\
N                                                                    (CapSense_CSD_AVG_CYCLES_PER_LOOP))
X#define CapSense_CSD_PRECHARGE_WATCHDOG_CYCLES_NUM         (((CYDEV_BCLK__SYSCLK__MHZ) * (CapSense_CSD_MEASURE_MAX_TIME_US)) /                                                                    (CapSense_CSD_AVG_CYCLES_PER_LOOP))
N
N/***************************************
N* Global software variables
N***************************************/
N
Nextern uint32 CapSense_configCsd;
N
N#if (CapSense_ENABLE == CapSense_CSD_NOISE_METRIC_EN)
X#if ((1u) == (0u))
S    extern uint8 CapSense_badConversionsNum;
N#endif /* (CapSense_ENABLE == CapSense_CSD_NOISE_METRIC_EN) */
N
N#if (CapSense_CSD_SS_DIS != CapSense_CSD_AUTOTUNE)
X#if ((0x00ul) != (0x00ul))
S    /* Stores IDAC and raw count that corresponds to a sensor with maximum Cp within a widget */
S    extern uint8 CapSense_calibratedIdac;
S    extern uint16 CapSense_calibratedRawcount;
S    #if (CapSense_CSD_MATRIX_WIDGET_EN || CapSense_CSD_TOUCHPAD_WIDGET_EN)
S        extern uint8 CapSense_calibratedIdacRow;
S        extern uint16 CapSense_calibratedRawcountRow;
S    #endif /*(CapSense_CSD_MATRIX_WIDGET_EN || CapSense_CSD_TOUCHPAD_WIDGET_EN) */
N#endif /* (CapSense_CSD_SS_DIS != CapSense_CSD_AUTOTUNE) */
N
N/***************************************
N* Function Prototypes
N**************************************/
N
N/**
N* \cond SECTION_C_LOW_LEVEL
N* \addtogroup group_c_low_level
N* \{
N*/
N
Nvoid CapSense_CSDSetupWidget(uint32 widgetId);
Nvoid CapSense_CSDSetupWidgetExt(uint32 widgetId, uint32 sensorId);
Nvoid CapSense_CSDScan(void);
Nvoid CapSense_CSDScanExt(void);
N#if ((CapSense_CSD_SS_DIS != CapSense_CSD_AUTOTUNE) || \
N     (CapSense_ENABLE == CapSense_CSD_IDAC_AUTOCAL_EN))
X#if (((0x00ul) != (0x00ul)) ||      ((1u) == (1u)))
N    cystatus CapSense_CSDCalibrateWidget(uint32 widgetId, uint32 target);
N#endif /* ((CapSense_CSD_SS_DIS != CapSense_CSD_AUTOTUNE) || \
N           (CapSense_ENABLE == CapSense_CSD_IDAC_AUTOCAL_EN))  */
X#endif  
Nvoid CapSense_CSDConnectSns(CapSense_FLASH_IO_STRUCT const *snsAddrPtr);
Nvoid CapSense_CSDDisconnectSns(CapSense_FLASH_IO_STRUCT const *snsAddrPtr);
N
N/** \}
N* \endcond */
N
N/*****************************************************
N* Function Prototypes - internal Low Level functions
N*****************************************************/
N
N/**
N* \cond SECTION_C_INTERNAL
N* \addtogroup group_c_internal
N* \{
N*/
N
Nvoid CapSense_SsCSDInitialize(void);
Nvoid CapSense_SsCSDStartSample(void);
Nvoid CapSense_SsCSDSetUpIdacs(CapSense_RAM_WD_BASE_STRUCT const *ptrWdgt);
Nvoid CapSense_SsCSDConfigClock(void);
Nvoid CapSense_SsCSDElectrodeCheck(void);
N#if ((CapSense_ENABLE == CapSense_CSD_SHIELD_EN) && \
N     (0u != CapSense_CSD_TOTAL_SHIELD_COUNT))
X#if (((1u) == (0u)) &&      (0u != (0u)))
S    void CapSense_SsCSDDisableShieldElectrodes(void);
N#endif /* ((CapSense_ENABLE == CapSense_CSD_SHIELD_EN) && \
N           (0u != CapSense_CSD_TOTAL_SHIELD_COUNT)) */
X#endif  
N#if (CapSense_ENABLE == CapSense_CSDV2)
X#if ((1u) == (1u))
N    uint32 CapSense_SsCSDGetNumberOfConversions(uint32 snsClkDivider, uint32 resolution, uint32 snsClkSrc);
N#endif /* (CapSense_ENABLE == CapSense_CSDV2) */
Nvoid CapSense_SsCSDCalculateScanDuration(CapSense_RAM_WD_BASE_STRUCT const *ptrWdgt);
Nvoid CapSense_SsCSDConnectSensorExt(uint32 widgetId, uint32 sensorId);
Nvoid CapSense_SsCSDDisconnectSnsExt(uint32 widgetId, uint32 sensorId);
N
N#if ((CapSense_CSD_SS_DIS != CapSense_CSD_AUTOTUNE) || \
N     (CapSense_ENABLE == CapSense_SELF_TEST_EN) || \
N     (CapSense_ENABLE == CapSense_CSD_IDAC_AUTOCAL_EN))
X#if (((0x00ul) != (0x00ul)) ||      ((1u) == (0Lu)) ||      ((1u) == (1u)))
N#endif /* ((CapSense_CSD_SS_DIS != CapSense_CSD_AUTOTUNE) || \
N           (CapSense_ENABLE == CapSense_SELF_TEST_EN) || \
N           (CapSense_ENABLE == CapSense_CSD_IDAC_AUTOCAL_EN)) */
X#endif  
N
N/** \}
N* \endcond */
N
N/***************************************
N* Global software variables
N***************************************/
Nextern uint32 CapSense_configCsd;
N
N/* Interrupt handler */
Nextern CY_ISR_PROTO(CapSense_CSDPostSingleScan);
Xextern void CapSense_CSDPostSingleScan (void);
Nextern CY_ISR_PROTO(CapSense_CSDPostMultiScan);
Xextern void CapSense_CSDPostMultiScan (void);
N#if (CapSense_ENABLE == CapSense_CSD_GANGED_SNS_EN)
X#if ((1u) == (1u))
Nextern CY_ISR_PROTO(CapSense_CSDPostMultiScanGanged);
Xextern void CapSense_CSDPostMultiScanGanged (void);
N#endif /* (CapSense_ENABLE == CapSense_CSD_GANGED_SNS_EN) */
N#if (CapSense_ENABLE == CapSense_CSD_NOISE_METRIC_EN)
X#if ((1u) == (0u))
S    extern uint8 CapSense_badConversionsNum;
N#endif /* (CapSense_ENABLE == CapSense_CSD_NOISE_METRIC_EN) */
N
N#endif /* End CY_SENSE_CapSense_SENSINGCSD_LL_H */
N
N
N/* [] END OF FILE */
L 50 "Generated_Source\PSoC4\CapSense.h" 2
N#endif /* (CapSense_ENABLE == CapSense_CSD_EN) */
N#if (CapSense_ENABLE == CapSense_CSX_EN)
X#if ((1u) == (0u))
S    #include "CapSense_SensingCSX_LL.h"
N#endif /* (CapSense_ENABLE == CapSense_CSX_EN) */
N#if (CapSense_ENABLE == CapSense_ISX_EN)
X#if ((1u) == (0u))
S    #include "CapSense_SensingISX_LL.h"
N#endif /* (CapSense_ENABLE == CapSense_ISX_EN) */
N#include "CapSense_Structure.h"
N#include "CapSense_Tuner.h"
L 1 "Generated_Source\PSoC4\CapSense_Tuner.h" 1
N/***************************************************************************//**
N* \file CapSense_Tuner.h
N* \version 5.0
N*
N* \brief
N*   This file provides Tuner FW module function prototypes.
N*
N* \see CapSense v5.0 Datasheet
N*
N*//*****************************************************************************
N* Copyright (2016-2017), Cypress Semiconductor Corporation.
N********************************************************************************
N* This software is owned by Cypress Semiconductor Corporation (Cypress) and is
N* protected by and subject to worldwide patent protection (United States and
N* foreign), United States copyright laws and international treaty provisions.
N* Cypress hereby grants to licensee a personal, non-exclusive, non-transferable
N* license to copy, use, modify, create derivative works of, and compile the
N* Cypress Source Code and derivative works for the sole purpose of creating
N* custom software in support of licensee product to be used only in conjunction
N* with a Cypress integrated circuit as specified in the applicable agreement.
N* Any reproduction, modification, translation, compilation, or representation of
N* this software except as specified above is prohibited without the express
N* written permission of Cypress.
N*
N* Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH
N* REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
N* Cypress reserves the right to make changes without further notice to the
N* materials described herein. Cypress does not assume any liability arising out
N* of the application or use of any product or circuit described herein. Cypress
N* does not authorize its products for use as critical components in life-support
N* systems where a malfunction or failure may reasonably be expected to result in
N* significant injury to the user. The inclusion of Cypress' product in a life-
N* support systems application implies that the manufacturer assumes all risk of
N* such use and in doing so indemnifies Cypress against all charges. Use may be
N* limited by and subject to the applicable Cypress software license agreement.
N*******************************************************************************/
N
N#if !defined(CY_SENSE_CapSense_TUNER_H)
X#if !0L
N#define CY_SENSE_CapSense_TUNER_H
N
N#include "cytypes.h"
N
N/* Defines the Tuner command codes */
Ntypedef enum
N{
N    CapSense_TU_CMD_NONE_E          = 0x0000u,
N    CapSense_TU_CMD_SUSPEND_E       = 0x0001u,
N    CapSense_TU_CMD_RESUME_E        = 0x0002u,
N    CapSense_TU_CMD_RESTART_E       = 0x0003u,
N    CapSense_TU_CMD_RUN_SNR_TEST_E  = 0x0004u,
N    CapSense_TU_CMD_PING_E          = 0x0005u,
N    CapSense_TU_CMD_ONE_SCAN_E      = 0x0006u
N} CapSense_TU_CMD_ENUM;
N
N/* Defines the command complete bit */
N#define CapSense_TU_CMD_COMPLETE_BIT        (0x8000u)
N
N/* Defines the status of restart command operation */
N#define CapSense_STATUS_RESTART_NONE        (0x00000000Lu)
N#define CapSense_STATUS_RESTART_DONE        (0x00000001Lu)
N
N/*******************************************************************************
N* Function Prototypes
N*******************************************************************************/
N
N/**
N* \cond (SECTION_C_HIGH_LEVEL || SECTION_I_HIGH_LEVEL)
N* \addtogroup group_c_high_level
N* \{
N*/
N
Nuint32 CapSense_RunTuner(void);
N
N/** \} 
N* \endcond */
N
N/**
N* \cond SECTION_C_INTERNAL
N* \addtogroup group_c_internal
N* \{
N*/
N
Nvoid CapSense_TuInitialize(void);
N
N/** \}
N* \endcond */
N
N#endif /* End CY_SENSE_CapSense_TUNER_H */
N
N
N/* [] END OF FILE */
L 59 "Generated_Source\PSoC4\CapSense.h" 2
N
N#endif /* End CY_SENSE_CapSense_H */
N
N
N/* [] END OF FILE */
L 62 "Generated_Source\PSoC4\project.h" 2
N#include "CapSense_Control.h"
N#include "CapSense_Filter.h"
N#include "CapSense_Processing.h"
N#include "CapSense_Sensing.h"
N#include "CapSense_Structure.h"
N#include "CapSense_Tuner.h"
N#include "CapSense_Configuration.h"
N#include "CapSense_SensingCSD_LL.h"
N#include "CapSense_RegisterMap.h"
L 1 "Generated_Source\PSoC4\CapSense_RegisterMap.h" 1
N/***************************************************************************//**
N* \file CapSense_RegisterMap.h
N* \version 5.0
N*
N* \brief
N*   This file provides the definitions for the Component data structure register.
N*
N* \see CapSense v5.0 Datasheet
N*
N*//*****************************************************************************
N* Copyright (2016-2017), Cypress Semiconductor Corporation.
N********************************************************************************
N* This software is owned by Cypress Semiconductor Corporation (Cypress) and is
N* protected by and subject to worldwide patent protection (United States and
N* foreign), United States copyright laws and international treaty provisions.
N* Cypress hereby grants to licensee a personal, non-exclusive, non-transferable
N* license to copy, use, modify, create derivative works of, and compile the
N* Cypress Source Code and derivative works for the sole purpose of creating
N* custom software in support of licensee product to be used only in conjunction
N* with a Cypress integrated circuit as specified in the applicable agreement.
N* Any reproduction, modification, translation, compilation, or representation of
N* this software except as specified above is prohibited without the express
N* written permission of Cypress.
N*
N* Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH
N* REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
N* Cypress reserves the right to make changes without further notice to the
N* materials described herein. Cypress does not assume any liability arising out
N* of the application or use of any product or circuit described herein. Cypress
N* does not authorize its products for use as critical components in life-support
N* systems where a malfunction or failure may reasonably be expected to result in
N* significant injury to the user. The inclusion of Cypress' product in a life-
N* support systems application implies that the manufacturer assumes all risk of
N* such use and in doing so indemnifies Cypress against all charges. Use may be
N* limited by and subject to the applicable Cypress software license agreement.
N*******************************************************************************/
N
N#if !defined(CY_SENSE_CapSense_REGISTER_MAP_H)
X#if !0L
N#define CY_SENSE_CapSense_REGISTER_MAP_H
N
N#include <cytypes.h>
N#include "CapSense_Configuration.h"
N#include "CapSense_Structure.h"
N
N/*****************************************************************************/
N/* RAM Data structure register definitions                                   */
N/*****************************************************************************/
N#define CapSense_CONFIG_ID_VALUE                            (CapSense_dsRam.configId)
N#define CapSense_CONFIG_ID_OFFSET                           (0u)
N#define CapSense_CONFIG_ID_SIZE                             (2u)
N#define CapSense_CONFIG_ID_PARAM_ID                         (0x87000000u)
N
N#define CapSense_DEVICE_ID_VALUE                            (CapSense_dsRam.deviceId)
N#define CapSense_DEVICE_ID_OFFSET                           (2u)
N#define CapSense_DEVICE_ID_SIZE                             (2u)
N#define CapSense_DEVICE_ID_PARAM_ID                         (0x8B000002u)
N
N#define CapSense_HW_CLOCK_VALUE                             (CapSense_dsRam.hwClock)
N#define CapSense_HW_CLOCK_OFFSET                            (4u)
N#define CapSense_HW_CLOCK_SIZE                              (2u)
N#define CapSense_HW_CLOCK_PARAM_ID                          (0x86000004u)
N
N#define CapSense_TUNER_CMD_VALUE                            (CapSense_dsRam.tunerCmd)
N#define CapSense_TUNER_CMD_OFFSET                           (6u)
N#define CapSense_TUNER_CMD_SIZE                             (2u)
N#define CapSense_TUNER_CMD_PARAM_ID                         (0xA1000006u)
N
N#define CapSense_SCAN_COUNTER_VALUE                         (CapSense_dsRam.scanCounter)
N#define CapSense_SCAN_COUNTER_OFFSET                        (8u)
N#define CapSense_SCAN_COUNTER_SIZE                          (2u)
N#define CapSense_SCAN_COUNTER_PARAM_ID                      (0x85000008u)
N
N#define CapSense_STATUS_VALUE                               (CapSense_dsRam.status)
N#define CapSense_STATUS_OFFSET                              (12u)
N#define CapSense_STATUS_SIZE                                (4u)
N#define CapSense_STATUS_PARAM_ID                            (0xCB00000Cu)
N
N#define CapSense_WDGT_ENABLE0_VALUE                         (CapSense_dsRam.wdgtEnable[0u])
N#define CapSense_WDGT_ENABLE0_OFFSET                        (16u)
N#define CapSense_WDGT_ENABLE0_SIZE                          (4u)
N#define CapSense_WDGT_ENABLE0_PARAM_ID                      (0xE6000010u)
N
N#define CapSense_WDGT_STATUS0_VALUE                         (CapSense_dsRam.wdgtStatus[0u])
N#define CapSense_WDGT_STATUS0_OFFSET                        (20u)
N#define CapSense_WDGT_STATUS0_SIZE                          (4u)
N#define CapSense_WDGT_STATUS0_PARAM_ID                      (0xCC000014u)
N
N#define CapSense_SNS_STATUS0_VALUE                          (CapSense_dsRam.snsStatus[0u])
N#define CapSense_SNS_STATUS0_OFFSET                         (24u)
N#define CapSense_SNS_STATUS0_SIZE                           (1u)
N#define CapSense_SNS_STATUS0_PARAM_ID                       (0x48000018u)
N
N#define CapSense_SNS_STATUS1_VALUE                          (CapSense_dsRam.snsStatus[1u])
N#define CapSense_SNS_STATUS1_OFFSET                         (25u)
N#define CapSense_SNS_STATUS1_SIZE                           (1u)
N#define CapSense_SNS_STATUS1_PARAM_ID                       (0x4E000019u)
N
N#define CapSense_SNS_STATUS2_VALUE                          (CapSense_dsRam.snsStatus[2u])
N#define CapSense_SNS_STATUS2_OFFSET                         (26u)
N#define CapSense_SNS_STATUS2_SIZE                           (1u)
N#define CapSense_SNS_STATUS2_PARAM_ID                       (0x4400001Au)
N
N#define CapSense_SNS_STATUS3_VALUE                          (CapSense_dsRam.snsStatus[3u])
N#define CapSense_SNS_STATUS3_OFFSET                         (27u)
N#define CapSense_SNS_STATUS3_SIZE                           (1u)
N#define CapSense_SNS_STATUS3_PARAM_ID                       (0x4200001Bu)
N
N#define CapSense_SNS_STATUS4_VALUE                          (CapSense_dsRam.snsStatus[4u])
N#define CapSense_SNS_STATUS4_OFFSET                         (28u)
N#define CapSense_SNS_STATUS4_SIZE                           (1u)
N#define CapSense_SNS_STATUS4_PARAM_ID                       (0x4900001Cu)
N
N#define CapSense_SNS_STATUS5_VALUE                          (CapSense_dsRam.snsStatus[5u])
N#define CapSense_SNS_STATUS5_OFFSET                         (29u)
N#define CapSense_SNS_STATUS5_SIZE                           (1u)
N#define CapSense_SNS_STATUS5_PARAM_ID                       (0x4F00001Du)
N
N#define CapSense_SNS_STATUS6_VALUE                          (CapSense_dsRam.snsStatus[6u])
N#define CapSense_SNS_STATUS6_OFFSET                         (30u)
N#define CapSense_SNS_STATUS6_SIZE                           (1u)
N#define CapSense_SNS_STATUS6_PARAM_ID                       (0x4500001Eu)
N
N#define CapSense_SNS_STATUS7_VALUE                          (CapSense_dsRam.snsStatus[7u])
N#define CapSense_SNS_STATUS7_OFFSET                         (31u)
N#define CapSense_SNS_STATUS7_SIZE                           (1u)
N#define CapSense_SNS_STATUS7_PARAM_ID                       (0x4300001Fu)
N
N#define CapSense_SNS_STATUS8_VALUE                          (CapSense_dsRam.snsStatus[8u])
N#define CapSense_SNS_STATUS8_OFFSET                         (32u)
N#define CapSense_SNS_STATUS8_SIZE                           (1u)
N#define CapSense_SNS_STATUS8_PARAM_ID                       (0x45000020u)
N
N#define CapSense_SNS_STATUS9_VALUE                          (CapSense_dsRam.snsStatus[9u])
N#define CapSense_SNS_STATUS9_OFFSET                         (33u)
N#define CapSense_SNS_STATUS9_SIZE                           (1u)
N#define CapSense_SNS_STATUS9_PARAM_ID                       (0x43000021u)
N
N#define CapSense_SNS_STATUS10_VALUE                         (CapSense_dsRam.snsStatus[10u])
N#define CapSense_SNS_STATUS10_OFFSET                        (34u)
N#define CapSense_SNS_STATUS10_SIZE                          (1u)
N#define CapSense_SNS_STATUS10_PARAM_ID                      (0x49000022u)
N
N#define CapSense_SNS_STATUS11_VALUE                         (CapSense_dsRam.snsStatus[11u])
N#define CapSense_SNS_STATUS11_OFFSET                        (35u)
N#define CapSense_SNS_STATUS11_SIZE                          (1u)
N#define CapSense_SNS_STATUS11_PARAM_ID                      (0x4F000023u)
N
N#define CapSense_SNS_STATUS12_VALUE                         (CapSense_dsRam.snsStatus[12u])
N#define CapSense_SNS_STATUS12_OFFSET                        (36u)
N#define CapSense_SNS_STATUS12_SIZE                          (1u)
N#define CapSense_SNS_STATUS12_PARAM_ID                      (0x44000024u)
N
N#define CapSense_CSD0_CONFIG_VALUE                          (CapSense_dsRam.csd0Config)
N#define CapSense_CSD0_CONFIG_OFFSET                         (38u)
N#define CapSense_CSD0_CONFIG_SIZE                           (2u)
N#define CapSense_CSD0_CONFIG_PARAM_ID                       (0xA6800026u)
N
N#define CapSense_MOD_CSD_CLK_VALUE                          (CapSense_dsRam.modCsdClk)
N#define CapSense_MOD_CSD_CLK_OFFSET                         (40u)
N#define CapSense_MOD_CSD_CLK_SIZE                           (1u)
N#define CapSense_MOD_CSD_CLK_PARAM_ID                       (0x61800028u)
N
N#define CapSense_BUTTON0_RESOLUTION_VALUE                   (CapSense_dsRam.wdgtList.button0.resolution)
N#define CapSense_BUTTON0_RESOLUTION_OFFSET                  (42u)
N#define CapSense_BUTTON0_RESOLUTION_SIZE                    (2u)
N#define CapSense_BUTTON0_RESOLUTION_PARAM_ID                (0xA580002Au)
N
N#define CapSense_BUTTON0_FINGER_TH_VALUE                    (CapSense_dsRam.wdgtList.button0.fingerTh)
N#define CapSense_BUTTON0_FINGER_TH_OFFSET                   (44u)
N#define CapSense_BUTTON0_FINGER_TH_SIZE                     (2u)
N#define CapSense_BUTTON0_FINGER_TH_PARAM_ID                 (0xA880002Cu)
N
N#define CapSense_BUTTON0_NOISE_TH_VALUE                     (CapSense_dsRam.wdgtList.button0.noiseTh)
N#define CapSense_BUTTON0_NOISE_TH_OFFSET                    (46u)
N#define CapSense_BUTTON0_NOISE_TH_SIZE                      (1u)
N#define CapSense_BUTTON0_NOISE_TH_PARAM_ID                  (0x6C80002Eu)
N
N#define CapSense_BUTTON0_NNOISE_TH_VALUE                    (CapSense_dsRam.wdgtList.button0.nNoiseTh)
N#define CapSense_BUTTON0_NNOISE_TH_OFFSET                   (47u)
N#define CapSense_BUTTON0_NNOISE_TH_SIZE                     (1u)
N#define CapSense_BUTTON0_NNOISE_TH_PARAM_ID                 (0x6A80002Fu)
N
N#define CapSense_BUTTON0_HYSTERESIS_VALUE                   (CapSense_dsRam.wdgtList.button0.hysteresis)
N#define CapSense_BUTTON0_HYSTERESIS_OFFSET                  (48u)
N#define CapSense_BUTTON0_HYSTERESIS_SIZE                    (1u)
N#define CapSense_BUTTON0_HYSTERESIS_PARAM_ID                (0x66800030u)
N
N#define CapSense_BUTTON0_ON_DEBOUNCE_VALUE                  (CapSense_dsRam.wdgtList.button0.onDebounce)
N#define CapSense_BUTTON0_ON_DEBOUNCE_OFFSET                 (49u)
N#define CapSense_BUTTON0_ON_DEBOUNCE_SIZE                   (1u)
N#define CapSense_BUTTON0_ON_DEBOUNCE_PARAM_ID               (0x60800031u)
N
N#define CapSense_BUTTON0_LOW_BSLN_RST_VALUE                 (CapSense_dsRam.wdgtList.button0.lowBslnRst)
N#define CapSense_BUTTON0_LOW_BSLN_RST_OFFSET                (50u)
N#define CapSense_BUTTON0_LOW_BSLN_RST_SIZE                  (1u)
N#define CapSense_BUTTON0_LOW_BSLN_RST_PARAM_ID              (0x6A800032u)
N
N#define CapSense_BUTTON0_IDAC_MOD0_VALUE                    (CapSense_dsRam.wdgtList.button0.idacMod[0u])
N#define CapSense_BUTTON0_IDAC_MOD0_OFFSET                   (51u)
N#define CapSense_BUTTON0_IDAC_MOD0_SIZE                     (1u)
N#define CapSense_BUTTON0_IDAC_MOD0_PARAM_ID                 (0x4A000033u)
N
N#define CapSense_BUTTON0_SNS_CLK_VALUE                      (CapSense_dsRam.wdgtList.button0.snsClk)
N#define CapSense_BUTTON0_SNS_CLK_OFFSET                     (52u)
N#define CapSense_BUTTON0_SNS_CLK_SIZE                       (2u)
N#define CapSense_BUTTON0_SNS_CLK_PARAM_ID                   (0xAF800034u)
N
N#define CapSense_BUTTON0_SNS_CLK_SOURCE_VALUE               (CapSense_dsRam.wdgtList.button0.snsClkSource)
N#define CapSense_BUTTON0_SNS_CLK_SOURCE_OFFSET              (54u)
N#define CapSense_BUTTON0_SNS_CLK_SOURCE_SIZE                (1u)
N#define CapSense_BUTTON0_SNS_CLK_SOURCE_PARAM_ID            (0x40800036u)
N
N#define CapSense_BUTTON1_RESOLUTION_VALUE                   (CapSense_dsRam.wdgtList.button1.resolution)
N#define CapSense_BUTTON1_RESOLUTION_OFFSET                  (56u)
N#define CapSense_BUTTON1_RESOLUTION_SIZE                    (2u)
N#define CapSense_BUTTON1_RESOLUTION_PARAM_ID                (0xAF810038u)
N
N#define CapSense_BUTTON1_FINGER_TH_VALUE                    (CapSense_dsRam.wdgtList.button1.fingerTh)
N#define CapSense_BUTTON1_FINGER_TH_OFFSET                   (58u)
N#define CapSense_BUTTON1_FINGER_TH_SIZE                     (2u)
N#define CapSense_BUTTON1_FINGER_TH_PARAM_ID                 (0xA381003Au)
N
N#define CapSense_BUTTON1_NOISE_TH_VALUE                     (CapSense_dsRam.wdgtList.button1.noiseTh)
N#define CapSense_BUTTON1_NOISE_TH_OFFSET                    (60u)
N#define CapSense_BUTTON1_NOISE_TH_SIZE                      (1u)
N#define CapSense_BUTTON1_NOISE_TH_PARAM_ID                  (0x6681003Cu)
N
N#define CapSense_BUTTON1_NNOISE_TH_VALUE                    (CapSense_dsRam.wdgtList.button1.nNoiseTh)
N#define CapSense_BUTTON1_NNOISE_TH_OFFSET                   (61u)
N#define CapSense_BUTTON1_NNOISE_TH_SIZE                     (1u)
N#define CapSense_BUTTON1_NNOISE_TH_PARAM_ID                 (0x6081003Du)
N
N#define CapSense_BUTTON1_HYSTERESIS_VALUE                   (CapSense_dsRam.wdgtList.button1.hysteresis)
N#define CapSense_BUTTON1_HYSTERESIS_OFFSET                  (62u)
N#define CapSense_BUTTON1_HYSTERESIS_SIZE                    (1u)
N#define CapSense_BUTTON1_HYSTERESIS_PARAM_ID                (0x6A81003Eu)
N
N#define CapSense_BUTTON1_ON_DEBOUNCE_VALUE                  (CapSense_dsRam.wdgtList.button1.onDebounce)
N#define CapSense_BUTTON1_ON_DEBOUNCE_OFFSET                 (63u)
N#define CapSense_BUTTON1_ON_DEBOUNCE_SIZE                   (1u)
N#define CapSense_BUTTON1_ON_DEBOUNCE_PARAM_ID               (0x6C81003Fu)
N
N#define CapSense_BUTTON1_LOW_BSLN_RST_VALUE                 (CapSense_dsRam.wdgtList.button1.lowBslnRst)
N#define CapSense_BUTTON1_LOW_BSLN_RST_OFFSET                (64u)
N#define CapSense_BUTTON1_LOW_BSLN_RST_SIZE                  (1u)
N#define CapSense_BUTTON1_LOW_BSLN_RST_PARAM_ID              (0x67810040u)
N
N#define CapSense_BUTTON1_IDAC_MOD0_VALUE                    (CapSense_dsRam.wdgtList.button1.idacMod[0u])
N#define CapSense_BUTTON1_IDAC_MOD0_OFFSET                   (65u)
N#define CapSense_BUTTON1_IDAC_MOD0_SIZE                     (1u)
N#define CapSense_BUTTON1_IDAC_MOD0_PARAM_ID                 (0x47010041u)
N
N#define CapSense_BUTTON1_SNS_CLK_VALUE                      (CapSense_dsRam.wdgtList.button1.snsClk)
N#define CapSense_BUTTON1_SNS_CLK_OFFSET                     (66u)
N#define CapSense_BUTTON1_SNS_CLK_SIZE                       (2u)
N#define CapSense_BUTTON1_SNS_CLK_PARAM_ID                   (0xA3810042u)
N
N#define CapSense_BUTTON1_SNS_CLK_SOURCE_VALUE               (CapSense_dsRam.wdgtList.button1.snsClkSource)
N#define CapSense_BUTTON1_SNS_CLK_SOURCE_OFFSET              (68u)
N#define CapSense_BUTTON1_SNS_CLK_SOURCE_SIZE                (1u)
N#define CapSense_BUTTON1_SNS_CLK_SOURCE_PARAM_ID            (0x4D810044u)
N
N#define CapSense_BUTTON2_RESOLUTION_VALUE                   (CapSense_dsRam.wdgtList.button2.resolution)
N#define CapSense_BUTTON2_RESOLUTION_OFFSET                  (70u)
N#define CapSense_BUTTON2_RESOLUTION_SIZE                    (2u)
N#define CapSense_BUTTON2_RESOLUTION_PARAM_ID                (0xA7820046u)
N
N#define CapSense_BUTTON2_FINGER_TH_VALUE                    (CapSense_dsRam.wdgtList.button2.fingerTh)
N#define CapSense_BUTTON2_FINGER_TH_OFFSET                   (72u)
N#define CapSense_BUTTON2_FINGER_TH_SIZE                     (2u)
N#define CapSense_BUTTON2_FINGER_TH_PARAM_ID                 (0xA8820048u)
N
N#define CapSense_BUTTON2_NOISE_TH_VALUE                     (CapSense_dsRam.wdgtList.button2.noiseTh)
N#define CapSense_BUTTON2_NOISE_TH_OFFSET                    (74u)
N#define CapSense_BUTTON2_NOISE_TH_SIZE                      (1u)
N#define CapSense_BUTTON2_NOISE_TH_PARAM_ID                  (0x6C82004Au)
N
N#define CapSense_BUTTON2_NNOISE_TH_VALUE                    (CapSense_dsRam.wdgtList.button2.nNoiseTh)
N#define CapSense_BUTTON2_NNOISE_TH_OFFSET                   (75u)
N#define CapSense_BUTTON2_NNOISE_TH_SIZE                     (1u)
N#define CapSense_BUTTON2_NNOISE_TH_PARAM_ID                 (0x6A82004Bu)
N
N#define CapSense_BUTTON2_HYSTERESIS_VALUE                   (CapSense_dsRam.wdgtList.button2.hysteresis)
N#define CapSense_BUTTON2_HYSTERESIS_OFFSET                  (76u)
N#define CapSense_BUTTON2_HYSTERESIS_SIZE                    (1u)
N#define CapSense_BUTTON2_HYSTERESIS_PARAM_ID                (0x6182004Cu)
N
N#define CapSense_BUTTON2_ON_DEBOUNCE_VALUE                  (CapSense_dsRam.wdgtList.button2.onDebounce)
N#define CapSense_BUTTON2_ON_DEBOUNCE_OFFSET                 (77u)
N#define CapSense_BUTTON2_ON_DEBOUNCE_SIZE                   (1u)
N#define CapSense_BUTTON2_ON_DEBOUNCE_PARAM_ID               (0x6782004Du)
N
N#define CapSense_BUTTON2_LOW_BSLN_RST_VALUE                 (CapSense_dsRam.wdgtList.button2.lowBslnRst)
N#define CapSense_BUTTON2_LOW_BSLN_RST_OFFSET                (78u)
N#define CapSense_BUTTON2_LOW_BSLN_RST_SIZE                  (1u)
N#define CapSense_BUTTON2_LOW_BSLN_RST_PARAM_ID              (0x6D82004Eu)
N
N#define CapSense_BUTTON2_IDAC_MOD0_VALUE                    (CapSense_dsRam.wdgtList.button2.idacMod[0u])
N#define CapSense_BUTTON2_IDAC_MOD0_OFFSET                   (79u)
N#define CapSense_BUTTON2_IDAC_MOD0_SIZE                     (1u)
N#define CapSense_BUTTON2_IDAC_MOD0_PARAM_ID                 (0x4D02004Fu)
N
N#define CapSense_BUTTON2_SNS_CLK_VALUE                      (CapSense_dsRam.wdgtList.button2.snsClk)
N#define CapSense_BUTTON2_SNS_CLK_OFFSET                     (80u)
N#define CapSense_BUTTON2_SNS_CLK_SIZE                       (2u)
N#define CapSense_BUTTON2_SNS_CLK_PARAM_ID                   (0xAF820050u)
N
N#define CapSense_BUTTON2_SNS_CLK_SOURCE_VALUE               (CapSense_dsRam.wdgtList.button2.snsClkSource)
N#define CapSense_BUTTON2_SNS_CLK_SOURCE_OFFSET              (82u)
N#define CapSense_BUTTON2_SNS_CLK_SOURCE_SIZE                (1u)
N#define CapSense_BUTTON2_SNS_CLK_SOURCE_PARAM_ID            (0x40820052u)
N
N#define CapSense_BUTTON3_RESOLUTION_VALUE                   (CapSense_dsRam.wdgtList.button3.resolution)
N#define CapSense_BUTTON3_RESOLUTION_OFFSET                  (84u)
N#define CapSense_BUTTON3_RESOLUTION_SIZE                    (2u)
N#define CapSense_BUTTON3_RESOLUTION_PARAM_ID                (0xAD830054u)
N
N#define CapSense_BUTTON3_FINGER_TH_VALUE                    (CapSense_dsRam.wdgtList.button3.fingerTh)
N#define CapSense_BUTTON3_FINGER_TH_OFFSET                   (86u)
N#define CapSense_BUTTON3_FINGER_TH_SIZE                     (2u)
N#define CapSense_BUTTON3_FINGER_TH_PARAM_ID                 (0xA1830056u)
N
N#define CapSense_BUTTON3_NOISE_TH_VALUE                     (CapSense_dsRam.wdgtList.button3.noiseTh)
N#define CapSense_BUTTON3_NOISE_TH_OFFSET                    (88u)
N#define CapSense_BUTTON3_NOISE_TH_SIZE                      (1u)
N#define CapSense_BUTTON3_NOISE_TH_PARAM_ID                  (0x66830058u)
N
N#define CapSense_BUTTON3_NNOISE_TH_VALUE                    (CapSense_dsRam.wdgtList.button3.nNoiseTh)
N#define CapSense_BUTTON3_NNOISE_TH_OFFSET                   (89u)
N#define CapSense_BUTTON3_NNOISE_TH_SIZE                     (1u)
N#define CapSense_BUTTON3_NNOISE_TH_PARAM_ID                 (0x60830059u)
N
N#define CapSense_BUTTON3_HYSTERESIS_VALUE                   (CapSense_dsRam.wdgtList.button3.hysteresis)
N#define CapSense_BUTTON3_HYSTERESIS_OFFSET                  (90u)
N#define CapSense_BUTTON3_HYSTERESIS_SIZE                    (1u)
N#define CapSense_BUTTON3_HYSTERESIS_PARAM_ID                (0x6A83005Au)
N
N#define CapSense_BUTTON3_ON_DEBOUNCE_VALUE                  (CapSense_dsRam.wdgtList.button3.onDebounce)
N#define CapSense_BUTTON3_ON_DEBOUNCE_OFFSET                 (91u)
N#define CapSense_BUTTON3_ON_DEBOUNCE_SIZE                   (1u)
N#define CapSense_BUTTON3_ON_DEBOUNCE_PARAM_ID               (0x6C83005Bu)
N
N#define CapSense_BUTTON3_LOW_BSLN_RST_VALUE                 (CapSense_dsRam.wdgtList.button3.lowBslnRst)
N#define CapSense_BUTTON3_LOW_BSLN_RST_OFFSET                (92u)
N#define CapSense_BUTTON3_LOW_BSLN_RST_SIZE                  (1u)
N#define CapSense_BUTTON3_LOW_BSLN_RST_PARAM_ID              (0x6783005Cu)
N
N#define CapSense_BUTTON3_IDAC_MOD0_VALUE                    (CapSense_dsRam.wdgtList.button3.idacMod[0u])
N#define CapSense_BUTTON3_IDAC_MOD0_OFFSET                   (93u)
N#define CapSense_BUTTON3_IDAC_MOD0_SIZE                     (1u)
N#define CapSense_BUTTON3_IDAC_MOD0_PARAM_ID                 (0x4703005Du)
N
N#define CapSense_BUTTON3_SNS_CLK_VALUE                      (CapSense_dsRam.wdgtList.button3.snsClk)
N#define CapSense_BUTTON3_SNS_CLK_OFFSET                     (94u)
N#define CapSense_BUTTON3_SNS_CLK_SIZE                       (2u)
N#define CapSense_BUTTON3_SNS_CLK_PARAM_ID                   (0xA383005Eu)
N
N#define CapSense_BUTTON3_SNS_CLK_SOURCE_VALUE               (CapSense_dsRam.wdgtList.button3.snsClkSource)
N#define CapSense_BUTTON3_SNS_CLK_SOURCE_OFFSET              (96u)
N#define CapSense_BUTTON3_SNS_CLK_SOURCE_SIZE                (1u)
N#define CapSense_BUTTON3_SNS_CLK_SOURCE_PARAM_ID            (0x40830060u)
N
N#define CapSense_BUTTON4_RESOLUTION_VALUE                   (CapSense_dsRam.wdgtList.button4.resolution)
N#define CapSense_BUTTON4_RESOLUTION_OFFSET                  (98u)
N#define CapSense_BUTTON4_RESOLUTION_SIZE                    (2u)
N#define CapSense_BUTTON4_RESOLUTION_PARAM_ID                (0xA6840062u)
N
N#define CapSense_BUTTON4_FINGER_TH_VALUE                    (CapSense_dsRam.wdgtList.button4.fingerTh)
N#define CapSense_BUTTON4_FINGER_TH_OFFSET                   (100u)
N#define CapSense_BUTTON4_FINGER_TH_SIZE                     (2u)
N#define CapSense_BUTTON4_FINGER_TH_PARAM_ID                 (0xAB840064u)
N
N#define CapSense_BUTTON4_NOISE_TH_VALUE                     (CapSense_dsRam.wdgtList.button4.noiseTh)
N#define CapSense_BUTTON4_NOISE_TH_OFFSET                    (102u)
N#define CapSense_BUTTON4_NOISE_TH_SIZE                      (1u)
N#define CapSense_BUTTON4_NOISE_TH_PARAM_ID                  (0x6F840066u)
N
N#define CapSense_BUTTON4_NNOISE_TH_VALUE                    (CapSense_dsRam.wdgtList.button4.nNoiseTh)
N#define CapSense_BUTTON4_NNOISE_TH_OFFSET                   (103u)
N#define CapSense_BUTTON4_NNOISE_TH_SIZE                     (1u)
N#define CapSense_BUTTON4_NNOISE_TH_PARAM_ID                 (0x69840067u)
N
N#define CapSense_BUTTON4_HYSTERESIS_VALUE                   (CapSense_dsRam.wdgtList.button4.hysteresis)
N#define CapSense_BUTTON4_HYSTERESIS_OFFSET                  (104u)
N#define CapSense_BUTTON4_HYSTERESIS_SIZE                    (1u)
N#define CapSense_BUTTON4_HYSTERESIS_PARAM_ID                (0x60840068u)
N
N#define CapSense_BUTTON4_ON_DEBOUNCE_VALUE                  (CapSense_dsRam.wdgtList.button4.onDebounce)
N#define CapSense_BUTTON4_ON_DEBOUNCE_OFFSET                 (105u)
N#define CapSense_BUTTON4_ON_DEBOUNCE_SIZE                   (1u)
N#define CapSense_BUTTON4_ON_DEBOUNCE_PARAM_ID               (0x66840069u)
N
N#define CapSense_BUTTON4_LOW_BSLN_RST_VALUE                 (CapSense_dsRam.wdgtList.button4.lowBslnRst)
N#define CapSense_BUTTON4_LOW_BSLN_RST_OFFSET                (106u)
N#define CapSense_BUTTON4_LOW_BSLN_RST_SIZE                  (1u)
N#define CapSense_BUTTON4_LOW_BSLN_RST_PARAM_ID              (0x6C84006Au)
N
N#define CapSense_BUTTON4_IDAC_MOD0_VALUE                    (CapSense_dsRam.wdgtList.button4.idacMod[0u])
N#define CapSense_BUTTON4_IDAC_MOD0_OFFSET                   (107u)
N#define CapSense_BUTTON4_IDAC_MOD0_SIZE                     (1u)
N#define CapSense_BUTTON4_IDAC_MOD0_PARAM_ID                 (0x4C04006Bu)
N
N#define CapSense_BUTTON4_SNS_CLK_VALUE                      (CapSense_dsRam.wdgtList.button4.snsClk)
N#define CapSense_BUTTON4_SNS_CLK_OFFSET                     (108u)
N#define CapSense_BUTTON4_SNS_CLK_SIZE                       (2u)
N#define CapSense_BUTTON4_SNS_CLK_PARAM_ID                   (0xA984006Cu)
N
N#define CapSense_BUTTON4_SNS_CLK_SOURCE_VALUE               (CapSense_dsRam.wdgtList.button4.snsClkSource)
N#define CapSense_BUTTON4_SNS_CLK_SOURCE_OFFSET              (110u)
N#define CapSense_BUTTON4_SNS_CLK_SOURCE_SIZE                (1u)
N#define CapSense_BUTTON4_SNS_CLK_SOURCE_PARAM_ID            (0x4684006Eu)
N
N#define CapSense_BUTTON5_RESOLUTION_VALUE                   (CapSense_dsRam.wdgtList.button5.resolution)
N#define CapSense_BUTTON5_RESOLUTION_OFFSET                  (112u)
N#define CapSense_BUTTON5_RESOLUTION_SIZE                    (2u)
N#define CapSense_BUTTON5_RESOLUTION_PARAM_ID                (0xAC850070u)
N
N#define CapSense_BUTTON5_FINGER_TH_VALUE                    (CapSense_dsRam.wdgtList.button5.fingerTh)
N#define CapSense_BUTTON5_FINGER_TH_OFFSET                   (114u)
N#define CapSense_BUTTON5_FINGER_TH_SIZE                     (2u)
N#define CapSense_BUTTON5_FINGER_TH_PARAM_ID                 (0xA0850072u)
N
N#define CapSense_BUTTON5_NOISE_TH_VALUE                     (CapSense_dsRam.wdgtList.button5.noiseTh)
N#define CapSense_BUTTON5_NOISE_TH_OFFSET                    (116u)
N#define CapSense_BUTTON5_NOISE_TH_SIZE                      (1u)
N#define CapSense_BUTTON5_NOISE_TH_PARAM_ID                  (0x65850074u)
N
N#define CapSense_BUTTON5_NNOISE_TH_VALUE                    (CapSense_dsRam.wdgtList.button5.nNoiseTh)
N#define CapSense_BUTTON5_NNOISE_TH_OFFSET                   (117u)
N#define CapSense_BUTTON5_NNOISE_TH_SIZE                     (1u)
N#define CapSense_BUTTON5_NNOISE_TH_PARAM_ID                 (0x63850075u)
N
N#define CapSense_BUTTON5_HYSTERESIS_VALUE                   (CapSense_dsRam.wdgtList.button5.hysteresis)
N#define CapSense_BUTTON5_HYSTERESIS_OFFSET                  (118u)
N#define CapSense_BUTTON5_HYSTERESIS_SIZE                    (1u)
N#define CapSense_BUTTON5_HYSTERESIS_PARAM_ID                (0x69850076u)
N
N#define CapSense_BUTTON5_ON_DEBOUNCE_VALUE                  (CapSense_dsRam.wdgtList.button5.onDebounce)
N#define CapSense_BUTTON5_ON_DEBOUNCE_OFFSET                 (119u)
N#define CapSense_BUTTON5_ON_DEBOUNCE_SIZE                   (1u)
N#define CapSense_BUTTON5_ON_DEBOUNCE_PARAM_ID               (0x6F850077u)
N
N#define CapSense_BUTTON5_LOW_BSLN_RST_VALUE                 (CapSense_dsRam.wdgtList.button5.lowBslnRst)
N#define CapSense_BUTTON5_LOW_BSLN_RST_OFFSET                (120u)
N#define CapSense_BUTTON5_LOW_BSLN_RST_SIZE                  (1u)
N#define CapSense_BUTTON5_LOW_BSLN_RST_PARAM_ID              (0x66850078u)
N
N#define CapSense_BUTTON5_IDAC_MOD0_VALUE                    (CapSense_dsRam.wdgtList.button5.idacMod[0u])
N#define CapSense_BUTTON5_IDAC_MOD0_OFFSET                   (121u)
N#define CapSense_BUTTON5_IDAC_MOD0_SIZE                     (1u)
N#define CapSense_BUTTON5_IDAC_MOD0_PARAM_ID                 (0x46050079u)
N
N#define CapSense_BUTTON5_SNS_CLK_VALUE                      (CapSense_dsRam.wdgtList.button5.snsClk)
N#define CapSense_BUTTON5_SNS_CLK_OFFSET                     (122u)
N#define CapSense_BUTTON5_SNS_CLK_SIZE                       (2u)
N#define CapSense_BUTTON5_SNS_CLK_PARAM_ID                   (0xA285007Au)
N
N#define CapSense_BUTTON5_SNS_CLK_SOURCE_VALUE               (CapSense_dsRam.wdgtList.button5.snsClkSource)
N#define CapSense_BUTTON5_SNS_CLK_SOURCE_OFFSET              (124u)
N#define CapSense_BUTTON5_SNS_CLK_SOURCE_SIZE                (1u)
N#define CapSense_BUTTON5_SNS_CLK_SOURCE_PARAM_ID            (0x4C85007Cu)
N
N#define CapSense_BUTTON6_RESOLUTION_VALUE                   (CapSense_dsRam.wdgtList.button6.resolution)
N#define CapSense_BUTTON6_RESOLUTION_OFFSET                  (126u)
N#define CapSense_BUTTON6_RESOLUTION_SIZE                    (2u)
N#define CapSense_BUTTON6_RESOLUTION_PARAM_ID                (0xA686007Eu)
N
N#define CapSense_BUTTON6_FINGER_TH_VALUE                    (CapSense_dsRam.wdgtList.button6.fingerTh)
N#define CapSense_BUTTON6_FINGER_TH_OFFSET                   (128u)
N#define CapSense_BUTTON6_FINGER_TH_SIZE                     (2u)
N#define CapSense_BUTTON6_FINGER_TH_PARAM_ID                 (0xA8860080u)
N
N#define CapSense_BUTTON6_NOISE_TH_VALUE                     (CapSense_dsRam.wdgtList.button6.noiseTh)
N#define CapSense_BUTTON6_NOISE_TH_OFFSET                    (130u)
N#define CapSense_BUTTON6_NOISE_TH_SIZE                      (1u)
N#define CapSense_BUTTON6_NOISE_TH_PARAM_ID                  (0x6C860082u)
N
N#define CapSense_BUTTON6_NNOISE_TH_VALUE                    (CapSense_dsRam.wdgtList.button6.nNoiseTh)
N#define CapSense_BUTTON6_NNOISE_TH_OFFSET                   (131u)
N#define CapSense_BUTTON6_NNOISE_TH_SIZE                     (1u)
N#define CapSense_BUTTON6_NNOISE_TH_PARAM_ID                 (0x6A860083u)
N
N#define CapSense_BUTTON6_HYSTERESIS_VALUE                   (CapSense_dsRam.wdgtList.button6.hysteresis)
N#define CapSense_BUTTON6_HYSTERESIS_OFFSET                  (132u)
N#define CapSense_BUTTON6_HYSTERESIS_SIZE                    (1u)
N#define CapSense_BUTTON6_HYSTERESIS_PARAM_ID                (0x61860084u)
N
N#define CapSense_BUTTON6_ON_DEBOUNCE_VALUE                  (CapSense_dsRam.wdgtList.button6.onDebounce)
N#define CapSense_BUTTON6_ON_DEBOUNCE_OFFSET                 (133u)
N#define CapSense_BUTTON6_ON_DEBOUNCE_SIZE                   (1u)
N#define CapSense_BUTTON6_ON_DEBOUNCE_PARAM_ID               (0x67860085u)
N
N#define CapSense_BUTTON6_LOW_BSLN_RST_VALUE                 (CapSense_dsRam.wdgtList.button6.lowBslnRst)
N#define CapSense_BUTTON6_LOW_BSLN_RST_OFFSET                (134u)
N#define CapSense_BUTTON6_LOW_BSLN_RST_SIZE                  (1u)
N#define CapSense_BUTTON6_LOW_BSLN_RST_PARAM_ID              (0x6D860086u)
N
N#define CapSense_BUTTON6_IDAC_MOD0_VALUE                    (CapSense_dsRam.wdgtList.button6.idacMod[0u])
N#define CapSense_BUTTON6_IDAC_MOD0_OFFSET                   (135u)
N#define CapSense_BUTTON6_IDAC_MOD0_SIZE                     (1u)
N#define CapSense_BUTTON6_IDAC_MOD0_PARAM_ID                 (0x4D060087u)
N
N#define CapSense_BUTTON6_SNS_CLK_VALUE                      (CapSense_dsRam.wdgtList.button6.snsClk)
N#define CapSense_BUTTON6_SNS_CLK_OFFSET                     (136u)
N#define CapSense_BUTTON6_SNS_CLK_SIZE                       (2u)
N#define CapSense_BUTTON6_SNS_CLK_PARAM_ID                   (0xAA860088u)
N
N#define CapSense_BUTTON6_SNS_CLK_SOURCE_VALUE               (CapSense_dsRam.wdgtList.button6.snsClkSource)
N#define CapSense_BUTTON6_SNS_CLK_SOURCE_OFFSET              (138u)
N#define CapSense_BUTTON6_SNS_CLK_SOURCE_SIZE                (1u)
N#define CapSense_BUTTON6_SNS_CLK_SOURCE_PARAM_ID            (0x4586008Au)
N
N#define CapSense_BUTTON7_RESOLUTION_VALUE                   (CapSense_dsRam.wdgtList.button7.resolution)
N#define CapSense_BUTTON7_RESOLUTION_OFFSET                  (140u)
N#define CapSense_BUTTON7_RESOLUTION_SIZE                    (2u)
N#define CapSense_BUTTON7_RESOLUTION_PARAM_ID                (0xA887008Cu)
N
N#define CapSense_BUTTON7_FINGER_TH_VALUE                    (CapSense_dsRam.wdgtList.button7.fingerTh)
N#define CapSense_BUTTON7_FINGER_TH_OFFSET                   (142u)
N#define CapSense_BUTTON7_FINGER_TH_SIZE                     (2u)
N#define CapSense_BUTTON7_FINGER_TH_PARAM_ID                 (0xA487008Eu)
N
N#define CapSense_BUTTON7_NOISE_TH_VALUE                     (CapSense_dsRam.wdgtList.button7.noiseTh)
N#define CapSense_BUTTON7_NOISE_TH_OFFSET                    (144u)
N#define CapSense_BUTTON7_NOISE_TH_SIZE                      (1u)
N#define CapSense_BUTTON7_NOISE_TH_PARAM_ID                  (0x66870090u)
N
N#define CapSense_BUTTON7_NNOISE_TH_VALUE                    (CapSense_dsRam.wdgtList.button7.nNoiseTh)
N#define CapSense_BUTTON7_NNOISE_TH_OFFSET                   (145u)
N#define CapSense_BUTTON7_NNOISE_TH_SIZE                     (1u)
N#define CapSense_BUTTON7_NNOISE_TH_PARAM_ID                 (0x60870091u)
N
N#define CapSense_BUTTON7_HYSTERESIS_VALUE                   (CapSense_dsRam.wdgtList.button7.hysteresis)
N#define CapSense_BUTTON7_HYSTERESIS_OFFSET                  (146u)
N#define CapSense_BUTTON7_HYSTERESIS_SIZE                    (1u)
N#define CapSense_BUTTON7_HYSTERESIS_PARAM_ID                (0x6A870092u)
N
N#define CapSense_BUTTON7_ON_DEBOUNCE_VALUE                  (CapSense_dsRam.wdgtList.button7.onDebounce)
N#define CapSense_BUTTON7_ON_DEBOUNCE_OFFSET                 (147u)
N#define CapSense_BUTTON7_ON_DEBOUNCE_SIZE                   (1u)
N#define CapSense_BUTTON7_ON_DEBOUNCE_PARAM_ID               (0x6C870093u)
N
N#define CapSense_BUTTON7_LOW_BSLN_RST_VALUE                 (CapSense_dsRam.wdgtList.button7.lowBslnRst)
N#define CapSense_BUTTON7_LOW_BSLN_RST_OFFSET                (148u)
N#define CapSense_BUTTON7_LOW_BSLN_RST_SIZE                  (1u)
N#define CapSense_BUTTON7_LOW_BSLN_RST_PARAM_ID              (0x67870094u)
N
N#define CapSense_BUTTON7_IDAC_MOD0_VALUE                    (CapSense_dsRam.wdgtList.button7.idacMod[0u])
N#define CapSense_BUTTON7_IDAC_MOD0_OFFSET                   (149u)
N#define CapSense_BUTTON7_IDAC_MOD0_SIZE                     (1u)
N#define CapSense_BUTTON7_IDAC_MOD0_PARAM_ID                 (0x47070095u)
N
N#define CapSense_BUTTON7_SNS_CLK_VALUE                      (CapSense_dsRam.wdgtList.button7.snsClk)
N#define CapSense_BUTTON7_SNS_CLK_OFFSET                     (150u)
N#define CapSense_BUTTON7_SNS_CLK_SIZE                       (2u)
N#define CapSense_BUTTON7_SNS_CLK_PARAM_ID                   (0xA3870096u)
N
N#define CapSense_BUTTON7_SNS_CLK_SOURCE_VALUE               (CapSense_dsRam.wdgtList.button7.snsClkSource)
N#define CapSense_BUTTON7_SNS_CLK_SOURCE_OFFSET              (152u)
N#define CapSense_BUTTON7_SNS_CLK_SOURCE_SIZE                (1u)
N#define CapSense_BUTTON7_SNS_CLK_SOURCE_PARAM_ID            (0x4F870098u)
N
N#define CapSense_BUTTON8_RESOLUTION_VALUE                   (CapSense_dsRam.wdgtList.button8.resolution)
N#define CapSense_BUTTON8_RESOLUTION_OFFSET                  (154u)
N#define CapSense_BUTTON8_RESOLUTION_SIZE                    (2u)
N#define CapSense_BUTTON8_RESOLUTION_PARAM_ID                (0xA888009Au)
N
N#define CapSense_BUTTON8_FINGER_TH_VALUE                    (CapSense_dsRam.wdgtList.button8.fingerTh)
N#define CapSense_BUTTON8_FINGER_TH_OFFSET                   (156u)
N#define CapSense_BUTTON8_FINGER_TH_SIZE                     (2u)
N#define CapSense_BUTTON8_FINGER_TH_PARAM_ID                 (0xA588009Cu)
N
N#define CapSense_BUTTON8_NOISE_TH_VALUE                     (CapSense_dsRam.wdgtList.button8.noiseTh)
N#define CapSense_BUTTON8_NOISE_TH_OFFSET                    (158u)
N#define CapSense_BUTTON8_NOISE_TH_SIZE                      (1u)
N#define CapSense_BUTTON8_NOISE_TH_PARAM_ID                  (0x6188009Eu)
N
N#define CapSense_BUTTON8_NNOISE_TH_VALUE                    (CapSense_dsRam.wdgtList.button8.nNoiseTh)
N#define CapSense_BUTTON8_NNOISE_TH_OFFSET                   (159u)
N#define CapSense_BUTTON8_NNOISE_TH_SIZE                     (1u)
N#define CapSense_BUTTON8_NNOISE_TH_PARAM_ID                 (0x6788009Fu)
N
N#define CapSense_BUTTON8_HYSTERESIS_VALUE                   (CapSense_dsRam.wdgtList.button8.hysteresis)
N#define CapSense_BUTTON8_HYSTERESIS_OFFSET                  (160u)
N#define CapSense_BUTTON8_HYSTERESIS_SIZE                    (1u)
N#define CapSense_BUTTON8_HYSTERESIS_PARAM_ID                (0x618800A0u)
N
N#define CapSense_BUTTON8_ON_DEBOUNCE_VALUE                  (CapSense_dsRam.wdgtList.button8.onDebounce)
N#define CapSense_BUTTON8_ON_DEBOUNCE_OFFSET                 (161u)
N#define CapSense_BUTTON8_ON_DEBOUNCE_SIZE                   (1u)
N#define CapSense_BUTTON8_ON_DEBOUNCE_PARAM_ID               (0x678800A1u)
N
N#define CapSense_BUTTON8_LOW_BSLN_RST_VALUE                 (CapSense_dsRam.wdgtList.button8.lowBslnRst)
N#define CapSense_BUTTON8_LOW_BSLN_RST_OFFSET                (162u)
N#define CapSense_BUTTON8_LOW_BSLN_RST_SIZE                  (1u)
N#define CapSense_BUTTON8_LOW_BSLN_RST_PARAM_ID              (0x6D8800A2u)
N
N#define CapSense_BUTTON8_IDAC_MOD0_VALUE                    (CapSense_dsRam.wdgtList.button8.idacMod[0u])
N#define CapSense_BUTTON8_IDAC_MOD0_OFFSET                   (163u)
N#define CapSense_BUTTON8_IDAC_MOD0_SIZE                     (1u)
N#define CapSense_BUTTON8_IDAC_MOD0_PARAM_ID                 (0x4D0800A3u)
N
N#define CapSense_BUTTON8_SNS_CLK_VALUE                      (CapSense_dsRam.wdgtList.button8.snsClk)
N#define CapSense_BUTTON8_SNS_CLK_OFFSET                     (164u)
N#define CapSense_BUTTON8_SNS_CLK_SIZE                       (2u)
N#define CapSense_BUTTON8_SNS_CLK_PARAM_ID                   (0xA88800A4u)
N
N#define CapSense_BUTTON8_SNS_CLK_SOURCE_VALUE               (CapSense_dsRam.wdgtList.button8.snsClkSource)
N#define CapSense_BUTTON8_SNS_CLK_SOURCE_OFFSET              (166u)
N#define CapSense_BUTTON8_SNS_CLK_SOURCE_SIZE                (1u)
N#define CapSense_BUTTON8_SNS_CLK_SOURCE_PARAM_ID            (0x478800A6u)
N
N#define CapSense_BUTTON9_RESOLUTION_VALUE                   (CapSense_dsRam.wdgtList.button9.resolution)
N#define CapSense_BUTTON9_RESOLUTION_OFFSET                  (168u)
N#define CapSense_BUTTON9_RESOLUTION_SIZE                    (2u)
N#define CapSense_BUTTON9_RESOLUTION_PARAM_ID                (0xA88900A8u)
N
N#define CapSense_BUTTON9_FINGER_TH_VALUE                    (CapSense_dsRam.wdgtList.button9.fingerTh)
N#define CapSense_BUTTON9_FINGER_TH_OFFSET                   (170u)
N#define CapSense_BUTTON9_FINGER_TH_SIZE                     (2u)
N#define CapSense_BUTTON9_FINGER_TH_PARAM_ID                 (0xA48900AAu)
N
N#define CapSense_BUTTON9_NOISE_TH_VALUE                     (CapSense_dsRam.wdgtList.button9.noiseTh)
N#define CapSense_BUTTON9_NOISE_TH_OFFSET                    (172u)
N#define CapSense_BUTTON9_NOISE_TH_SIZE                      (1u)
N#define CapSense_BUTTON9_NOISE_TH_PARAM_ID                  (0x618900ACu)
N
N#define CapSense_BUTTON9_NNOISE_TH_VALUE                    (CapSense_dsRam.wdgtList.button9.nNoiseTh)
N#define CapSense_BUTTON9_NNOISE_TH_OFFSET                   (173u)
N#define CapSense_BUTTON9_NNOISE_TH_SIZE                     (1u)
N#define CapSense_BUTTON9_NNOISE_TH_PARAM_ID                 (0x678900ADu)
N
N#define CapSense_BUTTON9_HYSTERESIS_VALUE                   (CapSense_dsRam.wdgtList.button9.hysteresis)
N#define CapSense_BUTTON9_HYSTERESIS_OFFSET                  (174u)
N#define CapSense_BUTTON9_HYSTERESIS_SIZE                    (1u)
N#define CapSense_BUTTON9_HYSTERESIS_PARAM_ID                (0x6D8900AEu)
N
N#define CapSense_BUTTON9_ON_DEBOUNCE_VALUE                  (CapSense_dsRam.wdgtList.button9.onDebounce)
N#define CapSense_BUTTON9_ON_DEBOUNCE_OFFSET                 (175u)
N#define CapSense_BUTTON9_ON_DEBOUNCE_SIZE                   (1u)
N#define CapSense_BUTTON9_ON_DEBOUNCE_PARAM_ID               (0x6B8900AFu)
N
N#define CapSense_BUTTON9_LOW_BSLN_RST_VALUE                 (CapSense_dsRam.wdgtList.button9.lowBslnRst)
N#define CapSense_BUTTON9_LOW_BSLN_RST_OFFSET                (176u)
N#define CapSense_BUTTON9_LOW_BSLN_RST_SIZE                  (1u)
N#define CapSense_BUTTON9_LOW_BSLN_RST_PARAM_ID              (0x678900B0u)
N
N#define CapSense_BUTTON9_IDAC_MOD0_VALUE                    (CapSense_dsRam.wdgtList.button9.idacMod[0u])
N#define CapSense_BUTTON9_IDAC_MOD0_OFFSET                   (177u)
N#define CapSense_BUTTON9_IDAC_MOD0_SIZE                     (1u)
N#define CapSense_BUTTON9_IDAC_MOD0_PARAM_ID                 (0x470900B1u)
N
N#define CapSense_BUTTON9_SNS_CLK_VALUE                      (CapSense_dsRam.wdgtList.button9.snsClk)
N#define CapSense_BUTTON9_SNS_CLK_OFFSET                     (178u)
N#define CapSense_BUTTON9_SNS_CLK_SIZE                       (2u)
N#define CapSense_BUTTON9_SNS_CLK_PARAM_ID                   (0xA38900B2u)
N
N#define CapSense_BUTTON9_SNS_CLK_SOURCE_VALUE               (CapSense_dsRam.wdgtList.button9.snsClkSource)
N#define CapSense_BUTTON9_SNS_CLK_SOURCE_OFFSET              (180u)
N#define CapSense_BUTTON9_SNS_CLK_SOURCE_SIZE                (1u)
N#define CapSense_BUTTON9_SNS_CLK_SOURCE_PARAM_ID            (0x4D8900B4u)
N
N#define CapSense_BUTTON10_RESOLUTION_VALUE                  (CapSense_dsRam.wdgtList.button10.resolution)
N#define CapSense_BUTTON10_RESOLUTION_OFFSET                 (182u)
N#define CapSense_BUTTON10_RESOLUTION_SIZE                   (2u)
N#define CapSense_BUTTON10_RESOLUTION_PARAM_ID               (0xA78A00B6u)
N
N#define CapSense_BUTTON10_FINGER_TH_VALUE                   (CapSense_dsRam.wdgtList.button10.fingerTh)
N#define CapSense_BUTTON10_FINGER_TH_OFFSET                  (184u)
N#define CapSense_BUTTON10_FINGER_TH_SIZE                    (2u)
N#define CapSense_BUTTON10_FINGER_TH_PARAM_ID                (0xA88A00B8u)
N
N#define CapSense_BUTTON10_NOISE_TH_VALUE                    (CapSense_dsRam.wdgtList.button10.noiseTh)
N#define CapSense_BUTTON10_NOISE_TH_OFFSET                   (186u)
N#define CapSense_BUTTON10_NOISE_TH_SIZE                     (1u)
N#define CapSense_BUTTON10_NOISE_TH_PARAM_ID                 (0x6C8A00BAu)
N
N#define CapSense_BUTTON10_NNOISE_TH_VALUE                   (CapSense_dsRam.wdgtList.button10.nNoiseTh)
N#define CapSense_BUTTON10_NNOISE_TH_OFFSET                  (187u)
N#define CapSense_BUTTON10_NNOISE_TH_SIZE                    (1u)
N#define CapSense_BUTTON10_NNOISE_TH_PARAM_ID                (0x6A8A00BBu)
N
N#define CapSense_BUTTON10_HYSTERESIS_VALUE                  (CapSense_dsRam.wdgtList.button10.hysteresis)
N#define CapSense_BUTTON10_HYSTERESIS_OFFSET                 (188u)
N#define CapSense_BUTTON10_HYSTERESIS_SIZE                   (1u)
N#define CapSense_BUTTON10_HYSTERESIS_PARAM_ID               (0x618A00BCu)
N
N#define CapSense_BUTTON10_ON_DEBOUNCE_VALUE                 (CapSense_dsRam.wdgtList.button10.onDebounce)
N#define CapSense_BUTTON10_ON_DEBOUNCE_OFFSET                (189u)
N#define CapSense_BUTTON10_ON_DEBOUNCE_SIZE                  (1u)
N#define CapSense_BUTTON10_ON_DEBOUNCE_PARAM_ID              (0x678A00BDu)
N
N#define CapSense_BUTTON10_LOW_BSLN_RST_VALUE                (CapSense_dsRam.wdgtList.button10.lowBslnRst)
N#define CapSense_BUTTON10_LOW_BSLN_RST_OFFSET               (190u)
N#define CapSense_BUTTON10_LOW_BSLN_RST_SIZE                 (1u)
N#define CapSense_BUTTON10_LOW_BSLN_RST_PARAM_ID             (0x6D8A00BEu)
N
N#define CapSense_BUTTON10_IDAC_MOD0_VALUE                   (CapSense_dsRam.wdgtList.button10.idacMod[0u])
N#define CapSense_BUTTON10_IDAC_MOD0_OFFSET                  (191u)
N#define CapSense_BUTTON10_IDAC_MOD0_SIZE                    (1u)
N#define CapSense_BUTTON10_IDAC_MOD0_PARAM_ID                (0x4D0A00BFu)
N
N#define CapSense_BUTTON10_SNS_CLK_VALUE                     (CapSense_dsRam.wdgtList.button10.snsClk)
N#define CapSense_BUTTON10_SNS_CLK_OFFSET                    (192u)
N#define CapSense_BUTTON10_SNS_CLK_SIZE                      (2u)
N#define CapSense_BUTTON10_SNS_CLK_PARAM_ID                  (0xA88A00C0u)
N
N#define CapSense_BUTTON10_SNS_CLK_SOURCE_VALUE              (CapSense_dsRam.wdgtList.button10.snsClkSource)
N#define CapSense_BUTTON10_SNS_CLK_SOURCE_OFFSET             (194u)
N#define CapSense_BUTTON10_SNS_CLK_SOURCE_SIZE               (1u)
N#define CapSense_BUTTON10_SNS_CLK_SOURCE_PARAM_ID           (0x478A00C2u)
N
N#define CapSense_BUTTON11_RESOLUTION_VALUE                  (CapSense_dsRam.wdgtList.button11.resolution)
N#define CapSense_BUTTON11_RESOLUTION_OFFSET                 (196u)
N#define CapSense_BUTTON11_RESOLUTION_SIZE                   (2u)
N#define CapSense_BUTTON11_RESOLUTION_PARAM_ID               (0xAA8B00C4u)
N
N#define CapSense_BUTTON11_FINGER_TH_VALUE                   (CapSense_dsRam.wdgtList.button11.fingerTh)
N#define CapSense_BUTTON11_FINGER_TH_OFFSET                  (198u)
N#define CapSense_BUTTON11_FINGER_TH_SIZE                    (2u)
N#define CapSense_BUTTON11_FINGER_TH_PARAM_ID                (0xA68B00C6u)
N
N#define CapSense_BUTTON11_NOISE_TH_VALUE                    (CapSense_dsRam.wdgtList.button11.noiseTh)
N#define CapSense_BUTTON11_NOISE_TH_OFFSET                   (200u)
N#define CapSense_BUTTON11_NOISE_TH_SIZE                     (1u)
N#define CapSense_BUTTON11_NOISE_TH_PARAM_ID                 (0x618B00C8u)
N
N#define CapSense_BUTTON11_NNOISE_TH_VALUE                   (CapSense_dsRam.wdgtList.button11.nNoiseTh)
N#define CapSense_BUTTON11_NNOISE_TH_OFFSET                  (201u)
N#define CapSense_BUTTON11_NNOISE_TH_SIZE                    (1u)
N#define CapSense_BUTTON11_NNOISE_TH_PARAM_ID                (0x678B00C9u)
N
N#define CapSense_BUTTON11_HYSTERESIS_VALUE                  (CapSense_dsRam.wdgtList.button11.hysteresis)
N#define CapSense_BUTTON11_HYSTERESIS_OFFSET                 (202u)
N#define CapSense_BUTTON11_HYSTERESIS_SIZE                   (1u)
N#define CapSense_BUTTON11_HYSTERESIS_PARAM_ID               (0x6D8B00CAu)
N
N#define CapSense_BUTTON11_ON_DEBOUNCE_VALUE                 (CapSense_dsRam.wdgtList.button11.onDebounce)
N#define CapSense_BUTTON11_ON_DEBOUNCE_OFFSET                (203u)
N#define CapSense_BUTTON11_ON_DEBOUNCE_SIZE                  (1u)
N#define CapSense_BUTTON11_ON_DEBOUNCE_PARAM_ID              (0x6B8B00CBu)
N
N#define CapSense_BUTTON11_LOW_BSLN_RST_VALUE                (CapSense_dsRam.wdgtList.button11.lowBslnRst)
N#define CapSense_BUTTON11_LOW_BSLN_RST_OFFSET               (204u)
N#define CapSense_BUTTON11_LOW_BSLN_RST_SIZE                 (1u)
N#define CapSense_BUTTON11_LOW_BSLN_RST_PARAM_ID             (0x608B00CCu)
N
N#define CapSense_BUTTON11_IDAC_MOD0_VALUE                   (CapSense_dsRam.wdgtList.button11.idacMod[0u])
N#define CapSense_BUTTON11_IDAC_MOD0_OFFSET                  (205u)
N#define CapSense_BUTTON11_IDAC_MOD0_SIZE                    (1u)
N#define CapSense_BUTTON11_IDAC_MOD0_PARAM_ID                (0x400B00CDu)
N
N#define CapSense_BUTTON11_SNS_CLK_VALUE                     (CapSense_dsRam.wdgtList.button11.snsClk)
N#define CapSense_BUTTON11_SNS_CLK_OFFSET                    (206u)
N#define CapSense_BUTTON11_SNS_CLK_SIZE                      (2u)
N#define CapSense_BUTTON11_SNS_CLK_PARAM_ID                  (0xA48B00CEu)
N
N#define CapSense_BUTTON11_SNS_CLK_SOURCE_VALUE              (CapSense_dsRam.wdgtList.button11.snsClkSource)
N#define CapSense_BUTTON11_SNS_CLK_SOURCE_OFFSET             (208u)
N#define CapSense_BUTTON11_SNS_CLK_SOURCE_SIZE               (1u)
N#define CapSense_BUTTON11_SNS_CLK_SOURCE_PARAM_ID           (0x4D8B00D0u)
N
N#define CapSense_PROXIMITY0_RESOLUTION_VALUE                (CapSense_dsRam.wdgtList.proximity0.resolution)
N#define CapSense_PROXIMITY0_RESOLUTION_OFFSET               (210u)
N#define CapSense_PROXIMITY0_RESOLUTION_SIZE                 (2u)
N#define CapSense_PROXIMITY0_RESOLUTION_PARAM_ID             (0xAB8C00D2u)
N
N#define CapSense_PROXIMITY0_FINGER_TH_VALUE                 (CapSense_dsRam.wdgtList.proximity0.fingerTh)
N#define CapSense_PROXIMITY0_FINGER_TH_OFFSET                (212u)
N#define CapSense_PROXIMITY0_FINGER_TH_SIZE                  (2u)
N#define CapSense_PROXIMITY0_FINGER_TH_PARAM_ID              (0xA68C00D4u)
N
N#define CapSense_PROXIMITY0_NOISE_TH_VALUE                  (CapSense_dsRam.wdgtList.proximity0.noiseTh)
N#define CapSense_PROXIMITY0_NOISE_TH_OFFSET                 (214u)
N#define CapSense_PROXIMITY0_NOISE_TH_SIZE                   (1u)
N#define CapSense_PROXIMITY0_NOISE_TH_PARAM_ID               (0x628C00D6u)
N
N#define CapSense_PROXIMITY0_NNOISE_TH_VALUE                 (CapSense_dsRam.wdgtList.proximity0.nNoiseTh)
N#define CapSense_PROXIMITY0_NNOISE_TH_OFFSET                (215u)
N#define CapSense_PROXIMITY0_NNOISE_TH_SIZE                  (1u)
N#define CapSense_PROXIMITY0_NNOISE_TH_PARAM_ID              (0x648C00D7u)
N
N#define CapSense_PROXIMITY0_HYSTERESIS_VALUE                (CapSense_dsRam.wdgtList.proximity0.hysteresis)
N#define CapSense_PROXIMITY0_HYSTERESIS_OFFSET               (216u)
N#define CapSense_PROXIMITY0_HYSTERESIS_SIZE                 (1u)
N#define CapSense_PROXIMITY0_HYSTERESIS_PARAM_ID             (0x6D8C00D8u)
N
N#define CapSense_PROXIMITY0_ON_DEBOUNCE_VALUE               (CapSense_dsRam.wdgtList.proximity0.onDebounce)
N#define CapSense_PROXIMITY0_ON_DEBOUNCE_OFFSET              (217u)
N#define CapSense_PROXIMITY0_ON_DEBOUNCE_SIZE                (1u)
N#define CapSense_PROXIMITY0_ON_DEBOUNCE_PARAM_ID            (0x6B8C00D9u)
N
N#define CapSense_PROXIMITY0_LOW_BSLN_RST_VALUE              (CapSense_dsRam.wdgtList.proximity0.lowBslnRst)
N#define CapSense_PROXIMITY0_LOW_BSLN_RST_OFFSET             (218u)
N#define CapSense_PROXIMITY0_LOW_BSLN_RST_SIZE               (1u)
N#define CapSense_PROXIMITY0_LOW_BSLN_RST_PARAM_ID           (0x618C00DAu)
N
N#define CapSense_PROXIMITY0_IDAC_MOD0_VALUE                 (CapSense_dsRam.wdgtList.proximity0.idacMod[0u])
N#define CapSense_PROXIMITY0_IDAC_MOD0_OFFSET                (219u)
N#define CapSense_PROXIMITY0_IDAC_MOD0_SIZE                  (1u)
N#define CapSense_PROXIMITY0_IDAC_MOD0_PARAM_ID              (0x410C00DBu)
N
N#define CapSense_PROXIMITY0_SNS_CLK_VALUE                   (CapSense_dsRam.wdgtList.proximity0.snsClk)
N#define CapSense_PROXIMITY0_SNS_CLK_OFFSET                  (220u)
N#define CapSense_PROXIMITY0_SNS_CLK_SIZE                    (2u)
N#define CapSense_PROXIMITY0_SNS_CLK_PARAM_ID                (0xA48C00DCu)
N
N#define CapSense_PROXIMITY0_SNS_CLK_SOURCE_VALUE            (CapSense_dsRam.wdgtList.proximity0.snsClkSource)
N#define CapSense_PROXIMITY0_SNS_CLK_SOURCE_OFFSET           (222u)
N#define CapSense_PROXIMITY0_SNS_CLK_SOURCE_SIZE             (1u)
N#define CapSense_PROXIMITY0_SNS_CLK_SOURCE_PARAM_ID         (0x4B8C00DEu)
N
N#define CapSense_PROXIMITY0_PROX_TOUCH_TH_VALUE             (CapSense_dsRam.wdgtList.proximity0.proxTouchTh)
N#define CapSense_PROXIMITY0_PROX_TOUCH_TH_OFFSET            (224u)
N#define CapSense_PROXIMITY0_PROX_TOUCH_TH_SIZE              (2u)
N#define CapSense_PROXIMITY0_PROX_TOUCH_TH_PARAM_ID          (0xA50C00E0u)
N
N#define CapSense_BUTTON0_SNS0_RAW0_VALUE                    (CapSense_dsRam.snsList.button0[0u].raw[0u])
N#define CapSense_BUTTON0_SNS0_RAW0_OFFSET                   (226u)
N#define CapSense_BUTTON0_SNS0_RAW0_SIZE                     (2u)
N#define CapSense_BUTTON0_SNS0_RAW0_PARAM_ID                 (0x8F0000E2u)
N
N#define CapSense_BUTTON0_SNS0_BSLN0_VALUE                   (CapSense_dsRam.snsList.button0[0u].bsln[0u])
N#define CapSense_BUTTON0_SNS0_BSLN0_OFFSET                  (228u)
N#define CapSense_BUTTON0_SNS0_BSLN0_SIZE                    (2u)
N#define CapSense_BUTTON0_SNS0_BSLN0_PARAM_ID                (0x820000E4u)
N
N#define CapSense_BUTTON0_SNS0_BSLN_EXT0_VALUE               (CapSense_dsRam.snsList.button0[0u].bslnExt[0u])
N#define CapSense_BUTTON0_SNS0_BSLN_EXT0_OFFSET              (230u)
N#define CapSense_BUTTON0_SNS0_BSLN_EXT0_SIZE                (1u)
N#define CapSense_BUTTON0_SNS0_BSLN_EXT0_PARAM_ID            (0x460000E6u)
N
N#define CapSense_BUTTON0_SNS0_DIFF_VALUE                    (CapSense_dsRam.snsList.button0[0u].diff)
N#define CapSense_BUTTON0_SNS0_DIFF_OFFSET                   (232u)
N#define CapSense_BUTTON0_SNS0_DIFF_SIZE                     (2u)
N#define CapSense_BUTTON0_SNS0_DIFF_PARAM_ID                 (0x810000E8u)
N
N#define CapSense_BUTTON0_SNS0_NEG_BSLN_RST_CNT0_VALUE       (CapSense_dsRam.snsList.button0[0u].negBslnRstCnt[0u])
N#define CapSense_BUTTON0_SNS0_NEG_BSLN_RST_CNT0_OFFSET      (234u)
N#define CapSense_BUTTON0_SNS0_NEG_BSLN_RST_CNT0_SIZE        (1u)
N#define CapSense_BUTTON0_SNS0_NEG_BSLN_RST_CNT0_PARAM_ID    (0x450000EAu)
N
N#define CapSense_BUTTON0_SNS0_IDAC_COMP0_VALUE              (CapSense_dsRam.snsList.button0[0u].idacComp[0u])
N#define CapSense_BUTTON0_SNS0_IDAC_COMP0_OFFSET             (235u)
N#define CapSense_BUTTON0_SNS0_IDAC_COMP0_SIZE               (1u)
N#define CapSense_BUTTON0_SNS0_IDAC_COMP0_PARAM_ID           (0x430000EBu)
N
N#define CapSense_BUTTON1_SNS0_RAW0_VALUE                    (CapSense_dsRam.snsList.button1[0u].raw[0u])
N#define CapSense_BUTTON1_SNS0_RAW0_OFFSET                   (236u)
N#define CapSense_BUTTON1_SNS0_RAW0_SIZE                     (2u)
N#define CapSense_BUTTON1_SNS0_RAW0_PARAM_ID                 (0x800000ECu)
N
N#define CapSense_BUTTON1_SNS0_BSLN0_VALUE                   (CapSense_dsRam.snsList.button1[0u].bsln[0u])
N#define CapSense_BUTTON1_SNS0_BSLN0_OFFSET                  (238u)
N#define CapSense_BUTTON1_SNS0_BSLN0_SIZE                    (2u)
N#define CapSense_BUTTON1_SNS0_BSLN0_PARAM_ID                (0x8C0000EEu)
N
N#define CapSense_BUTTON1_SNS0_BSLN_EXT0_VALUE               (CapSense_dsRam.snsList.button1[0u].bslnExt[0u])
N#define CapSense_BUTTON1_SNS0_BSLN_EXT0_OFFSET              (240u)
N#define CapSense_BUTTON1_SNS0_BSLN_EXT0_SIZE                (1u)
N#define CapSense_BUTTON1_SNS0_BSLN_EXT0_PARAM_ID            (0x4E0000F0u)
N
N#define CapSense_BUTTON1_SNS0_DIFF_VALUE                    (CapSense_dsRam.snsList.button1[0u].diff)
N#define CapSense_BUTTON1_SNS0_DIFF_OFFSET                   (242u)
N#define CapSense_BUTTON1_SNS0_DIFF_SIZE                     (2u)
N#define CapSense_BUTTON1_SNS0_DIFF_PARAM_ID                 (0x8A0000F2u)
N
N#define CapSense_BUTTON1_SNS0_NEG_BSLN_RST_CNT0_VALUE       (CapSense_dsRam.snsList.button1[0u].negBslnRstCnt[0u])
N#define CapSense_BUTTON1_SNS0_NEG_BSLN_RST_CNT0_OFFSET      (244u)
N#define CapSense_BUTTON1_SNS0_NEG_BSLN_RST_CNT0_SIZE        (1u)
N#define CapSense_BUTTON1_SNS0_NEG_BSLN_RST_CNT0_PARAM_ID    (0x4F0000F4u)
N
N#define CapSense_BUTTON1_SNS0_IDAC_COMP0_VALUE              (CapSense_dsRam.snsList.button1[0u].idacComp[0u])
N#define CapSense_BUTTON1_SNS0_IDAC_COMP0_OFFSET             (245u)
N#define CapSense_BUTTON1_SNS0_IDAC_COMP0_SIZE               (1u)
N#define CapSense_BUTTON1_SNS0_IDAC_COMP0_PARAM_ID           (0x490000F5u)
N
N#define CapSense_BUTTON2_SNS0_RAW0_VALUE                    (CapSense_dsRam.snsList.button2[0u].raw[0u])
N#define CapSense_BUTTON2_SNS0_RAW0_OFFSET                   (246u)
N#define CapSense_BUTTON2_SNS0_RAW0_SIZE                     (2u)
N#define CapSense_BUTTON2_SNS0_RAW0_PARAM_ID                 (0x8B0000F6u)
N
N#define CapSense_BUTTON2_SNS0_BSLN0_VALUE                   (CapSense_dsRam.snsList.button2[0u].bsln[0u])
N#define CapSense_BUTTON2_SNS0_BSLN0_OFFSET                  (248u)
N#define CapSense_BUTTON2_SNS0_BSLN0_SIZE                    (2u)
N#define CapSense_BUTTON2_SNS0_BSLN0_PARAM_ID                (0x840000F8u)
N
N#define CapSense_BUTTON2_SNS0_BSLN_EXT0_VALUE               (CapSense_dsRam.snsList.button2[0u].bslnExt[0u])
N#define CapSense_BUTTON2_SNS0_BSLN_EXT0_OFFSET              (250u)
N#define CapSense_BUTTON2_SNS0_BSLN_EXT0_SIZE                (1u)
N#define CapSense_BUTTON2_SNS0_BSLN_EXT0_PARAM_ID            (0x400000FAu)
N
N#define CapSense_BUTTON2_SNS0_DIFF_VALUE                    (CapSense_dsRam.snsList.button2[0u].diff)
N#define CapSense_BUTTON2_SNS0_DIFF_OFFSET                   (252u)
N#define CapSense_BUTTON2_SNS0_DIFF_SIZE                     (2u)
N#define CapSense_BUTTON2_SNS0_DIFF_PARAM_ID                 (0x850000FCu)
N
N#define CapSense_BUTTON2_SNS0_NEG_BSLN_RST_CNT0_VALUE       (CapSense_dsRam.snsList.button2[0u].negBslnRstCnt[0u])
N#define CapSense_BUTTON2_SNS0_NEG_BSLN_RST_CNT0_OFFSET      (254u)
N#define CapSense_BUTTON2_SNS0_NEG_BSLN_RST_CNT0_SIZE        (1u)
N#define CapSense_BUTTON2_SNS0_NEG_BSLN_RST_CNT0_PARAM_ID    (0x410000FEu)
N
N#define CapSense_BUTTON2_SNS0_IDAC_COMP0_VALUE              (CapSense_dsRam.snsList.button2[0u].idacComp[0u])
N#define CapSense_BUTTON2_SNS0_IDAC_COMP0_OFFSET             (255u)
N#define CapSense_BUTTON2_SNS0_IDAC_COMP0_SIZE               (1u)
N#define CapSense_BUTTON2_SNS0_IDAC_COMP0_PARAM_ID           (0x470000FFu)
N
N#define CapSense_BUTTON3_SNS0_RAW0_VALUE                    (CapSense_dsRam.snsList.button3[0u].raw[0u])
N#define CapSense_BUTTON3_SNS0_RAW0_OFFSET                   (256u)
N#define CapSense_BUTTON3_SNS0_RAW0_SIZE                     (2u)
N#define CapSense_BUTTON3_SNS0_RAW0_PARAM_ID                 (0x8C000100u)
N
N#define CapSense_BUTTON3_SNS0_BSLN0_VALUE                   (CapSense_dsRam.snsList.button3[0u].bsln[0u])
N#define CapSense_BUTTON3_SNS0_BSLN0_OFFSET                  (258u)
N#define CapSense_BUTTON3_SNS0_BSLN0_SIZE                    (2u)
N#define CapSense_BUTTON3_SNS0_BSLN0_PARAM_ID                (0x80000102u)
N
N#define CapSense_BUTTON3_SNS0_BSLN_EXT0_VALUE               (CapSense_dsRam.snsList.button3[0u].bslnExt[0u])
N#define CapSense_BUTTON3_SNS0_BSLN_EXT0_OFFSET              (260u)
N#define CapSense_BUTTON3_SNS0_BSLN_EXT0_SIZE                (1u)
N#define CapSense_BUTTON3_SNS0_BSLN_EXT0_PARAM_ID            (0x45000104u)
N
N#define CapSense_BUTTON3_SNS0_DIFF_VALUE                    (CapSense_dsRam.snsList.button3[0u].diff)
N#define CapSense_BUTTON3_SNS0_DIFF_OFFSET                   (262u)
N#define CapSense_BUTTON3_SNS0_DIFF_SIZE                     (2u)
N#define CapSense_BUTTON3_SNS0_DIFF_PARAM_ID                 (0x81000106u)
N
N#define CapSense_BUTTON3_SNS0_NEG_BSLN_RST_CNT0_VALUE       (CapSense_dsRam.snsList.button3[0u].negBslnRstCnt[0u])
N#define CapSense_BUTTON3_SNS0_NEG_BSLN_RST_CNT0_OFFSET      (264u)
N#define CapSense_BUTTON3_SNS0_NEG_BSLN_RST_CNT0_SIZE        (1u)
N#define CapSense_BUTTON3_SNS0_NEG_BSLN_RST_CNT0_PARAM_ID    (0x46000108u)
N
N#define CapSense_BUTTON3_SNS0_IDAC_COMP0_VALUE              (CapSense_dsRam.snsList.button3[0u].idacComp[0u])
N#define CapSense_BUTTON3_SNS0_IDAC_COMP0_OFFSET             (265u)
N#define CapSense_BUTTON3_SNS0_IDAC_COMP0_SIZE               (1u)
N#define CapSense_BUTTON3_SNS0_IDAC_COMP0_PARAM_ID           (0x40000109u)
N
N#define CapSense_BUTTON4_SNS0_RAW0_VALUE                    (CapSense_dsRam.snsList.button4[0u].raw[0u])
N#define CapSense_BUTTON4_SNS0_RAW0_OFFSET                   (266u)
N#define CapSense_BUTTON4_SNS0_RAW0_SIZE                     (2u)
N#define CapSense_BUTTON4_SNS0_RAW0_PARAM_ID                 (0x8200010Au)
N
N#define CapSense_BUTTON4_SNS0_BSLN0_VALUE                   (CapSense_dsRam.snsList.button4[0u].bsln[0u])
N#define CapSense_BUTTON4_SNS0_BSLN0_OFFSET                  (268u)
N#define CapSense_BUTTON4_SNS0_BSLN0_SIZE                    (2u)
N#define CapSense_BUTTON4_SNS0_BSLN0_PARAM_ID                (0x8F00010Cu)
N
N#define CapSense_BUTTON4_SNS0_BSLN_EXT0_VALUE               (CapSense_dsRam.snsList.button4[0u].bslnExt[0u])
N#define CapSense_BUTTON4_SNS0_BSLN_EXT0_OFFSET              (270u)
N#define CapSense_BUTTON4_SNS0_BSLN_EXT0_SIZE                (1u)
N#define CapSense_BUTTON4_SNS0_BSLN_EXT0_PARAM_ID            (0x4B00010Eu)
N
N#define CapSense_BUTTON4_SNS0_DIFF_VALUE                    (CapSense_dsRam.snsList.button4[0u].diff)
N#define CapSense_BUTTON4_SNS0_DIFF_OFFSET                   (272u)
N#define CapSense_BUTTON4_SNS0_DIFF_SIZE                     (2u)
N#define CapSense_BUTTON4_SNS0_DIFF_PARAM_ID                 (0x89000110u)
N
N#define CapSense_BUTTON4_SNS0_NEG_BSLN_RST_CNT0_VALUE       (CapSense_dsRam.snsList.button4[0u].negBslnRstCnt[0u])
N#define CapSense_BUTTON4_SNS0_NEG_BSLN_RST_CNT0_OFFSET      (274u)
N#define CapSense_BUTTON4_SNS0_NEG_BSLN_RST_CNT0_SIZE        (1u)
N#define CapSense_BUTTON4_SNS0_NEG_BSLN_RST_CNT0_PARAM_ID    (0x4D000112u)
N
N#define CapSense_BUTTON4_SNS0_IDAC_COMP0_VALUE              (CapSense_dsRam.snsList.button4[0u].idacComp[0u])
N#define CapSense_BUTTON4_SNS0_IDAC_COMP0_OFFSET             (275u)
N#define CapSense_BUTTON4_SNS0_IDAC_COMP0_SIZE               (1u)
N#define CapSense_BUTTON4_SNS0_IDAC_COMP0_PARAM_ID           (0x4B000113u)
N
N#define CapSense_BUTTON5_SNS0_RAW0_VALUE                    (CapSense_dsRam.snsList.button5[0u].raw[0u])
N#define CapSense_BUTTON5_SNS0_RAW0_OFFSET                   (276u)
N#define CapSense_BUTTON5_SNS0_RAW0_SIZE                     (2u)
N#define CapSense_BUTTON5_SNS0_RAW0_PARAM_ID                 (0x88000114u)
N
N#define CapSense_BUTTON5_SNS0_BSLN0_VALUE                   (CapSense_dsRam.snsList.button5[0u].bsln[0u])
N#define CapSense_BUTTON5_SNS0_BSLN0_OFFSET                  (278u)
N#define CapSense_BUTTON5_SNS0_BSLN0_SIZE                    (2u)
N#define CapSense_BUTTON5_SNS0_BSLN0_PARAM_ID                (0x84000116u)
N
N#define CapSense_BUTTON5_SNS0_BSLN_EXT0_VALUE               (CapSense_dsRam.snsList.button5[0u].bslnExt[0u])
N#define CapSense_BUTTON5_SNS0_BSLN_EXT0_OFFSET              (280u)
N#define CapSense_BUTTON5_SNS0_BSLN_EXT0_SIZE                (1u)
N#define CapSense_BUTTON5_SNS0_BSLN_EXT0_PARAM_ID            (0x43000118u)
N
N#define CapSense_BUTTON5_SNS0_DIFF_VALUE                    (CapSense_dsRam.snsList.button5[0u].diff)
N#define CapSense_BUTTON5_SNS0_DIFF_OFFSET                   (282u)
N#define CapSense_BUTTON5_SNS0_DIFF_SIZE                     (2u)
N#define CapSense_BUTTON5_SNS0_DIFF_PARAM_ID                 (0x8700011Au)
N
N#define CapSense_BUTTON5_SNS0_NEG_BSLN_RST_CNT0_VALUE       (CapSense_dsRam.snsList.button5[0u].negBslnRstCnt[0u])
N#define CapSense_BUTTON5_SNS0_NEG_BSLN_RST_CNT0_OFFSET      (284u)
N#define CapSense_BUTTON5_SNS0_NEG_BSLN_RST_CNT0_SIZE        (1u)
N#define CapSense_BUTTON5_SNS0_NEG_BSLN_RST_CNT0_PARAM_ID    (0x4200011Cu)
N
N#define CapSense_BUTTON5_SNS0_IDAC_COMP0_VALUE              (CapSense_dsRam.snsList.button5[0u].idacComp[0u])
N#define CapSense_BUTTON5_SNS0_IDAC_COMP0_OFFSET             (285u)
N#define CapSense_BUTTON5_SNS0_IDAC_COMP0_SIZE               (1u)
N#define CapSense_BUTTON5_SNS0_IDAC_COMP0_PARAM_ID           (0x4400011Du)
N
N#define CapSense_BUTTON6_SNS0_RAW0_VALUE                    (CapSense_dsRam.snsList.button6[0u].raw[0u])
N#define CapSense_BUTTON6_SNS0_RAW0_OFFSET                   (286u)
N#define CapSense_BUTTON6_SNS0_RAW0_SIZE                     (2u)
N#define CapSense_BUTTON6_SNS0_RAW0_PARAM_ID                 (0x8600011Eu)
N
N#define CapSense_BUTTON6_SNS0_BSLN0_VALUE                   (CapSense_dsRam.snsList.button6[0u].bsln[0u])
N#define CapSense_BUTTON6_SNS0_BSLN0_OFFSET                  (288u)
N#define CapSense_BUTTON6_SNS0_BSLN0_SIZE                    (2u)
N#define CapSense_BUTTON6_SNS0_BSLN0_PARAM_ID                (0x86000120u)
N
N#define CapSense_BUTTON6_SNS0_BSLN_EXT0_VALUE               (CapSense_dsRam.snsList.button6[0u].bslnExt[0u])
N#define CapSense_BUTTON6_SNS0_BSLN_EXT0_OFFSET              (290u)
N#define CapSense_BUTTON6_SNS0_BSLN_EXT0_SIZE                (1u)
N#define CapSense_BUTTON6_SNS0_BSLN_EXT0_PARAM_ID            (0x42000122u)
N
N#define CapSense_BUTTON6_SNS0_DIFF_VALUE                    (CapSense_dsRam.snsList.button6[0u].diff)
N#define CapSense_BUTTON6_SNS0_DIFF_OFFSET                   (292u)
N#define CapSense_BUTTON6_SNS0_DIFF_SIZE                     (2u)
N#define CapSense_BUTTON6_SNS0_DIFF_PARAM_ID                 (0x87000124u)
N
N#define CapSense_BUTTON6_SNS0_NEG_BSLN_RST_CNT0_VALUE       (CapSense_dsRam.snsList.button6[0u].negBslnRstCnt[0u])
N#define CapSense_BUTTON6_SNS0_NEG_BSLN_RST_CNT0_OFFSET      (294u)
N#define CapSense_BUTTON6_SNS0_NEG_BSLN_RST_CNT0_SIZE        (1u)
N#define CapSense_BUTTON6_SNS0_NEG_BSLN_RST_CNT0_PARAM_ID    (0x43000126u)
N
N#define CapSense_BUTTON6_SNS0_IDAC_COMP0_VALUE              (CapSense_dsRam.snsList.button6[0u].idacComp[0u])
N#define CapSense_BUTTON6_SNS0_IDAC_COMP0_OFFSET             (295u)
N#define CapSense_BUTTON6_SNS0_IDAC_COMP0_SIZE               (1u)
N#define CapSense_BUTTON6_SNS0_IDAC_COMP0_PARAM_ID           (0x45000127u)
N
N#define CapSense_BUTTON7_SNS0_RAW0_VALUE                    (CapSense_dsRam.snsList.button7[0u].raw[0u])
N#define CapSense_BUTTON7_SNS0_RAW0_OFFSET                   (296u)
N#define CapSense_BUTTON7_SNS0_RAW0_SIZE                     (2u)
N#define CapSense_BUTTON7_SNS0_RAW0_PARAM_ID                 (0x84000128u)
N
N#define CapSense_BUTTON7_SNS0_BSLN0_VALUE                   (CapSense_dsRam.snsList.button7[0u].bsln[0u])
N#define CapSense_BUTTON7_SNS0_BSLN0_OFFSET                  (298u)
N#define CapSense_BUTTON7_SNS0_BSLN0_SIZE                    (2u)
N#define CapSense_BUTTON7_SNS0_BSLN0_PARAM_ID                (0x8800012Au)
N
N#define CapSense_BUTTON7_SNS0_BSLN_EXT0_VALUE               (CapSense_dsRam.snsList.button7[0u].bslnExt[0u])
N#define CapSense_BUTTON7_SNS0_BSLN_EXT0_OFFSET              (300u)
N#define CapSense_BUTTON7_SNS0_BSLN_EXT0_SIZE                (1u)
N#define CapSense_BUTTON7_SNS0_BSLN_EXT0_PARAM_ID            (0x4D00012Cu)
N
N#define CapSense_BUTTON7_SNS0_DIFF_VALUE                    (CapSense_dsRam.snsList.button7[0u].diff)
N#define CapSense_BUTTON7_SNS0_DIFF_OFFSET                   (302u)
N#define CapSense_BUTTON7_SNS0_DIFF_SIZE                     (2u)
N#define CapSense_BUTTON7_SNS0_DIFF_PARAM_ID                 (0x8900012Eu)
N
N#define CapSense_BUTTON7_SNS0_NEG_BSLN_RST_CNT0_VALUE       (CapSense_dsRam.snsList.button7[0u].negBslnRstCnt[0u])
N#define CapSense_BUTTON7_SNS0_NEG_BSLN_RST_CNT0_OFFSET      (304u)
N#define CapSense_BUTTON7_SNS0_NEG_BSLN_RST_CNT0_SIZE        (1u)
N#define CapSense_BUTTON7_SNS0_NEG_BSLN_RST_CNT0_PARAM_ID    (0x4B000130u)
N
N#define CapSense_BUTTON7_SNS0_IDAC_COMP0_VALUE              (CapSense_dsRam.snsList.button7[0u].idacComp[0u])
N#define CapSense_BUTTON7_SNS0_IDAC_COMP0_OFFSET             (305u)
N#define CapSense_BUTTON7_SNS0_IDAC_COMP0_SIZE               (1u)
N#define CapSense_BUTTON7_SNS0_IDAC_COMP0_PARAM_ID           (0x4D000131u)
N
N#define CapSense_BUTTON8_SNS0_RAW0_VALUE                    (CapSense_dsRam.snsList.button8[0u].raw[0u])
N#define CapSense_BUTTON8_SNS0_RAW0_OFFSET                   (306u)
N#define CapSense_BUTTON8_SNS0_RAW0_SIZE                     (2u)
N#define CapSense_BUTTON8_SNS0_RAW0_PARAM_ID                 (0x8F000132u)
N
N#define CapSense_BUTTON8_SNS0_BSLN0_VALUE                   (CapSense_dsRam.snsList.button8[0u].bsln[0u])
N#define CapSense_BUTTON8_SNS0_BSLN0_OFFSET                  (308u)
N#define CapSense_BUTTON8_SNS0_BSLN0_SIZE                    (2u)
N#define CapSense_BUTTON8_SNS0_BSLN0_PARAM_ID                (0x82000134u)
N
N#define CapSense_BUTTON8_SNS0_BSLN_EXT0_VALUE               (CapSense_dsRam.snsList.button8[0u].bslnExt[0u])
N#define CapSense_BUTTON8_SNS0_BSLN_EXT0_OFFSET              (310u)
N#define CapSense_BUTTON8_SNS0_BSLN_EXT0_SIZE                (1u)
N#define CapSense_BUTTON8_SNS0_BSLN_EXT0_PARAM_ID            (0x46000136u)
N
N#define CapSense_BUTTON8_SNS0_DIFF_VALUE                    (CapSense_dsRam.snsList.button8[0u].diff)
N#define CapSense_BUTTON8_SNS0_DIFF_OFFSET                   (312u)
N#define CapSense_BUTTON8_SNS0_DIFF_SIZE                     (2u)
N#define CapSense_BUTTON8_SNS0_DIFF_PARAM_ID                 (0x81000138u)
N
N#define CapSense_BUTTON8_SNS0_NEG_BSLN_RST_CNT0_VALUE       (CapSense_dsRam.snsList.button8[0u].negBslnRstCnt[0u])
N#define CapSense_BUTTON8_SNS0_NEG_BSLN_RST_CNT0_OFFSET      (314u)
N#define CapSense_BUTTON8_SNS0_NEG_BSLN_RST_CNT0_SIZE        (1u)
N#define CapSense_BUTTON8_SNS0_NEG_BSLN_RST_CNT0_PARAM_ID    (0x4500013Au)
N
N#define CapSense_BUTTON8_SNS0_IDAC_COMP0_VALUE              (CapSense_dsRam.snsList.button8[0u].idacComp[0u])
N#define CapSense_BUTTON8_SNS0_IDAC_COMP0_OFFSET             (315u)
N#define CapSense_BUTTON8_SNS0_IDAC_COMP0_SIZE               (1u)
N#define CapSense_BUTTON8_SNS0_IDAC_COMP0_PARAM_ID           (0x4300013Bu)
N
N#define CapSense_BUTTON9_SNS0_RAW0_VALUE                    (CapSense_dsRam.snsList.button9[0u].raw[0u])
N#define CapSense_BUTTON9_SNS0_RAW0_OFFSET                   (316u)
N#define CapSense_BUTTON9_SNS0_RAW0_SIZE                     (2u)
N#define CapSense_BUTTON9_SNS0_RAW0_PARAM_ID                 (0x8000013Cu)
N
N#define CapSense_BUTTON9_SNS0_BSLN0_VALUE                   (CapSense_dsRam.snsList.button9[0u].bsln[0u])
N#define CapSense_BUTTON9_SNS0_BSLN0_OFFSET                  (318u)
N#define CapSense_BUTTON9_SNS0_BSLN0_SIZE                    (2u)
N#define CapSense_BUTTON9_SNS0_BSLN0_PARAM_ID                (0x8C00013Eu)
N
N#define CapSense_BUTTON9_SNS0_BSLN_EXT0_VALUE               (CapSense_dsRam.snsList.button9[0u].bslnExt[0u])
N#define CapSense_BUTTON9_SNS0_BSLN_EXT0_OFFSET              (320u)
N#define CapSense_BUTTON9_SNS0_BSLN_EXT0_SIZE                (1u)
N#define CapSense_BUTTON9_SNS0_BSLN_EXT0_PARAM_ID            (0x49000140u)
N
N#define CapSense_BUTTON9_SNS0_DIFF_VALUE                    (CapSense_dsRam.snsList.button9[0u].diff)
N#define CapSense_BUTTON9_SNS0_DIFF_OFFSET                   (322u)
N#define CapSense_BUTTON9_SNS0_DIFF_SIZE                     (2u)
N#define CapSense_BUTTON9_SNS0_DIFF_PARAM_ID                 (0x8D000142u)
N
N#define CapSense_BUTTON9_SNS0_NEG_BSLN_RST_CNT0_VALUE       (CapSense_dsRam.snsList.button9[0u].negBslnRstCnt[0u])
N#define CapSense_BUTTON9_SNS0_NEG_BSLN_RST_CNT0_OFFSET      (324u)
N#define CapSense_BUTTON9_SNS0_NEG_BSLN_RST_CNT0_SIZE        (1u)
N#define CapSense_BUTTON9_SNS0_NEG_BSLN_RST_CNT0_PARAM_ID    (0x48000144u)
N
N#define CapSense_BUTTON9_SNS0_IDAC_COMP0_VALUE              (CapSense_dsRam.snsList.button9[0u].idacComp[0u])
N#define CapSense_BUTTON9_SNS0_IDAC_COMP0_OFFSET             (325u)
N#define CapSense_BUTTON9_SNS0_IDAC_COMP0_SIZE               (1u)
N#define CapSense_BUTTON9_SNS0_IDAC_COMP0_PARAM_ID           (0x4E000145u)
N
N#define CapSense_BUTTON10_SNS0_RAW0_VALUE                   (CapSense_dsRam.snsList.button10[0u].raw[0u])
N#define CapSense_BUTTON10_SNS0_RAW0_OFFSET                  (326u)
N#define CapSense_BUTTON10_SNS0_RAW0_SIZE                    (2u)
N#define CapSense_BUTTON10_SNS0_RAW0_PARAM_ID                (0x8C000146u)
N
N#define CapSense_BUTTON10_SNS0_BSLN0_VALUE                  (CapSense_dsRam.snsList.button10[0u].bsln[0u])
N#define CapSense_BUTTON10_SNS0_BSLN0_OFFSET                 (328u)
N#define CapSense_BUTTON10_SNS0_BSLN0_SIZE                   (2u)
N#define CapSense_BUTTON10_SNS0_BSLN0_PARAM_ID               (0x83000148u)
N
N#define CapSense_BUTTON10_SNS0_BSLN_EXT0_VALUE              (CapSense_dsRam.snsList.button10[0u].bslnExt[0u])
N#define CapSense_BUTTON10_SNS0_BSLN_EXT0_OFFSET             (330u)
N#define CapSense_BUTTON10_SNS0_BSLN_EXT0_SIZE               (1u)
N#define CapSense_BUTTON10_SNS0_BSLN_EXT0_PARAM_ID           (0x4700014Au)
N
N#define CapSense_BUTTON10_SNS0_DIFF_VALUE                   (CapSense_dsRam.snsList.button10[0u].diff)
N#define CapSense_BUTTON10_SNS0_DIFF_OFFSET                  (332u)
N#define CapSense_BUTTON10_SNS0_DIFF_SIZE                    (2u)
N#define CapSense_BUTTON10_SNS0_DIFF_PARAM_ID                (0x8200014Cu)
N
N#define CapSense_BUTTON10_SNS0_NEG_BSLN_RST_CNT0_VALUE      (CapSense_dsRam.snsList.button10[0u].negBslnRstCnt[0u])
N#define CapSense_BUTTON10_SNS0_NEG_BSLN_RST_CNT0_OFFSET     (334u)
N#define CapSense_BUTTON10_SNS0_NEG_BSLN_RST_CNT0_SIZE       (1u)
N#define CapSense_BUTTON10_SNS0_NEG_BSLN_RST_CNT0_PARAM_ID   (0x4600014Eu)
N
N#define CapSense_BUTTON10_SNS0_IDAC_COMP0_VALUE             (CapSense_dsRam.snsList.button10[0u].idacComp[0u])
N#define CapSense_BUTTON10_SNS0_IDAC_COMP0_OFFSET            (335u)
N#define CapSense_BUTTON10_SNS0_IDAC_COMP0_SIZE              (1u)
N#define CapSense_BUTTON10_SNS0_IDAC_COMP0_PARAM_ID          (0x4000014Fu)
N
N#define CapSense_BUTTON11_SNS0_RAW0_VALUE                   (CapSense_dsRam.snsList.button11[0u].raw[0u])
N#define CapSense_BUTTON11_SNS0_RAW0_OFFSET                  (336u)
N#define CapSense_BUTTON11_SNS0_RAW0_SIZE                    (2u)
N#define CapSense_BUTTON11_SNS0_RAW0_PARAM_ID                (0x84000150u)
N
N#define CapSense_BUTTON11_SNS0_BSLN0_VALUE                  (CapSense_dsRam.snsList.button11[0u].bsln[0u])
N#define CapSense_BUTTON11_SNS0_BSLN0_OFFSET                 (338u)
N#define CapSense_BUTTON11_SNS0_BSLN0_SIZE                   (2u)
N#define CapSense_BUTTON11_SNS0_BSLN0_PARAM_ID               (0x88000152u)
N
N#define CapSense_BUTTON11_SNS0_BSLN_EXT0_VALUE              (CapSense_dsRam.snsList.button11[0u].bslnExt[0u])
N#define CapSense_BUTTON11_SNS0_BSLN_EXT0_OFFSET             (340u)
N#define CapSense_BUTTON11_SNS0_BSLN_EXT0_SIZE               (1u)
N#define CapSense_BUTTON11_SNS0_BSLN_EXT0_PARAM_ID           (0x4D000154u)
N
N#define CapSense_BUTTON11_SNS0_DIFF_VALUE                   (CapSense_dsRam.snsList.button11[0u].diff)
N#define CapSense_BUTTON11_SNS0_DIFF_OFFSET                  (342u)
N#define CapSense_BUTTON11_SNS0_DIFF_SIZE                    (2u)
N#define CapSense_BUTTON11_SNS0_DIFF_PARAM_ID                (0x89000156u)
N
N#define CapSense_BUTTON11_SNS0_NEG_BSLN_RST_CNT0_VALUE      (CapSense_dsRam.snsList.button11[0u].negBslnRstCnt[0u])
N#define CapSense_BUTTON11_SNS0_NEG_BSLN_RST_CNT0_OFFSET     (344u)
N#define CapSense_BUTTON11_SNS0_NEG_BSLN_RST_CNT0_SIZE       (1u)
N#define CapSense_BUTTON11_SNS0_NEG_BSLN_RST_CNT0_PARAM_ID   (0x4E000158u)
N
N#define CapSense_BUTTON11_SNS0_IDAC_COMP0_VALUE             (CapSense_dsRam.snsList.button11[0u].idacComp[0u])
N#define CapSense_BUTTON11_SNS0_IDAC_COMP0_OFFSET            (345u)
N#define CapSense_BUTTON11_SNS0_IDAC_COMP0_SIZE              (1u)
N#define CapSense_BUTTON11_SNS0_IDAC_COMP0_PARAM_ID          (0x48000159u)
N
N#define CapSense_PROXIMITY0_SNS0_RAW0_VALUE                 (CapSense_dsRam.snsList.proximity0[0u].raw[0u])
N#define CapSense_PROXIMITY0_SNS0_RAW0_OFFSET                (346u)
N#define CapSense_PROXIMITY0_SNS0_RAW0_SIZE                  (2u)
N#define CapSense_PROXIMITY0_SNS0_RAW0_PARAM_ID              (0x8A00015Au)
N
N#define CapSense_PROXIMITY0_SNS0_BSLN0_VALUE                (CapSense_dsRam.snsList.proximity0[0u].bsln[0u])
N#define CapSense_PROXIMITY0_SNS0_BSLN0_OFFSET               (348u)
N#define CapSense_PROXIMITY0_SNS0_BSLN0_SIZE                 (2u)
N#define CapSense_PROXIMITY0_SNS0_BSLN0_PARAM_ID             (0x8700015Cu)
N
N#define CapSense_PROXIMITY0_SNS0_BSLN_EXT0_VALUE            (CapSense_dsRam.snsList.proximity0[0u].bslnExt[0u])
N#define CapSense_PROXIMITY0_SNS0_BSLN_EXT0_OFFSET           (350u)
N#define CapSense_PROXIMITY0_SNS0_BSLN_EXT0_SIZE             (1u)
N#define CapSense_PROXIMITY0_SNS0_BSLN_EXT0_PARAM_ID         (0x4300015Eu)
N
N#define CapSense_PROXIMITY0_SNS0_DIFF_VALUE                 (CapSense_dsRam.snsList.proximity0[0u].diff)
N#define CapSense_PROXIMITY0_SNS0_DIFF_OFFSET                (352u)
N#define CapSense_PROXIMITY0_SNS0_DIFF_SIZE                  (2u)
N#define CapSense_PROXIMITY0_SNS0_DIFF_PARAM_ID              (0x8B000160u)
N
N#define CapSense_PROXIMITY0_SNS0_NEG_BSLN_RST_CNT0_VALUE    (CapSense_dsRam.snsList.proximity0[0u].negBslnRstCnt[0u])
N#define CapSense_PROXIMITY0_SNS0_NEG_BSLN_RST_CNT0_OFFSET   (354u)
N#define CapSense_PROXIMITY0_SNS0_NEG_BSLN_RST_CNT0_SIZE     (1u)
N#define CapSense_PROXIMITY0_SNS0_NEG_BSLN_RST_CNT0_PARAM_ID (0x4F000162u)
N
N#define CapSense_PROXIMITY0_SNS0_IDAC_COMP0_VALUE           (CapSense_dsRam.snsList.proximity0[0u].idacComp[0u])
N#define CapSense_PROXIMITY0_SNS0_IDAC_COMP0_OFFSET          (355u)
N#define CapSense_PROXIMITY0_SNS0_IDAC_COMP0_SIZE            (1u)
N#define CapSense_PROXIMITY0_SNS0_IDAC_COMP0_PARAM_ID        (0x49000163u)
N
N#define CapSense_SNR_TEST_WIDGET_ID_VALUE                   (CapSense_dsRam.snrTestWidgetId)
N#define CapSense_SNR_TEST_WIDGET_ID_OFFSET                  (356u)
N#define CapSense_SNR_TEST_WIDGET_ID_SIZE                    (1u)
N#define CapSense_SNR_TEST_WIDGET_ID_PARAM_ID                (0x69000164u)
N
N#define CapSense_SNR_TEST_SENSOR_ID_VALUE                   (CapSense_dsRam.snrTestSensorId)
N#define CapSense_SNR_TEST_SENSOR_ID_OFFSET                  (357u)
N#define CapSense_SNR_TEST_SENSOR_ID_SIZE                    (1u)
N#define CapSense_SNR_TEST_SENSOR_ID_PARAM_ID                (0x6F000165u)
N
N#define CapSense_SNR_TEST_SCAN_COUNTER_VALUE                (CapSense_dsRam.snrTestScanCounter)
N#define CapSense_SNR_TEST_SCAN_COUNTER_OFFSET               (358u)
N#define CapSense_SNR_TEST_SCAN_COUNTER_SIZE                 (2u)
N#define CapSense_SNR_TEST_SCAN_COUNTER_PARAM_ID             (0x86000166u)
N
N#define CapSense_SNR_TEST_RAW_COUNT0_VALUE                  (CapSense_dsRam.snrTestRawCount[0u])
N#define CapSense_SNR_TEST_RAW_COUNT0_OFFSET                 (360u)
N#define CapSense_SNR_TEST_RAW_COUNT0_SIZE                   (2u)
N#define CapSense_SNR_TEST_RAW_COUNT0_PARAM_ID               (0x89000168u)
N
N
N/*****************************************************************************/
N/* Flash Data structure register definitions                                 */
N/*****************************************************************************/
N#define CapSense_BUTTON0_PTR2SNS_FLASH_VALUE                (CapSense_dsFlash.wdgtArray[0].ptr2SnsFlash)
N#define CapSense_BUTTON0_PTR2SNS_FLASH_OFFSET               (0u)
N#define CapSense_BUTTON0_PTR2SNS_FLASH_SIZE                 (4u)
N#define CapSense_BUTTON0_PTR2SNS_FLASH_PARAM_ID             (0xD1000000u)
N
N#define CapSense_BUTTON0_PTR2WD_RAM_VALUE                   (CapSense_dsFlash.wdgtArray[0].ptr2WdgtRam)
N#define CapSense_BUTTON0_PTR2WD_RAM_OFFSET                  (4u)
N#define CapSense_BUTTON0_PTR2WD_RAM_SIZE                    (4u)
N#define CapSense_BUTTON0_PTR2WD_RAM_PARAM_ID                (0xD0000004u)
N
N#define CapSense_BUTTON0_PTR2SNS_RAM_VALUE                  (CapSense_dsFlash.wdgtArray[0].ptr2SnsRam)
N#define CapSense_BUTTON0_PTR2SNS_RAM_OFFSET                 (8u)
N#define CapSense_BUTTON0_PTR2SNS_RAM_SIZE                   (4u)
N#define CapSense_BUTTON0_PTR2SNS_RAM_PARAM_ID               (0xD3000008u)
N
N#define CapSense_BUTTON0_PTR2FLTR_HISTORY_VALUE             (CapSense_dsFlash.wdgtArray[0].ptr2FltrHistory)
N#define CapSense_BUTTON0_PTR2FLTR_HISTORY_OFFSET            (12u)
N#define CapSense_BUTTON0_PTR2FLTR_HISTORY_SIZE              (4u)
N#define CapSense_BUTTON0_PTR2FLTR_HISTORY_PARAM_ID          (0xD200000Cu)
N
N#define CapSense_BUTTON0_PTR2DEBOUNCE_VALUE                 (CapSense_dsFlash.wdgtArray[0].ptr2DebounceArr)
N#define CapSense_BUTTON0_PTR2DEBOUNCE_OFFSET                (16u)
N#define CapSense_BUTTON0_PTR2DEBOUNCE_SIZE                  (4u)
N#define CapSense_BUTTON0_PTR2DEBOUNCE_PARAM_ID              (0xD4000010u)
N
N#define CapSense_BUTTON0_STATIC_CONFIG_VALUE                (CapSense_dsFlash.wdgtArray[0].staticConfig)
N#define CapSense_BUTTON0_STATIC_CONFIG_OFFSET               (20u)
N#define CapSense_BUTTON0_STATIC_CONFIG_SIZE                 (4u)
N#define CapSense_BUTTON0_STATIC_CONFIG_PARAM_ID             (0xD5000014u)
N
N#define CapSense_BUTTON0_TOTAL_NUM_SNS_VALUE                (CapSense_dsFlash.wdgtArray[0].totalNumSns)
N#define CapSense_BUTTON0_TOTAL_NUM_SNS_OFFSET               (24u)
N#define CapSense_BUTTON0_TOTAL_NUM_SNS_SIZE                 (2u)
N#define CapSense_BUTTON0_TOTAL_NUM_SNS_PARAM_ID             (0x99000018u)
N
N#define CapSense_BUTTON0_TYPE_VALUE                         (CapSense_dsFlash.wdgtArray[0].wdgtType)
N#define CapSense_BUTTON0_TYPE_OFFSET                        (26u)
N#define CapSense_BUTTON0_TYPE_SIZE                          (1u)
N#define CapSense_BUTTON0_TYPE_PARAM_ID                      (0x5D00001Au)
N
N#define CapSense_BUTTON0_NUM_COLS_VALUE                     (CapSense_dsFlash.wdgtArray[0].numCols)
N#define CapSense_BUTTON0_NUM_COLS_OFFSET                    (27u)
N#define CapSense_BUTTON0_NUM_COLS_SIZE                      (1u)
N#define CapSense_BUTTON0_NUM_COLS_PARAM_ID                  (0x5B00001Bu)
N
N#define CapSense_BUTTON1_PTR2SNS_FLASH_VALUE                (CapSense_dsFlash.wdgtArray[1].ptr2SnsFlash)
N#define CapSense_BUTTON1_PTR2SNS_FLASH_OFFSET               (28u)
N#define CapSense_BUTTON1_PTR2SNS_FLASH_SIZE                 (4u)
N#define CapSense_BUTTON1_PTR2SNS_FLASH_PARAM_ID             (0xD401001Cu)
N
N#define CapSense_BUTTON1_PTR2WD_RAM_VALUE                   (CapSense_dsFlash.wdgtArray[1].ptr2WdgtRam)
N#define CapSense_BUTTON1_PTR2WD_RAM_OFFSET                  (32u)
N#define CapSense_BUTTON1_PTR2WD_RAM_SIZE                    (4u)
N#define CapSense_BUTTON1_PTR2WD_RAM_PARAM_ID                (0xD8010020u)
N
N#define CapSense_BUTTON1_PTR2SNS_RAM_VALUE                  (CapSense_dsFlash.wdgtArray[1].ptr2SnsRam)
N#define CapSense_BUTTON1_PTR2SNS_RAM_OFFSET                 (36u)
N#define CapSense_BUTTON1_PTR2SNS_RAM_SIZE                   (4u)
N#define CapSense_BUTTON1_PTR2SNS_RAM_PARAM_ID               (0xD9010024u)
N
N#define CapSense_BUTTON1_PTR2FLTR_HISTORY_VALUE             (CapSense_dsFlash.wdgtArray[1].ptr2FltrHistory)
N#define CapSense_BUTTON1_PTR2FLTR_HISTORY_OFFSET            (40u)
N#define CapSense_BUTTON1_PTR2FLTR_HISTORY_SIZE              (4u)
N#define CapSense_BUTTON1_PTR2FLTR_HISTORY_PARAM_ID          (0xDA010028u)
N
N#define CapSense_BUTTON1_PTR2DEBOUNCE_VALUE                 (CapSense_dsFlash.wdgtArray[1].ptr2DebounceArr)
N#define CapSense_BUTTON1_PTR2DEBOUNCE_OFFSET                (44u)
N#define CapSense_BUTTON1_PTR2DEBOUNCE_SIZE                  (4u)
N#define CapSense_BUTTON1_PTR2DEBOUNCE_PARAM_ID              (0xDB01002Cu)
N
N#define CapSense_BUTTON1_STATIC_CONFIG_VALUE                (CapSense_dsFlash.wdgtArray[1].staticConfig)
N#define CapSense_BUTTON1_STATIC_CONFIG_OFFSET               (48u)
N#define CapSense_BUTTON1_STATIC_CONFIG_SIZE                 (4u)
N#define CapSense_BUTTON1_STATIC_CONFIG_PARAM_ID             (0xDD010030u)
N
N#define CapSense_BUTTON1_TOTAL_NUM_SNS_VALUE                (CapSense_dsFlash.wdgtArray[1].totalNumSns)
N#define CapSense_BUTTON1_TOTAL_NUM_SNS_OFFSET               (52u)
N#define CapSense_BUTTON1_TOTAL_NUM_SNS_SIZE                 (2u)
N#define CapSense_BUTTON1_TOTAL_NUM_SNS_PARAM_ID             (0x93010034u)
N
N#define CapSense_BUTTON1_TYPE_VALUE                         (CapSense_dsFlash.wdgtArray[1].wdgtType)
N#define CapSense_BUTTON1_TYPE_OFFSET                        (54u)
N#define CapSense_BUTTON1_TYPE_SIZE                          (1u)
N#define CapSense_BUTTON1_TYPE_PARAM_ID                      (0x57010036u)
N
N#define CapSense_BUTTON1_NUM_COLS_VALUE                     (CapSense_dsFlash.wdgtArray[1].numCols)
N#define CapSense_BUTTON1_NUM_COLS_OFFSET                    (55u)
N#define CapSense_BUTTON1_NUM_COLS_SIZE                      (1u)
N#define CapSense_BUTTON1_NUM_COLS_PARAM_ID                  (0x51010037u)
N
N#define CapSense_BUTTON2_PTR2SNS_FLASH_VALUE                (CapSense_dsFlash.wdgtArray[2].ptr2SnsFlash)
N#define CapSense_BUTTON2_PTR2SNS_FLASH_OFFSET               (56u)
N#define CapSense_BUTTON2_PTR2SNS_FLASH_SIZE                 (4u)
N#define CapSense_BUTTON2_PTR2SNS_FLASH_PARAM_ID             (0xDA020038u)
N
N#define CapSense_BUTTON2_PTR2WD_RAM_VALUE                   (CapSense_dsFlash.wdgtArray[2].ptr2WdgtRam)
N#define CapSense_BUTTON2_PTR2WD_RAM_OFFSET                  (60u)
N#define CapSense_BUTTON2_PTR2WD_RAM_SIZE                    (4u)
N#define CapSense_BUTTON2_PTR2WD_RAM_PARAM_ID                (0xDB02003Cu)
N
N#define CapSense_BUTTON2_PTR2SNS_RAM_VALUE                  (CapSense_dsFlash.wdgtArray[2].ptr2SnsRam)
N#define CapSense_BUTTON2_PTR2SNS_RAM_OFFSET                 (64u)
N#define CapSense_BUTTON2_PTR2SNS_RAM_SIZE                   (4u)
N#define CapSense_BUTTON2_PTR2SNS_RAM_PARAM_ID               (0xDA020040u)
N
N#define CapSense_BUTTON2_PTR2FLTR_HISTORY_VALUE             (CapSense_dsFlash.wdgtArray[2].ptr2FltrHistory)
N#define CapSense_BUTTON2_PTR2FLTR_HISTORY_OFFSET            (68u)
N#define CapSense_BUTTON2_PTR2FLTR_HISTORY_SIZE              (4u)
N#define CapSense_BUTTON2_PTR2FLTR_HISTORY_PARAM_ID          (0xDB020044u)
N
N#define CapSense_BUTTON2_PTR2DEBOUNCE_VALUE                 (CapSense_dsFlash.wdgtArray[2].ptr2DebounceArr)
N#define CapSense_BUTTON2_PTR2DEBOUNCE_OFFSET                (72u)
N#define CapSense_BUTTON2_PTR2DEBOUNCE_SIZE                  (4u)
N#define CapSense_BUTTON2_PTR2DEBOUNCE_PARAM_ID              (0xD8020048u)
N
N#define CapSense_BUTTON2_STATIC_CONFIG_VALUE                (CapSense_dsFlash.wdgtArray[2].staticConfig)
N#define CapSense_BUTTON2_STATIC_CONFIG_OFFSET               (76u)
N#define CapSense_BUTTON2_STATIC_CONFIG_SIZE                 (4u)
N#define CapSense_BUTTON2_STATIC_CONFIG_PARAM_ID             (0xD902004Cu)
N
N#define CapSense_BUTTON2_TOTAL_NUM_SNS_VALUE                (CapSense_dsFlash.wdgtArray[2].totalNumSns)
N#define CapSense_BUTTON2_TOTAL_NUM_SNS_OFFSET               (80u)
N#define CapSense_BUTTON2_TOTAL_NUM_SNS_SIZE                 (2u)
N#define CapSense_BUTTON2_TOTAL_NUM_SNS_PARAM_ID             (0x90020050u)
N
N#define CapSense_BUTTON2_TYPE_VALUE                         (CapSense_dsFlash.wdgtArray[2].wdgtType)
N#define CapSense_BUTTON2_TYPE_OFFSET                        (82u)
N#define CapSense_BUTTON2_TYPE_SIZE                          (1u)
N#define CapSense_BUTTON2_TYPE_PARAM_ID                      (0x54020052u)
N
N#define CapSense_BUTTON2_NUM_COLS_VALUE                     (CapSense_dsFlash.wdgtArray[2].numCols)
N#define CapSense_BUTTON2_NUM_COLS_OFFSET                    (83u)
N#define CapSense_BUTTON2_NUM_COLS_SIZE                      (1u)
N#define CapSense_BUTTON2_NUM_COLS_PARAM_ID                  (0x52020053u)
N
N#define CapSense_BUTTON3_PTR2SNS_FLASH_VALUE                (CapSense_dsFlash.wdgtArray[3].ptr2SnsFlash)
N#define CapSense_BUTTON3_PTR2SNS_FLASH_OFFSET               (84u)
N#define CapSense_BUTTON3_PTR2SNS_FLASH_SIZE                 (4u)
N#define CapSense_BUTTON3_PTR2SNS_FLASH_PARAM_ID             (0xDD030054u)
N
N#define CapSense_BUTTON3_PTR2WD_RAM_VALUE                   (CapSense_dsFlash.wdgtArray[3].ptr2WdgtRam)
N#define CapSense_BUTTON3_PTR2WD_RAM_OFFSET                  (88u)
N#define CapSense_BUTTON3_PTR2WD_RAM_SIZE                    (4u)
N#define CapSense_BUTTON3_PTR2WD_RAM_PARAM_ID                (0xDE030058u)
N
N#define CapSense_BUTTON3_PTR2SNS_RAM_VALUE                  (CapSense_dsFlash.wdgtArray[3].ptr2SnsRam)
N#define CapSense_BUTTON3_PTR2SNS_RAM_OFFSET                 (92u)
N#define CapSense_BUTTON3_PTR2SNS_RAM_SIZE                   (4u)
N#define CapSense_BUTTON3_PTR2SNS_RAM_PARAM_ID               (0xDF03005Cu)
N
N#define CapSense_BUTTON3_PTR2FLTR_HISTORY_VALUE             (CapSense_dsFlash.wdgtArray[3].ptr2FltrHistory)
N#define CapSense_BUTTON3_PTR2FLTR_HISTORY_OFFSET            (96u)
N#define CapSense_BUTTON3_PTR2FLTR_HISTORY_SIZE              (4u)
N#define CapSense_BUTTON3_PTR2FLTR_HISTORY_PARAM_ID          (0xD3030060u)
N
N#define CapSense_BUTTON3_PTR2DEBOUNCE_VALUE                 (CapSense_dsFlash.wdgtArray[3].ptr2DebounceArr)
N#define CapSense_BUTTON3_PTR2DEBOUNCE_OFFSET                (100u)
N#define CapSense_BUTTON3_PTR2DEBOUNCE_SIZE                  (4u)
N#define CapSense_BUTTON3_PTR2DEBOUNCE_PARAM_ID              (0xD2030064u)
N
N#define CapSense_BUTTON3_STATIC_CONFIG_VALUE                (CapSense_dsFlash.wdgtArray[3].staticConfig)
N#define CapSense_BUTTON3_STATIC_CONFIG_OFFSET               (104u)
N#define CapSense_BUTTON3_STATIC_CONFIG_SIZE                 (4u)
N#define CapSense_BUTTON3_STATIC_CONFIG_PARAM_ID             (0xD1030068u)
N
N#define CapSense_BUTTON3_TOTAL_NUM_SNS_VALUE                (CapSense_dsFlash.wdgtArray[3].totalNumSns)
N#define CapSense_BUTTON3_TOTAL_NUM_SNS_OFFSET               (108u)
N#define CapSense_BUTTON3_TOTAL_NUM_SNS_SIZE                 (2u)
N#define CapSense_BUTTON3_TOTAL_NUM_SNS_PARAM_ID             (0x9F03006Cu)
N
N#define CapSense_BUTTON3_TYPE_VALUE                         (CapSense_dsFlash.wdgtArray[3].wdgtType)
N#define CapSense_BUTTON3_TYPE_OFFSET                        (110u)
N#define CapSense_BUTTON3_TYPE_SIZE                          (1u)
N#define CapSense_BUTTON3_TYPE_PARAM_ID                      (0x5B03006Eu)
N
N#define CapSense_BUTTON3_NUM_COLS_VALUE                     (CapSense_dsFlash.wdgtArray[3].numCols)
N#define CapSense_BUTTON3_NUM_COLS_OFFSET                    (111u)
N#define CapSense_BUTTON3_NUM_COLS_SIZE                      (1u)
N#define CapSense_BUTTON3_NUM_COLS_PARAM_ID                  (0x5D03006Fu)
N
N#define CapSense_BUTTON4_PTR2SNS_FLASH_VALUE                (CapSense_dsFlash.wdgtArray[4].ptr2SnsFlash)
N#define CapSense_BUTTON4_PTR2SNS_FLASH_OFFSET               (112u)
N#define CapSense_BUTTON4_PTR2SNS_FLASH_SIZE                 (4u)
N#define CapSense_BUTTON4_PTR2SNS_FLASH_PARAM_ID             (0xDF040070u)
N
N#define CapSense_BUTTON4_PTR2WD_RAM_VALUE                   (CapSense_dsFlash.wdgtArray[4].ptr2WdgtRam)
N#define CapSense_BUTTON4_PTR2WD_RAM_OFFSET                  (116u)
N#define CapSense_BUTTON4_PTR2WD_RAM_SIZE                    (4u)
N#define CapSense_BUTTON4_PTR2WD_RAM_PARAM_ID                (0xDE040074u)
N
N#define CapSense_BUTTON4_PTR2SNS_RAM_VALUE                  (CapSense_dsFlash.wdgtArray[4].ptr2SnsRam)
N#define CapSense_BUTTON4_PTR2SNS_RAM_OFFSET                 (120u)
N#define CapSense_BUTTON4_PTR2SNS_RAM_SIZE                   (4u)
N#define CapSense_BUTTON4_PTR2SNS_RAM_PARAM_ID               (0xDD040078u)
N
N#define CapSense_BUTTON4_PTR2FLTR_HISTORY_VALUE             (CapSense_dsFlash.wdgtArray[4].ptr2FltrHistory)
N#define CapSense_BUTTON4_PTR2FLTR_HISTORY_OFFSET            (124u)
N#define CapSense_BUTTON4_PTR2FLTR_HISTORY_SIZE              (4u)
N#define CapSense_BUTTON4_PTR2FLTR_HISTORY_PARAM_ID          (0xDC04007Cu)
N
N#define CapSense_BUTTON4_PTR2DEBOUNCE_VALUE                 (CapSense_dsFlash.wdgtArray[4].ptr2DebounceArr)
N#define CapSense_BUTTON4_PTR2DEBOUNCE_OFFSET                (128u)
N#define CapSense_BUTTON4_PTR2DEBOUNCE_SIZE                  (4u)
N#define CapSense_BUTTON4_PTR2DEBOUNCE_PARAM_ID              (0xDE040080u)
N
N#define CapSense_BUTTON4_STATIC_CONFIG_VALUE                (CapSense_dsFlash.wdgtArray[4].staticConfig)
N#define CapSense_BUTTON4_STATIC_CONFIG_OFFSET               (132u)
N#define CapSense_BUTTON4_STATIC_CONFIG_SIZE                 (4u)
N#define CapSense_BUTTON4_STATIC_CONFIG_PARAM_ID             (0xDF040084u)
N
N#define CapSense_BUTTON4_TOTAL_NUM_SNS_VALUE                (CapSense_dsFlash.wdgtArray[4].totalNumSns)
N#define CapSense_BUTTON4_TOTAL_NUM_SNS_OFFSET               (136u)
N#define CapSense_BUTTON4_TOTAL_NUM_SNS_SIZE                 (2u)
N#define CapSense_BUTTON4_TOTAL_NUM_SNS_PARAM_ID             (0x93040088u)
N
N#define CapSense_BUTTON4_TYPE_VALUE                         (CapSense_dsFlash.wdgtArray[4].wdgtType)
N#define CapSense_BUTTON4_TYPE_OFFSET                        (138u)
N#define CapSense_BUTTON4_TYPE_SIZE                          (1u)
N#define CapSense_BUTTON4_TYPE_PARAM_ID                      (0x5704008Au)
N
N#define CapSense_BUTTON4_NUM_COLS_VALUE                     (CapSense_dsFlash.wdgtArray[4].numCols)
N#define CapSense_BUTTON4_NUM_COLS_OFFSET                    (139u)
N#define CapSense_BUTTON4_NUM_COLS_SIZE                      (1u)
N#define CapSense_BUTTON4_NUM_COLS_PARAM_ID                  (0x5104008Bu)
N
N#define CapSense_BUTTON5_PTR2SNS_FLASH_VALUE                (CapSense_dsFlash.wdgtArray[5].ptr2SnsFlash)
N#define CapSense_BUTTON5_PTR2SNS_FLASH_OFFSET               (140u)
N#define CapSense_BUTTON5_PTR2SNS_FLASH_SIZE                 (4u)
N#define CapSense_BUTTON5_PTR2SNS_FLASH_PARAM_ID             (0xDE05008Cu)
N
N#define CapSense_BUTTON5_PTR2WD_RAM_VALUE                   (CapSense_dsFlash.wdgtArray[5].ptr2WdgtRam)
N#define CapSense_BUTTON5_PTR2WD_RAM_OFFSET                  (144u)
N#define CapSense_BUTTON5_PTR2WD_RAM_SIZE                    (4u)
N#define CapSense_BUTTON5_PTR2WD_RAM_PARAM_ID                (0xD8050090u)
N
N#define CapSense_BUTTON5_PTR2SNS_RAM_VALUE                  (CapSense_dsFlash.wdgtArray[5].ptr2SnsRam)
N#define CapSense_BUTTON5_PTR2SNS_RAM_OFFSET                 (148u)
N#define CapSense_BUTTON5_PTR2SNS_RAM_SIZE                   (4u)
N#define CapSense_BUTTON5_PTR2SNS_RAM_PARAM_ID               (0xD9050094u)
N
N#define CapSense_BUTTON5_PTR2FLTR_HISTORY_VALUE             (CapSense_dsFlash.wdgtArray[5].ptr2FltrHistory)
N#define CapSense_BUTTON5_PTR2FLTR_HISTORY_OFFSET            (152u)
N#define CapSense_BUTTON5_PTR2FLTR_HISTORY_SIZE              (4u)
N#define CapSense_BUTTON5_PTR2FLTR_HISTORY_PARAM_ID          (0xDA050098u)
N
N#define CapSense_BUTTON5_PTR2DEBOUNCE_VALUE                 (CapSense_dsFlash.wdgtArray[5].ptr2DebounceArr)
N#define CapSense_BUTTON5_PTR2DEBOUNCE_OFFSET                (156u)
N#define CapSense_BUTTON5_PTR2DEBOUNCE_SIZE                  (4u)
N#define CapSense_BUTTON5_PTR2DEBOUNCE_PARAM_ID              (0xDB05009Cu)
N
N#define CapSense_BUTTON5_STATIC_CONFIG_VALUE                (CapSense_dsFlash.wdgtArray[5].staticConfig)
N#define CapSense_BUTTON5_STATIC_CONFIG_OFFSET               (160u)
N#define CapSense_BUTTON5_STATIC_CONFIG_SIZE                 (4u)
N#define CapSense_BUTTON5_STATIC_CONFIG_PARAM_ID             (0xD70500A0u)
N
N#define CapSense_BUTTON5_TOTAL_NUM_SNS_VALUE                (CapSense_dsFlash.wdgtArray[5].totalNumSns)
N#define CapSense_BUTTON5_TOTAL_NUM_SNS_OFFSET               (164u)
N#define CapSense_BUTTON5_TOTAL_NUM_SNS_SIZE                 (2u)
N#define CapSense_BUTTON5_TOTAL_NUM_SNS_PARAM_ID             (0x990500A4u)
N
N#define CapSense_BUTTON5_TYPE_VALUE                         (CapSense_dsFlash.wdgtArray[5].wdgtType)
N#define CapSense_BUTTON5_TYPE_OFFSET                        (166u)
N#define CapSense_BUTTON5_TYPE_SIZE                          (1u)
N#define CapSense_BUTTON5_TYPE_PARAM_ID                      (0x5D0500A6u)
N
N#define CapSense_BUTTON5_NUM_COLS_VALUE                     (CapSense_dsFlash.wdgtArray[5].numCols)
N#define CapSense_BUTTON5_NUM_COLS_OFFSET                    (167u)
N#define CapSense_BUTTON5_NUM_COLS_SIZE                      (1u)
N#define CapSense_BUTTON5_NUM_COLS_PARAM_ID                  (0x5B0500A7u)
N
N#define CapSense_BUTTON6_PTR2SNS_FLASH_VALUE                (CapSense_dsFlash.wdgtArray[6].ptr2SnsFlash)
N#define CapSense_BUTTON6_PTR2SNS_FLASH_OFFSET               (168u)
N#define CapSense_BUTTON6_PTR2SNS_FLASH_SIZE                 (4u)
N#define CapSense_BUTTON6_PTR2SNS_FLASH_PARAM_ID             (0xD00600A8u)
N
N#define CapSense_BUTTON6_PTR2WD_RAM_VALUE                   (CapSense_dsFlash.wdgtArray[6].ptr2WdgtRam)
N#define CapSense_BUTTON6_PTR2WD_RAM_OFFSET                  (172u)
N#define CapSense_BUTTON6_PTR2WD_RAM_SIZE                    (4u)
N#define CapSense_BUTTON6_PTR2WD_RAM_PARAM_ID                (0xD10600ACu)
N
N#define CapSense_BUTTON6_PTR2SNS_RAM_VALUE                  (CapSense_dsFlash.wdgtArray[6].ptr2SnsRam)
N#define CapSense_BUTTON6_PTR2SNS_RAM_OFFSET                 (176u)
N#define CapSense_BUTTON6_PTR2SNS_RAM_SIZE                   (4u)
N#define CapSense_BUTTON6_PTR2SNS_RAM_PARAM_ID               (0xD70600B0u)
N
N#define CapSense_BUTTON6_PTR2FLTR_HISTORY_VALUE             (CapSense_dsFlash.wdgtArray[6].ptr2FltrHistory)
N#define CapSense_BUTTON6_PTR2FLTR_HISTORY_OFFSET            (180u)
N#define CapSense_BUTTON6_PTR2FLTR_HISTORY_SIZE              (4u)
N#define CapSense_BUTTON6_PTR2FLTR_HISTORY_PARAM_ID          (0xD60600B4u)
N
N#define CapSense_BUTTON6_PTR2DEBOUNCE_VALUE                 (CapSense_dsFlash.wdgtArray[6].ptr2DebounceArr)
N#define CapSense_BUTTON6_PTR2DEBOUNCE_OFFSET                (184u)
N#define CapSense_BUTTON6_PTR2DEBOUNCE_SIZE                  (4u)
N#define CapSense_BUTTON6_PTR2DEBOUNCE_PARAM_ID              (0xD50600B8u)
N
N#define CapSense_BUTTON6_STATIC_CONFIG_VALUE                (CapSense_dsFlash.wdgtArray[6].staticConfig)
N#define CapSense_BUTTON6_STATIC_CONFIG_OFFSET               (188u)
N#define CapSense_BUTTON6_STATIC_CONFIG_SIZE                 (4u)
N#define CapSense_BUTTON6_STATIC_CONFIG_PARAM_ID             (0xD40600BCu)
N
N#define CapSense_BUTTON6_TOTAL_NUM_SNS_VALUE                (CapSense_dsFlash.wdgtArray[6].totalNumSns)
N#define CapSense_BUTTON6_TOTAL_NUM_SNS_OFFSET               (192u)
N#define CapSense_BUTTON6_TOTAL_NUM_SNS_SIZE                 (2u)
N#define CapSense_BUTTON6_TOTAL_NUM_SNS_PARAM_ID             (0x9A0600C0u)
N
N#define CapSense_BUTTON6_TYPE_VALUE                         (CapSense_dsFlash.wdgtArray[6].wdgtType)
N#define CapSense_BUTTON6_TYPE_OFFSET                        (194u)
N#define CapSense_BUTTON6_TYPE_SIZE                          (1u)
N#define CapSense_BUTTON6_TYPE_PARAM_ID                      (0x5E0600C2u)
N
N#define CapSense_BUTTON6_NUM_COLS_VALUE                     (CapSense_dsFlash.wdgtArray[6].numCols)
N#define CapSense_BUTTON6_NUM_COLS_OFFSET                    (195u)
N#define CapSense_BUTTON6_NUM_COLS_SIZE                      (1u)
N#define CapSense_BUTTON6_NUM_COLS_PARAM_ID                  (0x580600C3u)
N
N#define CapSense_BUTTON7_PTR2SNS_FLASH_VALUE                (CapSense_dsFlash.wdgtArray[7].ptr2SnsFlash)
N#define CapSense_BUTTON7_PTR2SNS_FLASH_OFFSET               (196u)
N#define CapSense_BUTTON7_PTR2SNS_FLASH_SIZE                 (4u)
N#define CapSense_BUTTON7_PTR2SNS_FLASH_PARAM_ID             (0xD70700C4u)
N
N#define CapSense_BUTTON7_PTR2WD_RAM_VALUE                   (CapSense_dsFlash.wdgtArray[7].ptr2WdgtRam)
N#define CapSense_BUTTON7_PTR2WD_RAM_OFFSET                  (200u)
N#define CapSense_BUTTON7_PTR2WD_RAM_SIZE                    (4u)
N#define CapSense_BUTTON7_PTR2WD_RAM_PARAM_ID                (0xD40700C8u)
N
N#define CapSense_BUTTON7_PTR2SNS_RAM_VALUE                  (CapSense_dsFlash.wdgtArray[7].ptr2SnsRam)
N#define CapSense_BUTTON7_PTR2SNS_RAM_OFFSET                 (204u)
N#define CapSense_BUTTON7_PTR2SNS_RAM_SIZE                   (4u)
N#define CapSense_BUTTON7_PTR2SNS_RAM_PARAM_ID               (0xD50700CCu)
N
N#define CapSense_BUTTON7_PTR2FLTR_HISTORY_VALUE             (CapSense_dsFlash.wdgtArray[7].ptr2FltrHistory)
N#define CapSense_BUTTON7_PTR2FLTR_HISTORY_OFFSET            (208u)
N#define CapSense_BUTTON7_PTR2FLTR_HISTORY_SIZE              (4u)
N#define CapSense_BUTTON7_PTR2FLTR_HISTORY_PARAM_ID          (0xD30700D0u)
N
N#define CapSense_BUTTON7_PTR2DEBOUNCE_VALUE                 (CapSense_dsFlash.wdgtArray[7].ptr2DebounceArr)
N#define CapSense_BUTTON7_PTR2DEBOUNCE_OFFSET                (212u)
N#define CapSense_BUTTON7_PTR2DEBOUNCE_SIZE                  (4u)
N#define CapSense_BUTTON7_PTR2DEBOUNCE_PARAM_ID              (0xD20700D4u)
N
N#define CapSense_BUTTON7_STATIC_CONFIG_VALUE                (CapSense_dsFlash.wdgtArray[7].staticConfig)
N#define CapSense_BUTTON7_STATIC_CONFIG_OFFSET               (216u)
N#define CapSense_BUTTON7_STATIC_CONFIG_SIZE                 (4u)
N#define CapSense_BUTTON7_STATIC_CONFIG_PARAM_ID             (0xD10700D8u)
N
N#define CapSense_BUTTON7_TOTAL_NUM_SNS_VALUE                (CapSense_dsFlash.wdgtArray[7].totalNumSns)
N#define CapSense_BUTTON7_TOTAL_NUM_SNS_OFFSET               (220u)
N#define CapSense_BUTTON7_TOTAL_NUM_SNS_SIZE                 (2u)
N#define CapSense_BUTTON7_TOTAL_NUM_SNS_PARAM_ID             (0x9F0700DCu)
N
N#define CapSense_BUTTON7_TYPE_VALUE                         (CapSense_dsFlash.wdgtArray[7].wdgtType)
N#define CapSense_BUTTON7_TYPE_OFFSET                        (222u)
N#define CapSense_BUTTON7_TYPE_SIZE                          (1u)
N#define CapSense_BUTTON7_TYPE_PARAM_ID                      (0x5B0700DEu)
N
N#define CapSense_BUTTON7_NUM_COLS_VALUE                     (CapSense_dsFlash.wdgtArray[7].numCols)
N#define CapSense_BUTTON7_NUM_COLS_OFFSET                    (223u)
N#define CapSense_BUTTON7_NUM_COLS_SIZE                      (1u)
N#define CapSense_BUTTON7_NUM_COLS_PARAM_ID                  (0x5D0700DFu)
N
N#define CapSense_BUTTON8_PTR2SNS_FLASH_VALUE                (CapSense_dsFlash.wdgtArray[8].ptr2SnsFlash)
N#define CapSense_BUTTON8_PTR2SNS_FLASH_OFFSET               (224u)
N#define CapSense_BUTTON8_PTR2SNS_FLASH_SIZE                 (4u)
N#define CapSense_BUTTON8_PTR2SNS_FLASH_PARAM_ID             (0xD40800E0u)
N
N#define CapSense_BUTTON8_PTR2WD_RAM_VALUE                   (CapSense_dsFlash.wdgtArray[8].ptr2WdgtRam)
N#define CapSense_BUTTON8_PTR2WD_RAM_OFFSET                  (228u)
N#define CapSense_BUTTON8_PTR2WD_RAM_SIZE                    (4u)
N#define CapSense_BUTTON8_PTR2WD_RAM_PARAM_ID                (0xD50800E4u)
N
N#define CapSense_BUTTON8_PTR2SNS_RAM_VALUE                  (CapSense_dsFlash.wdgtArray[8].ptr2SnsRam)
N#define CapSense_BUTTON8_PTR2SNS_RAM_OFFSET                 (232u)
N#define CapSense_BUTTON8_PTR2SNS_RAM_SIZE                   (4u)
N#define CapSense_BUTTON8_PTR2SNS_RAM_PARAM_ID               (0xD60800E8u)
N
N#define CapSense_BUTTON8_PTR2FLTR_HISTORY_VALUE             (CapSense_dsFlash.wdgtArray[8].ptr2FltrHistory)
N#define CapSense_BUTTON8_PTR2FLTR_HISTORY_OFFSET            (236u)
N#define CapSense_BUTTON8_PTR2FLTR_HISTORY_SIZE              (4u)
N#define CapSense_BUTTON8_PTR2FLTR_HISTORY_PARAM_ID          (0xD70800ECu)
N
N#define CapSense_BUTTON8_PTR2DEBOUNCE_VALUE                 (CapSense_dsFlash.wdgtArray[8].ptr2DebounceArr)
N#define CapSense_BUTTON8_PTR2DEBOUNCE_OFFSET                (240u)
N#define CapSense_BUTTON8_PTR2DEBOUNCE_SIZE                  (4u)
N#define CapSense_BUTTON8_PTR2DEBOUNCE_PARAM_ID              (0xD10800F0u)
N
N#define CapSense_BUTTON8_STATIC_CONFIG_VALUE                (CapSense_dsFlash.wdgtArray[8].staticConfig)
N#define CapSense_BUTTON8_STATIC_CONFIG_OFFSET               (244u)
N#define CapSense_BUTTON8_STATIC_CONFIG_SIZE                 (4u)
N#define CapSense_BUTTON8_STATIC_CONFIG_PARAM_ID             (0xD00800F4u)
N
N#define CapSense_BUTTON8_TOTAL_NUM_SNS_VALUE                (CapSense_dsFlash.wdgtArray[8].totalNumSns)
N#define CapSense_BUTTON8_TOTAL_NUM_SNS_OFFSET               (248u)
N#define CapSense_BUTTON8_TOTAL_NUM_SNS_SIZE                 (2u)
N#define CapSense_BUTTON8_TOTAL_NUM_SNS_PARAM_ID             (0x9C0800F8u)
N
N#define CapSense_BUTTON8_TYPE_VALUE                         (CapSense_dsFlash.wdgtArray[8].wdgtType)
N#define CapSense_BUTTON8_TYPE_OFFSET                        (250u)
N#define CapSense_BUTTON8_TYPE_SIZE                          (1u)
N#define CapSense_BUTTON8_TYPE_PARAM_ID                      (0x580800FAu)
N
N#define CapSense_BUTTON8_NUM_COLS_VALUE                     (CapSense_dsFlash.wdgtArray[8].numCols)
N#define CapSense_BUTTON8_NUM_COLS_OFFSET                    (251u)
N#define CapSense_BUTTON8_NUM_COLS_SIZE                      (1u)
N#define CapSense_BUTTON8_NUM_COLS_PARAM_ID                  (0x5E0800FBu)
N
N#define CapSense_BUTTON9_PTR2SNS_FLASH_VALUE                (CapSense_dsFlash.wdgtArray[9].ptr2SnsFlash)
N#define CapSense_BUTTON9_PTR2SNS_FLASH_OFFSET               (252u)
N#define CapSense_BUTTON9_PTR2SNS_FLASH_SIZE                 (4u)
N#define CapSense_BUTTON9_PTR2SNS_FLASH_PARAM_ID             (0xD10900FCu)
N
N#define CapSense_BUTTON9_PTR2WD_RAM_VALUE                   (CapSense_dsFlash.wdgtArray[9].ptr2WdgtRam)
N#define CapSense_BUTTON9_PTR2WD_RAM_OFFSET                  (256u)
N#define CapSense_BUTTON9_PTR2WD_RAM_SIZE                    (4u)
N#define CapSense_BUTTON9_PTR2WD_RAM_PARAM_ID                (0xD8090100u)
N
N#define CapSense_BUTTON9_PTR2SNS_RAM_VALUE                  (CapSense_dsFlash.wdgtArray[9].ptr2SnsRam)
N#define CapSense_BUTTON9_PTR2SNS_RAM_OFFSET                 (260u)
N#define CapSense_BUTTON9_PTR2SNS_RAM_SIZE                   (4u)
N#define CapSense_BUTTON9_PTR2SNS_RAM_PARAM_ID               (0xD9090104u)
N
N#define CapSense_BUTTON9_PTR2FLTR_HISTORY_VALUE             (CapSense_dsFlash.wdgtArray[9].ptr2FltrHistory)
N#define CapSense_BUTTON9_PTR2FLTR_HISTORY_OFFSET            (264u)
N#define CapSense_BUTTON9_PTR2FLTR_HISTORY_SIZE              (4u)
N#define CapSense_BUTTON9_PTR2FLTR_HISTORY_PARAM_ID          (0xDA090108u)
N
N#define CapSense_BUTTON9_PTR2DEBOUNCE_VALUE                 (CapSense_dsFlash.wdgtArray[9].ptr2DebounceArr)
N#define CapSense_BUTTON9_PTR2DEBOUNCE_OFFSET                (268u)
N#define CapSense_BUTTON9_PTR2DEBOUNCE_SIZE                  (4u)
N#define CapSense_BUTTON9_PTR2DEBOUNCE_PARAM_ID              (0xDB09010Cu)
N
N#define CapSense_BUTTON9_STATIC_CONFIG_VALUE                (CapSense_dsFlash.wdgtArray[9].staticConfig)
N#define CapSense_BUTTON9_STATIC_CONFIG_OFFSET               (272u)
N#define CapSense_BUTTON9_STATIC_CONFIG_SIZE                 (4u)
N#define CapSense_BUTTON9_STATIC_CONFIG_PARAM_ID             (0xDD090110u)
N
N#define CapSense_BUTTON9_TOTAL_NUM_SNS_VALUE                (CapSense_dsFlash.wdgtArray[9].totalNumSns)
N#define CapSense_BUTTON9_TOTAL_NUM_SNS_OFFSET               (276u)
N#define CapSense_BUTTON9_TOTAL_NUM_SNS_SIZE                 (2u)
N#define CapSense_BUTTON9_TOTAL_NUM_SNS_PARAM_ID             (0x93090114u)
N
N#define CapSense_BUTTON9_TYPE_VALUE                         (CapSense_dsFlash.wdgtArray[9].wdgtType)
N#define CapSense_BUTTON9_TYPE_OFFSET                        (278u)
N#define CapSense_BUTTON9_TYPE_SIZE                          (1u)
N#define CapSense_BUTTON9_TYPE_PARAM_ID                      (0x57090116u)
N
N#define CapSense_BUTTON9_NUM_COLS_VALUE                     (CapSense_dsFlash.wdgtArray[9].numCols)
N#define CapSense_BUTTON9_NUM_COLS_OFFSET                    (279u)
N#define CapSense_BUTTON9_NUM_COLS_SIZE                      (1u)
N#define CapSense_BUTTON9_NUM_COLS_PARAM_ID                  (0x51090117u)
N
N#define CapSense_BUTTON10_PTR2SNS_FLASH_VALUE               (CapSense_dsFlash.wdgtArray[10].ptr2SnsFlash)
N#define CapSense_BUTTON10_PTR2SNS_FLASH_OFFSET              (280u)
N#define CapSense_BUTTON10_PTR2SNS_FLASH_SIZE                (4u)
N#define CapSense_BUTTON10_PTR2SNS_FLASH_PARAM_ID            (0xDA0A0118u)
N
N#define CapSense_BUTTON10_PTR2WD_RAM_VALUE                  (CapSense_dsFlash.wdgtArray[10].ptr2WdgtRam)
N#define CapSense_BUTTON10_PTR2WD_RAM_OFFSET                 (284u)
N#define CapSense_BUTTON10_PTR2WD_RAM_SIZE                   (4u)
N#define CapSense_BUTTON10_PTR2WD_RAM_PARAM_ID               (0xDB0A011Cu)
N
N#define CapSense_BUTTON10_PTR2SNS_RAM_VALUE                 (CapSense_dsFlash.wdgtArray[10].ptr2SnsRam)
N#define CapSense_BUTTON10_PTR2SNS_RAM_OFFSET                (288u)
N#define CapSense_BUTTON10_PTR2SNS_RAM_SIZE                  (4u)
N#define CapSense_BUTTON10_PTR2SNS_RAM_PARAM_ID              (0xD70A0120u)
N
N#define CapSense_BUTTON10_PTR2FLTR_HISTORY_VALUE            (CapSense_dsFlash.wdgtArray[10].ptr2FltrHistory)
N#define CapSense_BUTTON10_PTR2FLTR_HISTORY_OFFSET           (292u)
N#define CapSense_BUTTON10_PTR2FLTR_HISTORY_SIZE             (4u)
N#define CapSense_BUTTON10_PTR2FLTR_HISTORY_PARAM_ID         (0xD60A0124u)
N
N#define CapSense_BUTTON10_PTR2DEBOUNCE_VALUE                (CapSense_dsFlash.wdgtArray[10].ptr2DebounceArr)
N#define CapSense_BUTTON10_PTR2DEBOUNCE_OFFSET               (296u)
N#define CapSense_BUTTON10_PTR2DEBOUNCE_SIZE                 (4u)
N#define CapSense_BUTTON10_PTR2DEBOUNCE_PARAM_ID             (0xD50A0128u)
N
N#define CapSense_BUTTON10_STATIC_CONFIG_VALUE               (CapSense_dsFlash.wdgtArray[10].staticConfig)
N#define CapSense_BUTTON10_STATIC_CONFIG_OFFSET              (300u)
N#define CapSense_BUTTON10_STATIC_CONFIG_SIZE                (4u)
N#define CapSense_BUTTON10_STATIC_CONFIG_PARAM_ID            (0xD40A012Cu)
N
N#define CapSense_BUTTON10_TOTAL_NUM_SNS_VALUE               (CapSense_dsFlash.wdgtArray[10].totalNumSns)
N#define CapSense_BUTTON10_TOTAL_NUM_SNS_OFFSET              (304u)
N#define CapSense_BUTTON10_TOTAL_NUM_SNS_SIZE                (2u)
N#define CapSense_BUTTON10_TOTAL_NUM_SNS_PARAM_ID            (0x9D0A0130u)
N
N#define CapSense_BUTTON10_TYPE_VALUE                        (CapSense_dsFlash.wdgtArray[10].wdgtType)
N#define CapSense_BUTTON10_TYPE_OFFSET                       (306u)
N#define CapSense_BUTTON10_TYPE_SIZE                         (1u)
N#define CapSense_BUTTON10_TYPE_PARAM_ID                     (0x590A0132u)
N
N#define CapSense_BUTTON10_NUM_COLS_VALUE                    (CapSense_dsFlash.wdgtArray[10].numCols)
N#define CapSense_BUTTON10_NUM_COLS_OFFSET                   (307u)
N#define CapSense_BUTTON10_NUM_COLS_SIZE                     (1u)
N#define CapSense_BUTTON10_NUM_COLS_PARAM_ID                 (0x5F0A0133u)
N
N#define CapSense_BUTTON11_PTR2SNS_FLASH_VALUE               (CapSense_dsFlash.wdgtArray[11].ptr2SnsFlash)
N#define CapSense_BUTTON11_PTR2SNS_FLASH_OFFSET              (308u)
N#define CapSense_BUTTON11_PTR2SNS_FLASH_SIZE                (4u)
N#define CapSense_BUTTON11_PTR2SNS_FLASH_PARAM_ID            (0xD00B0134u)
N
N#define CapSense_BUTTON11_PTR2WD_RAM_VALUE                  (CapSense_dsFlash.wdgtArray[11].ptr2WdgtRam)
N#define CapSense_BUTTON11_PTR2WD_RAM_OFFSET                 (312u)
N#define CapSense_BUTTON11_PTR2WD_RAM_SIZE                   (4u)
N#define CapSense_BUTTON11_PTR2WD_RAM_PARAM_ID               (0xD30B0138u)
N
N#define CapSense_BUTTON11_PTR2SNS_RAM_VALUE                 (CapSense_dsFlash.wdgtArray[11].ptr2SnsRam)
N#define CapSense_BUTTON11_PTR2SNS_RAM_OFFSET                (316u)
N#define CapSense_BUTTON11_PTR2SNS_RAM_SIZE                  (4u)
N#define CapSense_BUTTON11_PTR2SNS_RAM_PARAM_ID              (0xD20B013Cu)
N
N#define CapSense_BUTTON11_PTR2FLTR_HISTORY_VALUE            (CapSense_dsFlash.wdgtArray[11].ptr2FltrHistory)
N#define CapSense_BUTTON11_PTR2FLTR_HISTORY_OFFSET           (320u)
N#define CapSense_BUTTON11_PTR2FLTR_HISTORY_SIZE             (4u)
N#define CapSense_BUTTON11_PTR2FLTR_HISTORY_PARAM_ID         (0xD30B0140u)
N
N#define CapSense_BUTTON11_PTR2DEBOUNCE_VALUE                (CapSense_dsFlash.wdgtArray[11].ptr2DebounceArr)
N#define CapSense_BUTTON11_PTR2DEBOUNCE_OFFSET               (324u)
N#define CapSense_BUTTON11_PTR2DEBOUNCE_SIZE                 (4u)
N#define CapSense_BUTTON11_PTR2DEBOUNCE_PARAM_ID             (0xD20B0144u)
N
N#define CapSense_BUTTON11_STATIC_CONFIG_VALUE               (CapSense_dsFlash.wdgtArray[11].staticConfig)
N#define CapSense_BUTTON11_STATIC_CONFIG_OFFSET              (328u)
N#define CapSense_BUTTON11_STATIC_CONFIG_SIZE                (4u)
N#define CapSense_BUTTON11_STATIC_CONFIG_PARAM_ID            (0xD10B0148u)
N
N#define CapSense_BUTTON11_TOTAL_NUM_SNS_VALUE               (CapSense_dsFlash.wdgtArray[11].totalNumSns)
N#define CapSense_BUTTON11_TOTAL_NUM_SNS_OFFSET              (332u)
N#define CapSense_BUTTON11_TOTAL_NUM_SNS_SIZE                (2u)
N#define CapSense_BUTTON11_TOTAL_NUM_SNS_PARAM_ID            (0x9F0B014Cu)
N
N#define CapSense_BUTTON11_TYPE_VALUE                        (CapSense_dsFlash.wdgtArray[11].wdgtType)
N#define CapSense_BUTTON11_TYPE_OFFSET                       (334u)
N#define CapSense_BUTTON11_TYPE_SIZE                         (1u)
N#define CapSense_BUTTON11_TYPE_PARAM_ID                     (0x5B0B014Eu)
N
N#define CapSense_BUTTON11_NUM_COLS_VALUE                    (CapSense_dsFlash.wdgtArray[11].numCols)
N#define CapSense_BUTTON11_NUM_COLS_OFFSET                   (335u)
N#define CapSense_BUTTON11_NUM_COLS_SIZE                     (1u)
N#define CapSense_BUTTON11_NUM_COLS_PARAM_ID                 (0x5D0B014Fu)
N
N#define CapSense_PROXIMITY0_PTR2SNS_FLASH_VALUE             (CapSense_dsFlash.wdgtArray[12].ptr2SnsFlash)
N#define CapSense_PROXIMITY0_PTR2SNS_FLASH_OFFSET            (336u)
N#define CapSense_PROXIMITY0_PTR2SNS_FLASH_SIZE              (4u)
N#define CapSense_PROXIMITY0_PTR2SNS_FLASH_PARAM_ID          (0xDF0C0150u)
N
N#define CapSense_PROXIMITY0_PTR2WD_RAM_VALUE                (CapSense_dsFlash.wdgtArray[12].ptr2WdgtRam)
N#define CapSense_PROXIMITY0_PTR2WD_RAM_OFFSET               (340u)
N#define CapSense_PROXIMITY0_PTR2WD_RAM_SIZE                 (4u)
N#define CapSense_PROXIMITY0_PTR2WD_RAM_PARAM_ID             (0xDE0C0154u)
N
N#define CapSense_PROXIMITY0_PTR2SNS_RAM_VALUE               (CapSense_dsFlash.wdgtArray[12].ptr2SnsRam)
N#define CapSense_PROXIMITY0_PTR2SNS_RAM_OFFSET              (344u)
N#define CapSense_PROXIMITY0_PTR2SNS_RAM_SIZE                (4u)
N#define CapSense_PROXIMITY0_PTR2SNS_RAM_PARAM_ID            (0xDD0C0158u)
N
N#define CapSense_PROXIMITY0_PTR2FLTR_HISTORY_VALUE          (CapSense_dsFlash.wdgtArray[12].ptr2FltrHistory)
N#define CapSense_PROXIMITY0_PTR2FLTR_HISTORY_OFFSET         (348u)
N#define CapSense_PROXIMITY0_PTR2FLTR_HISTORY_SIZE           (4u)
N#define CapSense_PROXIMITY0_PTR2FLTR_HISTORY_PARAM_ID       (0xDC0C015Cu)
N
N#define CapSense_PROXIMITY0_PTR2DEBOUNCE_VALUE              (CapSense_dsFlash.wdgtArray[12].ptr2DebounceArr)
N#define CapSense_PROXIMITY0_PTR2DEBOUNCE_OFFSET             (352u)
N#define CapSense_PROXIMITY0_PTR2DEBOUNCE_SIZE               (4u)
N#define CapSense_PROXIMITY0_PTR2DEBOUNCE_PARAM_ID           (0xD00C0160u)
N
N#define CapSense_PROXIMITY0_STATIC_CONFIG_VALUE             (CapSense_dsFlash.wdgtArray[12].staticConfig)
N#define CapSense_PROXIMITY0_STATIC_CONFIG_OFFSET            (356u)
N#define CapSense_PROXIMITY0_STATIC_CONFIG_SIZE              (4u)
N#define CapSense_PROXIMITY0_STATIC_CONFIG_PARAM_ID          (0xD10C0164u)
N
N#define CapSense_PROXIMITY0_TOTAL_NUM_SNS_VALUE             (CapSense_dsFlash.wdgtArray[12].totalNumSns)
N#define CapSense_PROXIMITY0_TOTAL_NUM_SNS_OFFSET            (360u)
N#define CapSense_PROXIMITY0_TOTAL_NUM_SNS_SIZE              (2u)
N#define CapSense_PROXIMITY0_TOTAL_NUM_SNS_PARAM_ID          (0x9D0C0168u)
N
N#define CapSense_PROXIMITY0_TYPE_VALUE                      (CapSense_dsFlash.wdgtArray[12].wdgtType)
N#define CapSense_PROXIMITY0_TYPE_OFFSET                     (362u)
N#define CapSense_PROXIMITY0_TYPE_SIZE                       (1u)
N#define CapSense_PROXIMITY0_TYPE_PARAM_ID                   (0x590C016Au)
N
N#define CapSense_PROXIMITY0_NUM_COLS_VALUE                  (CapSense_dsFlash.wdgtArray[12].numCols)
N#define CapSense_PROXIMITY0_NUM_COLS_OFFSET                 (363u)
N#define CapSense_PROXIMITY0_NUM_COLS_SIZE                   (1u)
N#define CapSense_PROXIMITY0_NUM_COLS_PARAM_ID               (0x5F0C016Bu)
N
N#define CapSense_PROXIMITY0_SNS0_FIRST_PIN_ID_VALUE         (CapSense_dsFlash.eltdList..proximity0_sns0.firstPinId)
N#define CapSense_PROXIMITY0_SNS0_FIRST_PIN_ID_OFFSET        (364u)
N#define CapSense_PROXIMITY0_SNS0_FIRST_PIN_ID_SIZE          (2u)
N#define CapSense_PROXIMITY0_SNS0_FIRST_PIN_ID_PARAM_ID      (0x9100016Cu)
N
N#define CapSense_PROXIMITY0_SNS0_NUM_PINS_VALUE             (CapSense_dsFlash.eltdList..proximity0_sns0.numPins)
N#define CapSense_PROXIMITY0_SNS0_NUM_PINS_OFFSET            (366u)
N#define CapSense_PROXIMITY0_SNS0_NUM_PINS_SIZE              (1u)
N#define CapSense_PROXIMITY0_SNS0_NUM_PINS_PARAM_ID          (0x5500016Eu)
N
N#define CapSense_PROXIMITY0_SNS0_TYPE_VALUE                 (CapSense_dsFlash.eltdList..proximity0_sns0.type)
N#define CapSense_PROXIMITY0_SNS0_TYPE_OFFSET                (367u)
N#define CapSense_PROXIMITY0_SNS0_TYPE_SIZE                  (1u)
N#define CapSense_PROXIMITY0_SNS0_TYPE_PARAM_ID              (0x5300016Fu)
N
N
N#endif /* End CY_SENSE_CapSense_REGISTER_MAP_H */
N
N
N/* [] END OF FILE */
L 71 "Generated_Source\PSoC4\project.h" 2
N#include "BAT_ADC.h"
L 1 "Generated_Source\PSoC4\BAT_ADC.h" 1
N/*******************************************************************************
N* File Name: BAT_ADC.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_BAT_ADC_H) /* Pins BAT_ADC_H */
X#if !0L  
N#define CY_PINS_BAT_ADC_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "BAT_ADC_aliases.h"
L 1 "Generated_Source\PSoC4\BAT_ADC_aliases.h" 1
N/*******************************************************************************
N* File Name: BAT_ADC.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_BAT_ADC_ALIASES_H) /* Pins BAT_ADC_ALIASES_H */
X#if !0L  
N#define CY_PINS_BAT_ADC_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define BAT_ADC_0			(BAT_ADC__0__PC)
N#define BAT_ADC_0_PS		(BAT_ADC__0__PS)
N#define BAT_ADC_0_PC		(BAT_ADC__0__PC)
N#define BAT_ADC_0_DR		(BAT_ADC__0__DR)
N#define BAT_ADC_0_SHIFT	(BAT_ADC__0__SHIFT)
N#define BAT_ADC_0_INTR	((uint16)((uint16)0x0003u << (BAT_ADC__0__SHIFT*2u)))
N
N#define BAT_ADC_INTR_ALL	 ((uint16)(BAT_ADC_0_INTR))
N
N
N#endif /* End Pins BAT_ADC_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\BAT_ADC.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} BAT_ADC_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   BAT_ADC_Read(void);
Nvoid    BAT_ADC_Write(uint8 value);
Nuint8   BAT_ADC_ReadDataReg(void);
N#if defined(BAT_ADC__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    BAT_ADC_SetDriveMode(uint8 mode);
N#endif
Nvoid    BAT_ADC_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   BAT_ADC_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid BAT_ADC_Sleep(void); 
Nvoid BAT_ADC_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(BAT_ADC__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define BAT_ADC_DRIVE_MODE_BITS        (3)
N    #define BAT_ADC_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - BAT_ADC_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the BAT_ADC_SetDriveMode() function.
N         *  @{
N         */
N        #define BAT_ADC_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define BAT_ADC_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define BAT_ADC_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define BAT_ADC_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define BAT_ADC_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define BAT_ADC_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define BAT_ADC_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define BAT_ADC_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define BAT_ADC_MASK               BAT_ADC__MASK
N#define BAT_ADC_SHIFT              BAT_ADC__SHIFT
N#define BAT_ADC_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in BAT_ADC_SetInterruptMode() function.
N     *  @{
N     */
N        #define BAT_ADC_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define BAT_ADC_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define BAT_ADC_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define BAT_ADC_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(BAT_ADC__SIO)
X#if 0L
S    #define BAT_ADC_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(BAT_ADC__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define BAT_ADC_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define BAT_ADC_USBIO_DISABLE              ((uint32)(~BAT_ADC_USBIO_ENABLE))
S    #define BAT_ADC_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define BAT_ADC_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define BAT_ADC_USBIO_ENTER_SLEEP          ((uint32)((1u << BAT_ADC_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << BAT_ADC_USBIO_SUSPEND_DEL_SHIFT)))
X    #define BAT_ADC_USBIO_ENTER_SLEEP          ((uint32)((1u << BAT_ADC_USBIO_SUSPEND_SHIFT)                                                         | (1u << BAT_ADC_USBIO_SUSPEND_DEL_SHIFT)))
S    #define BAT_ADC_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << BAT_ADC_USBIO_SUSPEND_SHIFT)))
S    #define BAT_ADC_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << BAT_ADC_USBIO_SUSPEND_DEL_SHIFT)))
S    #define BAT_ADC_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(BAT_ADC__PC)
X#if 1L
N    /* Port Configuration */
N    #define BAT_ADC_PC                 (* (reg32 *) BAT_ADC__PC)
N#endif
N/* Pin State */
N#define BAT_ADC_PS                     (* (reg32 *) BAT_ADC__PS)
N/* Data Register */
N#define BAT_ADC_DR                     (* (reg32 *) BAT_ADC__DR)
N/* Input Buffer Disable Override */
N#define BAT_ADC_INP_DIS                (* (reg32 *) BAT_ADC__PC2)
N
N/* Interrupt configuration Registers */
N#define BAT_ADC_INTCFG                 (* (reg32 *) BAT_ADC__INTCFG)
N#define BAT_ADC_INTSTAT                (* (reg32 *) BAT_ADC__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define BAT_ADC_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(BAT_ADC__SIO)
X#if 0L
S    #define BAT_ADC_SIO_REG            (* (reg32 *) BAT_ADC__SIO)
N#endif /* (BAT_ADC__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(BAT_ADC__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define BAT_ADC_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define BAT_ADC_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define BAT_ADC_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define BAT_ADC_DRIVE_MODE_SHIFT       (0x00u)
N#define BAT_ADC_DRIVE_MODE_MASK        (0x07u << BAT_ADC_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins BAT_ADC_H */
N
N
N/* [] END OF FILE */
L 72 "Generated_Source\PSoC4\project.h" 2
N#include "BAT_ADC_aliases.h"
L 1 "Generated_Source\PSoC4\BAT_ADC_aliases.h" 1
N/*******************************************************************************
N* File Name: BAT_ADC.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_BAT_ADC_ALIASES_H) /* Pins BAT_ADC_ALIASES_H */
X#if !1L  
S#define CY_PINS_BAT_ADC_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define BAT_ADC_0			(BAT_ADC__0__PC)
S#define BAT_ADC_0_PS		(BAT_ADC__0__PS)
S#define BAT_ADC_0_PC		(BAT_ADC__0__PC)
S#define BAT_ADC_0_DR		(BAT_ADC__0__DR)
S#define BAT_ADC_0_SHIFT	(BAT_ADC__0__SHIFT)
S#define BAT_ADC_0_INTR	((uint16)((uint16)0x0003u << (BAT_ADC__0__SHIFT*2u)))
S
S#define BAT_ADC_INTR_ALL	 ((uint16)(BAT_ADC_0_INTR))
S
S
N#endif /* End Pins BAT_ADC_ALIASES_H */
N
N
N/* [] END OF FILE */
L 73 "Generated_Source\PSoC4\project.h" 2
N#include "ADC.h"
L 1 "Generated_Source\PSoC4\ADC.h" 1
N/*******************************************************************************
N* File Name: ADC.h
N* Version 2.50
N*
N* Description:
N*  This file contains the function prototypes and constants used in
N*  the Sequencing Successive Approximation ADC Component.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2017, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_ADC_SAR_SEQ_ADC_H)
X#if !0L
N#define CY_ADC_SAR_SEQ_ADC_H
N
N#include "cytypes.h"
N#include "CyLib.h"
N
N
N/***************************************
N*      Data Struct Definition
N***************************************/
N
N/* Sleep Mode API Support */
Ntypedef struct
N{
N    uint8 enableState;
N    uint32 dftRegVal;
N} ADC_BACKUP_STRUCT;
N
N
N/**************************************
N*    Enumerated Types and Parameters
N**************************************/
N
N/*  Clock Source setting constants */
N#define ADC__EXTERNAL 0
N#define ADC__INTERNAL 1
N
N/*  Sample Mode setting constants */
N#define ADC__FREERUNNING 0
N#define ADC__HARDWARESOC 1
N
N/*  Reference type setting constants */
N#define ADC__VDDA_2 0
N#define ADC__VDDA 1
N#define ADC__INTERNAL1024 2
N#define ADC__INTERNAL1024BYPASSED 3
N#define ADC__INTERNALVREF 4
N#define ADC__INTERNALVREFBYPASSED 5
N#define ADC__VDDA_2BYPASSED 6
N#define ADC__EXTERNALVREF 7
N
N/* Input buffer gain setting constants */
N#define ADC__DISABLED 0
N#define ADC__ONE 1
N#define ADC__TWO 2
N#define ADC__FOUR 3
N#define ADC__EIGHT 4
N#define ADC__SIXTEEN 5
N
N/* Negative input setting sonstants in single ended mode */
N#define ADC__VSS 0
N#define ADC__VREF 1
N#define ADC__OTHER 2
N
N/* Compare mode setting constants:
N*    Mode0 - Disable
N*    Mode1 - Result < Low_Limit
N*    Mode2 - Low_Limit <= Result < High_Limit
N*    Mode3 - High_Limit <= Result
N*    Mode4 - (Result < Low_Limit) or (High_Limit <= Result)
N*/
N#define ADC__MODE0 0
N#define ADC__MODE1 1
N#define ADC__MODE2 2
N#define ADC__MODE3 3
N
N#define ADC__RES8 0
N#define ADC__RES10 1
N
N#define ADC__RIGHT 0
N#define ADC__LEFT 1
N
N#define ADC__FSIGNED 1
N#define ADC__FUNSIGNED 0
N
N#define ADC__ACCUMULATE 0
N#define ADC__FIXEDRESOLUTION 1
N
N
N
N/***************************************
N*   Conditional Compilation Parameters
N****************************************/ 
N
N#define ADC_CY_SAR_IP_VER0               	(0u)
N#define ADC_CY_SAR_IP_VER1               	(1u)
N
N#if (CY_PSOC4_4100 || CY_PSOC4_4200)
X#if ((16u == 18u) || (16u == 18u))
S    #define ADC_CY_SAR_IP_VER              (ADC_CY_SAR_IP_VER0)
N#else /* Other devices */
N    #define ADC_CY_SAR_IP_VER              (ADC_CY_SAR_IP_VER1)
N#endif  /* (CY_PSOC4_4100 || CY_PSOC4_4200) */
N
N
N/***************************************
N*    Initial Parameter Constants
N***************************************/
N#define ADC_DEFAULT_SAMPLE_MODE_SEL        (1u)
N#define ADC_DEFAULT_VREF_SEL               (4u)
N#define ADC_DEFAULT_NEG_INPUT_SEL          (1u)
N#define ADC_DEFAULT_ALT_RESOLUTION_SEL     (1u)
N#define ADC_DEFAULT_JUSTIFICATION_SEL      (0u)
N#define ADC_DEFAULT_DIFF_RESULT_FORMAT_SEL (0u)
N#define ADC_DEFAULT_SE_RESULT_FORMAT_SEL   (0u)
N#define ADC_DEFAULT_CLOCK_SOURCE           (1u)
N#define ADC_DEFAULT_VREF_MV_VALUE          (1200)
N#define ADC_DEFAULT_BUFFER_GAIN            (0u)
N#define ADC_DEFAULT_AVG_SAMPLES_NUM        (1u)
N#define ADC_DEFAULT_AVG_SAMPLES_DIV        (1u < 4u) ? (int16)(0x100u >> (7u - 1u)) : (int16)(0x100u >> 4u)
N#define ADC_DEFAULT_AVG_MODE               (1u)
N#define ADC_MAX_RESOLUTION                 (12u)
N#define ADC_DEFAULT_LOW_LIMIT              (0u)
N#define ADC_DEFAULT_HIGH_LIMIT             (2047u)
N#define ADC_DEFAULT_COMPARE_MODE           (0u)
N#define ADC_DEFAULT_ACLKS_NUM              (2u)
N#define ADC_DEFAULT_BCLKS_NUM              (2u)
N#define ADC_DEFAULT_CCLKS_NUM              (2u)
N#define ADC_DEFAULT_DCLKS_NUM              (2u)
N#define ADC_TOTAL_CHANNELS_NUM             (3u)
N#define ADC_SEQUENCED_CHANNELS_NUM         (3u)
N#define ADC_DEFAULT_EN_CHANNELS            (7u)
N#define ADC_NOMINAL_CLOCK_FREQ             (1600000)
N#define ADC_INJ_CHANNEL_ENABLED            (0u)
N#define ADC_IRQ_REMOVE                     (0u)
N
N/* Determines whether the configuration contains external negative input. */
N#define ADC_SINGLE_PRESENT                 (0u)
N#define ADC_CHANNELS_MODE                  (0u)
N#define ADC_MAX_CHANNELS_EN_MASK           (0xffffu >> (16u - ADC_SEQUENCED_CHANNELS_NUM))
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
Nvoid ADC_Start(void);
Nvoid ADC_Stop(void);
Nvoid ADC_Init(void);
Nvoid ADC_Enable(void);
Nvoid ADC_StartConvert(void);
Nvoid ADC_StopConvert(void);
Nuint32 ADC_IsEndConversion(uint32 retMode);
Nint16 ADC_GetResult16(uint32 chan);
Nvoid ADC_SetChanMask(uint32 mask);
Nvoid ADC_SetLowLimit(uint32 lowLimit);
Nvoid ADC_SetHighLimit(uint32 highLimit);
Nvoid ADC_SetLimitMask(uint32 mask);
Nvoid ADC_SetSatMask(uint32 mask);
Nvoid ADC_SetOffset(uint32 chan, int16 offset);
Nvoid ADC_SetGain(uint32 chan, int32 adcGain);
N#if(ADC_INJ_CHANNEL_ENABLED)
X#if((0u))
S    void ADC_EnableInjection(void);
N#endif /* ADC_INJ_CHANNEL_ENABLED */
N#if(ADC_DEFAULT_JUSTIFICATION_SEL == ADC__RIGHT)
X#if((0u) == 0)
N    int16 ADC_CountsTo_mVolts(uint32 chan, int16 adcCounts);
N    int32 ADC_CountsTo_uVolts(uint32 chan, int16 adcCounts);
N    float32 ADC_CountsTo_Volts(uint32 chan, int16 adcCounts);
N#endif /* End ADC_DEFAULT_JUSTIFICATION_SEL == ADC__RIGHT */
Nvoid ADC_Sleep(void);
Nvoid ADC_Wakeup(void);
Nvoid ADC_SaveConfig(void);
Nvoid ADC_RestoreConfig(void);
N
NCY_ISR_PROTO( ADC_ISR );
Xvoid ADC_ISR (void);
N
N
N/**************************************
N*           API Constants
N**************************************/
N/* Constants for Sleep mode states */
N#define ADC_DISABLED                   (0x00u)
N#define ADC_ENABLED                    (0x01u)
N#define ADC_STARTED                    (0x02u)
N#define ADC_BOOSTPUMP_ENABLED          (0x04u)
N
N/*   Constants for IsEndConversion() "retMode" parameter  */
N#define ADC_RETURN_STATUS              (0x01u)
N#define ADC_WAIT_FOR_RESULT            (0x02u)
N#define ADC_RETURN_STATUS_INJ          (0x04u)
N#define ADC_WAIT_FOR_RESULT_INJ        (0x08u)
N
N#define ADC_MAX_FREQUENCY              (18000000)       /*18Mhz*/
N
N#define ADC_RESOLUTION_12              (12u)
N#define ADC_RESOLUTION_10              (10u)
N#define ADC_RESOLUTION_8               (8u)
N
N#define ADC_10US_DELAY                 (10u)
N
N#define ADC_10V_COUNTS                 (10.0F)
N#define ADC_10MV_COUNTS                (10000)
N#define ADC_10UV_COUNTS                (10000000L)
N
N
N/***************************************
N* Global variables external identifier
N***************************************/
N
Nextern uint8 ADC_initVar;
Nextern volatile int16 ADC_offset[ADC_TOTAL_CHANNELS_NUM];
Xextern volatile int16 ADC_offset[(3u)];
Nextern volatile int32 ADC_countsPer10Volt[ADC_TOTAL_CHANNELS_NUM];
Xextern volatile int32 ADC_countsPer10Volt[(3u)];
N
N
N/***************************************
N*              Registers
N***************************************/
N
N#define ADC_SAR_CTRL_REG                (*(reg32 *) ADC_cy_psoc4_sar__SAR_CTRL )
N#define ADC_SAR_CTRL_PTR                ( (reg32 *) ADC_cy_psoc4_sar__SAR_CTRL )
N
N#define ADC_SAR_SAMPLE_CTRL_REG         (*(reg32 *) ADC_cy_psoc4_sar__SAR_SAMPLE_CTRL )
N#define ADC_SAR_SAMPLE_CTRL_PTR         ( (reg32 *) ADC_cy_psoc4_sar__SAR_SAMPLE_CTRL )
N
N#define ADC_SAR_SAMPLE_TIME01_REG       (*(reg32 *) ADC_cy_psoc4_sar__SAR_SAMPLE_TIME01 )
N#define ADC_SAR_SAMPLE_TIME01_PTR       ( (reg32 *) ADC_cy_psoc4_sar__SAR_SAMPLE_TIME01 )
N
N#define ADC_SAR_SAMPLE_TIME23_REG       (*(reg32 *) ADC_cy_psoc4_sar__SAR_SAMPLE_TIME23 )
N#define ADC_SAR_SAMPLE_TIME23_PTR       ( (reg32 *) ADC_cy_psoc4_sar__SAR_SAMPLE_TIME23 )
N
N#define ADC_SAR_RANGE_THRES_REG         (*(reg32 *) ADC_cy_psoc4_sar__SAR_RANGE_THRES )
N#define ADC_SAR_RANGE_THRES_PTR         ( (reg32 *) ADC_cy_psoc4_sar__SAR_RANGE_THRES )
N
N#define ADC_SAR_RANGE_COND_REG          (*(reg32 *) ADC_cy_psoc4_sar__SAR_RANGE_COND )
N#define ADC_SAR_RANGE_COND_PTR          ( (reg32 *) ADC_cy_psoc4_sar__SAR_RANGE_COND )
N
N#define ADC_SAR_CHAN_EN_REG             (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_EN )
N#define ADC_SAR_CHAN_EN_PTR             ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_EN )
N
N#define ADC_SAR_START_CTRL_REG          (*(reg32 *) ADC_cy_psoc4_sar__SAR_START_CTRL )
N#define ADC_SAR_START_CTRL_PTR          ( (reg32 *) ADC_cy_psoc4_sar__SAR_START_CTRL )
N
N#define ADC_SAR_DFT_CTRL_REG            (*(reg32 *) ADC_cy_psoc4_sar__SAR_DFT_CTRL )
N#define ADC_SAR_DFT_CTRL_PTR            ( (reg32 *) ADC_cy_psoc4_sar__SAR_DFT_CTRL )
N
N#define ADC_SAR_CHAN_CONFIG_REG         (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_CONFIG00 )
N#define ADC_SAR_CHAN_CONFIG_PTR         ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_CONFIG00 )
N#define ADC_SAR_CHAN_CONFIG_IND         ADC_cy_psoc4_sar__SAR_CHAN_CONFIG00
N
N#define ADC_SAR_CHAN_WORK_REG           (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_WORK00 )
N#define ADC_SAR_CHAN_WORK_PTR           ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_WORK00 )
N
N#define ADC_SAR_CHAN_RESULT_REG         (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT00 )
N#define ADC_SAR_CHAN_RESULT_PTR         ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT00 )
N#define ADC_SAR_CHAN_RESULT_IND         ADC_cy_psoc4_sar__SAR_CHAN_RESULT00
N
N#define ADC_SAR_CHAN0_RESULT_REG         (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT00 )
N#define ADC_SAR_CHAN0_RESULT_PTR         ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT00 )
N
N#define ADC_SAR_CHAN1_RESULT_REG         (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT01 )
N#define ADC_SAR_CHAN1_RESULT_PTR         ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT01 )
N
N#define ADC_SAR_CHAN2_RESULT_REG         (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT02 )
N#define ADC_SAR_CHAN2_RESULT_PTR         ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT02 )
N
N#define ADC_SAR_CHAN3_RESULT_REG         (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT03 )
N#define ADC_SAR_CHAN3_RESULT_PTR         ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT03 )
N
N#define ADC_SAR_CHAN4_RESULT_REG         (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT04 )
N#define ADC_SAR_CHAN4_RESULT_PTR         ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT04 )
N
N#define ADC_SAR_CHAN5_RESULT_REG         (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT05 )
N#define ADC_SAR_CHAN5_RESULT_PTR         ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT05 )
N
N#define ADC_SAR_CHAN6_RESULT_REG         (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT06 )
N#define ADC_SAR_CHAN6_RESULT_PTR         ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT06 )
N
N#define ADC_SAR_CHAN7_RESULT_REG         (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT07 )
N#define ADC_SAR_CHAN7_RESULT_PTR         ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT07 )
N
N#if(ADC_CY_SAR_IP_VER != ADC_CY_SAR_IP_VER0)
X#if(((1u)) != (0u))
N    #define ADC_SAR_CHAN8_RESULT_REG     (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT08 )
N    #define ADC_SAR_CHAN8_RESULT_PTR     ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT08 )
N
N    #define ADC_SAR_CHAN9_RESULT_REG     (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT09 )
N    #define ADC_SAR_CHAN9_RESULT_PTR     ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT09 )
N
N    #define ADC_SAR_CHAN10_RESULT_REG    (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT10 )
N    #define ADC_SAR_CHAN10_RESULT_PTR    ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT10 )
N
N    #define ADC_SAR_CHAN11_RESULT_REG    (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT11 )
N    #define ADC_SAR_CHAN11_RESULT_PTR    ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT11 )
N
N    #define ADC_SAR_CHAN12_RESULT_REG    (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT12 )
N    #define ADC_SAR_CHAN12_RESULT_PTR    ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT12 )
N
N    #define ADC_SAR_CHAN13_RESULT_REG    (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT13 )
N    #define ADC_SAR_CHAN13_RESULT_PTR    ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT13 )
N
N    #define ADC_SAR_CHAN14_RESULT_REG    (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT14 )
N    #define ADC_SAR_CHAN14_RESULT_PTR    ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT14 )
N
N    #define ADC_SAR_CHAN15_RESULT_REG    (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT15 )
N    #define ADC_SAR_CHAN15_RESULT_PTR    ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT15 )
N#endif /* (ADC_CY_SAR_IP_VER != ADC_CY_SAR_IP_VER0) */
N
N#define ADC_SAR_CHAN_WORK_VALID_REG     (*(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_WORK_VALID)
N#define ADC_SAR_CHAN_WORK_VALID_PTR     ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_WORK_VALID)
N
N#define ADC_SAR_CHAN_RESULT_VALID_REG  ( *(reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT_VALID )
N#define ADC_SAR_CHAN_RESULT_VALID_PTR  ( (reg32 *) ADC_cy_psoc4_sar__SAR_CHAN_RESULT_VALID )
N
N#define ADC_SAR_STATUS_REG              (*(reg32 *) ADC_cy_psoc4_sar__SAR_STATUS )
N#define ADC_SAR_STATUS_PTR              ( (reg32 *) ADC_cy_psoc4_sar__SAR_STATUS )
N
N#define ADC_SAR_AVG_START_REG           (*(reg32 *) ADC_cy_psoc4_sar__SAR_AVG_STAT )
N#define ADC_SAR_AVG_START_PTR           ( (reg32 *) ADC_cy_psoc4_sar__SAR_AVG_STAT )
N
N#define ADC_SAR_INTR_REG                (*(reg32 *) ADC_cy_psoc4_sar__SAR_INTR )
N#define ADC_SAR_INTR_PTR                ( (reg32 *) ADC_cy_psoc4_sar__SAR_INTR )
N
N#define ADC_SAR_INTR_SET_REG            (*(reg32 *) ADC_cy_psoc4_sar__SAR_INTR_SET )
N#define ADC_SAR_INTR_SET_PTR            ( (reg32 *) ADC_cy_psoc4_sar__SAR_INTR_SET )
N
N#define ADC_SAR_INTR_MASK_REG           (*(reg32 *) ADC_cy_psoc4_sar__SAR_INTR_MASK )
N#define ADC_SAR_INTR_MASK_PTR           ( (reg32 *) ADC_cy_psoc4_sar__SAR_INTR_MASK )
N
N#define ADC_SAR_INTR_MASKED_REG         (*(reg32 *) ADC_cy_psoc4_sar__SAR_INTR_MASKED )
N#define ADC_SAR_INTR_MASKED_PTR         ( (reg32 *) ADC_cy_psoc4_sar__SAR_INTR_MASKED )
N
N#define ADC_SAR_SATURATE_INTR_REG       (*(reg32 *) ADC_cy_psoc4_sar__SAR_SATURATE_INTR )
N#define ADC_SAR_SATURATE_INTR_PTR       ( (reg32 *) ADC_cy_psoc4_sar__SAR_SATURATE_INTR )
N
N#define ADC_SAR_SATURATE_INTR_SET_REG   (*(reg32 *) ADC_cy_psoc4_sar__SAR_SATURATE_INTR_SET )
N#define ADC_SAR_SATURATE_INTR_SET_PTR   ( (reg32 *) ADC_cy_psoc4_sar__SAR_SATURATE_INTR_SET )
N
N#define ADC_SAR_SATURATE_INTR_MASK_REG (*(reg32 *) ADC_cy_psoc4_sar__SAR_SATURATE_INTR_MASK )
N#define ADC_SAR_SATURATE_INTR_MASK_PTR ( (reg32 *) ADC_cy_psoc4_sar__SAR_SATURATE_INTR_MASK )
N
N#define ADC_SAR_SATURATE_INTR_MASKED_REG \
N                                                 (*(reg32 *) ADC_cy_psoc4_sar__SAR_SATURATE_INTR_MASKED )
X#define ADC_SAR_SATURATE_INTR_MASKED_REG                                                  (*(reg32 *) ADC_cy_psoc4_sar__SAR_SATURATE_INTR_MASKED )
N#define ADC_SAR_SATURATE_INTR_MASKED_PTR \
N                                                 ( (reg32 *) ADC_cy_psoc4_sar__SAR_SATURATE_INTR_MASKED )
X#define ADC_SAR_SATURATE_INTR_MASKED_PTR                                                  ( (reg32 *) ADC_cy_psoc4_sar__SAR_SATURATE_INTR_MASKED )
N
N#define ADC_SAR_RANGE_INTR_REG          (*(reg32 *) ADC_cy_psoc4_sar__SAR_RANGE_INTR )
N#define ADC_SAR_RANGE_INTR_PTR          ( (reg32 *) ADC_cy_psoc4_sar__SAR_RANGE_INTR )
N
N#define ADC_SAR_RANGE_INTR_SET_REG      (*(reg32 *) ADC_cy_psoc4_sar__SAR_RANGE_INTR_SET )
N#define ADC_SAR_RANGE_INTR_SET_PTR      ( (reg32 *) ADC_cy_psoc4_sar__SAR_RANGE_INTR_SET )
N
N#define ADC_SAR_RANGE_INTR_MASK_REG     (*(reg32 *) ADC_cy_psoc4_sar__SAR_RANGE_INTR_MASK )
N#define ADC_SAR_RANGE_INTR_MASK_PTR     ( (reg32 *) ADC_cy_psoc4_sar__SAR_RANGE_INTR_MASK )
N
N#define ADC_SAR_RANGE_INTR_MASKED_REG   (*(reg32 *) ADC_cy_psoc4_sar__SAR_RANGE_INTR_MASKED )
N#define ADC_SAR_RANGE_INTR_MASKED_PTR   ( (reg32 *) ADC_cy_psoc4_sar__SAR_RANGE_INTR_MASKED )
N
N#define ADC_SAR_INTR_CAUSE_REG          (*(reg32 *) ADC_cy_psoc4_sar__SAR_INTR_CAUSE )
N#define ADC_SAR_INTR_CAUSE_PTR          ( (reg32 *) ADC_cy_psoc4_sar__SAR_INTR_CAUSE )
N
N#if(ADC_INJ_CHANNEL_ENABLED)
X#if((0u))
S    #define ADC_SAR_INJ_CHAN_CONFIG_REG \
S                                                 (*(reg32 *) ADC_cy_psoc4_sarmux_8__SAR_INJ_CHAN_CONFIG )
X    #define ADC_SAR_INJ_CHAN_CONFIG_REG                                                  (*(reg32 *) ADC_cy_psoc4_sarmux_8__SAR_INJ_CHAN_CONFIG )
S    #define ADC_SAR_INJ_CHAN_CONFIG_PTR    \
S                                                 ( (reg32 *) ADC_cy_psoc4_sarmux_8__SAR_INJ_CHAN_CONFIG )
X    #define ADC_SAR_INJ_CHAN_CONFIG_PTR                                                     ( (reg32 *) ADC_cy_psoc4_sarmux_8__SAR_INJ_CHAN_CONFIG )
S
S    #define ADC_SAR_INJ_RESULT_REG    (*(reg32 *) ADC_cy_psoc4_sarmux_8__SAR_INJ_RESULT )
S    #define ADC_SAR_INJ_RESULT_PTR    ( (reg32 *) ADC_cy_psoc4_sarmux_8__SAR_INJ_RESULT )
N#endif /* ADC_INJ_CHANNEL_ENABLED */
N    
N#define ADC_MUX_SWITCH0_REG           (*(reg32 *)  ADC_cy_psoc4_sar__SAR_MUX_SWITCH0 )
N#define ADC_MUX_SWITCH0_PTR           ( (reg32 *)  ADC_cy_psoc4_sar__SAR_MUX_SWITCH0 )
N
N#define ADC_MUX_SWITCH_HW_CTRL_REG    (*(reg32 *)  ADC_cy_psoc4_sar__SAR_MUX_SWITCH_HW_CTRL )
N#define ADC_MUX_SWITCH_HW_CTRL_PTR    ( (reg32 *)  ADC_cy_psoc4_sar__SAR_MUX_SWITCH_HW_CTRL )
N
N#define ADC_PUMP_CTRL_REG             (*(reg32 *)  ADC_cy_psoc4_sar__SAR_PUMP_CTRL )
N#define ADC_PUMP_CTRL_PTR             ( (reg32 *)  ADC_cy_psoc4_sar__SAR_PUMP_CTRL )
N
N#define ADC_ANA_TRIM_REG              (*(reg32 *)  ADC_cy_psoc4_sar__SAR_ANA_TRIM )
N#define ADC_ANA_TRIM_PTR              ( (reg32 *)  ADC_cy_psoc4_sar__SAR_ANA_TRIM )
N
N#define ADC_WOUNDING_REG              (*(reg32 *)  ADC_cy_psoc4_sar__SAR_WOUNDING )
N#define ADC_WOUNDING_PTR              ( (reg32 *)  ADC_cy_psoc4_sar__SAR_WOUNDING )
N
N
N/**************************************
N*       Register Constants
N**************************************/
N#define ADC_INTC_NUMBER                (ADC_IRQ__INTC_NUMBER)
N#define ADC_INTC_PRIOR_NUMBER          (ADC_IRQ__INTC_PRIOR_NUM)
N
N/* defines for CTRL register */
N#define ADC_VREF_INTERNAL1024          (0x00000040Lu)
N#define ADC_VREF_EXTERNAL              (0x00000050Lu)
N#define ADC_VREF_VDDA_2                (0x00000060Lu)
N#define ADC_VREF_VDDA                  (0x00000070Lu)
N#define ADC_VREF_INTERNAL1024BYPASSED  (0x000000C0Lu)
N#define ADC_VREF_VDDA_2BYPASSED        (0x000000E0Lu)
N#define ADC_VREF_INTERNALVREF          (0x00000040Lu)
N#define ADC_VREF_INTERNALVREFBYPASSED  (0x000000C0Lu)
N
N#define ADC_NEG_VSSA_KELVIN            (0x00000000Lu)
N#define ADC_NEG_VSSA                   (0x00000200Lu)
N#define ADC_NEG_VREF                   (0x00000E00Lu)
N#if(ADC_TOTAL_CHANNELS_NUM > 1u)
X#if((3u) > 1u)
N    #define ADC_NEG_OTHER              (uint16)((uint16)ADC_cy_psoc4_sarmux_8__VNEG0 << 9u)
N#else
S    #define ADC_NEG_OTHER              (0)
N#endif /* ADC_TOTAL_CHANNELS_NUM > 1u */
N
N#define ADC_SAR_HW_CTRL_NEGVREF        (0x00002000Lu)
N
N#define ADC_BOOSTPUMP_EN               (0x00100000Lu)
N
N#define ADC_NORMAL_PWR                 (0x00000000Lu)
N#define ADC_HALF_PWR                   (0x01000000Lu)
N#define ADC_MORE_PWR                   (0x02000000Lu)
N#define ADC_QUARTER_PWR                (0x03000000Lu)
N#define ADC_DEEPSLEEP_ON               (0x08000000Lu)
N
N#define ADC_DSI_SYNC_CONFIG            (0x10000000Lu)
N#define ADC_DSI_MODE                   (0x20000000Lu)
N#define ADC_SWITCH_DISABLE             (0x40000000Lu)
N#define ADC_ENABLE                     (0x80000000Lu)
N
N/* defines for STATUS register */
N#define ADC_STATUS_BUSY                (0x80000000Lu)
N
N/* defines for SAMPLE_CTRL register */
N#define ADC_ALT_RESOLUTION_10BIT       (0x00000001Lu)
N#define ADC_ALT_RESOLUTION_8BIT        (0x00000000Lu)
N
N#define ADC_DATA_ALIGN_LEFT            (0x00000002Lu)
N#define ADC_DATA_ALIGN_RIGHT           (0x00000000Lu)
N
N#define ADC_SE_SIGNED_RESULT           (0x00000004Lu)
N#define ADC_SE_UNSIGNED_RESULT         (0x00000000Lu)
N
N#define ADC_DIFF_SIGNED_RESULT         (0x00000008Lu)
N#define ADC_DIFF_UNSIGNED_RESULT       (0x00000000Lu)
N
N#define ADC_AVG_CNT_OFFSET             (4u)
N#define ADC_AVG_CNT_MASK               (0x00000070Lu)
N#define ADC_AVG_SHIFT                  (0x00000080Lu)
N
N#define ADC_CONTINUOUS_EN              (0x00010000Lu)
N#define ADC_DSI_TRIGGER_EN             (0x00020000Lu)
N#define ADC_DSI_TRIGGER_LEVEL          (0x00040000Lu)
N#define ADC_DSI_SYNC_TRIGGER           (0x00080000Lu)
N#define ADC_EOS_DSI_OUT_EN             (0x80000000Lu)
N
N/* defines for SAMPLE_TIME01 / SAMPLE_TIME23 registers */
N#define ADC_SAMPLE_TIME13_OFFSET       (16u)
N#define ADC_SAMPLE_TIME02_MASK         (0x000003FFLu)
N#define ADC_SAMPLE_TIME13_MASK         (0x03FF0000Lu)
N
N/* defines for RANGE_THRES registers */
N#define ADC_RANGE_HIGH_OFFSET          (16u)
N#define ADC_RANGE_HIGH_MASK            (0xFFFF0000Lu)
N#define ADC_RANGE_LOW_MASK             (0x0000FFFFLu)
N
N/* defines for RANGE_COND register */
N/* Compare mode setting constants:
N*    BELOW   - Result < Low_Limit
N*    INSIDE  - Low_Limit <= Result < High_Limit
N*    ABOVE   - High_Limit <= Result
N*    OUTSIDE - (Result < Low_Limit) or (High_Limit <= Result)
N*/
N#define ADC_CMP_MODE_BELOW             (0x00000000Lu)
N#define ADC_CMP_MODE_INSIDE            (0x40000000Lu)
N#define ADC_CMP_MODE_ABOVE             (0x80000000Lu)
N#define ADC_CMP_MODE_OUTSIDE           (0xC0000000Lu)
N#define ADC_CMP_OFFSET                 (30u)
N
N/* defines for _START_CTRL register */
N#define ADC_FW_TRIGGER                 (0x00000001Lu)
N
N/* defines for DFT_CTRL register */
N#define ADC_DLY_INC                    (0x00000001Lu)
N#define ADC_HIZ                        (0x00000002Lu)
N#define ADC_DFT_INC_MASK               (0x000F0000Lu)
N#define ADC_DFT_OUTC_MASK              (0x00700000Lu)
N#define ADC_SEL_CSEL_DFT_MASK          (0x0F000000Lu)
N
N/* configuration for clock speed > 9 Mhz based on
N* characterization results
N*/
N#define ADC_SEL_CSEL_DFT_CHAR          (0x03000000Lu)
N#define ADC_EN_CSEL_DFT                (0x10000000Lu)
N#define ADC_DCEN                       (0x20000000Lu)
N#define ADC_ADFT_OVERRIDE              (0x80000000Lu)
N
N/* defines for CHAN_CONFIG / DIE_CHAN_CONFIG register
N*  and channelsConfig parameter
N*/
N#define ADC_SARMUX_VIRT_SELECT         (0x00000070Lu)
N#define ADC_DIFFERENTIAL_EN            (0x00000100Lu)
N#define ADC_ALT_RESOLUTION_ON          (0x00000200Lu)
N#define ADC_AVERAGING_EN               (0x00000400Lu)
N
N#define ADC_SAMPLE_TIME_SEL_SHIFT      (12u)
N#define ADC_SAMPLE_TIME_SEL_MASK       (0x00003000Lu)
N
N#define ADC_CHANNEL_CONFIG_MASK        (0x00003700Lu)
N
N/* for CHAN_CONFIG only */
N#define ADC_DSI_OUT_EN                 (0x80000000Lu)
N
N/* for INJ_CHAN_CONFIG only */
N#define ADC_INJ_TAILGATING             (0x40000000Lu)
N#define ADC_INJ_CHAN_EN                (0x80000000Lu)
N
N/* defines for CHAN_WORK register */
N#define ADC_SAR_WRK_MAX_12BIT          (0x00001000Lu)
N#define ADC_SAR_WRK_MAX_10BIT          (0x00000400Lu)
N#define ADC_SAR_WRK_MAX_8BIT           (0x00000100Lu)
N
N/* defines for CHAN_RESULT register */
N#define ADC_RESULT_MASK                (0x0000FFFFLu)
N#define ADC_SATURATE_INTR_MIR          (0x20000000Lu)
N#define ADC_RANGE_INTR_MIR             (0x40000000Lu)
N#define ADC_CHAN_RESULT_VALID_MIR      (0x80000000Lu)
N
N/* defines for INTR_MASK register */
N#define ADC_EOS_MASK                   (0x00000001Lu)
N#define ADC_OVERFLOW_MASK              (0x00000002Lu)
N#define ADC_FW_COLLISION_MASK          (0x00000004Lu)
N#define ADC_DSI_COLLISION_MASK         (0x00000008Lu)
N#define ADC_INJ_EOC_MASK               (0x00000010Lu)
N#define ADC_INJ_SATURATE_MASK          (0x00000020Lu)
N#define ADC_INJ_RANGE_MASK             (0x00000040Lu)
N#define ADC_INJ_COLLISION_MASK         (0x00000080Lu)
N
N/* defines for INJ_RESULT register */
N#define ADC_INJ_COLLISION_INTR_MIR     (0x10000000Lu)
N#define ADC_INJ_SATURATE_INTR_MIR      (0x20000000Lu)
N#define ADC_INJ_RANGE_INTR_MIR         (0x40000000Lu)
N#define ADC_INJ_EOC_INTR_MIR           (0x80000000Lu)
N
N/* defines for MUX_SWITCH0 register */
N#define ADC_MUX_FW_VSSA_VMINUS         (0x00010000Lu)
N
N/* defines for PUMP_CTRL register */
N#define ADC_PUMP_CTRL_ENABLED          (0x80000000Lu)
N
N/* additional defines for channelsConfig parameter */
N#define ADC_IS_SATURATE_EN_MASK        (0x00000001Lu)
N#define ADC_IS_RANGE_CTRL_EN_MASK      (0x00000002Lu)
N
N/* defines for WOUNDING register */
N#define ADC_WOUNDING_12BIT             (0x00000000Lu)
N#define ADC_WOUNDING_10BIT             (0x00000001Lu)
N#define ADC_WOUNDING_8BIT              (0x00000002Lu)
N
N/* Trim value based on characterization */
N#define ADC_TRIM_COEF                  (2u)
N
N#if(ADC_MAX_RESOLUTION == ADC_RESOLUTION_10)
X#if((12u) == (10u))
S    #define ADC_ALT_WOUNDING           ADC_WOUNDING_10BIT
N#else
N    #define ADC_ALT_WOUNDING           ADC_WOUNDING_8BIT
N#endif /* ADC_MAX_RESOLUTION == ADC_RESOLUTION_10 */
N
N#if(ADC_DEFAULT_VREF_SEL == ADC__VDDA_2)
X#if((4u) == 0)
S    #define ADC_DEFAULT_VREF_SOURCE    ADC_VREF_VDDA_2
S#elif(ADC_DEFAULT_VREF_SEL == ADC__VDDA)
X#elif((4u) == 1)
S    #define ADC_DEFAULT_VREF_SOURCE    ADC_VREF_VDDA
S#elif(ADC_DEFAULT_VREF_SEL == ADC__INTERNAL1024)
X#elif((4u) == 2)
S    #define ADC_DEFAULT_VREF_SOURCE    ADC_VREF_INTERNAL1024
S#elif(ADC_DEFAULT_VREF_SEL == ADC__INTERNAL1024BYPASSED)
X#elif((4u) == 3)
S    #define ADC_DEFAULT_VREF_SOURCE    ADC_VREF_INTERNAL1024BYPASSED
N#elif(ADC_DEFAULT_VREF_SEL == ADC__INTERNALVREF)
X#elif((4u) == 4)
N    #define ADC_DEFAULT_VREF_SOURCE    ADC_VREF_INTERNALVREF
N#elif(ADC_DEFAULT_VREF_SEL == ADC__INTERNALVREFBYPASSED)
S    #define ADC_DEFAULT_VREF_SOURCE    ADC_VREF_INTERNALVREFBYPASSED
S#elif(ADC_DEFAULT_VREF_SEL == ADC__VDDA_2BYPASSED)
S    #define ADC_DEFAULT_VREF_SOURCE    ADC_VREF_VDDA_2BYPASSED
S#else
S    #define ADC_DEFAULT_VREF_SOURCE    ADC_VREF_EXTERNAL
N#endif /* ADC_DEFAULT_VREF_SEL == ADC__VDDA_2 */
N
N#if(ADC_DEFAULT_NEG_INPUT_SEL == ADC__VSS)
X#if((1u) == 0)
S    /* Connect NEG input of SARADC to VSSA close to the SARADC for single channel mode */
S    #if(ADC_TOTAL_CHANNELS_NUM == 1u)
S        #define ADC_DEFAULT_SE_NEG_INPUT    ADC_NEG_VSSA
S    #else
S        #define ADC_DEFAULT_SE_NEG_INPUT    ADC_NEG_VSSA_KELVIN
S    #endif /* (ADC_TOTAL_CHANNELS_NUM == 1u) */
S    /* Do not connect VSSA to VMINUS when one channel in differential mode used */
S    #if((ADC_TOTAL_CHANNELS_NUM == 1u) && (ADC_CHANNELS_MODE != 0u))
S        #define ADC_DEFAULT_MUX_SWITCH0     0u
S    #else    /* miltiple channels or one single channel */
S        #define ADC_DEFAULT_MUX_SWITCH0     ADC_MUX_FW_VSSA_VMINUS
S    #endif /* (ADC_TOTAL_CHANNELS_NUM == 1u) */
N#elif(ADC_DEFAULT_NEG_INPUT_SEL == ADC__VREF)
X#elif((1u) == 1)
N    /* Do not connect VNEG to VREF when one channel in differential mode used */
N    #if((ADC_TOTAL_CHANNELS_NUM == 1u) && (ADC_CHANNELS_MODE != 0u))
X    #if(((3u) == 1u) && ((0u) != 0u))
S        #define ADC_DEFAULT_SE_NEG_INPUT    0u
N    #else    /* miltiple channels or one single channel */
N        #define ADC_DEFAULT_SE_NEG_INPUT    ADC_NEG_VREF
N    #endif /* (ADC_TOTAL_CHANNELS_NUM == 1u) */
N    #define ADC_DEFAULT_MUX_SWITCH0     0u
N#elif (ADC_SINGLE_PRESENT != 0u)
S    #define ADC_DEFAULT_SE_NEG_INPUT    ADC_NEG_OTHER
S    #define ADC_DEFAULT_MUX_SWITCH0     0u
S#else
S    #define ADC_DEFAULT_SE_NEG_INPUT    0u
S    #define ADC_DEFAULT_MUX_SWITCH0     0u
N#endif /* ADC_DEFAULT_NEG_INPUT_SEL == ADC__VREF */
N
N/* If the SAR is configured for multiple channels, always set SAR_HW_CTRL_NEGVREF to 1 */
N#if(ADC_TOTAL_CHANNELS_NUM == 1u)
X#if((3u) == 1u)
S    #define ADC_DEFAULT_HW_CTRL_NEGVREF 0u
N#else
N    #define ADC_DEFAULT_HW_CTRL_NEGVREF ADC_SAR_HW_CTRL_NEGVREF
N#endif /* (ADC_TOTAL_CHANNELS_NUM == 1u) */
N
N
N#if(ADC_DEFAULT_ALT_RESOLUTION_SEL == ADC__RES8)
X#if((1u) == 0)
S    #define ADC_DEFAULT_ALT_RESOLUTION     (ADC_ALT_RESOLUTION_8BIT)
S    #define ADC_DEFAULT_MAX_WRK_ALT        (ADC_SAR_WRK_MAX_8BIT)
N#else
N    #define ADC_DEFAULT_ALT_RESOLUTION     (ADC_ALT_RESOLUTION_10BIT)
N    #define ADC_DEFAULT_MAX_WRK_ALT        (ADC_SAR_WRK_MAX_10BIT)
N#endif /* End ADC_DEFAULT_ALT_RESOLUTION_SEL == ADC__RES8 */
N
N#if(ADC_DEFAULT_JUSTIFICATION_SEL == ADC__RIGHT)
X#if((0u) == 0)
N    #define ADC_DEFAULT_JUSTIFICATION  ADC_DATA_ALIGN_RIGHT
N#else
S    #define ADC_DEFAULT_JUSTIFICATION  ADC_DATA_ALIGN_LEFT
N#endif /* ADC_DEFAULT_JUSTIFICATION_SEL == ADC__RIGHT */
N
N#if(ADC_DEFAULT_DIFF_RESULT_FORMAT_SEL == ADC__FSIGNED)
X#if((0u) == 1)
S    #define ADC_DEFAULT_DIFF_RESULT_FORMAT ADC_DIFF_SIGNED_RESULT
N#else
N    #define ADC_DEFAULT_DIFF_RESULT_FORMAT ADC_DIFF_UNSIGNED_RESULT
N#endif /* ADC_DEFAULT_DIFF_RESULT_FORMAT_SEL == ADC__FSIGNED */
N
N#if(ADC_DEFAULT_SE_RESULT_FORMAT_SEL == ADC__FSIGNED)
X#if((0u) == 1)
S    #define ADC_DEFAULT_SE_RESULT_FORMAT ADC_SE_SIGNED_RESULT
N#else
N    #define ADC_DEFAULT_SE_RESULT_FORMAT ADC_SE_UNSIGNED_RESULT
N#endif /* ADC_DEFAULT_SE_RESULT_FORMAT_SEL == ADC__FSIGNED */
N
N#if(ADC_DEFAULT_SAMPLE_MODE_SEL == ADC__FREERUNNING)
X#if((1u) == 0)
S    #define ADC_DSI_TRIGGER        0u
N#else /* Firmware trigger */
N    #define ADC_DSI_TRIGGER        (ADC_DSI_TRIGGER_EN | ADC_DSI_SYNC_TRIGGER)
N#endif /* End ADC_DEFAULT_SAMPLE_MODE == ADC__FREERUNNING */
N
N#if(ADC_INJ_CHANNEL_ENABLED)
X#if((0u))
S    #define ADC_SAR_INTR_MASK      (ADC_EOS_MASK | ADC_INJ_EOC_MASK)
N#else
N    #define ADC_SAR_INTR_MASK      (ADC_EOS_MASK)
N#endif /* ADC_INJ_CHANNEL_ENABLED*/
N
N#if(ADC_DEFAULT_AVG_MODE == ADC__FIXEDRESOLUTION)
X#if((1u) == 1)
N    #define ADC_AVG_SHIFT_MODE     ADC_AVG_SHIFT
N#else
S    #define ADC_AVG_SHIFT_MODE     0u
N#endif /* End ADC_DEFAULT_AVG_MODE */
N
N#define ADC_COMPARE_MODE           (uint32)((uint32)(ADC_DEFAULT_COMPARE_MODE) \
N                                                << ADC_CMP_OFFSET)
X#define ADC_COMPARE_MODE           (uint32)((uint32)(ADC_DEFAULT_COMPARE_MODE)                                                 << ADC_CMP_OFFSET)
N
N#if(ADC_TOTAL_CHANNELS_NUM > 1u)
X#if((3u) > 1u)
N    #define ADC_DEFAULT_SWITCH_CONF    0u
N#else /* Disable SAR sequencer from enabling routing switches in single channel mode */
S    #define ADC_DEFAULT_SWITCH_CONF    ADC_SWITCH_DISABLE
N#endif /* End ADC_TOTAL_CHANNELS_NUM > 1 */
N
N#define ADC_DEFAULT_POWER \
N       ((ADC_NOMINAL_CLOCK_FREQ > (ADC_MAX_FREQUENCY / 4)) ? ADC_NORMAL_PWR : \
N       ((ADC_NOMINAL_CLOCK_FREQ > (ADC_MAX_FREQUENCY / 8)) ? ADC_HALF_PWR : \
N                                                                                       ADC_QUARTER_PWR))
X#define ADC_DEFAULT_POWER        ((ADC_NOMINAL_CLOCK_FREQ > (ADC_MAX_FREQUENCY / 4)) ? ADC_NORMAL_PWR :        ((ADC_NOMINAL_CLOCK_FREQ > (ADC_MAX_FREQUENCY / 8)) ? ADC_HALF_PWR :                                                                                        ADC_QUARTER_PWR))
N
N#define ADC_DEFAULT_CTRL_REG_CFG       (ADC_DEFAULT_VREF_SOURCE \
N                                                   | ADC_DEFAULT_SE_NEG_INPUT \
N                                                   | ADC_DEFAULT_HW_CTRL_NEGVREF \
N                                                   | ADC_DEFAULT_POWER \
N                                                   | ADC_DSI_SYNC_CONFIG \
N                                                   | ADC_DEFAULT_SWITCH_CONF)
X#define ADC_DEFAULT_CTRL_REG_CFG       (ADC_DEFAULT_VREF_SOURCE                                                    | ADC_DEFAULT_SE_NEG_INPUT                                                    | ADC_DEFAULT_HW_CTRL_NEGVREF                                                    | ADC_DEFAULT_POWER                                                    | ADC_DSI_SYNC_CONFIG                                                    | ADC_DEFAULT_SWITCH_CONF)
N
N#define ADC_DEFAULT_SAMPLE_CTRL_REG_CFG (ADC_DEFAULT_DIFF_RESULT_FORMAT \
N                                                    | ADC_DEFAULT_SE_RESULT_FORMAT \
N                                                    | ADC_DEFAULT_JUSTIFICATION \
N                                                    | ADC_DEFAULT_ALT_RESOLUTION \
N                                           | (uint8)(ADC_DEFAULT_AVG_SAMPLES_NUM \
N                                                   << ADC_AVG_CNT_OFFSET) \
N                                                    | ADC_AVG_SHIFT_MODE \
N                                                    | ADC_DSI_TRIGGER \
N                                                    | ADC_EOS_DSI_OUT_EN)
X#define ADC_DEFAULT_SAMPLE_CTRL_REG_CFG (ADC_DEFAULT_DIFF_RESULT_FORMAT                                                     | ADC_DEFAULT_SE_RESULT_FORMAT                                                     | ADC_DEFAULT_JUSTIFICATION                                                     | ADC_DEFAULT_ALT_RESOLUTION                                            | (uint8)(ADC_DEFAULT_AVG_SAMPLES_NUM                                                    << ADC_AVG_CNT_OFFSET)                                                     | ADC_AVG_SHIFT_MODE                                                     | ADC_DSI_TRIGGER                                                     | ADC_EOS_DSI_OUT_EN)
N
N#define ADC_DEFAULT_RANGE_THRES_REG_CFG (ADC_DEFAULT_LOW_LIMIT \
N            | (uint32)((uint32)ADC_DEFAULT_HIGH_LIMIT << ADC_RANGE_HIGH_OFFSET))
X#define ADC_DEFAULT_RANGE_THRES_REG_CFG (ADC_DEFAULT_LOW_LIMIT             | (uint32)((uint32)ADC_DEFAULT_HIGH_LIMIT << ADC_RANGE_HIGH_OFFSET))
N
N#define ADC_DEFAULT_SAMPLE_TIME01_REG_CFG (ADC_DEFAULT_ACLKS_NUM \
N            | (uint32)((uint32)ADC_DEFAULT_BCLKS_NUM << ADC_SAMPLE_TIME13_OFFSET))
X#define ADC_DEFAULT_SAMPLE_TIME01_REG_CFG (ADC_DEFAULT_ACLKS_NUM             | (uint32)((uint32)ADC_DEFAULT_BCLKS_NUM << ADC_SAMPLE_TIME13_OFFSET))
N
N#define ADC_DEFAULT_SAMPLE_TIME23_REG_CFG (ADC_DEFAULT_CCLKS_NUM \
N            | (uint32)((uint32)ADC_DEFAULT_DCLKS_NUM << ADC_SAMPLE_TIME13_OFFSET))
X#define ADC_DEFAULT_SAMPLE_TIME23_REG_CFG (ADC_DEFAULT_CCLKS_NUM             | (uint32)((uint32)ADC_DEFAULT_DCLKS_NUM << ADC_SAMPLE_TIME13_OFFSET))
N
N
N#endif /* End CY_ADC_SAR_SEQ_ADC_H */
N
N
N/* [] END OF FILE */
L 74 "Generated_Source\PSoC4\project.h" 2
N#include "MOTO_ADC.h"
L 1 "Generated_Source\PSoC4\MOTO_ADC.h" 1
N/*******************************************************************************
N* File Name: MOTO_ADC.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_MOTO_ADC_H) /* Pins MOTO_ADC_H */
X#if !0L  
N#define CY_PINS_MOTO_ADC_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "MOTO_ADC_aliases.h"
L 1 "Generated_Source\PSoC4\MOTO_ADC_aliases.h" 1
N/*******************************************************************************
N* File Name: MOTO_ADC.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_MOTO_ADC_ALIASES_H) /* Pins MOTO_ADC_ALIASES_H */
X#if !0L  
N#define CY_PINS_MOTO_ADC_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define MOTO_ADC_0			(MOTO_ADC__0__PC)
N#define MOTO_ADC_0_PS		(MOTO_ADC__0__PS)
N#define MOTO_ADC_0_PC		(MOTO_ADC__0__PC)
N#define MOTO_ADC_0_DR		(MOTO_ADC__0__DR)
N#define MOTO_ADC_0_SHIFT	(MOTO_ADC__0__SHIFT)
N#define MOTO_ADC_0_INTR	((uint16)((uint16)0x0003u << (MOTO_ADC__0__SHIFT*2u)))
N
N#define MOTO_ADC_INTR_ALL	 ((uint16)(MOTO_ADC_0_INTR))
N
N
N#endif /* End Pins MOTO_ADC_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\MOTO_ADC.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} MOTO_ADC_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   MOTO_ADC_Read(void);
Nvoid    MOTO_ADC_Write(uint8 value);
Nuint8   MOTO_ADC_ReadDataReg(void);
N#if defined(MOTO_ADC__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    MOTO_ADC_SetDriveMode(uint8 mode);
N#endif
Nvoid    MOTO_ADC_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   MOTO_ADC_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid MOTO_ADC_Sleep(void); 
Nvoid MOTO_ADC_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(MOTO_ADC__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define MOTO_ADC_DRIVE_MODE_BITS        (3)
N    #define MOTO_ADC_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - MOTO_ADC_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the MOTO_ADC_SetDriveMode() function.
N         *  @{
N         */
N        #define MOTO_ADC_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define MOTO_ADC_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define MOTO_ADC_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define MOTO_ADC_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define MOTO_ADC_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define MOTO_ADC_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define MOTO_ADC_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define MOTO_ADC_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define MOTO_ADC_MASK               MOTO_ADC__MASK
N#define MOTO_ADC_SHIFT              MOTO_ADC__SHIFT
N#define MOTO_ADC_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in MOTO_ADC_SetInterruptMode() function.
N     *  @{
N     */
N        #define MOTO_ADC_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define MOTO_ADC_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define MOTO_ADC_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define MOTO_ADC_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(MOTO_ADC__SIO)
X#if 0L
S    #define MOTO_ADC_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(MOTO_ADC__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define MOTO_ADC_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define MOTO_ADC_USBIO_DISABLE              ((uint32)(~MOTO_ADC_USBIO_ENABLE))
S    #define MOTO_ADC_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define MOTO_ADC_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define MOTO_ADC_USBIO_ENTER_SLEEP          ((uint32)((1u << MOTO_ADC_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << MOTO_ADC_USBIO_SUSPEND_DEL_SHIFT)))
X    #define MOTO_ADC_USBIO_ENTER_SLEEP          ((uint32)((1u << MOTO_ADC_USBIO_SUSPEND_SHIFT)                                                         | (1u << MOTO_ADC_USBIO_SUSPEND_DEL_SHIFT)))
S    #define MOTO_ADC_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << MOTO_ADC_USBIO_SUSPEND_SHIFT)))
S    #define MOTO_ADC_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << MOTO_ADC_USBIO_SUSPEND_DEL_SHIFT)))
S    #define MOTO_ADC_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(MOTO_ADC__PC)
X#if 1L
N    /* Port Configuration */
N    #define MOTO_ADC_PC                 (* (reg32 *) MOTO_ADC__PC)
N#endif
N/* Pin State */
N#define MOTO_ADC_PS                     (* (reg32 *) MOTO_ADC__PS)
N/* Data Register */
N#define MOTO_ADC_DR                     (* (reg32 *) MOTO_ADC__DR)
N/* Input Buffer Disable Override */
N#define MOTO_ADC_INP_DIS                (* (reg32 *) MOTO_ADC__PC2)
N
N/* Interrupt configuration Registers */
N#define MOTO_ADC_INTCFG                 (* (reg32 *) MOTO_ADC__INTCFG)
N#define MOTO_ADC_INTSTAT                (* (reg32 *) MOTO_ADC__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define MOTO_ADC_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(MOTO_ADC__SIO)
X#if 0L
S    #define MOTO_ADC_SIO_REG            (* (reg32 *) MOTO_ADC__SIO)
N#endif /* (MOTO_ADC__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(MOTO_ADC__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define MOTO_ADC_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define MOTO_ADC_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define MOTO_ADC_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define MOTO_ADC_DRIVE_MODE_SHIFT       (0x00u)
N#define MOTO_ADC_DRIVE_MODE_MASK        (0x07u << MOTO_ADC_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins MOTO_ADC_H */
N
N
N/* [] END OF FILE */
L 75 "Generated_Source\PSoC4\project.h" 2
N#include "MOTO_ADC_aliases.h"
L 1 "Generated_Source\PSoC4\MOTO_ADC_aliases.h" 1
N/*******************************************************************************
N* File Name: MOTO_ADC.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_MOTO_ADC_ALIASES_H) /* Pins MOTO_ADC_ALIASES_H */
X#if !1L  
S#define CY_PINS_MOTO_ADC_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define MOTO_ADC_0			(MOTO_ADC__0__PC)
S#define MOTO_ADC_0_PS		(MOTO_ADC__0__PS)
S#define MOTO_ADC_0_PC		(MOTO_ADC__0__PC)
S#define MOTO_ADC_0_DR		(MOTO_ADC__0__DR)
S#define MOTO_ADC_0_SHIFT	(MOTO_ADC__0__SHIFT)
S#define MOTO_ADC_0_INTR	((uint16)((uint16)0x0003u << (MOTO_ADC__0__SHIFT*2u)))
S
S#define MOTO_ADC_INTR_ALL	 ((uint16)(MOTO_ADC_0_INTR))
S
S
N#endif /* End Pins MOTO_ADC_ALIASES_H */
N
N
N/* [] END OF FILE */
L 76 "Generated_Source\PSoC4\project.h" 2
N#include "RF_ADC.h"
L 1 "Generated_Source\PSoC4\RF_ADC.h" 1
N/*******************************************************************************
N* File Name: RF_ADC.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_RF_ADC_H) /* Pins RF_ADC_H */
X#if !0L  
N#define CY_PINS_RF_ADC_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "RF_ADC_aliases.h"
L 1 "Generated_Source\PSoC4\RF_ADC_aliases.h" 1
N/*******************************************************************************
N* File Name: RF_ADC.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_RF_ADC_ALIASES_H) /* Pins RF_ADC_ALIASES_H */
X#if !0L  
N#define CY_PINS_RF_ADC_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define RF_ADC_0			(RF_ADC__0__PC)
N#define RF_ADC_0_PS		(RF_ADC__0__PS)
N#define RF_ADC_0_PC		(RF_ADC__0__PC)
N#define RF_ADC_0_DR		(RF_ADC__0__DR)
N#define RF_ADC_0_SHIFT	(RF_ADC__0__SHIFT)
N#define RF_ADC_0_INTR	((uint16)((uint16)0x0003u << (RF_ADC__0__SHIFT*2u)))
N
N#define RF_ADC_INTR_ALL	 ((uint16)(RF_ADC_0_INTR))
N
N
N#endif /* End Pins RF_ADC_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\RF_ADC.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} RF_ADC_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   RF_ADC_Read(void);
Nvoid    RF_ADC_Write(uint8 value);
Nuint8   RF_ADC_ReadDataReg(void);
N#if defined(RF_ADC__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    RF_ADC_SetDriveMode(uint8 mode);
N#endif
Nvoid    RF_ADC_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   RF_ADC_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid RF_ADC_Sleep(void); 
Nvoid RF_ADC_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(RF_ADC__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define RF_ADC_DRIVE_MODE_BITS        (3)
N    #define RF_ADC_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - RF_ADC_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the RF_ADC_SetDriveMode() function.
N         *  @{
N         */
N        #define RF_ADC_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define RF_ADC_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define RF_ADC_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define RF_ADC_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define RF_ADC_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define RF_ADC_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define RF_ADC_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define RF_ADC_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define RF_ADC_MASK               RF_ADC__MASK
N#define RF_ADC_SHIFT              RF_ADC__SHIFT
N#define RF_ADC_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in RF_ADC_SetInterruptMode() function.
N     *  @{
N     */
N        #define RF_ADC_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define RF_ADC_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define RF_ADC_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define RF_ADC_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(RF_ADC__SIO)
X#if 0L
S    #define RF_ADC_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(RF_ADC__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define RF_ADC_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define RF_ADC_USBIO_DISABLE              ((uint32)(~RF_ADC_USBIO_ENABLE))
S    #define RF_ADC_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define RF_ADC_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define RF_ADC_USBIO_ENTER_SLEEP          ((uint32)((1u << RF_ADC_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << RF_ADC_USBIO_SUSPEND_DEL_SHIFT)))
X    #define RF_ADC_USBIO_ENTER_SLEEP          ((uint32)((1u << RF_ADC_USBIO_SUSPEND_SHIFT)                                                         | (1u << RF_ADC_USBIO_SUSPEND_DEL_SHIFT)))
S    #define RF_ADC_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << RF_ADC_USBIO_SUSPEND_SHIFT)))
S    #define RF_ADC_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << RF_ADC_USBIO_SUSPEND_DEL_SHIFT)))
S    #define RF_ADC_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(RF_ADC__PC)
X#if 1L
N    /* Port Configuration */
N    #define RF_ADC_PC                 (* (reg32 *) RF_ADC__PC)
N#endif
N/* Pin State */
N#define RF_ADC_PS                     (* (reg32 *) RF_ADC__PS)
N/* Data Register */
N#define RF_ADC_DR                     (* (reg32 *) RF_ADC__DR)
N/* Input Buffer Disable Override */
N#define RF_ADC_INP_DIS                (* (reg32 *) RF_ADC__PC2)
N
N/* Interrupt configuration Registers */
N#define RF_ADC_INTCFG                 (* (reg32 *) RF_ADC__INTCFG)
N#define RF_ADC_INTSTAT                (* (reg32 *) RF_ADC__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define RF_ADC_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(RF_ADC__SIO)
X#if 0L
S    #define RF_ADC_SIO_REG            (* (reg32 *) RF_ADC__SIO)
N#endif /* (RF_ADC__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(RF_ADC__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define RF_ADC_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define RF_ADC_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define RF_ADC_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define RF_ADC_DRIVE_MODE_SHIFT       (0x00u)
N#define RF_ADC_DRIVE_MODE_MASK        (0x07u << RF_ADC_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins RF_ADC_H */
N
N
N/* [] END OF FILE */
L 77 "Generated_Source\PSoC4\project.h" 2
N#include "RF_ADC_aliases.h"
L 1 "Generated_Source\PSoC4\RF_ADC_aliases.h" 1
N/*******************************************************************************
N* File Name: RF_ADC.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_RF_ADC_ALIASES_H) /* Pins RF_ADC_ALIASES_H */
X#if !1L  
S#define CY_PINS_RF_ADC_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define RF_ADC_0			(RF_ADC__0__PC)
S#define RF_ADC_0_PS		(RF_ADC__0__PS)
S#define RF_ADC_0_PC		(RF_ADC__0__PC)
S#define RF_ADC_0_DR		(RF_ADC__0__DR)
S#define RF_ADC_0_SHIFT	(RF_ADC__0__SHIFT)
S#define RF_ADC_0_INTR	((uint16)((uint16)0x0003u << (RF_ADC__0__SHIFT*2u)))
S
S#define RF_ADC_INTR_ALL	 ((uint16)(RF_ADC_0_INTR))
S
S
N#endif /* End Pins RF_ADC_ALIASES_H */
N
N
N/* [] END OF FILE */
L 78 "Generated_Source\PSoC4\project.h" 2
N#include "VOICE_BUSY.h"
L 1 "Generated_Source\PSoC4\VOICE_BUSY.h" 1
N/*******************************************************************************
N* File Name: VOICE_BUSY.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_VOICE_BUSY_H) /* Pins VOICE_BUSY_H */
X#if !0L  
N#define CY_PINS_VOICE_BUSY_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "VOICE_BUSY_aliases.h"
L 1 "Generated_Source\PSoC4\VOICE_BUSY_aliases.h" 1
N/*******************************************************************************
N* File Name: VOICE_BUSY.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_VOICE_BUSY_ALIASES_H) /* Pins VOICE_BUSY_ALIASES_H */
X#if !0L  
N#define CY_PINS_VOICE_BUSY_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define VOICE_BUSY_0			(VOICE_BUSY__0__PC)
N#define VOICE_BUSY_0_PS		(VOICE_BUSY__0__PS)
N#define VOICE_BUSY_0_PC		(VOICE_BUSY__0__PC)
N#define VOICE_BUSY_0_DR		(VOICE_BUSY__0__DR)
N#define VOICE_BUSY_0_SHIFT	(VOICE_BUSY__0__SHIFT)
N#define VOICE_BUSY_0_INTR	((uint16)((uint16)0x0003u << (VOICE_BUSY__0__SHIFT*2u)))
N
N#define VOICE_BUSY_INTR_ALL	 ((uint16)(VOICE_BUSY_0_INTR))
N
N
N#endif /* End Pins VOICE_BUSY_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\VOICE_BUSY.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} VOICE_BUSY_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   VOICE_BUSY_Read(void);
Nvoid    VOICE_BUSY_Write(uint8 value);
Nuint8   VOICE_BUSY_ReadDataReg(void);
N#if defined(VOICE_BUSY__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    VOICE_BUSY_SetDriveMode(uint8 mode);
N#endif
Nvoid    VOICE_BUSY_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   VOICE_BUSY_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid VOICE_BUSY_Sleep(void); 
Nvoid VOICE_BUSY_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(VOICE_BUSY__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define VOICE_BUSY_DRIVE_MODE_BITS        (3)
N    #define VOICE_BUSY_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - VOICE_BUSY_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the VOICE_BUSY_SetDriveMode() function.
N         *  @{
N         */
N        #define VOICE_BUSY_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define VOICE_BUSY_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define VOICE_BUSY_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define VOICE_BUSY_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define VOICE_BUSY_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define VOICE_BUSY_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define VOICE_BUSY_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define VOICE_BUSY_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define VOICE_BUSY_MASK               VOICE_BUSY__MASK
N#define VOICE_BUSY_SHIFT              VOICE_BUSY__SHIFT
N#define VOICE_BUSY_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in VOICE_BUSY_SetInterruptMode() function.
N     *  @{
N     */
N        #define VOICE_BUSY_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define VOICE_BUSY_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define VOICE_BUSY_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define VOICE_BUSY_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(VOICE_BUSY__SIO)
X#if 0L
S    #define VOICE_BUSY_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(VOICE_BUSY__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define VOICE_BUSY_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define VOICE_BUSY_USBIO_DISABLE              ((uint32)(~VOICE_BUSY_USBIO_ENABLE))
S    #define VOICE_BUSY_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define VOICE_BUSY_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define VOICE_BUSY_USBIO_ENTER_SLEEP          ((uint32)((1u << VOICE_BUSY_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << VOICE_BUSY_USBIO_SUSPEND_DEL_SHIFT)))
X    #define VOICE_BUSY_USBIO_ENTER_SLEEP          ((uint32)((1u << VOICE_BUSY_USBIO_SUSPEND_SHIFT)                                                         | (1u << VOICE_BUSY_USBIO_SUSPEND_DEL_SHIFT)))
S    #define VOICE_BUSY_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << VOICE_BUSY_USBIO_SUSPEND_SHIFT)))
S    #define VOICE_BUSY_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << VOICE_BUSY_USBIO_SUSPEND_DEL_SHIFT)))
S    #define VOICE_BUSY_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(VOICE_BUSY__PC)
X#if 1L
N    /* Port Configuration */
N    #define VOICE_BUSY_PC                 (* (reg32 *) VOICE_BUSY__PC)
N#endif
N/* Pin State */
N#define VOICE_BUSY_PS                     (* (reg32 *) VOICE_BUSY__PS)
N/* Data Register */
N#define VOICE_BUSY_DR                     (* (reg32 *) VOICE_BUSY__DR)
N/* Input Buffer Disable Override */
N#define VOICE_BUSY_INP_DIS                (* (reg32 *) VOICE_BUSY__PC2)
N
N/* Interrupt configuration Registers */
N#define VOICE_BUSY_INTCFG                 (* (reg32 *) VOICE_BUSY__INTCFG)
N#define VOICE_BUSY_INTSTAT                (* (reg32 *) VOICE_BUSY__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define VOICE_BUSY_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(VOICE_BUSY__SIO)
X#if 0L
S    #define VOICE_BUSY_SIO_REG            (* (reg32 *) VOICE_BUSY__SIO)
N#endif /* (VOICE_BUSY__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(VOICE_BUSY__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define VOICE_BUSY_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define VOICE_BUSY_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define VOICE_BUSY_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define VOICE_BUSY_DRIVE_MODE_SHIFT       (0x00u)
N#define VOICE_BUSY_DRIVE_MODE_MASK        (0x07u << VOICE_BUSY_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins VOICE_BUSY_H */
N
N
N/* [] END OF FILE */
L 79 "Generated_Source\PSoC4\project.h" 2
N#include "VOICE_BUSY_aliases.h"
L 1 "Generated_Source\PSoC4\VOICE_BUSY_aliases.h" 1
N/*******************************************************************************
N* File Name: VOICE_BUSY.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_VOICE_BUSY_ALIASES_H) /* Pins VOICE_BUSY_ALIASES_H */
X#if !1L  
S#define CY_PINS_VOICE_BUSY_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define VOICE_BUSY_0			(VOICE_BUSY__0__PC)
S#define VOICE_BUSY_0_PS		(VOICE_BUSY__0__PS)
S#define VOICE_BUSY_0_PC		(VOICE_BUSY__0__PC)
S#define VOICE_BUSY_0_DR		(VOICE_BUSY__0__DR)
S#define VOICE_BUSY_0_SHIFT	(VOICE_BUSY__0__SHIFT)
S#define VOICE_BUSY_0_INTR	((uint16)((uint16)0x0003u << (VOICE_BUSY__0__SHIFT*2u)))
S
S#define VOICE_BUSY_INTR_ALL	 ((uint16)(VOICE_BUSY_0_INTR))
S
S
N#endif /* End Pins VOICE_BUSY_ALIASES_H */
N
N
N/* [] END OF FILE */
L 80 "Generated_Source\PSoC4\project.h" 2
N#include "VOICE_DATA.h"
L 1 "Generated_Source\PSoC4\VOICE_DATA.h" 1
N/*******************************************************************************
N* File Name: VOICE_DATA.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_VOICE_DATA_H) /* Pins VOICE_DATA_H */
X#if !0L  
N#define CY_PINS_VOICE_DATA_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "VOICE_DATA_aliases.h"
L 1 "Generated_Source\PSoC4\VOICE_DATA_aliases.h" 1
N/*******************************************************************************
N* File Name: VOICE_DATA.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_VOICE_DATA_ALIASES_H) /* Pins VOICE_DATA_ALIASES_H */
X#if !0L  
N#define CY_PINS_VOICE_DATA_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define VOICE_DATA_0			(VOICE_DATA__0__PC)
N#define VOICE_DATA_0_PS		(VOICE_DATA__0__PS)
N#define VOICE_DATA_0_PC		(VOICE_DATA__0__PC)
N#define VOICE_DATA_0_DR		(VOICE_DATA__0__DR)
N#define VOICE_DATA_0_SHIFT	(VOICE_DATA__0__SHIFT)
N#define VOICE_DATA_0_INTR	((uint16)((uint16)0x0003u << (VOICE_DATA__0__SHIFT*2u)))
N
N#define VOICE_DATA_INTR_ALL	 ((uint16)(VOICE_DATA_0_INTR))
N
N
N#endif /* End Pins VOICE_DATA_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\VOICE_DATA.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} VOICE_DATA_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   VOICE_DATA_Read(void);
Nvoid    VOICE_DATA_Write(uint8 value);
Nuint8   VOICE_DATA_ReadDataReg(void);
N#if defined(VOICE_DATA__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    VOICE_DATA_SetDriveMode(uint8 mode);
N#endif
Nvoid    VOICE_DATA_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   VOICE_DATA_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid VOICE_DATA_Sleep(void); 
Nvoid VOICE_DATA_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(VOICE_DATA__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define VOICE_DATA_DRIVE_MODE_BITS        (3)
N    #define VOICE_DATA_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - VOICE_DATA_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the VOICE_DATA_SetDriveMode() function.
N         *  @{
N         */
N        #define VOICE_DATA_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define VOICE_DATA_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define VOICE_DATA_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define VOICE_DATA_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define VOICE_DATA_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define VOICE_DATA_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define VOICE_DATA_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define VOICE_DATA_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define VOICE_DATA_MASK               VOICE_DATA__MASK
N#define VOICE_DATA_SHIFT              VOICE_DATA__SHIFT
N#define VOICE_DATA_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in VOICE_DATA_SetInterruptMode() function.
N     *  @{
N     */
N        #define VOICE_DATA_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define VOICE_DATA_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define VOICE_DATA_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define VOICE_DATA_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(VOICE_DATA__SIO)
X#if 0L
S    #define VOICE_DATA_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(VOICE_DATA__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define VOICE_DATA_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define VOICE_DATA_USBIO_DISABLE              ((uint32)(~VOICE_DATA_USBIO_ENABLE))
S    #define VOICE_DATA_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define VOICE_DATA_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define VOICE_DATA_USBIO_ENTER_SLEEP          ((uint32)((1u << VOICE_DATA_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << VOICE_DATA_USBIO_SUSPEND_DEL_SHIFT)))
X    #define VOICE_DATA_USBIO_ENTER_SLEEP          ((uint32)((1u << VOICE_DATA_USBIO_SUSPEND_SHIFT)                                                         | (1u << VOICE_DATA_USBIO_SUSPEND_DEL_SHIFT)))
S    #define VOICE_DATA_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << VOICE_DATA_USBIO_SUSPEND_SHIFT)))
S    #define VOICE_DATA_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << VOICE_DATA_USBIO_SUSPEND_DEL_SHIFT)))
S    #define VOICE_DATA_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(VOICE_DATA__PC)
X#if 1L
N    /* Port Configuration */
N    #define VOICE_DATA_PC                 (* (reg32 *) VOICE_DATA__PC)
N#endif
N/* Pin State */
N#define VOICE_DATA_PS                     (* (reg32 *) VOICE_DATA__PS)
N/* Data Register */
N#define VOICE_DATA_DR                     (* (reg32 *) VOICE_DATA__DR)
N/* Input Buffer Disable Override */
N#define VOICE_DATA_INP_DIS                (* (reg32 *) VOICE_DATA__PC2)
N
N/* Interrupt configuration Registers */
N#define VOICE_DATA_INTCFG                 (* (reg32 *) VOICE_DATA__INTCFG)
N#define VOICE_DATA_INTSTAT                (* (reg32 *) VOICE_DATA__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define VOICE_DATA_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(VOICE_DATA__SIO)
X#if 0L
S    #define VOICE_DATA_SIO_REG            (* (reg32 *) VOICE_DATA__SIO)
N#endif /* (VOICE_DATA__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(VOICE_DATA__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define VOICE_DATA_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define VOICE_DATA_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define VOICE_DATA_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define VOICE_DATA_DRIVE_MODE_SHIFT       (0x00u)
N#define VOICE_DATA_DRIVE_MODE_MASK        (0x07u << VOICE_DATA_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins VOICE_DATA_H */
N
N
N/* [] END OF FILE */
L 81 "Generated_Source\PSoC4\project.h" 2
N#include "VOICE_DATA_aliases.h"
L 1 "Generated_Source\PSoC4\VOICE_DATA_aliases.h" 1
N/*******************************************************************************
N* File Name: VOICE_DATA.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_VOICE_DATA_ALIASES_H) /* Pins VOICE_DATA_ALIASES_H */
X#if !1L  
S#define CY_PINS_VOICE_DATA_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define VOICE_DATA_0			(VOICE_DATA__0__PC)
S#define VOICE_DATA_0_PS		(VOICE_DATA__0__PS)
S#define VOICE_DATA_0_PC		(VOICE_DATA__0__PC)
S#define VOICE_DATA_0_DR		(VOICE_DATA__0__DR)
S#define VOICE_DATA_0_SHIFT	(VOICE_DATA__0__SHIFT)
S#define VOICE_DATA_0_INTR	((uint16)((uint16)0x0003u << (VOICE_DATA__0__SHIFT*2u)))
S
S#define VOICE_DATA_INTR_ALL	 ((uint16)(VOICE_DATA_0_INTR))
S
S
N#endif /* End Pins VOICE_DATA_ALIASES_H */
N
N
N/* [] END OF FILE */
L 82 "Generated_Source\PSoC4\project.h" 2
N#include "isr_1.h"
L 1 "Generated_Source\PSoC4\isr_1.h" 1
N/*******************************************************************************
N* File Name: isr_1.h
N* Version 1.70
N*
N*  Description:
N*   Provides the function definitions for the Interrupt Controller.
N*
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N#if !defined(CY_ISR_isr_1_H)
X#if !0L
N#define CY_ISR_isr_1_H
N
N
N#include <cytypes.h>
N#include <cyfitter.h>
N
N/* Interrupt Controller API. */
Nvoid isr_1_Start(void);
Nvoid isr_1_StartEx(cyisraddress address);
Nvoid isr_1_Stop(void);
N
NCY_ISR_PROTO(isr_1_Interrupt);
Xvoid isr_1_Interrupt (void);
N
Nvoid isr_1_SetVector(cyisraddress address);
Ncyisraddress isr_1_GetVector(void);
N
Nvoid isr_1_SetPriority(uint8 priority);
Nuint8 isr_1_GetPriority(void);
N
Nvoid isr_1_Enable(void);
Nuint8 isr_1_GetState(void);
Nvoid isr_1_Disable(void);
N
Nvoid isr_1_SetPending(void);
Nvoid isr_1_ClearPending(void);
N
N
N/* Interrupt Controller Constants */
N
N/* Address of the INTC.VECT[x] register that contains the Address of the isr_1 ISR. */
N#define isr_1_INTC_VECTOR            ((reg32 *) isr_1__INTC_VECT)
N
N/* Address of the isr_1 ISR priority. */
N#define isr_1_INTC_PRIOR             ((reg32 *) isr_1__INTC_PRIOR_REG)
N
N/* Priority of the isr_1 interrupt. */
N#define isr_1_INTC_PRIOR_NUMBER      isr_1__INTC_PRIOR_NUM
N
N/* Address of the INTC.SET_EN[x] byte to bit enable isr_1 interrupt. */
N#define isr_1_INTC_SET_EN            ((reg32 *) isr_1__INTC_SET_EN_REG)
N
N/* Address of the INTC.CLR_EN[x] register to bit clear the isr_1 interrupt. */
N#define isr_1_INTC_CLR_EN            ((reg32 *) isr_1__INTC_CLR_EN_REG)
N
N/* Address of the INTC.SET_PD[x] register to set the isr_1 interrupt state to pending. */
N#define isr_1_INTC_SET_PD            ((reg32 *) isr_1__INTC_SET_PD_REG)
N
N/* Address of the INTC.CLR_PD[x] register to clear the isr_1 interrupt. */
N#define isr_1_INTC_CLR_PD            ((reg32 *) isr_1__INTC_CLR_PD_REG)
N
N
N
N#endif /* CY_ISR_isr_1_H */
N
N
N/* [] END OF FILE */
L 83 "Generated_Source\PSoC4\project.h" 2
N#include "LOCK_INT.h"
L 1 "Generated_Source\PSoC4\LOCK_INT.h" 1
N/*******************************************************************************
N* File Name: LOCK_INT.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_LOCK_INT_H) /* Pins LOCK_INT_H */
X#if !0L  
N#define CY_PINS_LOCK_INT_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "LOCK_INT_aliases.h"
L 1 "Generated_Source\PSoC4\LOCK_INT_aliases.h" 1
N/*******************************************************************************
N* File Name: LOCK_INT.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_LOCK_INT_ALIASES_H) /* Pins LOCK_INT_ALIASES_H */
X#if !0L  
N#define CY_PINS_LOCK_INT_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define LOCK_INT_0			(LOCK_INT__0__PC)
N#define LOCK_INT_0_PS		(LOCK_INT__0__PS)
N#define LOCK_INT_0_PC		(LOCK_INT__0__PC)
N#define LOCK_INT_0_DR		(LOCK_INT__0__DR)
N#define LOCK_INT_0_SHIFT	(LOCK_INT__0__SHIFT)
N#define LOCK_INT_0_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__0__SHIFT*2u)))
N
N#define LOCK_INT_1			(LOCK_INT__1__PC)
N#define LOCK_INT_1_PS		(LOCK_INT__1__PS)
N#define LOCK_INT_1_PC		(LOCK_INT__1__PC)
N#define LOCK_INT_1_DR		(LOCK_INT__1__DR)
N#define LOCK_INT_1_SHIFT	(LOCK_INT__1__SHIFT)
N#define LOCK_INT_1_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__1__SHIFT*2u)))
N
N#define LOCK_INT_2			(LOCK_INT__2__PC)
N#define LOCK_INT_2_PS		(LOCK_INT__2__PS)
N#define LOCK_INT_2_PC		(LOCK_INT__2__PC)
N#define LOCK_INT_2_DR		(LOCK_INT__2__DR)
N#define LOCK_INT_2_SHIFT	(LOCK_INT__2__SHIFT)
N#define LOCK_INT_2_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__2__SHIFT*2u)))
N
N#define LOCK_INT_3			(LOCK_INT__3__PC)
N#define LOCK_INT_3_PS		(LOCK_INT__3__PS)
N#define LOCK_INT_3_PC		(LOCK_INT__3__PC)
N#define LOCK_INT_3_DR		(LOCK_INT__3__DR)
N#define LOCK_INT_3_SHIFT	(LOCK_INT__3__SHIFT)
N#define LOCK_INT_3_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__3__SHIFT*2u)))
N
N#define LOCK_INT_INTR_ALL	 ((uint16)(LOCK_INT_0_INTR| LOCK_INT_1_INTR| LOCK_INT_2_INTR| LOCK_INT_3_INTR))
N#define LOCK_INT_OP2INT			(LOCK_INT__OP2INT__PC)
N#define LOCK_INT_OP2INT_PS		(LOCK_INT__OP2INT__PS)
N#define LOCK_INT_OP2INT_PC		(LOCK_INT__OP2INT__PC)
N#define LOCK_INT_OP2INT_DR		(LOCK_INT__OP2INT__DR)
N#define LOCK_INT_OP2INT_SHIFT	(LOCK_INT__OP2INT__SHIFT)
N#define LOCK_INT_OP2INT_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__0__SHIFT*2u)))
N
N#define LOCK_INT_LOCK_BNT_INT			(LOCK_INT__LOCK_BNT_INT__PC)
N#define LOCK_INT_LOCK_BNT_INT_PS		(LOCK_INT__LOCK_BNT_INT__PS)
N#define LOCK_INT_LOCK_BNT_INT_PC		(LOCK_INT__LOCK_BNT_INT__PC)
N#define LOCK_INT_LOCK_BNT_INT_DR		(LOCK_INT__LOCK_BNT_INT__DR)
N#define LOCK_INT_LOCK_BNT_INT_SHIFT	(LOCK_INT__LOCK_BNT_INT__SHIFT)
N#define LOCK_INT_LOCK_BNT_INT_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__1__SHIFT*2u)))
N
N#define LOCK_INT_LOCK_MODE_INT			(LOCK_INT__LOCK_MODE_INT__PC)
N#define LOCK_INT_LOCK_MODE_INT_PS		(LOCK_INT__LOCK_MODE_INT__PS)
N#define LOCK_INT_LOCK_MODE_INT_PC		(LOCK_INT__LOCK_MODE_INT__PC)
N#define LOCK_INT_LOCK_MODE_INT_DR		(LOCK_INT__LOCK_MODE_INT__DR)
N#define LOCK_INT_LOCK_MODE_INT_SHIFT	(LOCK_INT__LOCK_MODE_INT__SHIFT)
N#define LOCK_INT_LOCK_MODE_INT_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__2__SHIFT*2u)))
N
N#define LOCK_INT_LOCK_SLOT_INT			(LOCK_INT__LOCK_SLOT_INT__PC)
N#define LOCK_INT_LOCK_SLOT_INT_PS		(LOCK_INT__LOCK_SLOT_INT__PS)
N#define LOCK_INT_LOCK_SLOT_INT_PC		(LOCK_INT__LOCK_SLOT_INT__PC)
N#define LOCK_INT_LOCK_SLOT_INT_DR		(LOCK_INT__LOCK_SLOT_INT__DR)
N#define LOCK_INT_LOCK_SLOT_INT_SHIFT	(LOCK_INT__LOCK_SLOT_INT__SHIFT)
N#define LOCK_INT_LOCK_SLOT_INT_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__3__SHIFT*2u)))
N
N
N#endif /* End Pins LOCK_INT_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\LOCK_INT.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} LOCK_INT_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   LOCK_INT_Read(void);
Nvoid    LOCK_INT_Write(uint8 value);
Nuint8   LOCK_INT_ReadDataReg(void);
N#if defined(LOCK_INT__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    LOCK_INT_SetDriveMode(uint8 mode);
N#endif
Nvoid    LOCK_INT_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   LOCK_INT_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid LOCK_INT_Sleep(void); 
Nvoid LOCK_INT_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(LOCK_INT__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define LOCK_INT_DRIVE_MODE_BITS        (3)
N    #define LOCK_INT_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - LOCK_INT_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the LOCK_INT_SetDriveMode() function.
N         *  @{
N         */
N        #define LOCK_INT_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define LOCK_INT_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define LOCK_INT_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define LOCK_INT_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define LOCK_INT_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define LOCK_INT_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define LOCK_INT_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define LOCK_INT_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define LOCK_INT_MASK               LOCK_INT__MASK
N#define LOCK_INT_SHIFT              LOCK_INT__SHIFT
N#define LOCK_INT_WIDTH              4u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in LOCK_INT_SetInterruptMode() function.
N     *  @{
N     */
N        #define LOCK_INT_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define LOCK_INT_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define LOCK_INT_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define LOCK_INT_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(LOCK_INT__SIO)
X#if 0L
S    #define LOCK_INT_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(LOCK_INT__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define LOCK_INT_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define LOCK_INT_USBIO_DISABLE              ((uint32)(~LOCK_INT_USBIO_ENABLE))
S    #define LOCK_INT_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define LOCK_INT_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define LOCK_INT_USBIO_ENTER_SLEEP          ((uint32)((1u << LOCK_INT_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << LOCK_INT_USBIO_SUSPEND_DEL_SHIFT)))
X    #define LOCK_INT_USBIO_ENTER_SLEEP          ((uint32)((1u << LOCK_INT_USBIO_SUSPEND_SHIFT)                                                         | (1u << LOCK_INT_USBIO_SUSPEND_DEL_SHIFT)))
S    #define LOCK_INT_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << LOCK_INT_USBIO_SUSPEND_SHIFT)))
S    #define LOCK_INT_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << LOCK_INT_USBIO_SUSPEND_DEL_SHIFT)))
S    #define LOCK_INT_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(LOCK_INT__PC)
X#if 1L
N    /* Port Configuration */
N    #define LOCK_INT_PC                 (* (reg32 *) LOCK_INT__PC)
N#endif
N/* Pin State */
N#define LOCK_INT_PS                     (* (reg32 *) LOCK_INT__PS)
N/* Data Register */
N#define LOCK_INT_DR                     (* (reg32 *) LOCK_INT__DR)
N/* Input Buffer Disable Override */
N#define LOCK_INT_INP_DIS                (* (reg32 *) LOCK_INT__PC2)
N
N/* Interrupt configuration Registers */
N#define LOCK_INT_INTCFG                 (* (reg32 *) LOCK_INT__INTCFG)
N#define LOCK_INT_INTSTAT                (* (reg32 *) LOCK_INT__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define LOCK_INT_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(LOCK_INT__SIO)
X#if 0L
S    #define LOCK_INT_SIO_REG            (* (reg32 *) LOCK_INT__SIO)
N#endif /* (LOCK_INT__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(LOCK_INT__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define LOCK_INT_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define LOCK_INT_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define LOCK_INT_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define LOCK_INT_DRIVE_MODE_SHIFT       (0x00u)
N#define LOCK_INT_DRIVE_MODE_MASK        (0x07u << LOCK_INT_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins LOCK_INT_H */
N
N
N/* [] END OF FILE */
L 84 "Generated_Source\PSoC4\project.h" 2
N#include "LOCK_INT_aliases.h"
L 1 "Generated_Source\PSoC4\LOCK_INT_aliases.h" 1
N/*******************************************************************************
N* File Name: LOCK_INT.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_LOCK_INT_ALIASES_H) /* Pins LOCK_INT_ALIASES_H */
X#if !1L  
S#define CY_PINS_LOCK_INT_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define LOCK_INT_0			(LOCK_INT__0__PC)
S#define LOCK_INT_0_PS		(LOCK_INT__0__PS)
S#define LOCK_INT_0_PC		(LOCK_INT__0__PC)
S#define LOCK_INT_0_DR		(LOCK_INT__0__DR)
S#define LOCK_INT_0_SHIFT	(LOCK_INT__0__SHIFT)
S#define LOCK_INT_0_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__0__SHIFT*2u)))
S
S#define LOCK_INT_1			(LOCK_INT__1__PC)
S#define LOCK_INT_1_PS		(LOCK_INT__1__PS)
S#define LOCK_INT_1_PC		(LOCK_INT__1__PC)
S#define LOCK_INT_1_DR		(LOCK_INT__1__DR)
S#define LOCK_INT_1_SHIFT	(LOCK_INT__1__SHIFT)
S#define LOCK_INT_1_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__1__SHIFT*2u)))
S
S#define LOCK_INT_2			(LOCK_INT__2__PC)
S#define LOCK_INT_2_PS		(LOCK_INT__2__PS)
S#define LOCK_INT_2_PC		(LOCK_INT__2__PC)
S#define LOCK_INT_2_DR		(LOCK_INT__2__DR)
S#define LOCK_INT_2_SHIFT	(LOCK_INT__2__SHIFT)
S#define LOCK_INT_2_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__2__SHIFT*2u)))
S
S#define LOCK_INT_3			(LOCK_INT__3__PC)
S#define LOCK_INT_3_PS		(LOCK_INT__3__PS)
S#define LOCK_INT_3_PC		(LOCK_INT__3__PC)
S#define LOCK_INT_3_DR		(LOCK_INT__3__DR)
S#define LOCK_INT_3_SHIFT	(LOCK_INT__3__SHIFT)
S#define LOCK_INT_3_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__3__SHIFT*2u)))
S
S#define LOCK_INT_INTR_ALL	 ((uint16)(LOCK_INT_0_INTR| LOCK_INT_1_INTR| LOCK_INT_2_INTR| LOCK_INT_3_INTR))
S#define LOCK_INT_OP2INT			(LOCK_INT__OP2INT__PC)
S#define LOCK_INT_OP2INT_PS		(LOCK_INT__OP2INT__PS)
S#define LOCK_INT_OP2INT_PC		(LOCK_INT__OP2INT__PC)
S#define LOCK_INT_OP2INT_DR		(LOCK_INT__OP2INT__DR)
S#define LOCK_INT_OP2INT_SHIFT	(LOCK_INT__OP2INT__SHIFT)
S#define LOCK_INT_OP2INT_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__0__SHIFT*2u)))
S
S#define LOCK_INT_LOCK_BNT_INT			(LOCK_INT__LOCK_BNT_INT__PC)
S#define LOCK_INT_LOCK_BNT_INT_PS		(LOCK_INT__LOCK_BNT_INT__PS)
S#define LOCK_INT_LOCK_BNT_INT_PC		(LOCK_INT__LOCK_BNT_INT__PC)
S#define LOCK_INT_LOCK_BNT_INT_DR		(LOCK_INT__LOCK_BNT_INT__DR)
S#define LOCK_INT_LOCK_BNT_INT_SHIFT	(LOCK_INT__LOCK_BNT_INT__SHIFT)
S#define LOCK_INT_LOCK_BNT_INT_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__1__SHIFT*2u)))
S
S#define LOCK_INT_LOCK_MODE_INT			(LOCK_INT__LOCK_MODE_INT__PC)
S#define LOCK_INT_LOCK_MODE_INT_PS		(LOCK_INT__LOCK_MODE_INT__PS)
S#define LOCK_INT_LOCK_MODE_INT_PC		(LOCK_INT__LOCK_MODE_INT__PC)
S#define LOCK_INT_LOCK_MODE_INT_DR		(LOCK_INT__LOCK_MODE_INT__DR)
S#define LOCK_INT_LOCK_MODE_INT_SHIFT	(LOCK_INT__LOCK_MODE_INT__SHIFT)
S#define LOCK_INT_LOCK_MODE_INT_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__2__SHIFT*2u)))
S
S#define LOCK_INT_LOCK_SLOT_INT			(LOCK_INT__LOCK_SLOT_INT__PC)
S#define LOCK_INT_LOCK_SLOT_INT_PS		(LOCK_INT__LOCK_SLOT_INT__PS)
S#define LOCK_INT_LOCK_SLOT_INT_PC		(LOCK_INT__LOCK_SLOT_INT__PC)
S#define LOCK_INT_LOCK_SLOT_INT_DR		(LOCK_INT__LOCK_SLOT_INT__DR)
S#define LOCK_INT_LOCK_SLOT_INT_SHIFT	(LOCK_INT__LOCK_SLOT_INT__SHIFT)
S#define LOCK_INT_LOCK_SLOT_INT_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__3__SHIFT*2u)))
S
S
N#endif /* End Pins LOCK_INT_ALIASES_H */
N
N
N/* [] END OF FILE */
L 85 "Generated_Source\PSoC4\project.h" 2
N#include "GPIO_ISR1.h"
L 1 "Generated_Source\PSoC4\GPIO_ISR1.h" 1
N/*******************************************************************************
N* File Name: GPIO_ISR1.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_GPIO_ISR1_H) /* Pins GPIO_ISR1_H */
X#if !0L  
N#define CY_PINS_GPIO_ISR1_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "GPIO_ISR1_aliases.h"
L 1 "Generated_Source\PSoC4\GPIO_ISR1_aliases.h" 1
N/*******************************************************************************
N* File Name: GPIO_ISR1.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_GPIO_ISR1_ALIASES_H) /* Pins GPIO_ISR1_ALIASES_H */
X#if !0L  
N#define CY_PINS_GPIO_ISR1_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define GPIO_ISR1_0			(GPIO_ISR1__0__PC)
N#define GPIO_ISR1_0_PS		(GPIO_ISR1__0__PS)
N#define GPIO_ISR1_0_PC		(GPIO_ISR1__0__PC)
N#define GPIO_ISR1_0_DR		(GPIO_ISR1__0__DR)
N#define GPIO_ISR1_0_SHIFT	(GPIO_ISR1__0__SHIFT)
N#define GPIO_ISR1_0_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__0__SHIFT*2u)))
N
N#define GPIO_ISR1_1			(GPIO_ISR1__1__PC)
N#define GPIO_ISR1_1_PS		(GPIO_ISR1__1__PS)
N#define GPIO_ISR1_1_PC		(GPIO_ISR1__1__PC)
N#define GPIO_ISR1_1_DR		(GPIO_ISR1__1__DR)
N#define GPIO_ISR1_1_SHIFT	(GPIO_ISR1__1__SHIFT)
N#define GPIO_ISR1_1_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__1__SHIFT*2u)))
N
N#define GPIO_ISR1_2			(GPIO_ISR1__2__PC)
N#define GPIO_ISR1_2_PS		(GPIO_ISR1__2__PS)
N#define GPIO_ISR1_2_PC		(GPIO_ISR1__2__PC)
N#define GPIO_ISR1_2_DR		(GPIO_ISR1__2__DR)
N#define GPIO_ISR1_2_SHIFT	(GPIO_ISR1__2__SHIFT)
N#define GPIO_ISR1_2_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__2__SHIFT*2u)))
N
N#define GPIO_ISR1_3			(GPIO_ISR1__3__PC)
N#define GPIO_ISR1_3_PS		(GPIO_ISR1__3__PS)
N#define GPIO_ISR1_3_PC		(GPIO_ISR1__3__PC)
N#define GPIO_ISR1_3_DR		(GPIO_ISR1__3__DR)
N#define GPIO_ISR1_3_SHIFT	(GPIO_ISR1__3__SHIFT)
N#define GPIO_ISR1_3_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__3__SHIFT*2u)))
N
N#define GPIO_ISR1_INTR_ALL	 ((uint16)(GPIO_ISR1_0_INTR| GPIO_ISR1_1_INTR| GPIO_ISR1_2_INTR| GPIO_ISR1_3_INTR))
N#define GPIO_ISR1_KEY_INT			(GPIO_ISR1__KEY_INT__PC)
N#define GPIO_ISR1_KEY_INT_PS		(GPIO_ISR1__KEY_INT__PS)
N#define GPIO_ISR1_KEY_INT_PC		(GPIO_ISR1__KEY_INT__PC)
N#define GPIO_ISR1_KEY_INT_DR		(GPIO_ISR1__KEY_INT__DR)
N#define GPIO_ISR1_KEY_INT_SHIFT	(GPIO_ISR1__KEY_INT__SHIFT)
N#define GPIO_ISR1_KEY_INT_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__0__SHIFT*2u)))
N
N#define GPIO_ISR1_EXT_UART_2_INT			(GPIO_ISR1__EXT_UART_2_INT__PC)
N#define GPIO_ISR1_EXT_UART_2_INT_PS		(GPIO_ISR1__EXT_UART_2_INT__PS)
N#define GPIO_ISR1_EXT_UART_2_INT_PC		(GPIO_ISR1__EXT_UART_2_INT__PC)
N#define GPIO_ISR1_EXT_UART_2_INT_DR		(GPIO_ISR1__EXT_UART_2_INT__DR)
N#define GPIO_ISR1_EXT_UART_2_INT_SHIFT	(GPIO_ISR1__EXT_UART_2_INT__SHIFT)
N#define GPIO_ISR1_EXT_UART_2_INT_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__1__SHIFT*2u)))
N
N#define GPIO_ISR1_BLE_INT			(GPIO_ISR1__BLE_INT__PC)
N#define GPIO_ISR1_BLE_INT_PS		(GPIO_ISR1__BLE_INT__PS)
N#define GPIO_ISR1_BLE_INT_PC		(GPIO_ISR1__BLE_INT__PC)
N#define GPIO_ISR1_BLE_INT_DR		(GPIO_ISR1__BLE_INT__DR)
N#define GPIO_ISR1_BLE_INT_SHIFT	(GPIO_ISR1__BLE_INT__SHIFT)
N#define GPIO_ISR1_BLE_INT_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__2__SHIFT*2u)))
N
N#define GPIO_ISR1_FPC_UART_0_INT			(GPIO_ISR1__FPC_UART_0_INT__PC)
N#define GPIO_ISR1_FPC_UART_0_INT_PS		(GPIO_ISR1__FPC_UART_0_INT__PS)
N#define GPIO_ISR1_FPC_UART_0_INT_PC		(GPIO_ISR1__FPC_UART_0_INT__PC)
N#define GPIO_ISR1_FPC_UART_0_INT_DR		(GPIO_ISR1__FPC_UART_0_INT__DR)
N#define GPIO_ISR1_FPC_UART_0_INT_SHIFT	(GPIO_ISR1__FPC_UART_0_INT__SHIFT)
N#define GPIO_ISR1_FPC_UART_0_INT_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__3__SHIFT*2u)))
N
N
N#endif /* End Pins GPIO_ISR1_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\GPIO_ISR1.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} GPIO_ISR1_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   GPIO_ISR1_Read(void);
Nvoid    GPIO_ISR1_Write(uint8 value);
Nuint8   GPIO_ISR1_ReadDataReg(void);
N#if defined(GPIO_ISR1__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    GPIO_ISR1_SetDriveMode(uint8 mode);
N#endif
Nvoid    GPIO_ISR1_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   GPIO_ISR1_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid GPIO_ISR1_Sleep(void); 
Nvoid GPIO_ISR1_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(GPIO_ISR1__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define GPIO_ISR1_DRIVE_MODE_BITS        (3)
N    #define GPIO_ISR1_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - GPIO_ISR1_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the GPIO_ISR1_SetDriveMode() function.
N         *  @{
N         */
N        #define GPIO_ISR1_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define GPIO_ISR1_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define GPIO_ISR1_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define GPIO_ISR1_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define GPIO_ISR1_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define GPIO_ISR1_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define GPIO_ISR1_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define GPIO_ISR1_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define GPIO_ISR1_MASK               GPIO_ISR1__MASK
N#define GPIO_ISR1_SHIFT              GPIO_ISR1__SHIFT
N#define GPIO_ISR1_WIDTH              4u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in GPIO_ISR1_SetInterruptMode() function.
N     *  @{
N     */
N        #define GPIO_ISR1_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define GPIO_ISR1_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define GPIO_ISR1_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define GPIO_ISR1_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(GPIO_ISR1__SIO)
X#if 0L
S    #define GPIO_ISR1_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(GPIO_ISR1__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define GPIO_ISR1_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define GPIO_ISR1_USBIO_DISABLE              ((uint32)(~GPIO_ISR1_USBIO_ENABLE))
S    #define GPIO_ISR1_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define GPIO_ISR1_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define GPIO_ISR1_USBIO_ENTER_SLEEP          ((uint32)((1u << GPIO_ISR1_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << GPIO_ISR1_USBIO_SUSPEND_DEL_SHIFT)))
X    #define GPIO_ISR1_USBIO_ENTER_SLEEP          ((uint32)((1u << GPIO_ISR1_USBIO_SUSPEND_SHIFT)                                                         | (1u << GPIO_ISR1_USBIO_SUSPEND_DEL_SHIFT)))
S    #define GPIO_ISR1_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << GPIO_ISR1_USBIO_SUSPEND_SHIFT)))
S    #define GPIO_ISR1_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << GPIO_ISR1_USBIO_SUSPEND_DEL_SHIFT)))
S    #define GPIO_ISR1_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(GPIO_ISR1__PC)
X#if 1L
N    /* Port Configuration */
N    #define GPIO_ISR1_PC                 (* (reg32 *) GPIO_ISR1__PC)
N#endif
N/* Pin State */
N#define GPIO_ISR1_PS                     (* (reg32 *) GPIO_ISR1__PS)
N/* Data Register */
N#define GPIO_ISR1_DR                     (* (reg32 *) GPIO_ISR1__DR)
N/* Input Buffer Disable Override */
N#define GPIO_ISR1_INP_DIS                (* (reg32 *) GPIO_ISR1__PC2)
N
N/* Interrupt configuration Registers */
N#define GPIO_ISR1_INTCFG                 (* (reg32 *) GPIO_ISR1__INTCFG)
N#define GPIO_ISR1_INTSTAT                (* (reg32 *) GPIO_ISR1__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define GPIO_ISR1_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(GPIO_ISR1__SIO)
X#if 0L
S    #define GPIO_ISR1_SIO_REG            (* (reg32 *) GPIO_ISR1__SIO)
N#endif /* (GPIO_ISR1__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(GPIO_ISR1__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define GPIO_ISR1_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define GPIO_ISR1_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define GPIO_ISR1_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define GPIO_ISR1_DRIVE_MODE_SHIFT       (0x00u)
N#define GPIO_ISR1_DRIVE_MODE_MASK        (0x07u << GPIO_ISR1_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins GPIO_ISR1_H */
N
N
N/* [] END OF FILE */
L 86 "Generated_Source\PSoC4\project.h" 2
N#include "GPIO_ISR1_aliases.h"
L 1 "Generated_Source\PSoC4\GPIO_ISR1_aliases.h" 1
N/*******************************************************************************
N* File Name: GPIO_ISR1.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_GPIO_ISR1_ALIASES_H) /* Pins GPIO_ISR1_ALIASES_H */
X#if !1L  
S#define CY_PINS_GPIO_ISR1_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define GPIO_ISR1_0			(GPIO_ISR1__0__PC)
S#define GPIO_ISR1_0_PS		(GPIO_ISR1__0__PS)
S#define GPIO_ISR1_0_PC		(GPIO_ISR1__0__PC)
S#define GPIO_ISR1_0_DR		(GPIO_ISR1__0__DR)
S#define GPIO_ISR1_0_SHIFT	(GPIO_ISR1__0__SHIFT)
S#define GPIO_ISR1_0_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__0__SHIFT*2u)))
S
S#define GPIO_ISR1_1			(GPIO_ISR1__1__PC)
S#define GPIO_ISR1_1_PS		(GPIO_ISR1__1__PS)
S#define GPIO_ISR1_1_PC		(GPIO_ISR1__1__PC)
S#define GPIO_ISR1_1_DR		(GPIO_ISR1__1__DR)
S#define GPIO_ISR1_1_SHIFT	(GPIO_ISR1__1__SHIFT)
S#define GPIO_ISR1_1_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__1__SHIFT*2u)))
S
S#define GPIO_ISR1_2			(GPIO_ISR1__2__PC)
S#define GPIO_ISR1_2_PS		(GPIO_ISR1__2__PS)
S#define GPIO_ISR1_2_PC		(GPIO_ISR1__2__PC)
S#define GPIO_ISR1_2_DR		(GPIO_ISR1__2__DR)
S#define GPIO_ISR1_2_SHIFT	(GPIO_ISR1__2__SHIFT)
S#define GPIO_ISR1_2_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__2__SHIFT*2u)))
S
S#define GPIO_ISR1_3			(GPIO_ISR1__3__PC)
S#define GPIO_ISR1_3_PS		(GPIO_ISR1__3__PS)
S#define GPIO_ISR1_3_PC		(GPIO_ISR1__3__PC)
S#define GPIO_ISR1_3_DR		(GPIO_ISR1__3__DR)
S#define GPIO_ISR1_3_SHIFT	(GPIO_ISR1__3__SHIFT)
S#define GPIO_ISR1_3_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__3__SHIFT*2u)))
S
S#define GPIO_ISR1_INTR_ALL	 ((uint16)(GPIO_ISR1_0_INTR| GPIO_ISR1_1_INTR| GPIO_ISR1_2_INTR| GPIO_ISR1_3_INTR))
S#define GPIO_ISR1_KEY_INT			(GPIO_ISR1__KEY_INT__PC)
S#define GPIO_ISR1_KEY_INT_PS		(GPIO_ISR1__KEY_INT__PS)
S#define GPIO_ISR1_KEY_INT_PC		(GPIO_ISR1__KEY_INT__PC)
S#define GPIO_ISR1_KEY_INT_DR		(GPIO_ISR1__KEY_INT__DR)
S#define GPIO_ISR1_KEY_INT_SHIFT	(GPIO_ISR1__KEY_INT__SHIFT)
S#define GPIO_ISR1_KEY_INT_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__0__SHIFT*2u)))
S
S#define GPIO_ISR1_EXT_UART_2_INT			(GPIO_ISR1__EXT_UART_2_INT__PC)
S#define GPIO_ISR1_EXT_UART_2_INT_PS		(GPIO_ISR1__EXT_UART_2_INT__PS)
S#define GPIO_ISR1_EXT_UART_2_INT_PC		(GPIO_ISR1__EXT_UART_2_INT__PC)
S#define GPIO_ISR1_EXT_UART_2_INT_DR		(GPIO_ISR1__EXT_UART_2_INT__DR)
S#define GPIO_ISR1_EXT_UART_2_INT_SHIFT	(GPIO_ISR1__EXT_UART_2_INT__SHIFT)
S#define GPIO_ISR1_EXT_UART_2_INT_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__1__SHIFT*2u)))
S
S#define GPIO_ISR1_BLE_INT			(GPIO_ISR1__BLE_INT__PC)
S#define GPIO_ISR1_BLE_INT_PS		(GPIO_ISR1__BLE_INT__PS)
S#define GPIO_ISR1_BLE_INT_PC		(GPIO_ISR1__BLE_INT__PC)
S#define GPIO_ISR1_BLE_INT_DR		(GPIO_ISR1__BLE_INT__DR)
S#define GPIO_ISR1_BLE_INT_SHIFT	(GPIO_ISR1__BLE_INT__SHIFT)
S#define GPIO_ISR1_BLE_INT_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__2__SHIFT*2u)))
S
S#define GPIO_ISR1_FPC_UART_0_INT			(GPIO_ISR1__FPC_UART_0_INT__PC)
S#define GPIO_ISR1_FPC_UART_0_INT_PS		(GPIO_ISR1__FPC_UART_0_INT__PS)
S#define GPIO_ISR1_FPC_UART_0_INT_PC		(GPIO_ISR1__FPC_UART_0_INT__PC)
S#define GPIO_ISR1_FPC_UART_0_INT_DR		(GPIO_ISR1__FPC_UART_0_INT__DR)
S#define GPIO_ISR1_FPC_UART_0_INT_SHIFT	(GPIO_ISR1__FPC_UART_0_INT__SHIFT)
S#define GPIO_ISR1_FPC_UART_0_INT_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__3__SHIFT*2u)))
S
S
N#endif /* End Pins GPIO_ISR1_ALIASES_H */
N
N
N/* [] END OF FILE */
L 87 "Generated_Source\PSoC4\project.h" 2
N#include "isr_2.h"
L 1 "Generated_Source\PSoC4\isr_2.h" 1
N/*******************************************************************************
N* File Name: isr_2.h
N* Version 1.70
N*
N*  Description:
N*   Provides the function definitions for the Interrupt Controller.
N*
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N#if !defined(CY_ISR_isr_2_H)
X#if !0L
N#define CY_ISR_isr_2_H
N
N
N#include <cytypes.h>
N#include <cyfitter.h>
N
N/* Interrupt Controller API. */
Nvoid isr_2_Start(void);
Nvoid isr_2_StartEx(cyisraddress address);
Nvoid isr_2_Stop(void);
N
NCY_ISR_PROTO(isr_2_Interrupt);
Xvoid isr_2_Interrupt (void);
N
Nvoid isr_2_SetVector(cyisraddress address);
Ncyisraddress isr_2_GetVector(void);
N
Nvoid isr_2_SetPriority(uint8 priority);
Nuint8 isr_2_GetPriority(void);
N
Nvoid isr_2_Enable(void);
Nuint8 isr_2_GetState(void);
Nvoid isr_2_Disable(void);
N
Nvoid isr_2_SetPending(void);
Nvoid isr_2_ClearPending(void);
N
N
N/* Interrupt Controller Constants */
N
N/* Address of the INTC.VECT[x] register that contains the Address of the isr_2 ISR. */
N#define isr_2_INTC_VECTOR            ((reg32 *) isr_2__INTC_VECT)
N
N/* Address of the isr_2 ISR priority. */
N#define isr_2_INTC_PRIOR             ((reg32 *) isr_2__INTC_PRIOR_REG)
N
N/* Priority of the isr_2 interrupt. */
N#define isr_2_INTC_PRIOR_NUMBER      isr_2__INTC_PRIOR_NUM
N
N/* Address of the INTC.SET_EN[x] byte to bit enable isr_2 interrupt. */
N#define isr_2_INTC_SET_EN            ((reg32 *) isr_2__INTC_SET_EN_REG)
N
N/* Address of the INTC.CLR_EN[x] register to bit clear the isr_2 interrupt. */
N#define isr_2_INTC_CLR_EN            ((reg32 *) isr_2__INTC_CLR_EN_REG)
N
N/* Address of the INTC.SET_PD[x] register to set the isr_2 interrupt state to pending. */
N#define isr_2_INTC_SET_PD            ((reg32 *) isr_2__INTC_SET_PD_REG)
N
N/* Address of the INTC.CLR_PD[x] register to clear the isr_2 interrupt. */
N#define isr_2_INTC_CLR_PD            ((reg32 *) isr_2__INTC_CLR_PD_REG)
N
N
N
N#endif /* CY_ISR_isr_2_H */
N
N
N/* [] END OF FILE */
L 88 "Generated_Source\PSoC4\project.h" 2
N#include "OP3_INT.h"
L 1 "Generated_Source\PSoC4\OP3_INT.h" 1
N/*******************************************************************************
N* File Name: OP3_INT.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_OP3_INT_H) /* Pins OP3_INT_H */
X#if !0L  
N#define CY_PINS_OP3_INT_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "OP3_INT_aliases.h"
L 1 "Generated_Source\PSoC4\OP3_INT_aliases.h" 1
N/*******************************************************************************
N* File Name: OP3_INT.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_OP3_INT_ALIASES_H) /* Pins OP3_INT_ALIASES_H */
X#if !0L  
N#define CY_PINS_OP3_INT_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define OP3_INT_0			(OP3_INT__0__PC)
N#define OP3_INT_0_PS		(OP3_INT__0__PS)
N#define OP3_INT_0_PC		(OP3_INT__0__PC)
N#define OP3_INT_0_DR		(OP3_INT__0__DR)
N#define OP3_INT_0_SHIFT	(OP3_INT__0__SHIFT)
N#define OP3_INT_0_INTR	((uint16)((uint16)0x0003u << (OP3_INT__0__SHIFT*2u)))
N
N#define OP3_INT_INTR_ALL	 ((uint16)(OP3_INT_0_INTR))
N
N
N#endif /* End Pins OP3_INT_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\OP3_INT.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} OP3_INT_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   OP3_INT_Read(void);
Nvoid    OP3_INT_Write(uint8 value);
Nuint8   OP3_INT_ReadDataReg(void);
N#if defined(OP3_INT__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    OP3_INT_SetDriveMode(uint8 mode);
N#endif
Nvoid    OP3_INT_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   OP3_INT_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid OP3_INT_Sleep(void); 
Nvoid OP3_INT_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(OP3_INT__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define OP3_INT_DRIVE_MODE_BITS        (3)
N    #define OP3_INT_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - OP3_INT_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the OP3_INT_SetDriveMode() function.
N         *  @{
N         */
N        #define OP3_INT_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define OP3_INT_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define OP3_INT_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define OP3_INT_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define OP3_INT_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define OP3_INT_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define OP3_INT_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define OP3_INT_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define OP3_INT_MASK               OP3_INT__MASK
N#define OP3_INT_SHIFT              OP3_INT__SHIFT
N#define OP3_INT_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in OP3_INT_SetInterruptMode() function.
N     *  @{
N     */
N        #define OP3_INT_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define OP3_INT_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define OP3_INT_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define OP3_INT_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(OP3_INT__SIO)
X#if 0L
S    #define OP3_INT_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(OP3_INT__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define OP3_INT_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define OP3_INT_USBIO_DISABLE              ((uint32)(~OP3_INT_USBIO_ENABLE))
S    #define OP3_INT_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define OP3_INT_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define OP3_INT_USBIO_ENTER_SLEEP          ((uint32)((1u << OP3_INT_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << OP3_INT_USBIO_SUSPEND_DEL_SHIFT)))
X    #define OP3_INT_USBIO_ENTER_SLEEP          ((uint32)((1u << OP3_INT_USBIO_SUSPEND_SHIFT)                                                         | (1u << OP3_INT_USBIO_SUSPEND_DEL_SHIFT)))
S    #define OP3_INT_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << OP3_INT_USBIO_SUSPEND_SHIFT)))
S    #define OP3_INT_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << OP3_INT_USBIO_SUSPEND_DEL_SHIFT)))
S    #define OP3_INT_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(OP3_INT__PC)
X#if 1L
N    /* Port Configuration */
N    #define OP3_INT_PC                 (* (reg32 *) OP3_INT__PC)
N#endif
N/* Pin State */
N#define OP3_INT_PS                     (* (reg32 *) OP3_INT__PS)
N/* Data Register */
N#define OP3_INT_DR                     (* (reg32 *) OP3_INT__DR)
N/* Input Buffer Disable Override */
N#define OP3_INT_INP_DIS                (* (reg32 *) OP3_INT__PC2)
N
N/* Interrupt configuration Registers */
N#define OP3_INT_INTCFG                 (* (reg32 *) OP3_INT__INTCFG)
N#define OP3_INT_INTSTAT                (* (reg32 *) OP3_INT__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define OP3_INT_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(OP3_INT__SIO)
X#if 0L
S    #define OP3_INT_SIO_REG            (* (reg32 *) OP3_INT__SIO)
N#endif /* (OP3_INT__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(OP3_INT__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define OP3_INT_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define OP3_INT_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define OP3_INT_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define OP3_INT_DRIVE_MODE_SHIFT       (0x00u)
N#define OP3_INT_DRIVE_MODE_MASK        (0x07u << OP3_INT_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins OP3_INT_H */
N
N
N/* [] END OF FILE */
L 89 "Generated_Source\PSoC4\project.h" 2
N#include "OP3_INT_aliases.h"
L 1 "Generated_Source\PSoC4\OP3_INT_aliases.h" 1
N/*******************************************************************************
N* File Name: OP3_INT.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_OP3_INT_ALIASES_H) /* Pins OP3_INT_ALIASES_H */
X#if !1L  
S#define CY_PINS_OP3_INT_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define OP3_INT_0			(OP3_INT__0__PC)
S#define OP3_INT_0_PS		(OP3_INT__0__PS)
S#define OP3_INT_0_PC		(OP3_INT__0__PC)
S#define OP3_INT_0_DR		(OP3_INT__0__DR)
S#define OP3_INT_0_SHIFT	(OP3_INT__0__SHIFT)
S#define OP3_INT_0_INTR	((uint16)((uint16)0x0003u << (OP3_INT__0__SHIFT*2u)))
S
S#define OP3_INT_INTR_ALL	 ((uint16)(OP3_INT_0_INTR))
S
S
N#endif /* End Pins OP3_INT_ALIASES_H */
N
N
N/* [] END OF FILE */
L 90 "Generated_Source\PSoC4\project.h" 2
N#include "OP1_INT.h"
L 1 "Generated_Source\PSoC4\OP1_INT.h" 1
N/*******************************************************************************
N* File Name: OP1_INT.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_OP1_INT_H) /* Pins OP1_INT_H */
X#if !0L  
N#define CY_PINS_OP1_INT_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "OP1_INT_aliases.h"
L 1 "Generated_Source\PSoC4\OP1_INT_aliases.h" 1
N/*******************************************************************************
N* File Name: OP1_INT.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_OP1_INT_ALIASES_H) /* Pins OP1_INT_ALIASES_H */
X#if !0L  
N#define CY_PINS_OP1_INT_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define OP1_INT_0			(OP1_INT__0__PC)
N#define OP1_INT_0_PS		(OP1_INT__0__PS)
N#define OP1_INT_0_PC		(OP1_INT__0__PC)
N#define OP1_INT_0_DR		(OP1_INT__0__DR)
N#define OP1_INT_0_SHIFT	(OP1_INT__0__SHIFT)
N#define OP1_INT_0_INTR	((uint16)((uint16)0x0003u << (OP1_INT__0__SHIFT*2u)))
N
N#define OP1_INT_INTR_ALL	 ((uint16)(OP1_INT_0_INTR))
N
N
N#endif /* End Pins OP1_INT_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\OP1_INT.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} OP1_INT_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   OP1_INT_Read(void);
Nvoid    OP1_INT_Write(uint8 value);
Nuint8   OP1_INT_ReadDataReg(void);
N#if defined(OP1_INT__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    OP1_INT_SetDriveMode(uint8 mode);
N#endif
Nvoid    OP1_INT_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   OP1_INT_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid OP1_INT_Sleep(void); 
Nvoid OP1_INT_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(OP1_INT__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define OP1_INT_DRIVE_MODE_BITS        (3)
N    #define OP1_INT_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - OP1_INT_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the OP1_INT_SetDriveMode() function.
N         *  @{
N         */
N        #define OP1_INT_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define OP1_INT_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define OP1_INT_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define OP1_INT_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define OP1_INT_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define OP1_INT_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define OP1_INT_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define OP1_INT_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define OP1_INT_MASK               OP1_INT__MASK
N#define OP1_INT_SHIFT              OP1_INT__SHIFT
N#define OP1_INT_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in OP1_INT_SetInterruptMode() function.
N     *  @{
N     */
N        #define OP1_INT_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define OP1_INT_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define OP1_INT_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define OP1_INT_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(OP1_INT__SIO)
X#if 0L
S    #define OP1_INT_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(OP1_INT__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define OP1_INT_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define OP1_INT_USBIO_DISABLE              ((uint32)(~OP1_INT_USBIO_ENABLE))
S    #define OP1_INT_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define OP1_INT_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define OP1_INT_USBIO_ENTER_SLEEP          ((uint32)((1u << OP1_INT_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << OP1_INT_USBIO_SUSPEND_DEL_SHIFT)))
X    #define OP1_INT_USBIO_ENTER_SLEEP          ((uint32)((1u << OP1_INT_USBIO_SUSPEND_SHIFT)                                                         | (1u << OP1_INT_USBIO_SUSPEND_DEL_SHIFT)))
S    #define OP1_INT_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << OP1_INT_USBIO_SUSPEND_SHIFT)))
S    #define OP1_INT_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << OP1_INT_USBIO_SUSPEND_DEL_SHIFT)))
S    #define OP1_INT_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(OP1_INT__PC)
X#if 1L
N    /* Port Configuration */
N    #define OP1_INT_PC                 (* (reg32 *) OP1_INT__PC)
N#endif
N/* Pin State */
N#define OP1_INT_PS                     (* (reg32 *) OP1_INT__PS)
N/* Data Register */
N#define OP1_INT_DR                     (* (reg32 *) OP1_INT__DR)
N/* Input Buffer Disable Override */
N#define OP1_INT_INP_DIS                (* (reg32 *) OP1_INT__PC2)
N
N/* Interrupt configuration Registers */
N#define OP1_INT_INTCFG                 (* (reg32 *) OP1_INT__INTCFG)
N#define OP1_INT_INTSTAT                (* (reg32 *) OP1_INT__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define OP1_INT_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(OP1_INT__SIO)
X#if 0L
S    #define OP1_INT_SIO_REG            (* (reg32 *) OP1_INT__SIO)
N#endif /* (OP1_INT__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(OP1_INT__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define OP1_INT_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define OP1_INT_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define OP1_INT_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define OP1_INT_DRIVE_MODE_SHIFT       (0x00u)
N#define OP1_INT_DRIVE_MODE_MASK        (0x07u << OP1_INT_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins OP1_INT_H */
N
N
N/* [] END OF FILE */
L 91 "Generated_Source\PSoC4\project.h" 2
N#include "OP1_INT_aliases.h"
L 1 "Generated_Source\PSoC4\OP1_INT_aliases.h" 1
N/*******************************************************************************
N* File Name: OP1_INT.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_OP1_INT_ALIASES_H) /* Pins OP1_INT_ALIASES_H */
X#if !1L  
S#define CY_PINS_OP1_INT_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define OP1_INT_0			(OP1_INT__0__PC)
S#define OP1_INT_0_PS		(OP1_INT__0__PS)
S#define OP1_INT_0_PC		(OP1_INT__0__PC)
S#define OP1_INT_0_DR		(OP1_INT__0__DR)
S#define OP1_INT_0_SHIFT	(OP1_INT__0__SHIFT)
S#define OP1_INT_0_INTR	((uint16)((uint16)0x0003u << (OP1_INT__0__SHIFT*2u)))
S
S#define OP1_INT_INTR_ALL	 ((uint16)(OP1_INT_0_INTR))
S
S
N#endif /* End Pins OP1_INT_ALIASES_H */
N
N
N/* [] END OF FILE */
L 92 "Generated_Source\PSoC4\project.h" 2
N#include "COVER_CHK_INT.h"
L 1 "Generated_Source\PSoC4\COVER_CHK_INT.h" 1
N/*******************************************************************************
N* File Name: COVER_CHK_INT.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_COVER_CHK_INT_H) /* Pins COVER_CHK_INT_H */
X#if !0L  
N#define CY_PINS_COVER_CHK_INT_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "COVER_CHK_INT_aliases.h"
L 1 "Generated_Source\PSoC4\COVER_CHK_INT_aliases.h" 1
N/*******************************************************************************
N* File Name: COVER_CHK_INT.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_COVER_CHK_INT_ALIASES_H) /* Pins COVER_CHK_INT_ALIASES_H */
X#if !0L  
N#define CY_PINS_COVER_CHK_INT_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define COVER_CHK_INT_0			(COVER_CHK_INT__0__PC)
N#define COVER_CHK_INT_0_PS		(COVER_CHK_INT__0__PS)
N#define COVER_CHK_INT_0_PC		(COVER_CHK_INT__0__PC)
N#define COVER_CHK_INT_0_DR		(COVER_CHK_INT__0__DR)
N#define COVER_CHK_INT_0_SHIFT	(COVER_CHK_INT__0__SHIFT)
N#define COVER_CHK_INT_0_INTR	((uint16)((uint16)0x0003u << (COVER_CHK_INT__0__SHIFT*2u)))
N
N#define COVER_CHK_INT_INTR_ALL	 ((uint16)(COVER_CHK_INT_0_INTR))
N
N
N#endif /* End Pins COVER_CHK_INT_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\COVER_CHK_INT.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} COVER_CHK_INT_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   COVER_CHK_INT_Read(void);
Nvoid    COVER_CHK_INT_Write(uint8 value);
Nuint8   COVER_CHK_INT_ReadDataReg(void);
N#if defined(COVER_CHK_INT__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    COVER_CHK_INT_SetDriveMode(uint8 mode);
N#endif
Nvoid    COVER_CHK_INT_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   COVER_CHK_INT_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid COVER_CHK_INT_Sleep(void); 
Nvoid COVER_CHK_INT_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(COVER_CHK_INT__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define COVER_CHK_INT_DRIVE_MODE_BITS        (3)
N    #define COVER_CHK_INT_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - COVER_CHK_INT_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the COVER_CHK_INT_SetDriveMode() function.
N         *  @{
N         */
N        #define COVER_CHK_INT_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define COVER_CHK_INT_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define COVER_CHK_INT_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define COVER_CHK_INT_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define COVER_CHK_INT_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define COVER_CHK_INT_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define COVER_CHK_INT_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define COVER_CHK_INT_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define COVER_CHK_INT_MASK               COVER_CHK_INT__MASK
N#define COVER_CHK_INT_SHIFT              COVER_CHK_INT__SHIFT
N#define COVER_CHK_INT_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in COVER_CHK_INT_SetInterruptMode() function.
N     *  @{
N     */
N        #define COVER_CHK_INT_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define COVER_CHK_INT_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define COVER_CHK_INT_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define COVER_CHK_INT_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(COVER_CHK_INT__SIO)
X#if 0L
S    #define COVER_CHK_INT_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(COVER_CHK_INT__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define COVER_CHK_INT_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define COVER_CHK_INT_USBIO_DISABLE              ((uint32)(~COVER_CHK_INT_USBIO_ENABLE))
S    #define COVER_CHK_INT_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define COVER_CHK_INT_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define COVER_CHK_INT_USBIO_ENTER_SLEEP          ((uint32)((1u << COVER_CHK_INT_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << COVER_CHK_INT_USBIO_SUSPEND_DEL_SHIFT)))
X    #define COVER_CHK_INT_USBIO_ENTER_SLEEP          ((uint32)((1u << COVER_CHK_INT_USBIO_SUSPEND_SHIFT)                                                         | (1u << COVER_CHK_INT_USBIO_SUSPEND_DEL_SHIFT)))
S    #define COVER_CHK_INT_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << COVER_CHK_INT_USBIO_SUSPEND_SHIFT)))
S    #define COVER_CHK_INT_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << COVER_CHK_INT_USBIO_SUSPEND_DEL_SHIFT)))
S    #define COVER_CHK_INT_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(COVER_CHK_INT__PC)
X#if 1L
N    /* Port Configuration */
N    #define COVER_CHK_INT_PC                 (* (reg32 *) COVER_CHK_INT__PC)
N#endif
N/* Pin State */
N#define COVER_CHK_INT_PS                     (* (reg32 *) COVER_CHK_INT__PS)
N/* Data Register */
N#define COVER_CHK_INT_DR                     (* (reg32 *) COVER_CHK_INT__DR)
N/* Input Buffer Disable Override */
N#define COVER_CHK_INT_INP_DIS                (* (reg32 *) COVER_CHK_INT__PC2)
N
N/* Interrupt configuration Registers */
N#define COVER_CHK_INT_INTCFG                 (* (reg32 *) COVER_CHK_INT__INTCFG)
N#define COVER_CHK_INT_INTSTAT                (* (reg32 *) COVER_CHK_INT__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define COVER_CHK_INT_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(COVER_CHK_INT__SIO)
X#if 0L
S    #define COVER_CHK_INT_SIO_REG            (* (reg32 *) COVER_CHK_INT__SIO)
N#endif /* (COVER_CHK_INT__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(COVER_CHK_INT__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define COVER_CHK_INT_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define COVER_CHK_INT_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define COVER_CHK_INT_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define COVER_CHK_INT_DRIVE_MODE_SHIFT       (0x00u)
N#define COVER_CHK_INT_DRIVE_MODE_MASK        (0x07u << COVER_CHK_INT_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins COVER_CHK_INT_H */
N
N
N/* [] END OF FILE */
L 93 "Generated_Source\PSoC4\project.h" 2
N#include "COVER_CHK_INT_aliases.h"
L 1 "Generated_Source\PSoC4\COVER_CHK_INT_aliases.h" 1
N/*******************************************************************************
N* File Name: COVER_CHK_INT.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_COVER_CHK_INT_ALIASES_H) /* Pins COVER_CHK_INT_ALIASES_H */
X#if !1L  
S#define CY_PINS_COVER_CHK_INT_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define COVER_CHK_INT_0			(COVER_CHK_INT__0__PC)
S#define COVER_CHK_INT_0_PS		(COVER_CHK_INT__0__PS)
S#define COVER_CHK_INT_0_PC		(COVER_CHK_INT__0__PC)
S#define COVER_CHK_INT_0_DR		(COVER_CHK_INT__0__DR)
S#define COVER_CHK_INT_0_SHIFT	(COVER_CHK_INT__0__SHIFT)
S#define COVER_CHK_INT_0_INTR	((uint16)((uint16)0x0003u << (COVER_CHK_INT__0__SHIFT*2u)))
S
S#define COVER_CHK_INT_INTR_ALL	 ((uint16)(COVER_CHK_INT_0_INTR))
S
S
N#endif /* End Pins COVER_CHK_INT_ALIASES_H */
N
N
N/* [] END OF FILE */
L 94 "Generated_Source\PSoC4\project.h" 2
N#include "isr_wdt.h"
L 1 "Generated_Source\PSoC4\isr_wdt.h" 1
N/*******************************************************************************
N* File Name: isr_wdt.h
N* Version 1.70
N*
N*  Description:
N*   Provides the function definitions for the Interrupt Controller.
N*
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N#if !defined(CY_ISR_isr_wdt_H)
X#if !0L
N#define CY_ISR_isr_wdt_H
N
N
N#include <cytypes.h>
N#include <cyfitter.h>
N
N/* Interrupt Controller API. */
Nvoid isr_wdt_Start(void);
Nvoid isr_wdt_StartEx(cyisraddress address);
Nvoid isr_wdt_Stop(void);
N
NCY_ISR_PROTO(isr_wdt_Interrupt);
Xvoid isr_wdt_Interrupt (void);
N
Nvoid isr_wdt_SetVector(cyisraddress address);
Ncyisraddress isr_wdt_GetVector(void);
N
Nvoid isr_wdt_SetPriority(uint8 priority);
Nuint8 isr_wdt_GetPriority(void);
N
Nvoid isr_wdt_Enable(void);
Nuint8 isr_wdt_GetState(void);
Nvoid isr_wdt_Disable(void);
N
Nvoid isr_wdt_SetPending(void);
Nvoid isr_wdt_ClearPending(void);
N
N
N/* Interrupt Controller Constants */
N
N/* Address of the INTC.VECT[x] register that contains the Address of the isr_wdt ISR. */
N#define isr_wdt_INTC_VECTOR            ((reg32 *) isr_wdt__INTC_VECT)
N
N/* Address of the isr_wdt ISR priority. */
N#define isr_wdt_INTC_PRIOR             ((reg32 *) isr_wdt__INTC_PRIOR_REG)
N
N/* Priority of the isr_wdt interrupt. */
N#define isr_wdt_INTC_PRIOR_NUMBER      isr_wdt__INTC_PRIOR_NUM
N
N/* Address of the INTC.SET_EN[x] byte to bit enable isr_wdt interrupt. */
N#define isr_wdt_INTC_SET_EN            ((reg32 *) isr_wdt__INTC_SET_EN_REG)
N
N/* Address of the INTC.CLR_EN[x] register to bit clear the isr_wdt interrupt. */
N#define isr_wdt_INTC_CLR_EN            ((reg32 *) isr_wdt__INTC_CLR_EN_REG)
N
N/* Address of the INTC.SET_PD[x] register to set the isr_wdt interrupt state to pending. */
N#define isr_wdt_INTC_SET_PD            ((reg32 *) isr_wdt__INTC_SET_PD_REG)
N
N/* Address of the INTC.CLR_PD[x] register to clear the isr_wdt interrupt. */
N#define isr_wdt_INTC_CLR_PD            ((reg32 *) isr_wdt__INTC_CLR_PD_REG)
N
N
N
N#endif /* CY_ISR_isr_wdt_H */
N
N
N/* [] END OF FILE */
L 95 "Generated_Source\PSoC4\project.h" 2
N#include "RTC_1.h"
L 1 "Generated_Source\PSoC4\RTC_1.h" 1
N/***************************************************************************//**
N* \file Name: RTC_1.h
N* \version 1.30
N*
N*  This file provides constants and parameter values for the RTC_P4 Component.
N*
N********************************************************************************
N* Copyright 2015-2017, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_RTC_P4_RTC_1_H)
X#if !0L
N#define CY_RTC_P4_RTC_1_H
N
N#include <cytypes.h>
N#include <CyLib.h>
N
N
N/*******************************************************************************
N*    Data types definition
N*******************************************************************************/
N/**
N* \addtogroup group_enums
N* \{
N*/
N/** Daylight saving Time format enumeration */
Ntypedef enum
N{
N    RTC_1_DST_DATE_RELATIVE = 0u,  /**< Relative DST format */
N    RTC_1_DST_DATE_FIXED = 1u      /**< Fixed DST format */
N}RTC_1_DST_DATETYPE_ENUM;
N/** \} group_enums */
N
N/**
N* \addtogroup group_structures
N* \{
N*/
N
N/** RTC_1_DATE_TIME structure is the data structure that is used to 
N* save the current time and date (RTC_currentTimeDate), and Alarm time and date 
N*(RTC_alarmCfgTimeDate)
N*
N*/
Ntypedef struct
N{
N    uint32 time;        /**< Time in the format used in API*/
N    uint32 date;        /**< Date in the format used in API*/
N    uint32 dayOfWeek;   /**< Day of the week, see \ref group_rtc_day_of_the_week */
N    uint32 status;      /**< RTC status, see \ref group_rtc_status */
N}RTC_1_DATE_TIME;
N
N/*
N* RTC_1_DST_TIME structure is the data structure that is used to 
N* save time and date values for Daylight Savings Time Start and Stop 
N* (RTC_dstTimeDateStart and RTC_dstTimeDateStop)
N*/
Ntypedef struct
N{
N    uint32 hour;          /**< Hour value */
N    uint32 dayOfWeek;     /**< Day of the week, see \ref group_rtc_day_of_the_week */
N    uint32 dayOfMonth;    /**< Day of the month */
N    uint32 weekOfMonth;   /**< Week of the month, see \ref group_rtc_dst_week_of_month */
N    uint32 month;         /**< Month value, see \ref group_rtc_month */
N    uint8  timeFormat;    /**< The DST operation mode, see \ref 
N                               RTC_1_DST_DATETYPE_ENUM */
N}RTC_1_DST_TIME;
N/** \} group_structures */
N
N/*******************************************************************************
N*    Enumerated Types and Parameters
N*******************************************************************************/
N/* Time Format setting constants */
N#define RTC_1__HOUR_12 1
N#define RTC_1__HOUR_24 0
N
N/*  Date Format setting constants */
N#define RTC_1__MM_DD_YYYY 0
N#define RTC_1__DD_MM_YYYY 1
N#define RTC_1__YYYY_MM_DD 2
N
N/* Date Type setting constants */
N#define RTC_1__RELATIVE 0
N#define RTC_1__FIXED 1
N
N/* DST Hour setting constants */
N#define RTC_1__H0000 0
N#define RTC_1__H0100 1
N#define RTC_1__H0200 2
N#define RTC_1__H0300 3
N#define RTC_1__H0400 4
N#define RTC_1__H0500 5
N#define RTC_1__H0600 6
N#define RTC_1__H0700 7
N#define RTC_1__H0800 8
N#define RTC_1__H0900 9
N#define RTC_1__H1000 10
N#define RTC_1__H1100 11
N#define RTC_1__H1200 12
N#define RTC_1__H1300 13
N#define RTC_1__H1400 14
N#define RTC_1__H1500 15
N#define RTC_1__H1600 16
N#define RTC_1__H1700 17
N#define RTC_1__H1800 18
N#define RTC_1__H1900 19
N#define RTC_1__H2000 20
N#define RTC_1__H2100 21
N#define RTC_1__H2200 22
N#define RTC_1__H2300 23
N
N/* DST DayOfWeek setting constants */
N#define RTC_1__SUNDAY 1
N#define RTC_1__MONDAY 2
N#define RTC_1__TUESDAY 3
N#define RTC_1__WEDNESDAY 4
N#define RTC_1__THURSDAY 5
N#define RTC_1__FRIDAY 6
N#define RTC_1__SATURDAY 7
N
N/* DST Month setting constants */
N#define RTC_1__JAN 1
N#define RTC_1__FEB 2
N#define RTC_1__MAR 3
N#define RTC_1__APR 4
N#define RTC_1__MAY 5
N#define RTC_1__JUN 6
N#define RTC_1__JUL 7
N#define RTC_1__AUG 8
N#define RTC_1__SEP 9
N#define RTC_1__OCT 10
N#define RTC_1__NOV 11
N#define RTC_1__DEC 12
N
N/* DST WeekOfMonth setting constants */
N#define RTC_1__FIRST 1
N#define RTC_1__SECOND 2
N#define RTC_1__THIRD 3
N#define RTC_1__FOURTH 4
N#define RTC_1__FIFTH 5
N#define RTC_1__LAST 6
N
N
N#define RTC_1_INITIAL_DATA_FORMAT     (0u)
N#define RTC_1_INITIAL_TIME_FORMAT     (1u)
N#define RTC_1_INITIAL_UPDATE_MODE     (0u)
N#define RTC_1_INITIAL_SECOND          (0u)
N#define RTC_1_INITIAL_MINUTE          (0u)
N#define RTC_1_INITIAL_HOUR            (0u)
N#define RTC_1_INITIAL_DAY             (1u)
N#define RTC_1_INITIAL_MONTH           (1u)
N#define RTC_1_INITIAL_YEAR            (1970u)
N
N#define RTC_1_INITIAL_ALARM_STATUS    (0u)
N
N#define RTC_1_INITIAL_DST_STATUS      (0u)
N#define RTC_1_INITIAL_DST_DATE_TYPE   (0u)
N#define RTC_1_INITIAL_DST_START_MONTH (3uL)
N#define RTC_1_INITIAL_DST_START_WOM   (6uL)
N#define RTC_1_INITIAL_DST_START_DOM   (22uL)
N#define RTC_1_INITIAL_DST_START_DOW   (1uL)
N#define RTC_1_INITIAL_DST_START_HRS   (0uL)
N#define RTC_1_INITIAL_DST_STOP_MONTH  (10uL)
N#define RTC_1_INITIAL_DST_STOP_DOM    (22uL)
N#define RTC_1_INITIAL_DST_STOP_DOW    (1uL)
N#define RTC_1_INITIAL_DST_STOP_WOM    (6uL)
N#define RTC_1_INITIAL_DST_STOP_HRS    (0uL)
N
N/**
N* \addtogroup group_constants
N* \{
N*/
N
N/**
N* \defgroup group_rtc_day_of_the_week Day of the week definitions
N* \{
N* Definitions of days in the week
N*/
N#define RTC_1_SUNDAY     (RTC_1__SUNDAY)       /**< Sequential number of Sunday in the week */
N#define RTC_1_MONDAY     (RTC_1__MONDAY)       /**< Sequential number of Monday in the week */
N#define RTC_1_TUESDAY    (RTC_1__TUESDAY)      /**< Sequential number of Tuesday in the week */
N#define RTC_1_WEDNESDAY  (RTC_1__WEDNESDAY)    /**< Sequential number of Wednesday in the week */
N#define RTC_1_THURSDAY   (RTC_1__THURSDAY)     /**< Sequential number of Thursday in the week */
N#define RTC_1_FRIDAY     (RTC_1__FRIDAY)       /**< Sequential number of Friday in the week */
N#define RTC_1_SATURDAY   (RTC_1__SATURDAY)     /**< Sequential number of Saturday in the week */
N/** \} group_rtc_day_of_the_week */
N
N/**
N* \defgroup group_rtc_dst_week_of_month DST Week of month setting constants definitions
N* \{
N* Week of month setting constants definitions for Daylight Saving Time feature
N*/
N#define RTC_1_FIRST      (RTC_1__FIRST)   /**< First week in the month */
N#define RTC_1_SECOND     (RTC_1__SECOND)  /**< Second week in the month  */
N#define RTC_1_THIRD      (RTC_1__THIRD)   /**< Third week in the month  */
N#define RTC_1_FOURTH     (RTC_1__FOURTH)  /**< Fourth week in the month  */
N#define RTC_1_FIFTH      (RTC_1__FIFTH)   /**< Fifth week in the month  */
N#define RTC_1_LAST       (RTC_1__LAST)    /**< Last week in the month  */
N/** \} group_rtc_dst_week_of_month */
N
N/**
N* \defgroup group_rtc_month Month definitions
N* \{
N* Constants definition for Months
N*/
N#define RTC_1_JANUARY    (RTC_1__JAN)    /**< Sequential number of January in the year */
N#define RTC_1_FEBRUARY   (RTC_1__FEB)    /**< Sequential number of February in the year */
N#define RTC_1_MARCH      (RTC_1__MAR)    /**< Sequential number of March in the year */
N#define RTC_1_APRIL      (RTC_1__APR)    /**< Sequential number of April in the year */
N#define RTC_1_MAY        (RTC_1__MAY)    /**< Sequential number of May in the year */
N#define RTC_1_JUNE       (RTC_1__JUN)    /**< Sequential number of June in the year */
N#define RTC_1_JULY       (RTC_1__JUL)    /**< Sequential number of July in the year */
N#define RTC_1_AUGUST     (RTC_1__AUG)    /**< Sequential number of August in the year */
N#define RTC_1_SEPTEMBER  (RTC_1__SEP)    /**< Sequential number of September in the year */
N#define RTC_1_OCTOBER    (RTC_1__OCT)    /**< Sequential number of October in the year */
N#define RTC_1_NOVEMBER   (RTC_1__NOV)    /**< Sequential number of November in the year */
N#define RTC_1_DECEMBER   (RTC_1__DEC)    /**< Sequential number of December in the year */
N/** \} group_rtc_month */
N
N/**
N* \defgroup group_rtc_am_pm AM/PM status definitions
N* \{
N* Definitions for 12 hour format for indicating the AM/PM period of day
N*/
N#define RTC_1_AM                 (0u)    /**< AM period of day */
N#define RTC_1_PM                 (1u)    /**< PM period of day */
N/** \} group_rtc_am_pm */
N
N/**
N* \defgroup group_rtc_hour_format Hour format definitions
N* \{
N* Definitions for hour format
N*/
N#define RTC_1_12_HOURS_FORMAT    (RTC_1__HOUR_12) /**< The 12 hour (AM/PM) format */
N#define RTC_1_24_HOURS_FORMAT    (RTC_1__HOUR_24) /**< The 24 hour format */
N/** \} group_rtc_hour_format */
N
N/**
N* \defgroup group_rtc_days_in_month Number of days in month definitions
N* \{
N* Definition of days in current month
N*/
N#define RTC_1_DAYS_IN_JANUARY     (31u)    /**< Number of days in January  */
N#define RTC_1_DAYS_IN_FEBRUARY    (28u)    /**< Number of days in February */
N#define RTC_1_DAYS_IN_MARCH       (31u)    /**< Number of days in March */
N#define RTC_1_DAYS_IN_APRIL       (30u)    /**< Number of days in April */
N#define RTC_1_DAYS_IN_MAY         (31u)    /**< Number of days in May */
N#define RTC_1_DAYS_IN_JUNE        (30u)    /**< Number of days in June */
N#define RTC_1_DAYS_IN_JULY        (31u)    /**< Number of days in July */
N#define RTC_1_DAYS_IN_AUGUST      (31u)    /**< Number of days in August */
N#define RTC_1_DAYS_IN_SEPTEMBER   (30u)    /**< Number of days in September */
N#define RTC_1_DAYS_IN_OCTOBER     (31u)    /**< Number of days in October */
N#define RTC_1_DAYS_IN_NOVEMBER    (30u)    /**< Number of days in November */
N#define RTC_1_DAYS_IN_DECEMBER    (31u)    /**< Number of days in December */
N/** \} group_rtc_days_in_month */
N
N/**
N* \defgroup group_rtc_status Definitions of the RTC status values
N* \{
N* Definitions for status software register, which has flags for DST (DST),
N* Leap Year (LY), AM/PM (AM_PM).
N*/
N
N/** Status of Daylight Saving Time. This bit
N* goes high when the current time and date match the DST time and date and the 
N* time is incremented. This bit goes low after the DST interval and the time is 
N* decremented.
N*/
N#define RTC_1_STATUS_DST     (1uL << RTC_1_STATUS_DST_OFFSET)
N
N/** Status of Leap Year. This bit goes high when the current year is a leap year */
N#define RTC_1_STATUS_LY      (1uL << RTC_1_STATUS_LY_OFFSET)
N
N/** Status of Current Time. This bit is low from midnight to noon and high from 
N*  noon to midnight. */
N#define RTC_1_STATUS_AM_PM   (1uL << RTC_1_STATUS_AM_PM_OFFSET)
N/** \} group_rtc_status */
N
N/**
N* \defgroup group_rtc_alarm_mask Definitions for Alarm Mask software register
N* \{
N* Definitions for Alarm Mask software register. These masks allow 
N* matching the alarm value register with the current value register.
N*/
N
N/** The second alarm mask allows matching the alarm second register with the 
N*   current second register.
N*/
N#define RTC_1_ALARM_SEC_MASK         (0x00000001uL)
N
N/** The minute alarm mask allows matching the alarm minute register with the 
N*   current minute register.
N*/
N#define RTC_1_ALARM_MIN_MASK         (0x00000002uL)
N
N/** The hour alarm mask allows matching the alarm hour register with the 
N*   current hour register.
N*/
N#define RTC_1_ALARM_HOUR_MASK        (0x00000004uL)
N
N/** The day of the week alarm mask allows matching the alarm hour register with 
N*   the current day of the week register.
N*/
N#define RTC_1_ALARM_DAYOFWEEK_MASK   (0x00000008uL)
N
N/** The day of the Month alarm mask allows matching the alarm hour register with 
N*   the current day of the Month register.
N*/
N#define RTC_1_ALARM_DAYOFMONTH_MASK  (0x00000010uL)
N
N/** The month alarm mask allows matching the alarm hour register with the
N*   current month register.
N*/
N#define RTC_1_ALARM_MONTH_MASK       (0x00000020uL)
N
N/** The year alarm mask allows matching the alarm hour register with the
N*   current year register.
N*/
N#define RTC_1_ALARM_YEAR_MASK        (0x00000040uL)
N
N/** \} group_rtc_alarm_mask */
N/** \} group_constants */
N
N#define RTC_1_DAYS_PER_WEEK       (7u)
N
N#define RTC_1_MONTHS_PER_YEAR     (12uL)
N
N#define RTC_1_HOURS_PER_DAY       (24uL)
N#define RTC_1_HOURS_PER_HALF_DAY  (12uL)
N
N#define RTC_1_SECONDS_PER_MINUTE  (60uL)
N#define RTC_1_SECONDS_PER_HOUR    (3600uL)
N#define RTC_1_SECONDS_PER_DAY     (24uL * 3600uL)
N
N#define RTC_1_SECONDS_PER_LEAP_YEAR    (366uL * 24uL * 3600uL)
N#define RTC_1_SECONDS_PER_NONLEAP_YEAR (365uL * 24uL * 3600uL)
N
N#define RTC_1_UNIX_TIME_PM        ((12uL * 3600uL) + 1uL)
N
N/* Unix time begins in 1970 year */
N#define RTC_1_YEAR_0             (1970u)
N
N/* Definition of date register fields */
N#if(RTC_1_INITIAL_DATA_FORMAT == RTC_1__MM_DD_YYYY)
X#if((0u) == 0)
N    #define RTC_1_10_MONTH_OFFSET   (28u)
N    #define RTC_1_MONTH_OFFSET      (24u)
N    #define RTC_1_10_DAY_OFFSET     (20u)
N    #define RTC_1_DAY_OFFSET        (16u)
N    #define RTC_1_1000_YEAR_OFFSET  (12u)
N    #define RTC_1_100_YEAR_OFFSET   (8u)
N    #define RTC_1_10_YEAR_OFFSET    (4u)
N    #define RTC_1_YEAR_OFFSET       (0u)
N#elif(RTC_1_INITIAL_DATA_FORMAT == RTC_1__DD_MM_YYYY)
S    #define RTC_1_10_MONTH_OFFSET   (20u)
S    #define RTC_1_MONTH_OFFSET      (16u)
S    #define RTC_1_10_DAY_OFFSET     (28u)
S    #define RTC_1_DAY_OFFSET        (24u)
S    #define RTC_1_1000_YEAR_OFFSET  (12u)
S    #define RTC_1_100_YEAR_OFFSET   (8u)
S    #define RTC_1_10_YEAR_OFFSET    (4u)
S    #define RTC_1_YEAR_OFFSET       (0u)
S#else
S    #define RTC_1_10_MONTH_OFFSET   (12u)
S    #define RTC_1_MONTH_OFFSET      (8u)
S    #define RTC_1_10_DAY_OFFSET     (4u)
S    #define RTC_1_DAY_OFFSET        (0u)
S    #define RTC_1_1000_YEAR_OFFSET  (28u)
S    #define RTC_1_100_YEAR_OFFSET   (24u)
S    #define RTC_1_10_YEAR_OFFSET    (20u)
S    #define RTC_1_YEAR_OFFSET       (16u)
N#endif /* (RTC_1_INITIAL_DATA_FORMAT == RTC_1__MM_DD_YYYY) */
N
N#define RTC_1_10_MONTH_MASK          (0x00000001uL << RTC_1_10_MONTH_OFFSET)
N#define RTC_1_MONTH_MASK             (0x0000000FuL << RTC_1_MONTH_OFFSET)
N#define RTC_1_10_DAY_MASK            (0x00000003uL << RTC_1_10_DAY_OFFSET)
N#define RTC_1_DAY_MASK               (0x0000000FuL << RTC_1_DAY_OFFSET)
N#define RTC_1_1000_YEAR_MASK         (0x00000003uL << RTC_1_1000_YEAR_OFFSET)
N#define RTC_1_100_YEAR_MASK          (0x0000000FuL << RTC_1_100_YEAR_OFFSET)
N#define RTC_1_10_YEAR_MASK           (0x0000000FuL << RTC_1_10_YEAR_OFFSET)
N#define RTC_1_YEAR_MASK              (0x0000000FuL << RTC_1_YEAR_OFFSET)
N
N#define  RTC_1_MONTH_FULL_MASK       (RTC_1_10_MONTH_MASK  | RTC_1_MONTH_MASK)
N#define  RTC_1_DAY_FULL_MASK         (RTC_1_10_DAY_MASK    | RTC_1_DAY_MASK)
N#define  RTC_1_YEAR_FULL_MASK        (RTC_1_1000_YEAR_MASK | RTC_1_100_YEAR_MASK |\
N                                                 RTC_1_10_YEAR_MASK   | RTC_1_YEAR_MASK)
X#define  RTC_1_YEAR_FULL_MASK        (RTC_1_1000_YEAR_MASK | RTC_1_100_YEAR_MASK |                                                 RTC_1_10_YEAR_MASK   | RTC_1_YEAR_MASK)
N
N/* Definition of time register fields */
N#define RTC_1_TIME_FORMAT_OFFSET     (23u)
N#define RTC_1_PERIOD_OF_DAY_OFFSET   (22u)
N#define RTC_1_10_HOURS_OFFSET        (20u)
N#define RTC_1_HOURS_OFFSET           (16u)
N#define RTC_1_10_MINUTES_OFFSET      (12u)
N#define RTC_1_MINUTES_OFFSET         (8u)
N#define RTC_1_10_SECONDS_OFFSET      (4u)
N#define RTC_1_SECONDS_OFFSET         (0u)
N
N#define RTC_1_TIME_FORMAT_MASK       (0x00000001uL << RTC_1_TIME_FORMAT_OFFSET)
N#define RTC_1_PERIOD_OF_DAY_MASK     (0x00000001uL << RTC_1_PERIOD_OF_DAY_OFFSET)
N#define RTC_1_10_HOURS_MASK          (0x00000003uL << RTC_1_10_HOURS_OFFSET)
N#define RTC_1_HOURS_MASK             (0x0000000FuL << RTC_1_HOURS_OFFSET)
N#define RTC_1_10_MINUTES_MASK        (0x00000007uL << RTC_1_10_MINUTES_OFFSET)
N#define RTC_1_MINUTES_MASK           (0x0000000FuL << RTC_1_MINUTES_OFFSET)
N#define RTC_1_10_SECONDS_MASK        (0x00000007uL << RTC_1_10_SECONDS_OFFSET)
N#define RTC_1_SECONDS_MASK           (0x0000000FuL << RTC_1_SECONDS_OFFSET)
N
N#define RTC_1_HOURS_FULL_MASK        (RTC_1_10_HOURS_MASK   | RTC_1_HOURS_MASK)
N#define RTC_1_MINUTES_FULL_MASK      (RTC_1_10_MINUTES_MASK | RTC_1_MINUTES_MASK)
N#define RTC_1_SECONDS_FULL_MASK      (RTC_1_10_SECONDS_MASK | RTC_1_SECONDS_MASK)
N
N#define RTC_1_STATUS_DST_OFFSET      (1u)
N#define RTC_1_STATUS_ALARM_OFFSET    (2u)
N#define RTC_1_STATUS_LY_OFFSET       (3u)
N#define RTC_1_STATUS_AM_PM_OFFSET    (4u)
N
N/* Number of bits per one BCD digit */
N#define RTC_1_BCD_NUMBER_SIZE        (4u)
N#define RTC_1_BCD_ONE_DIGIT_MASK     (0x0000000FuL)
N
N
N/*******************************************************************************
N*    External Variables
N*******************************************************************************/
N/**
N* \addtogroup group_globals
N* \{
N*/
N
N/**
N* Indicates whether the RTC has been initialized; The variable is initialized to
N* 0 and set to 1 the first time RTC_Start() is called. This allows the component
N* to restart without reinitialization after the first call to the RTC_Start() 
N* routine.
N*/
Nextern uint8  RTC_1_initVar;
N
N/** The DST start/stop status */
Nextern uint8  RTC_1_dstStatus;
N
N/**
N* The uint64 variable represents the standard Unix time (number of seconds 
N* elapsed from January 1, 1970 00:00 hours UTC) in 64-bit 
N*/
Nextern volatile uint64 RTC_1_unixTime;
N
N/** The values for the time and date of the DST start */
Nextern RTC_1_DST_TIME RTC_1_dstStartTime;
N
N/** The values for the time and date of the DST stop */
Nextern RTC_1_DST_TIME RTC_1_dstStopTime;
N
N/**
N* The last updated time and date values are stored in this structure (update 
N* happens in Get time/date APIs)
N*/
Nextern RTC_1_DATE_TIME RTC_1_currentTimeDate;
N
N/** The alarm time and date values are stored in this variable */
Nextern RTC_1_DATE_TIME RTC_1_alarmCfgTimeDate;
N
N/**
N* This variable is used to mask alarm events; mask seconds alarm, mask minutes 
N* alarm, and so on. It will have bit masks for each time item masking that item 
N* for alarm generation
N*/
Nextern uint32  RTC_1_alarmCfgMask;
N
N/**
N* This variable is used to indicate current active alarm status per time item 
N* used in the alarm; whether seconds alarm is active, minute's alarm is active, 
N* and so on. It will have bit masks for each time item (seconds, minutes, hours,
N* day, and so on) showing the status
N*/
Nextern uint32 RTC_1_alarmCurStatus;
N
N/** \} group_globals */
N
Nextern void (*RTC_1_alarmCallbackPtr)(void);
N
Nextern const uint16 RTC_1_daysBeforeMonthTbl[RTC_1_MONTHS_PER_YEAR];
Xextern const uint16 RTC_1_daysBeforeMonthTbl[(12uL)];
Nextern const uint8  RTC_1_daysInMonthTbl[RTC_1_MONTHS_PER_YEAR];
Xextern const uint8  RTC_1_daysInMonthTbl[(12uL)];
N
N
N/*******************************************************************************
N*    Function Prototypes
N*******************************************************************************/
N/**
N* \addtogroup group_general
N* \{
N*/
Nvoid   RTC_1_Start(void);
Nvoid   RTC_1_Stop(void);
Nvoid   RTC_1_Init(void);
Nvoid   RTC_1_SetUnixTime(uint64 unixTime);
Nuint64 RTC_1_GetUnixTime(void);
Nvoid   RTC_1_SetPeriod(uint32 ticks, uint32 refOneSecTicks);
Nuint32 RTC_1_GetPeriod(void);
Nuint32 RTC_1_GetRefOneSec(void);
Nvoid   RTC_1_SetDateAndTime(uint32 inputTime, uint32 inputDate);
Nvoid   RTC_1_GetDateAndTime(RTC_1_DATE_TIME* dateTime);
Nuint32 RTC_1_GetTime(void);
Nuint32 RTC_1_GetDate(void);
Nvoid   RTC_1_SetAlarmDateAndTime(const RTC_1_DATE_TIME* alarmTime);
Nvoid   RTC_1_GetAlarmDateAndTime(RTC_1_DATE_TIME* alarmTimeDate);
Nvoid   RTC_1_SetAlarmMask(uint32 mask);
Nuint32 RTC_1_GetAlarmMask(void);
Nuint32 RTC_1_ReadStatus(void);
Nuint32 RTC_1_GetAlarmStatus(void);
Nvoid   RTC_1_ClearAlarmStatus(void);
Nvoid   RTC_1_SetDSTStartTime(const RTC_1_DST_TIME* dstStartTime,
N                                              RTC_1_DST_DATETYPE_ENUM type);
Nvoid   RTC_1_SetDSTStopTime(const RTC_1_DST_TIME* dstStopTime,
N                                             RTC_1_DST_DATETYPE_ENUM type);
Nuint32 RTC_1_ConvertBCDToDec(uint32 bcdNum);
Nuint32 RTC_1_ConvertDecToBCD(uint32 decNum);
Nvoid   RTC_1_Update(void);
Nvoid*  RTC_1_SetAlarmHandler(void (*CallbackFunction)(void));
N
Nstatic uint32 RTC_1_ConstructDate(uint32 month, uint32 day, uint32 year);
Nstatic uint32 RTC_1_ConstructTime(uint32 timeFormat, uint32 stateAmPm, uint32 hour, uint32 min, uint32 sec);
N/** \} group_general */
N
Nstatic uint32 RTC_1_GetTimeFormat(uint32 inputTime);
Nstatic uint32 RTC_1_SetTimeFormat(uint32 inputTime, uint32 timeFormat);
N
N/**
N* \addtogroup group_general
N* \{
N*/
Nstatic uint32 RTC_1_LeapYear(uint32 year);
Nstatic uint32 RTC_1_IsBitSet(uint32 var, uint32 mask);
Nstatic uint32 RTC_1_GetSecond(uint32 inputTime);
Nstatic uint32 RTC_1_GetMinutes(uint32 inputTime);
Nstatic uint32 RTC_1_GetHours(uint32 inputTime);
Nstatic uint32 RTC_1_GetAmPm(uint32 inputTime);
Nstatic uint32 RTC_1_GetDay(uint32 date);
Nstatic uint32 RTC_1_GetMonth(uint32 date);
Nstatic uint32 RTC_1_GetYear(uint32 date);
N/** \} group_general */
N
Nstatic uint32 RTC_1_SetSecond(uint32 inputTime, uint32 inputSecond);
Nstatic uint32 RTC_1_SetMinutes(uint32 inputTime, uint32 inputMinute);
Nstatic uint32 RTC_1_SetHours(uint32 inputTime, uint32 inputHours);
Nstatic uint32 RTC_1_SetAmPm(uint32 inputTime, uint32 periodOfDay);
Nstatic uint32 RTC_1_SetDay(uint32 inputDate, uint32 inputDay);
Nstatic uint32 RTC_1_SetMonth(uint32 inputDate, uint32 inputMonth);
Nstatic uint32 RTC_1_SetYear(uint32 inputDate, uint32 inputYear);
N
Nuint64 RTC_1_ConstructUnixAlarmTime(const RTC_1_DATE_TIME* alarmTime, uint8 alarmCfgMask);
Nuint64 RTC_1_GetDstUnixTime(const RTC_1_DST_TIME* dstTime);
Nuint64 RTC_1_GetNexAlarmTime(uint64 curUnixTime, uint8 alarmCfgMask);
N
Nstatic uint32 RTC_1_GetNextMinSec(uint32 curVal);
Nstatic uint32 RTC_1_GetNextHour(uint32 curVal);
Nstatic uint32 RTC_1_GetNextDay(uint32 curYear, uint32 curMonth, uint32 curDay, uint32 alarmCfgMask);
Nstatic uint32 RTC_1_GetNextMonth(uint32 curMonth);
Nstatic uint32 RTC_1_GetNextYear(uint32 curYear);
Nstatic uint32 RTC_1_GetDayOfWeek(uint32 day, uint32 month, uint32 year);
Nstatic uint32 RTC_1_DaysBeforeMonth(uint32 month, uint32 year);
N
Nuint32 RTC_1_DaysInMonth(uint32 month, uint32 year);
N
N/**
N* \addtogroup group_general
N* \{
N*/
Nvoid   RTC_1_UnixToDateTime(RTC_1_DATE_TIME* dateTime, uint64 unixTime, uint32 timeFormat);
Nuint64 RTC_1_DateTimeToUnix(uint32 inputDate, uint32 inputTime);
N
N#if defined(CYDEV_RTC_SOURCE_WDT)
X#if 1L
N    #if((0u != CYDEV_WDT_GENERATE_ISR) && (0u == RTC_1_INITIAL_UPDATE_MODE))
X    #if((0u != 1u) && (0u == (0u)))
N        static void RTC_1_CySysRtcSetCallback(uint32 wdtNumber);
N        static void RTC_1_CySysRtcResetCallback(uint32 wdtNumber);
N    #endif /* ((0u != CYDEV_WDT_GENERATE_ISR) && (0u == RTC_1_INITIAL_UPDATE_MODE)) */
N#endif /* (CYDEV_RTC_SOURCE_WDT) */
N
N/** \} group_general */
N
Nuint32 RTC_1_RelativeToFixed(uint32 dayOfWeek, uint32 weekOfMonth, uint32 month, uint32 year);
N
N
N
N/*******************************************************************************
N* Function Name: RTC_1_IsBitSet
N****************************************************************************//**
N*
N* Checks the state of a bit passed through parameter.
N*
N* \param var
N* The variable to be checked.
N*
N* \param mask
N* The mask for a bit to be checked.
N*
N* \return
N*  0u - Bit is not set. <br> 1u - Bit is set.
N*
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_IsBitSet(uint32 var, uint32 mask)
Xstatic __inline uint32 RTC_1_IsBitSet(uint32 var, uint32 mask)
N{
N    return ((mask == (var & mask)) ? 1Lu : 0Lu);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_LeapYear
N****************************************************************************//**
N*
N* Checks whether the year passed through the parameter is leap or no.
N*
N* \param year
N* The year to be checked.
N*
N* \return
N* 0u - The year is not leap <br> 1u - The year is leap.
N*
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_LeapYear(uint32 year)
Xstatic __inline uint32 RTC_1_LeapYear(uint32 year)
N{
N    uint32 retVal;
N
N    if(((0u == (year % 4Lu)) && (0u != (year % 100Lu))) || (0u == (year % 400Lu)))
N    {
N        retVal = 1uL;
N    }
N    else
N    {
N        retVal = 0uL;
N    }
N
N    return(retVal);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_GetSecond
N****************************************************************************//**
N*
N* Returns the seconds value from the time value that is passed as a/the 
N* parameter.
N*
N* \param inputTime
N* The time value.
N*
N* \return
N* The seconds value.
N*
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_GetSecond(uint32 inputTime)
Xstatic __inline uint32 RTC_1_GetSecond(uint32 inputTime)
N{
N    uint32 retVal;
N
N    retVal  = ((inputTime & RTC_1_10_SECONDS_MASK) >> RTC_1_10_SECONDS_OFFSET) * 10u;
X    retVal  = ((inputTime & (0x00000007uL << (4u))) >> (4u)) * 10u;
N    retVal += (inputTime & RTC_1_SECONDS_MASK) >> RTC_1_SECONDS_OFFSET;
X    retVal += (inputTime & (0x0000000FuL << (0u))) >> (0u);
N
N    return (retVal);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_GetMinutes
N****************************************************************************//**
N*
N* Returns the minutes value from the time value that is passed as a/the 
N* parameter.
N*
N* \param inputTime
N* The time value.
N*
N* \return
N* The minutes value.
N*
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_GetMinutes(uint32 inputTime)
Xstatic __inline uint32 RTC_1_GetMinutes(uint32 inputTime)
N{
N    uint32 retVal;
N
N    retVal  = ((inputTime & RTC_1_10_MINUTES_MASK) >> RTC_1_10_MINUTES_OFFSET) * 10u;
X    retVal  = ((inputTime & (0x00000007uL << (12u))) >> (12u)) * 10u;
N    retVal += (inputTime & RTC_1_MINUTES_MASK) >> RTC_1_MINUTES_OFFSET;
X    retVal += (inputTime & (0x0000000FuL << (8u))) >> (8u);
N
N    return (retVal);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_GetHours
N****************************************************************************//**
N*
N* Returns the hours value from the time value that is passed as a/the parameter.
N*
N* \param inputTime
N* The time value.
N*
N* \return
N* The hours value.
N*
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_GetHours(uint32 inputTime)
Xstatic __inline uint32 RTC_1_GetHours(uint32 inputTime)
N{
N    uint32 retVal;
N
N    retVal  = ((inputTime & RTC_1_10_HOURS_MASK) >> RTC_1_10_HOURS_OFFSET) * 10u;
X    retVal  = ((inputTime & (0x00000003uL << (20u))) >> (20u)) * 10u;
N    retVal += (inputTime & RTC_1_HOURS_MASK) >> RTC_1_HOURS_OFFSET;
X    retVal += (inputTime & (0x0000000FuL << (16u))) >> (16u);
N
N    return (retVal);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_GetAmPm
N****************************************************************************//**
N*
N* Returns the AM/PM status from the time value that is passed as parameter.
N*
N* \param inputTime
N* The time value.
N*
N* \return
N* The am/pm period of day, see \ref group_rtc_am_pm.
N*
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_GetAmPm(uint32 inputTime)
Xstatic __inline uint32 RTC_1_GetAmPm(uint32 inputTime)
N{
N    return (RTC_1_IsBitSet(inputTime, RTC_1_PERIOD_OF_DAY_MASK));
X    return (RTC_1_IsBitSet(inputTime, (0x00000001uL << (22u))));
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_GetDay
N****************************************************************************//**
N*
N* Returns the day value from the date value that is passed as parameter.
N*
N* \param date
N* The date value.
N*
N* \return
N* The day value.
N*
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_GetDay(uint32 date)
Xstatic __inline uint32 RTC_1_GetDay(uint32 date)
N{
N    uint32 retVal;
N
N    retVal  = ((date & RTC_1_10_DAY_MASK) >> RTC_1_10_DAY_OFFSET) * 10u;
X    retVal  = ((date & (0x00000003uL << (20u))) >> (20u)) * 10u;
N    retVal += (date & RTC_1_DAY_MASK) >> RTC_1_DAY_OFFSET;
X    retVal += (date & (0x0000000FuL << (16u))) >> (16u);
N
N    return (retVal);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_GetMonth
N****************************************************************************//**
N*
N* Returns the month value from the date value that is passed as parameter.
N*
N* \param date
N* The date value.
N*
N* \return
N* The month value.
N*
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_GetMonth(uint32 date)
Xstatic __inline uint32 RTC_1_GetMonth(uint32 date)
N{
N    uint32 retVal;
N
N    retVal  = ((date & RTC_1_10_MONTH_MASK) >> RTC_1_10_MONTH_OFFSET) * 10u;
X    retVal  = ((date & (0x00000001uL << (28u))) >> (28u)) * 10u;
N    retVal += (date & RTC_1_MONTH_MASK) >> RTC_1_MONTH_OFFSET;
X    retVal += (date & (0x0000000FuL << (24u))) >> (24u);
N
N    return (retVal);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_GetYear
N****************************************************************************//**
N*
N* Returns the year value from the date value that is passed as parameter.
N*
N* \param date
N* The date value.
N*
N* \return
N* The year value.
N*
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_GetYear(uint32 date)
Xstatic __inline uint32 RTC_1_GetYear(uint32 date)
N{
N    uint32 retVal;
N
N    retVal  = ((date & RTC_1_1000_YEAR_MASK) >> RTC_1_1000_YEAR_OFFSET) * 1000u;
X    retVal  = ((date & (0x00000003uL << (12u))) >> (12u)) * 1000u;
N    retVal += ((date & RTC_1_100_YEAR_MASK) >> RTC_1_100_YEAR_OFFSET) * 100u;
X    retVal += ((date & (0x0000000FuL << (8u))) >> (8u)) * 100u;
N    retVal += ((date & RTC_1_10_YEAR_MASK) >> RTC_1_10_YEAR_OFFSET) * 10u;
X    retVal += ((date & (0x0000000FuL << (4u))) >> (4u)) * 10u;
N    retVal += (date & RTC_1_YEAR_MASK) >> RTC_1_YEAR_OFFSET;
X    retVal += (date & (0x0000000FuL << (0u))) >> (0u);
N
N    return (retVal);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_SetSecond
N****************************************************************************//**
N* \internal
N* Updates the time with the new second value.
N*
N* \param inputTime
N* The current date.
N*
N* \param inputSecond
N* The seconds value to be set to the time variable.
N*
N* \return
N* The updated time variable.
N* \endinternal
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_SetSecond(uint32 inputTime, uint32 inputSecond)
Xstatic __inline uint32 RTC_1_SetSecond(uint32 inputTime, uint32 inputSecond)
N{
N    inputTime &= ~(RTC_1_SECONDS_FULL_MASK);
X    inputTime &= ~(((0x00000007uL << (4u)) | (0x0000000FuL << (0u))));
N
N    inputTime |= (inputSecond / 10u) << RTC_1_10_SECONDS_OFFSET;
X    inputTime |= (inputSecond / 10u) << (4u);
N    inputTime |= (inputSecond % 10u) << RTC_1_SECONDS_OFFSET;
X    inputTime |= (inputSecond % 10u) << (0u);
N
N    return(inputTime);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_SetMinutes
N****************************************************************************//**
N* \internal
N*  Updates the time with the new minute value.
N*
N* \param inputTime
N* The current date.
N*
N* \param inputMinute
N* The minutes value to be set to the time variable.
N*
N* \return
N* The updated time variable.
N* \endinternal
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_SetMinutes(uint32 inputTime, uint32 inputMinute)
Xstatic __inline uint32 RTC_1_SetMinutes(uint32 inputTime, uint32 inputMinute)
N{
N    inputTime &= ~(RTC_1_MINUTES_FULL_MASK);
X    inputTime &= ~(((0x00000007uL << (12u)) | (0x0000000FuL << (8u))));
N
N    inputTime |= (inputMinute / 10u) << RTC_1_10_MINUTES_OFFSET;
X    inputTime |= (inputMinute / 10u) << (12u);
N    inputTime |= (inputMinute % 10u) << RTC_1_MINUTES_OFFSET;
X    inputTime |= (inputMinute % 10u) << (8u);
N
N    return(inputTime);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_SetHours
N****************************************************************************//**
N* \internal
N*  Updates the time with the new hour value.
N*
N* \param inputTime
N* The current date.
N*
N* \param inputHours
N* The hours value to be set to the time variable.
N*
N* \return
N* The updated time variable.
N* \endinternal
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_SetHours(uint32 inputTime, uint32 inputHours)
Xstatic __inline uint32 RTC_1_SetHours(uint32 inputTime, uint32 inputHours)
N{
N    inputTime &= ~(RTC_1_HOURS_FULL_MASK);
X    inputTime &= ~(((0x00000003uL << (20u)) | (0x0000000FuL << (16u))));
N
N    inputTime |= (inputHours / 10u) << RTC_1_10_HOURS_OFFSET;
X    inputTime |= (inputHours / 10u) << (20u);
N    inputTime |= (inputHours % 10u) << RTC_1_HOURS_OFFSET;
X    inputTime |= (inputHours % 10u) << (16u);
N
N    return(inputTime);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_SetAmPm
N****************************************************************************//**
N* \internal
N* Updates the time variable with the AmPm status.
N*
N* \param inputTime
N* The current date.
N*
N* \param periodOfDay
N* The AmPm status to be set to the time variable.
N*
N* \return
N* The updated time variable.
N* \endinternal
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_SetAmPm(uint32 inputTime, uint32 periodOfDay)
Xstatic __inline uint32 RTC_1_SetAmPm(uint32 inputTime, uint32 periodOfDay)
N{
N    if(0u != periodOfDay)
N    {
N        inputTime &= ~(RTC_1_PERIOD_OF_DAY_MASK);
X        inputTime &= ~((0x00000001uL << (22u)));
N    }
N    else
N    {
N        inputTime |= RTC_1_PERIOD_OF_DAY_MASK;
X        inputTime |= (0x00000001uL << (22u));
N    }
N
N    return(inputTime);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_SetDay
N****************************************************************************//**
N* \internal
N* Updates the date variable with the new day value.
N*
N* \param inputDate
N* The current date.
N*
N* \param inputDay
N* day The month to be set to the date variable.
N*
N* \return
N* The updated date variable.
N* \endinternal
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_SetDay(uint32 inputDate, uint32 inputDay)
Xstatic __inline uint32 RTC_1_SetDay(uint32 inputDate, uint32 inputDay)
N{
N    inputDate &= ~(RTC_1_DAY_FULL_MASK);
X    inputDate &= ~(((0x00000003uL << (20u)) | (0x0000000FuL << (16u))));
N
N    inputDate |= (inputDay / 10u) << RTC_1_10_DAY_OFFSET;
X    inputDate |= (inputDay / 10u) << (20u);
N    inputDate |= (inputDay % 10u) << RTC_1_DAY_OFFSET;
X    inputDate |= (inputDay % 10u) << (16u);
N
N    return(inputDate);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_SetMonth
N****************************************************************************//**
N* \internal
N* Updates the date variable with the new month value.
N*
N* \param inputDate
N* The current date.
N*
N* \param inputMonth
N* The month that to be set to the date variable.
N*
N* \return
N* The updated date variable.
N* \endinternal
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_SetMonth(uint32 inputDate, uint32 inputMonth)
Xstatic __inline uint32 RTC_1_SetMonth(uint32 inputDate, uint32 inputMonth)
N{
N    inputDate &= ~(RTC_1_MONTH_FULL_MASK);
X    inputDate &= ~(((0x00000001uL << (28u)) | (0x0000000FuL << (24u))));
N
N    inputDate |= (inputMonth / 10u) << RTC_1_10_MONTH_OFFSET;
X    inputDate |= (inputMonth / 10u) << (28u);
N    inputDate |= (inputMonth % 10u) << RTC_1_MONTH_OFFSET;
X    inputDate |= (inputMonth % 10u) << (24u);
N
N    return(inputDate);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_SetYear
N****************************************************************************//**
N*\internal
N* Updates the date variable with the new year value.
N*
N* \param inputDate
N* The current date.
N*
N* \param inputYear
N* The year to be set to the date variable.
N*
N* \return
N* The updated date variable.
N* \endinternal
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_SetYear(uint32 inputDate, uint32 inputYear)
Xstatic __inline uint32 RTC_1_SetYear(uint32 inputDate, uint32 inputYear)
N{
N    inputDate  &= ~(RTC_1_YEAR_FULL_MASK);
X    inputDate  &= ~(((0x00000003uL << (12u)) | (0x0000000FuL << (8u)) | (0x0000000FuL << (4u)) | (0x0000000FuL << (0u))));
N
N    inputDate |= (inputYear / 1000u) << RTC_1_1000_YEAR_OFFSET;
X    inputDate |= (inputYear / 1000u) << (12u);
N    inputYear %= 1000u;
N
N    inputDate |= (inputYear / 100u) << RTC_1_100_YEAR_OFFSET;
X    inputDate |= (inputYear / 100u) << (8u);
N    inputYear %= 100u;
N
N    inputDate |= (inputYear / 10u) << RTC_1_10_YEAR_OFFSET;
X    inputDate |= (inputYear / 10u) << (4u);
N    inputDate |= (inputYear % 10u) << RTC_1_YEAR_OFFSET;
X    inputDate |= (inputYear % 10u) << (0u);
N
N    return(inputDate);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_GetNextMinSec
N****************************************************************************//**
N*\internal
N* This is an internal function that calculates the value of the next Second/Minute
N* that follows after the current Minute/Second.
N*
N* \param curVal
N* The current Second/Minute value.
N*
N* \return
N* Returns the Second/Minute which follows after the current Second/Minute.
N* \endinternal
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_GetNextMinSec(uint32 curVal)
Xstatic __inline uint32 RTC_1_GetNextMinSec(uint32 curVal)
N{
N    return((curVal < 59u) ? (curVal + 1u) : 0u);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_GetNextHour
N****************************************************************************//**
N* \internal
N*  This is an internal function that calculates the value of the next Hour
N*  that follows after the current Hour.
N*
N* \param curVal
N* The current Hour value.
N*
N* \return
N* Returns the Hour which follows after the current Hour.
N* \endinternal
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_GetNextHour(uint32 curVal)
Xstatic __inline uint32 RTC_1_GetNextHour(uint32 curVal)
N{
N    return((curVal < 23u) ? (curVal + 1u) : 0u);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_GetNextDay
N****************************************************************************//**
N* \internal
N*  This is an internal function that calculates the value of the next Day
N*  that follows after the current Day.
N*
N* \param curYear
N* The current year.
N*
N* \param curMonth
N* The current month.
N*
N* \param curDay
N* The current day.
N*
N* \param alarmCfgMask
N* Alarm Config Mask.
N*
N* \return
N* Returns the day which follows after the current Day.
N* \endinternal
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_GetNextDay(uint32 curYear, uint32 curMonth,
Xstatic __inline uint32 RTC_1_GetNextDay(uint32 curYear, uint32 curMonth,
N                                                    uint32 curDay, uint32 alarmCfgMask)
N{
N    uint32 daysInMonth;
N    uint32 tmpVal;
N
N    daysInMonth = RTC_1_DaysInMonth(curMonth, curYear);
N
N    if(0u != (alarmCfgMask & RTC_1_ALARM_DAYOFWEEK_MASK))
X    if(0u != (alarmCfgMask & (0x00000008uL)))
N    {
N        tmpVal = curDay + RTC_1_DAYS_PER_WEEK;
X        tmpVal = curDay + (7u);
N        tmpVal = (tmpVal > daysInMonth) ? (tmpVal - daysInMonth) : tmpVal;
N    }
N    else
N    {
N        tmpVal = (curDay < daysInMonth) ? (curDay + 1u) : 1u;
N    }
N
N    return(tmpVal);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_GetNextMonth
N****************************************************************************//**
N* \internal
N* This is an internal function that calculates the value of the next month
N* that follows after the current month.
N*
N* \param curMonth
N* The current month.
N*
N* \return
N* Returns the month which follows after the current month.
N* \endinternal
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_GetNextMonth(uint32 curMonth)
Xstatic __inline uint32 RTC_1_GetNextMonth(uint32 curMonth)
N{
N    return((curMonth < 12u) ? (curMonth + 1u) : 1u);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_GetNextYear
N****************************************************************************//**
N* \internal
N* This is an internal function that calculates the value of the next year
N* that follows after the current year.
N*
N* \param curYear
N* The current year.
N*
N* \return
N* Returns the year which follows after the current year.
N* \endinternal
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_GetNextYear(uint32 curYear)
Xstatic __inline uint32 RTC_1_GetNextYear(uint32 curYear)
N{
N    return(curYear + 1u);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_SetTimeFormat
N****************************************************************************//**
N* \internal
N* Updates the "Time Format" value in the variable that contains time in the
N* "HH:MM:SS" format.
N*
N* \param inputTime
N* The current value of the time in the "HH:MM:SS" format.
N*
N* \param timeFormat
N* Required time format
N*
N* \return
N* Returns the updated value of the time in the "HH:MM:SS" format.
N* \endinternal
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_SetTimeFormat(uint32 inputTime, uint32 timeFormat)
Xstatic __inline uint32 RTC_1_SetTimeFormat(uint32 inputTime, uint32 timeFormat)
N{
N    inputTime &= ~(RTC_1_TIME_FORMAT_MASK);
X    inputTime &= ~((0x00000001uL << (23u)));
N
N    if((uint32)RTC_1_12_HOURS_FORMAT != timeFormat)
X    if((uint32)(1) != timeFormat)
N    {
N        inputTime |= RTC_1_TIME_FORMAT_MASK;
X        inputTime |= (0x00000001uL << (23u));
N    }
N
N    return(inputTime);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_GetTimeFormat
N****************************************************************************//**
N* \internal
N* Reads the time format from the variable that contains time in the
N* "HH:MM:SS" format.
N*
N* \param inputTime
N* The current value of the time in the "HH:MM:SS" format.
N*
N* \return
N* Returns the time format that is stored in the variable that contains time
N* in the "HH:MM:SS" format.
N* \endinternal
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_GetTimeFormat(uint32 inputTime)
Xstatic __inline uint32 RTC_1_GetTimeFormat(uint32 inputTime)
N{
N    return ((0uL != (inputTime & (1uL << RTC_1_TIME_FORMAT_OFFSET))) ?
X    return ((0uL != (inputTime & (1uL << (23u)))) ?
N                                       (uint32)RTC_1_12_HOURS_FORMAT :
X                                       (uint32)(1) :
N                                       (uint32)RTC_1_24_HOURS_FORMAT);
X                                       (uint32)(0));
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_ConstructTime
N****************************************************************************//**
N*
N* Returns the time in the format used in APIs from individual elements
N* passed (hour, min, sec etc)
N*
N* \param timeFormat
N* The 12/24 hours time format, see \ref group_rtc_hour_format
N*
N* \param stateAmPm 
N* The AM/PM status, see \ref group_rtc_am_pm.
N*
N* \param hour
N* The hour.
N*
N* \param min
N* The minute.
N*
N* \param sec
N* The second.
N*
N* \return
N* Time in the format used in API.
N*
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_ConstructTime(uint32 timeFormat, uint32 stateAmPm, 
Xstatic __inline uint32 RTC_1_ConstructTime(uint32 timeFormat, uint32 stateAmPm, 
N                                                       uint32 hour, uint32 min, uint32 sec)
N{
N    uint32 retVal;
N
N    retVal  = timeFormat << RTC_1_TIME_FORMAT_OFFSET;
X    retVal  = timeFormat << (23u);
N    retVal |= stateAmPm << RTC_1_PERIOD_OF_DAY_OFFSET;
X    retVal |= stateAmPm << (22u);
N
N    retVal |= (hour / 10u) << RTC_1_10_HOURS_OFFSET;
X    retVal |= (hour / 10u) << (20u);
N    retVal |= (hour % 10u) << RTC_1_HOURS_OFFSET;
X    retVal |= (hour % 10u) << (16u);
N
N    retVal |= (min / 10u) << RTC_1_10_MINUTES_OFFSET;
X    retVal |= (min / 10u) << (12u);
N    retVal |= (min % 10u) << RTC_1_MINUTES_OFFSET;
X    retVal |= (min % 10u) << (8u);
N
N    retVal |= (sec / 10u) << RTC_1_10_SECONDS_OFFSET;
X    retVal |= (sec / 10u) << (4u);
N    retVal |= (sec % 10u) << RTC_1_SECONDS_OFFSET;
X    retVal |= (sec % 10u) << (0u);
N
N    return (retVal);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_ConstructDate
N****************************************************************************//**
N*
N*  Returns the date in the format used in APIs from individual elements
N*  passed (day. Month and year)
N*
N* \param month
N* The month.
N*
N* \param day
N* The day.
N*
N* \param year
N* The year.
N*
N* \return
N* The date in the format used in API.
N*
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_ConstructDate(uint32 month, uint32 day, uint32 year)
Xstatic __inline uint32 RTC_1_ConstructDate(uint32 month, uint32 day, uint32 year)
N{
N    uint32 retVal;
N    uint32 tmpVal = year;
N
N    retVal  = (month / 10u) << RTC_1_10_MONTH_OFFSET;
X    retVal  = (month / 10u) << (28u);
N    retVal |= (month % 10u) << RTC_1_MONTH_OFFSET;
X    retVal |= (month % 10u) << (24u);
N
N    retVal |= (day / 10u) << RTC_1_10_DAY_OFFSET;
X    retVal |= (day / 10u) << (20u);
N    retVal |= (day % 10u) << RTC_1_DAY_OFFSET;
X    retVal |= (day % 10u) << (16u);
N
N    retVal |= (year / 1000u) << RTC_1_1000_YEAR_OFFSET;
X    retVal |= (year / 1000u) << (12u);
N    tmpVal %= 1000u;
N
N    retVal |= (tmpVal / 100u) << RTC_1_100_YEAR_OFFSET;
X    retVal |= (tmpVal / 100u) << (8u);
N    tmpVal %= 100u;
N
N    retVal |= (tmpVal / 10u) << RTC_1_10_YEAR_OFFSET;
X    retVal |= (tmpVal / 10u) << (4u);
N    retVal |= (tmpVal % 10u) << RTC_1_YEAR_OFFSET;
X    retVal |= (tmpVal % 10u) << (0u);
N
N    return (retVal);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_GetDayOfWeek
N****************************************************************************//**
N* \internal
N*
N*  Returns a day of the week for a year, month, and day of month that are passed
N*  through parameters. Zeller's congruence is used to calculate the day of
N*  the week.
N*
N*  For the Georgian calendar, Zeller's congruence is:
N*  h = (q + [13 * (m + 1)] + K + [K/4] + [J/4] - 2J) mod 7;
N*
N*  h - The day of the week (0 = Saturday, 1 = Sunday, 2 = Monday, ..., 
N*  6 = Friday).
N*  q - The day of the month.
N*  m - The month (3 = March, 4 = April, 5 = May, ..., 14 = February).
N*  K - The year of the century (year \mod 100).
N*  J - The zero-based century (actually [year/100]) For example, the zero-based
N*  centuries for 1995 and 2000 are 19 and 20 respectively (not to be
N*  confused with the common ordinal century enumeration which indicates
N*  20th for both cases).
N*
N* \note
N* In this algorithm January and February are counted as months 13 and 14
N* of the previous year.
N*
N* \param day
N* The day of the month(1..31)
N*
N* \param month
N* The month of the year, see \ref group_rtc_month
N*
N* \param year
N* The year value.
N*
N* \return
N* Returns a day of the week, see \ref group_rtc_day_of_the_week.
N*
N* \endinternal
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_GetDayOfWeek(uint32 day, uint32 month, uint32 year)
Xstatic __inline uint32 RTC_1_GetDayOfWeek(uint32 day, uint32 month, uint32 year)
N{
N    uint32 retVal;
N
N    /* Converts month number from regular convention
N     * (1=January,..., 12=December) to convention required for this
N     * algorithm(January and February are counted as months 13 and 14 of
N     * previous year).
N    */
N    if(month < (uint32)RTC_1_MARCH)
X    if(month < (uint32)(3))
N    {
N        month = 12u + month;
N        year--;
N    }
N
N    /* Calculates Day of Week using Zeller's congruence algorithms */
N    retVal = (day + (((month + 1u) * 26u) / 10u) + year + (year / 4u) + (6u * (year / 100u)) + (year / 400u)) % 7u;
N
N    /* Makes correction for Saturday. Saturday number should be 7 instead of 0. */
N    if(0u == retVal)
N    {
N        retVal = (uint32)RTC_1_SATURDAY;
X        retVal = (uint32)(7);
N    }
N
N    return(retVal);
N}
N
N
N/*******************************************************************************
N* Function Name: RTC_1_DaysBeforeMonth
N****************************************************************************//**
N*
N* Calculates how many days elapsed from the beginning of the year to the
N* beginning of the current month.
N*
N* \param month
N* A month of a year, see \ref group_rtc_month
N*
N* \param year
N* A year value.
N*
N* \return
N* A number of days elapsed from the beginning of the year to the
N* beginning of the current month passed through the parameters.
N*
N*******************************************************************************/
Nstatic CY_INLINE uint32 RTC_1_DaysBeforeMonth(uint32 month, uint32 year)
Xstatic __inline uint32 RTC_1_DaysBeforeMonth(uint32 month, uint32 year)
N{
N    uint32 retVal;
N
N    retVal = RTC_1_daysBeforeMonthTbl[month - 1u];
N    if((0u != RTC_1_LeapYear(year)) && (month > (uint32)RTC_1_FEBRUARY))
X    if((0u != RTC_1_LeapYear(year)) && (month > (uint32)(2)))
N    {
N        retVal++;
N    }
N
N    return(retVal);
N}
N
N#if defined(CYDEV_RTC_SOURCE_WDT)
X#if 1L
N    #if((0u != CYDEV_WDT_GENERATE_ISR) && (0u == RTC_1_INITIAL_UPDATE_MODE))
X    #if((0u != 1u) && (0u == (0u)))
N
N        /*******************************************************************************
N        * Function Name: RTC_1_CySysRtcSetCallback
N        ****************************************************************************//**
N        *
N        *  This is an internal function that registers a callback for the
N        *  RTC_1_Update() function by address "0".
N        *
N        * \param wdtNumber
N        * The number of the WDT or DeepSleep Timer to be used to pull the
N        * RTC_1_Update() function.
N        *
N        * The callback registered before by address "0" is replaced
N        * by the RTC_1_Update() function.
N        *
N        *******************************************************************************/
N        static CY_INLINE void RTC_1_CySysRtcSetCallback(uint32 wdtNumber)
X        static __inline void RTC_1_CySysRtcSetCallback(uint32 wdtNumber)
N        {
N            #if((0u != CY_IP_WCO_WDT_EN) && (0u != CY_IP_SRSSLT))
X            #if((0u != (1 == 1)) && (0u != (!(0 != 0))))
N                (void)CySysTimerSetInterruptCallback(wdtNumber, &RTC_1_Update);
N            #else
S                (void)CySysWdtSetIsrCallback(wdtNumber, &RTC_1_Update);
N            #endif /* ((0u != CY_IP_WCO_WDT_EN) && (0u != CY_IP_SRSSLT)) */
N        }
N
N
N        /*******************************************************************************
N        * Function Name: RTC_1_CySysRtcResetCallback
N        ****************************************************************************//**
N        *
N        *  This is an internal function that clears a callback by address "0".
N        *
N        * \param wdtNumber
N        * The number of the WDT or DeeSleep Timer to be cleared callback for.
N        *
N        * The callback registered before by address "0" is replaced
N        * by the NULL pointer.
N        *
N        *******************************************************************************/
N        static CY_INLINE void RTC_1_CySysRtcResetCallback(uint32 wdtNumber)
X        static __inline void RTC_1_CySysRtcResetCallback(uint32 wdtNumber)
N        {
N            #if((0u != CY_IP_WCO_WDT_EN) && (0u != CY_IP_SRSSLT))
X            #if((0u != (1 == 1)) && (0u != (!(0 != 0))))
N                (void)CySysTimerSetInterruptCallback(wdtNumber, (void *)0);
N            #else
S                (void)CySysWdtSetIsrCallback(wdtNumber, (void *)0);
N            #endif /* ((0u != CY_IP_WCO_WDT_EN) && (0u != CY_IP_SRSSLT)) */
N        }
N
N    #endif /* ((0u != CYDEV_WDT_GENERATE_ISR) && (0u == RTC_1_INITIAL_UPDATE_MODE)) */
N#endif /* (CYDEV_RTC_SOURCE_WDT) */
N
N#endif /* CY_RTC_P4_RTC_1_H */
N
N
N/* [] END OF FILE */
L 96 "Generated_Source\PSoC4\project.h" 2
N#include "Em_EEPROM.h"
L 1 "Generated_Source\PSoC4\Em_EEPROM.h" 1
N/*******************************************************************************
N* File Name: Em_EEPROM.h
N* Version 2.0
N*
N* Description:
N*  This file provides constants and parameter values for the Emulated EEPROM
N*  component.
N*
N********************************************************************************
N* Copyright 2013-2017, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#ifndef CY_EM_EEPROM_Em_EEPROM_H
N#define CY_EM_EEPROM_Em_EEPROM_H
N
N#include "cyfitter.h"
N
N#if (CYDEV_CHIP_FAMILY_USED != CYDEV_CHIP_FAMILY_PSOC6)
X#if (2u != 4u)
N    #include "CyFlash.h"
L 1 "Generated_Source\PSoC4\CyFlash.h" 1
N/***************************************************************************//**
N* \file CyFlash.h
N* \version 5.70
N*
N* \brief Provides the function definitions for the FLASH.
N*
N* \note Documentation of the API's in this file is located in the System
N* Reference Guide provided with PSoC Creator.
N*
N********************************************************************************
N* \copyright
N* Copyright 2010-2018, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_BOOT_CYFLASH_H)
X#if !0L
N#define CY_BOOT_CYFLASH_H
N
N#include "CyLib.h"
N
N/**
N* \addtogroup group_flash
N
N\brief Flash memory in PSoC devices provides nonvolatile storage for user
Nfirmware, user configuration data, and bulk data storage. See the device
Ndatasheet and TRM for more information on Flash architecture.
N
N\section section_flash_protection Flash Protection
NPSoC devices include a flexible flash-protection model that prevents access
Nand visibility to on-chip flash memory. The device offers the ability to
Nassign one of two protection levels to each row of flash: unprotected and
Nfull protection. The required protection level can be selected using the Flash
NSecurity tab of the PSoC Creator DWR file. Flash protection levels can only be
Nchanged by performing a complete flash erase. The Flash programming APIs will
Nfail to write a row with Full Protection level. For more information on
Nprotection model, refer to the Flash Security Editor section in the PSoC
NCreator Help.
N
N\section section_flash_working_with Working with Flash
NFlash programming operations are implemented as system calls. System calls are
Nexecuted out of SROM in the privileged mode of operation. Users have no access
Nto read or modify the SROM code. The CPU requests the system call by writing
Nthe function opcode and parameters to the System Performance Controller (SPC)
Ninput registers, and then requesting the SROM to execute the function. Based
Non the function opcode, the SPC executes the corresponding system call from
NSROM and updates the SPC status register. The CPU should read this status
Nregister for the pass/fail result of the function execution. As part of
Nfunction execution, the code in SROM interacts with the SPC interface to do
Nthe actual flash programming operations.
N
NIt can take as many as 20 milliseconds to write to flash. During this time,
Nthe device should not be reset, or unexpected changes may be made to portions
Nof the flash. Reset sources include XRES pin, software reset, and watchdog.
NMake sure that these are not inadvertently activated. Also, the low voltage
Ndetect circuits should be configured to generate an interrupt instead of a
Nreset.
N
NThe flash can be read either by the cache controller or the SPC. Flash write
Ncan be performed only by the SPC. Both the SPC and cache cannot simultaneously
Naccess flash memory. If the cache controller tries to access flash at the same
Ntime as the SPC, then it must wait until the SPC completes its flash access
Noperation. The CPU, which accesses the flash memory through the cache
Ncontroller, is therefore also stalled in this circumstance. If a CPU code
Nfetch has to be done from flash memory due to a cache miss condition, then the
Ncache would have to wait until the SPC completes the flash write operation.
NThus the CPU code execution will also be halted till the flash write is
Ncomplete. Flash is directly mapped into memory space and can be read directly.
N
N\note Flash write operations on PSoC 4000 devices modify the clock settings of
Nthe device during the period of the write operation.
NRefer to the \ref CySysFlashWriteRow() API documentation for details.
N
N* @{
N*/
N
Nuint32 CySysFlashWriteRow       (uint32 rowNum, const uint8 rowData[]);
N#if (CY_SFLASH_XTRA_ROWS)
X#if ((0 == 0))
N    uint32 CySysSFlashWriteUserRow  (uint32 rowNum, const uint8 rowData[]);
N#endif /* (CY_SFLASH_XTRA_ROWS) */
Nvoid   CySysFlashSetWaitCycles  (uint32 freq);
N
N#if (CY_IP_FLASH_PARALLEL_PGM_EN && (CY_IP_FLASH_MACROS > 1u))
X#if ((0 == 1) && ((1u) > 1u))
S    uint32 CySysFlashStartWriteRow(uint32 rowNum, const uint8 rowData[]);
S    uint32 CySysFlashGetWriteRowStatus(void);
S    uint32 CySysFlashResumeWriteRow(void);
N#endif /* (CY_IP_FLASH_PARALLEL_PGM_EN && (CY_IP_FLASH_MACROS > 1u)) */
N
N/** @} group_flash */
N
N
N#define CY_FLASH_BASE           (CYDEV_FLASH_BASE)              /**< The base pointer of the Flash memory.*/
N#define CY_FLASH_SIZE           (CYDEV_FLASH_SIZE)              /**< The size of the Flash memory. */
N#define CY_FLASH_NUMBER_ARRAYS  (CYDEV_FLASH_SIZE / CYDEV_FLS_SECTOR_SIZE)  /**< The size of Flash array. */
N#define CY_FLASH_SIZEOF_ARRAY   (CYDEV_FLS_SECTOR_SIZE)                     /**< The size of the Flash row. */
N#define CY_FLASH_NUMBER_ROWS    (CYDEV_FLASH_SIZE / CYDEV_FLS_ROW_SIZE)     /**< The number of Flash row. */
N#define CY_FLASH_SIZEOF_ROW     (CYDEV_FLS_ROW_SIZE)                        /**< The number of Flash arrays. */
N
N#if (CY_SFLASH_XTRA_ROWS)
X#if ((0 == 0))
N    #define CY_SFLASH_USERBASE  (CYREG_SFLASH_MACRO_0_FREE_SFLASH0) /**< The base pointer of the user SFlash memory. */
N    #define CY_SFLASH_SIZE      (CYDEV_SFLASH_SIZE)                 /**< The size of the SFlash memory. */
N    #define CY_SFLASH_SIZEOF_USERROW        (CYDEV_FLS_ROW_SIZE)    /**< The size of the SFlash row. */
N    #define CY_SFLASH_NUMBER_USERROWS       (4u)                    /**< The number of SFlash row. */
N#endif /* (CY_SFLASH_XTRA_ROWS) */
N
N
N/**
N* \addtogroup group_flash_status_codes Flash API status codes
N* \ingroup group_flash
N* @{
N*/
N
N/** Completed successfully. */
N#define CY_SYS_FLASH_SUCCESS            (0x00u)
N/** Specified flash row address is invalid. The row id or byte address provided is outside of the available memory. */
N#define CY_SYS_FLASH_INVALID_ADDR       (0x04u)
N/** Specified flash row is protected. */
N#define CY_SYS_FLASH_PROTECTED          (0x05u)
N/** Resume Completed. All non-blocking calls have completed. The resume/abort function cannot be called until the
Nnext non-blocking. */
N#define CY_SYS_FLASH_RESUME_COMPLETED   (0x07u)
N/** \brief Pending Resume. A non-blocking was initiated and must be completed by calling the resume API, before any other
Nfunction may be called. */
N#define CY_SYS_FLASH_PENDING_RESUME     (0x08u)
N/** System Call Still In Progress. A resume or non-blocking is still in progress. The SPC ISR must fire before
Nattempting the next resume. */
N#define CY_SYS_FLASH_CALL_IN_PROGRESS   (0x09u)
N/** Invalid Flash Clock. Products using CY_IP_SRSSLT must set the IMO to 48MHz and the HF clock source to the IMO clock
Nbefore Write/Erase operations. */
N#define CY_SYS_FLASH_INVALID_CLOCK      (0x12u)
N/** @} group_flash_status_codes */
N
N#define CY_SYS_SFLASH_SUCCESS            (CY_SYS_FLASH_SUCCESS)
N#define CY_SYS_SFLASH_INVALID_ADDR       (CY_SYS_FLASH_INVALID_ADDR)
N#define CY_SYS_SFLASH_PROTECTED          (CY_SYS_FLASH_PROTECTED)
N
N/* CySysFlashSetWaitCycles() - implementation definitions */
N#define CY_FLASH_WAIT_STATE_EN          (( uint32 )(( uint32 )0x01u << 18u))
N#define CY_FLASH_SYSCLK_BOUNDARY_MHZ    (24u)
N#if (CY_IP_CPUSS_FLASHC_PRESENT)
X#if ((0 == 0))
N    /* CySysFlashSetWaitCycles() */
N    #if(CY_IP_FM || CY_IP_FS)
X    #if((3 == 0) || (3 == 2))
S        #define CY_FLASH_CTL_WS_0_FREQ_MIN      (0u)
S        #define CY_FLASH_CTL_WS_0_FREQ_MAX      (24u)
S
S        #define CY_FLASH_CTL_WS_1_FREQ_MIN      (24u)
S        #define CY_FLASH_CTL_WS_1_FREQ_MAX      (48u)
N    #else /* (CY_IP_FMLT || CY_IP_FSLT) */
N        #define CY_FLASH_CTL_WS_0_FREQ_MIN      (0u)
N        #define CY_FLASH_CTL_WS_0_FREQ_MAX      (16u)
N
N        #define CY_FLASH_CTL_WS_1_FREQ_MIN      (16u)
N        #define CY_FLASH_CTL_WS_1_FREQ_MAX      (32u)
N
N        #define CY_FLASH_CTL_WS_2_FREQ_MIN      (32u)
N        #define CY_FLASH_CTL_WS_2_FREQ_MAX      (48u)
N    #endif  /* (CY_IP_FM || CY_IP_FS) */
N
N    #define CY_FLASH_CTL_WS_MASK        ((uint32) 0x03u)
N    #define CY_FLASH_CTL_WS_0_VALUE     (0x00u)
N    #define CY_FLASH_CTL_WS_1_VALUE     (0x01u)
N    #if(CY_IP_FMLT || CY_IP_FSLT)
X    #if((3 == 1) || (3 == 3))
N        #define CY_FLASH_CTL_WS_2_VALUE (0x02u)
N    #endif  /* (CY_IP_FMLT || CY_IP_FSLT) */
N#endif  /* (CY_IP_CPUSS_FLASHC_PRESENT) */
N
N
N#define CY_FLASH_KEY_ONE                (0xB6u)
N#define CY_FLASH_KEY_TWO(x)             ((uint32) (((uint16) 0xD3u) + ((uint16) (x))))
N
N#define CY_FLASH_PAGE_LATCH_START_ADDR  ((uint32) (0x00u))
N#define CY_FLASH_ROW_NUM_MASK           (0x100u)
N#define CY_FLASH_CPUSS_REQ_START        (( uint32 )(( uint32 )0x1u << 31u))
N
N/* Opcodes */
N#define CY_FLASH_API_OPCODE_LOAD                        (0x04u)
N#define CY_FLASH_API_OPCODE_WRITE_ROW                   (0x05u)
N#define CY_FLASH_API_OPCODE_NON_BLOCKING_WRITE_ROW      (0x07u)
N#define CY_FLASH_API_OPCODE_RESUME_NON_BLOCKING         (0x09u)
N
N#define CY_FLASH_API_OPCODE_PROGRAM_ROW                 (0x06u)
N#define CY_FLASH_API_OPCODE_WRITE_SFLASH_ROW            (0x18u)
N
N#define CY_FLASH_API_OPCODE_CLK_CONFIG                  (0x15u)
N#define CY_FLASH_API_OPCODE_CLK_BACKUP                  (0x16u)
N#define CY_FLASH_API_OPCODE_CLK_RESTORE                 (0x17u)
N
N/* SROM API parameters offsets */
N#define CY_FLASH_PARAM_KEY_TWO_OFFSET   (8u)
N#define CY_FLASH_PARAM_ADDR_OFFSET      (16u)
N#define CY_FLASH_PARAM_MACRO_SEL_OFFSET (24u)
N
N#if (CY_IP_FLASH_MACROS == 2u)
X#if ((1u) == 2u)
S    /*  Macro #0: rows 0x00-0x1ff, Macro #1: rows 0x200-0x3ff */
S    #define CY_FLASH_GET_MACRO_FROM_ROW(row)         ((uint32)(((row) > 0x1ffu) ? 1u : 0u))
N#else
N    /* Only macro # 0 is available */
N    #define CY_FLASH_GET_MACRO_FROM_ROW(row)         ((uint32)(((row) != 0u)    ? 0u : 0u))
N#endif  /* (CY_IP_FLASH_MACROS == 2u) */
N
N#if(CY_IP_FMLT)
X#if((3 == 1))
S    /* SROM size greater than 4k */
S    #define CY_FLASH_IS_BACKUP_RESTORE   (CYDEV_SROM_SIZE > 0x00001000u)
N#endif  /* (CY_IP_FMLT) */
N
N
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S    #define CY_FLASH_CLOCK_BACKUP_SIZE      (4u)
N#else /* CY_IP_SRSSLT */
N    #define CY_FLASH_CLOCK_BACKUP_SIZE      (6u)
N#endif  /* (CY_IP_SRSSV2) */
N
N
Ntypedef struct cySysFlashClockBackupStruct
N{
N#if(CY_IP_FM)
X#if((3 == 0))
S        uint32   imoConfigReg;
N#else   /* (CY_IP_FMLT) */
N    #if (CY_PSOC4_4000)
X    #if ((16u == 13u))
S        uint32 clkSelectReg;
S        uint32 clkImoEna;
S        uint32 clkImoFreq;
N    #else
N
N        #if(CY_IP_SRSSV2)
X        #if((0 != 0))
S            uint32 clkImoPump;
N        #endif /* (CY_IP_SRSSV2) */
N
N        #if (CY_IP_SPCIF_SYNCHRONOUS)
X        #if ((1 == 1))
N            uint32 clockSettings[CY_FLASH_CLOCK_BACKUP_SIZE];       /* FM-Lite Clock Backup */
X            uint32 clockSettings[(6u)];        
N        #endif /* (CY_IP_SPCIF_SYNCHRONOUS) */
N
N    #endif  /* (CY_PSOC4_4000) */
N
N#endif  /* (CY_IP_FM) */
N} CY_SYS_FLASH_CLOCK_BACKUP_STRUCT;
N
N
N/* SYSARG control register */
N#define CY_FLASH_CPUSS_SYSARG_REG       (*(reg32 *) CYREG_CPUSS_SYSARG)
N#define CY_FLASH_CPUSS_SYSARG_PTR       ( (reg32 *) CYREG_CPUSS_SYSARG)
N
N/* SYSCALL control register */
N#define CY_FLASH_CPUSS_SYSREQ_REG       (*(reg32 *) CYREG_CPUSS_SYSREQ)
N#define CY_FLASH_CPUSS_SYSREQ_PTR       ( (reg32 *) CYREG_CPUSS_SYSREQ)
N
N#if (CY_IP_CPUSS_FLASHC_PRESENT)
X#if ((0 == 0))
N    /* SYSARG control register */
N    #define CY_FLASH_CTL_REG            (*(reg32 *) CYREG_CPUSS_FLASH_CTL)
N    #define CY_FLASH_CTL_PTR            ( (reg32 *) CYREG_CPUSS_FLASH_CTL)
N#endif  /* (CY_IP_CPUSS_FLASHC_PRESENT) */
N
N
N#define CY_FLASH_API_RETURN             (((CY_FLASH_CPUSS_SYSARG_REG & 0xF0000000u) == 0xF0000000u) ? \
N                                         (CY_FLASH_CPUSS_SYSARG_REG & 0x000000FFu) : \
N                                         (((CY_FLASH_CPUSS_SYSARG_REG & 0xF0000000u) == 0xA0000000u) ? \
N                                            CYRET_SUCCESS : (CY_FLASH_CPUSS_SYSARG_REG & 0x000000FFu)))
X#define CY_FLASH_API_RETURN             (((CY_FLASH_CPUSS_SYSARG_REG & 0xF0000000u) == 0xF0000000u) ?                                          (CY_FLASH_CPUSS_SYSARG_REG & 0x000000FFu) :                                          (((CY_FLASH_CPUSS_SYSARG_REG & 0xF0000000u) == 0xA0000000u) ?                                             CYRET_SUCCESS : (CY_FLASH_CPUSS_SYSARG_REG & 0x000000FFu)))
N
N
N/*******************************************************************************
N* Thne following code is OBSOLETE and must not be used starting with cy_boot
N* 4.20.
N*
N* If the obsoleted macro definitions intended for use in the application use the
N* following scheme, redefine your own versions of these definitions:
N*    #ifdef <OBSOLETED_DEFINE>
N*        #undef  <OBSOLETED_DEFINE>
N*        #define <OBSOLETED_DEFINE>      (<New Value>)
N*    #endif
N*
N* Note: Redefine obsoleted macro definitions with caution. They might still be
N*       used in the application and their modification might lead to unexpected
N*       consequences.
N*******************************************************************************/
N#define CY_FLASH_SRAM_ROM_KEY1          (( uint32 )0x00u)
N#define CY_FLASH_SRAM_ROM_PARAM2        (CY_FLASH_SRAM_ROM_KEY1 + 0x04u)
N#define CY_FLASH_SRAM_ROM_DATA          (CY_FLASH_SRAM_ROM_KEY1 + 0x08u)
N
N#define CY_FLASH_SROM_CMD_RETURN_MASK   (0xF0000000u)
N#define CY_FLASH_SROM_CMD_RETURN_SUCC   (0xA0000000u)
N#define CY_FLASH_SROM_KEY1              (( uint32 )0xB6u)
N#define CY_FLASH_SROM_KEY2_LOAD         (( uint32 )0xD7u)
N#define CY_FLASH_SROM_KEY2_WRITE        (( uint32 )0xD8u)
N#define CY_FLASH_SROM_LOAD_CMD          ((CY_FLASH_SROM_KEY2_LOAD << 8u) | CY_FLASH_SROM_KEY1)
N#define CY_FLASH_LOAD_BYTE_OPCODE       (( uint32 )0x04u)
N#define CY_FLASH_WRITE_ROW_OPCODE       (( uint32 )0x05u)
N
N
N#endif  /* (CY_BOOT_CYFLASH_H) */
N
N
N/* [] END OF FILE */
L 23 "Generated_Source\PSoC4\Em_EEPROM.h" 2
N    #include "cytypes.h"
N    #include "cy_em_eeprom.h"
L 1 "Generated_Source\PSoC4\cy_em_eeprom.h" 1
N/*******************************************************************************
N* \file cy_em_eeprom.h
N* \version 2.0
N*
N* \brief
N*  This file provides the function prototypes and constants for the Emulated
N*  EEPROM middleware library.
N*
N********************************************************************************
N* Copyright 2017, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N/**
N * \mainpage Cypress Em_EEPROM Middleware Library
N *
N * The Emulated EEPROM provides an API that allows creating an emulated
N * EEPROM in flash that has the ability to do wear leveling and restore
N * corrupted data from a redundant copy. The Emulated EEPROM library is designed
N * to be used with the Em_EEPROM component.
N *
N * The Cy_Em_EEPROM API is described in the following sections:
N * - \ref group_em_eeprom_macros
N * - \ref group_em_eeprom_data_structures
N * - \ref group_em_eeprom_enums
N * - \ref group_em_eeprom_functions
N *
N * <b>Features:</b>
N * * EEPROM-Like Non-Volatile Storage
N * * Easy to use Read and Write API
N * * Optional Wear Leveling
N * * Optional Redundant Data storage
N *
N * \section group_em_eeprom_configuration Configuration Considerations
N *
N * The Em_EEPROM operates on the top of the flash driver. The flash driver has
N * some prerequisites for proper operation. Refer to the "Flash System 
N * Routine (Flash)" section of the PDL API Reference Manual.
N *
N * <b>Initializing Emulated EEPROM in User flash</b>
N *
N * To initialize an Emulated EEPROM in the User flash, the EEPROM storage should
N * be declared by the user. For the proper operation, the EEPROM storage should
N * be aligned to the size of the flash row. An example of the EEPROM storage
N * declaration is below (applicable for GCC and MDK compilers):
N *
N *      CY_ALIGN(CY_EM_EEPROM_FLASH_SIZEOF_ROW)
N *      const uint8 emEeprom[Em_EEPROM_PHYSICAL_SIZE] = {0u};
N *
N * The same declaration for the IAR compiler:
N *
N *      #pragma data_alignment = CY_EM_EEPROM_FLASH_SIZEOF_ROW
N *      const uint8 emEeprom[Em_EEPROM_PHYSICAL_SIZE] = {0u};
N * 
N * Note that the name "emEeprom" is shown for reference. Any other name can be
N * used instead. Also, note that the Em_EEPROM_PHYSICAL_SIZE constant is 
N * generated by the PSoC Creator Em_EEPROM component and so it is instance name
N * dependent and its prefix should be changed when the name of the component 
N * changes. If the The Cy_Em_EEPROM middleware library is used without the 
N * Em_EEPROM component, the user has to provide a proper size for the EEPROM 
N * storage instead of Em_EEPROM_PHYSICAL_SIZE. The size of the EEPROM storage 
N * can be calculated using the following equation:
N * 
N *  Physical size = EEPROM data size * 2 * wear leveling * (1 + redundant copy)
N *
N * where, 
N *   "EEPROM data size" - the size of data the user wants to store in the 
N *   EEPROM. The data size must divide evenly to the half of the flash row size.
N *   "wear leveling" - the wear leveling factor (1-10).
N *   "redundant copy" - "zero" if a redundant copy is not used, and "one" 
N *   otherwise.
N *
N * The start address of the storage should be filled to the Emulated EEPROM 
N * configuration structure and then passed to the Cy_Em_EEPROM_Init().
N * If the Em_EEPROM component is used, the config (Em_EEPROM_config) and 
N * context structures (Em_EEPROM_context) are defined by the component, so the
N * user may just use that structures otherwise both of the structures need to 
N * be provided by the user. Note that if the "Config Data in Flash"
N * option is selected in the component, then the configuration structure should
N * be copied to RAM to allow EEPROM storage start address update. The following 
N * code demonstrates utilization of "Em_EEPROM_config" and "Em_EEPROM_context"
N * Em_EEPROM component structures for Cy_Em_EEPROM middleware library 
N * initialization:
N *
N *      cy_en_em_eeprom_status_t retValue;
N *      cy_stc_eeprom_config_t config;
N *
N *      memcpy((void *)&config, 
N               (void *)&Em_EEPROM_config, 
N               sizeof(cy_stc_eeprom_config_t));
N *      config.userFlashStartAddr = (uint32)emEeprom;
N *      retValue = Cy_Em_EEPROM_Init(&config, &Em_EEPROM_context);
N *
N * <b>Initializing EEPROM in Emulated EEPROM flash area</b>
N * 
N * Initializing of the EEPROM storage in the Emulated EEPROM flash area is 
N * identical to initializing of the EEPROM storage in the User flash with one 
N * difference. The location of the Emulated EEPROM storage should be specified 
N * somewhere in the EmulatedEEPROM flash area. If the Em_EEPROM component is 
N * utilized in the project, then the respective storage 
N * (Em_EEPROM_em_EepromStorage[]) is automatically declared by the component 
N * if the "Use Emulated EEPROM" option is set to "Yes". The user just needs to 
N * fill the start address of the storage to the config structure. If the
N * Em_EEPROM component is not used, the user needs to declare the storage
N * in the Emulated EEPROM flash area. An example of such declaration is 
N * following (applicable for GCC and MDK compilers):
N *
N *      CY_SECTION(".cy_em_eeprom") CY_ALIGN(CY_EM_EEPROM_FLASH_SIZEOF_ROW)
N *      const uint8_t emEeprom[Em_EEPROM_PHYSICAL_SIZE] = {0u};
N *
N * The same declaration for the IAR compiler:
N *
N *      #pragma location = ".cy_em_eeprom"
N *      #pragma data_alignment = CY_EM_EEPROM_FLASH_SIZEOF_ROW
N *      const uint8 emEeprom[Em_EEPROM_PHYSICAL_SIZE] = {0u};
N *
N * where,
N *   Em_EEPROM_PHYSICAL_SIZE - is a constant that is generated by the Em_EEPROM
N *   component when the component is utilized in the project or it should be 
N *   provided by the user. The equation for the calculation of the constant is 
N *   shown above.
N *
N * Note that the size of the Emulated EEPROM flash area is limited. Refer to the
N * specific device datasheet for the value of the available EEPROM Emulation 
N * area.
N *
N * \section group_em_eeprom_more_information More Information
N * See the Em_EEPROM Component datasheet.
N *
N *
N * \section group_em_eeprom_MISRA MISRA-C Compliance
N *
N * The Cy_Em_EEPROM library has the following specific deviations:
N *
N * <table class="doxtable">
N *   <tr>
N *     <th>MISRA Rule</th>
N *     <th>Rule Class (Required/Advisory)</th>
N *     <th>Rule Description</th>
N *     <th>Description of Deviation(s)</th>
N *   </tr>
N *   <tr>
N *     <td>11.4</td>
N *     <td>A</td>
N *     <td>The cast should not be performed between a pointer to the object type
N *         and a different pointer to the object type.</td>
N *     <td>The cast from the object type and a different pointer to the object 
N *         was used intentionally because of the performance reasons.</td>
N *   </tr>
N *   <tr>
N *     <td>14.2</td>
N *     <td>R</td>
N *     <td>All non-null statements shall either have at least one side-effect,
N *         however executed, or cause control flow to change.</td>
N *     <td>To maintain common codebase, some variables, unused for a specific 
N *         device, are casted to void to prevent generation of an unused variable
N *         compiler warning.</td>
N *   </tr>
N *   <tr>
N *     <td>16.7</td>
N *     <td>A</td>
N *     <td>The object addressed by the pointer parameter is not modified and so
N *          the pointer could be of type 'pointer to const'.</td>
N *     <td>The warning is generated because of the pointer dereferencing to
N *         address which makes the MISRA checker think the data is not
N *         modified.</td>
N *   </tr>
N *   <tr>
N *     <td>17.4</td>
N *     <td>R</td>
N *     <td>The array indexing shall be the only allowed form of pointer 
N *         arithmetic.</td>
N *     <td>The pointer arithmetic used in several places on the Cy_Em_EEPROM
N *         implementation is safe and preferred because it increases the code
N *         flexibility.</td>
N *   </tr>
N *   <tr>
N *     <td>19.7</td>
N *     <td>A</td>
N *     <td>A function shall be used in preference to a function-like macro.</td>
N *     <td>Macro is used because of performance reasons.</td>
N *   </tr>
N * </table>
N *
N * \section group_em_eeprom_changelog Changelog
N * <table class="doxtable">
N *   <tr><th>Version</th><th>Changes</th><th>Reason for Change</th></tr>
N *   <tr>
N *     <td>1.0</td>
N *     <td>Initial Version</td>
N *     <td></td>
N *   </tr>
N * </table>
N *
N * \defgroup group_em_eeprom_macros Macros
N * \brief
N * This section describes the Emulated EEPROM Macros.
N *
N * \defgroup group_em_eeprom_functions Functions
N * \brief
N * This section describes the Emulated EEPROM Function Prototypes.
N *
N * \defgroup group_em_eeprom_data_structures Data Structures
N * \brief
N * Describes the data structures defined by the Emulated EEPROM.
N *
N * \defgroup group_em_eeprom_enums Enumerated types
N * \brief
N * Describes the enumeration types defined by the Emulated EEPROM.
N *
N */
N
N
N#if !defined(CY_EM_EEPROM_H)
X#if !0L
N#define CY_EM_EEPROM_H
N
N#include "cytypes.h"
N#include <stddef.h>
L 1 "D:\Keil_v5\ARM\ARMCC\bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 221 "Generated_Source\PSoC4\cy_em_eeprom.h" 2
N#if (CYDEV_CHIP_FAMILY_USED == CYDEV_CHIP_FAMILY_PSOC6)
X#if (2u == 4u)
S    #include <cy_device_headers.h>
S    #include "syslib/cy_syslib.h"
S    #include "flash/cy_flash.h"
N#else
N    #include "CyFlash.h"
N    #include <cyfitter.h>
N#endif /* (CYDEV_CHIP_FAMILY_USED == CYDEV_CHIP_FAMILY_PSOC6) */
N
N/* The C binding of definitions if building with the C++ compiler */
N#ifdef __cplusplus
Sextern "C" {
N#endif /* __cplusplus */
N
N
N/***************************************
N* Conditional Compilation Parameters
N***************************************/
N#define CY_PSOC6                                    (CYDEV_CHIP_FAMILY_USED == CYDEV_CHIP_FAMILY_PSOC6)
N
N
N/***************************************
N* Data Structure definitions
N***************************************/
N/**
N* \addtogroup group_em_eeprom_data_structures
N* \{
N*/
N
N/** EEPROM configuration structure */
Ntypedef struct
N{
N    /** The number of bytes to store in EEPROM */
N    uint32 eepromSize;
N
N    /** The amount of wear leveling from 1 to 10. 1 means no wear leveling
N    * is used.
N    */
N    uint32 wearLevelingFactor;
N
N    /** If not zero, a redundant copy of the Em_EEPROM is included. */
N    uint8 redundantCopy;
N
N    /** If not zero, a blocking write to flash is used. Otherwise non-blocking
N    * write is used. This parameter is used only for PSoC 6.
N    */
N    uint8 blockingWrite;
N
N    /** The start address for the EEPROM memory in the user's flash. */
N    uint32 userFlashStartAddr;
N} cy_stc_eeprom_config_t;
N
N/** \} group_em_eeprom_data_structures */
N
N/** The EEPROM context data structure. It is used to store the specific
N* EEPROM context data.
N*/
Ntypedef struct
N{
N    /** The pointer to the end address of EEPROM including wear leveling overhead
N    * and excluding redundant copy overhead.
N    */
N    uint32 wlEndAddr;
N
N    /** The number of flash rows allocated for the EEPROM excluding the number of
N    * rows allocated for wear leveling and redundant copy overhead.
N    */
N    uint32 numberOfRows;
N
N    /** The address of the last written EEPROM row */
N    uint32 lastWrRowAddr;
N
N    /** The number of bytes to store in EEPROM */
N    uint32 eepromSize;
N
N    /** The amount of wear leveling from 1 to 10. 1 means no wear leveling
N    * is used.
N    */
N    uint32 wearLevelingFactor;
N
N    /** If not zero, a redundant copy of the Em_EEPROM is included. */
N    uint8 redundantCopy;
N
N    /** If not zero, a blocking write to flash is used. Otherwise non-blocking
N    * write is used. This parameter is used only for PSoC 6.
N    */
N    uint8 blockingWrite;
N
N    /** The start address for the EEPROM memory in the user's flash. */
N    uint32 userFlashStartAddr;
N} cy_stc_eeprom_context_t;
N
N#if (CY_PSOC6)
X#if ((2u == 4u))
S
S    #define CY_EM_EEPROM_ID                         (CY_PDL_DRV_ID(0x1BuL))  /**< Em_EEPROM PDL ID */
S    /**
S    * \addtogroup group_em_eeprom_enums
S    * \{
S    * Specifies return values meaning.
S    */
S    /** A prefix for EEPROM function error return-values */
S    #define CY_EM_EEPROM_ID_ERROR                   (uint32_t)(CY_EM_EEPROM_ID | CY_PDL_STATUS_ERROR)
S
N#else
N
N    /** A prefix for EEPROM function status codes. For non-PSoC6 devices,
N    * prefix is zero.
N    */
N    #define CY_EM_EEPROM_ID_ERROR                       (0uL)
N
N#endif /* (CY_PSOC6) */
N
N
N/***************************************
N* Enumerated Types and Parameters
N***************************************/
N
N/** EEPROM return enumeration type */
Ntypedef enum
N{
N    CY_EM_EEPROM_SUCCESS      = 0x00uL,                             /**< The function executed successfully */
N    CY_EM_EEPROM_BAD_PARAM    = (CY_EM_EEPROM_ID_ERROR + 1uL),      /**< The input parameter is invalid */
X    CY_EM_EEPROM_BAD_PARAM    = ((0uL) + 1uL),       
N    CY_EM_EEPROM_BAD_CHECKSUM = (CY_EM_EEPROM_ID_ERROR + 2uL),      /**< The data in EEPROM is corrupted */
X    CY_EM_EEPROM_BAD_CHECKSUM = ((0uL) + 2uL),       
N    CY_EM_EEPROM_BAD_DATA     = (CY_EM_EEPROM_ID_ERROR + 3uL),      /**< Failed to place the EEPROM in flash */
X    CY_EM_EEPROM_BAD_DATA     = ((0uL) + 3uL),       
N    CY_EM_EEPROM_WRITE_FAIL   = (CY_EM_EEPROM_ID_ERROR + 4uL)       /**< Write to EEPROM failed */
X    CY_EM_EEPROM_WRITE_FAIL   = ((0uL) + 4uL)        
N} cy_en_em_eeprom_status_t;
N
N/** \} group_em_eeprom_enums */
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
N/**
N* \addtogroup group_em_eeprom_functions
N* \{
N*/
Ncy_en_em_eeprom_status_t Cy_Em_EEPROM_Init(cy_stc_eeprom_config_t* config, cy_stc_eeprom_context_t * context);
Ncy_en_em_eeprom_status_t Cy_Em_EEPROM_Read(uint32 addr,
N                                        void * eepromData,
N                                        uint32 size,
N                                        cy_stc_eeprom_context_t * context);
Ncy_en_em_eeprom_status_t Cy_Em_EEPROM_Write(uint32 addr,
N                                            void * eepromData,
N                                            uint32 size,
N                                            cy_stc_eeprom_context_t * context);
Ncy_en_em_eeprom_status_t Cy_Em_EEPROM_Erase(cy_stc_eeprom_context_t * context);
Nuint32 Cy_Em_EEPROM_NumWrites(cy_stc_eeprom_context_t * context);
N/** \} group_em_eeprom_functions */
N
N
N/***************************************
N* API Constants
N***************************************/
N/**
N* \addtogroup group_em_eeprom_macros
N* \{
N*/
N/** Library major version */
N#define CY_EM_EEPROM_VERSION_MAJOR                  (2)
N
N/** Library minor version */
N#define CY_EM_EEPROM_VERSION_MINOR                  (0)
N
N/** Defines the maximum data length that can be stored in one flash row */
N#define CY_EM_EEPROM_EEPROM_DATA_LEN                (CY_EM_EEPROM_FLASH_SIZEOF_ROW / 2u)
N
N/** \} group_em_eeprom_macros */
N
N
N/***************************************
N* Macro definitions
N***************************************/
N/** \cond INTERNAL */
N
N/* Defines the size of flash row */
N#define CY_EM_EEPROM_FLASH_SIZEOF_ROW               (CY_FLASH_SIZEOF_ROW)
N
N/* Device specific flash constants */
N#if (!CY_PSOC6)
X#if (!(2u == 4u))
N    #define CY_EM_EEPROM_FLASH_BASE_ADDR                (CYDEV_FLASH_BASE)
N    #define CY_EM_EEPROM_FLASH_SIZE                     (CYDEV_FLASH_SIZE)
N    #define CY_EM_EEPROM_ROWS_IN_ARRAY                  (CY_FLASH_SIZEOF_ARRAY / CY_EM_EEPROM_FLASH_SIZEOF_ROW)
N    #if (CY_PSOC3)
X    #if ((2u == 1u))
S        #define CY_EM_EEPROM_CODE_MEM_CLASS_PREFIX          (0xff0000uL)
S        #define CY_EM_EEPROM_CODE_ADDR_END                  \
S                        (CY_EM_EEPROM_CODE_MEM_CLASS_PREFIX + (CY_EM_EEPROM_FLASH_SIZE - 1u))
X        #define CY_EM_EEPROM_CODE_ADDR_END                                          (CY_EM_EEPROM_CODE_MEM_CLASS_PREFIX + (CY_EM_EEPROM_FLASH_SIZE - 1u))
S        #define CY_EM_EEPROM_CODE_ADDR_MASK                 (0xffffu)
S        /* Checks if the EEPROM is in flash range */
S        #define CY_EM_EEPROM_IS_IN_FLASH_RANGE(startAddr, endAddr) \
S                        (((startAddr) > CY_EM_EEPROM_CODE_MEM_CLASS_PREFIX) && \
S                         ((endAddr) <= CY_EM_EEPROM_CODE_ADDR_END))
X        #define CY_EM_EEPROM_IS_IN_FLASH_RANGE(startAddr, endAddr)                         (((startAddr) > CY_EM_EEPROM_CODE_MEM_CLASS_PREFIX) &&                          ((endAddr) <= CY_EM_EEPROM_CODE_ADDR_END))
N    #else
N        /* Checks is the EEPROM is in flash range */
N        #define CY_EM_EEPROM_IS_IN_FLASH_RANGE(startAddr, endAddr) \
N                        (((startAddr) > CY_EM_EEPROM_FLASH_BASE_ADDR) && ((endAddr) <= CY_EM_EEPROM_FLASH_END_ADDR))
X        #define CY_EM_EEPROM_IS_IN_FLASH_RANGE(startAddr, endAddr)                         (((startAddr) > CY_EM_EEPROM_FLASH_BASE_ADDR) && ((endAddr) <= CY_EM_EEPROM_FLASH_END_ADDR))
N    #endif /* (CY_PSOC3) */
N#else
S    #define CY_EM_EEPROM_FLASH_BASE_ADDR                (CY_FLASH_BASE)
S    #define CY_EM_EEPROM_FLASH_SIZE                     (CY_FLASH_SIZE)
S    #define CY_EM_EEPROM_EM_EEPROM_BASE_ADDR            (CY_EM_EEPROM_BASE)
S    #define CY_EM_EEPROM_EM_EEPROM_SIZE                 (CY_EM_EEPROM_SIZE)
S    #define CY_EM_EEPROM_EM_EEPROM_END_ADDR             (CY_EM_EEPROM_EM_EEPROM_BASE_ADDR + CY_EM_EEPROM_EM_EEPROM_SIZE)
S    /* Checks is the EEPROM is in flash range */
S    #define CY_EM_EEPROM_IS_IN_FLASH_RANGE(startAddr, endAddr) \
S                    (((((startAddr) > CY_EM_EEPROM_FLASH_BASE_ADDR) && ((endAddr) <= CY_EM_EEPROM_FLASH_END_ADDR)) || \
S                      (((startAddr) >= CY_EM_EEPROM_EM_EEPROM_BASE_ADDR) && \
S                                                                    ((endAddr) <= CY_EM_EEPROM_EM_EEPROM_END_ADDR))))
X    #define CY_EM_EEPROM_IS_IN_FLASH_RANGE(startAddr, endAddr)                     (((((startAddr) > CY_EM_EEPROM_FLASH_BASE_ADDR) && ((endAddr) <= CY_EM_EEPROM_FLASH_END_ADDR)) ||                       (((startAddr) >= CY_EM_EEPROM_EM_EEPROM_BASE_ADDR) &&                                                                     ((endAddr) <= CY_EM_EEPROM_EM_EEPROM_END_ADDR))))
N#endif /* (!CY_PSOC6) */
N
N#define CY_EM_EEPROM_FLASH_END_ADDR                 (CY_EM_EEPROM_FLASH_BASE_ADDR + CY_EM_EEPROM_FLASH_SIZE)
N
N/* Defines the length of EEPROM data that can be stored in Em_EEPROM header */
N#define CY_EM_EEPROM_HEADER_DATA_LEN                ((CY_EM_EEPROM_FLASH_SIZEOF_ROW / 2u) - 16u)
N
N#define CY_EM_EEPROM_ADDR_IN_RANGE                  (1u)
N
N/* Return CY_EM_EEPROM_ADDR_IN_RANGE if addr exceeded the upper range of
N* EEPROM. The wear leveling overhead is included in the range but redundant copy
N* is excluded.
N*/
N#define CY_EM_EEPROM_IS_ADDR_EXCEED_RANGE(addr, endEepromAddr) \
N                                    (((addr) >= (endEepromAddr)) ? (0u) : (CY_EM_EEPROM_ADDR_IN_RANGE))
X#define CY_EM_EEPROM_IS_ADDR_EXCEED_RANGE(addr, endEepromAddr)                                     (((addr) >= (endEepromAddr)) ? (0u) : (CY_EM_EEPROM_ADDR_IN_RANGE))
N
N/* Check to see if the specified address is present in the EEPROM */
N#define CY_EM_EEPROM_IS_ADDR_IN_RANGE(addr, startEepromAddr, endEepromAddr) \
N                                    (((addr) > (startEepromAddr)) ? \
N                                    (((addr) < (endEepromAddr)) ? (CY_EM_EEPROM_ADDR_IN_RANGE) : (0u)) : (0u))
X#define CY_EM_EEPROM_IS_ADDR_IN_RANGE(addr, startEepromAddr, endEepromAddr)                                     (((addr) > (startEepromAddr)) ?                                     (((addr) < (endEepromAddr)) ? (CY_EM_EEPROM_ADDR_IN_RANGE) : (0u)) : (0u))
N
N/* Check if the EEPROM address locations from startAddr1 to endAddr1
N* are crossed with EEPROM address locations from startAddr2 to endAddr2.
N*/
N#define CY_EM_EEPROM_IS_ADDRESES_CROSSING(startAddr1, endAddr1 , startAddr2, endAddr2) \
N                                    (((startAddr1) > (startAddr2)) ? (((startAddr1) >= (endAddr2)) ? (0u) : (1u) ) : \
N                                    (((startAddr2) >= (endAddr1)) ? (0u) : (1u)))
X#define CY_EM_EEPROM_IS_ADDRESES_CROSSING(startAddr1, endAddr1 , startAddr2, endAddr2)                                     (((startAddr1) > (startAddr2)) ? (((startAddr1) >= (endAddr2)) ? (0u) : (1u) ) :                                     (((startAddr2) >= (endAddr1)) ? (0u) : (1u)))
N
N/* Return the pointer to the start of the redundant copy of the EEPROM */
N#define CY_EM_EEPROM_GET_REDNT_COPY_ADDR_BASE(numRows, wearLeveling, eepromStartAddr) \
N                                    ((((numRows) * CY_EM_EEPROM_FLASH_SIZEOF_ROW) * (wearLeveling)) + (eepromStartAddr))
X#define CY_EM_EEPROM_GET_REDNT_COPY_ADDR_BASE(numRows, wearLeveling, eepromStartAddr)                                     ((((numRows) * CY_EM_EEPROM_FLASH_SIZEOF_ROW) * (wearLeveling)) + (eepromStartAddr))
N
N/* Return the number of the row in EM_EEPROM which contains an address defined by
N* rowAddr.
N */
N#define CY_EM_EEPROM_GET_ACT_ROW_NUM_FROM_ADDR(rowAddr, maxRows, eepromStartAddr) \
N                                    ((((rowAddr) - (eepromStartAddr)) / CY_EM_EEPROM_FLASH_SIZEOF_ROW) % (maxRows))
X#define CY_EM_EEPROM_GET_ACT_ROW_NUM_FROM_ADDR(rowAddr, maxRows, eepromStartAddr)                                     ((((rowAddr) - (eepromStartAddr)) / CY_EM_EEPROM_FLASH_SIZEOF_ROW) % (maxRows))
N
N
N/** Returns the size allocated for the EEPROM excluding wear leveling and
N* redundant copy overhead.
N*/
N#define CY_EM_EEPROM_GET_EEPROM_SIZE(numRows)       ((numRows) * CY_EM_EEPROM_FLASH_SIZEOF_ROW)
N
N/* Check if the given address belongs to the EEPROM address of the row
N* specified by rowNum.
N*/
N#define CY_EM_EEPROM_IS_ADDR_IN_ROW_RANGE(addr, rowNum) \
N                                    (((addr) < ((rowNum) * (CY_EM_EEPROM_FLASH_SIZEOF_ROW / 2u))) ? (0u) : \
N                                    (((addr) > ((((rowNum) + 1u) * (CY_EM_EEPROM_FLASH_SIZEOF_ROW / 2u)) - 1u)) ? \
N                                    (0u) : (1u)))
X#define CY_EM_EEPROM_IS_ADDR_IN_ROW_RANGE(addr, rowNum)                                     (((addr) < ((rowNum) * (CY_EM_EEPROM_FLASH_SIZEOF_ROW / 2u))) ? (0u) :                                     (((addr) > ((((rowNum) + 1u) * (CY_EM_EEPROM_FLASH_SIZEOF_ROW / 2u)) - 1u)) ?                                     (0u) : (1u)))
N
N/* CRC-8 constants */
N#define CY_EM_EEPROM_CRC8_POLYNOM                   ((uint8)(0x31u))
N#define CY_EM_EEPROM_CRC8_POLYNOM_LEN               (8u)
N#define CY_EM_EEPROM_CRC8_SEED                      (0xFFu)
N#define CY_EM_EEPROM_CRC8_XOR_VAL                   ((uint8) (0x80u))
N
N#define CY_EM_EEPROM_CALCULATE_CRC8(crc)            \
N                  ((CY_EM_EEPROM_CRC8_XOR_VAL == ((crc) & CY_EM_EEPROM_CRC8_XOR_VAL)) ? \
N                  ((uint8)(((uint8)((uint8)((crc) << 1u))) ^ CY_EM_EEPROM_CRC8_POLYNOM)) : ((uint8)((crc) << 1u)))
X#define CY_EM_EEPROM_CALCULATE_CRC8(crc)                              ((CY_EM_EEPROM_CRC8_XOR_VAL == ((crc) & CY_EM_EEPROM_CRC8_XOR_VAL)) ?                   ((uint8)(((uint8)((uint8)((crc) << 1u))) ^ CY_EM_EEPROM_CRC8_POLYNOM)) : ((uint8)((crc) << 1u)))
N
N#define CY_EM_EEPROM_GET_SEQ_NUM(addr)                (*(uint32*)(addr))
N
N/** \endcond */
N
N/**
N* \addtogroup group_em_eeprom_macros
N* \{
N*/
N
N/** Calculate the number of flash rows required to create an Em_EEPROM of
N* dataSize.
N*/
N#define CY_EM_EEPROM_GET_NUM_ROWS_IN_EEPROM(dataSize) \
N                                    (((dataSize) / (CY_EM_EEPROM_EEPROM_DATA_LEN)) + \
N                                    ((((dataSize) % (CY_EM_EEPROM_EEPROM_DATA_LEN)) != 0u) ? 1U : 0U))
X#define CY_EM_EEPROM_GET_NUM_ROWS_IN_EEPROM(dataSize)                                     (((dataSize) / (CY_EM_EEPROM_EEPROM_DATA_LEN)) +                                     ((((dataSize) % (CY_EM_EEPROM_EEPROM_DATA_LEN)) != 0u) ? 1U : 0U))
N
N/** Returns the size of flash allocated for EEPROM including wear leveling and
N* redundant copy overhead.
N*/
N#define CY_EM_EEPROM_GET_PHYSICAL_SIZE(dataSize, wearLeveling, redundantCopy) \
N                                    (((CY_EM_EEPROM_GET_NUM_ROWS_IN_EEPROM(dataSize) * \
N                                    CY_EM_EEPROM_FLASH_SIZEOF_ROW) * \
N                                    (wearLeveling)) * (1uL + (redundantCopy)))
X#define CY_EM_EEPROM_GET_PHYSICAL_SIZE(dataSize, wearLeveling, redundantCopy)                                     (((CY_EM_EEPROM_GET_NUM_ROWS_IN_EEPROM(dataSize) *                                     CY_EM_EEPROM_FLASH_SIZEOF_ROW) *                                     (wearLeveling)) * (1uL + (redundantCopy)))
N
N/** \} group_em_eeprom_macros */
N
N
N/******************************************************************************
N* Local definitions
N*******************************************************************************/
N/** \cond INTERNAL */
N
N/* Offsets for 32-bit RAM buffer addressing */
N#define CY_EM_EEPROM_EEPROM_DATA_OFFSET_U32         ((CY_EM_EEPROM_FLASH_SIZEOF_ROW / 2u) / 4u)
N#define CY_EM_EEPROM_HEADER_SEQ_NUM_OFFSET_U32      (0u)
N#define CY_EM_EEPROM_HEADER_ADDR_OFFSET_U32         (1u)
N#define CY_EM_EEPROM_HEADER_LEN_OFFSET_U32          (2u)
N#define CY_EM_EEPROM_HEADER_DATA_OFFSET_U32         (3u)
N#define CY_EM_EEPROM_HEADER_CHECKSUM_OFFSET_U32     (CY_EM_EEPROM_EEPROM_DATA_OFFSET_U32 - 1u)
N
N/* The same offsets as above used for direct memory addressing */
N#define CY_EM_EEPROM_EEPROM_DATA_OFFSET             (CY_EM_EEPROM_FLASH_SIZEOF_ROW / 2u)
N#define CY_EM_EEPROM_HEADER_ADDR_OFFSET             (4u)
N#define CY_EM_EEPROM_HEADER_LEN_OFFSET              (8u)
N#define CY_EM_EEPROM_HEADER_DATA_OFFSET             (12u)
N#define CY_EM_EEPROM_HEADER_CHECKSUM_OFFSET         (CY_EM_EEPROM_EEPROM_DATA_OFFSET - 4u)
N
N#define CY_EM_EEPROM_U32_DIV                        (4u)
N
N/* Maximum wear leveling value */
N#define CY_EM_EEPROM_MAX_WEAR_LEVELING_FACTOR       (10u)
N
N/* Maximum allowed flash row write/erase operation duration */
N#define CY_EM_EEPROM_MAX_WRITE_DURATION_MS          (50u)
N
N/** \endcond */
N
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N#endif /* CY_EM_EEPROM_H */
N
N
N/* [] END OF FILE */
L 25 "Generated_Source\PSoC4\Em_EEPROM.h" 2
N#else
S    #include "syslib/cy_syslib.h"
S    #include "em_eeprom/cy_em_eeprom.h"
N#endif /* (CYDEV_CHIP_FAMILY_USED != CYDEV_CHIP_FAMILY_PSOC6) */
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {
N#endif
N
N
N/***************************************
N* Conditional Compilation Parameters
N***************************************/
N#define Em_EEPROM_STORAGE_EM_EEPROM          (0U != Em_EEPROM_USE_EMULATED_EEEPROM)
N
N#if !defined(CY_PSOC6)
X#if !1L
S    #define CY_PSOC6                                    (CYDEV_CHIP_FAMILY_USED == CYDEV_CHIP_FAMILY_PSOC6)
N#endif /* !defined(CY_PSOC6) */
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
Ncy_en_em_eeprom_status_t Em_EEPROM_Init(uint32 startAddress);
N
N/*******************************************************************************
N* Function Name: Em_EEPROM_Write
N****************************************************************************//**
N*
N* Invokes the Cy_Em_EEPROM_Write() function. In case of PSoC 6 the function 
N* is located in Cy_Em_EEPROM middleware library which is part of PDL. In case if
N* it is utilized in the design based on non-PSOC 6 device the function is 
N* located in internal design wide resource component - Em_EEPROM_Dynamic.
N*
N*******************************************************************************/
N#define Em_EEPROM_Write(addr, eepromData, size) \
N                                            Cy_Em_EEPROM_Write(addr, eepromData, size, &Em_EEPROM_context)
X#define Em_EEPROM_Write(addr, eepromData, size)                                             Cy_Em_EEPROM_Write(addr, eepromData, size, &Em_EEPROM_context)
N
N
N/*******************************************************************************
N* Function Name: Em_EEPROM_Read
N****************************************************************************//**
N*
N* Invokes the Cy_Em_EEPROM_Read() function. In case of PSoC 6 the function 
N* is located in Cy_Em_EEPROM middleware library which is part of PDL. In case if
N* it is utilized in the design based on non-PSOC 6 device the function is 
N* located in internal design wide resource component - Em_EEPROM_Dynamic.
N*
N*******************************************************************************/
N#define Em_EEPROM_Read(addr, eepromData, size) \
N                                            Cy_Em_EEPROM_Read(addr, eepromData, size, &Em_EEPROM_context)
X#define Em_EEPROM_Read(addr, eepromData, size)                                             Cy_Em_EEPROM_Read(addr, eepromData, size, &Em_EEPROM_context)
N
N
N/*******************************************************************************
N* Function Name: Em_EEPROM_Erase
N****************************************************************************//**
N*
N* Invokes the Cy_Em_EEPROM_Erase() function. In case of PSoC 6 the function 
N* is located in Cy_Em_EEPROM middleware library which is part of PDL. In case if
N* it is utilized in the design based on non-PSOC 6 device the function is 
N* located in internal design wide resource component - Em_EEPROM_Dynamic.
N*
N*******************************************************************************/
N#define Em_EEPROM_Erase()                Cy_Em_EEPROM_Erase(&Em_EEPROM_context)
N
N
N/*******************************************************************************
N* Function Name: Em_EEPROM_NumWrites
N****************************************************************************//**
N*
N* Invokes the Cy_Em_EEPROM_NumWrites() function. In case of PSoC 6 the function 
N* is located in Cy_Em_EEPROM middleware library which is part of PDL. In case if
N* it is utilized in the design based on non-PSOC 6 device the function is 
N* located in internal design wide resource component - Em_EEPROM_Dynamic.
N*
N*******************************************************************************/
N#define Em_EEPROM_NumWrites()            Cy_Em_EEPROM_NumWrites(&Em_EEPROM_context)
N
N
N/***************************************
N*   Initial Parameter Constants
N****************************************/
N
N/* Defines the location of the EEPROM storage (User flash or Emulated EEPROM flash area) */
N#define Em_EEPROM_USE_EMULATED_EEEPROM       (1U)
N/* Defines if blocking or non-blocking writes will be used for writing flash */
N#define Em_EEPROM_USE_BLOCKING_WRITE         (0U)
N/* The EEPROM size required by the user */
N#define Em_EEPROM_EEPROM_SIZE                (6144U)
N/* The actual size of flash used to implement the EEPROM with the
N* configuration entered by the user.
N*/
N#define Em_EEPROM_ACTUAL_SIZE                (12288U)
N#define Em_EEPROM_PHYSICAL_SIZE              (Em_EEPROM_ACTUAL_SIZE)
N/* Holds the value of Wear Leveling option enter by user */
N#define Em_EEPROM_WEAR_LEVEL_FACTOR          (1U)
N/* Holds the value of Redundant Copy option enter by user */
N#define Em_EEPROM_REDUNDANT_COPY             (0U)
N
N
N/***************************************
N*       Global Variables
N***************************************/
Nextern cy_stc_eeprom_config_t const Em_EEPROM_config;
Nextern cy_stc_eeprom_context_t Em_EEPROM_context;
Nextern const uint8 Em_EEPROM_em_EepromStorage[Em_EEPROM_ACTUAL_SIZE];
Xextern const uint8 Em_EEPROM_em_EepromStorage[(12288U)];
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N#endif /* CY_EM_EEPROM_Em_EEPROM_H */
N
N
N/* [] END OF FILE */
L 97 "Generated_Source\PSoC4\project.h" 2
N#include "Opamp_Rf.h"
L 1 "Generated_Source\PSoC4\Opamp_Rf.h" 1
N/*******************************************************************************
N* File Name: Opamp_Rf.h
N* Version 1.20
N*
N* Description:
N*  This file contains the function prototypes and constants used in
N*  the Opamp (Analog Buffer) Component.
N*
N*
N********************************************************************************
N* Copyright 2013-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N
N#if !defined(CY_OPAMP_Opamp_Rf_H)
X#if !0L
N#define CY_OPAMP_Opamp_Rf_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N
N
N/***************************************
N*       Type Definitions
N***************************************/
N
N/* Structure to save state before go to sleep */
Ntypedef struct
N{
N    uint8  enableState;
N} Opamp_Rf_BACKUP_STRUCT;
N
N
N/**************************************
N*        Function Prototypes
N**************************************/
Nvoid Opamp_Rf_Init(void);
Nvoid Opamp_Rf_Enable(void);
Nvoid Opamp_Rf_Start(void);
Nvoid Opamp_Rf_Stop(void);
Nvoid Opamp_Rf_SetPower(uint32 power);
Nvoid Opamp_Rf_PumpControl(uint32 onOff);
Nvoid Opamp_Rf_Sleep(void);
Nvoid Opamp_Rf_Wakeup(void);
Nvoid Opamp_Rf_SaveConfig(void);
Nvoid Opamp_Rf_RestoreConfig(void);
N
N
N/**************************************
N*           API Constants
N**************************************/
N
N/* Parameters for SetPower() function */
N#define Opamp_Rf_LOW_POWER      (1u)
N#define Opamp_Rf_MED_POWER      (2u)
N#define Opamp_Rf_HIGH_POWER     (3u)
N
N
N/* Parameters for PumpControl() function */
N#define Opamp_Rf_PUMP_ON        (1u)
N#define Opamp_Rf_PUMP_OFF       (0u)
N
N
N/***************************************
N*   Initial Parameter Constants
N****************************************/
N
N#define Opamp_Rf_OUTPUT_CURRENT         (0u)
N#define Opamp_Rf_POWER                  (1u)
N#define Opamp_Rf_MODE                   (1u)
N#define Opamp_Rf_OA_COMP_TRIM_VALUE     (1u)
N#define Opamp_Rf_DEEPSLEEP_SUPPORT      (0u)
N
N
N/***************************************
N*    Variables with External Linkage
N***************************************/
N
Nextern uint8  Opamp_Rf_initVar;
N
N
N/**************************************
N*             Registers
N**************************************/
N
N#ifdef CYIPBLOCK_m0s8pass4b_VERSION
S    #define Opamp_Rf_CTB_CTRL_REG       (*(reg32 *) Opamp_Rf_cy_psoc4_abuf__CTB_CTB_CTRL)
S    #define Opamp_Rf_CTB_CTRL_PTR       ( (reg32 *) Opamp_Rf_cy_psoc4_abuf__CTB_CTB_CTRL)
N#else
N    #define Opamp_Rf_CTB_CTRL_REG       (*(reg32 *) Opamp_Rf_cy_psoc4_abuf__CTBM_CTB_CTRL)
N    #define Opamp_Rf_CTB_CTRL_PTR       ( (reg32 *) Opamp_Rf_cy_psoc4_abuf__CTBM_CTB_CTRL)
N#endif /* CYIPBLOCK_m0s8pass4b_VERSION */
N
N#define Opamp_Rf_OA_RES_CTRL_REG    (*(reg32 *) Opamp_Rf_cy_psoc4_abuf__OA_RES_CTRL)
N#define Opamp_Rf_OA_RES_CTRL_PTR    ( (reg32 *) Opamp_Rf_cy_psoc4_abuf__OA_RES_CTRL)
N#define Opamp_Rf_OA_COMP_TRIM_REG   (*(reg32 *) Opamp_Rf_cy_psoc4_abuf__OA_COMP_TRIM)
N#define Opamp_Rf_OA_COMP_TRIM_PTR   ( (reg32 *) Opamp_Rf_cy_psoc4_abuf__OA_COMP_TRIM)
N
N
N/***************************************
N*        Registers Constants
N***************************************/
N
N/* Opamp_Rf_CTB_CTRL_REG */
N#define Opamp_Rf_CTB_CTRL_DEEPSLEEP_ON_SHIFT    (30u)   /* [30] Selects behavior CTB IP in the DeepSleep power mode */
N#define Opamp_Rf_CTB_CTRL_ENABLED_SHIFT         (31u)   /* [31] Enable of the CTB IP */
N
N
N#define Opamp_Rf_CTB_CTRL_DEEPSLEEP_ON          ((uint32) 0x01u << Opamp_Rf_CTB_CTRL_DEEPSLEEP_ON_SHIFT)
N#define Opamp_Rf_CTB_CTRL_ENABLED               ((uint32) 0x01u << Opamp_Rf_CTB_CTRL_ENABLED_SHIFT)
N
N
N/* Opamp_Rf_OA_RES_CTRL_REG */
N#define Opamp_Rf_OA_PWR_MODE_SHIFT          (0u)    /* [1:0]    Power level */
N#define Opamp_Rf_OA_DRIVE_STR_SEL_SHIFT     (2u)    /* [2]      Opamp output strenght select: 0 - 1x, 1 - 10x */
N#define Opamp_Rf_OA_COMP_EN_SHIFT           (4u)    /* [4]      CTB IP mode: 0 - Opamp, 1 - Comparator  */
N#define Opamp_Rf_OA_PUMP_EN_SHIFT           (11u)   /* [11]     Pump enable */
N
N
N#define Opamp_Rf_OA_PWR_MODE                ((uint32) 0x02u << Opamp_Rf_OA_PWR_MODE_SHIFT)
N#define Opamp_Rf_OA_PWR_MODE_MASK           ((uint32) 0x03u << Opamp_Rf_OA_PWR_MODE_SHIFT)
N#define Opamp_Rf_OA_DRIVE_STR_SEL_1X        ((uint32) 0x00u << Opamp_Rf_OA_DRIVE_STR_SEL_SHIFT)
N#define Opamp_Rf_OA_DRIVE_STR_SEL_10X       ((uint32) 0x01u << Opamp_Rf_OA_DRIVE_STR_SEL_SHIFT)
N#define Opamp_Rf_OA_DRIVE_STR_SEL_MASK      ((uint32) 0x01u << Opamp_Rf_OA_DRIVE_STR_SEL_SHIFT)
N#define Opamp_Rf_OA_COMP_EN                 ((uint32) 0x00u << Opamp_Rf_OA_COMP_EN_SHIFT)
N#define Opamp_Rf_OA_PUMP_EN                 ((uint32) 0x01u << Opamp_Rf_OA_PUMP_EN_SHIFT)
N
N
N/***************************************
N*       Init Macros Definitions
N***************************************/
N
N#define Opamp_Rf_GET_DEEPSLEEP_ON(deepSleep)    ((0u != (deepSleep)) ? (Opamp_Rf_CTB_CTRL_DEEPSLEEP_ON) : (0u))
N#define Opamp_Rf_GET_OA_DRIVE_STR(current)      ((0u != (current)) ? (Opamp_Rf_OA_DRIVE_STR_SEL_10X) : \
N                                                                             (Opamp_Rf_OA_DRIVE_STR_SEL_1X))
X#define Opamp_Rf_GET_OA_DRIVE_STR(current)      ((0u != (current)) ? (Opamp_Rf_OA_DRIVE_STR_SEL_10X) :                                                                              (Opamp_Rf_OA_DRIVE_STR_SEL_1X))
N#define Opamp_Rf_GET_OA_PWR_MODE(mode)          ((mode) & Opamp_Rf_OA_PWR_MODE_MASK)
N#define Opamp_Rf_CHECK_PWR_MODE_OFF             (0u != (Opamp_Rf_OA_RES_CTRL_REG & \
N                                                                Opamp_Rf_OA_PWR_MODE_MASK))
X#define Opamp_Rf_CHECK_PWR_MODE_OFF             (0u != (Opamp_Rf_OA_RES_CTRL_REG &                                                                 Opamp_Rf_OA_PWR_MODE_MASK))
N
N/* Returns true if component available in Deep Sleep power mode*/ 
N#define Opamp_Rf_CHECK_DEEPSLEEP_SUPPORT        (0u != Opamp_Rf_DEEPSLEEP_SUPPORT) 
N
N#define Opamp_Rf_DEFAULT_CTB_CTRL (Opamp_Rf_GET_DEEPSLEEP_ON(Opamp_Rf_DEEPSLEEP_SUPPORT) | \
N                                           Opamp_Rf_CTB_CTRL_ENABLED)
X#define Opamp_Rf_DEFAULT_CTB_CTRL (Opamp_Rf_GET_DEEPSLEEP_ON(Opamp_Rf_DEEPSLEEP_SUPPORT) |                                            Opamp_Rf_CTB_CTRL_ENABLED)
N
N#define Opamp_Rf_DEFAULT_OA_RES_CTRL (Opamp_Rf_OA_COMP_EN | \
N                                              Opamp_Rf_GET_OA_DRIVE_STR(Opamp_Rf_OUTPUT_CURRENT))
X#define Opamp_Rf_DEFAULT_OA_RES_CTRL (Opamp_Rf_OA_COMP_EN |                                               Opamp_Rf_GET_OA_DRIVE_STR(Opamp_Rf_OUTPUT_CURRENT))
N
N#define Opamp_Rf_DEFAULT_OA_COMP_TRIM_REG (Opamp_Rf_OA_COMP_TRIM_VALUE)
N
N
N/***************************************
N* The following code is DEPRECATED and 
N* should not be used in new projects.
N***************************************/
N
N#define Opamp_Rf_LOWPOWER                   (Opamp_Rf_LOW_POWER)
N#define Opamp_Rf_MEDPOWER                   (Opamp_Rf_MED_POWER)
N#define Opamp_Rf_HIGHPOWER                  (Opamp_Rf_HIGH_POWER)
N
N/* PUMP ON/OFF defines */
N#define Opamp_Rf_PUMPON                     (Opamp_Rf_PUMP_ON)
N#define Opamp_Rf_PUMPOFF                    (Opamp_Rf_PUMP_OFF)
N
N#define Opamp_Rf_OA_CTRL                    (Opamp_Rf_CTB_CTRL_REG)
N#define Opamp_Rf_OA_RES_CTRL                (Opamp_Rf_OA_RES_CTRL_REG)
N
N/* Bit Field  OA_CTRL */
N#define Opamp_Rf_OA_CTB_EN_SHIFT            (Opamp_Rf_CTB_CTRL_ENABLED_SHIFT)
N#define Opamp_Rf_OA_PUMP_CTRL_SHIFT         (Opamp_Rf_OA_PUMP_EN_SHIFT)
N#define Opamp_Rf_OA_PUMP_EN_MASK            (0x800u)
N#define Opamp_Rf_PUMP_PROTECT_MASK          (1u)
N
N
N#endif    /* CY_OPAMP_Opamp_Rf_H */
N
N
N/* [] END OF FILE */
L 98 "Generated_Source\PSoC4\project.h" 2
N#include "Opamp_Bat.h"
L 1 "Generated_Source\PSoC4\Opamp_Bat.h" 1
N/*******************************************************************************
N* File Name: Opamp_Bat.h
N* Version 1.20
N*
N* Description:
N*  This file contains the function prototypes and constants used in
N*  the Opamp (Analog Buffer) Component.
N*
N*
N********************************************************************************
N* Copyright 2013-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N
N#if !defined(CY_OPAMP_Opamp_Bat_H)
X#if !0L
N#define CY_OPAMP_Opamp_Bat_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N
N
N/***************************************
N*       Type Definitions
N***************************************/
N
N/* Structure to save state before go to sleep */
Ntypedef struct
N{
N    uint8  enableState;
N} Opamp_Bat_BACKUP_STRUCT;
N
N
N/**************************************
N*        Function Prototypes
N**************************************/
Nvoid Opamp_Bat_Init(void);
Nvoid Opamp_Bat_Enable(void);
Nvoid Opamp_Bat_Start(void);
Nvoid Opamp_Bat_Stop(void);
Nvoid Opamp_Bat_SetPower(uint32 power);
Nvoid Opamp_Bat_PumpControl(uint32 onOff);
Nvoid Opamp_Bat_Sleep(void);
Nvoid Opamp_Bat_Wakeup(void);
Nvoid Opamp_Bat_SaveConfig(void);
Nvoid Opamp_Bat_RestoreConfig(void);
N
N
N/**************************************
N*           API Constants
N**************************************/
N
N/* Parameters for SetPower() function */
N#define Opamp_Bat_LOW_POWER      (1u)
N#define Opamp_Bat_MED_POWER      (2u)
N#define Opamp_Bat_HIGH_POWER     (3u)
N
N
N/* Parameters for PumpControl() function */
N#define Opamp_Bat_PUMP_ON        (1u)
N#define Opamp_Bat_PUMP_OFF       (0u)
N
N
N/***************************************
N*   Initial Parameter Constants
N****************************************/
N
N#define Opamp_Bat_OUTPUT_CURRENT         (0u)
N#define Opamp_Bat_POWER                  (2u)
N#define Opamp_Bat_MODE                   (1u)
N#define Opamp_Bat_OA_COMP_TRIM_VALUE     (3u)
N#define Opamp_Bat_DEEPSLEEP_SUPPORT      (0u)
N
N
N/***************************************
N*    Variables with External Linkage
N***************************************/
N
Nextern uint8  Opamp_Bat_initVar;
N
N
N/**************************************
N*             Registers
N**************************************/
N
N#ifdef CYIPBLOCK_m0s8pass4b_VERSION
S    #define Opamp_Bat_CTB_CTRL_REG       (*(reg32 *) Opamp_Bat_cy_psoc4_abuf__CTB_CTB_CTRL)
S    #define Opamp_Bat_CTB_CTRL_PTR       ( (reg32 *) Opamp_Bat_cy_psoc4_abuf__CTB_CTB_CTRL)
N#else
N    #define Opamp_Bat_CTB_CTRL_REG       (*(reg32 *) Opamp_Bat_cy_psoc4_abuf__CTBM_CTB_CTRL)
N    #define Opamp_Bat_CTB_CTRL_PTR       ( (reg32 *) Opamp_Bat_cy_psoc4_abuf__CTBM_CTB_CTRL)
N#endif /* CYIPBLOCK_m0s8pass4b_VERSION */
N
N#define Opamp_Bat_OA_RES_CTRL_REG    (*(reg32 *) Opamp_Bat_cy_psoc4_abuf__OA_RES_CTRL)
N#define Opamp_Bat_OA_RES_CTRL_PTR    ( (reg32 *) Opamp_Bat_cy_psoc4_abuf__OA_RES_CTRL)
N#define Opamp_Bat_OA_COMP_TRIM_REG   (*(reg32 *) Opamp_Bat_cy_psoc4_abuf__OA_COMP_TRIM)
N#define Opamp_Bat_OA_COMP_TRIM_PTR   ( (reg32 *) Opamp_Bat_cy_psoc4_abuf__OA_COMP_TRIM)
N
N
N/***************************************
N*        Registers Constants
N***************************************/
N
N/* Opamp_Bat_CTB_CTRL_REG */
N#define Opamp_Bat_CTB_CTRL_DEEPSLEEP_ON_SHIFT    (30u)   /* [30] Selects behavior CTB IP in the DeepSleep power mode */
N#define Opamp_Bat_CTB_CTRL_ENABLED_SHIFT         (31u)   /* [31] Enable of the CTB IP */
N
N
N#define Opamp_Bat_CTB_CTRL_DEEPSLEEP_ON          ((uint32) 0x01u << Opamp_Bat_CTB_CTRL_DEEPSLEEP_ON_SHIFT)
N#define Opamp_Bat_CTB_CTRL_ENABLED               ((uint32) 0x01u << Opamp_Bat_CTB_CTRL_ENABLED_SHIFT)
N
N
N/* Opamp_Bat_OA_RES_CTRL_REG */
N#define Opamp_Bat_OA_PWR_MODE_SHIFT          (0u)    /* [1:0]    Power level */
N#define Opamp_Bat_OA_DRIVE_STR_SEL_SHIFT     (2u)    /* [2]      Opamp output strenght select: 0 - 1x, 1 - 10x */
N#define Opamp_Bat_OA_COMP_EN_SHIFT           (4u)    /* [4]      CTB IP mode: 0 - Opamp, 1 - Comparator  */
N#define Opamp_Bat_OA_PUMP_EN_SHIFT           (11u)   /* [11]     Pump enable */
N
N
N#define Opamp_Bat_OA_PWR_MODE                ((uint32) 0x02u << Opamp_Bat_OA_PWR_MODE_SHIFT)
N#define Opamp_Bat_OA_PWR_MODE_MASK           ((uint32) 0x03u << Opamp_Bat_OA_PWR_MODE_SHIFT)
N#define Opamp_Bat_OA_DRIVE_STR_SEL_1X        ((uint32) 0x00u << Opamp_Bat_OA_DRIVE_STR_SEL_SHIFT)
N#define Opamp_Bat_OA_DRIVE_STR_SEL_10X       ((uint32) 0x01u << Opamp_Bat_OA_DRIVE_STR_SEL_SHIFT)
N#define Opamp_Bat_OA_DRIVE_STR_SEL_MASK      ((uint32) 0x01u << Opamp_Bat_OA_DRIVE_STR_SEL_SHIFT)
N#define Opamp_Bat_OA_COMP_EN                 ((uint32) 0x00u << Opamp_Bat_OA_COMP_EN_SHIFT)
N#define Opamp_Bat_OA_PUMP_EN                 ((uint32) 0x01u << Opamp_Bat_OA_PUMP_EN_SHIFT)
N
N
N/***************************************
N*       Init Macros Definitions
N***************************************/
N
N#define Opamp_Bat_GET_DEEPSLEEP_ON(deepSleep)    ((0u != (deepSleep)) ? (Opamp_Bat_CTB_CTRL_DEEPSLEEP_ON) : (0u))
N#define Opamp_Bat_GET_OA_DRIVE_STR(current)      ((0u != (current)) ? (Opamp_Bat_OA_DRIVE_STR_SEL_10X) : \
N                                                                             (Opamp_Bat_OA_DRIVE_STR_SEL_1X))
X#define Opamp_Bat_GET_OA_DRIVE_STR(current)      ((0u != (current)) ? (Opamp_Bat_OA_DRIVE_STR_SEL_10X) :                                                                              (Opamp_Bat_OA_DRIVE_STR_SEL_1X))
N#define Opamp_Bat_GET_OA_PWR_MODE(mode)          ((mode) & Opamp_Bat_OA_PWR_MODE_MASK)
N#define Opamp_Bat_CHECK_PWR_MODE_OFF             (0u != (Opamp_Bat_OA_RES_CTRL_REG & \
N                                                                Opamp_Bat_OA_PWR_MODE_MASK))
X#define Opamp_Bat_CHECK_PWR_MODE_OFF             (0u != (Opamp_Bat_OA_RES_CTRL_REG &                                                                 Opamp_Bat_OA_PWR_MODE_MASK))
N
N/* Returns true if component available in Deep Sleep power mode*/ 
N#define Opamp_Bat_CHECK_DEEPSLEEP_SUPPORT        (0u != Opamp_Bat_DEEPSLEEP_SUPPORT) 
N
N#define Opamp_Bat_DEFAULT_CTB_CTRL (Opamp_Bat_GET_DEEPSLEEP_ON(Opamp_Bat_DEEPSLEEP_SUPPORT) | \
N                                           Opamp_Bat_CTB_CTRL_ENABLED)
X#define Opamp_Bat_DEFAULT_CTB_CTRL (Opamp_Bat_GET_DEEPSLEEP_ON(Opamp_Bat_DEEPSLEEP_SUPPORT) |                                            Opamp_Bat_CTB_CTRL_ENABLED)
N
N#define Opamp_Bat_DEFAULT_OA_RES_CTRL (Opamp_Bat_OA_COMP_EN | \
N                                              Opamp_Bat_GET_OA_DRIVE_STR(Opamp_Bat_OUTPUT_CURRENT))
X#define Opamp_Bat_DEFAULT_OA_RES_CTRL (Opamp_Bat_OA_COMP_EN |                                               Opamp_Bat_GET_OA_DRIVE_STR(Opamp_Bat_OUTPUT_CURRENT))
N
N#define Opamp_Bat_DEFAULT_OA_COMP_TRIM_REG (Opamp_Bat_OA_COMP_TRIM_VALUE)
N
N
N/***************************************
N* The following code is DEPRECATED and 
N* should not be used in new projects.
N***************************************/
N
N#define Opamp_Bat_LOWPOWER                   (Opamp_Bat_LOW_POWER)
N#define Opamp_Bat_MEDPOWER                   (Opamp_Bat_MED_POWER)
N#define Opamp_Bat_HIGHPOWER                  (Opamp_Bat_HIGH_POWER)
N
N/* PUMP ON/OFF defines */
N#define Opamp_Bat_PUMPON                     (Opamp_Bat_PUMP_ON)
N#define Opamp_Bat_PUMPOFF                    (Opamp_Bat_PUMP_OFF)
N
N#define Opamp_Bat_OA_CTRL                    (Opamp_Bat_CTB_CTRL_REG)
N#define Opamp_Bat_OA_RES_CTRL                (Opamp_Bat_OA_RES_CTRL_REG)
N
N/* Bit Field  OA_CTRL */
N#define Opamp_Bat_OA_CTB_EN_SHIFT            (Opamp_Bat_CTB_CTRL_ENABLED_SHIFT)
N#define Opamp_Bat_OA_PUMP_CTRL_SHIFT         (Opamp_Bat_OA_PUMP_EN_SHIFT)
N#define Opamp_Bat_OA_PUMP_EN_MASK            (0x800u)
N#define Opamp_Bat_PUMP_PROTECT_MASK          (1u)
N
N
N#endif    /* CY_OPAMP_Opamp_Bat_H */
N
N
N/* [] END OF FILE */
L 99 "Generated_Source\PSoC4\project.h" 2
N#include "TEST.h"
L 1 "Generated_Source\PSoC4\TEST.h" 1
N/*******************************************************************************
N* File Name: TEST.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_TEST_H) /* Pins TEST_H */
X#if !0L  
N#define CY_PINS_TEST_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "TEST_aliases.h"
L 1 "Generated_Source\PSoC4\TEST_aliases.h" 1
N/*******************************************************************************
N* File Name: TEST.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_TEST_ALIASES_H) /* Pins TEST_ALIASES_H */
X#if !0L  
N#define CY_PINS_TEST_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "cypins.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define TEST_0			(TEST__0__PC)
N#define TEST_0_PS		(TEST__0__PS)
N#define TEST_0_PC		(TEST__0__PC)
N#define TEST_0_DR		(TEST__0__DR)
N#define TEST_0_SHIFT	(TEST__0__SHIFT)
N#define TEST_0_INTR	((uint16)((uint16)0x0003u << (TEST__0__SHIFT*2u)))
N
N#define TEST_INTR_ALL	 ((uint16)(TEST_0_INTR))
N
N
N#endif /* End Pins TEST_ALIASES_H */
N
N
N/* [] END OF FILE */
L 21 "Generated_Source\PSoC4\TEST.h" 2
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/**
N* \addtogroup group_structures
N* @{
N*/
N    
N/* Structure for sleep mode support */
Ntypedef struct
N{
N    uint32 pcState; /**< State of the port control register */
N    uint32 sioState; /**< State of the SIO configuration */
N    uint32 usbState; /**< State of the USBIO regulator */
N} TEST_BACKUP_STRUCT;
N
N/** @} structures */
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/
N/**
N* \addtogroup group_general
N* @{
N*/
Nuint8   TEST_Read(void);
Nvoid    TEST_Write(uint8 value);
Nuint8   TEST_ReadDataReg(void);
N#if defined(TEST__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    void    TEST_SetDriveMode(uint8 mode);
N#endif
Nvoid    TEST_SetInterruptMode(uint16 position, uint16 mode);
Nuint8   TEST_ClearInterrupt(void);
N/** @} general */
N
N/**
N* \addtogroup group_power
N* @{
N*/
Nvoid TEST_Sleep(void); 
Nvoid TEST_Wakeup(void);
N/** @} power */
N
N
N/***************************************
N*           API Constants        
N***************************************/
N#if defined(TEST__PC) || (CY_PSOC4_4200L) 
X#if 1L || ((16u == 22u)) 
N    /* Drive Modes */
N    #define TEST_DRIVE_MODE_BITS        (3)
N    #define TEST_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - TEST_DRIVE_MODE_BITS))
N
N    /**
N    * \addtogroup group_constants
N    * @{
N    */
N        /** \addtogroup driveMode Drive mode constants
N         * \brief Constants to be passed as "mode" parameter in the TEST_SetDriveMode() function.
N         *  @{
N         */
N        #define TEST_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N        #define TEST_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N        #define TEST_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N        #define TEST_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
N        #define TEST_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N        #define TEST_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N        #define TEST_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N        #define TEST_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
N        /** @} driveMode */
N    /** @} group_constants */
N#endif
N
N/* Digital Port Constants */
N#define TEST_MASK               TEST__MASK
N#define TEST_SHIFT              TEST__SHIFT
N#define TEST_WIDTH              1u
N
N/**
N* \addtogroup group_constants
N* @{
N*/
N    /** \addtogroup intrMode Interrupt constants
N     * \brief Constants to be passed as "mode" parameter in TEST_SetInterruptMode() function.
N     *  @{
N     */
N        #define TEST_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
N        #define TEST_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
N        #define TEST_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
N        #define TEST_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
N    /** @} intrMode */
N/** @} group_constants */
N
N/* SIO LPM definition */
N#if defined(TEST__SIO)
X#if 0L
S    #define TEST_SIO_LPM_MASK       (0x03u)
N#endif
N
N/* USBIO definitions */
N#if !defined(TEST__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define TEST_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define TEST_USBIO_DISABLE              ((uint32)(~TEST_USBIO_ENABLE))
S    #define TEST_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define TEST_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define TEST_USBIO_ENTER_SLEEP          ((uint32)((1u << TEST_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << TEST_USBIO_SUSPEND_DEL_SHIFT)))
X    #define TEST_USBIO_ENTER_SLEEP          ((uint32)((1u << TEST_USBIO_SUSPEND_SHIFT)                                                         | (1u << TEST_USBIO_SUSPEND_DEL_SHIFT)))
S    #define TEST_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << TEST_USBIO_SUSPEND_SHIFT)))
S    #define TEST_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << TEST_USBIO_SUSPEND_DEL_SHIFT)))
S    #define TEST_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
N#endif
N
N
N/***************************************
N*             Registers        
N***************************************/
N/* Main Port Registers */
N#if defined(TEST__PC)
X#if 1L
N    /* Port Configuration */
N    #define TEST_PC                 (* (reg32 *) TEST__PC)
N#endif
N/* Pin State */
N#define TEST_PS                     (* (reg32 *) TEST__PS)
N/* Data Register */
N#define TEST_DR                     (* (reg32 *) TEST__DR)
N/* Input Buffer Disable Override */
N#define TEST_INP_DIS                (* (reg32 *) TEST__PC2)
N
N/* Interrupt configuration Registers */
N#define TEST_INTCFG                 (* (reg32 *) TEST__INTCFG)
N#define TEST_INTSTAT                (* (reg32 *) TEST__INTSTAT)
N
N/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
N#if defined (CYREG_GPIO_INTR_CAUSE)
X#if 1L
N    #define TEST_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
N#endif
N
N/* SIO register */
N#if defined(TEST__SIO)
X#if 0L
S    #define TEST_SIO_REG            (* (reg32 *) TEST__SIO)
N#endif /* (TEST__SIO_CFG) */
N
N/* USBIO registers */
N#if !defined(TEST__PC) && (CY_PSOC4_4200L)
X#if !1L && ((16u == 22u))
S    #define TEST_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define TEST_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define TEST_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
N#endif    
N    
N    
N/***************************************
N* The following code is DEPRECATED and 
N* must not be used in new designs.
N***************************************/
N/**
N* \addtogroup group_deprecated
N* @{
N*/
N#define TEST_DRIVE_MODE_SHIFT       (0x00u)
N#define TEST_DRIVE_MODE_MASK        (0x07u << TEST_DRIVE_MODE_SHIFT)
N/** @} deprecated */
N
N#endif /* End Pins TEST_H */
N
N
N/* [] END OF FILE */
L 100 "Generated_Source\PSoC4\project.h" 2
N#include "TEST_aliases.h"
L 1 "Generated_Source\PSoC4\TEST_aliases.h" 1
N/*******************************************************************************
N* File Name: TEST.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_TEST_ALIASES_H) /* Pins TEST_ALIASES_H */
X#if !1L  
S#define CY_PINS_TEST_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define TEST_0			(TEST__0__PC)
S#define TEST_0_PS		(TEST__0__PS)
S#define TEST_0_PC		(TEST__0__PC)
S#define TEST_0_DR		(TEST__0__DR)
S#define TEST_0_SHIFT	(TEST__0__SHIFT)
S#define TEST_0_INTR	((uint16)((uint16)0x0003u << (TEST__0__SHIFT*2u)))
S
S#define TEST_INTR_ALL	 ((uint16)(TEST_0_INTR))
S
S
N#endif /* End Pins TEST_ALIASES_H */
N
N
N/* [] END OF FILE */
L 101 "Generated_Source\PSoC4\project.h" 2
N#include "UART_1_BLE_SCBCLK.h"
N#include "UART_1_BLE_tx.h"
L 1 "Generated_Source\PSoC4\UART_1_BLE_tx.h" 1
N/*******************************************************************************
N* File Name: UART_1_BLE_tx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_1_BLE_tx_H) /* Pins UART_1_BLE_tx_H */
X#if !1L  
S#define CY_PINS_UART_1_BLE_tx_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "UART_1_BLE_tx_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} UART_1_BLE_tx_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   UART_1_BLE_tx_Read(void);
Svoid    UART_1_BLE_tx_Write(uint8 value);
Suint8   UART_1_BLE_tx_ReadDataReg(void);
S#if defined(UART_1_BLE_tx__PC) || (CY_PSOC4_4200L) 
S    void    UART_1_BLE_tx_SetDriveMode(uint8 mode);
S#endif
Svoid    UART_1_BLE_tx_SetInterruptMode(uint16 position, uint16 mode);
Suint8   UART_1_BLE_tx_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid UART_1_BLE_tx_Sleep(void); 
Svoid UART_1_BLE_tx_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(UART_1_BLE_tx__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define UART_1_BLE_tx_DRIVE_MODE_BITS        (3)
S    #define UART_1_BLE_tx_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - UART_1_BLE_tx_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the UART_1_BLE_tx_SetDriveMode() function.
S         *  @{
S         */
S        #define UART_1_BLE_tx_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define UART_1_BLE_tx_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define UART_1_BLE_tx_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define UART_1_BLE_tx_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define UART_1_BLE_tx_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define UART_1_BLE_tx_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define UART_1_BLE_tx_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define UART_1_BLE_tx_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define UART_1_BLE_tx_MASK               UART_1_BLE_tx__MASK
S#define UART_1_BLE_tx_SHIFT              UART_1_BLE_tx__SHIFT
S#define UART_1_BLE_tx_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in UART_1_BLE_tx_SetInterruptMode() function.
S     *  @{
S     */
S        #define UART_1_BLE_tx_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define UART_1_BLE_tx_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define UART_1_BLE_tx_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define UART_1_BLE_tx_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(UART_1_BLE_tx__SIO)
S    #define UART_1_BLE_tx_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(UART_1_BLE_tx__PC) && (CY_PSOC4_4200L)
S    #define UART_1_BLE_tx_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define UART_1_BLE_tx_USBIO_DISABLE              ((uint32)(~UART_1_BLE_tx_USBIO_ENABLE))
S    #define UART_1_BLE_tx_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define UART_1_BLE_tx_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define UART_1_BLE_tx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_1_BLE_tx_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << UART_1_BLE_tx_USBIO_SUSPEND_DEL_SHIFT)))
X    #define UART_1_BLE_tx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_1_BLE_tx_USBIO_SUSPEND_SHIFT)                                                         | (1u << UART_1_BLE_tx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_1_BLE_tx_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << UART_1_BLE_tx_USBIO_SUSPEND_SHIFT)))
S    #define UART_1_BLE_tx_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << UART_1_BLE_tx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_1_BLE_tx_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(UART_1_BLE_tx__PC)
S    /* Port Configuration */
S    #define UART_1_BLE_tx_PC                 (* (reg32 *) UART_1_BLE_tx__PC)
S#endif
S/* Pin State */
S#define UART_1_BLE_tx_PS                     (* (reg32 *) UART_1_BLE_tx__PS)
S/* Data Register */
S#define UART_1_BLE_tx_DR                     (* (reg32 *) UART_1_BLE_tx__DR)
S/* Input Buffer Disable Override */
S#define UART_1_BLE_tx_INP_DIS                (* (reg32 *) UART_1_BLE_tx__PC2)
S
S/* Interrupt configuration Registers */
S#define UART_1_BLE_tx_INTCFG                 (* (reg32 *) UART_1_BLE_tx__INTCFG)
S#define UART_1_BLE_tx_INTSTAT                (* (reg32 *) UART_1_BLE_tx__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define UART_1_BLE_tx_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(UART_1_BLE_tx__SIO)
S    #define UART_1_BLE_tx_SIO_REG            (* (reg32 *) UART_1_BLE_tx__SIO)
S#endif /* (UART_1_BLE_tx__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(UART_1_BLE_tx__PC) && (CY_PSOC4_4200L)
S    #define UART_1_BLE_tx_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define UART_1_BLE_tx_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define UART_1_BLE_tx_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define UART_1_BLE_tx_DRIVE_MODE_SHIFT       (0x00u)
S#define UART_1_BLE_tx_DRIVE_MODE_MASK        (0x07u << UART_1_BLE_tx_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins UART_1_BLE_tx_H */
N
N
N/* [] END OF FILE */
L 103 "Generated_Source\PSoC4\project.h" 2
N#include "UART_1_BLE_tx_aliases.h"
L 1 "Generated_Source\PSoC4\UART_1_BLE_tx_aliases.h" 1
N/*******************************************************************************
N* File Name: UART_1_BLE_tx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_1_BLE_tx_ALIASES_H) /* Pins UART_1_BLE_tx_ALIASES_H */
X#if !1L  
S#define CY_PINS_UART_1_BLE_tx_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define UART_1_BLE_tx_0			(UART_1_BLE_tx__0__PC)
S#define UART_1_BLE_tx_0_PS		(UART_1_BLE_tx__0__PS)
S#define UART_1_BLE_tx_0_PC		(UART_1_BLE_tx__0__PC)
S#define UART_1_BLE_tx_0_DR		(UART_1_BLE_tx__0__DR)
S#define UART_1_BLE_tx_0_SHIFT	(UART_1_BLE_tx__0__SHIFT)
S#define UART_1_BLE_tx_0_INTR	((uint16)((uint16)0x0003u << (UART_1_BLE_tx__0__SHIFT*2u)))
S
S#define UART_1_BLE_tx_INTR_ALL	 ((uint16)(UART_1_BLE_tx_0_INTR))
S
S
N#endif /* End Pins UART_1_BLE_tx_ALIASES_H */
N
N
N/* [] END OF FILE */
L 104 "Generated_Source\PSoC4\project.h" 2
N#include "UART_1_BLE_SCB_IRQ.h"
L 1 "Generated_Source\PSoC4\UART_1_BLE_SCB_IRQ.h" 1
N/*******************************************************************************
N* File Name: UART_1_BLE_SCB_IRQ.h
N* Version 1.70
N*
N*  Description:
N*   Provides the function definitions for the Interrupt Controller.
N*
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N#if !defined(CY_ISR_UART_1_BLE_SCB_IRQ_H)
X#if !0L
N#define CY_ISR_UART_1_BLE_SCB_IRQ_H
N
N
N#include <cytypes.h>
N#include <cyfitter.h>
N
N/* Interrupt Controller API. */
Nvoid UART_1_BLE_SCB_IRQ_Start(void);
Nvoid UART_1_BLE_SCB_IRQ_StartEx(cyisraddress address);
Nvoid UART_1_BLE_SCB_IRQ_Stop(void);
N
NCY_ISR_PROTO(UART_1_BLE_SCB_IRQ_Interrupt);
Xvoid UART_1_BLE_SCB_IRQ_Interrupt (void);
N
Nvoid UART_1_BLE_SCB_IRQ_SetVector(cyisraddress address);
Ncyisraddress UART_1_BLE_SCB_IRQ_GetVector(void);
N
Nvoid UART_1_BLE_SCB_IRQ_SetPriority(uint8 priority);
Nuint8 UART_1_BLE_SCB_IRQ_GetPriority(void);
N
Nvoid UART_1_BLE_SCB_IRQ_Enable(void);
Nuint8 UART_1_BLE_SCB_IRQ_GetState(void);
Nvoid UART_1_BLE_SCB_IRQ_Disable(void);
N
Nvoid UART_1_BLE_SCB_IRQ_SetPending(void);
Nvoid UART_1_BLE_SCB_IRQ_ClearPending(void);
N
N
N/* Interrupt Controller Constants */
N
N/* Address of the INTC.VECT[x] register that contains the Address of the UART_1_BLE_SCB_IRQ ISR. */
N#define UART_1_BLE_SCB_IRQ_INTC_VECTOR            ((reg32 *) UART_1_BLE_SCB_IRQ__INTC_VECT)
N
N/* Address of the UART_1_BLE_SCB_IRQ ISR priority. */
N#define UART_1_BLE_SCB_IRQ_INTC_PRIOR             ((reg32 *) UART_1_BLE_SCB_IRQ__INTC_PRIOR_REG)
N
N/* Priority of the UART_1_BLE_SCB_IRQ interrupt. */
N#define UART_1_BLE_SCB_IRQ_INTC_PRIOR_NUMBER      UART_1_BLE_SCB_IRQ__INTC_PRIOR_NUM
N
N/* Address of the INTC.SET_EN[x] byte to bit enable UART_1_BLE_SCB_IRQ interrupt. */
N#define UART_1_BLE_SCB_IRQ_INTC_SET_EN            ((reg32 *) UART_1_BLE_SCB_IRQ__INTC_SET_EN_REG)
N
N/* Address of the INTC.CLR_EN[x] register to bit clear the UART_1_BLE_SCB_IRQ interrupt. */
N#define UART_1_BLE_SCB_IRQ_INTC_CLR_EN            ((reg32 *) UART_1_BLE_SCB_IRQ__INTC_CLR_EN_REG)
N
N/* Address of the INTC.SET_PD[x] register to set the UART_1_BLE_SCB_IRQ interrupt state to pending. */
N#define UART_1_BLE_SCB_IRQ_INTC_SET_PD            ((reg32 *) UART_1_BLE_SCB_IRQ__INTC_SET_PD_REG)
N
N/* Address of the INTC.CLR_PD[x] register to clear the UART_1_BLE_SCB_IRQ interrupt. */
N#define UART_1_BLE_SCB_IRQ_INTC_CLR_PD            ((reg32 *) UART_1_BLE_SCB_IRQ__INTC_CLR_PD_REG)
N
N
N
N#endif /* CY_ISR_UART_1_BLE_SCB_IRQ_H */
N
N
N/* [] END OF FILE */
L 105 "Generated_Source\PSoC4\project.h" 2
N#include "UART_1_BLE_rx.h"
L 1 "Generated_Source\PSoC4\UART_1_BLE_rx.h" 1
N/*******************************************************************************
N* File Name: UART_1_BLE_rx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_1_BLE_rx_H) /* Pins UART_1_BLE_rx_H */
X#if !1L  
S#define CY_PINS_UART_1_BLE_rx_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "UART_1_BLE_rx_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} UART_1_BLE_rx_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   UART_1_BLE_rx_Read(void);
Svoid    UART_1_BLE_rx_Write(uint8 value);
Suint8   UART_1_BLE_rx_ReadDataReg(void);
S#if defined(UART_1_BLE_rx__PC) || (CY_PSOC4_4200L) 
S    void    UART_1_BLE_rx_SetDriveMode(uint8 mode);
S#endif
Svoid    UART_1_BLE_rx_SetInterruptMode(uint16 position, uint16 mode);
Suint8   UART_1_BLE_rx_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid UART_1_BLE_rx_Sleep(void); 
Svoid UART_1_BLE_rx_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(UART_1_BLE_rx__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define UART_1_BLE_rx_DRIVE_MODE_BITS        (3)
S    #define UART_1_BLE_rx_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - UART_1_BLE_rx_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the UART_1_BLE_rx_SetDriveMode() function.
S         *  @{
S         */
S        #define UART_1_BLE_rx_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define UART_1_BLE_rx_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define UART_1_BLE_rx_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define UART_1_BLE_rx_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define UART_1_BLE_rx_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define UART_1_BLE_rx_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define UART_1_BLE_rx_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define UART_1_BLE_rx_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define UART_1_BLE_rx_MASK               UART_1_BLE_rx__MASK
S#define UART_1_BLE_rx_SHIFT              UART_1_BLE_rx__SHIFT
S#define UART_1_BLE_rx_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in UART_1_BLE_rx_SetInterruptMode() function.
S     *  @{
S     */
S        #define UART_1_BLE_rx_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define UART_1_BLE_rx_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define UART_1_BLE_rx_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define UART_1_BLE_rx_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(UART_1_BLE_rx__SIO)
S    #define UART_1_BLE_rx_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(UART_1_BLE_rx__PC) && (CY_PSOC4_4200L)
S    #define UART_1_BLE_rx_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define UART_1_BLE_rx_USBIO_DISABLE              ((uint32)(~UART_1_BLE_rx_USBIO_ENABLE))
S    #define UART_1_BLE_rx_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define UART_1_BLE_rx_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define UART_1_BLE_rx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_1_BLE_rx_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << UART_1_BLE_rx_USBIO_SUSPEND_DEL_SHIFT)))
X    #define UART_1_BLE_rx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_1_BLE_rx_USBIO_SUSPEND_SHIFT)                                                         | (1u << UART_1_BLE_rx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_1_BLE_rx_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << UART_1_BLE_rx_USBIO_SUSPEND_SHIFT)))
S    #define UART_1_BLE_rx_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << UART_1_BLE_rx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_1_BLE_rx_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(UART_1_BLE_rx__PC)
S    /* Port Configuration */
S    #define UART_1_BLE_rx_PC                 (* (reg32 *) UART_1_BLE_rx__PC)
S#endif
S/* Pin State */
S#define UART_1_BLE_rx_PS                     (* (reg32 *) UART_1_BLE_rx__PS)
S/* Data Register */
S#define UART_1_BLE_rx_DR                     (* (reg32 *) UART_1_BLE_rx__DR)
S/* Input Buffer Disable Override */
S#define UART_1_BLE_rx_INP_DIS                (* (reg32 *) UART_1_BLE_rx__PC2)
S
S/* Interrupt configuration Registers */
S#define UART_1_BLE_rx_INTCFG                 (* (reg32 *) UART_1_BLE_rx__INTCFG)
S#define UART_1_BLE_rx_INTSTAT                (* (reg32 *) UART_1_BLE_rx__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define UART_1_BLE_rx_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(UART_1_BLE_rx__SIO)
S    #define UART_1_BLE_rx_SIO_REG            (* (reg32 *) UART_1_BLE_rx__SIO)
S#endif /* (UART_1_BLE_rx__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(UART_1_BLE_rx__PC) && (CY_PSOC4_4200L)
S    #define UART_1_BLE_rx_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define UART_1_BLE_rx_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define UART_1_BLE_rx_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define UART_1_BLE_rx_DRIVE_MODE_SHIFT       (0x00u)
S#define UART_1_BLE_rx_DRIVE_MODE_MASK        (0x07u << UART_1_BLE_rx_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins UART_1_BLE_rx_H */
N
N
N/* [] END OF FILE */
L 106 "Generated_Source\PSoC4\project.h" 2
N#include "UART_1_BLE_rx_aliases.h"
L 1 "Generated_Source\PSoC4\UART_1_BLE_rx_aliases.h" 1
N/*******************************************************************************
N* File Name: UART_1_BLE_rx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_1_BLE_rx_ALIASES_H) /* Pins UART_1_BLE_rx_ALIASES_H */
X#if !1L  
S#define CY_PINS_UART_1_BLE_rx_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define UART_1_BLE_rx_0			(UART_1_BLE_rx__0__PC)
S#define UART_1_BLE_rx_0_PS		(UART_1_BLE_rx__0__PS)
S#define UART_1_BLE_rx_0_PC		(UART_1_BLE_rx__0__PC)
S#define UART_1_BLE_rx_0_DR		(UART_1_BLE_rx__0__DR)
S#define UART_1_BLE_rx_0_SHIFT	(UART_1_BLE_rx__0__SHIFT)
S#define UART_1_BLE_rx_0_INTR	((uint16)((uint16)0x0003u << (UART_1_BLE_rx__0__SHIFT*2u)))
S
S#define UART_1_BLE_rx_INTR_ALL	 ((uint16)(UART_1_BLE_rx_0_INTR))
S
S
N#endif /* End Pins UART_1_BLE_rx_ALIASES_H */
N
N
N/* [] END OF FILE */
L 107 "Generated_Source\PSoC4\project.h" 2
N#include "UART_0_FPC_SCBCLK.h"
N#include "UART_0_FPC_tx.h"
L 1 "Generated_Source\PSoC4\UART_0_FPC_tx.h" 1
N/*******************************************************************************
N* File Name: UART_0_FPC_tx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_0_FPC_tx_H) /* Pins UART_0_FPC_tx_H */
X#if !1L  
S#define CY_PINS_UART_0_FPC_tx_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "UART_0_FPC_tx_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} UART_0_FPC_tx_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   UART_0_FPC_tx_Read(void);
Svoid    UART_0_FPC_tx_Write(uint8 value);
Suint8   UART_0_FPC_tx_ReadDataReg(void);
S#if defined(UART_0_FPC_tx__PC) || (CY_PSOC4_4200L) 
S    void    UART_0_FPC_tx_SetDriveMode(uint8 mode);
S#endif
Svoid    UART_0_FPC_tx_SetInterruptMode(uint16 position, uint16 mode);
Suint8   UART_0_FPC_tx_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid UART_0_FPC_tx_Sleep(void); 
Svoid UART_0_FPC_tx_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(UART_0_FPC_tx__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define UART_0_FPC_tx_DRIVE_MODE_BITS        (3)
S    #define UART_0_FPC_tx_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - UART_0_FPC_tx_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the UART_0_FPC_tx_SetDriveMode() function.
S         *  @{
S         */
S        #define UART_0_FPC_tx_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define UART_0_FPC_tx_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define UART_0_FPC_tx_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define UART_0_FPC_tx_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define UART_0_FPC_tx_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define UART_0_FPC_tx_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define UART_0_FPC_tx_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define UART_0_FPC_tx_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define UART_0_FPC_tx_MASK               UART_0_FPC_tx__MASK
S#define UART_0_FPC_tx_SHIFT              UART_0_FPC_tx__SHIFT
S#define UART_0_FPC_tx_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in UART_0_FPC_tx_SetInterruptMode() function.
S     *  @{
S     */
S        #define UART_0_FPC_tx_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define UART_0_FPC_tx_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define UART_0_FPC_tx_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define UART_0_FPC_tx_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(UART_0_FPC_tx__SIO)
S    #define UART_0_FPC_tx_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(UART_0_FPC_tx__PC) && (CY_PSOC4_4200L)
S    #define UART_0_FPC_tx_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define UART_0_FPC_tx_USBIO_DISABLE              ((uint32)(~UART_0_FPC_tx_USBIO_ENABLE))
S    #define UART_0_FPC_tx_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define UART_0_FPC_tx_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define UART_0_FPC_tx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_0_FPC_tx_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << UART_0_FPC_tx_USBIO_SUSPEND_DEL_SHIFT)))
X    #define UART_0_FPC_tx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_0_FPC_tx_USBIO_SUSPEND_SHIFT)                                                         | (1u << UART_0_FPC_tx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_0_FPC_tx_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << UART_0_FPC_tx_USBIO_SUSPEND_SHIFT)))
S    #define UART_0_FPC_tx_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << UART_0_FPC_tx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_0_FPC_tx_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(UART_0_FPC_tx__PC)
S    /* Port Configuration */
S    #define UART_0_FPC_tx_PC                 (* (reg32 *) UART_0_FPC_tx__PC)
S#endif
S/* Pin State */
S#define UART_0_FPC_tx_PS                     (* (reg32 *) UART_0_FPC_tx__PS)
S/* Data Register */
S#define UART_0_FPC_tx_DR                     (* (reg32 *) UART_0_FPC_tx__DR)
S/* Input Buffer Disable Override */
S#define UART_0_FPC_tx_INP_DIS                (* (reg32 *) UART_0_FPC_tx__PC2)
S
S/* Interrupt configuration Registers */
S#define UART_0_FPC_tx_INTCFG                 (* (reg32 *) UART_0_FPC_tx__INTCFG)
S#define UART_0_FPC_tx_INTSTAT                (* (reg32 *) UART_0_FPC_tx__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define UART_0_FPC_tx_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(UART_0_FPC_tx__SIO)
S    #define UART_0_FPC_tx_SIO_REG            (* (reg32 *) UART_0_FPC_tx__SIO)
S#endif /* (UART_0_FPC_tx__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(UART_0_FPC_tx__PC) && (CY_PSOC4_4200L)
S    #define UART_0_FPC_tx_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define UART_0_FPC_tx_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define UART_0_FPC_tx_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define UART_0_FPC_tx_DRIVE_MODE_SHIFT       (0x00u)
S#define UART_0_FPC_tx_DRIVE_MODE_MASK        (0x07u << UART_0_FPC_tx_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins UART_0_FPC_tx_H */
N
N
N/* [] END OF FILE */
L 109 "Generated_Source\PSoC4\project.h" 2
N#include "UART_0_FPC_tx_aliases.h"
L 1 "Generated_Source\PSoC4\UART_0_FPC_tx_aliases.h" 1
N/*******************************************************************************
N* File Name: UART_0_FPC_tx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_0_FPC_tx_ALIASES_H) /* Pins UART_0_FPC_tx_ALIASES_H */
X#if !1L  
S#define CY_PINS_UART_0_FPC_tx_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define UART_0_FPC_tx_0			(UART_0_FPC_tx__0__PC)
S#define UART_0_FPC_tx_0_PS		(UART_0_FPC_tx__0__PS)
S#define UART_0_FPC_tx_0_PC		(UART_0_FPC_tx__0__PC)
S#define UART_0_FPC_tx_0_DR		(UART_0_FPC_tx__0__DR)
S#define UART_0_FPC_tx_0_SHIFT	(UART_0_FPC_tx__0__SHIFT)
S#define UART_0_FPC_tx_0_INTR	((uint16)((uint16)0x0003u << (UART_0_FPC_tx__0__SHIFT*2u)))
S
S#define UART_0_FPC_tx_INTR_ALL	 ((uint16)(UART_0_FPC_tx_0_INTR))
S
S
N#endif /* End Pins UART_0_FPC_tx_ALIASES_H */
N
N
N/* [] END OF FILE */
L 110 "Generated_Source\PSoC4\project.h" 2
N#include "UART_0_FPC_SCB_IRQ.h"
L 1 "Generated_Source\PSoC4\UART_0_FPC_SCB_IRQ.h" 1
N/*******************************************************************************
N* File Name: UART_0_FPC_SCB_IRQ.h
N* Version 1.70
N*
N*  Description:
N*   Provides the function definitions for the Interrupt Controller.
N*
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N#if !defined(CY_ISR_UART_0_FPC_SCB_IRQ_H)
X#if !0L
N#define CY_ISR_UART_0_FPC_SCB_IRQ_H
N
N
N#include <cytypes.h>
N#include <cyfitter.h>
N
N/* Interrupt Controller API. */
Nvoid UART_0_FPC_SCB_IRQ_Start(void);
Nvoid UART_0_FPC_SCB_IRQ_StartEx(cyisraddress address);
Nvoid UART_0_FPC_SCB_IRQ_Stop(void);
N
NCY_ISR_PROTO(UART_0_FPC_SCB_IRQ_Interrupt);
Xvoid UART_0_FPC_SCB_IRQ_Interrupt (void);
N
Nvoid UART_0_FPC_SCB_IRQ_SetVector(cyisraddress address);
Ncyisraddress UART_0_FPC_SCB_IRQ_GetVector(void);
N
Nvoid UART_0_FPC_SCB_IRQ_SetPriority(uint8 priority);
Nuint8 UART_0_FPC_SCB_IRQ_GetPriority(void);
N
Nvoid UART_0_FPC_SCB_IRQ_Enable(void);
Nuint8 UART_0_FPC_SCB_IRQ_GetState(void);
Nvoid UART_0_FPC_SCB_IRQ_Disable(void);
N
Nvoid UART_0_FPC_SCB_IRQ_SetPending(void);
Nvoid UART_0_FPC_SCB_IRQ_ClearPending(void);
N
N
N/* Interrupt Controller Constants */
N
N/* Address of the INTC.VECT[x] register that contains the Address of the UART_0_FPC_SCB_IRQ ISR. */
N#define UART_0_FPC_SCB_IRQ_INTC_VECTOR            ((reg32 *) UART_0_FPC_SCB_IRQ__INTC_VECT)
N
N/* Address of the UART_0_FPC_SCB_IRQ ISR priority. */
N#define UART_0_FPC_SCB_IRQ_INTC_PRIOR             ((reg32 *) UART_0_FPC_SCB_IRQ__INTC_PRIOR_REG)
N
N/* Priority of the UART_0_FPC_SCB_IRQ interrupt. */
N#define UART_0_FPC_SCB_IRQ_INTC_PRIOR_NUMBER      UART_0_FPC_SCB_IRQ__INTC_PRIOR_NUM
N
N/* Address of the INTC.SET_EN[x] byte to bit enable UART_0_FPC_SCB_IRQ interrupt. */
N#define UART_0_FPC_SCB_IRQ_INTC_SET_EN            ((reg32 *) UART_0_FPC_SCB_IRQ__INTC_SET_EN_REG)
N
N/* Address of the INTC.CLR_EN[x] register to bit clear the UART_0_FPC_SCB_IRQ interrupt. */
N#define UART_0_FPC_SCB_IRQ_INTC_CLR_EN            ((reg32 *) UART_0_FPC_SCB_IRQ__INTC_CLR_EN_REG)
N
N/* Address of the INTC.SET_PD[x] register to set the UART_0_FPC_SCB_IRQ interrupt state to pending. */
N#define UART_0_FPC_SCB_IRQ_INTC_SET_PD            ((reg32 *) UART_0_FPC_SCB_IRQ__INTC_SET_PD_REG)
N
N/* Address of the INTC.CLR_PD[x] register to clear the UART_0_FPC_SCB_IRQ interrupt. */
N#define UART_0_FPC_SCB_IRQ_INTC_CLR_PD            ((reg32 *) UART_0_FPC_SCB_IRQ__INTC_CLR_PD_REG)
N
N
N
N#endif /* CY_ISR_UART_0_FPC_SCB_IRQ_H */
N
N
N/* [] END OF FILE */
L 111 "Generated_Source\PSoC4\project.h" 2
N#include "UART_0_FPC_rx.h"
L 1 "Generated_Source\PSoC4\UART_0_FPC_rx.h" 1
N/*******************************************************************************
N* File Name: UART_0_FPC_rx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_0_FPC_rx_H) /* Pins UART_0_FPC_rx_H */
X#if !1L  
S#define CY_PINS_UART_0_FPC_rx_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "UART_0_FPC_rx_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} UART_0_FPC_rx_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   UART_0_FPC_rx_Read(void);
Svoid    UART_0_FPC_rx_Write(uint8 value);
Suint8   UART_0_FPC_rx_ReadDataReg(void);
S#if defined(UART_0_FPC_rx__PC) || (CY_PSOC4_4200L) 
S    void    UART_0_FPC_rx_SetDriveMode(uint8 mode);
S#endif
Svoid    UART_0_FPC_rx_SetInterruptMode(uint16 position, uint16 mode);
Suint8   UART_0_FPC_rx_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid UART_0_FPC_rx_Sleep(void); 
Svoid UART_0_FPC_rx_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(UART_0_FPC_rx__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define UART_0_FPC_rx_DRIVE_MODE_BITS        (3)
S    #define UART_0_FPC_rx_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - UART_0_FPC_rx_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the UART_0_FPC_rx_SetDriveMode() function.
S         *  @{
S         */
S        #define UART_0_FPC_rx_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define UART_0_FPC_rx_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define UART_0_FPC_rx_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define UART_0_FPC_rx_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define UART_0_FPC_rx_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define UART_0_FPC_rx_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define UART_0_FPC_rx_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define UART_0_FPC_rx_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define UART_0_FPC_rx_MASK               UART_0_FPC_rx__MASK
S#define UART_0_FPC_rx_SHIFT              UART_0_FPC_rx__SHIFT
S#define UART_0_FPC_rx_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in UART_0_FPC_rx_SetInterruptMode() function.
S     *  @{
S     */
S        #define UART_0_FPC_rx_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define UART_0_FPC_rx_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define UART_0_FPC_rx_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define UART_0_FPC_rx_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(UART_0_FPC_rx__SIO)
S    #define UART_0_FPC_rx_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(UART_0_FPC_rx__PC) && (CY_PSOC4_4200L)
S    #define UART_0_FPC_rx_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define UART_0_FPC_rx_USBIO_DISABLE              ((uint32)(~UART_0_FPC_rx_USBIO_ENABLE))
S    #define UART_0_FPC_rx_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define UART_0_FPC_rx_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define UART_0_FPC_rx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_0_FPC_rx_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << UART_0_FPC_rx_USBIO_SUSPEND_DEL_SHIFT)))
X    #define UART_0_FPC_rx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_0_FPC_rx_USBIO_SUSPEND_SHIFT)                                                         | (1u << UART_0_FPC_rx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_0_FPC_rx_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << UART_0_FPC_rx_USBIO_SUSPEND_SHIFT)))
S    #define UART_0_FPC_rx_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << UART_0_FPC_rx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_0_FPC_rx_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(UART_0_FPC_rx__PC)
S    /* Port Configuration */
S    #define UART_0_FPC_rx_PC                 (* (reg32 *) UART_0_FPC_rx__PC)
S#endif
S/* Pin State */
S#define UART_0_FPC_rx_PS                     (* (reg32 *) UART_0_FPC_rx__PS)
S/* Data Register */
S#define UART_0_FPC_rx_DR                     (* (reg32 *) UART_0_FPC_rx__DR)
S/* Input Buffer Disable Override */
S#define UART_0_FPC_rx_INP_DIS                (* (reg32 *) UART_0_FPC_rx__PC2)
S
S/* Interrupt configuration Registers */
S#define UART_0_FPC_rx_INTCFG                 (* (reg32 *) UART_0_FPC_rx__INTCFG)
S#define UART_0_FPC_rx_INTSTAT                (* (reg32 *) UART_0_FPC_rx__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define UART_0_FPC_rx_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(UART_0_FPC_rx__SIO)
S    #define UART_0_FPC_rx_SIO_REG            (* (reg32 *) UART_0_FPC_rx__SIO)
S#endif /* (UART_0_FPC_rx__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(UART_0_FPC_rx__PC) && (CY_PSOC4_4200L)
S    #define UART_0_FPC_rx_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define UART_0_FPC_rx_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define UART_0_FPC_rx_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define UART_0_FPC_rx_DRIVE_MODE_SHIFT       (0x00u)
S#define UART_0_FPC_rx_DRIVE_MODE_MASK        (0x07u << UART_0_FPC_rx_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins UART_0_FPC_rx_H */
N
N
N/* [] END OF FILE */
L 112 "Generated_Source\PSoC4\project.h" 2
N#include "UART_0_FPC_rx_aliases.h"
L 1 "Generated_Source\PSoC4\UART_0_FPC_rx_aliases.h" 1
N/*******************************************************************************
N* File Name: UART_0_FPC_rx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_0_FPC_rx_ALIASES_H) /* Pins UART_0_FPC_rx_ALIASES_H */
X#if !1L  
S#define CY_PINS_UART_0_FPC_rx_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define UART_0_FPC_rx_0			(UART_0_FPC_rx__0__PC)
S#define UART_0_FPC_rx_0_PS		(UART_0_FPC_rx__0__PS)
S#define UART_0_FPC_rx_0_PC		(UART_0_FPC_rx__0__PC)
S#define UART_0_FPC_rx_0_DR		(UART_0_FPC_rx__0__DR)
S#define UART_0_FPC_rx_0_SHIFT	(UART_0_FPC_rx__0__SHIFT)
S#define UART_0_FPC_rx_0_INTR	((uint16)((uint16)0x0003u << (UART_0_FPC_rx__0__SHIFT*2u)))
S
S#define UART_0_FPC_rx_INTR_ALL	 ((uint16)(UART_0_FPC_rx_0_INTR))
S
S
N#endif /* End Pins UART_0_FPC_rx_ALIASES_H */
N
N
N/* [] END OF FILE */
L 113 "Generated_Source\PSoC4\project.h" 2
N#include "UART_2_EXT_SCBCLK.h"
N#include "UART_2_EXT_tx.h"
L 1 "Generated_Source\PSoC4\UART_2_EXT_tx.h" 1
N/*******************************************************************************
N* File Name: UART_2_EXT_tx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_2_EXT_tx_H) /* Pins UART_2_EXT_tx_H */
X#if !1L  
S#define CY_PINS_UART_2_EXT_tx_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "UART_2_EXT_tx_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} UART_2_EXT_tx_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   UART_2_EXT_tx_Read(void);
Svoid    UART_2_EXT_tx_Write(uint8 value);
Suint8   UART_2_EXT_tx_ReadDataReg(void);
S#if defined(UART_2_EXT_tx__PC) || (CY_PSOC4_4200L) 
S    void    UART_2_EXT_tx_SetDriveMode(uint8 mode);
S#endif
Svoid    UART_2_EXT_tx_SetInterruptMode(uint16 position, uint16 mode);
Suint8   UART_2_EXT_tx_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid UART_2_EXT_tx_Sleep(void); 
Svoid UART_2_EXT_tx_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(UART_2_EXT_tx__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define UART_2_EXT_tx_DRIVE_MODE_BITS        (3)
S    #define UART_2_EXT_tx_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - UART_2_EXT_tx_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the UART_2_EXT_tx_SetDriveMode() function.
S         *  @{
S         */
S        #define UART_2_EXT_tx_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define UART_2_EXT_tx_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define UART_2_EXT_tx_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define UART_2_EXT_tx_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define UART_2_EXT_tx_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define UART_2_EXT_tx_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define UART_2_EXT_tx_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define UART_2_EXT_tx_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define UART_2_EXT_tx_MASK               UART_2_EXT_tx__MASK
S#define UART_2_EXT_tx_SHIFT              UART_2_EXT_tx__SHIFT
S#define UART_2_EXT_tx_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in UART_2_EXT_tx_SetInterruptMode() function.
S     *  @{
S     */
S        #define UART_2_EXT_tx_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define UART_2_EXT_tx_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define UART_2_EXT_tx_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define UART_2_EXT_tx_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(UART_2_EXT_tx__SIO)
S    #define UART_2_EXT_tx_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(UART_2_EXT_tx__PC) && (CY_PSOC4_4200L)
S    #define UART_2_EXT_tx_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define UART_2_EXT_tx_USBIO_DISABLE              ((uint32)(~UART_2_EXT_tx_USBIO_ENABLE))
S    #define UART_2_EXT_tx_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define UART_2_EXT_tx_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define UART_2_EXT_tx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_2_EXT_tx_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << UART_2_EXT_tx_USBIO_SUSPEND_DEL_SHIFT)))
X    #define UART_2_EXT_tx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_2_EXT_tx_USBIO_SUSPEND_SHIFT)                                                         | (1u << UART_2_EXT_tx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_2_EXT_tx_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << UART_2_EXT_tx_USBIO_SUSPEND_SHIFT)))
S    #define UART_2_EXT_tx_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << UART_2_EXT_tx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_2_EXT_tx_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(UART_2_EXT_tx__PC)
S    /* Port Configuration */
S    #define UART_2_EXT_tx_PC                 (* (reg32 *) UART_2_EXT_tx__PC)
S#endif
S/* Pin State */
S#define UART_2_EXT_tx_PS                     (* (reg32 *) UART_2_EXT_tx__PS)
S/* Data Register */
S#define UART_2_EXT_tx_DR                     (* (reg32 *) UART_2_EXT_tx__DR)
S/* Input Buffer Disable Override */
S#define UART_2_EXT_tx_INP_DIS                (* (reg32 *) UART_2_EXT_tx__PC2)
S
S/* Interrupt configuration Registers */
S#define UART_2_EXT_tx_INTCFG                 (* (reg32 *) UART_2_EXT_tx__INTCFG)
S#define UART_2_EXT_tx_INTSTAT                (* (reg32 *) UART_2_EXT_tx__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define UART_2_EXT_tx_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(UART_2_EXT_tx__SIO)
S    #define UART_2_EXT_tx_SIO_REG            (* (reg32 *) UART_2_EXT_tx__SIO)
S#endif /* (UART_2_EXT_tx__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(UART_2_EXT_tx__PC) && (CY_PSOC4_4200L)
S    #define UART_2_EXT_tx_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define UART_2_EXT_tx_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define UART_2_EXT_tx_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define UART_2_EXT_tx_DRIVE_MODE_SHIFT       (0x00u)
S#define UART_2_EXT_tx_DRIVE_MODE_MASK        (0x07u << UART_2_EXT_tx_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins UART_2_EXT_tx_H */
N
N
N/* [] END OF FILE */
L 115 "Generated_Source\PSoC4\project.h" 2
N#include "UART_2_EXT_tx_aliases.h"
L 1 "Generated_Source\PSoC4\UART_2_EXT_tx_aliases.h" 1
N/*******************************************************************************
N* File Name: UART_2_EXT_tx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_2_EXT_tx_ALIASES_H) /* Pins UART_2_EXT_tx_ALIASES_H */
X#if !1L  
S#define CY_PINS_UART_2_EXT_tx_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define UART_2_EXT_tx_0			(UART_2_EXT_tx__0__PC)
S#define UART_2_EXT_tx_0_PS		(UART_2_EXT_tx__0__PS)
S#define UART_2_EXT_tx_0_PC		(UART_2_EXT_tx__0__PC)
S#define UART_2_EXT_tx_0_DR		(UART_2_EXT_tx__0__DR)
S#define UART_2_EXT_tx_0_SHIFT	(UART_2_EXT_tx__0__SHIFT)
S#define UART_2_EXT_tx_0_INTR	((uint16)((uint16)0x0003u << (UART_2_EXT_tx__0__SHIFT*2u)))
S
S#define UART_2_EXT_tx_INTR_ALL	 ((uint16)(UART_2_EXT_tx_0_INTR))
S
S
N#endif /* End Pins UART_2_EXT_tx_ALIASES_H */
N
N
N/* [] END OF FILE */
L 116 "Generated_Source\PSoC4\project.h" 2
N#include "UART_2_EXT_SCB_IRQ.h"
L 1 "Generated_Source\PSoC4\UART_2_EXT_SCB_IRQ.h" 1
N/*******************************************************************************
N* File Name: UART_2_EXT_SCB_IRQ.h
N* Version 1.70
N*
N*  Description:
N*   Provides the function definitions for the Interrupt Controller.
N*
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N#if !defined(CY_ISR_UART_2_EXT_SCB_IRQ_H)
X#if !0L
N#define CY_ISR_UART_2_EXT_SCB_IRQ_H
N
N
N#include <cytypes.h>
N#include <cyfitter.h>
N
N/* Interrupt Controller API. */
Nvoid UART_2_EXT_SCB_IRQ_Start(void);
Nvoid UART_2_EXT_SCB_IRQ_StartEx(cyisraddress address);
Nvoid UART_2_EXT_SCB_IRQ_Stop(void);
N
NCY_ISR_PROTO(UART_2_EXT_SCB_IRQ_Interrupt);
Xvoid UART_2_EXT_SCB_IRQ_Interrupt (void);
N
Nvoid UART_2_EXT_SCB_IRQ_SetVector(cyisraddress address);
Ncyisraddress UART_2_EXT_SCB_IRQ_GetVector(void);
N
Nvoid UART_2_EXT_SCB_IRQ_SetPriority(uint8 priority);
Nuint8 UART_2_EXT_SCB_IRQ_GetPriority(void);
N
Nvoid UART_2_EXT_SCB_IRQ_Enable(void);
Nuint8 UART_2_EXT_SCB_IRQ_GetState(void);
Nvoid UART_2_EXT_SCB_IRQ_Disable(void);
N
Nvoid UART_2_EXT_SCB_IRQ_SetPending(void);
Nvoid UART_2_EXT_SCB_IRQ_ClearPending(void);
N
N
N/* Interrupt Controller Constants */
N
N/* Address of the INTC.VECT[x] register that contains the Address of the UART_2_EXT_SCB_IRQ ISR. */
N#define UART_2_EXT_SCB_IRQ_INTC_VECTOR            ((reg32 *) UART_2_EXT_SCB_IRQ__INTC_VECT)
N
N/* Address of the UART_2_EXT_SCB_IRQ ISR priority. */
N#define UART_2_EXT_SCB_IRQ_INTC_PRIOR             ((reg32 *) UART_2_EXT_SCB_IRQ__INTC_PRIOR_REG)
N
N/* Priority of the UART_2_EXT_SCB_IRQ interrupt. */
N#define UART_2_EXT_SCB_IRQ_INTC_PRIOR_NUMBER      UART_2_EXT_SCB_IRQ__INTC_PRIOR_NUM
N
N/* Address of the INTC.SET_EN[x] byte to bit enable UART_2_EXT_SCB_IRQ interrupt. */
N#define UART_2_EXT_SCB_IRQ_INTC_SET_EN            ((reg32 *) UART_2_EXT_SCB_IRQ__INTC_SET_EN_REG)
N
N/* Address of the INTC.CLR_EN[x] register to bit clear the UART_2_EXT_SCB_IRQ interrupt. */
N#define UART_2_EXT_SCB_IRQ_INTC_CLR_EN            ((reg32 *) UART_2_EXT_SCB_IRQ__INTC_CLR_EN_REG)
N
N/* Address of the INTC.SET_PD[x] register to set the UART_2_EXT_SCB_IRQ interrupt state to pending. */
N#define UART_2_EXT_SCB_IRQ_INTC_SET_PD            ((reg32 *) UART_2_EXT_SCB_IRQ__INTC_SET_PD_REG)
N
N/* Address of the INTC.CLR_PD[x] register to clear the UART_2_EXT_SCB_IRQ interrupt. */
N#define UART_2_EXT_SCB_IRQ_INTC_CLR_PD            ((reg32 *) UART_2_EXT_SCB_IRQ__INTC_CLR_PD_REG)
N
N
N
N#endif /* CY_ISR_UART_2_EXT_SCB_IRQ_H */
N
N
N/* [] END OF FILE */
L 117 "Generated_Source\PSoC4\project.h" 2
N#include "UART_2_EXT_rx.h"
L 1 "Generated_Source\PSoC4\UART_2_EXT_rx.h" 1
N/*******************************************************************************
N* File Name: UART_2_EXT_rx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_2_EXT_rx_H) /* Pins UART_2_EXT_rx_H */
X#if !1L  
S#define CY_PINS_UART_2_EXT_rx_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "UART_2_EXT_rx_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} UART_2_EXT_rx_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   UART_2_EXT_rx_Read(void);
Svoid    UART_2_EXT_rx_Write(uint8 value);
Suint8   UART_2_EXT_rx_ReadDataReg(void);
S#if defined(UART_2_EXT_rx__PC) || (CY_PSOC4_4200L) 
S    void    UART_2_EXT_rx_SetDriveMode(uint8 mode);
S#endif
Svoid    UART_2_EXT_rx_SetInterruptMode(uint16 position, uint16 mode);
Suint8   UART_2_EXT_rx_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid UART_2_EXT_rx_Sleep(void); 
Svoid UART_2_EXT_rx_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(UART_2_EXT_rx__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define UART_2_EXT_rx_DRIVE_MODE_BITS        (3)
S    #define UART_2_EXT_rx_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - UART_2_EXT_rx_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the UART_2_EXT_rx_SetDriveMode() function.
S         *  @{
S         */
S        #define UART_2_EXT_rx_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define UART_2_EXT_rx_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define UART_2_EXT_rx_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define UART_2_EXT_rx_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define UART_2_EXT_rx_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define UART_2_EXT_rx_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define UART_2_EXT_rx_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define UART_2_EXT_rx_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define UART_2_EXT_rx_MASK               UART_2_EXT_rx__MASK
S#define UART_2_EXT_rx_SHIFT              UART_2_EXT_rx__SHIFT
S#define UART_2_EXT_rx_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in UART_2_EXT_rx_SetInterruptMode() function.
S     *  @{
S     */
S        #define UART_2_EXT_rx_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define UART_2_EXT_rx_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define UART_2_EXT_rx_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define UART_2_EXT_rx_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(UART_2_EXT_rx__SIO)
S    #define UART_2_EXT_rx_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(UART_2_EXT_rx__PC) && (CY_PSOC4_4200L)
S    #define UART_2_EXT_rx_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define UART_2_EXT_rx_USBIO_DISABLE              ((uint32)(~UART_2_EXT_rx_USBIO_ENABLE))
S    #define UART_2_EXT_rx_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define UART_2_EXT_rx_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define UART_2_EXT_rx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_2_EXT_rx_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << UART_2_EXT_rx_USBIO_SUSPEND_DEL_SHIFT)))
X    #define UART_2_EXT_rx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_2_EXT_rx_USBIO_SUSPEND_SHIFT)                                                         | (1u << UART_2_EXT_rx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_2_EXT_rx_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << UART_2_EXT_rx_USBIO_SUSPEND_SHIFT)))
S    #define UART_2_EXT_rx_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << UART_2_EXT_rx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_2_EXT_rx_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(UART_2_EXT_rx__PC)
S    /* Port Configuration */
S    #define UART_2_EXT_rx_PC                 (* (reg32 *) UART_2_EXT_rx__PC)
S#endif
S/* Pin State */
S#define UART_2_EXT_rx_PS                     (* (reg32 *) UART_2_EXT_rx__PS)
S/* Data Register */
S#define UART_2_EXT_rx_DR                     (* (reg32 *) UART_2_EXT_rx__DR)
S/* Input Buffer Disable Override */
S#define UART_2_EXT_rx_INP_DIS                (* (reg32 *) UART_2_EXT_rx__PC2)
S
S/* Interrupt configuration Registers */
S#define UART_2_EXT_rx_INTCFG                 (* (reg32 *) UART_2_EXT_rx__INTCFG)
S#define UART_2_EXT_rx_INTSTAT                (* (reg32 *) UART_2_EXT_rx__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define UART_2_EXT_rx_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(UART_2_EXT_rx__SIO)
S    #define UART_2_EXT_rx_SIO_REG            (* (reg32 *) UART_2_EXT_rx__SIO)
S#endif /* (UART_2_EXT_rx__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(UART_2_EXT_rx__PC) && (CY_PSOC4_4200L)
S    #define UART_2_EXT_rx_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define UART_2_EXT_rx_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define UART_2_EXT_rx_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define UART_2_EXT_rx_DRIVE_MODE_SHIFT       (0x00u)
S#define UART_2_EXT_rx_DRIVE_MODE_MASK        (0x07u << UART_2_EXT_rx_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins UART_2_EXT_rx_H */
N
N
N/* [] END OF FILE */
L 118 "Generated_Source\PSoC4\project.h" 2
N#include "UART_2_EXT_rx_aliases.h"
L 1 "Generated_Source\PSoC4\UART_2_EXT_rx_aliases.h" 1
N/*******************************************************************************
N* File Name: UART_2_EXT_rx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_2_EXT_rx_ALIASES_H) /* Pins UART_2_EXT_rx_ALIASES_H */
X#if !1L  
S#define CY_PINS_UART_2_EXT_rx_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define UART_2_EXT_rx_0			(UART_2_EXT_rx__0__PC)
S#define UART_2_EXT_rx_0_PS		(UART_2_EXT_rx__0__PS)
S#define UART_2_EXT_rx_0_PC		(UART_2_EXT_rx__0__PC)
S#define UART_2_EXT_rx_0_DR		(UART_2_EXT_rx__0__DR)
S#define UART_2_EXT_rx_0_SHIFT	(UART_2_EXT_rx__0__SHIFT)
S#define UART_2_EXT_rx_0_INTR	((uint16)((uint16)0x0003u << (UART_2_EXT_rx__0__SHIFT*2u)))
S
S#define UART_2_EXT_rx_INTR_ALL	 ((uint16)(UART_2_EXT_rx_0_INTR))
S
S
N#endif /* End Pins UART_2_EXT_rx_ALIASES_H */
N
N
N/* [] END OF FILE */
L 119 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_SCBCLK.h"
N#include "SPI_0_OLED_FLASH_ss1_m.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_ss1_m.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_ss1_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_ss1_m_H) /* Pins SPI_0_OLED_FLASH_ss1_m_H */
X#if !1L  
S#define CY_PINS_SPI_0_OLED_FLASH_ss1_m_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "SPI_0_OLED_FLASH_ss1_m_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} SPI_0_OLED_FLASH_ss1_m_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   SPI_0_OLED_FLASH_ss1_m_Read(void);
Svoid    SPI_0_OLED_FLASH_ss1_m_Write(uint8 value);
Suint8   SPI_0_OLED_FLASH_ss1_m_ReadDataReg(void);
S#if defined(SPI_0_OLED_FLASH_ss1_m__PC) || (CY_PSOC4_4200L) 
S    void    SPI_0_OLED_FLASH_ss1_m_SetDriveMode(uint8 mode);
S#endif
Svoid    SPI_0_OLED_FLASH_ss1_m_SetInterruptMode(uint16 position, uint16 mode);
Suint8   SPI_0_OLED_FLASH_ss1_m_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid SPI_0_OLED_FLASH_ss1_m_Sleep(void); 
Svoid SPI_0_OLED_FLASH_ss1_m_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(SPI_0_OLED_FLASH_ss1_m__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define SPI_0_OLED_FLASH_ss1_m_DRIVE_MODE_BITS        (3)
S    #define SPI_0_OLED_FLASH_ss1_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_0_OLED_FLASH_ss1_m_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the SPI_0_OLED_FLASH_ss1_m_SetDriveMode() function.
S         *  @{
S         */
S        #define SPI_0_OLED_FLASH_ss1_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define SPI_0_OLED_FLASH_ss1_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define SPI_0_OLED_FLASH_ss1_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define SPI_0_OLED_FLASH_ss1_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define SPI_0_OLED_FLASH_ss1_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define SPI_0_OLED_FLASH_ss1_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define SPI_0_OLED_FLASH_ss1_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define SPI_0_OLED_FLASH_ss1_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define SPI_0_OLED_FLASH_ss1_m_MASK               SPI_0_OLED_FLASH_ss1_m__MASK
S#define SPI_0_OLED_FLASH_ss1_m_SHIFT              SPI_0_OLED_FLASH_ss1_m__SHIFT
S#define SPI_0_OLED_FLASH_ss1_m_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in SPI_0_OLED_FLASH_ss1_m_SetInterruptMode() function.
S     *  @{
S     */
S        #define SPI_0_OLED_FLASH_ss1_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define SPI_0_OLED_FLASH_ss1_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define SPI_0_OLED_FLASH_ss1_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define SPI_0_OLED_FLASH_ss1_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(SPI_0_OLED_FLASH_ss1_m__SIO)
S    #define SPI_0_OLED_FLASH_ss1_m_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(SPI_0_OLED_FLASH_ss1_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_DISABLE              ((uint32)(~SPI_0_OLED_FLASH_ss1_m_USBIO_ENABLE))
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_0_OLED_FLASH_ss1_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(SPI_0_OLED_FLASH_ss1_m__PC)
S    /* Port Configuration */
S    #define SPI_0_OLED_FLASH_ss1_m_PC                 (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__PC)
S#endif
S/* Pin State */
S#define SPI_0_OLED_FLASH_ss1_m_PS                     (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__PS)
S/* Data Register */
S#define SPI_0_OLED_FLASH_ss1_m_DR                     (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__DR)
S/* Input Buffer Disable Override */
S#define SPI_0_OLED_FLASH_ss1_m_INP_DIS                (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__PC2)
S
S/* Interrupt configuration Registers */
S#define SPI_0_OLED_FLASH_ss1_m_INTCFG                 (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__INTCFG)
S#define SPI_0_OLED_FLASH_ss1_m_INTSTAT                (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define SPI_0_OLED_FLASH_ss1_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(SPI_0_OLED_FLASH_ss1_m__SIO)
S    #define SPI_0_OLED_FLASH_ss1_m_SIO_REG            (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__SIO)
S#endif /* (SPI_0_OLED_FLASH_ss1_m__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(SPI_0_OLED_FLASH_ss1_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_0_OLED_FLASH_ss1_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_0_OLED_FLASH_ss1_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define SPI_0_OLED_FLASH_ss1_m_DRIVE_MODE_SHIFT       (0x00u)
S#define SPI_0_OLED_FLASH_ss1_m_DRIVE_MODE_MASK        (0x07u << SPI_0_OLED_FLASH_ss1_m_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins SPI_0_OLED_FLASH_ss1_m_H */
N
N
N/* [] END OF FILE */
L 121 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_ss1_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_ss1_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_ss1_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_ss1_m_ALIASES_H) /* Pins SPI_0_OLED_FLASH_ss1_m_ALIASES_H */
X#if !1L  
S#define CY_PINS_SPI_0_OLED_FLASH_ss1_m_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define SPI_0_OLED_FLASH_ss1_m_0			(SPI_0_OLED_FLASH_ss1_m__0__PC)
S#define SPI_0_OLED_FLASH_ss1_m_0_PS		(SPI_0_OLED_FLASH_ss1_m__0__PS)
S#define SPI_0_OLED_FLASH_ss1_m_0_PC		(SPI_0_OLED_FLASH_ss1_m__0__PC)
S#define SPI_0_OLED_FLASH_ss1_m_0_DR		(SPI_0_OLED_FLASH_ss1_m__0__DR)
S#define SPI_0_OLED_FLASH_ss1_m_0_SHIFT	(SPI_0_OLED_FLASH_ss1_m__0__SHIFT)
S#define SPI_0_OLED_FLASH_ss1_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_0_OLED_FLASH_ss1_m__0__SHIFT*2u)))
S
S#define SPI_0_OLED_FLASH_ss1_m_INTR_ALL	 ((uint16)(SPI_0_OLED_FLASH_ss1_m_0_INTR))
S
S
N#endif /* End Pins SPI_0_OLED_FLASH_ss1_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 122 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_sclk_m.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_sclk_m.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_sclk_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_sclk_m_H) /* Pins SPI_0_OLED_FLASH_sclk_m_H */
X#if !1L  
S#define CY_PINS_SPI_0_OLED_FLASH_sclk_m_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "SPI_0_OLED_FLASH_sclk_m_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} SPI_0_OLED_FLASH_sclk_m_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   SPI_0_OLED_FLASH_sclk_m_Read(void);
Svoid    SPI_0_OLED_FLASH_sclk_m_Write(uint8 value);
Suint8   SPI_0_OLED_FLASH_sclk_m_ReadDataReg(void);
S#if defined(SPI_0_OLED_FLASH_sclk_m__PC) || (CY_PSOC4_4200L) 
S    void    SPI_0_OLED_FLASH_sclk_m_SetDriveMode(uint8 mode);
S#endif
Svoid    SPI_0_OLED_FLASH_sclk_m_SetInterruptMode(uint16 position, uint16 mode);
Suint8   SPI_0_OLED_FLASH_sclk_m_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid SPI_0_OLED_FLASH_sclk_m_Sleep(void); 
Svoid SPI_0_OLED_FLASH_sclk_m_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(SPI_0_OLED_FLASH_sclk_m__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define SPI_0_OLED_FLASH_sclk_m_DRIVE_MODE_BITS        (3)
S    #define SPI_0_OLED_FLASH_sclk_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_0_OLED_FLASH_sclk_m_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the SPI_0_OLED_FLASH_sclk_m_SetDriveMode() function.
S         *  @{
S         */
S        #define SPI_0_OLED_FLASH_sclk_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define SPI_0_OLED_FLASH_sclk_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define SPI_0_OLED_FLASH_sclk_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define SPI_0_OLED_FLASH_sclk_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define SPI_0_OLED_FLASH_sclk_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define SPI_0_OLED_FLASH_sclk_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define SPI_0_OLED_FLASH_sclk_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define SPI_0_OLED_FLASH_sclk_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define SPI_0_OLED_FLASH_sclk_m_MASK               SPI_0_OLED_FLASH_sclk_m__MASK
S#define SPI_0_OLED_FLASH_sclk_m_SHIFT              SPI_0_OLED_FLASH_sclk_m__SHIFT
S#define SPI_0_OLED_FLASH_sclk_m_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in SPI_0_OLED_FLASH_sclk_m_SetInterruptMode() function.
S     *  @{
S     */
S        #define SPI_0_OLED_FLASH_sclk_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define SPI_0_OLED_FLASH_sclk_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define SPI_0_OLED_FLASH_sclk_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define SPI_0_OLED_FLASH_sclk_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(SPI_0_OLED_FLASH_sclk_m__SIO)
S    #define SPI_0_OLED_FLASH_sclk_m_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(SPI_0_OLED_FLASH_sclk_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_DISABLE              ((uint32)(~SPI_0_OLED_FLASH_sclk_m_USBIO_ENABLE))
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_0_OLED_FLASH_sclk_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(SPI_0_OLED_FLASH_sclk_m__PC)
S    /* Port Configuration */
S    #define SPI_0_OLED_FLASH_sclk_m_PC                 (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__PC)
S#endif
S/* Pin State */
S#define SPI_0_OLED_FLASH_sclk_m_PS                     (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__PS)
S/* Data Register */
S#define SPI_0_OLED_FLASH_sclk_m_DR                     (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__DR)
S/* Input Buffer Disable Override */
S#define SPI_0_OLED_FLASH_sclk_m_INP_DIS                (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__PC2)
S
S/* Interrupt configuration Registers */
S#define SPI_0_OLED_FLASH_sclk_m_INTCFG                 (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__INTCFG)
S#define SPI_0_OLED_FLASH_sclk_m_INTSTAT                (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define SPI_0_OLED_FLASH_sclk_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(SPI_0_OLED_FLASH_sclk_m__SIO)
S    #define SPI_0_OLED_FLASH_sclk_m_SIO_REG            (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__SIO)
S#endif /* (SPI_0_OLED_FLASH_sclk_m__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(SPI_0_OLED_FLASH_sclk_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_0_OLED_FLASH_sclk_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_0_OLED_FLASH_sclk_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define SPI_0_OLED_FLASH_sclk_m_DRIVE_MODE_SHIFT       (0x00u)
S#define SPI_0_OLED_FLASH_sclk_m_DRIVE_MODE_MASK        (0x07u << SPI_0_OLED_FLASH_sclk_m_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins SPI_0_OLED_FLASH_sclk_m_H */
N
N
N/* [] END OF FILE */
L 123 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_sclk_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_sclk_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_sclk_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_sclk_m_ALIASES_H) /* Pins SPI_0_OLED_FLASH_sclk_m_ALIASES_H */
X#if !1L  
S#define CY_PINS_SPI_0_OLED_FLASH_sclk_m_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define SPI_0_OLED_FLASH_sclk_m_0			(SPI_0_OLED_FLASH_sclk_m__0__PC)
S#define SPI_0_OLED_FLASH_sclk_m_0_PS		(SPI_0_OLED_FLASH_sclk_m__0__PS)
S#define SPI_0_OLED_FLASH_sclk_m_0_PC		(SPI_0_OLED_FLASH_sclk_m__0__PC)
S#define SPI_0_OLED_FLASH_sclk_m_0_DR		(SPI_0_OLED_FLASH_sclk_m__0__DR)
S#define SPI_0_OLED_FLASH_sclk_m_0_SHIFT	(SPI_0_OLED_FLASH_sclk_m__0__SHIFT)
S#define SPI_0_OLED_FLASH_sclk_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_0_OLED_FLASH_sclk_m__0__SHIFT*2u)))
S
S#define SPI_0_OLED_FLASH_sclk_m_INTR_ALL	 ((uint16)(SPI_0_OLED_FLASH_sclk_m_0_INTR))
S
S
N#endif /* End Pins SPI_0_OLED_FLASH_sclk_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 124 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_miso_m.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_miso_m.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_miso_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_miso_m_H) /* Pins SPI_0_OLED_FLASH_miso_m_H */
X#if !1L  
S#define CY_PINS_SPI_0_OLED_FLASH_miso_m_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "SPI_0_OLED_FLASH_miso_m_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} SPI_0_OLED_FLASH_miso_m_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   SPI_0_OLED_FLASH_miso_m_Read(void);
Svoid    SPI_0_OLED_FLASH_miso_m_Write(uint8 value);
Suint8   SPI_0_OLED_FLASH_miso_m_ReadDataReg(void);
S#if defined(SPI_0_OLED_FLASH_miso_m__PC) || (CY_PSOC4_4200L) 
S    void    SPI_0_OLED_FLASH_miso_m_SetDriveMode(uint8 mode);
S#endif
Svoid    SPI_0_OLED_FLASH_miso_m_SetInterruptMode(uint16 position, uint16 mode);
Suint8   SPI_0_OLED_FLASH_miso_m_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid SPI_0_OLED_FLASH_miso_m_Sleep(void); 
Svoid SPI_0_OLED_FLASH_miso_m_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(SPI_0_OLED_FLASH_miso_m__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define SPI_0_OLED_FLASH_miso_m_DRIVE_MODE_BITS        (3)
S    #define SPI_0_OLED_FLASH_miso_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_0_OLED_FLASH_miso_m_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the SPI_0_OLED_FLASH_miso_m_SetDriveMode() function.
S         *  @{
S         */
S        #define SPI_0_OLED_FLASH_miso_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define SPI_0_OLED_FLASH_miso_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define SPI_0_OLED_FLASH_miso_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define SPI_0_OLED_FLASH_miso_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define SPI_0_OLED_FLASH_miso_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define SPI_0_OLED_FLASH_miso_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define SPI_0_OLED_FLASH_miso_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define SPI_0_OLED_FLASH_miso_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define SPI_0_OLED_FLASH_miso_m_MASK               SPI_0_OLED_FLASH_miso_m__MASK
S#define SPI_0_OLED_FLASH_miso_m_SHIFT              SPI_0_OLED_FLASH_miso_m__SHIFT
S#define SPI_0_OLED_FLASH_miso_m_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in SPI_0_OLED_FLASH_miso_m_SetInterruptMode() function.
S     *  @{
S     */
S        #define SPI_0_OLED_FLASH_miso_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define SPI_0_OLED_FLASH_miso_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define SPI_0_OLED_FLASH_miso_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define SPI_0_OLED_FLASH_miso_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(SPI_0_OLED_FLASH_miso_m__SIO)
S    #define SPI_0_OLED_FLASH_miso_m_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(SPI_0_OLED_FLASH_miso_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_DISABLE              ((uint32)(~SPI_0_OLED_FLASH_miso_m_USBIO_ENABLE))
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_0_OLED_FLASH_miso_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(SPI_0_OLED_FLASH_miso_m__PC)
S    /* Port Configuration */
S    #define SPI_0_OLED_FLASH_miso_m_PC                 (* (reg32 *) SPI_0_OLED_FLASH_miso_m__PC)
S#endif
S/* Pin State */
S#define SPI_0_OLED_FLASH_miso_m_PS                     (* (reg32 *) SPI_0_OLED_FLASH_miso_m__PS)
S/* Data Register */
S#define SPI_0_OLED_FLASH_miso_m_DR                     (* (reg32 *) SPI_0_OLED_FLASH_miso_m__DR)
S/* Input Buffer Disable Override */
S#define SPI_0_OLED_FLASH_miso_m_INP_DIS                (* (reg32 *) SPI_0_OLED_FLASH_miso_m__PC2)
S
S/* Interrupt configuration Registers */
S#define SPI_0_OLED_FLASH_miso_m_INTCFG                 (* (reg32 *) SPI_0_OLED_FLASH_miso_m__INTCFG)
S#define SPI_0_OLED_FLASH_miso_m_INTSTAT                (* (reg32 *) SPI_0_OLED_FLASH_miso_m__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define SPI_0_OLED_FLASH_miso_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(SPI_0_OLED_FLASH_miso_m__SIO)
S    #define SPI_0_OLED_FLASH_miso_m_SIO_REG            (* (reg32 *) SPI_0_OLED_FLASH_miso_m__SIO)
S#endif /* (SPI_0_OLED_FLASH_miso_m__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(SPI_0_OLED_FLASH_miso_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_0_OLED_FLASH_miso_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_0_OLED_FLASH_miso_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define SPI_0_OLED_FLASH_miso_m_DRIVE_MODE_SHIFT       (0x00u)
S#define SPI_0_OLED_FLASH_miso_m_DRIVE_MODE_MASK        (0x07u << SPI_0_OLED_FLASH_miso_m_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins SPI_0_OLED_FLASH_miso_m_H */
N
N
N/* [] END OF FILE */
L 125 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_miso_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_miso_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_miso_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_miso_m_ALIASES_H) /* Pins SPI_0_OLED_FLASH_miso_m_ALIASES_H */
X#if !1L  
S#define CY_PINS_SPI_0_OLED_FLASH_miso_m_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define SPI_0_OLED_FLASH_miso_m_0			(SPI_0_OLED_FLASH_miso_m__0__PC)
S#define SPI_0_OLED_FLASH_miso_m_0_PS		(SPI_0_OLED_FLASH_miso_m__0__PS)
S#define SPI_0_OLED_FLASH_miso_m_0_PC		(SPI_0_OLED_FLASH_miso_m__0__PC)
S#define SPI_0_OLED_FLASH_miso_m_0_DR		(SPI_0_OLED_FLASH_miso_m__0__DR)
S#define SPI_0_OLED_FLASH_miso_m_0_SHIFT	(SPI_0_OLED_FLASH_miso_m__0__SHIFT)
S#define SPI_0_OLED_FLASH_miso_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_0_OLED_FLASH_miso_m__0__SHIFT*2u)))
S
S#define SPI_0_OLED_FLASH_miso_m_INTR_ALL	 ((uint16)(SPI_0_OLED_FLASH_miso_m_0_INTR))
S
S
N#endif /* End Pins SPI_0_OLED_FLASH_miso_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 126 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_mosi_m.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_mosi_m.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_mosi_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_mosi_m_H) /* Pins SPI_0_OLED_FLASH_mosi_m_H */
X#if !1L  
S#define CY_PINS_SPI_0_OLED_FLASH_mosi_m_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "SPI_0_OLED_FLASH_mosi_m_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} SPI_0_OLED_FLASH_mosi_m_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   SPI_0_OLED_FLASH_mosi_m_Read(void);
Svoid    SPI_0_OLED_FLASH_mosi_m_Write(uint8 value);
Suint8   SPI_0_OLED_FLASH_mosi_m_ReadDataReg(void);
S#if defined(SPI_0_OLED_FLASH_mosi_m__PC) || (CY_PSOC4_4200L) 
S    void    SPI_0_OLED_FLASH_mosi_m_SetDriveMode(uint8 mode);
S#endif
Svoid    SPI_0_OLED_FLASH_mosi_m_SetInterruptMode(uint16 position, uint16 mode);
Suint8   SPI_0_OLED_FLASH_mosi_m_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid SPI_0_OLED_FLASH_mosi_m_Sleep(void); 
Svoid SPI_0_OLED_FLASH_mosi_m_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(SPI_0_OLED_FLASH_mosi_m__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define SPI_0_OLED_FLASH_mosi_m_DRIVE_MODE_BITS        (3)
S    #define SPI_0_OLED_FLASH_mosi_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_0_OLED_FLASH_mosi_m_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the SPI_0_OLED_FLASH_mosi_m_SetDriveMode() function.
S         *  @{
S         */
S        #define SPI_0_OLED_FLASH_mosi_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define SPI_0_OLED_FLASH_mosi_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define SPI_0_OLED_FLASH_mosi_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define SPI_0_OLED_FLASH_mosi_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define SPI_0_OLED_FLASH_mosi_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define SPI_0_OLED_FLASH_mosi_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define SPI_0_OLED_FLASH_mosi_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define SPI_0_OLED_FLASH_mosi_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define SPI_0_OLED_FLASH_mosi_m_MASK               SPI_0_OLED_FLASH_mosi_m__MASK
S#define SPI_0_OLED_FLASH_mosi_m_SHIFT              SPI_0_OLED_FLASH_mosi_m__SHIFT
S#define SPI_0_OLED_FLASH_mosi_m_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in SPI_0_OLED_FLASH_mosi_m_SetInterruptMode() function.
S     *  @{
S     */
S        #define SPI_0_OLED_FLASH_mosi_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define SPI_0_OLED_FLASH_mosi_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define SPI_0_OLED_FLASH_mosi_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define SPI_0_OLED_FLASH_mosi_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(SPI_0_OLED_FLASH_mosi_m__SIO)
S    #define SPI_0_OLED_FLASH_mosi_m_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(SPI_0_OLED_FLASH_mosi_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_DISABLE              ((uint32)(~SPI_0_OLED_FLASH_mosi_m_USBIO_ENABLE))
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_0_OLED_FLASH_mosi_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(SPI_0_OLED_FLASH_mosi_m__PC)
S    /* Port Configuration */
S    #define SPI_0_OLED_FLASH_mosi_m_PC                 (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__PC)
S#endif
S/* Pin State */
S#define SPI_0_OLED_FLASH_mosi_m_PS                     (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__PS)
S/* Data Register */
S#define SPI_0_OLED_FLASH_mosi_m_DR                     (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__DR)
S/* Input Buffer Disable Override */
S#define SPI_0_OLED_FLASH_mosi_m_INP_DIS                (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__PC2)
S
S/* Interrupt configuration Registers */
S#define SPI_0_OLED_FLASH_mosi_m_INTCFG                 (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__INTCFG)
S#define SPI_0_OLED_FLASH_mosi_m_INTSTAT                (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define SPI_0_OLED_FLASH_mosi_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(SPI_0_OLED_FLASH_mosi_m__SIO)
S    #define SPI_0_OLED_FLASH_mosi_m_SIO_REG            (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__SIO)
S#endif /* (SPI_0_OLED_FLASH_mosi_m__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(SPI_0_OLED_FLASH_mosi_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_0_OLED_FLASH_mosi_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_0_OLED_FLASH_mosi_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define SPI_0_OLED_FLASH_mosi_m_DRIVE_MODE_SHIFT       (0x00u)
S#define SPI_0_OLED_FLASH_mosi_m_DRIVE_MODE_MASK        (0x07u << SPI_0_OLED_FLASH_mosi_m_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins SPI_0_OLED_FLASH_mosi_m_H */
N
N
N/* [] END OF FILE */
L 127 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_mosi_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_mosi_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_mosi_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_mosi_m_ALIASES_H) /* Pins SPI_0_OLED_FLASH_mosi_m_ALIASES_H */
X#if !1L  
S#define CY_PINS_SPI_0_OLED_FLASH_mosi_m_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define SPI_0_OLED_FLASH_mosi_m_0			(SPI_0_OLED_FLASH_mosi_m__0__PC)
S#define SPI_0_OLED_FLASH_mosi_m_0_PS		(SPI_0_OLED_FLASH_mosi_m__0__PS)
S#define SPI_0_OLED_FLASH_mosi_m_0_PC		(SPI_0_OLED_FLASH_mosi_m__0__PC)
S#define SPI_0_OLED_FLASH_mosi_m_0_DR		(SPI_0_OLED_FLASH_mosi_m__0__DR)
S#define SPI_0_OLED_FLASH_mosi_m_0_SHIFT	(SPI_0_OLED_FLASH_mosi_m__0__SHIFT)
S#define SPI_0_OLED_FLASH_mosi_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_0_OLED_FLASH_mosi_m__0__SHIFT*2u)))
S
S#define SPI_0_OLED_FLASH_mosi_m_INTR_ALL	 ((uint16)(SPI_0_OLED_FLASH_mosi_m_0_INTR))
S
S
N#endif /* End Pins SPI_0_OLED_FLASH_mosi_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 128 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_ss0_m.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_ss0_m.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_ss0_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_ss0_m_H) /* Pins SPI_0_OLED_FLASH_ss0_m_H */
X#if !1L  
S#define CY_PINS_SPI_0_OLED_FLASH_ss0_m_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "SPI_0_OLED_FLASH_ss0_m_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} SPI_0_OLED_FLASH_ss0_m_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   SPI_0_OLED_FLASH_ss0_m_Read(void);
Svoid    SPI_0_OLED_FLASH_ss0_m_Write(uint8 value);
Suint8   SPI_0_OLED_FLASH_ss0_m_ReadDataReg(void);
S#if defined(SPI_0_OLED_FLASH_ss0_m__PC) || (CY_PSOC4_4200L) 
S    void    SPI_0_OLED_FLASH_ss0_m_SetDriveMode(uint8 mode);
S#endif
Svoid    SPI_0_OLED_FLASH_ss0_m_SetInterruptMode(uint16 position, uint16 mode);
Suint8   SPI_0_OLED_FLASH_ss0_m_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid SPI_0_OLED_FLASH_ss0_m_Sleep(void); 
Svoid SPI_0_OLED_FLASH_ss0_m_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(SPI_0_OLED_FLASH_ss0_m__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define SPI_0_OLED_FLASH_ss0_m_DRIVE_MODE_BITS        (3)
S    #define SPI_0_OLED_FLASH_ss0_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_0_OLED_FLASH_ss0_m_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the SPI_0_OLED_FLASH_ss0_m_SetDriveMode() function.
S         *  @{
S         */
S        #define SPI_0_OLED_FLASH_ss0_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define SPI_0_OLED_FLASH_ss0_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define SPI_0_OLED_FLASH_ss0_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define SPI_0_OLED_FLASH_ss0_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define SPI_0_OLED_FLASH_ss0_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define SPI_0_OLED_FLASH_ss0_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define SPI_0_OLED_FLASH_ss0_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define SPI_0_OLED_FLASH_ss0_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define SPI_0_OLED_FLASH_ss0_m_MASK               SPI_0_OLED_FLASH_ss0_m__MASK
S#define SPI_0_OLED_FLASH_ss0_m_SHIFT              SPI_0_OLED_FLASH_ss0_m__SHIFT
S#define SPI_0_OLED_FLASH_ss0_m_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in SPI_0_OLED_FLASH_ss0_m_SetInterruptMode() function.
S     *  @{
S     */
S        #define SPI_0_OLED_FLASH_ss0_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define SPI_0_OLED_FLASH_ss0_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define SPI_0_OLED_FLASH_ss0_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define SPI_0_OLED_FLASH_ss0_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(SPI_0_OLED_FLASH_ss0_m__SIO)
S    #define SPI_0_OLED_FLASH_ss0_m_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(SPI_0_OLED_FLASH_ss0_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_DISABLE              ((uint32)(~SPI_0_OLED_FLASH_ss0_m_USBIO_ENABLE))
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_0_OLED_FLASH_ss0_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(SPI_0_OLED_FLASH_ss0_m__PC)
S    /* Port Configuration */
S    #define SPI_0_OLED_FLASH_ss0_m_PC                 (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__PC)
S#endif
S/* Pin State */
S#define SPI_0_OLED_FLASH_ss0_m_PS                     (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__PS)
S/* Data Register */
S#define SPI_0_OLED_FLASH_ss0_m_DR                     (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__DR)
S/* Input Buffer Disable Override */
S#define SPI_0_OLED_FLASH_ss0_m_INP_DIS                (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__PC2)
S
S/* Interrupt configuration Registers */
S#define SPI_0_OLED_FLASH_ss0_m_INTCFG                 (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__INTCFG)
S#define SPI_0_OLED_FLASH_ss0_m_INTSTAT                (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define SPI_0_OLED_FLASH_ss0_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(SPI_0_OLED_FLASH_ss0_m__SIO)
S    #define SPI_0_OLED_FLASH_ss0_m_SIO_REG            (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__SIO)
S#endif /* (SPI_0_OLED_FLASH_ss0_m__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(SPI_0_OLED_FLASH_ss0_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_0_OLED_FLASH_ss0_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_0_OLED_FLASH_ss0_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define SPI_0_OLED_FLASH_ss0_m_DRIVE_MODE_SHIFT       (0x00u)
S#define SPI_0_OLED_FLASH_ss0_m_DRIVE_MODE_MASK        (0x07u << SPI_0_OLED_FLASH_ss0_m_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins SPI_0_OLED_FLASH_ss0_m_H */
N
N
N/* [] END OF FILE */
L 129 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_ss0_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_ss0_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_ss0_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_ss0_m_ALIASES_H) /* Pins SPI_0_OLED_FLASH_ss0_m_ALIASES_H */
X#if !1L  
S#define CY_PINS_SPI_0_OLED_FLASH_ss0_m_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define SPI_0_OLED_FLASH_ss0_m_0			(SPI_0_OLED_FLASH_ss0_m__0__PC)
S#define SPI_0_OLED_FLASH_ss0_m_0_PS		(SPI_0_OLED_FLASH_ss0_m__0__PS)
S#define SPI_0_OLED_FLASH_ss0_m_0_PC		(SPI_0_OLED_FLASH_ss0_m__0__PC)
S#define SPI_0_OLED_FLASH_ss0_m_0_DR		(SPI_0_OLED_FLASH_ss0_m__0__DR)
S#define SPI_0_OLED_FLASH_ss0_m_0_SHIFT	(SPI_0_OLED_FLASH_ss0_m__0__SHIFT)
S#define SPI_0_OLED_FLASH_ss0_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_0_OLED_FLASH_ss0_m__0__SHIFT*2u)))
S
S#define SPI_0_OLED_FLASH_ss0_m_INTR_ALL	 ((uint16)(SPI_0_OLED_FLASH_ss0_m_0_INTR))
S
S
N#endif /* End Pins SPI_0_OLED_FLASH_ss0_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 130 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD_SCBCLK.h"
N#include "SPI_1_CARD_sclk_m.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_sclk_m.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_sclk_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_sclk_m_H) /* Pins SPI_1_CARD_sclk_m_H */
X#if !1L  
S#define CY_PINS_SPI_1_CARD_sclk_m_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "SPI_1_CARD_sclk_m_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} SPI_1_CARD_sclk_m_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   SPI_1_CARD_sclk_m_Read(void);
Svoid    SPI_1_CARD_sclk_m_Write(uint8 value);
Suint8   SPI_1_CARD_sclk_m_ReadDataReg(void);
S#if defined(SPI_1_CARD_sclk_m__PC) || (CY_PSOC4_4200L) 
S    void    SPI_1_CARD_sclk_m_SetDriveMode(uint8 mode);
S#endif
Svoid    SPI_1_CARD_sclk_m_SetInterruptMode(uint16 position, uint16 mode);
Suint8   SPI_1_CARD_sclk_m_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid SPI_1_CARD_sclk_m_Sleep(void); 
Svoid SPI_1_CARD_sclk_m_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(SPI_1_CARD_sclk_m__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define SPI_1_CARD_sclk_m_DRIVE_MODE_BITS        (3)
S    #define SPI_1_CARD_sclk_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_1_CARD_sclk_m_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the SPI_1_CARD_sclk_m_SetDriveMode() function.
S         *  @{
S         */
S        #define SPI_1_CARD_sclk_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define SPI_1_CARD_sclk_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define SPI_1_CARD_sclk_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define SPI_1_CARD_sclk_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define SPI_1_CARD_sclk_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define SPI_1_CARD_sclk_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define SPI_1_CARD_sclk_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define SPI_1_CARD_sclk_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define SPI_1_CARD_sclk_m_MASK               SPI_1_CARD_sclk_m__MASK
S#define SPI_1_CARD_sclk_m_SHIFT              SPI_1_CARD_sclk_m__SHIFT
S#define SPI_1_CARD_sclk_m_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in SPI_1_CARD_sclk_m_SetInterruptMode() function.
S     *  @{
S     */
S        #define SPI_1_CARD_sclk_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define SPI_1_CARD_sclk_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define SPI_1_CARD_sclk_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define SPI_1_CARD_sclk_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(SPI_1_CARD_sclk_m__SIO)
S    #define SPI_1_CARD_sclk_m_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(SPI_1_CARD_sclk_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_1_CARD_sclk_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_1_CARD_sclk_m_USBIO_DISABLE              ((uint32)(~SPI_1_CARD_sclk_m_USBIO_ENABLE))
S    #define SPI_1_CARD_sclk_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_1_CARD_sclk_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_1_CARD_sclk_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_sclk_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_1_CARD_sclk_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_1_CARD_sclk_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_sclk_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_1_CARD_sclk_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_sclk_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_1_CARD_sclk_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_1_CARD_sclk_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_1_CARD_sclk_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_sclk_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(SPI_1_CARD_sclk_m__PC)
S    /* Port Configuration */
S    #define SPI_1_CARD_sclk_m_PC                 (* (reg32 *) SPI_1_CARD_sclk_m__PC)
S#endif
S/* Pin State */
S#define SPI_1_CARD_sclk_m_PS                     (* (reg32 *) SPI_1_CARD_sclk_m__PS)
S/* Data Register */
S#define SPI_1_CARD_sclk_m_DR                     (* (reg32 *) SPI_1_CARD_sclk_m__DR)
S/* Input Buffer Disable Override */
S#define SPI_1_CARD_sclk_m_INP_DIS                (* (reg32 *) SPI_1_CARD_sclk_m__PC2)
S
S/* Interrupt configuration Registers */
S#define SPI_1_CARD_sclk_m_INTCFG                 (* (reg32 *) SPI_1_CARD_sclk_m__INTCFG)
S#define SPI_1_CARD_sclk_m_INTSTAT                (* (reg32 *) SPI_1_CARD_sclk_m__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define SPI_1_CARD_sclk_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(SPI_1_CARD_sclk_m__SIO)
S    #define SPI_1_CARD_sclk_m_SIO_REG            (* (reg32 *) SPI_1_CARD_sclk_m__SIO)
S#endif /* (SPI_1_CARD_sclk_m__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(SPI_1_CARD_sclk_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_1_CARD_sclk_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_1_CARD_sclk_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_1_CARD_sclk_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define SPI_1_CARD_sclk_m_DRIVE_MODE_SHIFT       (0x00u)
S#define SPI_1_CARD_sclk_m_DRIVE_MODE_MASK        (0x07u << SPI_1_CARD_sclk_m_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins SPI_1_CARD_sclk_m_H */
N
N
N/* [] END OF FILE */
L 132 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD_sclk_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_sclk_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_sclk_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_sclk_m_ALIASES_H) /* Pins SPI_1_CARD_sclk_m_ALIASES_H */
X#if !1L  
S#define CY_PINS_SPI_1_CARD_sclk_m_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define SPI_1_CARD_sclk_m_0			(SPI_1_CARD_sclk_m__0__PC)
S#define SPI_1_CARD_sclk_m_0_PS		(SPI_1_CARD_sclk_m__0__PS)
S#define SPI_1_CARD_sclk_m_0_PC		(SPI_1_CARD_sclk_m__0__PC)
S#define SPI_1_CARD_sclk_m_0_DR		(SPI_1_CARD_sclk_m__0__DR)
S#define SPI_1_CARD_sclk_m_0_SHIFT	(SPI_1_CARD_sclk_m__0__SHIFT)
S#define SPI_1_CARD_sclk_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_1_CARD_sclk_m__0__SHIFT*2u)))
S
S#define SPI_1_CARD_sclk_m_INTR_ALL	 ((uint16)(SPI_1_CARD_sclk_m_0_INTR))
S
S
N#endif /* End Pins SPI_1_CARD_sclk_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 133 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD_miso_m.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_miso_m.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_miso_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_miso_m_H) /* Pins SPI_1_CARD_miso_m_H */
X#if !1L  
S#define CY_PINS_SPI_1_CARD_miso_m_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "SPI_1_CARD_miso_m_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} SPI_1_CARD_miso_m_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   SPI_1_CARD_miso_m_Read(void);
Svoid    SPI_1_CARD_miso_m_Write(uint8 value);
Suint8   SPI_1_CARD_miso_m_ReadDataReg(void);
S#if defined(SPI_1_CARD_miso_m__PC) || (CY_PSOC4_4200L) 
S    void    SPI_1_CARD_miso_m_SetDriveMode(uint8 mode);
S#endif
Svoid    SPI_1_CARD_miso_m_SetInterruptMode(uint16 position, uint16 mode);
Suint8   SPI_1_CARD_miso_m_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid SPI_1_CARD_miso_m_Sleep(void); 
Svoid SPI_1_CARD_miso_m_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(SPI_1_CARD_miso_m__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define SPI_1_CARD_miso_m_DRIVE_MODE_BITS        (3)
S    #define SPI_1_CARD_miso_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_1_CARD_miso_m_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the SPI_1_CARD_miso_m_SetDriveMode() function.
S         *  @{
S         */
S        #define SPI_1_CARD_miso_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define SPI_1_CARD_miso_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define SPI_1_CARD_miso_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define SPI_1_CARD_miso_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define SPI_1_CARD_miso_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define SPI_1_CARD_miso_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define SPI_1_CARD_miso_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define SPI_1_CARD_miso_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define SPI_1_CARD_miso_m_MASK               SPI_1_CARD_miso_m__MASK
S#define SPI_1_CARD_miso_m_SHIFT              SPI_1_CARD_miso_m__SHIFT
S#define SPI_1_CARD_miso_m_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in SPI_1_CARD_miso_m_SetInterruptMode() function.
S     *  @{
S     */
S        #define SPI_1_CARD_miso_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define SPI_1_CARD_miso_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define SPI_1_CARD_miso_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define SPI_1_CARD_miso_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(SPI_1_CARD_miso_m__SIO)
S    #define SPI_1_CARD_miso_m_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(SPI_1_CARD_miso_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_1_CARD_miso_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_1_CARD_miso_m_USBIO_DISABLE              ((uint32)(~SPI_1_CARD_miso_m_USBIO_ENABLE))
S    #define SPI_1_CARD_miso_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_1_CARD_miso_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_1_CARD_miso_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_miso_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_1_CARD_miso_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_1_CARD_miso_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_miso_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_1_CARD_miso_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_miso_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_1_CARD_miso_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_1_CARD_miso_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_1_CARD_miso_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_miso_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(SPI_1_CARD_miso_m__PC)
S    /* Port Configuration */
S    #define SPI_1_CARD_miso_m_PC                 (* (reg32 *) SPI_1_CARD_miso_m__PC)
S#endif
S/* Pin State */
S#define SPI_1_CARD_miso_m_PS                     (* (reg32 *) SPI_1_CARD_miso_m__PS)
S/* Data Register */
S#define SPI_1_CARD_miso_m_DR                     (* (reg32 *) SPI_1_CARD_miso_m__DR)
S/* Input Buffer Disable Override */
S#define SPI_1_CARD_miso_m_INP_DIS                (* (reg32 *) SPI_1_CARD_miso_m__PC2)
S
S/* Interrupt configuration Registers */
S#define SPI_1_CARD_miso_m_INTCFG                 (* (reg32 *) SPI_1_CARD_miso_m__INTCFG)
S#define SPI_1_CARD_miso_m_INTSTAT                (* (reg32 *) SPI_1_CARD_miso_m__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define SPI_1_CARD_miso_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(SPI_1_CARD_miso_m__SIO)
S    #define SPI_1_CARD_miso_m_SIO_REG            (* (reg32 *) SPI_1_CARD_miso_m__SIO)
S#endif /* (SPI_1_CARD_miso_m__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(SPI_1_CARD_miso_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_1_CARD_miso_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_1_CARD_miso_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_1_CARD_miso_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define SPI_1_CARD_miso_m_DRIVE_MODE_SHIFT       (0x00u)
S#define SPI_1_CARD_miso_m_DRIVE_MODE_MASK        (0x07u << SPI_1_CARD_miso_m_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins SPI_1_CARD_miso_m_H */
N
N
N/* [] END OF FILE */
L 134 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD_miso_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_miso_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_miso_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_miso_m_ALIASES_H) /* Pins SPI_1_CARD_miso_m_ALIASES_H */
X#if !1L  
S#define CY_PINS_SPI_1_CARD_miso_m_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define SPI_1_CARD_miso_m_0			(SPI_1_CARD_miso_m__0__PC)
S#define SPI_1_CARD_miso_m_0_PS		(SPI_1_CARD_miso_m__0__PS)
S#define SPI_1_CARD_miso_m_0_PC		(SPI_1_CARD_miso_m__0__PC)
S#define SPI_1_CARD_miso_m_0_DR		(SPI_1_CARD_miso_m__0__DR)
S#define SPI_1_CARD_miso_m_0_SHIFT	(SPI_1_CARD_miso_m__0__SHIFT)
S#define SPI_1_CARD_miso_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_1_CARD_miso_m__0__SHIFT*2u)))
S
S#define SPI_1_CARD_miso_m_INTR_ALL	 ((uint16)(SPI_1_CARD_miso_m_0_INTR))
S
S
N#endif /* End Pins SPI_1_CARD_miso_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 135 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD_mosi_m.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_mosi_m.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_mosi_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_mosi_m_H) /* Pins SPI_1_CARD_mosi_m_H */
X#if !1L  
S#define CY_PINS_SPI_1_CARD_mosi_m_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "SPI_1_CARD_mosi_m_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} SPI_1_CARD_mosi_m_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   SPI_1_CARD_mosi_m_Read(void);
Svoid    SPI_1_CARD_mosi_m_Write(uint8 value);
Suint8   SPI_1_CARD_mosi_m_ReadDataReg(void);
S#if defined(SPI_1_CARD_mosi_m__PC) || (CY_PSOC4_4200L) 
S    void    SPI_1_CARD_mosi_m_SetDriveMode(uint8 mode);
S#endif
Svoid    SPI_1_CARD_mosi_m_SetInterruptMode(uint16 position, uint16 mode);
Suint8   SPI_1_CARD_mosi_m_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid SPI_1_CARD_mosi_m_Sleep(void); 
Svoid SPI_1_CARD_mosi_m_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(SPI_1_CARD_mosi_m__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define SPI_1_CARD_mosi_m_DRIVE_MODE_BITS        (3)
S    #define SPI_1_CARD_mosi_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_1_CARD_mosi_m_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the SPI_1_CARD_mosi_m_SetDriveMode() function.
S         *  @{
S         */
S        #define SPI_1_CARD_mosi_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define SPI_1_CARD_mosi_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define SPI_1_CARD_mosi_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define SPI_1_CARD_mosi_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define SPI_1_CARD_mosi_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define SPI_1_CARD_mosi_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define SPI_1_CARD_mosi_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define SPI_1_CARD_mosi_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define SPI_1_CARD_mosi_m_MASK               SPI_1_CARD_mosi_m__MASK
S#define SPI_1_CARD_mosi_m_SHIFT              SPI_1_CARD_mosi_m__SHIFT
S#define SPI_1_CARD_mosi_m_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in SPI_1_CARD_mosi_m_SetInterruptMode() function.
S     *  @{
S     */
S        #define SPI_1_CARD_mosi_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define SPI_1_CARD_mosi_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define SPI_1_CARD_mosi_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define SPI_1_CARD_mosi_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(SPI_1_CARD_mosi_m__SIO)
S    #define SPI_1_CARD_mosi_m_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(SPI_1_CARD_mosi_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_1_CARD_mosi_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_1_CARD_mosi_m_USBIO_DISABLE              ((uint32)(~SPI_1_CARD_mosi_m_USBIO_ENABLE))
S    #define SPI_1_CARD_mosi_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_1_CARD_mosi_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_1_CARD_mosi_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_mosi_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_1_CARD_mosi_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_1_CARD_mosi_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_mosi_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_1_CARD_mosi_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_mosi_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_1_CARD_mosi_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_1_CARD_mosi_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_1_CARD_mosi_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_mosi_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(SPI_1_CARD_mosi_m__PC)
S    /* Port Configuration */
S    #define SPI_1_CARD_mosi_m_PC                 (* (reg32 *) SPI_1_CARD_mosi_m__PC)
S#endif
S/* Pin State */
S#define SPI_1_CARD_mosi_m_PS                     (* (reg32 *) SPI_1_CARD_mosi_m__PS)
S/* Data Register */
S#define SPI_1_CARD_mosi_m_DR                     (* (reg32 *) SPI_1_CARD_mosi_m__DR)
S/* Input Buffer Disable Override */
S#define SPI_1_CARD_mosi_m_INP_DIS                (* (reg32 *) SPI_1_CARD_mosi_m__PC2)
S
S/* Interrupt configuration Registers */
S#define SPI_1_CARD_mosi_m_INTCFG                 (* (reg32 *) SPI_1_CARD_mosi_m__INTCFG)
S#define SPI_1_CARD_mosi_m_INTSTAT                (* (reg32 *) SPI_1_CARD_mosi_m__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define SPI_1_CARD_mosi_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(SPI_1_CARD_mosi_m__SIO)
S    #define SPI_1_CARD_mosi_m_SIO_REG            (* (reg32 *) SPI_1_CARD_mosi_m__SIO)
S#endif /* (SPI_1_CARD_mosi_m__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(SPI_1_CARD_mosi_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_1_CARD_mosi_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_1_CARD_mosi_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_1_CARD_mosi_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define SPI_1_CARD_mosi_m_DRIVE_MODE_SHIFT       (0x00u)
S#define SPI_1_CARD_mosi_m_DRIVE_MODE_MASK        (0x07u << SPI_1_CARD_mosi_m_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins SPI_1_CARD_mosi_m_H */
N
N
N/* [] END OF FILE */
L 136 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD_mosi_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_mosi_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_mosi_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_mosi_m_ALIASES_H) /* Pins SPI_1_CARD_mosi_m_ALIASES_H */
X#if !1L  
S#define CY_PINS_SPI_1_CARD_mosi_m_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define SPI_1_CARD_mosi_m_0			(SPI_1_CARD_mosi_m__0__PC)
S#define SPI_1_CARD_mosi_m_0_PS		(SPI_1_CARD_mosi_m__0__PS)
S#define SPI_1_CARD_mosi_m_0_PC		(SPI_1_CARD_mosi_m__0__PC)
S#define SPI_1_CARD_mosi_m_0_DR		(SPI_1_CARD_mosi_m__0__DR)
S#define SPI_1_CARD_mosi_m_0_SHIFT	(SPI_1_CARD_mosi_m__0__SHIFT)
S#define SPI_1_CARD_mosi_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_1_CARD_mosi_m__0__SHIFT*2u)))
S
S#define SPI_1_CARD_mosi_m_INTR_ALL	 ((uint16)(SPI_1_CARD_mosi_m_0_INTR))
S
S
N#endif /* End Pins SPI_1_CARD_mosi_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 137 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD_ss0_m.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_ss0_m.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_ss0_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_ss0_m_H) /* Pins SPI_1_CARD_ss0_m_H */
X#if !1L  
S#define CY_PINS_SPI_1_CARD_ss0_m_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "SPI_1_CARD_ss0_m_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} SPI_1_CARD_ss0_m_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   SPI_1_CARD_ss0_m_Read(void);
Svoid    SPI_1_CARD_ss0_m_Write(uint8 value);
Suint8   SPI_1_CARD_ss0_m_ReadDataReg(void);
S#if defined(SPI_1_CARD_ss0_m__PC) || (CY_PSOC4_4200L) 
S    void    SPI_1_CARD_ss0_m_SetDriveMode(uint8 mode);
S#endif
Svoid    SPI_1_CARD_ss0_m_SetInterruptMode(uint16 position, uint16 mode);
Suint8   SPI_1_CARD_ss0_m_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid SPI_1_CARD_ss0_m_Sleep(void); 
Svoid SPI_1_CARD_ss0_m_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(SPI_1_CARD_ss0_m__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define SPI_1_CARD_ss0_m_DRIVE_MODE_BITS        (3)
S    #define SPI_1_CARD_ss0_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_1_CARD_ss0_m_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the SPI_1_CARD_ss0_m_SetDriveMode() function.
S         *  @{
S         */
S        #define SPI_1_CARD_ss0_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define SPI_1_CARD_ss0_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define SPI_1_CARD_ss0_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define SPI_1_CARD_ss0_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define SPI_1_CARD_ss0_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define SPI_1_CARD_ss0_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define SPI_1_CARD_ss0_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define SPI_1_CARD_ss0_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define SPI_1_CARD_ss0_m_MASK               SPI_1_CARD_ss0_m__MASK
S#define SPI_1_CARD_ss0_m_SHIFT              SPI_1_CARD_ss0_m__SHIFT
S#define SPI_1_CARD_ss0_m_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in SPI_1_CARD_ss0_m_SetInterruptMode() function.
S     *  @{
S     */
S        #define SPI_1_CARD_ss0_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define SPI_1_CARD_ss0_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define SPI_1_CARD_ss0_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define SPI_1_CARD_ss0_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(SPI_1_CARD_ss0_m__SIO)
S    #define SPI_1_CARD_ss0_m_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(SPI_1_CARD_ss0_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_1_CARD_ss0_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_1_CARD_ss0_m_USBIO_DISABLE              ((uint32)(~SPI_1_CARD_ss0_m_USBIO_ENABLE))
S    #define SPI_1_CARD_ss0_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_1_CARD_ss0_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_1_CARD_ss0_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_ss0_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_1_CARD_ss0_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_1_CARD_ss0_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_ss0_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_1_CARD_ss0_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_ss0_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_1_CARD_ss0_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_1_CARD_ss0_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_1_CARD_ss0_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_ss0_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(SPI_1_CARD_ss0_m__PC)
S    /* Port Configuration */
S    #define SPI_1_CARD_ss0_m_PC                 (* (reg32 *) SPI_1_CARD_ss0_m__PC)
S#endif
S/* Pin State */
S#define SPI_1_CARD_ss0_m_PS                     (* (reg32 *) SPI_1_CARD_ss0_m__PS)
S/* Data Register */
S#define SPI_1_CARD_ss0_m_DR                     (* (reg32 *) SPI_1_CARD_ss0_m__DR)
S/* Input Buffer Disable Override */
S#define SPI_1_CARD_ss0_m_INP_DIS                (* (reg32 *) SPI_1_CARD_ss0_m__PC2)
S
S/* Interrupt configuration Registers */
S#define SPI_1_CARD_ss0_m_INTCFG                 (* (reg32 *) SPI_1_CARD_ss0_m__INTCFG)
S#define SPI_1_CARD_ss0_m_INTSTAT                (* (reg32 *) SPI_1_CARD_ss0_m__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define SPI_1_CARD_ss0_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(SPI_1_CARD_ss0_m__SIO)
S    #define SPI_1_CARD_ss0_m_SIO_REG            (* (reg32 *) SPI_1_CARD_ss0_m__SIO)
S#endif /* (SPI_1_CARD_ss0_m__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(SPI_1_CARD_ss0_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_1_CARD_ss0_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_1_CARD_ss0_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_1_CARD_ss0_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define SPI_1_CARD_ss0_m_DRIVE_MODE_SHIFT       (0x00u)
S#define SPI_1_CARD_ss0_m_DRIVE_MODE_MASK        (0x07u << SPI_1_CARD_ss0_m_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins SPI_1_CARD_ss0_m_H */
N
N
N/* [] END OF FILE */
L 138 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD_ss0_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_ss0_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_ss0_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_ss0_m_ALIASES_H) /* Pins SPI_1_CARD_ss0_m_ALIASES_H */
X#if !1L  
S#define CY_PINS_SPI_1_CARD_ss0_m_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define SPI_1_CARD_ss0_m_0			(SPI_1_CARD_ss0_m__0__PC)
S#define SPI_1_CARD_ss0_m_0_PS		(SPI_1_CARD_ss0_m__0__PS)
S#define SPI_1_CARD_ss0_m_0_PC		(SPI_1_CARD_ss0_m__0__PC)
S#define SPI_1_CARD_ss0_m_0_DR		(SPI_1_CARD_ss0_m__0__DR)
S#define SPI_1_CARD_ss0_m_0_SHIFT	(SPI_1_CARD_ss0_m__0__SHIFT)
S#define SPI_1_CARD_ss0_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_1_CARD_ss0_m__0__SHIFT*2u)))
S
S#define SPI_1_CARD_ss0_m_INTR_ALL	 ((uint16)(SPI_1_CARD_ss0_m_0_INTR))
S
S
N#endif /* End Pins SPI_1_CARD_ss0_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 139 "Generated_Source\PSoC4\project.h" 2
N#include "CapSense_ISR.h"
N#include "ADC_IRQ.h"
L 1 "Generated_Source\PSoC4\ADC_IRQ.h" 1
N/*******************************************************************************
N* File Name: ADC_IRQ.h
N* Version 1.70
N*
N*  Description:
N*   Provides the function definitions for the Interrupt Controller.
N*
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N#if !defined(CY_ISR_ADC_IRQ_H)
X#if !0L
N#define CY_ISR_ADC_IRQ_H
N
N
N#include <cytypes.h>
N#include <cyfitter.h>
N
N/* Interrupt Controller API. */
Nvoid ADC_IRQ_Start(void);
Nvoid ADC_IRQ_StartEx(cyisraddress address);
Nvoid ADC_IRQ_Stop(void);
N
NCY_ISR_PROTO(ADC_IRQ_Interrupt);
Xvoid ADC_IRQ_Interrupt (void);
N
Nvoid ADC_IRQ_SetVector(cyisraddress address);
Ncyisraddress ADC_IRQ_GetVector(void);
N
Nvoid ADC_IRQ_SetPriority(uint8 priority);
Nuint8 ADC_IRQ_GetPriority(void);
N
Nvoid ADC_IRQ_Enable(void);
Nuint8 ADC_IRQ_GetState(void);
Nvoid ADC_IRQ_Disable(void);
N
Nvoid ADC_IRQ_SetPending(void);
Nvoid ADC_IRQ_ClearPending(void);
N
N
N/* Interrupt Controller Constants */
N
N/* Address of the INTC.VECT[x] register that contains the Address of the ADC_IRQ ISR. */
N#define ADC_IRQ_INTC_VECTOR            ((reg32 *) ADC_IRQ__INTC_VECT)
N
N/* Address of the ADC_IRQ ISR priority. */
N#define ADC_IRQ_INTC_PRIOR             ((reg32 *) ADC_IRQ__INTC_PRIOR_REG)
N
N/* Priority of the ADC_IRQ interrupt. */
N#define ADC_IRQ_INTC_PRIOR_NUMBER      ADC_IRQ__INTC_PRIOR_NUM
N
N/* Address of the INTC.SET_EN[x] byte to bit enable ADC_IRQ interrupt. */
N#define ADC_IRQ_INTC_SET_EN            ((reg32 *) ADC_IRQ__INTC_SET_EN_REG)
N
N/* Address of the INTC.CLR_EN[x] register to bit clear the ADC_IRQ interrupt. */
N#define ADC_IRQ_INTC_CLR_EN            ((reg32 *) ADC_IRQ__INTC_CLR_EN_REG)
N
N/* Address of the INTC.SET_PD[x] register to set the ADC_IRQ interrupt state to pending. */
N#define ADC_IRQ_INTC_SET_PD            ((reg32 *) ADC_IRQ__INTC_SET_PD_REG)
N
N/* Address of the INTC.CLR_PD[x] register to clear the ADC_IRQ interrupt. */
N#define ADC_IRQ_INTC_CLR_PD            ((reg32 *) ADC_IRQ__INTC_CLR_PD_REG)
N
N
N
N#endif /* CY_ISR_ADC_IRQ_H */
N
N
N/* [] END OF FILE */
L 141 "Generated_Source\PSoC4\project.h" 2
N#include "ADC_intClock.h"
L 1 "Generated_Source\PSoC4\ADC_intClock.h" 1
N/*******************************************************************************
N* File Name: ADC_intClock.h
N* Version 2.20
N*
N*  Description:
N*   Provides the function and constant definitions for the clock component.
N*
N*  Note:
N*
N********************************************************************************
N* Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_CLOCK_ADC_intClock_H)
X#if !0L
N#define CY_CLOCK_ADC_intClock_H
N
N#include <cytypes.h>
N#include <cyfitter.h>
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N#if defined CYREG_PERI_DIV_CMD
X#if 1L
N
Nvoid ADC_intClock_StartEx(uint32 alignClkDiv);
N#define ADC_intClock_Start() \
N    ADC_intClock_StartEx(ADC_intClock__PA_DIV_ID)
X#define ADC_intClock_Start()     ADC_intClock_StartEx(ADC_intClock__PA_DIV_ID)
N
N#else
S
Svoid ADC_intClock_Start(void);
S
N#endif/* CYREG_PERI_DIV_CMD */
N
Nvoid ADC_intClock_Stop(void);
N
Nvoid ADC_intClock_SetFractionalDividerRegister(uint16 clkDivider, uint8 clkFractional);
N
Nuint16 ADC_intClock_GetDividerRegister(void);
Nuint8  ADC_intClock_GetFractionalDividerRegister(void);
N
N#define ADC_intClock_Enable()                         ADC_intClock_Start()
N#define ADC_intClock_Disable()                        ADC_intClock_Stop()
N#define ADC_intClock_SetDividerRegister(clkDivider, reset)  \
N    ADC_intClock_SetFractionalDividerRegister((clkDivider), 0u)
X#define ADC_intClock_SetDividerRegister(clkDivider, reset)      ADC_intClock_SetFractionalDividerRegister((clkDivider), 0u)
N#define ADC_intClock_SetDivider(clkDivider)           ADC_intClock_SetDividerRegister((clkDivider), 1u)
N#define ADC_intClock_SetDividerValue(clkDivider)      ADC_intClock_SetDividerRegister((clkDivider) - 1u, 1u)
N
N
N/***************************************
N*             Registers
N***************************************/
N#if defined CYREG_PERI_DIV_CMD
X#if 1L
N
N#define ADC_intClock_DIV_ID     ADC_intClock__DIV_ID
N
N#define ADC_intClock_CMD_REG    (*(reg32 *)CYREG_PERI_DIV_CMD)
N#define ADC_intClock_CTRL_REG   (*(reg32 *)ADC_intClock__CTRL_REGISTER)
N#define ADC_intClock_DIV_REG    (*(reg32 *)ADC_intClock__DIV_REGISTER)
N
N#define ADC_intClock_CMD_DIV_SHIFT          (0u)
N#define ADC_intClock_CMD_PA_DIV_SHIFT       (8u)
N#define ADC_intClock_CMD_DISABLE_SHIFT      (30u)
N#define ADC_intClock_CMD_ENABLE_SHIFT       (31u)
N
N#define ADC_intClock_CMD_DISABLE_MASK       ((uint32)((uint32)1u << ADC_intClock_CMD_DISABLE_SHIFT))
N#define ADC_intClock_CMD_ENABLE_MASK        ((uint32)((uint32)1u << ADC_intClock_CMD_ENABLE_SHIFT))
N
N#define ADC_intClock_DIV_FRAC_MASK  (0x000000F8u)
N#define ADC_intClock_DIV_FRAC_SHIFT (3u)
N#define ADC_intClock_DIV_INT_MASK   (0xFFFFFF00u)
N#define ADC_intClock_DIV_INT_SHIFT  (8u)
N
N#else 
S
S#define ADC_intClock_DIV_REG        (*(reg32 *)ADC_intClock__REGISTER)
S#define ADC_intClock_ENABLE_REG     ADC_intClock_DIV_REG
S#define ADC_intClock_DIV_FRAC_MASK  ADC_intClock__FRAC_MASK
S#define ADC_intClock_DIV_FRAC_SHIFT (16u)
S#define ADC_intClock_DIV_INT_MASK   ADC_intClock__DIVIDER_MASK
S#define ADC_intClock_DIV_INT_SHIFT  (0u)
S
N#endif/* CYREG_PERI_DIV_CMD */
N
N#endif /* !defined(CY_CLOCK_ADC_intClock_H) */
N
N/* [] END OF FILE */
L 142 "Generated_Source\PSoC4\project.h" 2
N#include "CyFlash.h"
N#include "CyLib.h"
N#include "cyPm.h"
L 1 "Generated_Source\PSoC4\cyPm.h" 1
N/***************************************************************************//**
N* \file cyPm.h
N* \version 5.70
N*
N* \brief Provides the function definitions for the power management API.
N*
N* \note Documentation of the API's in this file is located in the System
N* Reference Guide provided with PSoC Creator.
N*
N********************************************************************************
N* \copyright
N* Copyright 2011-2018, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_BOOT_CYPM_H)
X#if !0L
N#define CY_BOOT_CYPM_H
N
N#include "cytypes.h"
N#include "cypins.h"
N
N
N/**
N* \addtogroup group_power_management Power Management API
N* @{
N
N\brief PSoC 4 devices support the following power modes (in order of high to low power consumption): Active, Sleep,
NDeep Sleep, Hibernate, and Stop. Active, Sleep and Deep-Sleep are standard ARM defined power modes, supported by the
NARM CPUs. Hibernate/Stop are even lower power modes that are entered from firmware just like Deep-Sleep, but on wakeup
Nthe CPU (and all peripherals) goes through a full reset.
N
NThere is a full range of power modes supported by PSoC devices to control power consumption and the amount of available
Nresources. See the following table for the supported power modes.
N
NMode        | PSoC 4000              | Rest Devices           |
N----------- | ---------------------- | ---------------------- |
NActive      |          Y             |       Y                |
NSleep       |          Y             |       Y                |
NDeep Sleep  |          Y             |       Y                |
NHibernate   |          Y             |       Y                |
NStop        |                        |       Y                |
N
NFor the ARM-based devices (PSoC 4), an interrupt is required for the CPU to wake up. The Power Management implementation
Nassumes that wakeup time is configured with a separate component (component-based wakeup time configuration) for an
Ninterrupt to be issued on terminal count.
N
NAll pending interrupts should be cleared before the device is put into low power mode, even if they are masked.
N
NThe Power Management API is provided in the CyPm.c and CyPm.h files.
N
N
N\section group_power_management_implementation Implementation
NFor PSoC 4100, PSoC 4000U and PSoC 4200 devices, the software should set EXT_VCCD bit in the PWR_CONTROL register when 
NVccd is shorted to Vddd on the board. This impacts the chip internal state transitions where it is necessary to know 
Nwhether Vccd is connected or floating to achieve minimum current in low power modes. Note Setting this bit turns off 
Nthe active regulator and will lead to a system reset unless both Vddd and Vccd pins are supplied externally. Refer to 
Nthe device TRM for more information.
N
NIt is safe to call PM APIs from the ISR. The wakeup conditions for Sleep and DeepSleep low power modes are illustrated
Nin the following table.
N
NInterrupts State  |  Condition                      | Wakeup    |   ISR Execution   |
N------------------|---------------------------------|-----------|------------------ |
NUnmasked          | IRQ priority > current level    | Yes       |   Yes             |
NUnmasked          | IRQ priority  current level    | No        |   No              |
NMasked            | IRQ priority > current level    | Yes       |   No              |
NMasked            | IRQ priority  current level    | No        |   No              |
N
N
N\section group_power_management_clocks Clock Configuration
NFor PSoC 4100 BLE and PSoC 4200 BLE devices, the HFCLK source should be set to IMO before switching the device into low
Npower mode. The IMO should be enabled (by calling CySysClkImoStart(), if it is not) and HFCLK source should be changed
Nto IMO by calling CySysClkWriteHfclkDirect(CY_SYS_CLK_HFCLK_IMO).
N
NIf the System clock frequency is increased by switching to the IMO, the CySysFlashSetWaitCycles() function with an
Nappropriate parameter should be called beforehand. Also, it can optionally be called after lowering the System clock
Nfrequency in order to improve CPU performance. See CySysFlashSetWaitCycles() description for the details.
N
N
N
N
N
N*/
Nvoid CySysPmSleep(void);
Nvoid CySysPmDeepSleep(void);
N
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S    void CySysPmHibernate(void);
S    void CySysPmFreezeIo(void);
S    void CySysPmUnfreezeIo(void);
S    uint32 CySysPmGetResetReason(void);
S    void CySysPmStop(void);
S    void CySysPmSetWakeupPolarity(uint32 polarity);
N#else
N    void CySysPmSetWakeupHoldoff(uint32 hfclkFrequencyMhz);
N#endif /* (CY_IP_SRSSV2) */
N
N/** @} group_power_management */
N
N
N/*******************************************************************************
N* The ARM compilers have the __wfi() intrinsic that inserts a WFI instruction
N* into the instruction stream generated by the compiler. The GCC compiler has to
N* execute assembly language instruction.
N*******************************************************************************/
N#if defined(__ARMCC_VERSION)    /* Instristic for Keil compilers */
X#if 1L     
N    #define CY_PM_WFI       __wfi()
N#else   /* ASM for GCC & IAR */
S    #define CY_PM_WFI       __asm volatile ("WFI \n")
N#endif /* __ARMCC_VERSION */
N
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S
S    /* CySysPmSetWakeupPolarity() */
S    #define CY_PM_STOP_WAKEUP_ACTIVE_LOW        ((uint32)(0x0u))    /**< Logical zero will wakeup the chip */
S    #define CY_PM_STOP_WAKEUP_ACTIVE_HIGH       ((uint32)(0x1u))    /**< Logical one will wakeup the chip */
S    #define CY_PM_STOP_WAKEUP_POLARITY          (CY_PM_STOP_WAKEUP_ACTIVE_LOW)
S
S    /* CySysPmGetResetReason() */
S    #define CY_PM_RESET_REASON_UNKN             (0u)    /**< Unknown reset reason. */
S    #define CY_PM_RESET_REASON_XRES             (1u)    /**< Transition from OFF/XRES to RESET */
S    #define CY_PM_RESET_REASON_WAKEUP_HIB       (2u)    /**< Transition/wakeup from HIBERNATE to RESET */
S    #define CY_PM_RESET_REASON_WAKEUP_STOP      (3u)    /**< Transition/wakeup from STOP to RESET */
S
N#endif /* (CY_IP_SRSSV2) */
N
N
N/***************************************
N*              Registers
N***************************************/
N
N/* Power Mode Control */
N#define CY_PM_PWR_CONTROL_REG               (*(reg32 *) CYREG_PWR_CONTROL)
N#define CY_PM_PWR_CONTROL_PTR               ( (reg32 *) CYREG_PWR_CONTROL)
N
N/* CPU System Control Register */
N#if (CY_IP_CPUSS_CM0)
X#if ((0 == 1))
S    #define CY_PM_CPU_SCR_REG                   (*(reg32 *) CYREG_CM0_SCR)
S    #define CY_PM_CPU_SCR_PTR                   ( (reg32 *) CYREG_CM0_SCR)
N#else /* CY_IP_CPUSS_CM0PLUS */
N    #define CY_PM_CPU_SCR_REG                   (*(reg32 *) CYREG_CM0P_SCR)
N    #define CY_PM_CPU_SCR_PTR                   ( (reg32 *) CYREG_CM0P_SCR)
N#endif /* (CY_IP_CPUSS_CM0) */
N
N/* Power System Key & Delay Register */
N#define CY_PM_PWR_KEY_DELAY_REG             (*(reg32 *) CYREG_PWR_KEY_DELAY)
N#define CY_PM_PWR_KEY_DELAY_PTR             ( (reg32 *) CYREG_PWR_KEY_DELAY)
N
N
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S    /* Hibernate wakeup value for PWR_KEY_DELAY */
S    #define CY_SFLASH_HIB_KEY_DELAY_REG     (*(reg16 *) CYREG_SFLASH_HIB_KEY_DELAY)
S    #define CY_SFLASH_HIB_KEY_DELAY_PTR     ( (reg16 *) CYREG_SFLASH_HIB_KEY_DELAY)
N#endif  /* (CY_IP_SRSSV2) */
N
N/* Deep Sleep wakeup value for PWR_KEY_DELAY */
N#define CY_SFLASH_DPSLP_KEY_DELAY_REG       (*(reg16 *) CYREG_SFLASH_DPSLP_KEY_DELAY)
N#define CY_SFLASH_DPSLP_KEY_DELAY_PTR       ( (reg16 *) CYREG_SFLASH_DPSLP_KEY_DELAY)
N
N/* Power Stop Mode Register */
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S    #define CY_PM_PWR_STOP_REG              (*(reg32 *) CYREG_PWR_STOP)
S    #define CY_PM_PWR_STOP_PTR              ( (reg32 *) CYREG_PWR_STOP)
N#endif /* (CY_IP_SRSSV2) */
N
N#if (CY_PSOC4_4100 || CY_PSOC4_4200 || CY_PSOC4_4000U)
X#if ((16u == 18u) || (16u == 18u) || (16u == 5u))
S    /* CPU Subsystem Configuration */
S    #define CY_PM_CPUSS_CONFIG_REG             (*(reg32 *) CYREG_CPUSS_CONFIG)
S    #define CY_PM_CPUSS_CONFIG_PTR             ( (reg32 *) CYREG_CPUSS_CONFIG)
N#endif /* (CY_PSOC4_4100 || CY_PSOC4_4200 || CY_PSOC4_4000U) */
N
N
N/***************************************
N*       Register Constants
N***************************************/
N
N/* CM0 System Control Register Constants */
N#define CY_PM_CPU_SCR_SLEEPDEEP             ((uint32)(0x04u))
N
N#if(CY_IP_SRSSV2)
X#if((0 != 0))
S    /* Power Mode Control Constants */
S    #define CY_PM_PWR_CONTROL_HIBERNATE         (0x80000000u)
S
S    /* Power Mode Stop Constants */
S    #define CY_PM_PWR_STOP_POLARITY_SHIFT       (16u)
S    #define CY_PM_PWR_STOP_POLARITY             ((uint32)((uint32)1u << CY_PM_PWR_STOP_POLARITY_SHIFT))
S    #define CY_PM_PWR_STOP_FREEZE_SHIFT         (17u)
S    #define CY_PM_PWR_STOP_FREEZE               ((uint32)((uint32)1u << CY_PM_PWR_STOP_FREEZE_SHIFT))
S    #define CY_PM_PWR_STOP_UNLOCK_SHIFT         (8u)
S    #define CY_PM_PWR_STOP_UNLOCK_MASK          ((uint32)((uint32)0xFFu << CY_PM_PWR_STOP_UNLOCK_SHIFT))
S    #define CY_PM_PWR_STOP_UNLOCK               ((uint32)((uint32)0x3Au << CY_PM_PWR_STOP_UNLOCK_SHIFT))
S    #define CY_PM_PWR_STOP_STOP_SHIFT           (31u)
S    #define CY_PM_PWR_STOP_STOP                 ((uint32)((uint32)1u << CY_PM_PWR_STOP_STOP_SHIFT))
S    #define CY_PM_PWR_STOP_TOKEN_MASK           ((uint32)(0xFFu))
S    #define CY_PM_PWR_STOP_TOKEN_XRES           ((uint32)(0x00u))
S    #define CY_PM_PWR_STOP_TOKEN_HIB            ((uint32)(0xF1u))
S    #define CY_PM_PWR_STOP_TOKEN_STOP           ((uint32)(0xF2u))
N#else
N    #define CY_PM_PWR_KEY_DELAY_REG_DEFAULT     ((uint32) 248u)
N    #define CY_PM_PWR_KEY_DELAY_FREQ_DEFAULT    (48u)
N#endif /* (CY_IP_SRSSV2) */
N
N#if (CY_PSOC4_4100 || CY_PSOC4_4200 || CY_PSOC4_4000U)
X#if ((16u == 18u) || (16u == 18u) || (16u == 5u))
S    /* 0 - normal operation, 1 - Flash Accelerator in bypass mode */
S    #define CY_PM_CPUSS_CONFIG_FLSH_ACC_BYPASS      ((uint32) 0x02u)
N#endif /* (CY_PSOC4_4100 || CY_PSOC4_4200 || CY_PSOC4_4000U) */
N
N
N#if (CY_IP_SRSSV2)
X#if ((0 != 0))
S    #if (CY_IP_HOBTO_DEVICE)
S        /*******************************************************************************
S        * Function Name: CySysPmHibPinsDisableInputBuf
S        ****************************************************************************//**
S        *
S        *  Disable the input buffer for all the port. This is required before Hibernate
S        *  mode entry as the operation of the input buffer is not guaranteed if VCCD
S        *  drops down to 1.0 V.
S        *
S        *******************************************************************************/
S        static CY_INLINE void CySysPmHibPinsDisableInputBuf(void)
S        {
S            #ifdef CYREG_GPIO_PRT0_PC
S                CY_CLEAR_REG32_FIELD(CYREG_GPIO_PRT0_PC, CYFLD_GPIO_PRT_PORT_IB_MODE_SEL);
S            #endif /* CYREG_GPIO_PRT0_PC */
S
S            #ifdef CYREG_GPIO_PRT1_PC
S                CY_CLEAR_REG32_FIELD( CYREG_GPIO_PRT1_PC, CYFLD_GPIO_PRT_PORT_IB_MODE_SEL);
S            #endif /* CYREG_GPIO_PRT1_PC */
S
S            #ifdef CYREG_GPIO_PRT2_PC
S                CY_CLEAR_REG32_FIELD( CYREG_GPIO_PRT2_PC, CYFLD_GPIO_PRT_PORT_IB_MODE_SEL);
S            #endif /* CYREG_GPIO_PRT2_PC */
S
S            #ifdef CYREG_GPIO_PRT3_PC
S                CY_CLEAR_REG32_FIELD( CYREG_GPIO_PRT3_PC, CYFLD_GPIO_PRT_PORT_IB_MODE_SEL);
S            #endif /* CYREG_GPIO_PRT3_PC */
S
S            #ifdef CYREG_GPIO_PRT4_PC
S                CY_CLEAR_REG32_FIELD( CYREG_GPIO_PRT4_PC, CYFLD_GPIO_PRT_PORT_IB_MODE_SEL);
S            #endif /* CYREG_GPIO_PRT4_PC */
S
S            #ifdef CYREG_GPIO_PRT5_PC
S                CY_CLEAR_REG32_FIELD( CYREG_GPIO_PRT5_PC, CYFLD_GPIO_PRT_PORT_IB_MODE_SEL);
S            #endif /* CYREG_GPIO_PRT5_PC */
S
S            #ifdef CYREG_GPIO_PRT6_PC
S                CY_CLEAR_REG32_FIELD( CYREG_GPIO_PRT6_PC, CYFLD_GPIO_PRT_PORT_IB_MODE_SEL);
S            #endif /* CYREG_GPIO_PRT6_PC */
S
S            #ifdef CYREG_GPIO_PRT7_PC
S                CY_CLEAR_REG32_FIELD( CYREG_GPIO_PRT7_PC, CYFLD_GPIO_PRT_PORT_IB_MODE_SEL);
S            #endif /* CYREG_GPIO_PRT7_PC */
S
S            #ifdef CYREG_GPIO_PRT8_PC
S                CY_CLEAR_REG32_FIELD( CYREG_GPIO_PRT8_PC, CYFLD_GPIO_PRT_PORT_IB_MODE_SEL);
S            #endif /* CYREG_GPIO_PRT8_PC */
S
S            #ifdef CYREG_GPIO_PRT9_PC
S                CY_CLEAR_REG32_FIELD( CYREG_GPIO_PRT9_PC, CYFLD_GPIO_PRT_PORT_IB_MODE_SEL);
S            #endif /* CYREG_GPIO_PRT9_PC */
S
S            #ifdef CYREG_GPIO_PRT10_PC
S                CY_CLEAR_REG32_FIELD(CYREG_GPIO_PRT10_PC, CYFLD_GPIO_PRT_PORT_IB_MODE_SEL);
S            #endif /* CYREG_GPIO_PRT10_PC */
S
S            #ifdef CYREG_GPIO_PRT11_PC
S                CY_CLEAR_REG32_FIELD(CYREG_GPIO_PRT11_PC, CYFLD_GPIO_PRT_PORT_IB_MODE_SEL);
S            #endif /* CYREG_GPIO_PRT11_PC */
S
S            #ifdef CYREG_GPIO_PRT12_PC
S                CY_CLEAR_REG32_FIELD(CYREG_GPIO_PRT12_PC, CYFLD_GPIO_PRT_PORT_IB_MODE_SEL);
S            #endif /* CYREG_GPIO_PRT12_PC */
S
S            #ifdef CYREG_GPIO_PRT13_PC
S                CY_CLEAR_REG32_FIELD(CYREG_GPIO_PRT13_PC, CYFLD_GPIO_PRT_PORT_IB_MODE_SEL);
S            #endif /* CYREG_GPIO_PRT13_PC */
S
S            #ifdef CYREG_GPIO_PRT14_PC
S                CY_CLEAR_REG32_FIELD(CYREG_GPIO_PRT14_PC, CYFLD_GPIO_PRT_PORT_IB_MODE_SEL);
S            #endif /* CYREG_GPIO_PRT14_PC */
S
S            #ifdef CYREG_GPIO_PRT15_PC
S                CY_CLEAR_REG32_FIELD(CYREG_GPIO_PRT15_PC, CYFLD_GPIO_PRT_PORT_IB_MODE_SEL);
S            #endif /* CYREG_GPIO_PRT15_PC */
S        }
S    #endif /* (CY_IP_HOBTO_DEVICE) */
N#endif  /* (CY_IP_SRSSV2) */
N
N
N#if (CY_IP_CPUSS_CM0)
X#if ((0 == 1))
S    #define CY_PM_CM0_SCR_REG                   (CY_PM_CPU_SCR_REG)
S    #define CY_PM_CM0_SCR_PTR                   (CY_PM_CPU_SCR_PTR)
S    #define CY_PM_CM0_SCR_SLEEPDEEP             (CY_PM_CPU_SCR_SLEEPDEEP)
N#endif /* (CY_IP_CPUSS_CM0) */
N
N
N#endif  /* CY_BOOT_CYPM_H */
N
N
N/* [] END OF FILE */
L 145 "Generated_Source\PSoC4\project.h" 2
N#include "cytypes.h"
N#include "cypins.h"
N#include "core_cm0plus_psoc4.h"
L 1 "Generated_Source\PSoC4\core_cm0plus_psoc4.h" 1
N/***************************************************************************//**
N* \file core_cm0plus_psoc4.h
N* \version 5.70
N*
N* \brief Provides important type information for the  PSOC4 device family.
N* This includes types necessary for core_cm0.h.
N*
N* \note Documentation of the API's in this file is located in the
N*   System Reference Guide provided with PSoC Creator.
N*
N********************************************************************************
N* \copyright
N* Copyright 2008-2018, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N
N#if !defined(CY_BOOT_CORE_CM0_PSOC4_H)
X#if !0L
N#define CY_BOOT_CORE_CM0_PSOC4_H
N
N/** Interrupt Number Definition */
Ntypedef enum IRQn
N{
N/******  Cortex-M0 Processor Exceptions Numbers ***************************************************/
N  NonMaskableInt_IRQn   = -14,              /*!< 2 Non Maskable Interrupt                         */
N  HardFault_IRQn        = -13,              /*!< 3 Cortex-M0 Hard Fault Interrupt                 */
N  SVCall_IRQn           = -5,               /*!< 11 Cortex-M0 SV Call Interrupt                   */
N  PendSV_IRQn           = -2,               /*!< 14 Cortex-M0 Pend SV Interrupt                   */
N  SysTick_IRQn          = -1                /*!< 15 Cortex-M0 System Tick Interrupt               */
N/******  PSOC4 Peripheral Interrupt Numbers *******************************************************/
N  /* Not relevant.  All peripheral interrupts are defined by the user */
N} IRQn_Type;
N
N#define __CHECK_DEVICE_DEFINES
N
N#define __CM0PLUS_REV             0x0000
N#define __VTOR_PRESENT            0U
N#define __MPU_PRESENT             1U
N#define __NVIC_PRIO_BITS          2
N#define __Vendor_SysTickConfig    0
N
N#include <core_cm0plus.h>
L 1 "Generated_Source\PSoC4\core_cm0plus.h" 1
N/**************************************************************************//**
N * @file     core_cm0plus.h
N * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
N * @version  V5.00
N * @date     13. September 2016
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2016 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM0PLUS_H_GENERIC
N#define __CORE_CM0PLUS_H_GENERIC
N
N#include <stdint.h>
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex-M0+
N  @{
N */
N
N/*  CMSIS CM0+ definitions */
N#define __CM0PLUS_CMSIS_VERSION_MAIN ( 5U)                                      /*!< [31:16] CMSIS HAL main version */
N#define __CM0PLUS_CMSIS_VERSION_SUB  ( 0U)                                      /*!< [15:0]  CMSIS HAL sub version */
N#define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) | \
N                                       __CM0PLUS_CMSIS_VERSION_SUB           )  /*!< CMSIS HAL version number */
X#define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) |                                        __CM0PLUS_CMSIS_VERSION_SUB           )   
N
N#define __CORTEX_M                   (0U)                                       /*!< Cortex-M Core */
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
L 1 "Generated_Source\PSoC4\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler specific macros, functions, instructions
N * @version  V5.00
N * @date     09. November 2016
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2016 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include <stdint.h>
N
N/*
N * ARM Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "Generated_Source\PSoC4\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS Cortex-M Core Function/Instruction Header File
N * @version  V5.00
N * @date     27. September 2016
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2016 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060422 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* CMSIS compiler control architecture macros */
N#if (defined (__TARGET_ARCH_6_M ) && (__TARGET_ARCH_6_M  == 1))
X#if (0L && (__TARGET_ARCH_6_M  == 1))
S  #define __ARM_ARCH_6M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7_M ) && (__TARGET_ARCH_7_M  == 1))
X#if (0L && (__TARGET_ARCH_7_M  == 1))
S  #define __ARM_ARCH_7M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7E_M) && (__TARGET_ARCH_7E_M == 1))
X#if (0L && (__TARGET_ARCH_7E_M == 1))
S  #define __ARM_ARCH_7EM__          1
N#endif
N
N  /* __ARM_ARCH_8M_BASE__  not applicable */
N  /* __ARM_ARCH_8M_MAIN__  not applicable */
N
N
N/* CMSIS compiler specific defines */
N#ifndef   __ASM
N  #define __ASM                     __asm
N#endif
N#ifndef   __INLINE
N  #define __INLINE                  __inline
N#endif
N#ifndef   __STATIC_INLINE
N  #define __STATIC_INLINE           static __inline
N#endif
N#ifndef   __NO_RETURN
N  #define __NO_RETURN               __declspec(noreturn)
N#endif
N#ifndef   __USED
N  #define __USED                    __attribute__((used))
N#endif
N#ifndef   __WEAK
N  #define __WEAK                    __attribute__((weak))
N#endif
N#ifndef   __UNALIGNED_UINT32
N  #define __UNALIGNED_UINT32(x)     (*((__packed uint32_t *)(x)))
N#endif
N#ifndef   __ALIGNED
N  #define __ALIGNED(x)              __attribute__((aligned(x)))
N#endif
N#ifndef   __PACKED
N  #define __PACKED                  __attribute__((packed))
N#endif
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/**
N  \brief   Enable IRQ Interrupts
N  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __enable_irq();     */
N
N
N/**
N  \brief   Disable IRQ Interrupts
N  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   Enable FIQ
S  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/**
S  \brief   Disable FIQ
S  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/**
S  \brief   Get Base Priority
S  \details Returns the current value of the Base Priority register.
S  \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/**
S  \brief   Set Base Priority
S  \details Assigns the given value to the Base Priority register.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Set Base Priority with condition
S  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S           or the new value increases the BASEPRI priority level.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
S{
S  register uint32_t __regBasePriMax      __ASM("basepri_max");
S  __regBasePriMax = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Get Fault Mask
S  \details Returns the current value of the Fault Mask register.
S  \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/**
S  \brief   Set Fault Mask
S  \details Assigns the given value to the Fault Mask register.
S  \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1U);
S}
S
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   Get FPSCR
S  \details Returns the current value of the Floating Point Status/Control register.
S  \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
S     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) &&      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0U);
S#endif
S}
S
S
S/**
S  \brief   Set FPSCR
S  \details Assigns the given value to the Floating Point Status/Control register.
S  \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
S     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) &&      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in integer value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in two unsigned short values.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Reverse byte order in signed short value
N  \details Reverses the byte order in a signed short value with sign extension to integer.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    op1  Value to rotate
N  \param [in]    op2  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S  #define __RBIT                          __rbit
N#else
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
X__attribute__((always_inline)) static __inline uint32_t __RBIT(uint32_t value)
N{
N  uint32_t result;
N  int32_t s = (4 /*sizeof(v)*/ * 8) - 1; /* extra shift needed at end */
N
N  result = value;                      /* r will be reversed bits of v; first get LSB of v */
N  for (value >>= 1U; value; value >>= 1U)
N  {
N    result <<= 1U;
N    result |= value & 1U;
N    s--;
N  }
N  result <<= s;                        /* shift when v's highest bits are zero */
N  return(result);
N}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   LDR Exclusive (8 bit)
S  \details Executes a exclusive LDR instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
S#else
S  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (16 bit)
S  \details Executes a exclusive LDR instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
S#else
S  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (32 bit)
S  \details Executes a exclusive LDR instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
S#else
S  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (8 bit)
S  \details Executes a exclusive STR instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (16 bit)
S  \details Executes a exclusive STR instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (32 bit)
S  \details Executes a exclusive STR instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   Remove the exclusive lock
S  \details Removes the exclusive lock which is created by LDREX.
S */
S#define __CLREX                           __clrex
S
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/**
S  \brief   Rotate Right with Extend (32 bit)
S  \details Moves each bit of a bitstring right by one bit.
S           The carry input is shifted in at the left end of the bitstring.
S  \param [in]    value  Value to rotate
S  \return               Rotated value
S */
S#ifndef __NO_EMBEDDED_ASM
S__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
S{
S  rrx r0, r0
S  bx lr
S}
S#endif
S
S
S/**
S  \brief   LDRT Unprivileged (8 bit)
S  \details Executes a Unprivileged LDRT instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (16 bit)
S  \details Executes a Unprivileged LDRT instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (32 bit)
S  \details Executes a Unprivileged LDRT instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
S
S
S/**
S  \brief   STRT Unprivileged (8 bit)
S  \details Executes a Unprivileged STRT instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRBT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (16 bit)
S  \details Executes a Unprivileged STRT instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRHT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (32 bit)
S  \details Executes a Unprivileged STRT instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRT(value, ptr)                __strt(value, ptr)
S
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 35 "Generated_Source\PSoC4\cmsis_compiler.h" 2
N
N
N/*
N * ARM Compiler 6 (armclang)
N */
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
S
S  #ifndef   __ASM
S    #define __ASM                     __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                  inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE           static inline
S  #endif
S
S  #include <cmsis_iar.h>
S
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN               __noreturn
S  #endif
S  #ifndef   __USED
S    #define __USED                    __root
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                    __weak
S  #endif
S  #ifndef   __UNALIGNED_UINT32
S    __packed struct T_UINT32 { uint32_t v; };
S      #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                  __packed
S  #endif
S
S
S/*
S * TI ARM Compiler
S */
S#elif defined ( __TI_ARM__ )
S  #include <cmsis_ccs.h>
S
S  #ifndef   __ASM
S    #define __ASM                     __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                  inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE           static inline
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN               __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                    __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                    __attribute__((weak))
S  #endif
S  #ifndef   __UNALIGNED_UINT32
S    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __attribute__((aligned(x)))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                  __attribute__((packed))
S  #endif
S
S
S/*
S * TASKING Compiler
S */
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                     __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                  inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE           static inline
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN               __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                    __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                    __attribute__((weak))
S  #endif
S  #ifndef   __UNALIGNED_UINT32
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                  __packed__
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                     _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                  inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE           static inline
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                    __weak
S  #endif
S  #ifndef   __UNALIGNED_UINT32
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                  @packed
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 114 "Generated_Source\PSoC4\core_cm0plus.h" 2
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0PLUS_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0PLUS_H_DEPENDANT
N#define __CORE_CM0PLUS_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 1L
N  #ifndef __CM0PLUS_REV
S    #define __CM0PLUS_REV             0x0000U
S    #warning "__CM0PLUS_REV not defined in device header file; using default!"
N  #endif
N
N  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
N  #endif
N
N  #ifndef __VTOR_PRESENT
S    #define __VTOR_PRESENT            0U
S    #warning "__VTOR_PRESENT not defined in device header file; using default!"
N  #endif
N
N  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
N  #endif
N
N  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
N  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex-M0+ */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core MPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[1U];                
N        uint32_t RESERVED0[31U];
N  __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[1U];                
N        uint32_t RSERVED1[31U];
N  __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[1U];                
N        uint32_t RESERVED2[31U];
N  __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[1U];                
N        uint32_t RESERVED3[31U];
N        uint32_t RESERVED4[64U];
N  __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
X  volatile uint32_t IP[8U];                  
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
X#if 1L && (0U == 1U)
S  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
N#else
N        uint32_t RESERVED0;
N#endif
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N        uint32_t RESERVED1;
N  __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED */
X  volatile uint32_t SHP[2U];                 
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
X#if 1L && (0U == 1U)
S/* SCB Interrupt Control State Register Definitions */
S#define SCB_VTOR_TBLOFF_Pos                 8U                                            /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N#endif
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1U == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N  \brief    Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
X  volatile const  uint32_t TYPE;                    
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
X  volatile uint32_t RNR;                     
N  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
X  volatile uint32_t RBAR;                    
N  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
X  volatile uint32_t RASR;                    
N} MPU_Type;
N
N/* MPU Type Register Definitions */
N#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register Definitions */
N#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register Definitions */
N#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register Definitions */
N#define MPU_RBAR_ADDR_Pos                   8U                                            /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register Definitions */
N#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible over DAP and not via processor.
N            Therefore they are not covered by the Cortex-M0+ header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0+ Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1U == 1U)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
N#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
N#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
N
N
N/**
N  \brief   Enable Interrupt
N  \details Enables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Enable status
N  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt is not enabled.
N  \return             1  Interrupt is enabled.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t NVIC_GetEnableIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetEnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Disable Interrupt
N  \details Disables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N  \note    The priority cannot be set for every processor exception.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  = ((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N  else
N  {
N    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] = ((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N  else
N  {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N}
N
N#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
X#if 1L && (0U == 1U)
S  #define NVIC_USER_IRQ_OFFSET          16
S
S/**
S  \brief   Set Interrupt Vector
S  \details Sets an interrupt vector in SRAM based interrupt vector table.
S           The interrupt number can be positive to specify a device specific interrupt,
S           or negative to specify a processor exception.
S           VTOR must been relocated to SRAM before.
S  \param [in]   IRQn      Interrupt number
S  \param [in]   vector    Address of interrupt handler function
S */
S__STATIC_INLINE void NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
S{
S    uint32_t *vectors = (uint32_t *)SCB->VTOR;
S    vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
S}
S
S
S/**
S  \brief   Get Interrupt Vector
S  \details Reads an interrupt vector from interrupt vector table.
S           The interrupt number can be positive to specify a device specific interrupt,
S           or negative to specify a processor exception.
S  \param [in]   IRQn      Interrupt number.
S  \return                 Address of interrupt handler function
S */
S__STATIC_INLINE uint32_t NVIC_GetVector(IRQn_Type IRQn)
S{
S    uint32_t *vectors = (uint32_t *)SCB->VTOR;
S    return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
S}
N#endif
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FAUL << 16U) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2U));
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic __inline uint32_t SCB_GetFPUType(void)
N{
N    return 0U;           /* No FPU */
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
X#if 1L && (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1UL << 2) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0PLUS_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 45 "Generated_Source\PSoC4\core_cm0plus_psoc4.h" 2
N
N#endif /* CY_BOOT_CORE_CM0_PSOC4_H */
L 148 "Generated_Source\PSoC4\project.h" 2
N#include "CyDMA.h"
L 1 "Generated_Source\PSoC4\CyDMA.h" 1
N/*******************************************************************************
N* File Name: CyDMA.h
N* Version 1.10
N*
N* Description:
N*  This file provides global DMA defines and API function definitions.
N*
N* Note:
N*  All the API function in this file are documented in the DMA Channel
N*  component datasheet.
N*
N********************************************************************************
N* Copyright 2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#ifndef CY_DMA_GLOBAL_P4_H
N#define CY_DMA_GLOBAL_P4_H
N
N#include "cytypes.h"
N
N
N/***************************************
N*   Conditional Compilation Parameters
N***************************************/
N
N#define CYDMA_CH_NR         (CYDEV_DMA_CHANNELS_AVAILABLE)
N#define CYDMA_DESCR_NR      (2)
N
N
N/***************************************
N*     Data Struct Definitions
N***************************************/
N
N/* Channel control registers. Each channel has a dedicated control register. */
Ntypedef struct
N{
N    uint32 ctl[CYDMA_CH_NR];
X    uint32 ctl[(8)];
N} cydma_channel_ctl_struct;
N
N/* Descriptor structure specifies transfer settings. */
Ntypedef struct
N{
N    void * src;     /* Source address */
N    void * dst;     /* Destination address */
N    uint32 ctl;     /* Control word */
N    uint32 status;  /* Status word */
N} cydma_descriptor_struct;
N
N/* Each channel has two descriptor structures for double buffering purposes.
N* The two descriptor structures are identical. All descriptors are placed
N* sequentially in the DMAC MMIO register space.
N*/
Ntypedef struct
N{
N    cydma_descriptor_struct descriptor[CYDMA_CH_NR][CYDMA_DESCR_NR];
X    cydma_descriptor_struct descriptor[(8)][(2)];
N} cydma_descriptor_ram_struct;
N
N/* Configuration structure used by CyDmaSetConfiguration() API. */
Ntypedef struct
N{
N    /* Specifies the size of the data element. The DMA transfer engine transfers
N    * one data element at a time. How these transfers occur is controlled by the
N    * transferMode parameter.
N    */
N    uint32  dataElementSize;
N
N    /* Specifies the total number of data elements this descriptor transfers.
N    * Valid ranges are 1 to 65536.
N    */
N    int32   numDataElements;
N
N    /* Specifies the source and destination widths. */
N    uint32  srcDstTransferWidth;
N
N    /* Specifies whether the source and/or destination address will be
N    * incremented after the transfer of each single data element.
N    */
N    uint32  addressIncrement;
N
N    /* Specifies the type of DMA trigger. */
N    uint32  triggerType;
N
N    /* Specifies how the DMA reacts to each trigger event. */
N    uint32  transferMode;
N
N    /* Specifies whether the descriptor is preemptable. */ 
N    uint32  preemptable;
N
N    /* Specifies what occurs after a descriptor completes. */
N    uint32  actions;
N
N} cydma_init_struct;
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
N/* Callback function pointer type */
Ntypedef void (*cydma_callback_t)(void);
N
N/* Default interrupt service routine */
NCY_ISR_PROTO(CyDmaInterrupt);
Xvoid CyDmaInterrupt (void);
N
N/* DMA controller specific functions */
Nvoid   CyDmaEnable(void);
Nvoid   CyDmaDisable(void);
N
Nuint32 CyDmaGetStatus(void);
Nuint32 CyDmaGetActiveChannels(void);
Nvoid * CyDmaGetActiveSrcAddress(void);
Nvoid * CyDmaGetActiveDstAddress(void);
N
Nvoid   CyDmaSetInterruptVector(cyisraddress interruptVector);
Nuint32 CyDmaGetInterruptSource(void);
Nvoid   CyDmaClearInterruptSource(uint32 interruptMask);
Nuint32 CyDmaGetInterruptSourceMasked(void);
Nvoid   CyDmaSetInterruptSourceMask(uint32 interruptMask);
Nuint32 CyDmaGetInterruptSourceMask(void);
Ncydma_callback_t CyDmaSetInterruptCallback(int32 channel, cydma_callback_t callback);
Ncydma_callback_t CyDmaGetInterruptCallback(int32 channel);
N
N/* Channel specific functions */
Nint32  CyDmaChAlloc(void);
Ncystatus CyDmaChFree(int32 channel);
N
Nvoid   CyDmaChEnable(int32 channel);
Nvoid   CyDmaChDisable(int32 channel);
Nvoid   CyDmaTrigger(int32 channel);
N
Nvoid   CyDmaSetPriority(int32 channel, int32 priority);
Nint32  CyDmaGetPriority(int32 channel);
N
Nvoid   CyDmaSetNextDescriptor(int32 channel, int32 descriptor);
Nint32  CyDmaGetNextDescriptor(int32 channel);
N
N/* Descriptor specific functions */
Nvoid   CyDmaSetConfiguration(int32 channel, int32 descriptor, const cydma_init_struct * config);
N
Nvoid   CyDmaValidateDescriptor(int32 channel, int32 descriptor);
N
Nuint32 CyDmaGetDescriptorStatus(int32 channel, int32 descriptor);
N
Nvoid   CyDmaSetSrcAddress(int32 channel, int32 descriptor, void * srcAddress);
Nvoid * CyDmaGetSrcAddress(int32 channel, int32 descriptor);
N
Nvoid   CyDmaSetDstAddress(int32 channel, int32 descriptor, void * dstAddress);
Nvoid * CyDmaGetDstAddress(int32 channel, int32 descriptor);
N
Nvoid   CyDmaSetDataElementSize(int32 channel, int32 descriptor, uint32 dataElementSize);
Nuint32 CyDmaGetDataElementSize(int32 channel, int32 descriptor);
N
Nvoid   CyDmaSetNumDataElements(int32 channel, int32 descriptor, int32 numDataElements);
Nint32  CyDmaGetNumDataElements(int32 channel, int32 descriptor);
N
Nvoid   CyDmaSetSrcDstTransferWidth(int32 channel, int32 descriptor, uint32 transferWidth);
Nuint32 CyDmaGetSrcDstTransferWidth(int32 channel, int32 descriptor);
N
Nvoid   CyDmaSetAddressIncrement(int32 channel, int32 descriptor, uint32 addressIncrement);
Nuint32 CyDmaGetAddressIncrement(int32 channel, int32 descriptor);
N
Nvoid   CyDmaSetTriggerType(int32 channel, int32 descriptor, uint32 triggerType);
Nuint32 CyDmaGetTriggerType(int32 channel, int32 descriptor);
N
Nvoid   CyDmaSetTransferMode(int32 channel, int32 descriptor, uint32 transferMode);
Nuint32 CyDmaGetTransferMode(int32 channel, int32 descriptor);
N
Nvoid   CyDmaSetPreemptable(int32 channel, int32 descriptor, uint32 preemptable);
Nuint32 CyDmaGetPreemptable(int32 channel, int32 descriptor);
N
Nvoid   CyDmaSetPostCompletionActions(int32 channel, int32 descriptor, uint32 actions);
Nuint32 CyDmaGetPostCompletionActions(int32 channel, int32 descriptor);
N
N
N/***************************************
N*           API Constants
N***************************************/
N
N#define CYDMA_INTR_NUMBER               (CYDEV_INTR_NUMBER_DMA)
N#define CYDMA_INTR_PRIO                 (3u)
N
N#define CYDMA_INVALID_CHANNEL           (-1)
N
N#define CYDMA_TRIGGER_MASK              (0xC0020000U)
N#define CYDMA_TR_SEL_MASK               (0x00000007U)
N#define CYDMA_TR_GROUP_SHR              (3)
N
N#define CYDMA_MAX_DATA_NR               (65536)
N
N#define CY_DMA_MAX_PRIO                 (3)
N
N
N/*******************************************************************************
N* Bit fields for CyDmaSetDataElementSize()/CyDmaGetDataElementSize().
N*******************************************************************************/
N
N/* Specifies the size of the data element that is transferred at a time. */
N#define CYDMA_BYTE                      (0x00000000U)    /* 1 byte */
N#define CYDMA_HALFWORD                  (0x00010000U)    /* 2 bytes */
N#define CYDMA_WORD                      (0x00020000U)    /* 4 bytes */
N
N
N/*******************************************************************************
N* Bit fields for CyDmaSetSrcDstTransferWidth()/CyDmaGetSrcDstTransferWidth().
N*******************************************************************************/
N
N/* Source and Destination widths are set by the data element size. */
N#define CYDMA_ELEMENT_ELEMENT           (0x00000000U)
N
N/* Source width is set by data element size. Destination width is a 
N* word (4bytes). If the source width is smaller than the destination
N* width, the upper bytes of the destination are written with zeros.
N*/
N#define CYDMA_ELEMENT_WORD              (0x00100000U)
N
N/* Source width is a word (4 bytes). Destination width is set by data
N* element size. If the source width is larger than the destination width,
N* the upper bytes of the source are ignored during the transaction.
N*/
N#define CYDMA_WORD_ELEMENT              (0x00400000U)
N
N/* Both source and destination widths are words. However, the data element
N* size still has an effect in this mode. For example, if the data element
N* size is set to a byte, then the upper three bytes of destination is
N* padded with zeros, and the upper three bytes of the source is ignored
N* during the transaction.
N*/
N#define CYDMA_WORD_WORD                 (0x00500000U)
N
N
N/*******************************************************************************
N* Bit fields for CyDmaSetAddressIncrement()/CyDmaGetAddressIncrement().
N*******************************************************************************/
N
N/* Specifies whether the source and/or destination address is incremented
N* after the transfer of each single data element. The defines can be OR'd
N* together.
N*/
N#define CYDMA_INC_SRC_ADDR              (0x00800000U)
N#define CYDMA_INC_DST_ADDR              (0x00200000U)
N#define CYDMA_INC_NONE                  (0x00000000U)
N
N
N/*******************************************************************************
N* Bit fields for CyDmaSetTriggerType()/CyDmaGetTriggerType().
N*******************************************************************************/
N
N/* Specifies the type of DMA trigger */
N#define CYDMA_PULSE                     (0x00000000U)
N#define CYDMA_LEVEL_FOUR                (0x01000000U)
N#define CYDMA_LEVEL_EIGHT               (0x02000000U)
N#define CYDMA_PULSE_UNKNOWN             (0x03000000U)
N
N
N/*******************************************************************************
N* Bit fields for CyDmaSetTransferMode()/CyDmaGetTransferMode().
N*******************************************************************************/
N
N/* Each trigger causes the DMA to transfer a single data element. */
N#define CYDMA_SINGLE_DATA_ELEMENT       (0x00000000U)
N    
N/* Each trigger automatically transfers all data elements associated with
N* the current descriptor, one data element at a time.
N*/
N#define CYDMA_ENTIRE_DESCRIPTOR         (0x40000000U)
N
N/* Each trigger automatically transfers all data elements associated with
N* the current descriptor, one data element at a time. Upon completion the
N* next descriptor is automatically triggered.
N*/
N#define CYDMA_ENTIRE_DESCRIPTOR_CHAIN   (0x80000000U)
N
N
N/*******************************************************************************
N* Bit fields for CyDmaSetPreemptable()/CyDmaGetPreemptable().
N*******************************************************************************/
N
N/* Specifies whether the descriptor is preemptable. */
N#define CYDMA_PREEMPTABLE               (0x10000000U)
N#define CYDMA_NON_PREEMPTABLE           (0x00000000U)
N
N
N/*******************************************************************************
N* Bit fields for CyDmaSetPostCompletionActions()/CyDmaGetPostCompletionActions()
N*******************************************************************************/
N
N/* Specifies what occurs after a descriptor completes. The defines that can be
N* OR'd together.
N*
N* On completion of descriptor chain to the next descriptor. */
N#define CYDMA_CHAIN                     (0x20000000U)
N
N/* Invalidate the descriptor when it completes. */
N#define CYDMA_INVALIDATE                (0x04000000U)
N    
N/* On completion of descriptor generate an interrupt request. */
N#define CYDMA_GENERATE_IRQ              (0x08000000U)
N    
N/* No actions after the descriptor completes. */
N#define CYDMA_NONE                      (0x00000000U)
N
N
N/*******************************************************************************
N* Bit fields for CyDmaGetStatus().
N*******************************************************************************/
N
N/* Bit fields to access the status register bits of the DMA transfer engine. */
N#define CYDMA_TRANSFER_INDEX            (0x0000FFFFU)
N#define CYDMA_CH_NUM                    (0x001F0000U)
N#define CYDMA_STATE                     (0x07000000U)
N#define CYDMA_PRIO                      (0x30000000U)
N#define CYDMA_DESCRIPTOR                (0x40000000U)
N#define CYDMA_ACTIVE                    (0x80000000U)
N
N/* Defines for STATE: Only one define can be active at a time. */
N#define CYDMA_IDLE                      (0x00000000U)
N#define CYDMA_LOAD_DESCR                (0x01000000U)
N#define CYDMA_LOAD_SRC                  (0x02000000U)
N#define CYDMA_STORE_DST                 (0x03000000U)
N#define CYDMA_STORE_DESCR               (0x04000000U)
N#define CYDMA_WAIT_TRIG_DEACT           (0x05000000U)
N#define CYDMA_STORE_ERROR               (0x06000000U)
N
N
N/*******************************************************************************
N* Bit fields for CyDmaGetDescriptorStatus().
N*******************************************************************************/
N
N/* Bit fields to access the status register bits of the descriptor. */
N#define CYDMA_TRANSFER_INDEX            (0x0000FFFFU)
N#define CYDMA_RESPONSE                  (0x00070000U)
N#define CYDMA_VALID                     (0x80000000U)
N
N/* Response code meaning */
N#define CYDMA_NO_ERROR                  (0x00000000U)
N#define CYDMA_DONE                      (0x00010000U)
N#define CYDMA_SRC_BUS_ERROR             (0x00020000U)
N#define CYDMA_DST_BUS_ERROR             (0x00030000U)
N#define CYDMA_SRC_MISAL                 (0x00040000U)
N#define CYDMA_DST_MISAL                 (0x00050000U)
N#define CYDMA_INVALID_DESCR             (0x00060000U)
N
N
N/***************************************
N*             Registers
N***************************************/
N
N#define CYDMA_CTL_REG                   (*(reg32 *) CYREG_DMAC_CTL)
N#define CYDMA_STATUS_REG                (*(reg32 *) CYREG_DMAC_STATUS)
N#define CYDMA_STATUS_SRC_ADDR_REG       (*(reg32 *) CYREG_DMAC_STATUS_SRC_ADDR)
N#define CYDMA_STATUS_DST_ADDR_REG       (*(reg32 *) CYREG_DMAC_STATUS_DST_ADDR)
N#define CYDMA_STATUS_CH_ACT_REG         (*(reg32 *) CYREG_DMAC_STATUS_CH_ACT)
N#define CYDMA_INTR_REG                  (*(reg32 *) CYREG_DMAC_INTR)
N#define CYDMA_INTR_SET_REG              (*(reg32 *) CYREG_DMAC_INTR_SET)
N#define CYDMA_INTR_MASK_REG             (*(reg32 *) CYREG_DMAC_INTR_MASK)
N#define CYDMA_INTR_MASKED_REG           (*(reg32 *) CYREG_DMAC_INTR_MASKED)
N#define CYDMA_CH_CTL_BASE               (*(volatile cydma_channel_ctl_struct *) CYREG_DMAC_CH_CTL0)
N#define CYDMA_DESCR_BASE                (*(volatile cydma_descriptor_ram_struct *) CYDEV_DMAC_DESCR0_BASE)
N
N#define CYDMA_TR_CTL_REG                (*(reg32 *) CYREG_PERI_TR_CTL)
N
N
N/***************************************
N*       Register Constants
N***************************************/
N
N#define CYDMA_ENABLED                   (0x80000000U)
N#define CYDMA_PRIO_POS                  (28)
N#define CYDMA_DESCRIPTOR_POS            (30)
N
N/* Descriptor control register */
N#define CYDMA_DATA_SIZE                 (0x00030000U)
N#define CYDMA_DATA_NR                   (0x0000FFFFUL)
N#define CYDMA_TRANSFER_WIDTH            (0x00500000U)
N#define CYDMA_ADDR_INCR                 (0x00A00000U)
N#define CYDMA_TRANSFER_MODE             (0xC0000000U)
N#define CYDMA_TRIGGER_TYPE              (0x03000000U)
N#define CYDMA_POST_COMPLETE_ACTIONS     (0x2C000000U)
N
N#endif /* CY_DMA_GLOBAL_P4_H */
N
N
N/* [] END OF FILE */
L 149 "Generated_Source\PSoC4\project.h" 2
N#include "CyLFClk.h"
N#include "cy_em_eeprom.h"
N
N/*[]*/
N
L 16 ".\Modules\Tuch\Tuch.h" 2
N#include "stdbool.h"
N#include "main.h"
N    
N#define USE_TUNER                       0     
N
N//#define CapSense_TOTAL_BUTTON 12
N//#define ABOVE_BASELINE_MAX  100
N//#define BLOW_BASELINE_MAX   100
N//#define RESET_BASELINE_MAX  5000
N
N/* Device power mode related macros */
N
N/* Active status scan timeout */ 
N//#define ACTIVE_SCAN_TIMEOUT_COUNTER     (500)
N    
N    
N//#define WORK_ACTIVE 0
N//#define WORK_LOWPOWER 1
N
N//#define SET_BIT(data, bitPosition)  ((data) |= (1 << (bitPosition)))
N//#define CLEAR_BIT(data, bitPosition)  ((data) &= (~(1 << (bitPosition))))
N    
N    
N
N//void CapSense_Active(void);
N
N
Nextern void EnterDeepSleepLowPowerMode(void);  //娣卞害
N//==========================================================================
Ntypedef enum {
N    TUCH_KEY0 = 0,
N    TUCH_KEY1 = 1,
N    TUCH_KEY2 = 2,
N    TUCH_KEY3 = 3,
N    TUCH_KEY4 = 4,
N    TUCH_KEY5 = 5,
N    TUCH_KEY6 = 6,
N    TUCH_KEY7 = 7,
N    TUCH_KEY8 = 8,
N    TUCH_KEY9 = 9,
N    TUCH_KEY_ESC    = 10,
N    TUCH_KEY_ENTER  = 11,
N    TUCH_KEY_ENTER_UP  = 12,
N    TUCH_KEY_NULL = 13,
N} TUCH_KEY_t;
N
Ntypedef enum {
N	RELEASE     	= 0x40,
N    LONG_CLICK  	= 0x20,
N    DOUBLE_CLICK 	= 0x10,
N    CLICK       	= 0x00,
N} TUCH_STATE_t;
N
Ntypedef struct {
N    uint8_t even;
N    uint8_t val;
N}Tuch_t;
N
Nextern int8_t Tuch_init(void);
Nextern Tuch_t *Tuch_status(void);
Nextern bool Tuch_Scan(void);        //娴搴
Xextern _Bool Tuch_Scan(void);        
Nextern bool Tuch_LowpowerScan(void);//娣卞害
Xextern _Bool Tuch_LowpowerScan(void);
N
N#endif
N/* [] END OF FILE */
L 28 ".\main.h" 2
N#include "Display.h"
L 1 ".\Modules\Display\Display.h" 1
N/* ========================================
N *
N * Copyright YOUR COMPANY, THE YEAR
N * All Rights Reserved
N * UNPUBLISHED, LICENSED SOFTWARE.
N *
N * CONFIDENTIAL AND PROPRIETARY INFORMATION
N * WHICH IS THE PROPERTY OF your company.
N *
N * ========================================
N*/
N#ifndef _DISPLAY_H
N#define _DISPLAY_H
N
N#include "main.h"
N
N#define _CMD                 		0
N#define _DAT                 		1
N
Ntypedef struct {
N    uint16_t GBcode;
N    uint8_t dat[32];
N} GB2313_t;
N
N#define CN_NUM	140
Nextern const GB2313_t CN16X16[];														//涓瀛搴
Nextern const uint8_t F8X16[];															//辨板 瀛搴
Nextern const char Bterry20x10[];														//垫剧
Nextern const char Bterry1x10[];															//甸剧
N
Nextern int8_t Display_init(void);
Nextern void Display_clear_screen(void);
Nextern void Display_picture(uint8_t x, uint8_t y, uint8_t w, uint8_t h, char *pic);
Nextern void Display_char(uint8_t x, uint8_t y, uint8_t chr,uint8_t N);                  //N涓烘姝ｅ剧ず
Nextern void Display_english_str(uint8_t x, uint8_t y, char *str, uint8_t N);            //N涓烘姝ｅ剧ず
Nextern void Display_chinese_str(uint8_t x, uint8_t y, char *str, uint8_t N);            //N涓烘姝ｅ剧ず
N
N#endif
N
N/* [] END OF FILE */
L 29 ".\main.h" 2
N#include "Rtc.h"
L 1 ".\Modules\Rtc\Rtc.h" 1
N/* ========================================
N *
N * Copyright YOUR COMPANY, THE YEAR
N * All Rights Reserved
N * UNPUBLISHED, LICENSED SOFTWARE.
N *typedef struct{
N    
N    volatile uint32_t TimeOutCount;
N    
N    volatile uint8_t WakeFlag;
N    
N    volatile uint8_t LOW_FLAG;//妯″蹇  ACTIVITY 娲诲ㄦā寮  LOWPOWER 浣妯″
N    
N    volatile uint8_t Tick_Flag;
N    
N    volatile uint8_t Sys_status;
N    
N    volatile uint8_t Lock_run;
N    
N}SYSFlAG,*pSYSFLAG;
N * CONFIDENTIAL AND PROPRIETARY INFORMATION
N * WHICH IS THE PROPERTY OF your company.
N *
N * ========================================
N*/
N#ifndef _RTC_H
N#define _RTC_H
N
N#include "main.h"
N
Ntypedef struct
N{
N    uint16_t year;  /*!< Range from 1970 to 2099.*/
N    uint8_t month;  /*!< Range from 1 to 12.*/
N    uint8_t day;    /*!< Range from 1 to 31 (depending on month).*/
N    uint8_t hour;   /*!< Range from 0 to 23.*/
N    uint8_t minute; /*!< Range from 0 to 59.*/
N    uint8_t second; /*!< Range from 0 to 59.*/
N}Rtc_t;
N
Nextern int8_t Rtc_init(void);
Nextern int8_t Rtc_Set(Rtc_t *t);
Nextern int8_t Rtc_Get(Rtc_t *t);
N
N#endif
N
N/* [] END OF FILE */
L 30 ".\main.h" 2
N#include "Voice.h"
L 1 ".\Modules\Voice\Voice.h" 1
N/* ========================================
N *
N * Copyright YOUR COMPANY, THE YEAR
N * All Rights Reserved
N * UNPUBLISHED, LICENSED SOFTWARE.
N *
N * CONFIDENTIAL AND PROPRIETARY INFORMATION
N * WHICH IS THE PROPERTY OF your company.
N *
N * ========================================
N*/
N#ifndef _VOICE_H_
N#define _VOICE_H_
N    
N#include "main.h"
N    
N#define HAUN_YING_YIN                                           1//娆㈣
N#define AN_JIAN_YIN_DI                                          2//Di
N#define ZHI_WEN_YIN_DO                                          3//绾归Do
N#define BAO_JING_YIN                                            4//ヨ
N#define YU_YIN_A                                                5//A
N#define YU_YIN_B                                                6//B
N#define YU_YIN_C                                                7//C
N#define YU_YIN_D                                                8//D
N#define YU_YIN_E                                                9//E
N#define YU_YIN_F                                                10//F
N#define YU_YIN_G                                                11//G
N#define YU_YIN_H                                                12//H
N#define YU_YIN_I                                                13//I
N#define YU_YIN_J                                                14//J
N#define YU_YIN_K                                                15//K
N#define YU_YIN_L                                                16//L
N#define YU_YIN_M                                                17//M
N#define YU_YIN_N                                                18//N
N#define YU_YIN_O                                                19//O
N#define YU_YIN_P                                                20//P
N#define YU_YIN_Q                                                21//Q
N#define YU_YIN_R                                                22//R 
N#define YU_YIN_S                                                23//S
N#define YU_YIN_T                                                24//T
N#define YU_YIN_U                                                25//U
N#define YU_YIN_V                                                26//V
N#define YU_YIN_W                                                27//W
N#define YU_YIN_X                                                28//X
N#define YU_YIN_Y                                                29//Y
N#define YU_YIN_Z                                                30//Z
N#define YU_YIN_1                                                31//涓
N#define YU_YIN_2                                                32//浜
N#define YU_YIN_3                                                33//涓
N#define YU_YIN_4                                                34//
N#define YU_YIN_5                                                35//浜
N#define YU_YIN_6                                                36//
N#define YU_YIN_7                                                37//涓
N#define YU_YIN_8                                                38//
N#define YU_YIN_9                                                39//涔
N#define YU_YIN_0                                                40//
N#define YAN_ZHENG_SHI_BAI                                       41//楠璇澶辫触
N#define YI_TUI_CHU_GUAN_LI_MO_SHI                               42//宸查虹＄妯″
N#define QING_SHU_RU_YONG_HU_MI_MA_YI_JING_HAO_JIAN_JIE_SHU      43//璇疯ョㄦ峰浠#烽缁
N#define QING_SHU_RU_LIANG_WEI_BIAN_HAO_YI_JING_HAO_JIAN_JIE_SHU 44//璇疯ヤ袱浣缂蜂互#烽缁
N#define SHU_RU_CUO_WU                                           45//杈ラ璇
N#define MI_MA_GUO_YU_JIAN_DAN                                   46//瀵杩浜绠
N#define SHE_ZHI_SHI_BAI                                         47//璁剧疆澶辫触
N#define QING_CHONG_XIN_SHU_RU                                   48//璇烽拌
N#define QING_NA_KAI_SHOU_ZHI_ZAI_FANG_YI_CI                     49//璇锋垮锛句娆
N#define TIAN_JIA_SHI_BAI                                        50//娣诲澶辫触
N#define TIAN_JIA_CHENG_GONG                                     51//娣诲
N#define FAN_HUI_SHANG_JI_CAI_DAN_QING_AN_XING_HAO_JIAN          52//杩涓绾ц璇锋*烽
N#define SHAN_CHU_SHI_BAI                                        53//ゅけ璐
N#define SHAN_CHU_CHENG_GONG                                     54//ゆ
N#define ZHI_WEN_KU_WEI_KONG                                     55//绾瑰涓虹┖
N#define BIAN_HAO_BU_CUN_ZAI                                     56//缂蜂瀛
N#define QING_JI_SHI_XIU_GAI_GUAN_LI_MI_MA                       57//璇峰朵慨圭＄瀵
N#define YI_JIN_RU_GUAN_LI_MO_SHI                                58//宸茶ョ＄妯″
N#define YONG_HU_SHE_ZHI_QING_AN                                 59//ㄦ疯剧疆璇锋
N#define XI_TONG_SHE_ZHI_QING_AN                                 60//绯荤璁剧疆璇锋
N#define JI_LU_CHA_XUN_QING_AN                                   61//璁板ヨ㈣锋
N#define KUO_ZHAN_GONG_NENG_QING_AN                              62//╁借锋
N#define TIAN_JIA_YONG_HU_MI_MA_QING_AN                          63//娣诲ㄦ峰璇锋
N#define TIAN_JIA_YONG_HU_ZHI_WEN_QING_AN                        64//娣诲ㄦ锋绾硅锋
N#define TIAN_JIA_YONG_HU_KA_PIAN_QING_AN                        65//娣诲ㄦ峰＄璇锋
N#define SHAN_CHU_YONG_HU_KA_PIAN_QING_AN                        66//ょㄦ峰＄璇锋
N#define SHAN_CHU_YONG_HU_MI_MA_QING_AN                          67//ょㄦ峰璇锋
N#define SHAN_CHU_YONG_HU_ZHI_WEN_QING_AN                        68//ょㄦ锋绾硅锋
N#define SHE_ZHI_KAI_MEN_MO_SHI_QING_AN                          69//璁剧疆寮ㄦā寮璇锋
N#define XIU_GAI_GUAN_LI_MI_MA_QING_AN                           70//淇圭＄瀵璇锋
N#define SHI_JIAN_SHE_ZHI_QING_AN                                71//堕磋剧疆璇锋
N#define RI_QI_SHE_ZHI_QING_AN                                   72//ユ璁剧疆璇锋
N#define XI_TONG_CHA_XUN_QING_AN                                 73//绯荤ヨ㈣锋
N#define SHUN_XU_CHA_XUN_QING_AN                                 74//椤哄ヨ㈣锋
N#define BIAN_HAO_CHA_XUN_QING_AN                                75//缂锋ヨ㈣锋
N#define WU_XIAN_MO_KUAI_QING_AN                                 76//绾挎ā璇锋
N#define JIA_RU_WANG_LUO                  					   77//ョ缁璇锋
N#define TUI_CHU_WANG_LUO                                      78//虹缁璇锋
N#define QUAN_BU_SHAN_CHU_QING_AN                                79//ㄩㄥよ锋
N#define DAN_GE_SAHN_CHU_QING_AN                                 80//涓よ锋
N#define CHANG_YONG_MO_SHI_QING_AN                               81//甯哥ㄦā寮璇锋
N#define AN_QUAN_MO_SHI_QING_AN                                  82//瀹ㄦā寮璇锋
N#define YU_YIN_MO_SHI_QING_AN                                   83//璇虫ā寮璇锋
N#define JING_YIN_MO_SHI_QING_AN                                 84//虫ā寮璇锋
N#define YU_YIN_SHE_ZHI_QING_AN                                  85//璇宠剧疆璇锋
N#define YU_YAN_SHE_ZHI_QING_AN                                  86//璇瑷璁剧疆璇锋
N#define ZHONG_WEN_QING_AN                                       87//涓璇锋
N#define YING_WEN_QING_AN                                        88//辨璇锋
N#define YAN_ZHENG_CHENG_GONG_QING_KAI_MEN                        89//楠璇,璇峰
N#define DIAN_LIANG_DI_QING_GENG_HUAN_DIAN_CHI                   90//甸浣璇锋存㈢垫
N#define BIAN_HAO_YI_CUN_ZAI                                     91//缂峰凡瀛
N#define ZHI_WEN_YI_CUN_ZAI                                      92//绾瑰凡瀛
N#define SHE_ZHI_CHENG_GONG                                      93//璁剧疆
N#define XI_TONG_YI_SUO_DING_QING_SHAO_HOU_ZAI_SHI               94//绯荤宸查瀹锛璇风璇
N#define QING_SHU_RU_BIAN_HAO_YI_JING_HAO_JIAN_JIE_SHU           95//璇疯ョ蜂互#烽缁
N#define QING_ZAI_SHU_RU_YI_CI                                   96//璇峰杈ヤ娆
N#define QING_AN_ZHI_WEN                                         97//璇锋绾
N#define WEI_TIAN_JIA_ZHI_WEN                                    98//娣诲绾
N#define WEI_SHE_ZHI_MI_MA                                       99//璁剧疆瀵
N#define QING_TIAN_JIA_GUAN_LI_MI_MA_YI_JING_HAO_JIAN_JIE_SHU    100//璇锋坊绠＄瀵浠#烽缁
N#define WEI_TIAN_JIA_YONG_HU_KA                                 101//娣诲ㄦ峰
N#define QING_SHUA_FANG_WEI_MA                                   102//璇峰烽蹭吉
N#define SHAN_CHU_SHI_BAI_WEI_AN_QUAN_MO_SHI                     103//ゅけ璐ワ涓哄ㄦā寮
N#define YI_HUI_FU_DAO_CHU_CHANG_SHE_ZHI                         104//宸叉㈠板哄璁剧疆
N#define ZHNEG_ZAI_HUI_FU_QING_SHAO_HOU                          105//姝ｅㄦ㈠锛璇风
N#define QING_XIU_GAI_GUAN_LI_MI_MA                              106//璇蜂慨圭＄瀵
N#define QING_AN_YAO_KONG_QI                                     107//璇锋ユу
N#define QING_SHUA_KA                                            108//璇峰峰
N#define QING_SHU_RU_ZHI_WEN_HUO_SHU_RU_LIANG_WEI_BAIN_HAO       109//璇疯ユ绾规杈ヤ袱浣缂凤浠#烽缁
N#define QING_SHUA_KA_HUO_SHU_RU_LIANG_WEI_BAIN_HAO              110//璇峰峰℃杈ヤ袱浣缂凤浠#烽缁
N#define KA_PIAN_KU_WEI_KONG                                     111//＄搴涓虹┖
N#define KA_PIAN_KU_YI_MAN                                       112//＄搴宸叉弧
N#define KA_PIAN_YI_CUN_ZAI                                      113//＄宸插
N#define ZHI_WEN_KU_YI_MAN                                       114//绾瑰宸叉弧
N#define MI_MA_KU_YI_MAN                                         115//瀵搴宸叉弧
N#define MI_MA_KU_WEI_KONG                                       116//瀵搴涓虹┖
N#define FEI_ZHENG_CHANG_KAI_SUO                                 117//姝ｅ父寮
N#define QING_SHUA_KA_HUO_AN_ZHI_WEN                             118//璇峰峰℃绾
N#define QING_SHU_RU_MI_MA_HUO_KA_PIAN                           119//璇疯ュ＄
N#define QING_SHU_RU_MI_MA_HUO_ZHI_WEN                           120//璇疯ュ绾
N
N#define YI_KAI_MEN                                              126//宸插
N#define YI_GUAN_MEN                                             127//宸插抽
N#define YI_QI_DONG_BU_FANG                                      128//宸插ㄥ
N#define YI_FAN_SUO                                              129//宸插
N#define MEN_WEI_SHANG_SUO                                       130//ㄦ涓
N#define PEI_WANG_ZHONG_QING_SHAO_HOU                            131//缃涓璇风
N#define TUI_WANG_ZHONG_QING_SHAO_HOU                            132//缃涓璇风
N#define YU_YIN_MO_SHI                                           133//璇虫ā寮
N#define JING_YIN_MO_SHI                                         134//虫ā寮
N#define GAO_YIN_LIANG_MO_SHI                                    135//楂抽妯″
N#define DI_YIN_LIANG_MO_SHI                                     136//浣抽妯″
N#define SUO_TI_YI_CHANG                                         137//浣寮甯
N#define YI_RU_WANG                                              138//宸插ョ
N#define HUAN_YING_HUI_JIA                                       139//娆㈣瀹
N#define ZI_DONG_MO_SHI                                          143//ㄦā寮
N#define SHOU_DONG_MO_SHI                                        144//ㄦā寮
N
N#define KAI_QI_LAN_YA_QING_AN                                   145//寮璇锋
N#define GUAN_BI_LAN_YA_QING_AN                                  146//抽璇锋
N#define LIAN_JIE_LAN_YA_QING_AN                                 147//杩ヨ璇锋
N#define DUAN_KAI_LAN_YA_QING_AN                                 148//寮璇锋
N#define LAN_YA_YI_KAI_QI                                        149//宸插
N#define LAN_YA_YI_GUAN_BI                                       150//宸插抽
N#define LAN_YA_YI_LIAN_JIE                                      151//宸茶
N#define LAN_YA_SHE_ZHI_QING_AN                                  152//璁剧疆璇锋
N
N#define QING_XIANG_ZUO_WEI_WEI_YI_DONG_SHOU_ZHI               	153//璇峰宸寰寰绉诲ㄦ
N#define QING_XIANG_YOU_WEI_WEI_YI_DONG_SHOU_ZHI            		154//璇峰冲井寰绉诲ㄦ
N#define QING_XIANG_SHANG_WEI_WEI_YI_DONG_SHOU_ZHI         		155//璇峰涓寰寰绉诲ㄦ
N#define QING_XIANG_XAI_WEI_WEI_YI_DONG_SHOU_ZHI         		156//璇峰涓寰寰绉诲ㄦ
N
N#define QING_SHU_RU_GUAN_LI_MI_MA_YI_JING_HAO_JINA_JIE_SHU      157//璇疯ョ＄瀵锛浜烽
N#define YI_JING_HAO_JINA_JIE_SHU         		                158//宸#峰缓缁
N
N#define  SHU_RU_CHENG_GONG        								159//杈ユ
N#define QING_SHU_RU_GUAN_LI_MA_MA       						160//璇疯ョ＄瀵
N
N#define QING_SHU_RU_6_12WEI_XIN_MI_MA       					161//璇疯6-12浣板  0806
N#define TIAN_JIA_YAO_KONG_QING_AN                               162//娣诲ユц锋
N#define SHAN_CHU_YAO_KONG_QING_AN                               163//らユц锋
N#define MI_MA_YI_CUN_ZAI       				        			164//瀵宸插 0806
N#define LIANG_CI_SHU_RU_DE_MA_MA_BU_YI_ZHI 						165//涓ゆ¤ョ瀵涓涓
N    
N#define VOICE_ST_BUSY                                              -1
N#define VOICE_ST_IDLE                                              0
N   
Nextern int8_t Voice_init(void);
Nextern void Voice_play(uint16_t val);
Nextern int8_t Voice_Status(void);
N
N#endif    
N/* [] END OF FILE */
L 31 ".\main.h" 2
N#include "Card.h"
L 1 ".\Modules\Card\Card.h" 1
N/* ========================================
N *
N * Copyright YOUR COMPANY, THE YEAR
N * All Rights Reserved
N * UNPUBLISHED, LICENSED SOFTWARE.
N *
N * CONFIDENTIAL AND PROPRIETARY INFORMATION
N * WHICH IS THE PROPERTY OF your company.
N *
N * ========================================
N*/
N#ifndef _CARD_H
N#define _CARD_H
N    
N#include "main.h"
N#include "nxp520.h"
L 1 ".\Modules\Card\nxp520.h" 1
N#ifndef __NXP520_H__
N#define __NXP520_H__
N//绛寰PICC杩寰浣娉㈠舰稿
N#define TOLERANT_WAIT_LOOP       35
N
N//澶╃嚎璁剧疆 澶╃嚎 1锛2 锛澶╃嚎
N#define ANT_CONFIG             ANT_TXD
N
N#define ANT_TX1                  1
N#define ANT_TX2                  2
N#define ANT_TXD                  3 //澶╃嚎
N
N/***************MF520戒护瀛****************/
N#define PCD_IDLE              0x00//娑褰戒护
N#define PCD_MEM               0x01//ㄥ25瀛版板BUFF 
N#define PCD_CALCCRC           0x03//CRC璁＄
N#define PCD_TRANSMIT          0x04//版
N#define PCD_NOCMDCHANGE       0x07//璁剧疆CommandReg 涓瑰㈢Command 
N
N#define PCD_RECEIVE           0x08//ユ舵版
N#define PCD_TRANSCEIVE        0x0C//骞舵ユ舵版
N#define PCD_AUTHENT           0x0E//楠璇瀵
N#define PCD_RESETPHASE        0x0F//澶浣
N/**********Mifare_One＄戒护瀛************/
N#define PICC_REQIDL           0x26//瀵诲ぉ绾垮哄杩ヤ舵
N#define PICC_REQALL           0x52//瀵诲ぉ绾垮哄ㄩㄥ
N#define PICC_ANTICOLL1        0x93//插叉
N#define PICC_ANTICOLL2        0x95//插叉
N#define PICC_ANTICOLL3        0x97//插叉3
N#define PICC_AUTHENT1A        0x60//楠璇A瀵
N#define PICC_AUTHENT1B        0x61//楠璇B瀵
N#define PICC_READ             0x30//璇诲
N#define PICC_WRITE            0xA0//
N#define PICC_DECREMENT        0xC0//ｆ
N#define PICC_INCREMENT        0xC1//
N#define PICC_RESTORE          0xC2//璋版扮插
N#define PICC_TRANSFER         0xB0//淇瀛缂插轰腑版
N#define PICC_HALT             0x50//浼
N
N/**************MFRC520瀵瀛ㄥ涔**************/
N// Page 0 :  у跺舵   
N#define     RFU00                 0x00     //淇
N#define     CommandReg            0x01     //ㄥ姝㈡浠
N#define     ComIEnReg             0x02     //浣胯藉绂ㄤ腑璇锋
N#define     DivlEnReg             0x03     //浣胯藉绂ㄤ腑璇锋
N#define     ComIrqReg             0x04     //涓璇锋
N#define     DivIrqReg             0x05     //涓璇锋
N#define     ErrorReg              0x06     //剧ず涓涓涓浠ゆц璇舵
N#define     Status1Reg            0x07     //淇＄舵
N#define     Status2Reg            0x08     //ユ跺舵
N#define     FIFODataReg           0x09     //64 瀛 FIFO 缂插虹杈ュ杈
N#define     FIFOLevelReg          0x0A     //FIFO 缂插轰腑宸插ㄥ伴
N#define     WaterLevelReg         0x0B     //FIFO 缂插烘孩哄绌鸿
N#define     ControlReg            0x0C     //澶绉у跺瀛
N#define     BitFramingReg         0x0D     //㈠浣甯х璋
N#define     CollReg               0x0E     //妫ヤ骇浣茬绗涓涓浣板
N#define     RFU0F                 0x0F     //淇
N//PAGE 1 : 淇
N#define     RFU10                 0x10     //淇
N#define     ModeReg               0x11     //ユ剁ㄦā寮璁剧疆
N#define     TxModeReg             0x12     //版剁浼杈
N#define     RxModeReg             0x13     //版ユ舵剁浼杈
N#define     TxControlReg          0x14     //澶╃嚎椹卞ㄥㄥ TX1  TX2 у
N#define     TxASKReg              0x15     //璋剁璁剧疆
N#define     TxSelReg              0x16     //╁ぉ绾块┍ㄧㄤ俊锋
N#define     RxSelReg              0x17     //ㄦユ跺ㄧ璁剧疆
N#define     RxThresholdReg        0x18     //浣瑙ｇㄩ肩
N#define     DemodReg              0x19     //瑙ｈㄧ璁剧疆
N#define     RFU1A                 0x1A     //淇
N#define     RFU1B                 0x1B     //淇
N#define     MfTxReg               0x1C     //MIFARE 淇℃跺扮璁剧疆
N#define     MfRxReg               0x1D     //MIFARE 淇℃舵ユ跺扮璁剧疆
N#define     RFU1E                 0x1E     //淇
N#define     RFU1F                 0x1F     //淇
N//Page 2 : 缃
N#define     RFU20                 0x20     //淇
N#define     CRCResultRegM         0x21     //CRC 璁＄ MSB 浣
N#define     CRCResultRegL         0x22     //CRC 璁＄ LSB 浣
N#define     RFU23                 0x23     //淇
N#define     ModWidthReg           0x24     //璋跺藉害璁剧疆
N#define     RFU25                 0x25     //淇
N#define     RFCfgReg              0x26     //ユ跺缃
N#define     GsNReg                0x27     //╁ぉ绾块┍ㄥㄥ TX1  TX2 ㄨ舵剁靛煎
N#define     CWGsCfgReg            0x28     //瀹涔p-driver璋剁杈虹靛
N#define     ModGsCfgReg           0x29     //瀹涔p-driver缁杩璋剁杈虹靛
N#define     TModeReg              0x2A     //瀹涔瀹跺ㄧ璁剧疆涓 Tprescaler 璁剧疆楂 4 浣
N#define     TPrescalerReg         0x2B     //TprescalerReg 瀵瀛ㄨ剧疆浣 8 浣
N#define     TReloadRegH           0x2C     //16 浣瀹跺ㄧ杞藉奸8浣
N#define     TReloadRegL           0x2D     //16 浣瀹跺ㄧ杞藉间8浣
N#define     TCounterValueRegH     0x2E     //剧ず 16 瀹跺ㄧ褰奸8浣
N#define     TCounterValueRegL     0x2F     //剧ず 16 瀹跺ㄧ褰间8浣
N//Page 3: 娴璇
N#define     RFU30                 0x30     //淇
N#define     TestSel1Reg           0x31     //娴璇淇″风缃
N#define     TestSel2Reg           0x32     //娴璇淇″风缃PRBS у
N#define     TestPinEnReg          0x33     //浣胯D1D7 杈洪┍ㄥ
N#define     TestPinValueReg       0x34     //瀹涔寮 DI  D7 褰剁ㄤ I/O ｆ剁靛钩
N#define     TestBusReg            0x35     //剧ずㄦ璇荤嚎舵
N#define     AutoTestReg           0x36     //板妫у
N#define     VersionReg            0x37     //剧ず杞浠剁
N#define     AnalogTestReg         0x38     //寮AUX1AUX2 у
N#define     TestDAC1Reg           0x39     //瀹涔TestDAC1 娴璇
N#define     TestDAC2Reg           0x3A     //瀹涔TestDAC2 娴璇
N#define     TestADCReg            0x3B     //剧ず ADC I  Q 
N#define     RFU3C                 0x3C     //淇
N#define     RFU3D                 0x3D     //淇
N#define     RFU3E                 0x3E     //淇
N#define     RFU3F		          0x3F     //淇
N
N/************MF522璁惰璇浠ｇ*********/
N#define MI_OK                     0
N#define MI_NOTAGERR              (-1)
N#define MI_ERR                   (-2)
N#define MI_COLLERR                3
N#define MI_CT					  1				     // CASCADE TAG
N#define DEF_FIFO_LENGTH           64                 //FIFO size=64byte
N#define MAXRLEN                   18
N
Nsigned char Nxp520_Reset(void);
Nextern void Nxp520_Init(void);
Nvoid Nxp520_Antenna_On( void );
Nunsigned char Nxp520_ReadCardId(unsigned short *pType);
Nvoid Nxp520_Antenna_Off( void );
Nsigned char Nxp520_Request(unsigned char req_code, unsigned char *pTagType);
Nsigned char Nxp520_Anticoll(unsigned char *pSnr);
Nsigned char Nxp520_Select(unsigned char *pSnr);
Nsigned char Nxp520_Auth_State(unsigned char auth_mode, unsigned char addr, unsigned char *pKey, unsigned char *pSnr);
Nsigned char Nxp520_write(unsigned char addr, unsigned char *pData);
Nsigned char Nxp520_Read(unsigned char addr, unsigned char *pData);
Nsigned char Nxp520_Halt(void);
Nsigned char Lowpower_Request(unsigned char req_code, unsigned char *pTagType);
Nsigned char Lowpower_ReadCardrequest(unsigned char req_code, unsigned char *pTagType);
Nvoid Ad_Nxp520_Antenna_Off( void );
Nchar UL_PcdAnticoll( unsigned char *pSnr, unsigned char *cardlen);
Nsigned char nxp520ConfigISOType(unsigned char type);
Nextern void Nxp520_Reset_Wait(void);
N
N#endif
L 17 ".\Modules\Card\Card.h" 2
N    
Ntypedef struct{
N    uint8_t ID[4];
N    bool CardAct;
X    _Bool CardAct;
N    uint16_t adc;
N    uint16_t Evr;
N}Card_t;
N
N/*******************澶ㄥ芥板０*****************/    
Nvoid Card_Init(void);
Nint8_t Card_ReadId(uint8_t *pTemp);
Nbool Sleep_SearchCard(void);
X_Bool Sleep_SearchCard(void);
NCard_t *Card_Status(void);
N#endif
N
N/* [] END OF FILE */
L 32 ".\main.h" 2
N#include "Fingerprint.h"
L 1 ".\Modules\Fingerprint\Fingerprint.h" 1
N/* ========================================
N *
N * Copyright YOUR COMPANY, THE YEAR
N * All Rights Reserved
N * UNPUBLISHED, LICENSED SOFTWARE.
N *
N * CONFIDENTIAL AND PROPRIETARY INFORMATION
N * WHICH IS THE PROPERTY OF your company.
N *
N * ========================================
N*/
N#ifndef _FINGERPRINT_H
N#define _FINGERPRINT_H
N
N#include "main.h"  
N
N#define REG_NUM 	8
N#define REG_LOGIC	1
N
Ntypedef enum{
N    F_NULL,
N    GET_ING,
N	GET_OK,
N	GET_FAIL,
N	GENCHAR_OK,
N	SEARCH_OK,
N	REGMODEL_OK,
N	STORE_OK,
N    SLEEP_OK,
N    EMPTY_OK,
N    EMPTY_FAIL,
N	CMD_FAIL,
N    SEARCH_FAIL,
N    STORE_FAIL,
N	GENCHAR_SAME,
N    WAIT_ISR,
N}CmdEven_t;
Ntypedef struct{
N    uint8_t step;
N    uint8_t BID;
N	uint16_t PID;
N	CmdEven_t NormalEven;
N	CmdEven_t RegEven;
N    bool PowerStaus;
X    _Bool PowerStaus;
N	bool SensorIsr;
X	_Bool SensorIsr;
N}Fingerprint_t;
N
Nextern int8_t Fingerprint_init(void);
Nextern void Fingerprint_Sleep(void);
Nextern void Fingerprint_Power(bool option);
Xextern void Fingerprint_Power(_Bool option);
Nextern Fingerprint_t *Fingerprint_status(void);
Nextern int8_t Fingerprint_NormalProcess(void);
Nextern int8_t Fingerprint_RegProcess(void);
Nextern int8_t Fingerprint_RegDelProcess(uint8_t pid,bool all);          //all涓true跺ㄦ绌 false舵pid
Xextern int8_t Fingerprint_RegDelProcess(uint8_t pid,_Bool all);          
N
N#endif
N
N/* [] END OF FILE */
L 33 ".\main.h" 2
N#include "Bat.h"
L 1 ".\Modules\Bat\Bat.h" 1
N/* ========================================
N *
N * Copyright YOUR COMPANY, THE YEAR
N * All Rights Reserved
N * UNPUBLISHED, LICENSED SOFTWARE.
N *
N * CONFIDENTIAL AND PROPRIETARY INFORMATION
N * WHICH IS THE PROPERTY OF your company.
N *
N * ========================================
N*/
N#ifndef _BAT_H
N#define _BAT_H
N    
N#include "main.h"
N    
W ".\Modules\Bat\Bat.h" 17 6 Deprecated declaration Bat_Init - give arg types
Nvoid Bat_Init();
N    
W ".\Modules\Bat\Bat.h" 19 9 Deprecated declaration Bat_Numeric - give arg types
Nuint8_t Bat_Numeric();//甸惧姣 0-100
N
N#endif
N
N/* [] END OF FILE */
L 34 ".\main.h" 2
N#include "Power.h"
L 1 ".\Modules\Power\Power.h" 1
N#ifndef _POWER_H
N#define _POWER_H
N#include "main.h"
N
N//#define FL3235_IIC_ADDRESS  	0x78//AD  GND
N#define ON 						    0x01			//宸ヤ妯″杞浠跺
N#define OFF 						0x00			//宸ヤ妯″杞浠跺
N#define I_MAX_1_1					0x00
N#define I_MAX_1_2					0x02
N#define I_MAX_1_3					0x04
N#define I_MAX_1_4					0x06
N
N#define FL3235_REG_SHUTDOWN		    0x00 		//虫瀵瀛
N#define FL3235_REG_PWM_OUT1 	    0x05		//杈PWM瀵瀛
N#define FL3235_REG_PWM_OUT2 	    0x06
N#define FL3235_REG_PWM_OUT3 	    0x07
N#define FL3235_REG_PWM_OUT4 	    0x08
N#define FL3235_REG_PWM_OUT5 	    0x09
N#define FL3235_REG_PWM_OUT6 	    0x0A
N#define FL3235_REG_PWM_OUT7 	    0x0B
N#define FL3235_REG_PWM_OUT8 	    0x0C
N#define FL3235_REG_PWM_OUT9 	    0x0D
N#define FL3235_REG_PWM_OUT10 	    0x0E
N#define FL3235_REG_PWM_OUT11 	    0x0F
N#define FL3235_REG_PWM_OUT12 	    0x10
N#define FL3235_REG_PWM_OUT13 	    0x11
N#define FL3235_REG_PWM_OUT14 	    0x12
N#define FL3235_REG_PWM_OUT15 	    0x13
N#define FL3235_REG_PWM_OUT16 	    0x14
N#define FL3235_REG_PWM_OUT17 	    0x15
N#define FL3235_REG_PWM_OUT18 	    0x16
N#define FL3235_REG_PWM_OUT19 	    0x17
N#define FL3235_REG_PWM_OUT20 	    0x18
N#define FL3235_REG_PWM_OUT21 	    0x19
N#define FL3235_REG_PWM_OUT22 	    0x1A
N#define FL3235_REG_PWM_OUT23 	    0x1B
N#define FL3235_REG_PWM_OUT24 	    0x1C
N#define FL3235_REG_PWM_OUT25 	    0x1D
N#define FL3235_REG_PWM_OUT26 	    0x1E
N#define FL3235_REG_PWM_OUT27 	    0x1F
N#define FL3235_REG_PWM_OUT28 	    0x20
N#define	FL3235_REG_DATA_UPDATE	    0x25 	//PWMLEDу舵存板瀛
N#define FL3235_REG_CTRL_OUT1 		0x2A	//LEDу跺瀛
N#define FL3235_REG_CTRL_OUT2 		0x2B
N#define FL3235_REG_CTRL_OUT3 		0x2C
N#define FL3235_REG_CTRL_OUT4 		0x2D
N#define FL3235_REG_CTRL_OUT5 		0x2E
N#define FL3235_REG_CTRL_OUT6 		0x2F
N#define FL3235_REG_CTRL_OUT7 		0x30
N#define FL3235_REG_CTRL_OUT8 		0x31
N#define FL3235_REG_CTRL_OUT9 		0x32
N#define FL3235_REG_CTRL_OUT10 	    0x33
N#define FL3235_REG_CTRL_OUT11 	    0x34
N#define FL3235_REG_CTRL_OUT12 	    0x35
N#define FL3235_REG_CTRL_OUT13 	    0x36
N#define FL3235_REG_CTRL_OUT14 	    0x37
N#define FL3235_REG_CTRL_OUT15 	    0x38
N#define FL3235_REG_CTRL_OUT16 	    0x39
N#define FL3235_REG_CTRL_OUT17 	    0x3A
N#define FL3235_REG_CTRL_OUT18 	    0x3B
N#define FL3235_REG_CTRL_OUT19 	    0x3C
N#define FL3235_REG_CTRL_OUT20 	    0x3D
N#define FL3235_REG_CTRL_OUT21 	    0x3E
N#define FL3235_REG_CTRL_OUT22 	    0x3F
N#define FL3235_REG_CTRL_OUT23 	    0x40
N#define FL3235_REG_CTRL_OUT24 	    0x41
N#define FL3235_REG_CTRL_OUT25 	    0x42
N#define FL3235_REG_CTRL_OUT26 	    0x43
N#define FL3235_REG_CTRL_OUT27 	    0x44
N#define FL3235_REG_CTRL_OUT28 	    0x45
N#define FL3235_REG_LED_GLOBAL_CTRL  0x4A //ㄩ寮
N#define FL3235_REG_LED_FRE 			0x4B //杈洪瀵瀛
N#define FL3235_REG_RST 			    0x4F //澶浣瀵瀛
N
N/********************************************************/
N#define	SN_SDB_PIN_High()	I2C_ST_Write(1)     //chip shut down绾胯洪.
N#define	SN_SDB_PIN_Low()	I2C_ST_Write(0)     //chip shut down绾胯轰.
N    
Nbool I2C_WriteReg(uint8_t reg_address, uint8_t reg_data);
X_Bool I2C_WriteReg(uint8_t reg_address, uint8_t reg_data);
Nbool I2C_WriteRegSeries(uint8_t reg_address, uint8_t reg_data,uint8_t unit);
X_Bool I2C_WriteRegSeries(uint8_t reg_address, uint8_t reg_data,uint8_t unit);
Nbool I2C_WriteRegTab(uint8_t reg_address, uint8_t *tab,uint8_t unit);
X_Bool I2C_WriteRegTab(uint8_t reg_address, uint8_t *tab,uint8_t unit);
W ".\Modules\Power\Power.h" 82 6 Deprecated declaration FL3225_Init - give arg types
Nvoid FL3225_Init();
Nvoid FL3225_DataUpdate(void);
Nvoid OLED_FLASH_POWER(uint8_t onoff);//OLED垫寮
Nvoid VOICE_POWER(uint8_t onoff);//璇崇垫寮
Nvoid BLE_POWER(uint8_t onoff);//垫寮
Nvoid FPC_POWER(uint8_t onoff);//绾圭垫寮
Nvoid LOCK_POWER(uint8_t onoff);//浣垫寮
W ".\Modules\Power\Power.h" 89 7 last line of file ends without a newline
N#endif
L 35 ".\main.h" 2
N#include "Led.h"
L 1 ".\Modules\Led\Led.h" 1
N#ifndef __LED_H
N#define __LED_H
N    
N#include "main.h"
N
Ntypedef enum
N{
N    IDEL=0,
N    ALL_ON,                         //全部LED打开
N    ALL_OFF,                        //全部LED关闭
N    TUCH,                           //触摸
N    XXX,                            //播放XXX图案
N    XXX_F,                          //带呼吸播放XXX图案
N    UPDOWN,                         //播放上下图案
N    UPDOWN_F,                       //带呼吸播放上下图案                    
N}Led_e;
Ntypedef struct 
N{
N    uint8_t Ia;                     //LED的全局最大电流控制
N    uint8_t Luma;                   //LED的全局亮度控制
N    Led_e Status; 
N    uint8_t Num;                    //键对应LED
N}Led_t;
N
Nextern uint8_t Led_Init(void);      //初始化
Nextern Led_t *Led_Status(void);     //状态接口
Nextern void Led_Play(Led_e m);      //可中断调用
Nextern void Led_Process(void);      //TIME_BASIC_MS 调用
N
Nextern void LED_switch(uint8_t num,uint8_t sta);  
N#define LED_FRONT_LOCK(x)           LED_switch(12,x)//前面板 左下角，锁上
N#define LED_FRONT_BAT(x)            LED_switch(13,x)//前面板 右下角，电量低符号
N#define LED_FRONT_OPEN(x)           LED_switch(14,x)//前面板 右上角 OPEN
N#define LED_FRONT_CLOSE(x)          LED_switch(15,x)//前面板 左上角 CLOSE
N#define LED_BACK_OPEN(x)            LED_switch(16,x)//后面板绿OPEN    
N#define LED_BACK_CLOSE(x)           LED_switch(17,x)//后面板红CLOSE
N
N#endif
L 36 ".\main.h" 2
N#include "SwitchKey.h"
L 1 ".\Modules\SwitchKey\SwitchKey.h" 1
N/* ========================================
N *
N * Copyright YOUR COMPANY, THE YEAR
N * All Rights Reserved
N * UNPUBLISHED, LICENSED SOFTWARE.
N *
N * CONFIDENTIAL AND PROPRIETARY INFORMATION
N * WHICH IS THE PROPERTY OF your company.
N *
N * ========================================
N*/
N#ifndef _SWITCHKEY_H
N#define _SWITCHKEY_H
N
N#include "main.h"
N
N#define COVER_OPEN    1
N#define COVER_CLOSE   2    
N#define AUTO_MODE     1
N#define MANUAL_MODE   2
N    
Ntypedef struct{
N	uint8_t DoorOneKey;
N	uint8_t ResetKeyVal;
N    bool ModeSwAct;
X    _Bool ModeSwAct;
N    uint8_t ModeSwStatus;
N    bool ConverAct;
X    _Bool ConverAct;
N    uint8_t ConverStatus;
N}SwitchKey_t;
N
Nenum
N{
N	LOCK_BNT_KEY       = 12,//涓寮抽ㄩ
N	LOCK_MODE_KEY      = 13,//ㄦā寮
N	SLOT_KEY           = 14,//浣
N	RESET_KEY          = 15,//澶浣
N};
N
Nextern void SwitchKey_init(void);
Nextern SwitchKey_t *SwitchKey_Status(void);
Nextern uint8_t SwitchKey_Scan(void);
Nextern uint8_t SwitchKey_Cover_Scan(void);
Nextern uint8_t SwitchKey_Slot_Scan(void);
Nextern uint8_t SwitchKey_Mode_Scan(void);
N
N
N#endif
N
N/* [] END OF FILE */
L 37 ".\main.h" 2
N#include "Lock.h"
L 1 ".\Modules\Lock\Lock.h" 1
N/**
N  ******************************************************************************
N  * @file         lock.h
N  * @brief        涓lock.c瀵瑰澶存浠
N  * @author       Fli
N  * @date         2018-06-22
N  * @version      v001
N  * @copyright    kaadas
N  * 
N  * @note         杩浠路鸿介
N  *
N  ******************************************************************************
N  */
N#ifndef __LOCK_H__
N#define __LOCK_H__
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#include "main.h"
N#include "lock_hal.h"
L 1 ".\Modules\Lock\lock_hal.h" 1
N/**
N  ******************************************************************************
N  * @file         lock_hal.h
N  * @brief        与lock_hal.c对应的头文件
N  * @author       Fli
N  * @date         2018-06-21
N  * @version      v001
N  * @copyright    kaadas
N  *
N  * @note         凯迪仕・智能锁
N  *
N  ******************************************************************************
N  */
N#ifndef __LOCK_HAL_H__
N#define __LOCK_HAL_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "main.h"
N
N	/* 电机控制参数 */
N#define MOTOR_MAX_LOCKED_TIMES           3    //最大上锁次数（上锁失败后，会自动重复上锁）
N#define MOTOR_MAX_ADC_VALUE              238  //电机堵转限制电流280mA 采样电阻0.5Ω 
N#define MOTOR_LOCKED_MORE_TIME           50   //上锁过推时间Ms
N#define MOTOR_ABNORMAL_REVERSE_GAP_TIME  100  //电机异常时，反转空隙时间Ms
N#define MOTOR_REVERSE_GAP_TIME           1000 //电机正常时，反转空隙时间Ms
N#define MOTOR_RUNNING_TIMEOUT            2000 //电机正常运行，超时时间Ms
N#define MOTOR_BACK_TIMEOUT               1000 //电机回拖运行，超时时间Ms
N#define MOTOR_ADC_DETECT_DELAY_TIME      100   //电机启动后，ADC检测延迟时间Ms
N#define MOTOR_BRAKE_TIME                 30   //电机刹车时间Ms
N
N
N	/* 锁体底层驱动产生的事件 */
N#define LOCK_EVT_LOCK_CHANGE     0X01 //锁状态改变
N#define LOCK_EVT_DOOR_CHANGE     0X02 //门状态改变
N#define LOCK_EVT_LOCKED_ABNORMAL 0X04 //上锁发生异常
N#define LOCK_EVT_UNLOCK_ABNORMAL 0X08 //开锁发生异常
N
N	/* 锁状态 */
N#define	LOCK_STATUS_LOCKING        0X01 //正在上锁
N#define	LOCK_STATUS_LOCKED         0X02 //已上锁
N#define	LOCK_STATUS_UNLOCKING      0X04 //正在开锁
N#define	LOCK_STATUS_UNLOCK         0X08 //已开锁
N#define	LOCK_STATUS_UNKNOWN        0X10 //锁状态未知
N#define	LOCK_STATUS_LOCKED_MECH    0X20 //已上锁（机械方式）
N#define	LOCK_STATUS_UNLOCK_MECH    0X40 //已开锁（机械方式）
N
N	/* 门状态 */
N#define DOOR_STATUS_OPENED       0X01//门已打开
N#define DOOR_STATUS_CLOSED       0X02//门已关闭
N#define DOOR_STATUS_CLOSED_LONG  0X04//门已长时间关闭（1.5s）
N#define DOOR_STATUS_ABNORMAL     0X08//门状态异常--被撬开
N
N	/* 异常状态 */
N#define ABNORMAL_STA_TIMEOUT     0X01//锁体异常：超时
N#define ABNORMAL_STA_AWD         0X02//锁体异常：过流（模拟看门狗）
N#define ABNORMAL_STA_DOOR_OPEN   0X04//锁体异常：上锁过程中门开了
N
N
N/* 回到函数类型 */
Ntypedef void (*LockHalCallBackFunction)(uint8_t event, uint8_t param);
N
N
NErrorStatus LockHal_Init(LockHalCallBackFunction cb);
NErrorStatus LockHal_Unlock(void);
NErrorStatus LockHal_UnlockBack(void);
NErrorStatus LockHal_Locked(void);
Nvoid LockHal_Scan(void);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__LOCK_HAL_H__ */
L 23 ".\Modules\Lock\Lock.h" 2
N
N#define LOCK_DEBUG_EN   (0)
N#define DEBUG_EN        (0)
N
N#if (LOCK_DEBUG_EN && DEBUG_EN)
X#if ((0) && (0))
S#define LOCK_LOG(format, ...) printf("[File: "__FILE__"   Line:%05d]  "format"\r\n", __LINE__, ##__VA_ARGS__)  
N#else
N#define LOCK_LOG(format, ...)
N#endif
N
N
N/* 浣舵 */
N#define LOCK_MSG_LOCKED_OK      1//涓 /*lock_status涓舵*/
N#define LOCK_MSG_LOCKED_ERR     3//涓澶辫触
N
N#define LOCK_MSG_UNLOCK_OK      2//寮 /*unlock_status寮舵*/
N#define LOCK_MSG_UNLOCK_ERR     4//寮澶辫触
N
N#define LOCK_MSG_ANTI_LOCK_ON   5//ㄥ /*anti_lock_statusㄥ抽*/
N#define LOCK_MSG_ANTI_LOCK_OFF  6//抽
N
N#define LOCK_MSG_INPUT_ON       7//浣胯界ㄦ疯 /*input_status绂姝浣胯界ㄦ疯*/
N#define LOCK_MSG_INPUT_OFF      8//绂姝㈢ㄦ疯
N
N#define LOCK_MSG_NOT_LOCKED     9//ㄦ涓 /*locking_statusㄩ舵*/
N#define LOCK_MSG_TAMPER         10//ㄩ琚
N#define LOCK_MSG_UNKNOWN_MECH   11//舵ワ烘版瑰浣锛
N
N#define LOCK_MSG_OPEN_DOOR      12//ㄥ凡寮 /*door_statusㄥ崇舵*/
N#define LOCK_MSG_CLOSE_DOOR     13//ㄥ凡抽
N
N/* 寮抽 */
N#define LOCK_PARAM_CLOSE        1//浣跨CLOSE 寮抽 /*lock_parameter寮抽*/
N#define LOCK_PARAM_KEYS         2//浣跨ㄥ 寮抽
N#define LOCK_PARAM_AUTO         3// 寮抽
N#define LOCK_PARAM_MECHANICAL   4//烘版瑰 寮抽
N#define LOCK_PARAM_APP          5//APP瑰寮
N
N/* 浣缁涓讳换＄娑缁 */
N//typedef struct
N//{
N//	MsgType_enum_t type;  //娑绫诲
N//	uint8_t msg;          //娑
N//	uint8_t param;        //
N//}LockMsg_stu_t;
N
N/* 浣宸ヤ妯″ */
Ntypedef enum
N{
N	LOCK_MODE_AUTO,
N	LOCK_MODE_MANUAL,
N}LockMode_enum_t; /*lock_workmode; //浣宸ヤ妯″*/
N
Ntypedef struct
N{
N    uint8_t status;
N    uint8_t param;
N}Msg_t;
N
Ntypedef struct
N{
N    Msg_t locked;//涓舵
N    Msg_t unlock;//寮舵
N    Msg_t anti_lock;//ㄥ抽
N    Msg_t input;//绂姝浣胯界ㄦ疯
N    Msg_t locking;//ㄩ舵
N    Msg_t door;//ㄥ崇舵
N      
N    LockMode_enum_t lock_workmode; //浣宸ヤ妯″      
N    
N}LockStatus_t,*pLockStatus_t;
N
Nvoid Lock_Init(uint8_t opt);
Nvoid Lock_Task(void);
Nvoid Lock_SetMode(LockMode_enum_t mode);
Nvoid Lock_ProcessVerifySuceed(void);
Nvoid Lock_ProcessCloseKey(uint8_t action);
Nvoid Lock_ProcessAppOpenAndClose(uint8_t opt);
Nvoid Lock_SleepAutoLocked(void);
NpLockStatus_t Lock_Status(void);//舵
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__LOCK_H__ */
L 38 ".\main.h" 2
N#include "Wdt.h"
L 1 ".\Modules\Wdt\Wdt.h" 1
N/* ========================================
N *
N * Copyright YOUR COMPANY, THE YEAR
N * All Rights Reserved
N * UNPUBLISHED, LICENSED SOFTWARE.
N *
N * CONFIDENTIAL AND PROPRIETARY INFORMATION
N * WHICH IS THE PROPERTY OF your company.
N *
N * ========================================
N*/
N#ifndef _WDT_H
N#define _WDT_H
N    
N#include "main.h"
N    
Ntypedef struct{
N    bool clear;
X    _Bool clear;
N    bool Isr;
X    _Bool Isr;
N}Wdt_t;
N    
Nextern void WDT_Init(void);
Nextern void Wdt_Feed_Dog(void);
Nextern Wdt_t *WDT_Status(void);
N
N#endif
N
N/* [] END OF FILE */
L 39 ".\main.h" 2
N#include "Record.h"
L 1 ".\Modules\Record\Record.h" 1
N/* ========================================
N *
N * Copyright YOUR COMPANY, THE YEAR
N * All Rights Reserved
N * UNPUBLISHED, LICENSED SOFTWARE.
N *
N * CONFIDENTIAL AND PROPRIETARY INFORMATION
N * WHICH IS THE PROPERTY OF your company.
N *
N * ========================================
N*/
N#ifndef _RECORD_H
N#define _RECORD_H
N#include "main.h"    
N    
N#define EEPROM_BASE_ADD  0x1B000                                    //Flash瀛ㄥ板  х嚎            
N    
Ntypedef struct
N{
N    uint8_t Attr;
N    uint8_t ID;
N	uint8_t UPSW[16];
N}UserPswRecord_t;
Ntypedef struct
N{
N    uint8_t Attr;
N    uint8_t ID;
N	uint8_t CID[4];
N}CardRecord_t;
Ntypedef struct
N{
N    uint8_t Attr;
N    uint8_t ID;
N	uint16_t FID;
N}FigRecord_t;
N
Ntypedef enum
N{
N    C_PSW=1,
N    C_FIG=2,
N    C_CARD=3,
N    C_BLE=4,
N}OpenDoorClass_t;
Ntypedef struct
N{
N    uint16_t year;  
N    uint8_t month;      
N    uint8_t day;        
N    uint8_t hour;   
N    uint8_t minute;     
N    uint8_t second;     
N}RtcRecord_t;
Ntypedef struct
N{
N    OpenDoorClass_t Class;                                          //寮ㄧ被 绾广＄瀵
N    uint8_t ID;                                                     //寮ID
N    uint8_t Para[4];                                                // 姣濡＄4ID
N    uint8_t loop;                                                   //宸茶板婊″濮寰璁板
N	RtcRecord_t Time;                                               //寮ㄦ堕
N}DoordRecord_t;
N
Ntypedef struct
N{
N    uint8_t Voice;                                                  //璇
N    uint8_t Language;                                               //璇瑷
N    uint8_t OpenDoorMode;                                           //寮ㄦā寮
N}OptionRecord_t;
N
N
N#define LEN_SN                      17
N#define LEN_MANAGE_PSW_RECORD       12                              //绠＄瀵垮害
N#define LEN_USER_PSW_RECORD         10                              //ㄦ峰缁
N#define LEN_CRAD_RECORD             100                             //＄缁
N#define LEN_FIG_RECORD              100                             //绾圭
N#define LEN_DOOR_RECORD             200                             //寮ㄨ板缁
Ntypedef struct
N{ 
N    uint8_t SysSN[17];                                              //      17
N    uint8_t ManagePSWRecord[12];                                    //绠＄瀵  12
N    OptionRecord_t OptionRecord;                                    //绯荤璁剧疆  3
N	UserPswRecord_t UserPswRecord[LEN_USER_PSW_RECORD];             //10缁瀵  18*10   
X	UserPswRecord_t UserPswRecord[10];             
N    CardRecord_t CardRecord[LEN_CRAD_RECORD];                       //100缁＄ 6*100                                    
X    CardRecord_t CardRecord[100];                       
N	FigRecord_t FigRecord[LEN_FIG_RECORD];                          //100缁绾 4*100                 
X	FigRecord_t FigRecord[100];                          
N	DoordRecord_t DoodrRecord[LEN_DOOR_RECORD];                     //200寮ㄨ板 16*200
X	DoordRecord_t DoodrRecord[200];                     
N}Record_t;
N
Nextern const Record_t LockRecord; 
W ".\Modules\Record\Record.h" 88 13 Deprecated declaration Record_InitSet - give arg types
Nextern bool Record_InitSet();
Xextern _Bool Record_InitSet();
Nextern bool Record_Read(uint32_t addr,void * eepromData,uint32_t size);
Xextern _Bool Record_Read(uint32_t addr,void * eepromData,uint32_t size);
Nextern bool Record_Write(uint32_t addr,void * eepromData,uint32_t size);
Xextern _Bool Record_Write(uint32_t addr,void * eepromData,uint32_t size);
N
Nextern bool WriteManagePSW(uint8_t p[]);                            //绠＄绉瀵
Xextern _Bool WriteManagePSW(uint8_t p[]);                            
Nextern bool ReadManagePSW(uint8_t p[]);                             //璇荤＄瀵
Xextern _Bool ReadManagePSW(uint8_t p[]);                             
Nextern bool ReadAndcheckUserPmpswByPSW(uint8_t psw[]);              //楠璇绠＄瀵
Xextern _Bool ReadAndcheckUserPmpswByPSW(uint8_t psw[]);              
N
Nextern bool WriteUserPSW(uint8_t id,uint8_t p[]);                   //ㄦ峰        
Xextern _Bool WriteUserPSW(uint8_t id,uint8_t p[]);                   
Nextern bool ReadAndcheckUserPswByID(uint8_t upsw[],uint8_t ID);     //ユ剧ㄦ峰 舵IDユupsw
Xextern _Bool ReadAndcheckUserPswByID(uint8_t upsw[],uint8_t ID);     
Nextern bool ReadAndcheckUserPswByPSW(uint8_t *id,uint8_t upsw[]);   //ユ剧ㄦ峰 舵upswユID
Xextern _Bool ReadAndcheckUserPswByPSW(uint8_t *id,uint8_t upsw[]);   
Nextern bool DelUserPswRecord(uint8_t id,bool option);               //ょㄦ峰 true涓烘绌
Xextern _Bool DelUserPswRecord(uint8_t id,_Bool option);               
N
Nextern bool WriteCardRecord(uint8_t id,uint8_t CID[]);              //＄
Xextern _Bool WriteCardRecord(uint8_t id,uint8_t CID[]);              
Nextern bool ReadAndcheckCardByUID(uint8_t *id,uint8_t CID[]);       //璇讳ユ惧＄ 杩UIDユ
Xextern _Bool ReadAndcheckCardByUID(uint8_t *id,uint8_t CID[]);       
Nextern bool ReadAndcheckCardByid(uint8_t id,uint8_t CID[]);         //璇讳ユ惧＄ 杩idユ
Xextern _Bool ReadAndcheckCardByid(uint8_t id,uint8_t CID[]);         
Nextern bool DelCardRecord(uint8_t id,uint8_t CID[],bool option);    //ゅ＄ true涓烘绌 false涓烘idゆCID
Xextern _Bool DelCardRecord(uint8_t id,uint8_t CID[],_Bool option);    
N
Nextern bool WriteFigRecord(uint8_t id,uint8_t FID);                 //瀛绾
Xextern _Bool WriteFigRecord(uint8_t id,uint8_t FID);                 
Nextern bool DelFigRecord(uint8_t id,bool option);                   //ゆ绾 true涓烘绌
Xextern _Bool DelFigRecord(uint8_t id,_Bool option);                   
Nextern bool ReadAndcheckFigByid(uint8_t id,uint8_t *FID);           //璇讳ユ炬绾 杩id 
Xextern _Bool ReadAndcheckFigByid(uint8_t id,uint8_t *FID);           
N
Nextern void ResteLockRecord(void);                                  //㈠哄璁剧疆
N
Nextern bool ReadOptionRecord(OptionRecord_t *option);               //璇荤郴缁璁剧疆
Xextern _Bool ReadOptionRecord(OptionRecord_t *option);               
Nextern bool WriteOptionRecord(OptionRecord_t *option);              //绯荤璁剧疆
Xextern _Bool WriteOptionRecord(OptionRecord_t *option);              
N
Nextern bool WriteOpenDoorRecordById(OpenDoorClass_t class,uint8_t id,RtcRecord_t *t,uint8_t *para);//寮ㄨ板
Xextern _Bool WriteOpenDoorRecordById(OpenDoorClass_t class,uint8_t id,RtcRecord_t *t,uint8_t *para);
N
N#endif
N
N/* [] END OF FILE */
L 40 ".\main.h" 2
N#include "Extend.h"
L 1 ".\Modules\Extend\Extend.h" 1
N/* ========================================
N *
N * Copyright YOUR COMPANY, THE YEAR
N * All Rights Reserved
N * UNPUBLISHED, LICENSED SOFTWARE.
N *
N * CONFIDENTIAL AND PROPRIETARY INFORMATION
N * WHICH IS THE PROPERTY OF your company.
N *
N * ========================================
N*/
N#ifndef _EXTEND_H
N#define _EXTEND_H
N#include "main.h"
N    
Nextern void Extend_Init(void);
N
N#endif
N
N/* [] END OF FILE */
L 41 ".\main.h" 2
N#include "MLock.h"
L 1 ".\Modules\Lock\MLock.h" 1
N/* ========================================
N *
N * Copyright YOUR COMPANY, THE YEAR
N * All Rights Reserved
N * UNPUBLISHED, LICENSED SOFTWARE.
N *
N * CONFIDENTIAL AND PROPRIETARY INFORMATION
N * WHICH IS THE PROPERTY OF your company.
N *
N * ========================================
N*/
N#ifndef _BAT_H
S#define _BAT_H
S    
S#include "main.h"
S    
Stypedef struct
S{
S    uint8_t cmd;
S    uint8_t status;
S    bool act;
S}MLock_t;
S    
S
N#endif
N
N/* [] END OF FILE */
L 42 ".\main.h" 2
N    
N#define PLATFORM        
N#define TIME_BASIC_MS 10
N
N#ifdef PLATFORM
N#include "project.h"
L 1 "Generated_Source\PSoC4\project.h" 1
N/*******************************************************************************
N* File Name: project.h
N* 
N* PSoC Creator  4.2
N*
N* Description:
N* It contains references to all generated header files and should not be modified.
N* This file is automatically generated by PSoC Creator.
N*
N********************************************************************************
N* Copyright (c) 2007-2018 Cypress Semiconductor.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N********************************************************************************/
N
N#include "cyfitter_cfg.h"
N#include "cydevice_trm.h"
N#include "cyfitter.h"
N#include "cydisabledsheets.h"
N#include "UART_1_BLE.h"
N#include "UART_1_BLE_SPI_UART.h"
N#include "UART_1_BLE_PINS.h"
N#include "UART_1_BLE_SPI_UART_PVT.h"
N#include "UART_1_BLE_PVT.h"
N#include "UART_1_BLE_BOOT.h"
N#include "UART_0_FPC.h"
N#include "UART_0_FPC_SPI_UART.h"
N#include "UART_0_FPC_PINS.h"
N#include "UART_0_FPC_SPI_UART_PVT.h"
N#include "UART_0_FPC_PVT.h"
N#include "UART_0_FPC_BOOT.h"
N#include "UART_2_EXT.h"
N#include "UART_2_EXT_SPI_UART.h"
N#include "UART_2_EXT_PINS.h"
N#include "UART_2_EXT_SPI_UART_PVT.h"
N#include "UART_2_EXT_PVT.h"
N#include "UART_2_EXT_BOOT.h"
N#include "SPI_0_OLED_FLASH.h"
N#include "SPI_0_OLED_FLASH_SPI_UART.h"
N#include "SPI_0_OLED_FLASH_PINS.h"
N#include "SPI_0_OLED_FLASH_SPI_UART_PVT.h"
N#include "SPI_0_OLED_FLASH_PVT.h"
N#include "SPI_0_OLED_FLASH_BOOT.h"
N#include "SPI_1_CARD.h"
N#include "SPI_1_CARD_SPI_UART.h"
N#include "SPI_1_CARD_PINS.h"
N#include "SPI_1_CARD_SPI_UART_PVT.h"
N#include "SPI_1_CARD_PVT.h"
N#include "SPI_1_CARD_BOOT.h"
N#include "CARD_RESET.h"
L 1 "Generated_Source\PSoC4\CARD_RESET.h" 1
N/*******************************************************************************
N* File Name: CARD_RESET.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_CARD_RESET_H) /* Pins CARD_RESET_H */
X#if !1L  
S#define CY_PINS_CARD_RESET_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "CARD_RESET_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} CARD_RESET_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   CARD_RESET_Read(void);
Svoid    CARD_RESET_Write(uint8 value);
Suint8   CARD_RESET_ReadDataReg(void);
S#if defined(CARD_RESET__PC) || (CY_PSOC4_4200L) 
S    void    CARD_RESET_SetDriveMode(uint8 mode);
S#endif
Svoid    CARD_RESET_SetInterruptMode(uint16 position, uint16 mode);
Suint8   CARD_RESET_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid CARD_RESET_Sleep(void); 
Svoid CARD_RESET_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(CARD_RESET__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define CARD_RESET_DRIVE_MODE_BITS        (3)
S    #define CARD_RESET_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - CARD_RESET_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the CARD_RESET_SetDriveMode() function.
S         *  @{
S         */
S        #define CARD_RESET_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define CARD_RESET_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define CARD_RESET_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define CARD_RESET_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define CARD_RESET_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define CARD_RESET_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define CARD_RESET_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define CARD_RESET_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define CARD_RESET_MASK               CARD_RESET__MASK
S#define CARD_RESET_SHIFT              CARD_RESET__SHIFT
S#define CARD_RESET_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in CARD_RESET_SetInterruptMode() function.
S     *  @{
S     */
S        #define CARD_RESET_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define CARD_RESET_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define CARD_RESET_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define CARD_RESET_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(CARD_RESET__SIO)
S    #define CARD_RESET_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(CARD_RESET__PC) && (CY_PSOC4_4200L)
S    #define CARD_RESET_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define CARD_RESET_USBIO_DISABLE              ((uint32)(~CARD_RESET_USBIO_ENABLE))
S    #define CARD_RESET_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define CARD_RESET_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define CARD_RESET_USBIO_ENTER_SLEEP          ((uint32)((1u << CARD_RESET_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << CARD_RESET_USBIO_SUSPEND_DEL_SHIFT)))
X    #define CARD_RESET_USBIO_ENTER_SLEEP          ((uint32)((1u << CARD_RESET_USBIO_SUSPEND_SHIFT)                                                         | (1u << CARD_RESET_USBIO_SUSPEND_DEL_SHIFT)))
S    #define CARD_RESET_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << CARD_RESET_USBIO_SUSPEND_SHIFT)))
S    #define CARD_RESET_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << CARD_RESET_USBIO_SUSPEND_DEL_SHIFT)))
S    #define CARD_RESET_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(CARD_RESET__PC)
S    /* Port Configuration */
S    #define CARD_RESET_PC                 (* (reg32 *) CARD_RESET__PC)
S#endif
S/* Pin State */
S#define CARD_RESET_PS                     (* (reg32 *) CARD_RESET__PS)
S/* Data Register */
S#define CARD_RESET_DR                     (* (reg32 *) CARD_RESET__DR)
S/* Input Buffer Disable Override */
S#define CARD_RESET_INP_DIS                (* (reg32 *) CARD_RESET__PC2)
S
S/* Interrupt configuration Registers */
S#define CARD_RESET_INTCFG                 (* (reg32 *) CARD_RESET__INTCFG)
S#define CARD_RESET_INTSTAT                (* (reg32 *) CARD_RESET__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define CARD_RESET_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(CARD_RESET__SIO)
S    #define CARD_RESET_SIO_REG            (* (reg32 *) CARD_RESET__SIO)
S#endif /* (CARD_RESET__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(CARD_RESET__PC) && (CY_PSOC4_4200L)
S    #define CARD_RESET_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define CARD_RESET_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define CARD_RESET_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define CARD_RESET_DRIVE_MODE_SHIFT       (0x00u)
S#define CARD_RESET_DRIVE_MODE_MASK        (0x07u << CARD_RESET_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins CARD_RESET_H */
N
N
N/* [] END OF FILE */
L 52 "Generated_Source\PSoC4\project.h" 2
N#include "CARD_RESET_aliases.h"
L 1 "Generated_Source\PSoC4\CARD_RESET_aliases.h" 1
N/*******************************************************************************
N* File Name: CARD_RESET.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_CARD_RESET_ALIASES_H) /* Pins CARD_RESET_ALIASES_H */
X#if !1L  
S#define CY_PINS_CARD_RESET_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define CARD_RESET_0			(CARD_RESET__0__PC)
S#define CARD_RESET_0_PS		(CARD_RESET__0__PS)
S#define CARD_RESET_0_PC		(CARD_RESET__0__PC)
S#define CARD_RESET_0_DR		(CARD_RESET__0__DR)
S#define CARD_RESET_0_SHIFT	(CARD_RESET__0__SHIFT)
S#define CARD_RESET_0_INTR	((uint16)((uint16)0x0003u << (CARD_RESET__0__SHIFT*2u)))
S
S#define CARD_RESET_INTR_ALL	 ((uint16)(CARD_RESET_0_INTR))
S
S
N#endif /* End Pins CARD_RESET_ALIASES_H */
N
N
N/* [] END OF FILE */
L 53 "Generated_Source\PSoC4\project.h" 2
N#include "OLED_DC.h"
L 1 "Generated_Source\PSoC4\OLED_DC.h" 1
N/*******************************************************************************
N* File Name: OLED_DC.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_OLED_DC_H) /* Pins OLED_DC_H */
X#if !1L  
S#define CY_PINS_OLED_DC_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "OLED_DC_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} OLED_DC_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   OLED_DC_Read(void);
Svoid    OLED_DC_Write(uint8 value);
Suint8   OLED_DC_ReadDataReg(void);
S#if defined(OLED_DC__PC) || (CY_PSOC4_4200L) 
S    void    OLED_DC_SetDriveMode(uint8 mode);
S#endif
Svoid    OLED_DC_SetInterruptMode(uint16 position, uint16 mode);
Suint8   OLED_DC_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid OLED_DC_Sleep(void); 
Svoid OLED_DC_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(OLED_DC__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define OLED_DC_DRIVE_MODE_BITS        (3)
S    #define OLED_DC_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - OLED_DC_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the OLED_DC_SetDriveMode() function.
S         *  @{
S         */
S        #define OLED_DC_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define OLED_DC_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define OLED_DC_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define OLED_DC_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define OLED_DC_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define OLED_DC_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define OLED_DC_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define OLED_DC_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define OLED_DC_MASK               OLED_DC__MASK
S#define OLED_DC_SHIFT              OLED_DC__SHIFT
S#define OLED_DC_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in OLED_DC_SetInterruptMode() function.
S     *  @{
S     */
S        #define OLED_DC_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define OLED_DC_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define OLED_DC_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define OLED_DC_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(OLED_DC__SIO)
S    #define OLED_DC_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(OLED_DC__PC) && (CY_PSOC4_4200L)
S    #define OLED_DC_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define OLED_DC_USBIO_DISABLE              ((uint32)(~OLED_DC_USBIO_ENABLE))
S    #define OLED_DC_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define OLED_DC_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define OLED_DC_USBIO_ENTER_SLEEP          ((uint32)((1u << OLED_DC_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << OLED_DC_USBIO_SUSPEND_DEL_SHIFT)))
X    #define OLED_DC_USBIO_ENTER_SLEEP          ((uint32)((1u << OLED_DC_USBIO_SUSPEND_SHIFT)                                                         | (1u << OLED_DC_USBIO_SUSPEND_DEL_SHIFT)))
S    #define OLED_DC_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << OLED_DC_USBIO_SUSPEND_SHIFT)))
S    #define OLED_DC_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << OLED_DC_USBIO_SUSPEND_DEL_SHIFT)))
S    #define OLED_DC_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(OLED_DC__PC)
S    /* Port Configuration */
S    #define OLED_DC_PC                 (* (reg32 *) OLED_DC__PC)
S#endif
S/* Pin State */
S#define OLED_DC_PS                     (* (reg32 *) OLED_DC__PS)
S/* Data Register */
S#define OLED_DC_DR                     (* (reg32 *) OLED_DC__DR)
S/* Input Buffer Disable Override */
S#define OLED_DC_INP_DIS                (* (reg32 *) OLED_DC__PC2)
S
S/* Interrupt configuration Registers */
S#define OLED_DC_INTCFG                 (* (reg32 *) OLED_DC__INTCFG)
S#define OLED_DC_INTSTAT                (* (reg32 *) OLED_DC__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define OLED_DC_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(OLED_DC__SIO)
S    #define OLED_DC_SIO_REG            (* (reg32 *) OLED_DC__SIO)
S#endif /* (OLED_DC__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(OLED_DC__PC) && (CY_PSOC4_4200L)
S    #define OLED_DC_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define OLED_DC_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define OLED_DC_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define OLED_DC_DRIVE_MODE_SHIFT       (0x00u)
S#define OLED_DC_DRIVE_MODE_MASK        (0x07u << OLED_DC_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins OLED_DC_H */
N
N
N/* [] END OF FILE */
L 54 "Generated_Source\PSoC4\project.h" 2
N#include "OLED_DC_aliases.h"
L 1 "Generated_Source\PSoC4\OLED_DC_aliases.h" 1
N/*******************************************************************************
N* File Name: OLED_DC.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_OLED_DC_ALIASES_H) /* Pins OLED_DC_ALIASES_H */
X#if !1L  
S#define CY_PINS_OLED_DC_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define OLED_DC_0			(OLED_DC__0__PC)
S#define OLED_DC_0_PS		(OLED_DC__0__PS)
S#define OLED_DC_0_PC		(OLED_DC__0__PC)
S#define OLED_DC_0_DR		(OLED_DC__0__DR)
S#define OLED_DC_0_SHIFT	(OLED_DC__0__SHIFT)
S#define OLED_DC_0_INTR	((uint16)((uint16)0x0003u << (OLED_DC__0__SHIFT*2u)))
S
S#define OLED_DC_INTR_ALL	 ((uint16)(OLED_DC_0_INTR))
S
S
N#endif /* End Pins OLED_DC_ALIASES_H */
N
N
N/* [] END OF FILE */
L 55 "Generated_Source\PSoC4\project.h" 2
N#include "I2C_SCL.h"
L 1 "Generated_Source\PSoC4\I2C_SCL.h" 1
N/*******************************************************************************
N* File Name: I2C_SCL.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_I2C_SCL_H) /* Pins I2C_SCL_H */
X#if !1L  
S#define CY_PINS_I2C_SCL_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "I2C_SCL_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} I2C_SCL_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   I2C_SCL_Read(void);
Svoid    I2C_SCL_Write(uint8 value);
Suint8   I2C_SCL_ReadDataReg(void);
S#if defined(I2C_SCL__PC) || (CY_PSOC4_4200L) 
S    void    I2C_SCL_SetDriveMode(uint8 mode);
S#endif
Svoid    I2C_SCL_SetInterruptMode(uint16 position, uint16 mode);
Suint8   I2C_SCL_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid I2C_SCL_Sleep(void); 
Svoid I2C_SCL_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(I2C_SCL__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define I2C_SCL_DRIVE_MODE_BITS        (3)
S    #define I2C_SCL_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - I2C_SCL_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the I2C_SCL_SetDriveMode() function.
S         *  @{
S         */
S        #define I2C_SCL_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define I2C_SCL_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define I2C_SCL_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define I2C_SCL_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define I2C_SCL_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define I2C_SCL_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define I2C_SCL_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define I2C_SCL_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define I2C_SCL_MASK               I2C_SCL__MASK
S#define I2C_SCL_SHIFT              I2C_SCL__SHIFT
S#define I2C_SCL_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in I2C_SCL_SetInterruptMode() function.
S     *  @{
S     */
S        #define I2C_SCL_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define I2C_SCL_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define I2C_SCL_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define I2C_SCL_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(I2C_SCL__SIO)
S    #define I2C_SCL_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(I2C_SCL__PC) && (CY_PSOC4_4200L)
S    #define I2C_SCL_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define I2C_SCL_USBIO_DISABLE              ((uint32)(~I2C_SCL_USBIO_ENABLE))
S    #define I2C_SCL_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define I2C_SCL_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define I2C_SCL_USBIO_ENTER_SLEEP          ((uint32)((1u << I2C_SCL_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << I2C_SCL_USBIO_SUSPEND_DEL_SHIFT)))
X    #define I2C_SCL_USBIO_ENTER_SLEEP          ((uint32)((1u << I2C_SCL_USBIO_SUSPEND_SHIFT)                                                         | (1u << I2C_SCL_USBIO_SUSPEND_DEL_SHIFT)))
S    #define I2C_SCL_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << I2C_SCL_USBIO_SUSPEND_SHIFT)))
S    #define I2C_SCL_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << I2C_SCL_USBIO_SUSPEND_DEL_SHIFT)))
S    #define I2C_SCL_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(I2C_SCL__PC)
S    /* Port Configuration */
S    #define I2C_SCL_PC                 (* (reg32 *) I2C_SCL__PC)
S#endif
S/* Pin State */
S#define I2C_SCL_PS                     (* (reg32 *) I2C_SCL__PS)
S/* Data Register */
S#define I2C_SCL_DR                     (* (reg32 *) I2C_SCL__DR)
S/* Input Buffer Disable Override */
S#define I2C_SCL_INP_DIS                (* (reg32 *) I2C_SCL__PC2)
S
S/* Interrupt configuration Registers */
S#define I2C_SCL_INTCFG                 (* (reg32 *) I2C_SCL__INTCFG)
S#define I2C_SCL_INTSTAT                (* (reg32 *) I2C_SCL__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define I2C_SCL_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(I2C_SCL__SIO)
S    #define I2C_SCL_SIO_REG            (* (reg32 *) I2C_SCL__SIO)
S#endif /* (I2C_SCL__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(I2C_SCL__PC) && (CY_PSOC4_4200L)
S    #define I2C_SCL_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define I2C_SCL_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define I2C_SCL_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define I2C_SCL_DRIVE_MODE_SHIFT       (0x00u)
S#define I2C_SCL_DRIVE_MODE_MASK        (0x07u << I2C_SCL_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins I2C_SCL_H */
N
N
N/* [] END OF FILE */
L 56 "Generated_Source\PSoC4\project.h" 2
N#include "I2C_SCL_aliases.h"
L 1 "Generated_Source\PSoC4\I2C_SCL_aliases.h" 1
N/*******************************************************************************
N* File Name: I2C_SCL.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_I2C_SCL_ALIASES_H) /* Pins I2C_SCL_ALIASES_H */
X#if !1L  
S#define CY_PINS_I2C_SCL_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define I2C_SCL_0			(I2C_SCL__0__PC)
S#define I2C_SCL_0_PS		(I2C_SCL__0__PS)
S#define I2C_SCL_0_PC		(I2C_SCL__0__PC)
S#define I2C_SCL_0_DR		(I2C_SCL__0__DR)
S#define I2C_SCL_0_SHIFT	(I2C_SCL__0__SHIFT)
S#define I2C_SCL_0_INTR	((uint16)((uint16)0x0003u << (I2C_SCL__0__SHIFT*2u)))
S
S#define I2C_SCL_INTR_ALL	 ((uint16)(I2C_SCL_0_INTR))
S
S
N#endif /* End Pins I2C_SCL_ALIASES_H */
N
N
N/* [] END OF FILE */
L 57 "Generated_Source\PSoC4\project.h" 2
N#include "I2C_SDA.h"
L 1 "Generated_Source\PSoC4\I2C_SDA.h" 1
N/*******************************************************************************
N* File Name: I2C_SDA.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_I2C_SDA_H) /* Pins I2C_SDA_H */
X#if !1L  
S#define CY_PINS_I2C_SDA_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "I2C_SDA_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} I2C_SDA_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   I2C_SDA_Read(void);
Svoid    I2C_SDA_Write(uint8 value);
Suint8   I2C_SDA_ReadDataReg(void);
S#if defined(I2C_SDA__PC) || (CY_PSOC4_4200L) 
S    void    I2C_SDA_SetDriveMode(uint8 mode);
S#endif
Svoid    I2C_SDA_SetInterruptMode(uint16 position, uint16 mode);
Suint8   I2C_SDA_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid I2C_SDA_Sleep(void); 
Svoid I2C_SDA_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(I2C_SDA__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define I2C_SDA_DRIVE_MODE_BITS        (3)
S    #define I2C_SDA_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - I2C_SDA_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the I2C_SDA_SetDriveMode() function.
S         *  @{
S         */
S        #define I2C_SDA_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define I2C_SDA_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define I2C_SDA_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define I2C_SDA_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define I2C_SDA_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define I2C_SDA_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define I2C_SDA_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define I2C_SDA_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define I2C_SDA_MASK               I2C_SDA__MASK
S#define I2C_SDA_SHIFT              I2C_SDA__SHIFT
S#define I2C_SDA_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in I2C_SDA_SetInterruptMode() function.
S     *  @{
S     */
S        #define I2C_SDA_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define I2C_SDA_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define I2C_SDA_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define I2C_SDA_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(I2C_SDA__SIO)
S    #define I2C_SDA_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(I2C_SDA__PC) && (CY_PSOC4_4200L)
S    #define I2C_SDA_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define I2C_SDA_USBIO_DISABLE              ((uint32)(~I2C_SDA_USBIO_ENABLE))
S    #define I2C_SDA_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define I2C_SDA_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define I2C_SDA_USBIO_ENTER_SLEEP          ((uint32)((1u << I2C_SDA_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << I2C_SDA_USBIO_SUSPEND_DEL_SHIFT)))
X    #define I2C_SDA_USBIO_ENTER_SLEEP          ((uint32)((1u << I2C_SDA_USBIO_SUSPEND_SHIFT)                                                         | (1u << I2C_SDA_USBIO_SUSPEND_DEL_SHIFT)))
S    #define I2C_SDA_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << I2C_SDA_USBIO_SUSPEND_SHIFT)))
S    #define I2C_SDA_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << I2C_SDA_USBIO_SUSPEND_DEL_SHIFT)))
S    #define I2C_SDA_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(I2C_SDA__PC)
S    /* Port Configuration */
S    #define I2C_SDA_PC                 (* (reg32 *) I2C_SDA__PC)
S#endif
S/* Pin State */
S#define I2C_SDA_PS                     (* (reg32 *) I2C_SDA__PS)
S/* Data Register */
S#define I2C_SDA_DR                     (* (reg32 *) I2C_SDA__DR)
S/* Input Buffer Disable Override */
S#define I2C_SDA_INP_DIS                (* (reg32 *) I2C_SDA__PC2)
S
S/* Interrupt configuration Registers */
S#define I2C_SDA_INTCFG                 (* (reg32 *) I2C_SDA__INTCFG)
S#define I2C_SDA_INTSTAT                (* (reg32 *) I2C_SDA__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define I2C_SDA_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(I2C_SDA__SIO)
S    #define I2C_SDA_SIO_REG            (* (reg32 *) I2C_SDA__SIO)
S#endif /* (I2C_SDA__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(I2C_SDA__PC) && (CY_PSOC4_4200L)
S    #define I2C_SDA_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define I2C_SDA_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define I2C_SDA_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define I2C_SDA_DRIVE_MODE_SHIFT       (0x00u)
S#define I2C_SDA_DRIVE_MODE_MASK        (0x07u << I2C_SDA_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins I2C_SDA_H */
N
N
N/* [] END OF FILE */
L 58 "Generated_Source\PSoC4\project.h" 2
N#include "I2C_SDA_aliases.h"
L 1 "Generated_Source\PSoC4\I2C_SDA_aliases.h" 1
N/*******************************************************************************
N* File Name: I2C_SDA.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_I2C_SDA_ALIASES_H) /* Pins I2C_SDA_ALIASES_H */
X#if !1L  
S#define CY_PINS_I2C_SDA_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define I2C_SDA_0			(I2C_SDA__0__PC)
S#define I2C_SDA_0_PS		(I2C_SDA__0__PS)
S#define I2C_SDA_0_PC		(I2C_SDA__0__PC)
S#define I2C_SDA_0_DR		(I2C_SDA__0__DR)
S#define I2C_SDA_0_SHIFT	(I2C_SDA__0__SHIFT)
S#define I2C_SDA_0_INTR	((uint16)((uint16)0x0003u << (I2C_SDA__0__SHIFT*2u)))
S
S#define I2C_SDA_INTR_ALL	 ((uint16)(I2C_SDA_0_INTR))
S
S
N#endif /* End Pins I2C_SDA_ALIASES_H */
N
N
N/* [] END OF FILE */
L 59 "Generated_Source\PSoC4\project.h" 2
N#include "I2C_ST.h"
L 1 "Generated_Source\PSoC4\I2C_ST.h" 1
N/*******************************************************************************
N* File Name: I2C_ST.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_I2C_ST_H) /* Pins I2C_ST_H */
X#if !1L  
S#define CY_PINS_I2C_ST_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "I2C_ST_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} I2C_ST_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   I2C_ST_Read(void);
Svoid    I2C_ST_Write(uint8 value);
Suint8   I2C_ST_ReadDataReg(void);
S#if defined(I2C_ST__PC) || (CY_PSOC4_4200L) 
S    void    I2C_ST_SetDriveMode(uint8 mode);
S#endif
Svoid    I2C_ST_SetInterruptMode(uint16 position, uint16 mode);
Suint8   I2C_ST_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid I2C_ST_Sleep(void); 
Svoid I2C_ST_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(I2C_ST__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define I2C_ST_DRIVE_MODE_BITS        (3)
S    #define I2C_ST_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - I2C_ST_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the I2C_ST_SetDriveMode() function.
S         *  @{
S         */
S        #define I2C_ST_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define I2C_ST_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define I2C_ST_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define I2C_ST_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define I2C_ST_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define I2C_ST_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define I2C_ST_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define I2C_ST_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define I2C_ST_MASK               I2C_ST__MASK
S#define I2C_ST_SHIFT              I2C_ST__SHIFT
S#define I2C_ST_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in I2C_ST_SetInterruptMode() function.
S     *  @{
S     */
S        #define I2C_ST_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define I2C_ST_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define I2C_ST_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define I2C_ST_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(I2C_ST__SIO)
S    #define I2C_ST_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(I2C_ST__PC) && (CY_PSOC4_4200L)
S    #define I2C_ST_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define I2C_ST_USBIO_DISABLE              ((uint32)(~I2C_ST_USBIO_ENABLE))
S    #define I2C_ST_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define I2C_ST_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define I2C_ST_USBIO_ENTER_SLEEP          ((uint32)((1u << I2C_ST_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << I2C_ST_USBIO_SUSPEND_DEL_SHIFT)))
X    #define I2C_ST_USBIO_ENTER_SLEEP          ((uint32)((1u << I2C_ST_USBIO_SUSPEND_SHIFT)                                                         | (1u << I2C_ST_USBIO_SUSPEND_DEL_SHIFT)))
S    #define I2C_ST_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << I2C_ST_USBIO_SUSPEND_SHIFT)))
S    #define I2C_ST_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << I2C_ST_USBIO_SUSPEND_DEL_SHIFT)))
S    #define I2C_ST_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(I2C_ST__PC)
S    /* Port Configuration */
S    #define I2C_ST_PC                 (* (reg32 *) I2C_ST__PC)
S#endif
S/* Pin State */
S#define I2C_ST_PS                     (* (reg32 *) I2C_ST__PS)
S/* Data Register */
S#define I2C_ST_DR                     (* (reg32 *) I2C_ST__DR)
S/* Input Buffer Disable Override */
S#define I2C_ST_INP_DIS                (* (reg32 *) I2C_ST__PC2)
S
S/* Interrupt configuration Registers */
S#define I2C_ST_INTCFG                 (* (reg32 *) I2C_ST__INTCFG)
S#define I2C_ST_INTSTAT                (* (reg32 *) I2C_ST__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define I2C_ST_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(I2C_ST__SIO)
S    #define I2C_ST_SIO_REG            (* (reg32 *) I2C_ST__SIO)
S#endif /* (I2C_ST__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(I2C_ST__PC) && (CY_PSOC4_4200L)
S    #define I2C_ST_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define I2C_ST_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define I2C_ST_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define I2C_ST_DRIVE_MODE_SHIFT       (0x00u)
S#define I2C_ST_DRIVE_MODE_MASK        (0x07u << I2C_ST_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins I2C_ST_H */
N
N
N/* [] END OF FILE */
L 60 "Generated_Source\PSoC4\project.h" 2
N#include "I2C_ST_aliases.h"
L 1 "Generated_Source\PSoC4\I2C_ST_aliases.h" 1
N/*******************************************************************************
N* File Name: I2C_ST.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_I2C_ST_ALIASES_H) /* Pins I2C_ST_ALIASES_H */
X#if !1L  
S#define CY_PINS_I2C_ST_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define I2C_ST_0			(I2C_ST__0__PC)
S#define I2C_ST_0_PS		(I2C_ST__0__PS)
S#define I2C_ST_0_PC		(I2C_ST__0__PC)
S#define I2C_ST_0_DR		(I2C_ST__0__DR)
S#define I2C_ST_0_SHIFT	(I2C_ST__0__SHIFT)
S#define I2C_ST_0_INTR	((uint16)((uint16)0x0003u << (I2C_ST__0__SHIFT*2u)))
S
S#define I2C_ST_INTR_ALL	 ((uint16)(I2C_ST_0_INTR))
S
S
N#endif /* End Pins I2C_ST_ALIASES_H */
N
N
N/* [] END OF FILE */
L 61 "Generated_Source\PSoC4\project.h" 2
N#include "CapSense.h"
N#include "CapSense_Control.h"
N#include "CapSense_Filter.h"
N#include "CapSense_Processing.h"
N#include "CapSense_Sensing.h"
N#include "CapSense_Structure.h"
N#include "CapSense_Tuner.h"
N#include "CapSense_Configuration.h"
N#include "CapSense_SensingCSD_LL.h"
N#include "CapSense_RegisterMap.h"
N#include "BAT_ADC.h"
L 1 "Generated_Source\PSoC4\BAT_ADC.h" 1
N/*******************************************************************************
N* File Name: BAT_ADC.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_BAT_ADC_H) /* Pins BAT_ADC_H */
X#if !1L  
S#define CY_PINS_BAT_ADC_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "BAT_ADC_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} BAT_ADC_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   BAT_ADC_Read(void);
Svoid    BAT_ADC_Write(uint8 value);
Suint8   BAT_ADC_ReadDataReg(void);
S#if defined(BAT_ADC__PC) || (CY_PSOC4_4200L) 
S    void    BAT_ADC_SetDriveMode(uint8 mode);
S#endif
Svoid    BAT_ADC_SetInterruptMode(uint16 position, uint16 mode);
Suint8   BAT_ADC_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid BAT_ADC_Sleep(void); 
Svoid BAT_ADC_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(BAT_ADC__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define BAT_ADC_DRIVE_MODE_BITS        (3)
S    #define BAT_ADC_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - BAT_ADC_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the BAT_ADC_SetDriveMode() function.
S         *  @{
S         */
S        #define BAT_ADC_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define BAT_ADC_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define BAT_ADC_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define BAT_ADC_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define BAT_ADC_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define BAT_ADC_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define BAT_ADC_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define BAT_ADC_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define BAT_ADC_MASK               BAT_ADC__MASK
S#define BAT_ADC_SHIFT              BAT_ADC__SHIFT
S#define BAT_ADC_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in BAT_ADC_SetInterruptMode() function.
S     *  @{
S     */
S        #define BAT_ADC_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define BAT_ADC_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define BAT_ADC_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define BAT_ADC_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(BAT_ADC__SIO)
S    #define BAT_ADC_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(BAT_ADC__PC) && (CY_PSOC4_4200L)
S    #define BAT_ADC_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define BAT_ADC_USBIO_DISABLE              ((uint32)(~BAT_ADC_USBIO_ENABLE))
S    #define BAT_ADC_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define BAT_ADC_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define BAT_ADC_USBIO_ENTER_SLEEP          ((uint32)((1u << BAT_ADC_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << BAT_ADC_USBIO_SUSPEND_DEL_SHIFT)))
X    #define BAT_ADC_USBIO_ENTER_SLEEP          ((uint32)((1u << BAT_ADC_USBIO_SUSPEND_SHIFT)                                                         | (1u << BAT_ADC_USBIO_SUSPEND_DEL_SHIFT)))
S    #define BAT_ADC_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << BAT_ADC_USBIO_SUSPEND_SHIFT)))
S    #define BAT_ADC_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << BAT_ADC_USBIO_SUSPEND_DEL_SHIFT)))
S    #define BAT_ADC_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(BAT_ADC__PC)
S    /* Port Configuration */
S    #define BAT_ADC_PC                 (* (reg32 *) BAT_ADC__PC)
S#endif
S/* Pin State */
S#define BAT_ADC_PS                     (* (reg32 *) BAT_ADC__PS)
S/* Data Register */
S#define BAT_ADC_DR                     (* (reg32 *) BAT_ADC__DR)
S/* Input Buffer Disable Override */
S#define BAT_ADC_INP_DIS                (* (reg32 *) BAT_ADC__PC2)
S
S/* Interrupt configuration Registers */
S#define BAT_ADC_INTCFG                 (* (reg32 *) BAT_ADC__INTCFG)
S#define BAT_ADC_INTSTAT                (* (reg32 *) BAT_ADC__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define BAT_ADC_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(BAT_ADC__SIO)
S    #define BAT_ADC_SIO_REG            (* (reg32 *) BAT_ADC__SIO)
S#endif /* (BAT_ADC__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(BAT_ADC__PC) && (CY_PSOC4_4200L)
S    #define BAT_ADC_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define BAT_ADC_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define BAT_ADC_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define BAT_ADC_DRIVE_MODE_SHIFT       (0x00u)
S#define BAT_ADC_DRIVE_MODE_MASK        (0x07u << BAT_ADC_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins BAT_ADC_H */
N
N
N/* [] END OF FILE */
L 72 "Generated_Source\PSoC4\project.h" 2
N#include "BAT_ADC_aliases.h"
L 1 "Generated_Source\PSoC4\BAT_ADC_aliases.h" 1
N/*******************************************************************************
N* File Name: BAT_ADC.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_BAT_ADC_ALIASES_H) /* Pins BAT_ADC_ALIASES_H */
X#if !1L  
S#define CY_PINS_BAT_ADC_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define BAT_ADC_0			(BAT_ADC__0__PC)
S#define BAT_ADC_0_PS		(BAT_ADC__0__PS)
S#define BAT_ADC_0_PC		(BAT_ADC__0__PC)
S#define BAT_ADC_0_DR		(BAT_ADC__0__DR)
S#define BAT_ADC_0_SHIFT	(BAT_ADC__0__SHIFT)
S#define BAT_ADC_0_INTR	((uint16)((uint16)0x0003u << (BAT_ADC__0__SHIFT*2u)))
S
S#define BAT_ADC_INTR_ALL	 ((uint16)(BAT_ADC_0_INTR))
S
S
N#endif /* End Pins BAT_ADC_ALIASES_H */
N
N
N/* [] END OF FILE */
L 73 "Generated_Source\PSoC4\project.h" 2
N#include "ADC.h"
N#include "MOTO_ADC.h"
L 1 "Generated_Source\PSoC4\MOTO_ADC.h" 1
N/*******************************************************************************
N* File Name: MOTO_ADC.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_MOTO_ADC_H) /* Pins MOTO_ADC_H */
X#if !1L  
S#define CY_PINS_MOTO_ADC_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "MOTO_ADC_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} MOTO_ADC_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   MOTO_ADC_Read(void);
Svoid    MOTO_ADC_Write(uint8 value);
Suint8   MOTO_ADC_ReadDataReg(void);
S#if defined(MOTO_ADC__PC) || (CY_PSOC4_4200L) 
S    void    MOTO_ADC_SetDriveMode(uint8 mode);
S#endif
Svoid    MOTO_ADC_SetInterruptMode(uint16 position, uint16 mode);
Suint8   MOTO_ADC_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid MOTO_ADC_Sleep(void); 
Svoid MOTO_ADC_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(MOTO_ADC__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define MOTO_ADC_DRIVE_MODE_BITS        (3)
S    #define MOTO_ADC_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - MOTO_ADC_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the MOTO_ADC_SetDriveMode() function.
S         *  @{
S         */
S        #define MOTO_ADC_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define MOTO_ADC_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define MOTO_ADC_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define MOTO_ADC_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define MOTO_ADC_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define MOTO_ADC_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define MOTO_ADC_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define MOTO_ADC_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define MOTO_ADC_MASK               MOTO_ADC__MASK
S#define MOTO_ADC_SHIFT              MOTO_ADC__SHIFT
S#define MOTO_ADC_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in MOTO_ADC_SetInterruptMode() function.
S     *  @{
S     */
S        #define MOTO_ADC_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define MOTO_ADC_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define MOTO_ADC_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define MOTO_ADC_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(MOTO_ADC__SIO)
S    #define MOTO_ADC_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(MOTO_ADC__PC) && (CY_PSOC4_4200L)
S    #define MOTO_ADC_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define MOTO_ADC_USBIO_DISABLE              ((uint32)(~MOTO_ADC_USBIO_ENABLE))
S    #define MOTO_ADC_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define MOTO_ADC_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define MOTO_ADC_USBIO_ENTER_SLEEP          ((uint32)((1u << MOTO_ADC_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << MOTO_ADC_USBIO_SUSPEND_DEL_SHIFT)))
X    #define MOTO_ADC_USBIO_ENTER_SLEEP          ((uint32)((1u << MOTO_ADC_USBIO_SUSPEND_SHIFT)                                                         | (1u << MOTO_ADC_USBIO_SUSPEND_DEL_SHIFT)))
S    #define MOTO_ADC_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << MOTO_ADC_USBIO_SUSPEND_SHIFT)))
S    #define MOTO_ADC_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << MOTO_ADC_USBIO_SUSPEND_DEL_SHIFT)))
S    #define MOTO_ADC_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(MOTO_ADC__PC)
S    /* Port Configuration */
S    #define MOTO_ADC_PC                 (* (reg32 *) MOTO_ADC__PC)
S#endif
S/* Pin State */
S#define MOTO_ADC_PS                     (* (reg32 *) MOTO_ADC__PS)
S/* Data Register */
S#define MOTO_ADC_DR                     (* (reg32 *) MOTO_ADC__DR)
S/* Input Buffer Disable Override */
S#define MOTO_ADC_INP_DIS                (* (reg32 *) MOTO_ADC__PC2)
S
S/* Interrupt configuration Registers */
S#define MOTO_ADC_INTCFG                 (* (reg32 *) MOTO_ADC__INTCFG)
S#define MOTO_ADC_INTSTAT                (* (reg32 *) MOTO_ADC__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define MOTO_ADC_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(MOTO_ADC__SIO)
S    #define MOTO_ADC_SIO_REG            (* (reg32 *) MOTO_ADC__SIO)
S#endif /* (MOTO_ADC__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(MOTO_ADC__PC) && (CY_PSOC4_4200L)
S    #define MOTO_ADC_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define MOTO_ADC_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define MOTO_ADC_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define MOTO_ADC_DRIVE_MODE_SHIFT       (0x00u)
S#define MOTO_ADC_DRIVE_MODE_MASK        (0x07u << MOTO_ADC_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins MOTO_ADC_H */
N
N
N/* [] END OF FILE */
L 75 "Generated_Source\PSoC4\project.h" 2
N#include "MOTO_ADC_aliases.h"
L 1 "Generated_Source\PSoC4\MOTO_ADC_aliases.h" 1
N/*******************************************************************************
N* File Name: MOTO_ADC.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_MOTO_ADC_ALIASES_H) /* Pins MOTO_ADC_ALIASES_H */
X#if !1L  
S#define CY_PINS_MOTO_ADC_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define MOTO_ADC_0			(MOTO_ADC__0__PC)
S#define MOTO_ADC_0_PS		(MOTO_ADC__0__PS)
S#define MOTO_ADC_0_PC		(MOTO_ADC__0__PC)
S#define MOTO_ADC_0_DR		(MOTO_ADC__0__DR)
S#define MOTO_ADC_0_SHIFT	(MOTO_ADC__0__SHIFT)
S#define MOTO_ADC_0_INTR	((uint16)((uint16)0x0003u << (MOTO_ADC__0__SHIFT*2u)))
S
S#define MOTO_ADC_INTR_ALL	 ((uint16)(MOTO_ADC_0_INTR))
S
S
N#endif /* End Pins MOTO_ADC_ALIASES_H */
N
N
N/* [] END OF FILE */
L 76 "Generated_Source\PSoC4\project.h" 2
N#include "RF_ADC.h"
L 1 "Generated_Source\PSoC4\RF_ADC.h" 1
N/*******************************************************************************
N* File Name: RF_ADC.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_RF_ADC_H) /* Pins RF_ADC_H */
X#if !1L  
S#define CY_PINS_RF_ADC_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "RF_ADC_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} RF_ADC_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   RF_ADC_Read(void);
Svoid    RF_ADC_Write(uint8 value);
Suint8   RF_ADC_ReadDataReg(void);
S#if defined(RF_ADC__PC) || (CY_PSOC4_4200L) 
S    void    RF_ADC_SetDriveMode(uint8 mode);
S#endif
Svoid    RF_ADC_SetInterruptMode(uint16 position, uint16 mode);
Suint8   RF_ADC_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid RF_ADC_Sleep(void); 
Svoid RF_ADC_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(RF_ADC__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define RF_ADC_DRIVE_MODE_BITS        (3)
S    #define RF_ADC_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - RF_ADC_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the RF_ADC_SetDriveMode() function.
S         *  @{
S         */
S        #define RF_ADC_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define RF_ADC_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define RF_ADC_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define RF_ADC_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define RF_ADC_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define RF_ADC_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define RF_ADC_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define RF_ADC_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define RF_ADC_MASK               RF_ADC__MASK
S#define RF_ADC_SHIFT              RF_ADC__SHIFT
S#define RF_ADC_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in RF_ADC_SetInterruptMode() function.
S     *  @{
S     */
S        #define RF_ADC_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define RF_ADC_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define RF_ADC_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define RF_ADC_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(RF_ADC__SIO)
S    #define RF_ADC_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(RF_ADC__PC) && (CY_PSOC4_4200L)
S    #define RF_ADC_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define RF_ADC_USBIO_DISABLE              ((uint32)(~RF_ADC_USBIO_ENABLE))
S    #define RF_ADC_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define RF_ADC_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define RF_ADC_USBIO_ENTER_SLEEP          ((uint32)((1u << RF_ADC_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << RF_ADC_USBIO_SUSPEND_DEL_SHIFT)))
X    #define RF_ADC_USBIO_ENTER_SLEEP          ((uint32)((1u << RF_ADC_USBIO_SUSPEND_SHIFT)                                                         | (1u << RF_ADC_USBIO_SUSPEND_DEL_SHIFT)))
S    #define RF_ADC_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << RF_ADC_USBIO_SUSPEND_SHIFT)))
S    #define RF_ADC_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << RF_ADC_USBIO_SUSPEND_DEL_SHIFT)))
S    #define RF_ADC_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(RF_ADC__PC)
S    /* Port Configuration */
S    #define RF_ADC_PC                 (* (reg32 *) RF_ADC__PC)
S#endif
S/* Pin State */
S#define RF_ADC_PS                     (* (reg32 *) RF_ADC__PS)
S/* Data Register */
S#define RF_ADC_DR                     (* (reg32 *) RF_ADC__DR)
S/* Input Buffer Disable Override */
S#define RF_ADC_INP_DIS                (* (reg32 *) RF_ADC__PC2)
S
S/* Interrupt configuration Registers */
S#define RF_ADC_INTCFG                 (* (reg32 *) RF_ADC__INTCFG)
S#define RF_ADC_INTSTAT                (* (reg32 *) RF_ADC__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define RF_ADC_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(RF_ADC__SIO)
S    #define RF_ADC_SIO_REG            (* (reg32 *) RF_ADC__SIO)
S#endif /* (RF_ADC__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(RF_ADC__PC) && (CY_PSOC4_4200L)
S    #define RF_ADC_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define RF_ADC_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define RF_ADC_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define RF_ADC_DRIVE_MODE_SHIFT       (0x00u)
S#define RF_ADC_DRIVE_MODE_MASK        (0x07u << RF_ADC_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins RF_ADC_H */
N
N
N/* [] END OF FILE */
L 77 "Generated_Source\PSoC4\project.h" 2
N#include "RF_ADC_aliases.h"
L 1 "Generated_Source\PSoC4\RF_ADC_aliases.h" 1
N/*******************************************************************************
N* File Name: RF_ADC.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_RF_ADC_ALIASES_H) /* Pins RF_ADC_ALIASES_H */
X#if !1L  
S#define CY_PINS_RF_ADC_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define RF_ADC_0			(RF_ADC__0__PC)
S#define RF_ADC_0_PS		(RF_ADC__0__PS)
S#define RF_ADC_0_PC		(RF_ADC__0__PC)
S#define RF_ADC_0_DR		(RF_ADC__0__DR)
S#define RF_ADC_0_SHIFT	(RF_ADC__0__SHIFT)
S#define RF_ADC_0_INTR	((uint16)((uint16)0x0003u << (RF_ADC__0__SHIFT*2u)))
S
S#define RF_ADC_INTR_ALL	 ((uint16)(RF_ADC_0_INTR))
S
S
N#endif /* End Pins RF_ADC_ALIASES_H */
N
N
N/* [] END OF FILE */
L 78 "Generated_Source\PSoC4\project.h" 2
N#include "VOICE_BUSY.h"
L 1 "Generated_Source\PSoC4\VOICE_BUSY.h" 1
N/*******************************************************************************
N* File Name: VOICE_BUSY.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_VOICE_BUSY_H) /* Pins VOICE_BUSY_H */
X#if !1L  
S#define CY_PINS_VOICE_BUSY_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "VOICE_BUSY_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} VOICE_BUSY_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   VOICE_BUSY_Read(void);
Svoid    VOICE_BUSY_Write(uint8 value);
Suint8   VOICE_BUSY_ReadDataReg(void);
S#if defined(VOICE_BUSY__PC) || (CY_PSOC4_4200L) 
S    void    VOICE_BUSY_SetDriveMode(uint8 mode);
S#endif
Svoid    VOICE_BUSY_SetInterruptMode(uint16 position, uint16 mode);
Suint8   VOICE_BUSY_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid VOICE_BUSY_Sleep(void); 
Svoid VOICE_BUSY_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(VOICE_BUSY__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define VOICE_BUSY_DRIVE_MODE_BITS        (3)
S    #define VOICE_BUSY_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - VOICE_BUSY_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the VOICE_BUSY_SetDriveMode() function.
S         *  @{
S         */
S        #define VOICE_BUSY_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define VOICE_BUSY_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define VOICE_BUSY_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define VOICE_BUSY_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define VOICE_BUSY_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define VOICE_BUSY_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define VOICE_BUSY_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define VOICE_BUSY_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define VOICE_BUSY_MASK               VOICE_BUSY__MASK
S#define VOICE_BUSY_SHIFT              VOICE_BUSY__SHIFT
S#define VOICE_BUSY_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in VOICE_BUSY_SetInterruptMode() function.
S     *  @{
S     */
S        #define VOICE_BUSY_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define VOICE_BUSY_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define VOICE_BUSY_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define VOICE_BUSY_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(VOICE_BUSY__SIO)
S    #define VOICE_BUSY_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(VOICE_BUSY__PC) && (CY_PSOC4_4200L)
S    #define VOICE_BUSY_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define VOICE_BUSY_USBIO_DISABLE              ((uint32)(~VOICE_BUSY_USBIO_ENABLE))
S    #define VOICE_BUSY_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define VOICE_BUSY_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define VOICE_BUSY_USBIO_ENTER_SLEEP          ((uint32)((1u << VOICE_BUSY_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << VOICE_BUSY_USBIO_SUSPEND_DEL_SHIFT)))
X    #define VOICE_BUSY_USBIO_ENTER_SLEEP          ((uint32)((1u << VOICE_BUSY_USBIO_SUSPEND_SHIFT)                                                         | (1u << VOICE_BUSY_USBIO_SUSPEND_DEL_SHIFT)))
S    #define VOICE_BUSY_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << VOICE_BUSY_USBIO_SUSPEND_SHIFT)))
S    #define VOICE_BUSY_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << VOICE_BUSY_USBIO_SUSPEND_DEL_SHIFT)))
S    #define VOICE_BUSY_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(VOICE_BUSY__PC)
S    /* Port Configuration */
S    #define VOICE_BUSY_PC                 (* (reg32 *) VOICE_BUSY__PC)
S#endif
S/* Pin State */
S#define VOICE_BUSY_PS                     (* (reg32 *) VOICE_BUSY__PS)
S/* Data Register */
S#define VOICE_BUSY_DR                     (* (reg32 *) VOICE_BUSY__DR)
S/* Input Buffer Disable Override */
S#define VOICE_BUSY_INP_DIS                (* (reg32 *) VOICE_BUSY__PC2)
S
S/* Interrupt configuration Registers */
S#define VOICE_BUSY_INTCFG                 (* (reg32 *) VOICE_BUSY__INTCFG)
S#define VOICE_BUSY_INTSTAT                (* (reg32 *) VOICE_BUSY__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define VOICE_BUSY_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(VOICE_BUSY__SIO)
S    #define VOICE_BUSY_SIO_REG            (* (reg32 *) VOICE_BUSY__SIO)
S#endif /* (VOICE_BUSY__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(VOICE_BUSY__PC) && (CY_PSOC4_4200L)
S    #define VOICE_BUSY_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define VOICE_BUSY_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define VOICE_BUSY_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define VOICE_BUSY_DRIVE_MODE_SHIFT       (0x00u)
S#define VOICE_BUSY_DRIVE_MODE_MASK        (0x07u << VOICE_BUSY_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins VOICE_BUSY_H */
N
N
N/* [] END OF FILE */
L 79 "Generated_Source\PSoC4\project.h" 2
N#include "VOICE_BUSY_aliases.h"
L 1 "Generated_Source\PSoC4\VOICE_BUSY_aliases.h" 1
N/*******************************************************************************
N* File Name: VOICE_BUSY.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_VOICE_BUSY_ALIASES_H) /* Pins VOICE_BUSY_ALIASES_H */
X#if !1L  
S#define CY_PINS_VOICE_BUSY_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define VOICE_BUSY_0			(VOICE_BUSY__0__PC)
S#define VOICE_BUSY_0_PS		(VOICE_BUSY__0__PS)
S#define VOICE_BUSY_0_PC		(VOICE_BUSY__0__PC)
S#define VOICE_BUSY_0_DR		(VOICE_BUSY__0__DR)
S#define VOICE_BUSY_0_SHIFT	(VOICE_BUSY__0__SHIFT)
S#define VOICE_BUSY_0_INTR	((uint16)((uint16)0x0003u << (VOICE_BUSY__0__SHIFT*2u)))
S
S#define VOICE_BUSY_INTR_ALL	 ((uint16)(VOICE_BUSY_0_INTR))
S
S
N#endif /* End Pins VOICE_BUSY_ALIASES_H */
N
N
N/* [] END OF FILE */
L 80 "Generated_Source\PSoC4\project.h" 2
N#include "VOICE_DATA.h"
L 1 "Generated_Source\PSoC4\VOICE_DATA.h" 1
N/*******************************************************************************
N* File Name: VOICE_DATA.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_VOICE_DATA_H) /* Pins VOICE_DATA_H */
X#if !1L  
S#define CY_PINS_VOICE_DATA_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "VOICE_DATA_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} VOICE_DATA_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   VOICE_DATA_Read(void);
Svoid    VOICE_DATA_Write(uint8 value);
Suint8   VOICE_DATA_ReadDataReg(void);
S#if defined(VOICE_DATA__PC) || (CY_PSOC4_4200L) 
S    void    VOICE_DATA_SetDriveMode(uint8 mode);
S#endif
Svoid    VOICE_DATA_SetInterruptMode(uint16 position, uint16 mode);
Suint8   VOICE_DATA_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid VOICE_DATA_Sleep(void); 
Svoid VOICE_DATA_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(VOICE_DATA__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define VOICE_DATA_DRIVE_MODE_BITS        (3)
S    #define VOICE_DATA_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - VOICE_DATA_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the VOICE_DATA_SetDriveMode() function.
S         *  @{
S         */
S        #define VOICE_DATA_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define VOICE_DATA_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define VOICE_DATA_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define VOICE_DATA_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define VOICE_DATA_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define VOICE_DATA_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define VOICE_DATA_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define VOICE_DATA_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define VOICE_DATA_MASK               VOICE_DATA__MASK
S#define VOICE_DATA_SHIFT              VOICE_DATA__SHIFT
S#define VOICE_DATA_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in VOICE_DATA_SetInterruptMode() function.
S     *  @{
S     */
S        #define VOICE_DATA_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define VOICE_DATA_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define VOICE_DATA_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define VOICE_DATA_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(VOICE_DATA__SIO)
S    #define VOICE_DATA_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(VOICE_DATA__PC) && (CY_PSOC4_4200L)
S    #define VOICE_DATA_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define VOICE_DATA_USBIO_DISABLE              ((uint32)(~VOICE_DATA_USBIO_ENABLE))
S    #define VOICE_DATA_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define VOICE_DATA_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define VOICE_DATA_USBIO_ENTER_SLEEP          ((uint32)((1u << VOICE_DATA_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << VOICE_DATA_USBIO_SUSPEND_DEL_SHIFT)))
X    #define VOICE_DATA_USBIO_ENTER_SLEEP          ((uint32)((1u << VOICE_DATA_USBIO_SUSPEND_SHIFT)                                                         | (1u << VOICE_DATA_USBIO_SUSPEND_DEL_SHIFT)))
S    #define VOICE_DATA_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << VOICE_DATA_USBIO_SUSPEND_SHIFT)))
S    #define VOICE_DATA_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << VOICE_DATA_USBIO_SUSPEND_DEL_SHIFT)))
S    #define VOICE_DATA_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(VOICE_DATA__PC)
S    /* Port Configuration */
S    #define VOICE_DATA_PC                 (* (reg32 *) VOICE_DATA__PC)
S#endif
S/* Pin State */
S#define VOICE_DATA_PS                     (* (reg32 *) VOICE_DATA__PS)
S/* Data Register */
S#define VOICE_DATA_DR                     (* (reg32 *) VOICE_DATA__DR)
S/* Input Buffer Disable Override */
S#define VOICE_DATA_INP_DIS                (* (reg32 *) VOICE_DATA__PC2)
S
S/* Interrupt configuration Registers */
S#define VOICE_DATA_INTCFG                 (* (reg32 *) VOICE_DATA__INTCFG)
S#define VOICE_DATA_INTSTAT                (* (reg32 *) VOICE_DATA__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define VOICE_DATA_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(VOICE_DATA__SIO)
S    #define VOICE_DATA_SIO_REG            (* (reg32 *) VOICE_DATA__SIO)
S#endif /* (VOICE_DATA__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(VOICE_DATA__PC) && (CY_PSOC4_4200L)
S    #define VOICE_DATA_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define VOICE_DATA_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define VOICE_DATA_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define VOICE_DATA_DRIVE_MODE_SHIFT       (0x00u)
S#define VOICE_DATA_DRIVE_MODE_MASK        (0x07u << VOICE_DATA_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins VOICE_DATA_H */
N
N
N/* [] END OF FILE */
L 81 "Generated_Source\PSoC4\project.h" 2
N#include "VOICE_DATA_aliases.h"
L 1 "Generated_Source\PSoC4\VOICE_DATA_aliases.h" 1
N/*******************************************************************************
N* File Name: VOICE_DATA.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_VOICE_DATA_ALIASES_H) /* Pins VOICE_DATA_ALIASES_H */
X#if !1L  
S#define CY_PINS_VOICE_DATA_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define VOICE_DATA_0			(VOICE_DATA__0__PC)
S#define VOICE_DATA_0_PS		(VOICE_DATA__0__PS)
S#define VOICE_DATA_0_PC		(VOICE_DATA__0__PC)
S#define VOICE_DATA_0_DR		(VOICE_DATA__0__DR)
S#define VOICE_DATA_0_SHIFT	(VOICE_DATA__0__SHIFT)
S#define VOICE_DATA_0_INTR	((uint16)((uint16)0x0003u << (VOICE_DATA__0__SHIFT*2u)))
S
S#define VOICE_DATA_INTR_ALL	 ((uint16)(VOICE_DATA_0_INTR))
S
S
N#endif /* End Pins VOICE_DATA_ALIASES_H */
N
N
N/* [] END OF FILE */
L 82 "Generated_Source\PSoC4\project.h" 2
N#include "isr_1.h"
N#include "LOCK_INT.h"
L 1 "Generated_Source\PSoC4\LOCK_INT.h" 1
N/*******************************************************************************
N* File Name: LOCK_INT.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_LOCK_INT_H) /* Pins LOCK_INT_H */
X#if !1L  
S#define CY_PINS_LOCK_INT_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "LOCK_INT_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} LOCK_INT_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   LOCK_INT_Read(void);
Svoid    LOCK_INT_Write(uint8 value);
Suint8   LOCK_INT_ReadDataReg(void);
S#if defined(LOCK_INT__PC) || (CY_PSOC4_4200L) 
S    void    LOCK_INT_SetDriveMode(uint8 mode);
S#endif
Svoid    LOCK_INT_SetInterruptMode(uint16 position, uint16 mode);
Suint8   LOCK_INT_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid LOCK_INT_Sleep(void); 
Svoid LOCK_INT_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(LOCK_INT__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define LOCK_INT_DRIVE_MODE_BITS        (3)
S    #define LOCK_INT_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - LOCK_INT_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the LOCK_INT_SetDriveMode() function.
S         *  @{
S         */
S        #define LOCK_INT_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define LOCK_INT_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define LOCK_INT_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define LOCK_INT_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define LOCK_INT_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define LOCK_INT_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define LOCK_INT_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define LOCK_INT_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define LOCK_INT_MASK               LOCK_INT__MASK
S#define LOCK_INT_SHIFT              LOCK_INT__SHIFT
S#define LOCK_INT_WIDTH              4u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in LOCK_INT_SetInterruptMode() function.
S     *  @{
S     */
S        #define LOCK_INT_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define LOCK_INT_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define LOCK_INT_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define LOCK_INT_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(LOCK_INT__SIO)
S    #define LOCK_INT_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(LOCK_INT__PC) && (CY_PSOC4_4200L)
S    #define LOCK_INT_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define LOCK_INT_USBIO_DISABLE              ((uint32)(~LOCK_INT_USBIO_ENABLE))
S    #define LOCK_INT_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define LOCK_INT_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define LOCK_INT_USBIO_ENTER_SLEEP          ((uint32)((1u << LOCK_INT_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << LOCK_INT_USBIO_SUSPEND_DEL_SHIFT)))
X    #define LOCK_INT_USBIO_ENTER_SLEEP          ((uint32)((1u << LOCK_INT_USBIO_SUSPEND_SHIFT)                                                         | (1u << LOCK_INT_USBIO_SUSPEND_DEL_SHIFT)))
S    #define LOCK_INT_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << LOCK_INT_USBIO_SUSPEND_SHIFT)))
S    #define LOCK_INT_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << LOCK_INT_USBIO_SUSPEND_DEL_SHIFT)))
S    #define LOCK_INT_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(LOCK_INT__PC)
S    /* Port Configuration */
S    #define LOCK_INT_PC                 (* (reg32 *) LOCK_INT__PC)
S#endif
S/* Pin State */
S#define LOCK_INT_PS                     (* (reg32 *) LOCK_INT__PS)
S/* Data Register */
S#define LOCK_INT_DR                     (* (reg32 *) LOCK_INT__DR)
S/* Input Buffer Disable Override */
S#define LOCK_INT_INP_DIS                (* (reg32 *) LOCK_INT__PC2)
S
S/* Interrupt configuration Registers */
S#define LOCK_INT_INTCFG                 (* (reg32 *) LOCK_INT__INTCFG)
S#define LOCK_INT_INTSTAT                (* (reg32 *) LOCK_INT__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define LOCK_INT_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(LOCK_INT__SIO)
S    #define LOCK_INT_SIO_REG            (* (reg32 *) LOCK_INT__SIO)
S#endif /* (LOCK_INT__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(LOCK_INT__PC) && (CY_PSOC4_4200L)
S    #define LOCK_INT_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define LOCK_INT_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define LOCK_INT_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define LOCK_INT_DRIVE_MODE_SHIFT       (0x00u)
S#define LOCK_INT_DRIVE_MODE_MASK        (0x07u << LOCK_INT_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins LOCK_INT_H */
N
N
N/* [] END OF FILE */
L 84 "Generated_Source\PSoC4\project.h" 2
N#include "LOCK_INT_aliases.h"
L 1 "Generated_Source\PSoC4\LOCK_INT_aliases.h" 1
N/*******************************************************************************
N* File Name: LOCK_INT.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_LOCK_INT_ALIASES_H) /* Pins LOCK_INT_ALIASES_H */
X#if !1L  
S#define CY_PINS_LOCK_INT_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define LOCK_INT_0			(LOCK_INT__0__PC)
S#define LOCK_INT_0_PS		(LOCK_INT__0__PS)
S#define LOCK_INT_0_PC		(LOCK_INT__0__PC)
S#define LOCK_INT_0_DR		(LOCK_INT__0__DR)
S#define LOCK_INT_0_SHIFT	(LOCK_INT__0__SHIFT)
S#define LOCK_INT_0_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__0__SHIFT*2u)))
S
S#define LOCK_INT_1			(LOCK_INT__1__PC)
S#define LOCK_INT_1_PS		(LOCK_INT__1__PS)
S#define LOCK_INT_1_PC		(LOCK_INT__1__PC)
S#define LOCK_INT_1_DR		(LOCK_INT__1__DR)
S#define LOCK_INT_1_SHIFT	(LOCK_INT__1__SHIFT)
S#define LOCK_INT_1_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__1__SHIFT*2u)))
S
S#define LOCK_INT_2			(LOCK_INT__2__PC)
S#define LOCK_INT_2_PS		(LOCK_INT__2__PS)
S#define LOCK_INT_2_PC		(LOCK_INT__2__PC)
S#define LOCK_INT_2_DR		(LOCK_INT__2__DR)
S#define LOCK_INT_2_SHIFT	(LOCK_INT__2__SHIFT)
S#define LOCK_INT_2_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__2__SHIFT*2u)))
S
S#define LOCK_INT_3			(LOCK_INT__3__PC)
S#define LOCK_INT_3_PS		(LOCK_INT__3__PS)
S#define LOCK_INT_3_PC		(LOCK_INT__3__PC)
S#define LOCK_INT_3_DR		(LOCK_INT__3__DR)
S#define LOCK_INT_3_SHIFT	(LOCK_INT__3__SHIFT)
S#define LOCK_INT_3_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__3__SHIFT*2u)))
S
S#define LOCK_INT_INTR_ALL	 ((uint16)(LOCK_INT_0_INTR| LOCK_INT_1_INTR| LOCK_INT_2_INTR| LOCK_INT_3_INTR))
S#define LOCK_INT_OP2INT			(LOCK_INT__OP2INT__PC)
S#define LOCK_INT_OP2INT_PS		(LOCK_INT__OP2INT__PS)
S#define LOCK_INT_OP2INT_PC		(LOCK_INT__OP2INT__PC)
S#define LOCK_INT_OP2INT_DR		(LOCK_INT__OP2INT__DR)
S#define LOCK_INT_OP2INT_SHIFT	(LOCK_INT__OP2INT__SHIFT)
S#define LOCK_INT_OP2INT_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__0__SHIFT*2u)))
S
S#define LOCK_INT_LOCK_BNT_INT			(LOCK_INT__LOCK_BNT_INT__PC)
S#define LOCK_INT_LOCK_BNT_INT_PS		(LOCK_INT__LOCK_BNT_INT__PS)
S#define LOCK_INT_LOCK_BNT_INT_PC		(LOCK_INT__LOCK_BNT_INT__PC)
S#define LOCK_INT_LOCK_BNT_INT_DR		(LOCK_INT__LOCK_BNT_INT__DR)
S#define LOCK_INT_LOCK_BNT_INT_SHIFT	(LOCK_INT__LOCK_BNT_INT__SHIFT)
S#define LOCK_INT_LOCK_BNT_INT_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__1__SHIFT*2u)))
S
S#define LOCK_INT_LOCK_MODE_INT			(LOCK_INT__LOCK_MODE_INT__PC)
S#define LOCK_INT_LOCK_MODE_INT_PS		(LOCK_INT__LOCK_MODE_INT__PS)
S#define LOCK_INT_LOCK_MODE_INT_PC		(LOCK_INT__LOCK_MODE_INT__PC)
S#define LOCK_INT_LOCK_MODE_INT_DR		(LOCK_INT__LOCK_MODE_INT__DR)
S#define LOCK_INT_LOCK_MODE_INT_SHIFT	(LOCK_INT__LOCK_MODE_INT__SHIFT)
S#define LOCK_INT_LOCK_MODE_INT_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__2__SHIFT*2u)))
S
S#define LOCK_INT_LOCK_SLOT_INT			(LOCK_INT__LOCK_SLOT_INT__PC)
S#define LOCK_INT_LOCK_SLOT_INT_PS		(LOCK_INT__LOCK_SLOT_INT__PS)
S#define LOCK_INT_LOCK_SLOT_INT_PC		(LOCK_INT__LOCK_SLOT_INT__PC)
S#define LOCK_INT_LOCK_SLOT_INT_DR		(LOCK_INT__LOCK_SLOT_INT__DR)
S#define LOCK_INT_LOCK_SLOT_INT_SHIFT	(LOCK_INT__LOCK_SLOT_INT__SHIFT)
S#define LOCK_INT_LOCK_SLOT_INT_INTR	((uint16)((uint16)0x0003u << (LOCK_INT__3__SHIFT*2u)))
S
S
N#endif /* End Pins LOCK_INT_ALIASES_H */
N
N
N/* [] END OF FILE */
L 85 "Generated_Source\PSoC4\project.h" 2
N#include "GPIO_ISR1.h"
L 1 "Generated_Source\PSoC4\GPIO_ISR1.h" 1
N/*******************************************************************************
N* File Name: GPIO_ISR1.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_GPIO_ISR1_H) /* Pins GPIO_ISR1_H */
X#if !1L  
S#define CY_PINS_GPIO_ISR1_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "GPIO_ISR1_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} GPIO_ISR1_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   GPIO_ISR1_Read(void);
Svoid    GPIO_ISR1_Write(uint8 value);
Suint8   GPIO_ISR1_ReadDataReg(void);
S#if defined(GPIO_ISR1__PC) || (CY_PSOC4_4200L) 
S    void    GPIO_ISR1_SetDriveMode(uint8 mode);
S#endif
Svoid    GPIO_ISR1_SetInterruptMode(uint16 position, uint16 mode);
Suint8   GPIO_ISR1_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid GPIO_ISR1_Sleep(void); 
Svoid GPIO_ISR1_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(GPIO_ISR1__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define GPIO_ISR1_DRIVE_MODE_BITS        (3)
S    #define GPIO_ISR1_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - GPIO_ISR1_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the GPIO_ISR1_SetDriveMode() function.
S         *  @{
S         */
S        #define GPIO_ISR1_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define GPIO_ISR1_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define GPIO_ISR1_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define GPIO_ISR1_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define GPIO_ISR1_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define GPIO_ISR1_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define GPIO_ISR1_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define GPIO_ISR1_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define GPIO_ISR1_MASK               GPIO_ISR1__MASK
S#define GPIO_ISR1_SHIFT              GPIO_ISR1__SHIFT
S#define GPIO_ISR1_WIDTH              4u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in GPIO_ISR1_SetInterruptMode() function.
S     *  @{
S     */
S        #define GPIO_ISR1_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define GPIO_ISR1_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define GPIO_ISR1_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define GPIO_ISR1_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(GPIO_ISR1__SIO)
S    #define GPIO_ISR1_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(GPIO_ISR1__PC) && (CY_PSOC4_4200L)
S    #define GPIO_ISR1_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define GPIO_ISR1_USBIO_DISABLE              ((uint32)(~GPIO_ISR1_USBIO_ENABLE))
S    #define GPIO_ISR1_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define GPIO_ISR1_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define GPIO_ISR1_USBIO_ENTER_SLEEP          ((uint32)((1u << GPIO_ISR1_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << GPIO_ISR1_USBIO_SUSPEND_DEL_SHIFT)))
X    #define GPIO_ISR1_USBIO_ENTER_SLEEP          ((uint32)((1u << GPIO_ISR1_USBIO_SUSPEND_SHIFT)                                                         | (1u << GPIO_ISR1_USBIO_SUSPEND_DEL_SHIFT)))
S    #define GPIO_ISR1_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << GPIO_ISR1_USBIO_SUSPEND_SHIFT)))
S    #define GPIO_ISR1_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << GPIO_ISR1_USBIO_SUSPEND_DEL_SHIFT)))
S    #define GPIO_ISR1_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(GPIO_ISR1__PC)
S    /* Port Configuration */
S    #define GPIO_ISR1_PC                 (* (reg32 *) GPIO_ISR1__PC)
S#endif
S/* Pin State */
S#define GPIO_ISR1_PS                     (* (reg32 *) GPIO_ISR1__PS)
S/* Data Register */
S#define GPIO_ISR1_DR                     (* (reg32 *) GPIO_ISR1__DR)
S/* Input Buffer Disable Override */
S#define GPIO_ISR1_INP_DIS                (* (reg32 *) GPIO_ISR1__PC2)
S
S/* Interrupt configuration Registers */
S#define GPIO_ISR1_INTCFG                 (* (reg32 *) GPIO_ISR1__INTCFG)
S#define GPIO_ISR1_INTSTAT                (* (reg32 *) GPIO_ISR1__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define GPIO_ISR1_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(GPIO_ISR1__SIO)
S    #define GPIO_ISR1_SIO_REG            (* (reg32 *) GPIO_ISR1__SIO)
S#endif /* (GPIO_ISR1__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(GPIO_ISR1__PC) && (CY_PSOC4_4200L)
S    #define GPIO_ISR1_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define GPIO_ISR1_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define GPIO_ISR1_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define GPIO_ISR1_DRIVE_MODE_SHIFT       (0x00u)
S#define GPIO_ISR1_DRIVE_MODE_MASK        (0x07u << GPIO_ISR1_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins GPIO_ISR1_H */
N
N
N/* [] END OF FILE */
L 86 "Generated_Source\PSoC4\project.h" 2
N#include "GPIO_ISR1_aliases.h"
L 1 "Generated_Source\PSoC4\GPIO_ISR1_aliases.h" 1
N/*******************************************************************************
N* File Name: GPIO_ISR1.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_GPIO_ISR1_ALIASES_H) /* Pins GPIO_ISR1_ALIASES_H */
X#if !1L  
S#define CY_PINS_GPIO_ISR1_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define GPIO_ISR1_0			(GPIO_ISR1__0__PC)
S#define GPIO_ISR1_0_PS		(GPIO_ISR1__0__PS)
S#define GPIO_ISR1_0_PC		(GPIO_ISR1__0__PC)
S#define GPIO_ISR1_0_DR		(GPIO_ISR1__0__DR)
S#define GPIO_ISR1_0_SHIFT	(GPIO_ISR1__0__SHIFT)
S#define GPIO_ISR1_0_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__0__SHIFT*2u)))
S
S#define GPIO_ISR1_1			(GPIO_ISR1__1__PC)
S#define GPIO_ISR1_1_PS		(GPIO_ISR1__1__PS)
S#define GPIO_ISR1_1_PC		(GPIO_ISR1__1__PC)
S#define GPIO_ISR1_1_DR		(GPIO_ISR1__1__DR)
S#define GPIO_ISR1_1_SHIFT	(GPIO_ISR1__1__SHIFT)
S#define GPIO_ISR1_1_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__1__SHIFT*2u)))
S
S#define GPIO_ISR1_2			(GPIO_ISR1__2__PC)
S#define GPIO_ISR1_2_PS		(GPIO_ISR1__2__PS)
S#define GPIO_ISR1_2_PC		(GPIO_ISR1__2__PC)
S#define GPIO_ISR1_2_DR		(GPIO_ISR1__2__DR)
S#define GPIO_ISR1_2_SHIFT	(GPIO_ISR1__2__SHIFT)
S#define GPIO_ISR1_2_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__2__SHIFT*2u)))
S
S#define GPIO_ISR1_3			(GPIO_ISR1__3__PC)
S#define GPIO_ISR1_3_PS		(GPIO_ISR1__3__PS)
S#define GPIO_ISR1_3_PC		(GPIO_ISR1__3__PC)
S#define GPIO_ISR1_3_DR		(GPIO_ISR1__3__DR)
S#define GPIO_ISR1_3_SHIFT	(GPIO_ISR1__3__SHIFT)
S#define GPIO_ISR1_3_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__3__SHIFT*2u)))
S
S#define GPIO_ISR1_INTR_ALL	 ((uint16)(GPIO_ISR1_0_INTR| GPIO_ISR1_1_INTR| GPIO_ISR1_2_INTR| GPIO_ISR1_3_INTR))
S#define GPIO_ISR1_KEY_INT			(GPIO_ISR1__KEY_INT__PC)
S#define GPIO_ISR1_KEY_INT_PS		(GPIO_ISR1__KEY_INT__PS)
S#define GPIO_ISR1_KEY_INT_PC		(GPIO_ISR1__KEY_INT__PC)
S#define GPIO_ISR1_KEY_INT_DR		(GPIO_ISR1__KEY_INT__DR)
S#define GPIO_ISR1_KEY_INT_SHIFT	(GPIO_ISR1__KEY_INT__SHIFT)
S#define GPIO_ISR1_KEY_INT_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__0__SHIFT*2u)))
S
S#define GPIO_ISR1_EXT_UART_2_INT			(GPIO_ISR1__EXT_UART_2_INT__PC)
S#define GPIO_ISR1_EXT_UART_2_INT_PS		(GPIO_ISR1__EXT_UART_2_INT__PS)
S#define GPIO_ISR1_EXT_UART_2_INT_PC		(GPIO_ISR1__EXT_UART_2_INT__PC)
S#define GPIO_ISR1_EXT_UART_2_INT_DR		(GPIO_ISR1__EXT_UART_2_INT__DR)
S#define GPIO_ISR1_EXT_UART_2_INT_SHIFT	(GPIO_ISR1__EXT_UART_2_INT__SHIFT)
S#define GPIO_ISR1_EXT_UART_2_INT_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__1__SHIFT*2u)))
S
S#define GPIO_ISR1_BLE_INT			(GPIO_ISR1__BLE_INT__PC)
S#define GPIO_ISR1_BLE_INT_PS		(GPIO_ISR1__BLE_INT__PS)
S#define GPIO_ISR1_BLE_INT_PC		(GPIO_ISR1__BLE_INT__PC)
S#define GPIO_ISR1_BLE_INT_DR		(GPIO_ISR1__BLE_INT__DR)
S#define GPIO_ISR1_BLE_INT_SHIFT	(GPIO_ISR1__BLE_INT__SHIFT)
S#define GPIO_ISR1_BLE_INT_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__2__SHIFT*2u)))
S
S#define GPIO_ISR1_FPC_UART_0_INT			(GPIO_ISR1__FPC_UART_0_INT__PC)
S#define GPIO_ISR1_FPC_UART_0_INT_PS		(GPIO_ISR1__FPC_UART_0_INT__PS)
S#define GPIO_ISR1_FPC_UART_0_INT_PC		(GPIO_ISR1__FPC_UART_0_INT__PC)
S#define GPIO_ISR1_FPC_UART_0_INT_DR		(GPIO_ISR1__FPC_UART_0_INT__DR)
S#define GPIO_ISR1_FPC_UART_0_INT_SHIFT	(GPIO_ISR1__FPC_UART_0_INT__SHIFT)
S#define GPIO_ISR1_FPC_UART_0_INT_INTR	((uint16)((uint16)0x0003u << (GPIO_ISR1__3__SHIFT*2u)))
S
S
N#endif /* End Pins GPIO_ISR1_ALIASES_H */
N
N
N/* [] END OF FILE */
L 87 "Generated_Source\PSoC4\project.h" 2
N#include "isr_2.h"
N#include "OP3_INT.h"
L 1 "Generated_Source\PSoC4\OP3_INT.h" 1
N/*******************************************************************************
N* File Name: OP3_INT.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_OP3_INT_H) /* Pins OP3_INT_H */
X#if !1L  
S#define CY_PINS_OP3_INT_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "OP3_INT_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} OP3_INT_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   OP3_INT_Read(void);
Svoid    OP3_INT_Write(uint8 value);
Suint8   OP3_INT_ReadDataReg(void);
S#if defined(OP3_INT__PC) || (CY_PSOC4_4200L) 
S    void    OP3_INT_SetDriveMode(uint8 mode);
S#endif
Svoid    OP3_INT_SetInterruptMode(uint16 position, uint16 mode);
Suint8   OP3_INT_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid OP3_INT_Sleep(void); 
Svoid OP3_INT_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(OP3_INT__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define OP3_INT_DRIVE_MODE_BITS        (3)
S    #define OP3_INT_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - OP3_INT_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the OP3_INT_SetDriveMode() function.
S         *  @{
S         */
S        #define OP3_INT_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define OP3_INT_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define OP3_INT_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define OP3_INT_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define OP3_INT_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define OP3_INT_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define OP3_INT_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define OP3_INT_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define OP3_INT_MASK               OP3_INT__MASK
S#define OP3_INT_SHIFT              OP3_INT__SHIFT
S#define OP3_INT_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in OP3_INT_SetInterruptMode() function.
S     *  @{
S     */
S        #define OP3_INT_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define OP3_INT_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define OP3_INT_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define OP3_INT_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(OP3_INT__SIO)
S    #define OP3_INT_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(OP3_INT__PC) && (CY_PSOC4_4200L)
S    #define OP3_INT_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define OP3_INT_USBIO_DISABLE              ((uint32)(~OP3_INT_USBIO_ENABLE))
S    #define OP3_INT_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define OP3_INT_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define OP3_INT_USBIO_ENTER_SLEEP          ((uint32)((1u << OP3_INT_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << OP3_INT_USBIO_SUSPEND_DEL_SHIFT)))
X    #define OP3_INT_USBIO_ENTER_SLEEP          ((uint32)((1u << OP3_INT_USBIO_SUSPEND_SHIFT)                                                         | (1u << OP3_INT_USBIO_SUSPEND_DEL_SHIFT)))
S    #define OP3_INT_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << OP3_INT_USBIO_SUSPEND_SHIFT)))
S    #define OP3_INT_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << OP3_INT_USBIO_SUSPEND_DEL_SHIFT)))
S    #define OP3_INT_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(OP3_INT__PC)
S    /* Port Configuration */
S    #define OP3_INT_PC                 (* (reg32 *) OP3_INT__PC)
S#endif
S/* Pin State */
S#define OP3_INT_PS                     (* (reg32 *) OP3_INT__PS)
S/* Data Register */
S#define OP3_INT_DR                     (* (reg32 *) OP3_INT__DR)
S/* Input Buffer Disable Override */
S#define OP3_INT_INP_DIS                (* (reg32 *) OP3_INT__PC2)
S
S/* Interrupt configuration Registers */
S#define OP3_INT_INTCFG                 (* (reg32 *) OP3_INT__INTCFG)
S#define OP3_INT_INTSTAT                (* (reg32 *) OP3_INT__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define OP3_INT_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(OP3_INT__SIO)
S    #define OP3_INT_SIO_REG            (* (reg32 *) OP3_INT__SIO)
S#endif /* (OP3_INT__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(OP3_INT__PC) && (CY_PSOC4_4200L)
S    #define OP3_INT_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define OP3_INT_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define OP3_INT_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define OP3_INT_DRIVE_MODE_SHIFT       (0x00u)
S#define OP3_INT_DRIVE_MODE_MASK        (0x07u << OP3_INT_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins OP3_INT_H */
N
N
N/* [] END OF FILE */
L 89 "Generated_Source\PSoC4\project.h" 2
N#include "OP3_INT_aliases.h"
L 1 "Generated_Source\PSoC4\OP3_INT_aliases.h" 1
N/*******************************************************************************
N* File Name: OP3_INT.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_OP3_INT_ALIASES_H) /* Pins OP3_INT_ALIASES_H */
X#if !1L  
S#define CY_PINS_OP3_INT_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define OP3_INT_0			(OP3_INT__0__PC)
S#define OP3_INT_0_PS		(OP3_INT__0__PS)
S#define OP3_INT_0_PC		(OP3_INT__0__PC)
S#define OP3_INT_0_DR		(OP3_INT__0__DR)
S#define OP3_INT_0_SHIFT	(OP3_INT__0__SHIFT)
S#define OP3_INT_0_INTR	((uint16)((uint16)0x0003u << (OP3_INT__0__SHIFT*2u)))
S
S#define OP3_INT_INTR_ALL	 ((uint16)(OP3_INT_0_INTR))
S
S
N#endif /* End Pins OP3_INT_ALIASES_H */
N
N
N/* [] END OF FILE */
L 90 "Generated_Source\PSoC4\project.h" 2
N#include "OP1_INT.h"
L 1 "Generated_Source\PSoC4\OP1_INT.h" 1
N/*******************************************************************************
N* File Name: OP1_INT.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_OP1_INT_H) /* Pins OP1_INT_H */
X#if !1L  
S#define CY_PINS_OP1_INT_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "OP1_INT_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} OP1_INT_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   OP1_INT_Read(void);
Svoid    OP1_INT_Write(uint8 value);
Suint8   OP1_INT_ReadDataReg(void);
S#if defined(OP1_INT__PC) || (CY_PSOC4_4200L) 
S    void    OP1_INT_SetDriveMode(uint8 mode);
S#endif
Svoid    OP1_INT_SetInterruptMode(uint16 position, uint16 mode);
Suint8   OP1_INT_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid OP1_INT_Sleep(void); 
Svoid OP1_INT_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(OP1_INT__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define OP1_INT_DRIVE_MODE_BITS        (3)
S    #define OP1_INT_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - OP1_INT_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the OP1_INT_SetDriveMode() function.
S         *  @{
S         */
S        #define OP1_INT_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define OP1_INT_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define OP1_INT_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define OP1_INT_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define OP1_INT_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define OP1_INT_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define OP1_INT_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define OP1_INT_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define OP1_INT_MASK               OP1_INT__MASK
S#define OP1_INT_SHIFT              OP1_INT__SHIFT
S#define OP1_INT_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in OP1_INT_SetInterruptMode() function.
S     *  @{
S     */
S        #define OP1_INT_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define OP1_INT_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define OP1_INT_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define OP1_INT_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(OP1_INT__SIO)
S    #define OP1_INT_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(OP1_INT__PC) && (CY_PSOC4_4200L)
S    #define OP1_INT_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define OP1_INT_USBIO_DISABLE              ((uint32)(~OP1_INT_USBIO_ENABLE))
S    #define OP1_INT_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define OP1_INT_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define OP1_INT_USBIO_ENTER_SLEEP          ((uint32)((1u << OP1_INT_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << OP1_INT_USBIO_SUSPEND_DEL_SHIFT)))
X    #define OP1_INT_USBIO_ENTER_SLEEP          ((uint32)((1u << OP1_INT_USBIO_SUSPEND_SHIFT)                                                         | (1u << OP1_INT_USBIO_SUSPEND_DEL_SHIFT)))
S    #define OP1_INT_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << OP1_INT_USBIO_SUSPEND_SHIFT)))
S    #define OP1_INT_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << OP1_INT_USBIO_SUSPEND_DEL_SHIFT)))
S    #define OP1_INT_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(OP1_INT__PC)
S    /* Port Configuration */
S    #define OP1_INT_PC                 (* (reg32 *) OP1_INT__PC)
S#endif
S/* Pin State */
S#define OP1_INT_PS                     (* (reg32 *) OP1_INT__PS)
S/* Data Register */
S#define OP1_INT_DR                     (* (reg32 *) OP1_INT__DR)
S/* Input Buffer Disable Override */
S#define OP1_INT_INP_DIS                (* (reg32 *) OP1_INT__PC2)
S
S/* Interrupt configuration Registers */
S#define OP1_INT_INTCFG                 (* (reg32 *) OP1_INT__INTCFG)
S#define OP1_INT_INTSTAT                (* (reg32 *) OP1_INT__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define OP1_INT_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(OP1_INT__SIO)
S    #define OP1_INT_SIO_REG            (* (reg32 *) OP1_INT__SIO)
S#endif /* (OP1_INT__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(OP1_INT__PC) && (CY_PSOC4_4200L)
S    #define OP1_INT_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define OP1_INT_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define OP1_INT_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define OP1_INT_DRIVE_MODE_SHIFT       (0x00u)
S#define OP1_INT_DRIVE_MODE_MASK        (0x07u << OP1_INT_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins OP1_INT_H */
N
N
N/* [] END OF FILE */
L 91 "Generated_Source\PSoC4\project.h" 2
N#include "OP1_INT_aliases.h"
L 1 "Generated_Source\PSoC4\OP1_INT_aliases.h" 1
N/*******************************************************************************
N* File Name: OP1_INT.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_OP1_INT_ALIASES_H) /* Pins OP1_INT_ALIASES_H */
X#if !1L  
S#define CY_PINS_OP1_INT_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define OP1_INT_0			(OP1_INT__0__PC)
S#define OP1_INT_0_PS		(OP1_INT__0__PS)
S#define OP1_INT_0_PC		(OP1_INT__0__PC)
S#define OP1_INT_0_DR		(OP1_INT__0__DR)
S#define OP1_INT_0_SHIFT	(OP1_INT__0__SHIFT)
S#define OP1_INT_0_INTR	((uint16)((uint16)0x0003u << (OP1_INT__0__SHIFT*2u)))
S
S#define OP1_INT_INTR_ALL	 ((uint16)(OP1_INT_0_INTR))
S
S
N#endif /* End Pins OP1_INT_ALIASES_H */
N
N
N/* [] END OF FILE */
L 92 "Generated_Source\PSoC4\project.h" 2
N#include "COVER_CHK_INT.h"
L 1 "Generated_Source\PSoC4\COVER_CHK_INT.h" 1
N/*******************************************************************************
N* File Name: COVER_CHK_INT.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_COVER_CHK_INT_H) /* Pins COVER_CHK_INT_H */
X#if !1L  
S#define CY_PINS_COVER_CHK_INT_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "COVER_CHK_INT_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} COVER_CHK_INT_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   COVER_CHK_INT_Read(void);
Svoid    COVER_CHK_INT_Write(uint8 value);
Suint8   COVER_CHK_INT_ReadDataReg(void);
S#if defined(COVER_CHK_INT__PC) || (CY_PSOC4_4200L) 
S    void    COVER_CHK_INT_SetDriveMode(uint8 mode);
S#endif
Svoid    COVER_CHK_INT_SetInterruptMode(uint16 position, uint16 mode);
Suint8   COVER_CHK_INT_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid COVER_CHK_INT_Sleep(void); 
Svoid COVER_CHK_INT_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(COVER_CHK_INT__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define COVER_CHK_INT_DRIVE_MODE_BITS        (3)
S    #define COVER_CHK_INT_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - COVER_CHK_INT_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the COVER_CHK_INT_SetDriveMode() function.
S         *  @{
S         */
S        #define COVER_CHK_INT_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define COVER_CHK_INT_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define COVER_CHK_INT_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define COVER_CHK_INT_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define COVER_CHK_INT_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define COVER_CHK_INT_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define COVER_CHK_INT_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define COVER_CHK_INT_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define COVER_CHK_INT_MASK               COVER_CHK_INT__MASK
S#define COVER_CHK_INT_SHIFT              COVER_CHK_INT__SHIFT
S#define COVER_CHK_INT_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in COVER_CHK_INT_SetInterruptMode() function.
S     *  @{
S     */
S        #define COVER_CHK_INT_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define COVER_CHK_INT_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define COVER_CHK_INT_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define COVER_CHK_INT_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(COVER_CHK_INT__SIO)
S    #define COVER_CHK_INT_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(COVER_CHK_INT__PC) && (CY_PSOC4_4200L)
S    #define COVER_CHK_INT_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define COVER_CHK_INT_USBIO_DISABLE              ((uint32)(~COVER_CHK_INT_USBIO_ENABLE))
S    #define COVER_CHK_INT_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define COVER_CHK_INT_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define COVER_CHK_INT_USBIO_ENTER_SLEEP          ((uint32)((1u << COVER_CHK_INT_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << COVER_CHK_INT_USBIO_SUSPEND_DEL_SHIFT)))
X    #define COVER_CHK_INT_USBIO_ENTER_SLEEP          ((uint32)((1u << COVER_CHK_INT_USBIO_SUSPEND_SHIFT)                                                         | (1u << COVER_CHK_INT_USBIO_SUSPEND_DEL_SHIFT)))
S    #define COVER_CHK_INT_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << COVER_CHK_INT_USBIO_SUSPEND_SHIFT)))
S    #define COVER_CHK_INT_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << COVER_CHK_INT_USBIO_SUSPEND_DEL_SHIFT)))
S    #define COVER_CHK_INT_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(COVER_CHK_INT__PC)
S    /* Port Configuration */
S    #define COVER_CHK_INT_PC                 (* (reg32 *) COVER_CHK_INT__PC)
S#endif
S/* Pin State */
S#define COVER_CHK_INT_PS                     (* (reg32 *) COVER_CHK_INT__PS)
S/* Data Register */
S#define COVER_CHK_INT_DR                     (* (reg32 *) COVER_CHK_INT__DR)
S/* Input Buffer Disable Override */
S#define COVER_CHK_INT_INP_DIS                (* (reg32 *) COVER_CHK_INT__PC2)
S
S/* Interrupt configuration Registers */
S#define COVER_CHK_INT_INTCFG                 (* (reg32 *) COVER_CHK_INT__INTCFG)
S#define COVER_CHK_INT_INTSTAT                (* (reg32 *) COVER_CHK_INT__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define COVER_CHK_INT_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(COVER_CHK_INT__SIO)
S    #define COVER_CHK_INT_SIO_REG            (* (reg32 *) COVER_CHK_INT__SIO)
S#endif /* (COVER_CHK_INT__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(COVER_CHK_INT__PC) && (CY_PSOC4_4200L)
S    #define COVER_CHK_INT_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define COVER_CHK_INT_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define COVER_CHK_INT_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define COVER_CHK_INT_DRIVE_MODE_SHIFT       (0x00u)
S#define COVER_CHK_INT_DRIVE_MODE_MASK        (0x07u << COVER_CHK_INT_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins COVER_CHK_INT_H */
N
N
N/* [] END OF FILE */
L 93 "Generated_Source\PSoC4\project.h" 2
N#include "COVER_CHK_INT_aliases.h"
L 1 "Generated_Source\PSoC4\COVER_CHK_INT_aliases.h" 1
N/*******************************************************************************
N* File Name: COVER_CHK_INT.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_COVER_CHK_INT_ALIASES_H) /* Pins COVER_CHK_INT_ALIASES_H */
X#if !1L  
S#define CY_PINS_COVER_CHK_INT_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define COVER_CHK_INT_0			(COVER_CHK_INT__0__PC)
S#define COVER_CHK_INT_0_PS		(COVER_CHK_INT__0__PS)
S#define COVER_CHK_INT_0_PC		(COVER_CHK_INT__0__PC)
S#define COVER_CHK_INT_0_DR		(COVER_CHK_INT__0__DR)
S#define COVER_CHK_INT_0_SHIFT	(COVER_CHK_INT__0__SHIFT)
S#define COVER_CHK_INT_0_INTR	((uint16)((uint16)0x0003u << (COVER_CHK_INT__0__SHIFT*2u)))
S
S#define COVER_CHK_INT_INTR_ALL	 ((uint16)(COVER_CHK_INT_0_INTR))
S
S
N#endif /* End Pins COVER_CHK_INT_ALIASES_H */
N
N
N/* [] END OF FILE */
L 94 "Generated_Source\PSoC4\project.h" 2
N#include "isr_wdt.h"
N#include "RTC_1.h"
N#include "Em_EEPROM.h"
N#include "Opamp_Rf.h"
N#include "Opamp_Bat.h"
N#include "TEST.h"
L 1 "Generated_Source\PSoC4\TEST.h" 1
N/*******************************************************************************
N* File Name: TEST.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_TEST_H) /* Pins TEST_H */
X#if !1L  
S#define CY_PINS_TEST_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "TEST_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} TEST_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   TEST_Read(void);
Svoid    TEST_Write(uint8 value);
Suint8   TEST_ReadDataReg(void);
S#if defined(TEST__PC) || (CY_PSOC4_4200L) 
S    void    TEST_SetDriveMode(uint8 mode);
S#endif
Svoid    TEST_SetInterruptMode(uint16 position, uint16 mode);
Suint8   TEST_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid TEST_Sleep(void); 
Svoid TEST_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(TEST__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define TEST_DRIVE_MODE_BITS        (3)
S    #define TEST_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - TEST_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the TEST_SetDriveMode() function.
S         *  @{
S         */
S        #define TEST_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define TEST_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define TEST_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define TEST_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define TEST_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define TEST_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define TEST_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define TEST_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define TEST_MASK               TEST__MASK
S#define TEST_SHIFT              TEST__SHIFT
S#define TEST_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in TEST_SetInterruptMode() function.
S     *  @{
S     */
S        #define TEST_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define TEST_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define TEST_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define TEST_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(TEST__SIO)
S    #define TEST_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(TEST__PC) && (CY_PSOC4_4200L)
S    #define TEST_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define TEST_USBIO_DISABLE              ((uint32)(~TEST_USBIO_ENABLE))
S    #define TEST_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define TEST_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define TEST_USBIO_ENTER_SLEEP          ((uint32)((1u << TEST_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << TEST_USBIO_SUSPEND_DEL_SHIFT)))
X    #define TEST_USBIO_ENTER_SLEEP          ((uint32)((1u << TEST_USBIO_SUSPEND_SHIFT)                                                         | (1u << TEST_USBIO_SUSPEND_DEL_SHIFT)))
S    #define TEST_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << TEST_USBIO_SUSPEND_SHIFT)))
S    #define TEST_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << TEST_USBIO_SUSPEND_DEL_SHIFT)))
S    #define TEST_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(TEST__PC)
S    /* Port Configuration */
S    #define TEST_PC                 (* (reg32 *) TEST__PC)
S#endif
S/* Pin State */
S#define TEST_PS                     (* (reg32 *) TEST__PS)
S/* Data Register */
S#define TEST_DR                     (* (reg32 *) TEST__DR)
S/* Input Buffer Disable Override */
S#define TEST_INP_DIS                (* (reg32 *) TEST__PC2)
S
S/* Interrupt configuration Registers */
S#define TEST_INTCFG                 (* (reg32 *) TEST__INTCFG)
S#define TEST_INTSTAT                (* (reg32 *) TEST__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define TEST_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(TEST__SIO)
S    #define TEST_SIO_REG            (* (reg32 *) TEST__SIO)
S#endif /* (TEST__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(TEST__PC) && (CY_PSOC4_4200L)
S    #define TEST_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define TEST_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define TEST_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define TEST_DRIVE_MODE_SHIFT       (0x00u)
S#define TEST_DRIVE_MODE_MASK        (0x07u << TEST_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins TEST_H */
N
N
N/* [] END OF FILE */
L 100 "Generated_Source\PSoC4\project.h" 2
N#include "TEST_aliases.h"
L 1 "Generated_Source\PSoC4\TEST_aliases.h" 1
N/*******************************************************************************
N* File Name: TEST.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_TEST_ALIASES_H) /* Pins TEST_ALIASES_H */
X#if !1L  
S#define CY_PINS_TEST_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define TEST_0			(TEST__0__PC)
S#define TEST_0_PS		(TEST__0__PS)
S#define TEST_0_PC		(TEST__0__PC)
S#define TEST_0_DR		(TEST__0__DR)
S#define TEST_0_SHIFT	(TEST__0__SHIFT)
S#define TEST_0_INTR	((uint16)((uint16)0x0003u << (TEST__0__SHIFT*2u)))
S
S#define TEST_INTR_ALL	 ((uint16)(TEST_0_INTR))
S
S
N#endif /* End Pins TEST_ALIASES_H */
N
N
N/* [] END OF FILE */
L 101 "Generated_Source\PSoC4\project.h" 2
N#include "UART_1_BLE_SCBCLK.h"
N#include "UART_1_BLE_tx.h"
L 1 "Generated_Source\PSoC4\UART_1_BLE_tx.h" 1
N/*******************************************************************************
N* File Name: UART_1_BLE_tx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_1_BLE_tx_H) /* Pins UART_1_BLE_tx_H */
X#if !1L  
S#define CY_PINS_UART_1_BLE_tx_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "UART_1_BLE_tx_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} UART_1_BLE_tx_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   UART_1_BLE_tx_Read(void);
Svoid    UART_1_BLE_tx_Write(uint8 value);
Suint8   UART_1_BLE_tx_ReadDataReg(void);
S#if defined(UART_1_BLE_tx__PC) || (CY_PSOC4_4200L) 
S    void    UART_1_BLE_tx_SetDriveMode(uint8 mode);
S#endif
Svoid    UART_1_BLE_tx_SetInterruptMode(uint16 position, uint16 mode);
Suint8   UART_1_BLE_tx_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid UART_1_BLE_tx_Sleep(void); 
Svoid UART_1_BLE_tx_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(UART_1_BLE_tx__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define UART_1_BLE_tx_DRIVE_MODE_BITS        (3)
S    #define UART_1_BLE_tx_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - UART_1_BLE_tx_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the UART_1_BLE_tx_SetDriveMode() function.
S         *  @{
S         */
S        #define UART_1_BLE_tx_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define UART_1_BLE_tx_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define UART_1_BLE_tx_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define UART_1_BLE_tx_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define UART_1_BLE_tx_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define UART_1_BLE_tx_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define UART_1_BLE_tx_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define UART_1_BLE_tx_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define UART_1_BLE_tx_MASK               UART_1_BLE_tx__MASK
S#define UART_1_BLE_tx_SHIFT              UART_1_BLE_tx__SHIFT
S#define UART_1_BLE_tx_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in UART_1_BLE_tx_SetInterruptMode() function.
S     *  @{
S     */
S        #define UART_1_BLE_tx_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define UART_1_BLE_tx_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define UART_1_BLE_tx_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define UART_1_BLE_tx_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(UART_1_BLE_tx__SIO)
S    #define UART_1_BLE_tx_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(UART_1_BLE_tx__PC) && (CY_PSOC4_4200L)
S    #define UART_1_BLE_tx_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define UART_1_BLE_tx_USBIO_DISABLE              ((uint32)(~UART_1_BLE_tx_USBIO_ENABLE))
S    #define UART_1_BLE_tx_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define UART_1_BLE_tx_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define UART_1_BLE_tx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_1_BLE_tx_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << UART_1_BLE_tx_USBIO_SUSPEND_DEL_SHIFT)))
X    #define UART_1_BLE_tx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_1_BLE_tx_USBIO_SUSPEND_SHIFT)                                                         | (1u << UART_1_BLE_tx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_1_BLE_tx_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << UART_1_BLE_tx_USBIO_SUSPEND_SHIFT)))
S    #define UART_1_BLE_tx_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << UART_1_BLE_tx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_1_BLE_tx_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(UART_1_BLE_tx__PC)
S    /* Port Configuration */
S    #define UART_1_BLE_tx_PC                 (* (reg32 *) UART_1_BLE_tx__PC)
S#endif
S/* Pin State */
S#define UART_1_BLE_tx_PS                     (* (reg32 *) UART_1_BLE_tx__PS)
S/* Data Register */
S#define UART_1_BLE_tx_DR                     (* (reg32 *) UART_1_BLE_tx__DR)
S/* Input Buffer Disable Override */
S#define UART_1_BLE_tx_INP_DIS                (* (reg32 *) UART_1_BLE_tx__PC2)
S
S/* Interrupt configuration Registers */
S#define UART_1_BLE_tx_INTCFG                 (* (reg32 *) UART_1_BLE_tx__INTCFG)
S#define UART_1_BLE_tx_INTSTAT                (* (reg32 *) UART_1_BLE_tx__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define UART_1_BLE_tx_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(UART_1_BLE_tx__SIO)
S    #define UART_1_BLE_tx_SIO_REG            (* (reg32 *) UART_1_BLE_tx__SIO)
S#endif /* (UART_1_BLE_tx__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(UART_1_BLE_tx__PC) && (CY_PSOC4_4200L)
S    #define UART_1_BLE_tx_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define UART_1_BLE_tx_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define UART_1_BLE_tx_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define UART_1_BLE_tx_DRIVE_MODE_SHIFT       (0x00u)
S#define UART_1_BLE_tx_DRIVE_MODE_MASK        (0x07u << UART_1_BLE_tx_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins UART_1_BLE_tx_H */
N
N
N/* [] END OF FILE */
L 103 "Generated_Source\PSoC4\project.h" 2
N#include "UART_1_BLE_tx_aliases.h"
L 1 "Generated_Source\PSoC4\UART_1_BLE_tx_aliases.h" 1
N/*******************************************************************************
N* File Name: UART_1_BLE_tx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_1_BLE_tx_ALIASES_H) /* Pins UART_1_BLE_tx_ALIASES_H */
X#if !1L  
S#define CY_PINS_UART_1_BLE_tx_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define UART_1_BLE_tx_0			(UART_1_BLE_tx__0__PC)
S#define UART_1_BLE_tx_0_PS		(UART_1_BLE_tx__0__PS)
S#define UART_1_BLE_tx_0_PC		(UART_1_BLE_tx__0__PC)
S#define UART_1_BLE_tx_0_DR		(UART_1_BLE_tx__0__DR)
S#define UART_1_BLE_tx_0_SHIFT	(UART_1_BLE_tx__0__SHIFT)
S#define UART_1_BLE_tx_0_INTR	((uint16)((uint16)0x0003u << (UART_1_BLE_tx__0__SHIFT*2u)))
S
S#define UART_1_BLE_tx_INTR_ALL	 ((uint16)(UART_1_BLE_tx_0_INTR))
S
S
N#endif /* End Pins UART_1_BLE_tx_ALIASES_H */
N
N
N/* [] END OF FILE */
L 104 "Generated_Source\PSoC4\project.h" 2
N#include "UART_1_BLE_SCB_IRQ.h"
N#include "UART_1_BLE_rx.h"
L 1 "Generated_Source\PSoC4\UART_1_BLE_rx.h" 1
N/*******************************************************************************
N* File Name: UART_1_BLE_rx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_1_BLE_rx_H) /* Pins UART_1_BLE_rx_H */
X#if !1L  
S#define CY_PINS_UART_1_BLE_rx_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "UART_1_BLE_rx_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} UART_1_BLE_rx_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   UART_1_BLE_rx_Read(void);
Svoid    UART_1_BLE_rx_Write(uint8 value);
Suint8   UART_1_BLE_rx_ReadDataReg(void);
S#if defined(UART_1_BLE_rx__PC) || (CY_PSOC4_4200L) 
S    void    UART_1_BLE_rx_SetDriveMode(uint8 mode);
S#endif
Svoid    UART_1_BLE_rx_SetInterruptMode(uint16 position, uint16 mode);
Suint8   UART_1_BLE_rx_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid UART_1_BLE_rx_Sleep(void); 
Svoid UART_1_BLE_rx_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(UART_1_BLE_rx__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define UART_1_BLE_rx_DRIVE_MODE_BITS        (3)
S    #define UART_1_BLE_rx_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - UART_1_BLE_rx_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the UART_1_BLE_rx_SetDriveMode() function.
S         *  @{
S         */
S        #define UART_1_BLE_rx_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define UART_1_BLE_rx_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define UART_1_BLE_rx_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define UART_1_BLE_rx_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define UART_1_BLE_rx_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define UART_1_BLE_rx_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define UART_1_BLE_rx_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define UART_1_BLE_rx_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define UART_1_BLE_rx_MASK               UART_1_BLE_rx__MASK
S#define UART_1_BLE_rx_SHIFT              UART_1_BLE_rx__SHIFT
S#define UART_1_BLE_rx_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in UART_1_BLE_rx_SetInterruptMode() function.
S     *  @{
S     */
S        #define UART_1_BLE_rx_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define UART_1_BLE_rx_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define UART_1_BLE_rx_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define UART_1_BLE_rx_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(UART_1_BLE_rx__SIO)
S    #define UART_1_BLE_rx_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(UART_1_BLE_rx__PC) && (CY_PSOC4_4200L)
S    #define UART_1_BLE_rx_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define UART_1_BLE_rx_USBIO_DISABLE              ((uint32)(~UART_1_BLE_rx_USBIO_ENABLE))
S    #define UART_1_BLE_rx_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define UART_1_BLE_rx_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define UART_1_BLE_rx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_1_BLE_rx_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << UART_1_BLE_rx_USBIO_SUSPEND_DEL_SHIFT)))
X    #define UART_1_BLE_rx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_1_BLE_rx_USBIO_SUSPEND_SHIFT)                                                         | (1u << UART_1_BLE_rx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_1_BLE_rx_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << UART_1_BLE_rx_USBIO_SUSPEND_SHIFT)))
S    #define UART_1_BLE_rx_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << UART_1_BLE_rx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_1_BLE_rx_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(UART_1_BLE_rx__PC)
S    /* Port Configuration */
S    #define UART_1_BLE_rx_PC                 (* (reg32 *) UART_1_BLE_rx__PC)
S#endif
S/* Pin State */
S#define UART_1_BLE_rx_PS                     (* (reg32 *) UART_1_BLE_rx__PS)
S/* Data Register */
S#define UART_1_BLE_rx_DR                     (* (reg32 *) UART_1_BLE_rx__DR)
S/* Input Buffer Disable Override */
S#define UART_1_BLE_rx_INP_DIS                (* (reg32 *) UART_1_BLE_rx__PC2)
S
S/* Interrupt configuration Registers */
S#define UART_1_BLE_rx_INTCFG                 (* (reg32 *) UART_1_BLE_rx__INTCFG)
S#define UART_1_BLE_rx_INTSTAT                (* (reg32 *) UART_1_BLE_rx__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define UART_1_BLE_rx_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(UART_1_BLE_rx__SIO)
S    #define UART_1_BLE_rx_SIO_REG            (* (reg32 *) UART_1_BLE_rx__SIO)
S#endif /* (UART_1_BLE_rx__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(UART_1_BLE_rx__PC) && (CY_PSOC4_4200L)
S    #define UART_1_BLE_rx_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define UART_1_BLE_rx_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define UART_1_BLE_rx_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define UART_1_BLE_rx_DRIVE_MODE_SHIFT       (0x00u)
S#define UART_1_BLE_rx_DRIVE_MODE_MASK        (0x07u << UART_1_BLE_rx_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins UART_1_BLE_rx_H */
N
N
N/* [] END OF FILE */
L 106 "Generated_Source\PSoC4\project.h" 2
N#include "UART_1_BLE_rx_aliases.h"
L 1 "Generated_Source\PSoC4\UART_1_BLE_rx_aliases.h" 1
N/*******************************************************************************
N* File Name: UART_1_BLE_rx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_1_BLE_rx_ALIASES_H) /* Pins UART_1_BLE_rx_ALIASES_H */
X#if !1L  
S#define CY_PINS_UART_1_BLE_rx_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define UART_1_BLE_rx_0			(UART_1_BLE_rx__0__PC)
S#define UART_1_BLE_rx_0_PS		(UART_1_BLE_rx__0__PS)
S#define UART_1_BLE_rx_0_PC		(UART_1_BLE_rx__0__PC)
S#define UART_1_BLE_rx_0_DR		(UART_1_BLE_rx__0__DR)
S#define UART_1_BLE_rx_0_SHIFT	(UART_1_BLE_rx__0__SHIFT)
S#define UART_1_BLE_rx_0_INTR	((uint16)((uint16)0x0003u << (UART_1_BLE_rx__0__SHIFT*2u)))
S
S#define UART_1_BLE_rx_INTR_ALL	 ((uint16)(UART_1_BLE_rx_0_INTR))
S
S
N#endif /* End Pins UART_1_BLE_rx_ALIASES_H */
N
N
N/* [] END OF FILE */
L 107 "Generated_Source\PSoC4\project.h" 2
N#include "UART_0_FPC_SCBCLK.h"
N#include "UART_0_FPC_tx.h"
L 1 "Generated_Source\PSoC4\UART_0_FPC_tx.h" 1
N/*******************************************************************************
N* File Name: UART_0_FPC_tx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_0_FPC_tx_H) /* Pins UART_0_FPC_tx_H */
X#if !1L  
S#define CY_PINS_UART_0_FPC_tx_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "UART_0_FPC_tx_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} UART_0_FPC_tx_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   UART_0_FPC_tx_Read(void);
Svoid    UART_0_FPC_tx_Write(uint8 value);
Suint8   UART_0_FPC_tx_ReadDataReg(void);
S#if defined(UART_0_FPC_tx__PC) || (CY_PSOC4_4200L) 
S    void    UART_0_FPC_tx_SetDriveMode(uint8 mode);
S#endif
Svoid    UART_0_FPC_tx_SetInterruptMode(uint16 position, uint16 mode);
Suint8   UART_0_FPC_tx_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid UART_0_FPC_tx_Sleep(void); 
Svoid UART_0_FPC_tx_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(UART_0_FPC_tx__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define UART_0_FPC_tx_DRIVE_MODE_BITS        (3)
S    #define UART_0_FPC_tx_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - UART_0_FPC_tx_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the UART_0_FPC_tx_SetDriveMode() function.
S         *  @{
S         */
S        #define UART_0_FPC_tx_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define UART_0_FPC_tx_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define UART_0_FPC_tx_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define UART_0_FPC_tx_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define UART_0_FPC_tx_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define UART_0_FPC_tx_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define UART_0_FPC_tx_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define UART_0_FPC_tx_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define UART_0_FPC_tx_MASK               UART_0_FPC_tx__MASK
S#define UART_0_FPC_tx_SHIFT              UART_0_FPC_tx__SHIFT
S#define UART_0_FPC_tx_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in UART_0_FPC_tx_SetInterruptMode() function.
S     *  @{
S     */
S        #define UART_0_FPC_tx_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define UART_0_FPC_tx_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define UART_0_FPC_tx_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define UART_0_FPC_tx_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(UART_0_FPC_tx__SIO)
S    #define UART_0_FPC_tx_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(UART_0_FPC_tx__PC) && (CY_PSOC4_4200L)
S    #define UART_0_FPC_tx_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define UART_0_FPC_tx_USBIO_DISABLE              ((uint32)(~UART_0_FPC_tx_USBIO_ENABLE))
S    #define UART_0_FPC_tx_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define UART_0_FPC_tx_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define UART_0_FPC_tx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_0_FPC_tx_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << UART_0_FPC_tx_USBIO_SUSPEND_DEL_SHIFT)))
X    #define UART_0_FPC_tx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_0_FPC_tx_USBIO_SUSPEND_SHIFT)                                                         | (1u << UART_0_FPC_tx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_0_FPC_tx_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << UART_0_FPC_tx_USBIO_SUSPEND_SHIFT)))
S    #define UART_0_FPC_tx_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << UART_0_FPC_tx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_0_FPC_tx_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(UART_0_FPC_tx__PC)
S    /* Port Configuration */
S    #define UART_0_FPC_tx_PC                 (* (reg32 *) UART_0_FPC_tx__PC)
S#endif
S/* Pin State */
S#define UART_0_FPC_tx_PS                     (* (reg32 *) UART_0_FPC_tx__PS)
S/* Data Register */
S#define UART_0_FPC_tx_DR                     (* (reg32 *) UART_0_FPC_tx__DR)
S/* Input Buffer Disable Override */
S#define UART_0_FPC_tx_INP_DIS                (* (reg32 *) UART_0_FPC_tx__PC2)
S
S/* Interrupt configuration Registers */
S#define UART_0_FPC_tx_INTCFG                 (* (reg32 *) UART_0_FPC_tx__INTCFG)
S#define UART_0_FPC_tx_INTSTAT                (* (reg32 *) UART_0_FPC_tx__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define UART_0_FPC_tx_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(UART_0_FPC_tx__SIO)
S    #define UART_0_FPC_tx_SIO_REG            (* (reg32 *) UART_0_FPC_tx__SIO)
S#endif /* (UART_0_FPC_tx__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(UART_0_FPC_tx__PC) && (CY_PSOC4_4200L)
S    #define UART_0_FPC_tx_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define UART_0_FPC_tx_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define UART_0_FPC_tx_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define UART_0_FPC_tx_DRIVE_MODE_SHIFT       (0x00u)
S#define UART_0_FPC_tx_DRIVE_MODE_MASK        (0x07u << UART_0_FPC_tx_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins UART_0_FPC_tx_H */
N
N
N/* [] END OF FILE */
L 109 "Generated_Source\PSoC4\project.h" 2
N#include "UART_0_FPC_tx_aliases.h"
L 1 "Generated_Source\PSoC4\UART_0_FPC_tx_aliases.h" 1
N/*******************************************************************************
N* File Name: UART_0_FPC_tx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_0_FPC_tx_ALIASES_H) /* Pins UART_0_FPC_tx_ALIASES_H */
X#if !1L  
S#define CY_PINS_UART_0_FPC_tx_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define UART_0_FPC_tx_0			(UART_0_FPC_tx__0__PC)
S#define UART_0_FPC_tx_0_PS		(UART_0_FPC_tx__0__PS)
S#define UART_0_FPC_tx_0_PC		(UART_0_FPC_tx__0__PC)
S#define UART_0_FPC_tx_0_DR		(UART_0_FPC_tx__0__DR)
S#define UART_0_FPC_tx_0_SHIFT	(UART_0_FPC_tx__0__SHIFT)
S#define UART_0_FPC_tx_0_INTR	((uint16)((uint16)0x0003u << (UART_0_FPC_tx__0__SHIFT*2u)))
S
S#define UART_0_FPC_tx_INTR_ALL	 ((uint16)(UART_0_FPC_tx_0_INTR))
S
S
N#endif /* End Pins UART_0_FPC_tx_ALIASES_H */
N
N
N/* [] END OF FILE */
L 110 "Generated_Source\PSoC4\project.h" 2
N#include "UART_0_FPC_SCB_IRQ.h"
N#include "UART_0_FPC_rx.h"
L 1 "Generated_Source\PSoC4\UART_0_FPC_rx.h" 1
N/*******************************************************************************
N* File Name: UART_0_FPC_rx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_0_FPC_rx_H) /* Pins UART_0_FPC_rx_H */
X#if !1L  
S#define CY_PINS_UART_0_FPC_rx_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "UART_0_FPC_rx_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} UART_0_FPC_rx_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   UART_0_FPC_rx_Read(void);
Svoid    UART_0_FPC_rx_Write(uint8 value);
Suint8   UART_0_FPC_rx_ReadDataReg(void);
S#if defined(UART_0_FPC_rx__PC) || (CY_PSOC4_4200L) 
S    void    UART_0_FPC_rx_SetDriveMode(uint8 mode);
S#endif
Svoid    UART_0_FPC_rx_SetInterruptMode(uint16 position, uint16 mode);
Suint8   UART_0_FPC_rx_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid UART_0_FPC_rx_Sleep(void); 
Svoid UART_0_FPC_rx_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(UART_0_FPC_rx__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define UART_0_FPC_rx_DRIVE_MODE_BITS        (3)
S    #define UART_0_FPC_rx_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - UART_0_FPC_rx_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the UART_0_FPC_rx_SetDriveMode() function.
S         *  @{
S         */
S        #define UART_0_FPC_rx_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define UART_0_FPC_rx_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define UART_0_FPC_rx_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define UART_0_FPC_rx_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define UART_0_FPC_rx_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define UART_0_FPC_rx_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define UART_0_FPC_rx_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define UART_0_FPC_rx_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define UART_0_FPC_rx_MASK               UART_0_FPC_rx__MASK
S#define UART_0_FPC_rx_SHIFT              UART_0_FPC_rx__SHIFT
S#define UART_0_FPC_rx_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in UART_0_FPC_rx_SetInterruptMode() function.
S     *  @{
S     */
S        #define UART_0_FPC_rx_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define UART_0_FPC_rx_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define UART_0_FPC_rx_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define UART_0_FPC_rx_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(UART_0_FPC_rx__SIO)
S    #define UART_0_FPC_rx_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(UART_0_FPC_rx__PC) && (CY_PSOC4_4200L)
S    #define UART_0_FPC_rx_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define UART_0_FPC_rx_USBIO_DISABLE              ((uint32)(~UART_0_FPC_rx_USBIO_ENABLE))
S    #define UART_0_FPC_rx_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define UART_0_FPC_rx_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define UART_0_FPC_rx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_0_FPC_rx_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << UART_0_FPC_rx_USBIO_SUSPEND_DEL_SHIFT)))
X    #define UART_0_FPC_rx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_0_FPC_rx_USBIO_SUSPEND_SHIFT)                                                         | (1u << UART_0_FPC_rx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_0_FPC_rx_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << UART_0_FPC_rx_USBIO_SUSPEND_SHIFT)))
S    #define UART_0_FPC_rx_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << UART_0_FPC_rx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_0_FPC_rx_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(UART_0_FPC_rx__PC)
S    /* Port Configuration */
S    #define UART_0_FPC_rx_PC                 (* (reg32 *) UART_0_FPC_rx__PC)
S#endif
S/* Pin State */
S#define UART_0_FPC_rx_PS                     (* (reg32 *) UART_0_FPC_rx__PS)
S/* Data Register */
S#define UART_0_FPC_rx_DR                     (* (reg32 *) UART_0_FPC_rx__DR)
S/* Input Buffer Disable Override */
S#define UART_0_FPC_rx_INP_DIS                (* (reg32 *) UART_0_FPC_rx__PC2)
S
S/* Interrupt configuration Registers */
S#define UART_0_FPC_rx_INTCFG                 (* (reg32 *) UART_0_FPC_rx__INTCFG)
S#define UART_0_FPC_rx_INTSTAT                (* (reg32 *) UART_0_FPC_rx__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define UART_0_FPC_rx_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(UART_0_FPC_rx__SIO)
S    #define UART_0_FPC_rx_SIO_REG            (* (reg32 *) UART_0_FPC_rx__SIO)
S#endif /* (UART_0_FPC_rx__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(UART_0_FPC_rx__PC) && (CY_PSOC4_4200L)
S    #define UART_0_FPC_rx_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define UART_0_FPC_rx_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define UART_0_FPC_rx_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define UART_0_FPC_rx_DRIVE_MODE_SHIFT       (0x00u)
S#define UART_0_FPC_rx_DRIVE_MODE_MASK        (0x07u << UART_0_FPC_rx_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins UART_0_FPC_rx_H */
N
N
N/* [] END OF FILE */
L 112 "Generated_Source\PSoC4\project.h" 2
N#include "UART_0_FPC_rx_aliases.h"
L 1 "Generated_Source\PSoC4\UART_0_FPC_rx_aliases.h" 1
N/*******************************************************************************
N* File Name: UART_0_FPC_rx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_0_FPC_rx_ALIASES_H) /* Pins UART_0_FPC_rx_ALIASES_H */
X#if !1L  
S#define CY_PINS_UART_0_FPC_rx_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define UART_0_FPC_rx_0			(UART_0_FPC_rx__0__PC)
S#define UART_0_FPC_rx_0_PS		(UART_0_FPC_rx__0__PS)
S#define UART_0_FPC_rx_0_PC		(UART_0_FPC_rx__0__PC)
S#define UART_0_FPC_rx_0_DR		(UART_0_FPC_rx__0__DR)
S#define UART_0_FPC_rx_0_SHIFT	(UART_0_FPC_rx__0__SHIFT)
S#define UART_0_FPC_rx_0_INTR	((uint16)((uint16)0x0003u << (UART_0_FPC_rx__0__SHIFT*2u)))
S
S#define UART_0_FPC_rx_INTR_ALL	 ((uint16)(UART_0_FPC_rx_0_INTR))
S
S
N#endif /* End Pins UART_0_FPC_rx_ALIASES_H */
N
N
N/* [] END OF FILE */
L 113 "Generated_Source\PSoC4\project.h" 2
N#include "UART_2_EXT_SCBCLK.h"
N#include "UART_2_EXT_tx.h"
L 1 "Generated_Source\PSoC4\UART_2_EXT_tx.h" 1
N/*******************************************************************************
N* File Name: UART_2_EXT_tx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_2_EXT_tx_H) /* Pins UART_2_EXT_tx_H */
X#if !1L  
S#define CY_PINS_UART_2_EXT_tx_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "UART_2_EXT_tx_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} UART_2_EXT_tx_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   UART_2_EXT_tx_Read(void);
Svoid    UART_2_EXT_tx_Write(uint8 value);
Suint8   UART_2_EXT_tx_ReadDataReg(void);
S#if defined(UART_2_EXT_tx__PC) || (CY_PSOC4_4200L) 
S    void    UART_2_EXT_tx_SetDriveMode(uint8 mode);
S#endif
Svoid    UART_2_EXT_tx_SetInterruptMode(uint16 position, uint16 mode);
Suint8   UART_2_EXT_tx_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid UART_2_EXT_tx_Sleep(void); 
Svoid UART_2_EXT_tx_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(UART_2_EXT_tx__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define UART_2_EXT_tx_DRIVE_MODE_BITS        (3)
S    #define UART_2_EXT_tx_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - UART_2_EXT_tx_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the UART_2_EXT_tx_SetDriveMode() function.
S         *  @{
S         */
S        #define UART_2_EXT_tx_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define UART_2_EXT_tx_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define UART_2_EXT_tx_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define UART_2_EXT_tx_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define UART_2_EXT_tx_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define UART_2_EXT_tx_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define UART_2_EXT_tx_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define UART_2_EXT_tx_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define UART_2_EXT_tx_MASK               UART_2_EXT_tx__MASK
S#define UART_2_EXT_tx_SHIFT              UART_2_EXT_tx__SHIFT
S#define UART_2_EXT_tx_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in UART_2_EXT_tx_SetInterruptMode() function.
S     *  @{
S     */
S        #define UART_2_EXT_tx_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define UART_2_EXT_tx_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define UART_2_EXT_tx_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define UART_2_EXT_tx_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(UART_2_EXT_tx__SIO)
S    #define UART_2_EXT_tx_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(UART_2_EXT_tx__PC) && (CY_PSOC4_4200L)
S    #define UART_2_EXT_tx_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define UART_2_EXT_tx_USBIO_DISABLE              ((uint32)(~UART_2_EXT_tx_USBIO_ENABLE))
S    #define UART_2_EXT_tx_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define UART_2_EXT_tx_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define UART_2_EXT_tx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_2_EXT_tx_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << UART_2_EXT_tx_USBIO_SUSPEND_DEL_SHIFT)))
X    #define UART_2_EXT_tx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_2_EXT_tx_USBIO_SUSPEND_SHIFT)                                                         | (1u << UART_2_EXT_tx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_2_EXT_tx_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << UART_2_EXT_tx_USBIO_SUSPEND_SHIFT)))
S    #define UART_2_EXT_tx_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << UART_2_EXT_tx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_2_EXT_tx_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(UART_2_EXT_tx__PC)
S    /* Port Configuration */
S    #define UART_2_EXT_tx_PC                 (* (reg32 *) UART_2_EXT_tx__PC)
S#endif
S/* Pin State */
S#define UART_2_EXT_tx_PS                     (* (reg32 *) UART_2_EXT_tx__PS)
S/* Data Register */
S#define UART_2_EXT_tx_DR                     (* (reg32 *) UART_2_EXT_tx__DR)
S/* Input Buffer Disable Override */
S#define UART_2_EXT_tx_INP_DIS                (* (reg32 *) UART_2_EXT_tx__PC2)
S
S/* Interrupt configuration Registers */
S#define UART_2_EXT_tx_INTCFG                 (* (reg32 *) UART_2_EXT_tx__INTCFG)
S#define UART_2_EXT_tx_INTSTAT                (* (reg32 *) UART_2_EXT_tx__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define UART_2_EXT_tx_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(UART_2_EXT_tx__SIO)
S    #define UART_2_EXT_tx_SIO_REG            (* (reg32 *) UART_2_EXT_tx__SIO)
S#endif /* (UART_2_EXT_tx__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(UART_2_EXT_tx__PC) && (CY_PSOC4_4200L)
S    #define UART_2_EXT_tx_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define UART_2_EXT_tx_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define UART_2_EXT_tx_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define UART_2_EXT_tx_DRIVE_MODE_SHIFT       (0x00u)
S#define UART_2_EXT_tx_DRIVE_MODE_MASK        (0x07u << UART_2_EXT_tx_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins UART_2_EXT_tx_H */
N
N
N/* [] END OF FILE */
L 115 "Generated_Source\PSoC4\project.h" 2
N#include "UART_2_EXT_tx_aliases.h"
L 1 "Generated_Source\PSoC4\UART_2_EXT_tx_aliases.h" 1
N/*******************************************************************************
N* File Name: UART_2_EXT_tx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_2_EXT_tx_ALIASES_H) /* Pins UART_2_EXT_tx_ALIASES_H */
X#if !1L  
S#define CY_PINS_UART_2_EXT_tx_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define UART_2_EXT_tx_0			(UART_2_EXT_tx__0__PC)
S#define UART_2_EXT_tx_0_PS		(UART_2_EXT_tx__0__PS)
S#define UART_2_EXT_tx_0_PC		(UART_2_EXT_tx__0__PC)
S#define UART_2_EXT_tx_0_DR		(UART_2_EXT_tx__0__DR)
S#define UART_2_EXT_tx_0_SHIFT	(UART_2_EXT_tx__0__SHIFT)
S#define UART_2_EXT_tx_0_INTR	((uint16)((uint16)0x0003u << (UART_2_EXT_tx__0__SHIFT*2u)))
S
S#define UART_2_EXT_tx_INTR_ALL	 ((uint16)(UART_2_EXT_tx_0_INTR))
S
S
N#endif /* End Pins UART_2_EXT_tx_ALIASES_H */
N
N
N/* [] END OF FILE */
L 116 "Generated_Source\PSoC4\project.h" 2
N#include "UART_2_EXT_SCB_IRQ.h"
N#include "UART_2_EXT_rx.h"
L 1 "Generated_Source\PSoC4\UART_2_EXT_rx.h" 1
N/*******************************************************************************
N* File Name: UART_2_EXT_rx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_2_EXT_rx_H) /* Pins UART_2_EXT_rx_H */
X#if !1L  
S#define CY_PINS_UART_2_EXT_rx_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "UART_2_EXT_rx_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} UART_2_EXT_rx_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   UART_2_EXT_rx_Read(void);
Svoid    UART_2_EXT_rx_Write(uint8 value);
Suint8   UART_2_EXT_rx_ReadDataReg(void);
S#if defined(UART_2_EXT_rx__PC) || (CY_PSOC4_4200L) 
S    void    UART_2_EXT_rx_SetDriveMode(uint8 mode);
S#endif
Svoid    UART_2_EXT_rx_SetInterruptMode(uint16 position, uint16 mode);
Suint8   UART_2_EXT_rx_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid UART_2_EXT_rx_Sleep(void); 
Svoid UART_2_EXT_rx_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(UART_2_EXT_rx__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define UART_2_EXT_rx_DRIVE_MODE_BITS        (3)
S    #define UART_2_EXT_rx_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - UART_2_EXT_rx_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the UART_2_EXT_rx_SetDriveMode() function.
S         *  @{
S         */
S        #define UART_2_EXT_rx_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define UART_2_EXT_rx_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define UART_2_EXT_rx_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define UART_2_EXT_rx_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define UART_2_EXT_rx_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define UART_2_EXT_rx_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define UART_2_EXT_rx_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define UART_2_EXT_rx_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define UART_2_EXT_rx_MASK               UART_2_EXT_rx__MASK
S#define UART_2_EXT_rx_SHIFT              UART_2_EXT_rx__SHIFT
S#define UART_2_EXT_rx_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in UART_2_EXT_rx_SetInterruptMode() function.
S     *  @{
S     */
S        #define UART_2_EXT_rx_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define UART_2_EXT_rx_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define UART_2_EXT_rx_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define UART_2_EXT_rx_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(UART_2_EXT_rx__SIO)
S    #define UART_2_EXT_rx_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(UART_2_EXT_rx__PC) && (CY_PSOC4_4200L)
S    #define UART_2_EXT_rx_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define UART_2_EXT_rx_USBIO_DISABLE              ((uint32)(~UART_2_EXT_rx_USBIO_ENABLE))
S    #define UART_2_EXT_rx_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define UART_2_EXT_rx_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define UART_2_EXT_rx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_2_EXT_rx_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << UART_2_EXT_rx_USBIO_SUSPEND_DEL_SHIFT)))
X    #define UART_2_EXT_rx_USBIO_ENTER_SLEEP          ((uint32)((1u << UART_2_EXT_rx_USBIO_SUSPEND_SHIFT)                                                         | (1u << UART_2_EXT_rx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_2_EXT_rx_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << UART_2_EXT_rx_USBIO_SUSPEND_SHIFT)))
S    #define UART_2_EXT_rx_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << UART_2_EXT_rx_USBIO_SUSPEND_DEL_SHIFT)))
S    #define UART_2_EXT_rx_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(UART_2_EXT_rx__PC)
S    /* Port Configuration */
S    #define UART_2_EXT_rx_PC                 (* (reg32 *) UART_2_EXT_rx__PC)
S#endif
S/* Pin State */
S#define UART_2_EXT_rx_PS                     (* (reg32 *) UART_2_EXT_rx__PS)
S/* Data Register */
S#define UART_2_EXT_rx_DR                     (* (reg32 *) UART_2_EXT_rx__DR)
S/* Input Buffer Disable Override */
S#define UART_2_EXT_rx_INP_DIS                (* (reg32 *) UART_2_EXT_rx__PC2)
S
S/* Interrupt configuration Registers */
S#define UART_2_EXT_rx_INTCFG                 (* (reg32 *) UART_2_EXT_rx__INTCFG)
S#define UART_2_EXT_rx_INTSTAT                (* (reg32 *) UART_2_EXT_rx__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define UART_2_EXT_rx_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(UART_2_EXT_rx__SIO)
S    #define UART_2_EXT_rx_SIO_REG            (* (reg32 *) UART_2_EXT_rx__SIO)
S#endif /* (UART_2_EXT_rx__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(UART_2_EXT_rx__PC) && (CY_PSOC4_4200L)
S    #define UART_2_EXT_rx_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define UART_2_EXT_rx_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define UART_2_EXT_rx_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define UART_2_EXT_rx_DRIVE_MODE_SHIFT       (0x00u)
S#define UART_2_EXT_rx_DRIVE_MODE_MASK        (0x07u << UART_2_EXT_rx_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins UART_2_EXT_rx_H */
N
N
N/* [] END OF FILE */
L 118 "Generated_Source\PSoC4\project.h" 2
N#include "UART_2_EXT_rx_aliases.h"
L 1 "Generated_Source\PSoC4\UART_2_EXT_rx_aliases.h" 1
N/*******************************************************************************
N* File Name: UART_2_EXT_rx.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_2_EXT_rx_ALIASES_H) /* Pins UART_2_EXT_rx_ALIASES_H */
X#if !1L  
S#define CY_PINS_UART_2_EXT_rx_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define UART_2_EXT_rx_0			(UART_2_EXT_rx__0__PC)
S#define UART_2_EXT_rx_0_PS		(UART_2_EXT_rx__0__PS)
S#define UART_2_EXT_rx_0_PC		(UART_2_EXT_rx__0__PC)
S#define UART_2_EXT_rx_0_DR		(UART_2_EXT_rx__0__DR)
S#define UART_2_EXT_rx_0_SHIFT	(UART_2_EXT_rx__0__SHIFT)
S#define UART_2_EXT_rx_0_INTR	((uint16)((uint16)0x0003u << (UART_2_EXT_rx__0__SHIFT*2u)))
S
S#define UART_2_EXT_rx_INTR_ALL	 ((uint16)(UART_2_EXT_rx_0_INTR))
S
S
N#endif /* End Pins UART_2_EXT_rx_ALIASES_H */
N
N
N/* [] END OF FILE */
L 119 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_SCBCLK.h"
N#include "SPI_0_OLED_FLASH_ss1_m.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_ss1_m.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_ss1_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_ss1_m_H) /* Pins SPI_0_OLED_FLASH_ss1_m_H */
X#if !1L  
S#define CY_PINS_SPI_0_OLED_FLASH_ss1_m_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "SPI_0_OLED_FLASH_ss1_m_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} SPI_0_OLED_FLASH_ss1_m_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   SPI_0_OLED_FLASH_ss1_m_Read(void);
Svoid    SPI_0_OLED_FLASH_ss1_m_Write(uint8 value);
Suint8   SPI_0_OLED_FLASH_ss1_m_ReadDataReg(void);
S#if defined(SPI_0_OLED_FLASH_ss1_m__PC) || (CY_PSOC4_4200L) 
S    void    SPI_0_OLED_FLASH_ss1_m_SetDriveMode(uint8 mode);
S#endif
Svoid    SPI_0_OLED_FLASH_ss1_m_SetInterruptMode(uint16 position, uint16 mode);
Suint8   SPI_0_OLED_FLASH_ss1_m_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid SPI_0_OLED_FLASH_ss1_m_Sleep(void); 
Svoid SPI_0_OLED_FLASH_ss1_m_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(SPI_0_OLED_FLASH_ss1_m__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define SPI_0_OLED_FLASH_ss1_m_DRIVE_MODE_BITS        (3)
S    #define SPI_0_OLED_FLASH_ss1_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_0_OLED_FLASH_ss1_m_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the SPI_0_OLED_FLASH_ss1_m_SetDriveMode() function.
S         *  @{
S         */
S        #define SPI_0_OLED_FLASH_ss1_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define SPI_0_OLED_FLASH_ss1_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define SPI_0_OLED_FLASH_ss1_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define SPI_0_OLED_FLASH_ss1_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define SPI_0_OLED_FLASH_ss1_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define SPI_0_OLED_FLASH_ss1_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define SPI_0_OLED_FLASH_ss1_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define SPI_0_OLED_FLASH_ss1_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define SPI_0_OLED_FLASH_ss1_m_MASK               SPI_0_OLED_FLASH_ss1_m__MASK
S#define SPI_0_OLED_FLASH_ss1_m_SHIFT              SPI_0_OLED_FLASH_ss1_m__SHIFT
S#define SPI_0_OLED_FLASH_ss1_m_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in SPI_0_OLED_FLASH_ss1_m_SetInterruptMode() function.
S     *  @{
S     */
S        #define SPI_0_OLED_FLASH_ss1_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define SPI_0_OLED_FLASH_ss1_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define SPI_0_OLED_FLASH_ss1_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define SPI_0_OLED_FLASH_ss1_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(SPI_0_OLED_FLASH_ss1_m__SIO)
S    #define SPI_0_OLED_FLASH_ss1_m_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(SPI_0_OLED_FLASH_ss1_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_DISABLE              ((uint32)(~SPI_0_OLED_FLASH_ss1_m_USBIO_ENABLE))
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_0_OLED_FLASH_ss1_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_ss1_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(SPI_0_OLED_FLASH_ss1_m__PC)
S    /* Port Configuration */
S    #define SPI_0_OLED_FLASH_ss1_m_PC                 (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__PC)
S#endif
S/* Pin State */
S#define SPI_0_OLED_FLASH_ss1_m_PS                     (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__PS)
S/* Data Register */
S#define SPI_0_OLED_FLASH_ss1_m_DR                     (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__DR)
S/* Input Buffer Disable Override */
S#define SPI_0_OLED_FLASH_ss1_m_INP_DIS                (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__PC2)
S
S/* Interrupt configuration Registers */
S#define SPI_0_OLED_FLASH_ss1_m_INTCFG                 (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__INTCFG)
S#define SPI_0_OLED_FLASH_ss1_m_INTSTAT                (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define SPI_0_OLED_FLASH_ss1_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(SPI_0_OLED_FLASH_ss1_m__SIO)
S    #define SPI_0_OLED_FLASH_ss1_m_SIO_REG            (* (reg32 *) SPI_0_OLED_FLASH_ss1_m__SIO)
S#endif /* (SPI_0_OLED_FLASH_ss1_m__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(SPI_0_OLED_FLASH_ss1_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_0_OLED_FLASH_ss1_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_0_OLED_FLASH_ss1_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_0_OLED_FLASH_ss1_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define SPI_0_OLED_FLASH_ss1_m_DRIVE_MODE_SHIFT       (0x00u)
S#define SPI_0_OLED_FLASH_ss1_m_DRIVE_MODE_MASK        (0x07u << SPI_0_OLED_FLASH_ss1_m_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins SPI_0_OLED_FLASH_ss1_m_H */
N
N
N/* [] END OF FILE */
L 121 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_ss1_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_ss1_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_ss1_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_ss1_m_ALIASES_H) /* Pins SPI_0_OLED_FLASH_ss1_m_ALIASES_H */
X#if !1L  
S#define CY_PINS_SPI_0_OLED_FLASH_ss1_m_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define SPI_0_OLED_FLASH_ss1_m_0			(SPI_0_OLED_FLASH_ss1_m__0__PC)
S#define SPI_0_OLED_FLASH_ss1_m_0_PS		(SPI_0_OLED_FLASH_ss1_m__0__PS)
S#define SPI_0_OLED_FLASH_ss1_m_0_PC		(SPI_0_OLED_FLASH_ss1_m__0__PC)
S#define SPI_0_OLED_FLASH_ss1_m_0_DR		(SPI_0_OLED_FLASH_ss1_m__0__DR)
S#define SPI_0_OLED_FLASH_ss1_m_0_SHIFT	(SPI_0_OLED_FLASH_ss1_m__0__SHIFT)
S#define SPI_0_OLED_FLASH_ss1_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_0_OLED_FLASH_ss1_m__0__SHIFT*2u)))
S
S#define SPI_0_OLED_FLASH_ss1_m_INTR_ALL	 ((uint16)(SPI_0_OLED_FLASH_ss1_m_0_INTR))
S
S
N#endif /* End Pins SPI_0_OLED_FLASH_ss1_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 122 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_sclk_m.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_sclk_m.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_sclk_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_sclk_m_H) /* Pins SPI_0_OLED_FLASH_sclk_m_H */
X#if !1L  
S#define CY_PINS_SPI_0_OLED_FLASH_sclk_m_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "SPI_0_OLED_FLASH_sclk_m_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} SPI_0_OLED_FLASH_sclk_m_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   SPI_0_OLED_FLASH_sclk_m_Read(void);
Svoid    SPI_0_OLED_FLASH_sclk_m_Write(uint8 value);
Suint8   SPI_0_OLED_FLASH_sclk_m_ReadDataReg(void);
S#if defined(SPI_0_OLED_FLASH_sclk_m__PC) || (CY_PSOC4_4200L) 
S    void    SPI_0_OLED_FLASH_sclk_m_SetDriveMode(uint8 mode);
S#endif
Svoid    SPI_0_OLED_FLASH_sclk_m_SetInterruptMode(uint16 position, uint16 mode);
Suint8   SPI_0_OLED_FLASH_sclk_m_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid SPI_0_OLED_FLASH_sclk_m_Sleep(void); 
Svoid SPI_0_OLED_FLASH_sclk_m_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(SPI_0_OLED_FLASH_sclk_m__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define SPI_0_OLED_FLASH_sclk_m_DRIVE_MODE_BITS        (3)
S    #define SPI_0_OLED_FLASH_sclk_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_0_OLED_FLASH_sclk_m_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the SPI_0_OLED_FLASH_sclk_m_SetDriveMode() function.
S         *  @{
S         */
S        #define SPI_0_OLED_FLASH_sclk_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define SPI_0_OLED_FLASH_sclk_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define SPI_0_OLED_FLASH_sclk_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define SPI_0_OLED_FLASH_sclk_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define SPI_0_OLED_FLASH_sclk_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define SPI_0_OLED_FLASH_sclk_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define SPI_0_OLED_FLASH_sclk_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define SPI_0_OLED_FLASH_sclk_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define SPI_0_OLED_FLASH_sclk_m_MASK               SPI_0_OLED_FLASH_sclk_m__MASK
S#define SPI_0_OLED_FLASH_sclk_m_SHIFT              SPI_0_OLED_FLASH_sclk_m__SHIFT
S#define SPI_0_OLED_FLASH_sclk_m_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in SPI_0_OLED_FLASH_sclk_m_SetInterruptMode() function.
S     *  @{
S     */
S        #define SPI_0_OLED_FLASH_sclk_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define SPI_0_OLED_FLASH_sclk_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define SPI_0_OLED_FLASH_sclk_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define SPI_0_OLED_FLASH_sclk_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(SPI_0_OLED_FLASH_sclk_m__SIO)
S    #define SPI_0_OLED_FLASH_sclk_m_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(SPI_0_OLED_FLASH_sclk_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_DISABLE              ((uint32)(~SPI_0_OLED_FLASH_sclk_m_USBIO_ENABLE))
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_0_OLED_FLASH_sclk_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_sclk_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(SPI_0_OLED_FLASH_sclk_m__PC)
S    /* Port Configuration */
S    #define SPI_0_OLED_FLASH_sclk_m_PC                 (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__PC)
S#endif
S/* Pin State */
S#define SPI_0_OLED_FLASH_sclk_m_PS                     (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__PS)
S/* Data Register */
S#define SPI_0_OLED_FLASH_sclk_m_DR                     (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__DR)
S/* Input Buffer Disable Override */
S#define SPI_0_OLED_FLASH_sclk_m_INP_DIS                (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__PC2)
S
S/* Interrupt configuration Registers */
S#define SPI_0_OLED_FLASH_sclk_m_INTCFG                 (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__INTCFG)
S#define SPI_0_OLED_FLASH_sclk_m_INTSTAT                (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define SPI_0_OLED_FLASH_sclk_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(SPI_0_OLED_FLASH_sclk_m__SIO)
S    #define SPI_0_OLED_FLASH_sclk_m_SIO_REG            (* (reg32 *) SPI_0_OLED_FLASH_sclk_m__SIO)
S#endif /* (SPI_0_OLED_FLASH_sclk_m__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(SPI_0_OLED_FLASH_sclk_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_0_OLED_FLASH_sclk_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_0_OLED_FLASH_sclk_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_0_OLED_FLASH_sclk_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define SPI_0_OLED_FLASH_sclk_m_DRIVE_MODE_SHIFT       (0x00u)
S#define SPI_0_OLED_FLASH_sclk_m_DRIVE_MODE_MASK        (0x07u << SPI_0_OLED_FLASH_sclk_m_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins SPI_0_OLED_FLASH_sclk_m_H */
N
N
N/* [] END OF FILE */
L 123 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_sclk_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_sclk_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_sclk_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_sclk_m_ALIASES_H) /* Pins SPI_0_OLED_FLASH_sclk_m_ALIASES_H */
X#if !1L  
S#define CY_PINS_SPI_0_OLED_FLASH_sclk_m_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define SPI_0_OLED_FLASH_sclk_m_0			(SPI_0_OLED_FLASH_sclk_m__0__PC)
S#define SPI_0_OLED_FLASH_sclk_m_0_PS		(SPI_0_OLED_FLASH_sclk_m__0__PS)
S#define SPI_0_OLED_FLASH_sclk_m_0_PC		(SPI_0_OLED_FLASH_sclk_m__0__PC)
S#define SPI_0_OLED_FLASH_sclk_m_0_DR		(SPI_0_OLED_FLASH_sclk_m__0__DR)
S#define SPI_0_OLED_FLASH_sclk_m_0_SHIFT	(SPI_0_OLED_FLASH_sclk_m__0__SHIFT)
S#define SPI_0_OLED_FLASH_sclk_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_0_OLED_FLASH_sclk_m__0__SHIFT*2u)))
S
S#define SPI_0_OLED_FLASH_sclk_m_INTR_ALL	 ((uint16)(SPI_0_OLED_FLASH_sclk_m_0_INTR))
S
S
N#endif /* End Pins SPI_0_OLED_FLASH_sclk_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 124 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_miso_m.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_miso_m.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_miso_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_miso_m_H) /* Pins SPI_0_OLED_FLASH_miso_m_H */
X#if !1L  
S#define CY_PINS_SPI_0_OLED_FLASH_miso_m_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "SPI_0_OLED_FLASH_miso_m_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} SPI_0_OLED_FLASH_miso_m_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   SPI_0_OLED_FLASH_miso_m_Read(void);
Svoid    SPI_0_OLED_FLASH_miso_m_Write(uint8 value);
Suint8   SPI_0_OLED_FLASH_miso_m_ReadDataReg(void);
S#if defined(SPI_0_OLED_FLASH_miso_m__PC) || (CY_PSOC4_4200L) 
S    void    SPI_0_OLED_FLASH_miso_m_SetDriveMode(uint8 mode);
S#endif
Svoid    SPI_0_OLED_FLASH_miso_m_SetInterruptMode(uint16 position, uint16 mode);
Suint8   SPI_0_OLED_FLASH_miso_m_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid SPI_0_OLED_FLASH_miso_m_Sleep(void); 
Svoid SPI_0_OLED_FLASH_miso_m_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(SPI_0_OLED_FLASH_miso_m__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define SPI_0_OLED_FLASH_miso_m_DRIVE_MODE_BITS        (3)
S    #define SPI_0_OLED_FLASH_miso_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_0_OLED_FLASH_miso_m_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the SPI_0_OLED_FLASH_miso_m_SetDriveMode() function.
S         *  @{
S         */
S        #define SPI_0_OLED_FLASH_miso_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define SPI_0_OLED_FLASH_miso_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define SPI_0_OLED_FLASH_miso_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define SPI_0_OLED_FLASH_miso_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define SPI_0_OLED_FLASH_miso_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define SPI_0_OLED_FLASH_miso_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define SPI_0_OLED_FLASH_miso_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define SPI_0_OLED_FLASH_miso_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define SPI_0_OLED_FLASH_miso_m_MASK               SPI_0_OLED_FLASH_miso_m__MASK
S#define SPI_0_OLED_FLASH_miso_m_SHIFT              SPI_0_OLED_FLASH_miso_m__SHIFT
S#define SPI_0_OLED_FLASH_miso_m_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in SPI_0_OLED_FLASH_miso_m_SetInterruptMode() function.
S     *  @{
S     */
S        #define SPI_0_OLED_FLASH_miso_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define SPI_0_OLED_FLASH_miso_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define SPI_0_OLED_FLASH_miso_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define SPI_0_OLED_FLASH_miso_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(SPI_0_OLED_FLASH_miso_m__SIO)
S    #define SPI_0_OLED_FLASH_miso_m_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(SPI_0_OLED_FLASH_miso_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_DISABLE              ((uint32)(~SPI_0_OLED_FLASH_miso_m_USBIO_ENABLE))
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_0_OLED_FLASH_miso_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_miso_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(SPI_0_OLED_FLASH_miso_m__PC)
S    /* Port Configuration */
S    #define SPI_0_OLED_FLASH_miso_m_PC                 (* (reg32 *) SPI_0_OLED_FLASH_miso_m__PC)
S#endif
S/* Pin State */
S#define SPI_0_OLED_FLASH_miso_m_PS                     (* (reg32 *) SPI_0_OLED_FLASH_miso_m__PS)
S/* Data Register */
S#define SPI_0_OLED_FLASH_miso_m_DR                     (* (reg32 *) SPI_0_OLED_FLASH_miso_m__DR)
S/* Input Buffer Disable Override */
S#define SPI_0_OLED_FLASH_miso_m_INP_DIS                (* (reg32 *) SPI_0_OLED_FLASH_miso_m__PC2)
S
S/* Interrupt configuration Registers */
S#define SPI_0_OLED_FLASH_miso_m_INTCFG                 (* (reg32 *) SPI_0_OLED_FLASH_miso_m__INTCFG)
S#define SPI_0_OLED_FLASH_miso_m_INTSTAT                (* (reg32 *) SPI_0_OLED_FLASH_miso_m__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define SPI_0_OLED_FLASH_miso_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(SPI_0_OLED_FLASH_miso_m__SIO)
S    #define SPI_0_OLED_FLASH_miso_m_SIO_REG            (* (reg32 *) SPI_0_OLED_FLASH_miso_m__SIO)
S#endif /* (SPI_0_OLED_FLASH_miso_m__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(SPI_0_OLED_FLASH_miso_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_0_OLED_FLASH_miso_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_0_OLED_FLASH_miso_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_0_OLED_FLASH_miso_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define SPI_0_OLED_FLASH_miso_m_DRIVE_MODE_SHIFT       (0x00u)
S#define SPI_0_OLED_FLASH_miso_m_DRIVE_MODE_MASK        (0x07u << SPI_0_OLED_FLASH_miso_m_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins SPI_0_OLED_FLASH_miso_m_H */
N
N
N/* [] END OF FILE */
L 125 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_miso_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_miso_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_miso_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_miso_m_ALIASES_H) /* Pins SPI_0_OLED_FLASH_miso_m_ALIASES_H */
X#if !1L  
S#define CY_PINS_SPI_0_OLED_FLASH_miso_m_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define SPI_0_OLED_FLASH_miso_m_0			(SPI_0_OLED_FLASH_miso_m__0__PC)
S#define SPI_0_OLED_FLASH_miso_m_0_PS		(SPI_0_OLED_FLASH_miso_m__0__PS)
S#define SPI_0_OLED_FLASH_miso_m_0_PC		(SPI_0_OLED_FLASH_miso_m__0__PC)
S#define SPI_0_OLED_FLASH_miso_m_0_DR		(SPI_0_OLED_FLASH_miso_m__0__DR)
S#define SPI_0_OLED_FLASH_miso_m_0_SHIFT	(SPI_0_OLED_FLASH_miso_m__0__SHIFT)
S#define SPI_0_OLED_FLASH_miso_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_0_OLED_FLASH_miso_m__0__SHIFT*2u)))
S
S#define SPI_0_OLED_FLASH_miso_m_INTR_ALL	 ((uint16)(SPI_0_OLED_FLASH_miso_m_0_INTR))
S
S
N#endif /* End Pins SPI_0_OLED_FLASH_miso_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 126 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_mosi_m.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_mosi_m.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_mosi_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_mosi_m_H) /* Pins SPI_0_OLED_FLASH_mosi_m_H */
X#if !1L  
S#define CY_PINS_SPI_0_OLED_FLASH_mosi_m_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "SPI_0_OLED_FLASH_mosi_m_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} SPI_0_OLED_FLASH_mosi_m_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   SPI_0_OLED_FLASH_mosi_m_Read(void);
Svoid    SPI_0_OLED_FLASH_mosi_m_Write(uint8 value);
Suint8   SPI_0_OLED_FLASH_mosi_m_ReadDataReg(void);
S#if defined(SPI_0_OLED_FLASH_mosi_m__PC) || (CY_PSOC4_4200L) 
S    void    SPI_0_OLED_FLASH_mosi_m_SetDriveMode(uint8 mode);
S#endif
Svoid    SPI_0_OLED_FLASH_mosi_m_SetInterruptMode(uint16 position, uint16 mode);
Suint8   SPI_0_OLED_FLASH_mosi_m_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid SPI_0_OLED_FLASH_mosi_m_Sleep(void); 
Svoid SPI_0_OLED_FLASH_mosi_m_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(SPI_0_OLED_FLASH_mosi_m__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define SPI_0_OLED_FLASH_mosi_m_DRIVE_MODE_BITS        (3)
S    #define SPI_0_OLED_FLASH_mosi_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_0_OLED_FLASH_mosi_m_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the SPI_0_OLED_FLASH_mosi_m_SetDriveMode() function.
S         *  @{
S         */
S        #define SPI_0_OLED_FLASH_mosi_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define SPI_0_OLED_FLASH_mosi_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define SPI_0_OLED_FLASH_mosi_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define SPI_0_OLED_FLASH_mosi_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define SPI_0_OLED_FLASH_mosi_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define SPI_0_OLED_FLASH_mosi_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define SPI_0_OLED_FLASH_mosi_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define SPI_0_OLED_FLASH_mosi_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define SPI_0_OLED_FLASH_mosi_m_MASK               SPI_0_OLED_FLASH_mosi_m__MASK
S#define SPI_0_OLED_FLASH_mosi_m_SHIFT              SPI_0_OLED_FLASH_mosi_m__SHIFT
S#define SPI_0_OLED_FLASH_mosi_m_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in SPI_0_OLED_FLASH_mosi_m_SetInterruptMode() function.
S     *  @{
S     */
S        #define SPI_0_OLED_FLASH_mosi_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define SPI_0_OLED_FLASH_mosi_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define SPI_0_OLED_FLASH_mosi_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define SPI_0_OLED_FLASH_mosi_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(SPI_0_OLED_FLASH_mosi_m__SIO)
S    #define SPI_0_OLED_FLASH_mosi_m_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(SPI_0_OLED_FLASH_mosi_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_DISABLE              ((uint32)(~SPI_0_OLED_FLASH_mosi_m_USBIO_ENABLE))
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_0_OLED_FLASH_mosi_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_mosi_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(SPI_0_OLED_FLASH_mosi_m__PC)
S    /* Port Configuration */
S    #define SPI_0_OLED_FLASH_mosi_m_PC                 (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__PC)
S#endif
S/* Pin State */
S#define SPI_0_OLED_FLASH_mosi_m_PS                     (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__PS)
S/* Data Register */
S#define SPI_0_OLED_FLASH_mosi_m_DR                     (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__DR)
S/* Input Buffer Disable Override */
S#define SPI_0_OLED_FLASH_mosi_m_INP_DIS                (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__PC2)
S
S/* Interrupt configuration Registers */
S#define SPI_0_OLED_FLASH_mosi_m_INTCFG                 (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__INTCFG)
S#define SPI_0_OLED_FLASH_mosi_m_INTSTAT                (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define SPI_0_OLED_FLASH_mosi_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(SPI_0_OLED_FLASH_mosi_m__SIO)
S    #define SPI_0_OLED_FLASH_mosi_m_SIO_REG            (* (reg32 *) SPI_0_OLED_FLASH_mosi_m__SIO)
S#endif /* (SPI_0_OLED_FLASH_mosi_m__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(SPI_0_OLED_FLASH_mosi_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_0_OLED_FLASH_mosi_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_0_OLED_FLASH_mosi_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_0_OLED_FLASH_mosi_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define SPI_0_OLED_FLASH_mosi_m_DRIVE_MODE_SHIFT       (0x00u)
S#define SPI_0_OLED_FLASH_mosi_m_DRIVE_MODE_MASK        (0x07u << SPI_0_OLED_FLASH_mosi_m_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins SPI_0_OLED_FLASH_mosi_m_H */
N
N
N/* [] END OF FILE */
L 127 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_mosi_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_mosi_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_mosi_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_mosi_m_ALIASES_H) /* Pins SPI_0_OLED_FLASH_mosi_m_ALIASES_H */
X#if !1L  
S#define CY_PINS_SPI_0_OLED_FLASH_mosi_m_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define SPI_0_OLED_FLASH_mosi_m_0			(SPI_0_OLED_FLASH_mosi_m__0__PC)
S#define SPI_0_OLED_FLASH_mosi_m_0_PS		(SPI_0_OLED_FLASH_mosi_m__0__PS)
S#define SPI_0_OLED_FLASH_mosi_m_0_PC		(SPI_0_OLED_FLASH_mosi_m__0__PC)
S#define SPI_0_OLED_FLASH_mosi_m_0_DR		(SPI_0_OLED_FLASH_mosi_m__0__DR)
S#define SPI_0_OLED_FLASH_mosi_m_0_SHIFT	(SPI_0_OLED_FLASH_mosi_m__0__SHIFT)
S#define SPI_0_OLED_FLASH_mosi_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_0_OLED_FLASH_mosi_m__0__SHIFT*2u)))
S
S#define SPI_0_OLED_FLASH_mosi_m_INTR_ALL	 ((uint16)(SPI_0_OLED_FLASH_mosi_m_0_INTR))
S
S
N#endif /* End Pins SPI_0_OLED_FLASH_mosi_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 128 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_ss0_m.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_ss0_m.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_ss0_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_ss0_m_H) /* Pins SPI_0_OLED_FLASH_ss0_m_H */
X#if !1L  
S#define CY_PINS_SPI_0_OLED_FLASH_ss0_m_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "SPI_0_OLED_FLASH_ss0_m_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} SPI_0_OLED_FLASH_ss0_m_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   SPI_0_OLED_FLASH_ss0_m_Read(void);
Svoid    SPI_0_OLED_FLASH_ss0_m_Write(uint8 value);
Suint8   SPI_0_OLED_FLASH_ss0_m_ReadDataReg(void);
S#if defined(SPI_0_OLED_FLASH_ss0_m__PC) || (CY_PSOC4_4200L) 
S    void    SPI_0_OLED_FLASH_ss0_m_SetDriveMode(uint8 mode);
S#endif
Svoid    SPI_0_OLED_FLASH_ss0_m_SetInterruptMode(uint16 position, uint16 mode);
Suint8   SPI_0_OLED_FLASH_ss0_m_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid SPI_0_OLED_FLASH_ss0_m_Sleep(void); 
Svoid SPI_0_OLED_FLASH_ss0_m_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(SPI_0_OLED_FLASH_ss0_m__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define SPI_0_OLED_FLASH_ss0_m_DRIVE_MODE_BITS        (3)
S    #define SPI_0_OLED_FLASH_ss0_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_0_OLED_FLASH_ss0_m_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the SPI_0_OLED_FLASH_ss0_m_SetDriveMode() function.
S         *  @{
S         */
S        #define SPI_0_OLED_FLASH_ss0_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define SPI_0_OLED_FLASH_ss0_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define SPI_0_OLED_FLASH_ss0_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define SPI_0_OLED_FLASH_ss0_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define SPI_0_OLED_FLASH_ss0_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define SPI_0_OLED_FLASH_ss0_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define SPI_0_OLED_FLASH_ss0_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define SPI_0_OLED_FLASH_ss0_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define SPI_0_OLED_FLASH_ss0_m_MASK               SPI_0_OLED_FLASH_ss0_m__MASK
S#define SPI_0_OLED_FLASH_ss0_m_SHIFT              SPI_0_OLED_FLASH_ss0_m__SHIFT
S#define SPI_0_OLED_FLASH_ss0_m_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in SPI_0_OLED_FLASH_ss0_m_SetInterruptMode() function.
S     *  @{
S     */
S        #define SPI_0_OLED_FLASH_ss0_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define SPI_0_OLED_FLASH_ss0_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define SPI_0_OLED_FLASH_ss0_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define SPI_0_OLED_FLASH_ss0_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(SPI_0_OLED_FLASH_ss0_m__SIO)
S    #define SPI_0_OLED_FLASH_ss0_m_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(SPI_0_OLED_FLASH_ss0_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_DISABLE              ((uint32)(~SPI_0_OLED_FLASH_ss0_m_USBIO_ENABLE))
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_0_OLED_FLASH_ss0_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_0_OLED_FLASH_ss0_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(SPI_0_OLED_FLASH_ss0_m__PC)
S    /* Port Configuration */
S    #define SPI_0_OLED_FLASH_ss0_m_PC                 (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__PC)
S#endif
S/* Pin State */
S#define SPI_0_OLED_FLASH_ss0_m_PS                     (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__PS)
S/* Data Register */
S#define SPI_0_OLED_FLASH_ss0_m_DR                     (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__DR)
S/* Input Buffer Disable Override */
S#define SPI_0_OLED_FLASH_ss0_m_INP_DIS                (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__PC2)
S
S/* Interrupt configuration Registers */
S#define SPI_0_OLED_FLASH_ss0_m_INTCFG                 (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__INTCFG)
S#define SPI_0_OLED_FLASH_ss0_m_INTSTAT                (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define SPI_0_OLED_FLASH_ss0_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(SPI_0_OLED_FLASH_ss0_m__SIO)
S    #define SPI_0_OLED_FLASH_ss0_m_SIO_REG            (* (reg32 *) SPI_0_OLED_FLASH_ss0_m__SIO)
S#endif /* (SPI_0_OLED_FLASH_ss0_m__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(SPI_0_OLED_FLASH_ss0_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_0_OLED_FLASH_ss0_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_0_OLED_FLASH_ss0_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_0_OLED_FLASH_ss0_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define SPI_0_OLED_FLASH_ss0_m_DRIVE_MODE_SHIFT       (0x00u)
S#define SPI_0_OLED_FLASH_ss0_m_DRIVE_MODE_MASK        (0x07u << SPI_0_OLED_FLASH_ss0_m_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins SPI_0_OLED_FLASH_ss0_m_H */
N
N
N/* [] END OF FILE */
L 129 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_0_OLED_FLASH_ss0_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_0_OLED_FLASH_ss0_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_0_OLED_FLASH_ss0_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_0_OLED_FLASH_ss0_m_ALIASES_H) /* Pins SPI_0_OLED_FLASH_ss0_m_ALIASES_H */
X#if !1L  
S#define CY_PINS_SPI_0_OLED_FLASH_ss0_m_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define SPI_0_OLED_FLASH_ss0_m_0			(SPI_0_OLED_FLASH_ss0_m__0__PC)
S#define SPI_0_OLED_FLASH_ss0_m_0_PS		(SPI_0_OLED_FLASH_ss0_m__0__PS)
S#define SPI_0_OLED_FLASH_ss0_m_0_PC		(SPI_0_OLED_FLASH_ss0_m__0__PC)
S#define SPI_0_OLED_FLASH_ss0_m_0_DR		(SPI_0_OLED_FLASH_ss0_m__0__DR)
S#define SPI_0_OLED_FLASH_ss0_m_0_SHIFT	(SPI_0_OLED_FLASH_ss0_m__0__SHIFT)
S#define SPI_0_OLED_FLASH_ss0_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_0_OLED_FLASH_ss0_m__0__SHIFT*2u)))
S
S#define SPI_0_OLED_FLASH_ss0_m_INTR_ALL	 ((uint16)(SPI_0_OLED_FLASH_ss0_m_0_INTR))
S
S
N#endif /* End Pins SPI_0_OLED_FLASH_ss0_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 130 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD_SCBCLK.h"
N#include "SPI_1_CARD_sclk_m.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_sclk_m.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_sclk_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_sclk_m_H) /* Pins SPI_1_CARD_sclk_m_H */
X#if !1L  
S#define CY_PINS_SPI_1_CARD_sclk_m_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "SPI_1_CARD_sclk_m_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} SPI_1_CARD_sclk_m_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   SPI_1_CARD_sclk_m_Read(void);
Svoid    SPI_1_CARD_sclk_m_Write(uint8 value);
Suint8   SPI_1_CARD_sclk_m_ReadDataReg(void);
S#if defined(SPI_1_CARD_sclk_m__PC) || (CY_PSOC4_4200L) 
S    void    SPI_1_CARD_sclk_m_SetDriveMode(uint8 mode);
S#endif
Svoid    SPI_1_CARD_sclk_m_SetInterruptMode(uint16 position, uint16 mode);
Suint8   SPI_1_CARD_sclk_m_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid SPI_1_CARD_sclk_m_Sleep(void); 
Svoid SPI_1_CARD_sclk_m_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(SPI_1_CARD_sclk_m__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define SPI_1_CARD_sclk_m_DRIVE_MODE_BITS        (3)
S    #define SPI_1_CARD_sclk_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_1_CARD_sclk_m_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the SPI_1_CARD_sclk_m_SetDriveMode() function.
S         *  @{
S         */
S        #define SPI_1_CARD_sclk_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define SPI_1_CARD_sclk_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define SPI_1_CARD_sclk_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define SPI_1_CARD_sclk_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define SPI_1_CARD_sclk_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define SPI_1_CARD_sclk_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define SPI_1_CARD_sclk_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define SPI_1_CARD_sclk_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define SPI_1_CARD_sclk_m_MASK               SPI_1_CARD_sclk_m__MASK
S#define SPI_1_CARD_sclk_m_SHIFT              SPI_1_CARD_sclk_m__SHIFT
S#define SPI_1_CARD_sclk_m_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in SPI_1_CARD_sclk_m_SetInterruptMode() function.
S     *  @{
S     */
S        #define SPI_1_CARD_sclk_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define SPI_1_CARD_sclk_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define SPI_1_CARD_sclk_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define SPI_1_CARD_sclk_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(SPI_1_CARD_sclk_m__SIO)
S    #define SPI_1_CARD_sclk_m_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(SPI_1_CARD_sclk_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_1_CARD_sclk_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_1_CARD_sclk_m_USBIO_DISABLE              ((uint32)(~SPI_1_CARD_sclk_m_USBIO_ENABLE))
S    #define SPI_1_CARD_sclk_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_1_CARD_sclk_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_1_CARD_sclk_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_sclk_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_1_CARD_sclk_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_1_CARD_sclk_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_sclk_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_1_CARD_sclk_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_sclk_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_1_CARD_sclk_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_1_CARD_sclk_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_1_CARD_sclk_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_sclk_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(SPI_1_CARD_sclk_m__PC)
S    /* Port Configuration */
S    #define SPI_1_CARD_sclk_m_PC                 (* (reg32 *) SPI_1_CARD_sclk_m__PC)
S#endif
S/* Pin State */
S#define SPI_1_CARD_sclk_m_PS                     (* (reg32 *) SPI_1_CARD_sclk_m__PS)
S/* Data Register */
S#define SPI_1_CARD_sclk_m_DR                     (* (reg32 *) SPI_1_CARD_sclk_m__DR)
S/* Input Buffer Disable Override */
S#define SPI_1_CARD_sclk_m_INP_DIS                (* (reg32 *) SPI_1_CARD_sclk_m__PC2)
S
S/* Interrupt configuration Registers */
S#define SPI_1_CARD_sclk_m_INTCFG                 (* (reg32 *) SPI_1_CARD_sclk_m__INTCFG)
S#define SPI_1_CARD_sclk_m_INTSTAT                (* (reg32 *) SPI_1_CARD_sclk_m__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define SPI_1_CARD_sclk_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(SPI_1_CARD_sclk_m__SIO)
S    #define SPI_1_CARD_sclk_m_SIO_REG            (* (reg32 *) SPI_1_CARD_sclk_m__SIO)
S#endif /* (SPI_1_CARD_sclk_m__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(SPI_1_CARD_sclk_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_1_CARD_sclk_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_1_CARD_sclk_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_1_CARD_sclk_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define SPI_1_CARD_sclk_m_DRIVE_MODE_SHIFT       (0x00u)
S#define SPI_1_CARD_sclk_m_DRIVE_MODE_MASK        (0x07u << SPI_1_CARD_sclk_m_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins SPI_1_CARD_sclk_m_H */
N
N
N/* [] END OF FILE */
L 132 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD_sclk_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_sclk_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_sclk_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_sclk_m_ALIASES_H) /* Pins SPI_1_CARD_sclk_m_ALIASES_H */
X#if !1L  
S#define CY_PINS_SPI_1_CARD_sclk_m_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define SPI_1_CARD_sclk_m_0			(SPI_1_CARD_sclk_m__0__PC)
S#define SPI_1_CARD_sclk_m_0_PS		(SPI_1_CARD_sclk_m__0__PS)
S#define SPI_1_CARD_sclk_m_0_PC		(SPI_1_CARD_sclk_m__0__PC)
S#define SPI_1_CARD_sclk_m_0_DR		(SPI_1_CARD_sclk_m__0__DR)
S#define SPI_1_CARD_sclk_m_0_SHIFT	(SPI_1_CARD_sclk_m__0__SHIFT)
S#define SPI_1_CARD_sclk_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_1_CARD_sclk_m__0__SHIFT*2u)))
S
S#define SPI_1_CARD_sclk_m_INTR_ALL	 ((uint16)(SPI_1_CARD_sclk_m_0_INTR))
S
S
N#endif /* End Pins SPI_1_CARD_sclk_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 133 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD_miso_m.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_miso_m.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_miso_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_miso_m_H) /* Pins SPI_1_CARD_miso_m_H */
X#if !1L  
S#define CY_PINS_SPI_1_CARD_miso_m_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "SPI_1_CARD_miso_m_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} SPI_1_CARD_miso_m_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   SPI_1_CARD_miso_m_Read(void);
Svoid    SPI_1_CARD_miso_m_Write(uint8 value);
Suint8   SPI_1_CARD_miso_m_ReadDataReg(void);
S#if defined(SPI_1_CARD_miso_m__PC) || (CY_PSOC4_4200L) 
S    void    SPI_1_CARD_miso_m_SetDriveMode(uint8 mode);
S#endif
Svoid    SPI_1_CARD_miso_m_SetInterruptMode(uint16 position, uint16 mode);
Suint8   SPI_1_CARD_miso_m_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid SPI_1_CARD_miso_m_Sleep(void); 
Svoid SPI_1_CARD_miso_m_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(SPI_1_CARD_miso_m__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define SPI_1_CARD_miso_m_DRIVE_MODE_BITS        (3)
S    #define SPI_1_CARD_miso_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_1_CARD_miso_m_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the SPI_1_CARD_miso_m_SetDriveMode() function.
S         *  @{
S         */
S        #define SPI_1_CARD_miso_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define SPI_1_CARD_miso_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define SPI_1_CARD_miso_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define SPI_1_CARD_miso_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define SPI_1_CARD_miso_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define SPI_1_CARD_miso_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define SPI_1_CARD_miso_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define SPI_1_CARD_miso_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define SPI_1_CARD_miso_m_MASK               SPI_1_CARD_miso_m__MASK
S#define SPI_1_CARD_miso_m_SHIFT              SPI_1_CARD_miso_m__SHIFT
S#define SPI_1_CARD_miso_m_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in SPI_1_CARD_miso_m_SetInterruptMode() function.
S     *  @{
S     */
S        #define SPI_1_CARD_miso_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define SPI_1_CARD_miso_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define SPI_1_CARD_miso_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define SPI_1_CARD_miso_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(SPI_1_CARD_miso_m__SIO)
S    #define SPI_1_CARD_miso_m_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(SPI_1_CARD_miso_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_1_CARD_miso_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_1_CARD_miso_m_USBIO_DISABLE              ((uint32)(~SPI_1_CARD_miso_m_USBIO_ENABLE))
S    #define SPI_1_CARD_miso_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_1_CARD_miso_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_1_CARD_miso_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_miso_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_1_CARD_miso_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_1_CARD_miso_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_miso_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_1_CARD_miso_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_miso_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_1_CARD_miso_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_1_CARD_miso_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_1_CARD_miso_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_miso_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(SPI_1_CARD_miso_m__PC)
S    /* Port Configuration */
S    #define SPI_1_CARD_miso_m_PC                 (* (reg32 *) SPI_1_CARD_miso_m__PC)
S#endif
S/* Pin State */
S#define SPI_1_CARD_miso_m_PS                     (* (reg32 *) SPI_1_CARD_miso_m__PS)
S/* Data Register */
S#define SPI_1_CARD_miso_m_DR                     (* (reg32 *) SPI_1_CARD_miso_m__DR)
S/* Input Buffer Disable Override */
S#define SPI_1_CARD_miso_m_INP_DIS                (* (reg32 *) SPI_1_CARD_miso_m__PC2)
S
S/* Interrupt configuration Registers */
S#define SPI_1_CARD_miso_m_INTCFG                 (* (reg32 *) SPI_1_CARD_miso_m__INTCFG)
S#define SPI_1_CARD_miso_m_INTSTAT                (* (reg32 *) SPI_1_CARD_miso_m__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define SPI_1_CARD_miso_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(SPI_1_CARD_miso_m__SIO)
S    #define SPI_1_CARD_miso_m_SIO_REG            (* (reg32 *) SPI_1_CARD_miso_m__SIO)
S#endif /* (SPI_1_CARD_miso_m__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(SPI_1_CARD_miso_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_1_CARD_miso_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_1_CARD_miso_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_1_CARD_miso_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define SPI_1_CARD_miso_m_DRIVE_MODE_SHIFT       (0x00u)
S#define SPI_1_CARD_miso_m_DRIVE_MODE_MASK        (0x07u << SPI_1_CARD_miso_m_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins SPI_1_CARD_miso_m_H */
N
N
N/* [] END OF FILE */
L 134 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD_miso_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_miso_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_miso_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_miso_m_ALIASES_H) /* Pins SPI_1_CARD_miso_m_ALIASES_H */
X#if !1L  
S#define CY_PINS_SPI_1_CARD_miso_m_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define SPI_1_CARD_miso_m_0			(SPI_1_CARD_miso_m__0__PC)
S#define SPI_1_CARD_miso_m_0_PS		(SPI_1_CARD_miso_m__0__PS)
S#define SPI_1_CARD_miso_m_0_PC		(SPI_1_CARD_miso_m__0__PC)
S#define SPI_1_CARD_miso_m_0_DR		(SPI_1_CARD_miso_m__0__DR)
S#define SPI_1_CARD_miso_m_0_SHIFT	(SPI_1_CARD_miso_m__0__SHIFT)
S#define SPI_1_CARD_miso_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_1_CARD_miso_m__0__SHIFT*2u)))
S
S#define SPI_1_CARD_miso_m_INTR_ALL	 ((uint16)(SPI_1_CARD_miso_m_0_INTR))
S
S
N#endif /* End Pins SPI_1_CARD_miso_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 135 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD_mosi_m.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_mosi_m.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_mosi_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_mosi_m_H) /* Pins SPI_1_CARD_mosi_m_H */
X#if !1L  
S#define CY_PINS_SPI_1_CARD_mosi_m_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "SPI_1_CARD_mosi_m_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} SPI_1_CARD_mosi_m_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   SPI_1_CARD_mosi_m_Read(void);
Svoid    SPI_1_CARD_mosi_m_Write(uint8 value);
Suint8   SPI_1_CARD_mosi_m_ReadDataReg(void);
S#if defined(SPI_1_CARD_mosi_m__PC) || (CY_PSOC4_4200L) 
S    void    SPI_1_CARD_mosi_m_SetDriveMode(uint8 mode);
S#endif
Svoid    SPI_1_CARD_mosi_m_SetInterruptMode(uint16 position, uint16 mode);
Suint8   SPI_1_CARD_mosi_m_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid SPI_1_CARD_mosi_m_Sleep(void); 
Svoid SPI_1_CARD_mosi_m_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(SPI_1_CARD_mosi_m__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define SPI_1_CARD_mosi_m_DRIVE_MODE_BITS        (3)
S    #define SPI_1_CARD_mosi_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_1_CARD_mosi_m_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the SPI_1_CARD_mosi_m_SetDriveMode() function.
S         *  @{
S         */
S        #define SPI_1_CARD_mosi_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define SPI_1_CARD_mosi_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define SPI_1_CARD_mosi_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define SPI_1_CARD_mosi_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define SPI_1_CARD_mosi_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define SPI_1_CARD_mosi_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define SPI_1_CARD_mosi_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define SPI_1_CARD_mosi_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define SPI_1_CARD_mosi_m_MASK               SPI_1_CARD_mosi_m__MASK
S#define SPI_1_CARD_mosi_m_SHIFT              SPI_1_CARD_mosi_m__SHIFT
S#define SPI_1_CARD_mosi_m_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in SPI_1_CARD_mosi_m_SetInterruptMode() function.
S     *  @{
S     */
S        #define SPI_1_CARD_mosi_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define SPI_1_CARD_mosi_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define SPI_1_CARD_mosi_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define SPI_1_CARD_mosi_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(SPI_1_CARD_mosi_m__SIO)
S    #define SPI_1_CARD_mosi_m_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(SPI_1_CARD_mosi_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_1_CARD_mosi_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_1_CARD_mosi_m_USBIO_DISABLE              ((uint32)(~SPI_1_CARD_mosi_m_USBIO_ENABLE))
S    #define SPI_1_CARD_mosi_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_1_CARD_mosi_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_1_CARD_mosi_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_mosi_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_1_CARD_mosi_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_1_CARD_mosi_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_mosi_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_1_CARD_mosi_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_mosi_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_1_CARD_mosi_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_1_CARD_mosi_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_1_CARD_mosi_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_mosi_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(SPI_1_CARD_mosi_m__PC)
S    /* Port Configuration */
S    #define SPI_1_CARD_mosi_m_PC                 (* (reg32 *) SPI_1_CARD_mosi_m__PC)
S#endif
S/* Pin State */
S#define SPI_1_CARD_mosi_m_PS                     (* (reg32 *) SPI_1_CARD_mosi_m__PS)
S/* Data Register */
S#define SPI_1_CARD_mosi_m_DR                     (* (reg32 *) SPI_1_CARD_mosi_m__DR)
S/* Input Buffer Disable Override */
S#define SPI_1_CARD_mosi_m_INP_DIS                (* (reg32 *) SPI_1_CARD_mosi_m__PC2)
S
S/* Interrupt configuration Registers */
S#define SPI_1_CARD_mosi_m_INTCFG                 (* (reg32 *) SPI_1_CARD_mosi_m__INTCFG)
S#define SPI_1_CARD_mosi_m_INTSTAT                (* (reg32 *) SPI_1_CARD_mosi_m__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define SPI_1_CARD_mosi_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(SPI_1_CARD_mosi_m__SIO)
S    #define SPI_1_CARD_mosi_m_SIO_REG            (* (reg32 *) SPI_1_CARD_mosi_m__SIO)
S#endif /* (SPI_1_CARD_mosi_m__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(SPI_1_CARD_mosi_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_1_CARD_mosi_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_1_CARD_mosi_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_1_CARD_mosi_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define SPI_1_CARD_mosi_m_DRIVE_MODE_SHIFT       (0x00u)
S#define SPI_1_CARD_mosi_m_DRIVE_MODE_MASK        (0x07u << SPI_1_CARD_mosi_m_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins SPI_1_CARD_mosi_m_H */
N
N
N/* [] END OF FILE */
L 136 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD_mosi_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_mosi_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_mosi_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_mosi_m_ALIASES_H) /* Pins SPI_1_CARD_mosi_m_ALIASES_H */
X#if !1L  
S#define CY_PINS_SPI_1_CARD_mosi_m_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define SPI_1_CARD_mosi_m_0			(SPI_1_CARD_mosi_m__0__PC)
S#define SPI_1_CARD_mosi_m_0_PS		(SPI_1_CARD_mosi_m__0__PS)
S#define SPI_1_CARD_mosi_m_0_PC		(SPI_1_CARD_mosi_m__0__PC)
S#define SPI_1_CARD_mosi_m_0_DR		(SPI_1_CARD_mosi_m__0__DR)
S#define SPI_1_CARD_mosi_m_0_SHIFT	(SPI_1_CARD_mosi_m__0__SHIFT)
S#define SPI_1_CARD_mosi_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_1_CARD_mosi_m__0__SHIFT*2u)))
S
S#define SPI_1_CARD_mosi_m_INTR_ALL	 ((uint16)(SPI_1_CARD_mosi_m_0_INTR))
S
S
N#endif /* End Pins SPI_1_CARD_mosi_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 137 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD_ss0_m.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_ss0_m.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_ss0_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains Pin function prototypes and register defines
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_ss0_m_H) /* Pins SPI_1_CARD_ss0_m_H */
X#if !1L  
S#define CY_PINS_SPI_1_CARD_ss0_m_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "SPI_1_CARD_ss0_m_aliases.h"
S
S
S/***************************************
S*     Data Struct Definitions
S***************************************/
S
S/**
S* \addtogroup group_structures
S* @{
S*/
S    
S/* Structure for sleep mode support */
Stypedef struct
S{
S    uint32 pcState; /**< State of the port control register */
S    uint32 sioState; /**< State of the SIO configuration */
S    uint32 usbState; /**< State of the USBIO regulator */
S} SPI_1_CARD_ss0_m_BACKUP_STRUCT;
S
S/** @} structures */
S
S
S/***************************************
S*        Function Prototypes             
S***************************************/
S/**
S* \addtogroup group_general
S* @{
S*/
Suint8   SPI_1_CARD_ss0_m_Read(void);
Svoid    SPI_1_CARD_ss0_m_Write(uint8 value);
Suint8   SPI_1_CARD_ss0_m_ReadDataReg(void);
S#if defined(SPI_1_CARD_ss0_m__PC) || (CY_PSOC4_4200L) 
S    void    SPI_1_CARD_ss0_m_SetDriveMode(uint8 mode);
S#endif
Svoid    SPI_1_CARD_ss0_m_SetInterruptMode(uint16 position, uint16 mode);
Suint8   SPI_1_CARD_ss0_m_ClearInterrupt(void);
S/** @} general */
S
S/**
S* \addtogroup group_power
S* @{
S*/
Svoid SPI_1_CARD_ss0_m_Sleep(void); 
Svoid SPI_1_CARD_ss0_m_Wakeup(void);
S/** @} power */
S
S
S/***************************************
S*           API Constants        
S***************************************/
S#if defined(SPI_1_CARD_ss0_m__PC) || (CY_PSOC4_4200L) 
S    /* Drive Modes */
S    #define SPI_1_CARD_ss0_m_DRIVE_MODE_BITS        (3)
S    #define SPI_1_CARD_ss0_m_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - SPI_1_CARD_ss0_m_DRIVE_MODE_BITS))
S
S    /**
S    * \addtogroup group_constants
S    * @{
S    */
S        /** \addtogroup driveMode Drive mode constants
S         * \brief Constants to be passed as "mode" parameter in the SPI_1_CARD_ss0_m_SetDriveMode() function.
S         *  @{
S         */
S        #define SPI_1_CARD_ss0_m_DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
S        #define SPI_1_CARD_ss0_m_DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
S        #define SPI_1_CARD_ss0_m_DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
S        #define SPI_1_CARD_ss0_m_DM_RES_DWN         (0x03u) /**< \brief Resistive Pull Down     */
S        #define SPI_1_CARD_ss0_m_DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
S        #define SPI_1_CARD_ss0_m_DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
S        #define SPI_1_CARD_ss0_m_DM_STRONG          (0x06u) /**< \brief Strong Drive            */
S        #define SPI_1_CARD_ss0_m_DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */
S        /** @} driveMode */
S    /** @} group_constants */
S#endif
S
S/* Digital Port Constants */
S#define SPI_1_CARD_ss0_m_MASK               SPI_1_CARD_ss0_m__MASK
S#define SPI_1_CARD_ss0_m_SHIFT              SPI_1_CARD_ss0_m__SHIFT
S#define SPI_1_CARD_ss0_m_WIDTH              1u
S
S/**
S* \addtogroup group_constants
S* @{
S*/
S    /** \addtogroup intrMode Interrupt constants
S     * \brief Constants to be passed as "mode" parameter in SPI_1_CARD_ss0_m_SetInterruptMode() function.
S     *  @{
S     */
S        #define SPI_1_CARD_ss0_m_INTR_NONE      ((uint16)(0x0000u)) /**< \brief Disabled             */
S        #define SPI_1_CARD_ss0_m_INTR_RISING    ((uint16)(0x5555u)) /**< \brief Rising edge trigger  */
S        #define SPI_1_CARD_ss0_m_INTR_FALLING   ((uint16)(0xaaaau)) /**< \brief Falling edge trigger */
S        #define SPI_1_CARD_ss0_m_INTR_BOTH      ((uint16)(0xffffu)) /**< \brief Both edge trigger    */
S    /** @} intrMode */
S/** @} group_constants */
S
S/* SIO LPM definition */
S#if defined(SPI_1_CARD_ss0_m__SIO)
S    #define SPI_1_CARD_ss0_m_SIO_LPM_MASK       (0x03u)
S#endif
S
S/* USBIO definitions */
S#if !defined(SPI_1_CARD_ss0_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_1_CARD_ss0_m_USBIO_ENABLE               ((uint32)0x80000000u)
S    #define SPI_1_CARD_ss0_m_USBIO_DISABLE              ((uint32)(~SPI_1_CARD_ss0_m_USBIO_ENABLE))
S    #define SPI_1_CARD_ss0_m_USBIO_SUSPEND_SHIFT        CYFLD_USBDEVv2_USB_SUSPEND__OFFSET
S    #define SPI_1_CARD_ss0_m_USBIO_SUSPEND_DEL_SHIFT    CYFLD_USBDEVv2_USB_SUSPEND_DEL__OFFSET
S    #define SPI_1_CARD_ss0_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_ss0_m_USBIO_SUSPEND_SHIFT) \
S                                                        | (1u << SPI_1_CARD_ss0_m_USBIO_SUSPEND_DEL_SHIFT)))
X    #define SPI_1_CARD_ss0_m_USBIO_ENTER_SLEEP          ((uint32)((1u << SPI_1_CARD_ss0_m_USBIO_SUSPEND_SHIFT)                                                         | (1u << SPI_1_CARD_ss0_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_ss0_m_USBIO_EXIT_SLEEP_PH1       ((uint32)~((uint32)(1u << SPI_1_CARD_ss0_m_USBIO_SUSPEND_SHIFT)))
S    #define SPI_1_CARD_ss0_m_USBIO_EXIT_SLEEP_PH2       ((uint32)~((uint32)(1u << SPI_1_CARD_ss0_m_USBIO_SUSPEND_DEL_SHIFT)))
S    #define SPI_1_CARD_ss0_m_USBIO_CR1_OFF              ((uint32)0xfffffffeu)
S#endif
S
S
S/***************************************
S*             Registers        
S***************************************/
S/* Main Port Registers */
S#if defined(SPI_1_CARD_ss0_m__PC)
S    /* Port Configuration */
S    #define SPI_1_CARD_ss0_m_PC                 (* (reg32 *) SPI_1_CARD_ss0_m__PC)
S#endif
S/* Pin State */
S#define SPI_1_CARD_ss0_m_PS                     (* (reg32 *) SPI_1_CARD_ss0_m__PS)
S/* Data Register */
S#define SPI_1_CARD_ss0_m_DR                     (* (reg32 *) SPI_1_CARD_ss0_m__DR)
S/* Input Buffer Disable Override */
S#define SPI_1_CARD_ss0_m_INP_DIS                (* (reg32 *) SPI_1_CARD_ss0_m__PC2)
S
S/* Interrupt configuration Registers */
S#define SPI_1_CARD_ss0_m_INTCFG                 (* (reg32 *) SPI_1_CARD_ss0_m__INTCFG)
S#define SPI_1_CARD_ss0_m_INTSTAT                (* (reg32 *) SPI_1_CARD_ss0_m__INTSTAT)
S
S/* "Interrupt cause" register for Combined Port Interrupt (AllPortInt) in GSRef component */
S#if defined (CYREG_GPIO_INTR_CAUSE)
S    #define SPI_1_CARD_ss0_m_INTR_CAUSE         (* (reg32 *) CYREG_GPIO_INTR_CAUSE)
S#endif
S
S/* SIO register */
S#if defined(SPI_1_CARD_ss0_m__SIO)
S    #define SPI_1_CARD_ss0_m_SIO_REG            (* (reg32 *) SPI_1_CARD_ss0_m__SIO)
S#endif /* (SPI_1_CARD_ss0_m__SIO_CFG) */
S
S/* USBIO registers */
S#if !defined(SPI_1_CARD_ss0_m__PC) && (CY_PSOC4_4200L)
S    #define SPI_1_CARD_ss0_m_USB_POWER_REG       (* (reg32 *) CYREG_USBDEVv2_USB_POWER_CTRL)
S    #define SPI_1_CARD_ss0_m_CR1_REG             (* (reg32 *) CYREG_USBDEVv2_CR1)
S    #define SPI_1_CARD_ss0_m_USBIO_CTRL_REG      (* (reg32 *) CYREG_USBDEVv2_USB_USBIO_CTRL)
S#endif    
S    
S    
S/***************************************
S* The following code is DEPRECATED and 
S* must not be used in new designs.
S***************************************/
S/**
S* \addtogroup group_deprecated
S* @{
S*/
S#define SPI_1_CARD_ss0_m_DRIVE_MODE_SHIFT       (0x00u)
S#define SPI_1_CARD_ss0_m_DRIVE_MODE_MASK        (0x07u << SPI_1_CARD_ss0_m_DRIVE_MODE_SHIFT)
S/** @} deprecated */
S
N#endif /* End Pins SPI_1_CARD_ss0_m_H */
N
N
N/* [] END OF FILE */
L 138 "Generated_Source\PSoC4\project.h" 2
N#include "SPI_1_CARD_ss0_m_aliases.h"
L 1 "Generated_Source\PSoC4\SPI_1_CARD_ss0_m_aliases.h" 1
N/*******************************************************************************
N* File Name: SPI_1_CARD_ss0_m.h  
N* Version 2.20
N*
N* Description:
N*  This file contains the Alias definitions for Per-Pin APIs in cypins.h. 
N*  Information on using these APIs can be found in the System Reference Guide.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_SPI_1_CARD_ss0_m_ALIASES_H) /* Pins SPI_1_CARD_ss0_m_ALIASES_H */
X#if !1L  
S#define CY_PINS_SPI_1_CARD_ss0_m_ALIASES_H
S
S#include "cytypes.h"
S#include "cyfitter.h"
S#include "cypins.h"
S
S
S/***************************************
S*              Constants        
S***************************************/
S#define SPI_1_CARD_ss0_m_0			(SPI_1_CARD_ss0_m__0__PC)
S#define SPI_1_CARD_ss0_m_0_PS		(SPI_1_CARD_ss0_m__0__PS)
S#define SPI_1_CARD_ss0_m_0_PC		(SPI_1_CARD_ss0_m__0__PC)
S#define SPI_1_CARD_ss0_m_0_DR		(SPI_1_CARD_ss0_m__0__DR)
S#define SPI_1_CARD_ss0_m_0_SHIFT	(SPI_1_CARD_ss0_m__0__SHIFT)
S#define SPI_1_CARD_ss0_m_0_INTR	((uint16)((uint16)0x0003u << (SPI_1_CARD_ss0_m__0__SHIFT*2u)))
S
S#define SPI_1_CARD_ss0_m_INTR_ALL	 ((uint16)(SPI_1_CARD_ss0_m_0_INTR))
S
S
N#endif /* End Pins SPI_1_CARD_ss0_m_ALIASES_H */
N
N
N/* [] END OF FILE */
L 139 "Generated_Source\PSoC4\project.h" 2
N#include "CapSense_ISR.h"
N#include "ADC_IRQ.h"
N#include "ADC_intClock.h"
N#include "CyFlash.h"
N#include "CyLib.h"
N#include "cyPm.h"
N#include "cytypes.h"
N#include "cypins.h"
N#include "core_cm0plus_psoc4.h"
N#include "CyDMA.h"
N#include "CyLFClk.h"
N#include "cy_em_eeprom.h"
N
N/*[]*/
N
L 48 ".\main.h" 2
N#include "gpio.h"
L 1 ".\Modules\Mcu\gpio.h" 1
N#ifndef _GPIO_H
N#define _GPIO_H
N    
N#include "main.h"
N    
Ntypedef struct {
N    uint32_t gpio0_data;
N    uint32_t gpio1_data;
N    uint32_t gpio2_data;
N    uint32_t gpio3_data;
N    uint32_t gpio4_data;
N    uint32_t gpio5_data;
N    uint32_t gpio6_data;
N    uint32_t gpio7_data;
N}GPIO_REGDATA,*pGPIO_REGDATA;
N
Ntypedef enum
N{
N    GPIO0 = 1,
N    GPIO1 = 2,
N    GPIO2 = 3,
N    GPIO3 = 4,
N    GPIO4 = 5,
N    GPIO5 = 6,
N    GPIO6 = 7,
N    GPIO7 = 8,
N}GPIO_TYPE;
N
Ntypedef enum
N{
N    PIN0 = 0,
N    PIN1 = 1,
N    PIN2 = 2,
N    PIN3 = 3,
N    PIN4 = 4,
N    PIN5 = 5,
N    PIN6 = 6,
N    PIN7 = 7,
N}PINS;
N    
N#define DM_ALG_HIZ         (0x00u) /**< \brief High Impedance Analog   */
N#define DM_DIG_HIZ         (0x01u) /**< \brief High Impedance Digital  */
N#define DM_RES_UP          (0x02u) /**< \brief Resistive Pull Up       */
N#define DM_RES_DOWN        (0x03u) /**< \brief Resistive Pull Down     */
N#define DM_OD_LO           (0x04u) /**< \brief Open Drain, Drives Low  */
N#define DM_OD_HI           (0x05u) /**< \brief Open Drain, Drives High */
N#define DM_STRONG          (0x06u) /**< \brief Strong Drive            */
N#define DM_RES_UPDWN       (0x07u) /**< \brief Resistive Pull Up/Down  */ 
N
N#define FPC_WAKE_PIN       (5)
N#define BLE_WAKE_PIN       (4) 
N#define EXT_WAKE_PIN       (3) 
N#define KEY_WAKE_PIN       (2)
N
N#define SLOT_PIN           (3)
N#define LOCK_MODE_PIN      (2)
N#define LOCK_BNT_PIN       (1)
N
N#define SWD_DIO_PIN        (2)
N#define SWD_CLK_PIN        (3)
N       
W ".\Modules\Mcu\gpio.h" 62 6 Deprecated declaration GPIO_SaveStat - give arg types
Nvoid GPIO_SaveStat();//淇瀛GPIO濮舵瀵瀛ㄧ
N
W ".\Modules\Mcu\gpio.h" 64 6 Deprecated declaration GPIO_LoadStat - give arg types
Nvoid GPIO_LoadStat();//㈠GPIO瀵瀛ㄥ濮
N
W ".\Modules\Mcu\gpio.h" 66 6 Deprecated declaration GPIO_SleepSet - give arg types
Nvoid GPIO_SleepSet();//＄灏IOｈ剧疆楂荤舵
N
W ".\Modules\Mcu\gpio.h" 68 15 Deprecated declaration GPIO_GetRegData - give arg types
NpGPIO_REGDATA GPIO_GetRegData();
N
Nvoid GPIO_SetPinDriveMode(GPIO_TYPE type,PINS pin,uint8_t mode);
N
Nvoid GPIO_WritePin(GPIO_TYPE type,PINS pin,uint8_t val);
N
Nuint8_t GPIO_ReadPin(GPIO_TYPE type,PINS pin);
N
N#endif
W ".\Modules\Mcu\gpio.h" 77 5 last line of file ends without a newline
N    
L 49 ".\main.h" 2
N#endif
N
N
N
N
N#endif
N/* [] END OF FILE */
L 22 "Modules\Lock\lock_evt.h" 2
N
N
NErrorStatus LockEvt_Create(void (*pFun)(void), uint16_t timeMs);
Nvoid LockEvt_Clear(void);
Nvoid LockEvt_TimeUpdate(void);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__LOCK_EVT_H__ */
L 15 "Modules\Lock\lock_evt.c" 2
N
N#define EVENT_MAX_QTY  (5)
N
Nstatic __IO uint32_t timeBeatCount;//时间节拍
Xstatic volatile uint32_t timeBeatCount;
N
Nstatic struct
N{
N	void (*pFunction)(void);
N	uint32_t timeout;
N}eventList[EVENT_MAX_QTY]; //事件表
X}eventList[(5)]; 
N
Nstatic uint8_t mutexFlag;  //事件表访问互斥标志
N
N
N
N/**
N  * @brief  清除所有延时事件
N  *         
N  * @note   
N  */
Nvoid LockEvt_Clear(void)
N{
N	mutexFlag = 1;
N	
N	timeBeatCount = 0;
N	memset(eventList, 0, sizeof(eventList));
N	
N	mutexFlag = 0;
N}
N
N/**
N  * @brief  创建一个延时事件
N  * @note   
N  *         
N  * @param  pFun：事件处理函数
N  * @param  timeMs：延时时间MS
N  */
NErrorStatus LockEvt_Create(void (*pFun)(void), uint16_t timeMs)
N{
N	uint8_t i;
N	
N	mutexFlag = 1;
N
N	if (pFun == NULL)
X	if (pFun == 0)
N	{
N		mutexFlag = 0;
N		return ERROR;
N	}
N	
N	for (i=0; i<EVENT_MAX_QTY; i++)
X	for (i=0; i<(5); i++)
N	{
N		if (eventList[i].pFunction == NULL)
X		if (eventList[i].pFunction == 0)
N		{
N			break;
N		}
N	}
N	
N	if (i == EVENT_MAX_QTY)
X	if (i == (5))
N	{
N		mutexFlag = 0;
N		return ERROR;
N	}
N
N	eventList[i].timeout = timeMs + timeBeatCount;
N	eventList[i].pFunction = pFun;
N	
N	mutexFlag = 0;
N	return SUCCESS;
N}
N
N/**
N  * @brief  延时事件 时间更新函数
N  *         
N  * @note   该函数必须使用定时器中断每间隔2ms调用一次
N  */
Nvoid LockEvt_TimeUpdate(void)
N{
N	uint8_t i;
N	void (*pFun)(void);
N	
N	timeBeatCount += TIME_BASIC_MS;
X	timeBeatCount += 10;
N	
N	if (mutexFlag != 0)
N	{
N		return;
N	}
N	
N	for (i=0; i<EVENT_MAX_QTY; i++)
X	for (i=0; i<(5); i++)
N	{
N		if (eventList[i].pFunction != NULL && timeBeatCount > eventList[i].timeout)
X		if (eventList[i].pFunction != 0 && timeBeatCount > eventList[i].timeout)
N		{
N			pFun = eventList[i].pFunction;
N			
N			eventList[i].pFunction = NULL;
X			eventList[i].pFunction = 0;
N			eventList[i].timeout = 0;
N			
N			pFun();
N			break;
N		}
N	}
N}
N
